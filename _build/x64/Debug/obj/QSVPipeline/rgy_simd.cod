; Listing generated by Microsoft (R) Optimizing Compiler Version 19.23.28106.4 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?get_availableSIMD@@YAIXZ			; get_availableSIMD
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__security_cookie:QWORD
pdata	SEGMENT
$pdata$?get_availableSIMD@@YAIXZ DD imagerel $LN13
	DD	imagerel $LN13+499
	DD	imagerel $unwind$?get_availableSIMD@@YAIXZ
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
xdata	SEGMENT
$unwind$?get_availableSIMD@@YAIXZ DD 032519H
	DD	07003c207H
	DD	03002H
	DD	imagerel __GSHandlerCheck
	DD	058H
xdata	ENDS
CONST	SEGMENT
?get_availableSIMD@@YAIXZ$rtcName$0 DB 043H		; get_availableSIMD
	DB	050H
	DB	055H
	DB	049H
	DB	06eH
	DB	066H
	DB	06fH
	DB	00H
	ORG $+8
?get_availableSIMD@@YAIXZ$rtcVarDesc DD 028H		; get_availableSIMD
	DD	010H
	DQ	FLAT:?get_availableSIMD@@YAIXZ$rtcName$0
	ORG $+48
?get_availableSIMD@@YAIXZ$rtcFrameData DD 01H		; get_availableSIMD
	DD	00H
	DQ	FLAT:?get_availableSIMD@@YAIXZ$rtcVarDesc
CONST	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\rgy_simd.cpp
_TEXT	SEGMENT
CPUInfo$ = 40
simd$ = 68
xgetbv$ = 72
__$ArrayPad$ = 88
?get_availableSIMD@@YAIXZ PROC				; get_availableSIMD

; 37   : unsigned int get_availableSIMD() {

$LN13:
  00000	40 53		 push	 rbx
  00002	57		 push	 rdi
  00003	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00007	48 8b fc	 mov	 rdi, rsp
  0000a	b9 1a 00 00 00	 mov	 ecx, 26
  0000f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00014	f3 ab		 rep stosd
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 44 24 58	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 38   :     int CPUInfo[4];
; 39   :     __cpuid(CPUInfo, 1);

  00025	b8 01 00 00 00	 mov	 eax, 1
  0002a	33 c9		 xor	 ecx, ecx
  0002c	0f a2		 cpuid
  0002e	4c 8d 44 24 28	 lea	 r8, QWORD PTR CPUInfo$[rsp]
  00033	41 89 00	 mov	 DWORD PTR [r8], eax
  00036	41 89 58 04	 mov	 DWORD PTR [r8+4], ebx
  0003a	41 89 48 08	 mov	 DWORD PTR [r8+8], ecx
  0003e	41 89 50 0c	 mov	 DWORD PTR [r8+12], edx

; 40   :     uint32_t simd = NONE;

  00042	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR simd$[rsp], 0

; 41   :     if (CPUInfo[3] & 0x04000000) simd |= SSE2;

  0004a	b8 04 00 00 00	 mov	 eax, 4
  0004f	48 6b c0 03	 imul	 rax, rax, 3
  00053	8b 44 04 28	 mov	 eax, DWORD PTR CPUInfo$[rsp+rax]
  00057	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  0005c	85 c0		 test	 eax, eax
  0005e	74 0b		 je	 SHORT $LN2@get_availa
  00060	8b 44 24 44	 mov	 eax, DWORD PTR simd$[rsp]
  00064	83 c8 01	 or	 eax, 1
  00067	89 44 24 44	 mov	 DWORD PTR simd$[rsp], eax
$LN2@get_availa:

; 42   :     if (CPUInfo[2] & 0x00000001) simd |= SSE3;

  0006b	b8 04 00 00 00	 mov	 eax, 4
  00070	48 6b c0 02	 imul	 rax, rax, 2
  00074	8b 44 04 28	 mov	 eax, DWORD PTR CPUInfo$[rsp+rax]
  00078	83 e0 01	 and	 eax, 1
  0007b	85 c0		 test	 eax, eax
  0007d	74 0b		 je	 SHORT $LN3@get_availa
  0007f	8b 44 24 44	 mov	 eax, DWORD PTR simd$[rsp]
  00083	83 c8 02	 or	 eax, 2
  00086	89 44 24 44	 mov	 DWORD PTR simd$[rsp], eax
$LN3@get_availa:

; 43   :     if (CPUInfo[2] & 0x00000200) simd |= SSSE3;

  0008a	b8 04 00 00 00	 mov	 eax, 4
  0008f	48 6b c0 02	 imul	 rax, rax, 2
  00093	8b 44 04 28	 mov	 eax, DWORD PTR CPUInfo$[rsp+rax]
  00097	25 00 02 00 00	 and	 eax, 512		; 00000200H
  0009c	85 c0		 test	 eax, eax
  0009e	74 0b		 je	 SHORT $LN4@get_availa
  000a0	8b 44 24 44	 mov	 eax, DWORD PTR simd$[rsp]
  000a4	83 c8 04	 or	 eax, 4
  000a7	89 44 24 44	 mov	 DWORD PTR simd$[rsp], eax
$LN4@get_availa:

; 44   :     if (CPUInfo[2] & 0x00080000) simd |= SSE41;

  000ab	b8 04 00 00 00	 mov	 eax, 4
  000b0	48 6b c0 02	 imul	 rax, rax, 2
  000b4	8b 44 04 28	 mov	 eax, DWORD PTR CPUInfo$[rsp+rax]
  000b8	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  000bd	85 c0		 test	 eax, eax
  000bf	74 0b		 je	 SHORT $LN5@get_availa
  000c1	8b 44 24 44	 mov	 eax, DWORD PTR simd$[rsp]
  000c5	83 c8 08	 or	 eax, 8
  000c8	89 44 24 44	 mov	 DWORD PTR simd$[rsp], eax
$LN5@get_availa:

; 45   :     if (CPUInfo[2] & 0x00100000) simd |= SSE42;

  000cc	b8 04 00 00 00	 mov	 eax, 4
  000d1	48 6b c0 02	 imul	 rax, rax, 2
  000d5	8b 44 04 28	 mov	 eax, DWORD PTR CPUInfo$[rsp+rax]
  000d9	25 00 00 10 00	 and	 eax, 1048576		; 00100000H
  000de	85 c0		 test	 eax, eax
  000e0	74 0b		 je	 SHORT $LN6@get_availa
  000e2	8b 44 24 44	 mov	 eax, DWORD PTR simd$[rsp]
  000e6	83 c8 10	 or	 eax, 16
  000e9	89 44 24 44	 mov	 DWORD PTR simd$[rsp], eax
$LN6@get_availa:

; 46   :     if (CPUInfo[2] & 0x00800000) simd |= POPCNT;

  000ed	b8 04 00 00 00	 mov	 eax, 4
  000f2	48 6b c0 02	 imul	 rax, rax, 2
  000f6	8b 44 04 28	 mov	 eax, DWORD PTR CPUInfo$[rsp+rax]
  000fa	25 00 00 80 00	 and	 eax, 8388608		; 00800000H
  000ff	85 c0		 test	 eax, eax
  00101	74 0b		 je	 SHORT $LN7@get_availa
  00103	8b 44 24 44	 mov	 eax, DWORD PTR simd$[rsp]
  00107	83 c8 20	 or	 eax, 32			; 00000020H
  0010a	89 44 24 44	 mov	 DWORD PTR simd$[rsp], eax
$LN7@get_availa:

; 47   :     uint64_t xgetbv = 0;

  0010e	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR xgetbv$[rsp], 0

; 48   :     if ((CPUInfo[2] & 0x18000000) == 0x18000000) {

  00117	b8 04 00 00 00	 mov	 eax, 4
  0011c	48 6b c0 02	 imul	 rax, rax, 2
  00120	8b 44 04 28	 mov	 eax, DWORD PTR CPUInfo$[rsp+rax]
  00124	25 00 00 00 18	 and	 eax, 402653184		; 18000000H
  00129	3d 00 00 00 18	 cmp	 eax, 402653184		; 18000000H
  0012e	75 50		 jne	 SHORT $LN8@get_availa

; 49   :         xgetbv = _xgetbv(0);

  00130	33 c9		 xor	 ecx, ecx
  00132	0f 01 d0	 xgetbv
  00135	48 c1 e2 20	 shl	 rdx, 32			; 00000020H
  00139	48 0b d0	 or	 rdx, rax
  0013c	48 8b c2	 mov	 rax, rdx
  0013f	48 89 44 24 48	 mov	 QWORD PTR xgetbv$[rsp], rax

; 50   :         if ((xgetbv & 0x06) == 0x06)

  00144	48 8b 44 24 48	 mov	 rax, QWORD PTR xgetbv$[rsp]
  00149	48 83 e0 06	 and	 rax, 6
  0014d	48 83 f8 06	 cmp	 rax, 6
  00151	75 0b		 jne	 SHORT $LN9@get_availa

; 51   :             simd |= AVX;

  00153	8b 44 24 44	 mov	 eax, DWORD PTR simd$[rsp]
  00157	83 c8 40	 or	 eax, 64			; 00000040H
  0015a	89 44 24 44	 mov	 DWORD PTR simd$[rsp], eax
$LN9@get_availa:

; 52   :         if (CPUInfo[2] & 0x00001000)

  0015e	b8 04 00 00 00	 mov	 eax, 4
  00163	48 6b c0 02	 imul	 rax, rax, 2
  00167	8b 44 04 28	 mov	 eax, DWORD PTR CPUInfo$[rsp+rax]
  0016b	25 00 10 00 00	 and	 eax, 4096		; 00001000H
  00170	85 c0		 test	 eax, eax
  00172	74 0c		 je	 SHORT $LN10@get_availa

; 53   :             simd |= FMA3;

  00174	8b 44 24 44	 mov	 eax, DWORD PTR simd$[rsp]
  00178	0f ba e8 08	 bts	 eax, 8
  0017c	89 44 24 44	 mov	 DWORD PTR simd$[rsp], eax
$LN10@get_availa:
$LN8@get_availa:

; 54   :     }
; 55   :     __cpuid(CPUInfo, 7);

  00180	b8 07 00 00 00	 mov	 eax, 7
  00185	33 c9		 xor	 ecx, ecx
  00187	0f a2		 cpuid
  00189	4c 8d 44 24 28	 lea	 r8, QWORD PTR CPUInfo$[rsp]
  0018e	41 89 00	 mov	 DWORD PTR [r8], eax
  00191	41 89 58 04	 mov	 DWORD PTR [r8+4], ebx
  00195	41 89 48 08	 mov	 DWORD PTR [r8+8], ecx
  00199	41 89 50 0c	 mov	 DWORD PTR [r8+12], edx

; 56   :     if ((simd & AVX) && (CPUInfo[1] & 0x00000020))

  0019d	8b 44 24 44	 mov	 eax, DWORD PTR simd$[rsp]
  001a1	83 e0 40	 and	 eax, 64			; 00000040H
  001a4	85 c0		 test	 eax, eax
  001a6	74 20		 je	 SHORT $LN11@get_availa
  001a8	b8 04 00 00 00	 mov	 eax, 4
  001ad	48 6b c0 01	 imul	 rax, rax, 1
  001b1	8b 44 04 28	 mov	 eax, DWORD PTR CPUInfo$[rsp+rax]
  001b5	83 e0 20	 and	 eax, 32			; 00000020H
  001b8	85 c0		 test	 eax, eax
  001ba	74 0c		 je	 SHORT $LN11@get_availa

; 57   :         simd |= AVX2;

  001bc	8b 44 24 44	 mov	 eax, DWORD PTR simd$[rsp]
  001c0	0f ba e8 07	 bts	 eax, 7
  001c4	89 44 24 44	 mov	 DWORD PTR simd$[rsp], eax
$LN11@get_availa:

; 58   :     return simd;

  001c8	8b 44 24 44	 mov	 eax, DWORD PTR simd$[rsp]

; 59   : }

  001cc	8b f8		 mov	 edi, eax
  001ce	48 8b cc	 mov	 rcx, rsp
  001d1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?get_availableSIMD@@YAIXZ$rtcFrameData
  001d8	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  001dd	8b c7		 mov	 eax, edi
  001df	48 8b 4c 24 58	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001e4	48 33 cc	 xor	 rcx, rsp
  001e7	e8 00 00 00 00	 call	 __security_check_cookie
  001ec	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001f0	5f		 pop	 rdi
  001f1	5b		 pop	 rbx
  001f2	c3		 ret	 0
?get_availableSIMD@@YAIXZ ENDP				; get_availableSIMD
_TEXT	ENDS
END
