; Listing generated by Microsoft (R) Optimizing Compiler Version 19.23.28106.4 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
?ERR_MAP_MFX@@3QBURGYErrMapMFX@@B DD 00H		; ERR_MAP_MFX
	DD	00H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0fffffffeH
	DD	0fffffffeH
	DD	0fffffffdH
	DD	0fffffffdH
	DD	0fffffffcH
	DD	0fffffffcH
	DD	0fffffffbH
	DD	0fffffffbH
	DD	0fffffffaH
	DD	0fffffffaH
	DD	0fffffff9H
	DD	0fffffff9H
	DD	0fffffff8H
	DD	0fffffff8H
	DD	0fffffff7H
	DD	0fffffff7H
	DD	0fffffff6H
	DD	0fffffff6H
	DD	0fffffff5H
	DD	0fffffff5H
	DD	0fffffff4H
	DD	0fffffff4H
	DD	0fffffff3H
	DD	0fffffff3H
	DD	0fffffff2H
	DD	0fffffff2H
	DD	0fffffff1H
	DD	0fffffff1H
	DD	0fffffff0H
	DD	0fffffff0H
	DD	0ffffffefH
	DD	0ffffffefH
	DD	0ffffffeeH
	DD	0ffffffeeH
	DD	0ffffffedH
	DD	0ffffffedH
	DD	0ffffffecH
	DD	0ffffffecH
	DD	0ffffffebH
	DD	0ffffffebH
	DD	0ffffffeaH
	DD	0ffffffeaH
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	03H
	DD	03H
	DD	04H
	DD	04H
	DD	05H
	DD	05H
	DD	06H
	DD	06H
	DD	07H
	DD	07H
	DD	0aH
	DD	0aH
	DD	0bH
	DD	0bH
	DD	0ffffd8f0H
	DD	0ffffd8f0H
$SG58888 DB	'no error.', 00H
	ORG $+6
$SG58890 DB	'unknown error.', 00H
	ORG $+1
$SG58892 DB	'null pointer.', 00H
	ORG $+2
$SG58894 DB	'undeveloped feature.', 00H
	ORG $+3
$SG58896 DB	'failed to allocate memory.', 00H
	ORG $+5
$SG58898 DB	'insufficient buffer at input/output.', 00H
	ORG $+3
$SG58900 DB	'invalid handle.', 00H
$SG58902 DB	'failed to lock the memory block.', 00H
	ORG $+7
$SG58904 DB	'member function called before initialization.', 00H
	ORG $+2
$SG58906 DB	'the specified object is not found.', 00H
	ORG $+5
$SG58908 DB	'expect more data at input.', 00H
	ORG $+5
$SG58910 DB	'expect more surface at output.', 00H
	ORG $+1
$SG58912 DB	'operation aborted.', 00H
	ORG $+5
$SG58914 DB	'lose the HW acceleration device.', 00H
	ORG $+7
$SG58916 DB	'incompatible video parameters.', 00H
	ORG $+1
$SG58918 DB	'invalid video parameters.', 00H
	ORG $+6
$SG58920 DB	'undefined behavior.', 00H
	ORG $+4
$SG58922 DB	'device operation failure.', 00H
	ORG $+6
$SG58924 DB	'gpu hang.', 00H
	ORG $+6
$SG58926 DB	'failed to realloc surface.', 00H
	ORG $+5
$SG58928 DB	'access denied', 00H
	ORG $+2
$SG58930 DB	'invalid param.', 00H
	ORG $+1
$SG58932 DB	'out pf range.', 00H
	ORG $+2
$SG58934 DB	'already initialized.', 00H
	ORG $+3
$SG58936 DB	'invalid format.', 00H
$SG58938 DB	'wrong state.', 00H
	ORG $+3
$SG58940 DB	'file open error.', 00H
	ORG $+7
$SG58942 DB	'input full.', 00H
	ORG $+4
$SG58944 DB	'invalid codec.', 00H
	ORG $+1
$SG58946 DB	'invalid data type.', 00H
	ORG $+5
$SG58948 DB	'invaldi resolution.', 00H
	ORG $+4
$SG58950 DB	'invalid devices.', 00H
	ORG $+7
$SG58952 DB	'invalid call sequence.', 00H
	ORG $+1
$SG58954 DB	'no deivce found.', 00H
	ORG $+7
$SG58956 DB	'invalid version.', 00H
	ORG $+7
$SG58958 DB	'map failed.', 00H
	ORG $+4
$SG58960 DB	'error in cuda.', 00H
	ORG $+1
$SG58962 DB	'running process failed.', 00H
$SG58964 DB	'the previous asynchrous operation is in execution.', 00H
	ORG $+5
$SG58966 DB	'the HW acceleration device is busy.', 00H
	ORG $+4
$SG58968 DB	'the video parameters are changed during decoding.', 00H
	ORG $+6
$SG58970 DB	'SW is used.', 00H
	ORG $+4
$SG58972 DB	'incompatible video parameters.', 00H
	ORG $+1
$SG58974 DB	'the value is saturated based on its valid range.', 00H
	ORG $+7
$SG58976 DB	'the value is out of valid range.', 00H
	ORG $+7
$SG58978 DB	'unknown error.', 00H
CONST	ENDS
PUBLIC	?err_to_mfx@@YA?AW4mfxStatus@@W4RGY_ERR@@@Z	; err_to_mfx
PUBLIC	?err_to_rgy@@YA?AW4RGY_ERR@@W4mfxStatus@@@Z	; err_to_rgy
PUBLIC	?get_err_mes@@YAPEBDW4RGY_ERR@@@Z		; get_err_mes
PUBLIC	??$_Adl_verify_range@PEBURGYErrMapMFX@@PEBU1@@std@@YAXAEBQEBURGYErrMapMFX@@0@Z ; std::_Adl_verify_range<RGYErrMapMFX const *,RGYErrMapMFX const *>
PUBLIC	??$_Get_unwrapped@$$CBURGYErrMapMFX@@@std@@YAPEBURGYErrMapMFX@@QEBU1@@Z ; std::_Get_unwrapped<RGYErrMapMFX const >
PUBLIC	??$_Seek_wrapped@$$CBURGYErrMapMFX@@@std@@YAXAEAPEBURGYErrMapMFX@@QEBU1@@Z ; std::_Seek_wrapped<RGYErrMapMFX const >
PUBLIC	??$_Verify_range@URGYErrMapMFX@@@std@@YAXQEBURGYErrMapMFX@@0@Z ; std::_Verify_range<RGYErrMapMFX>
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_0BJ@HAJGEHKO@transposed?5pointer?5range@	; `string'
PUBLIC	??_C@_0GJ@GDKIGMBO@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ ; `string'
PUBLIC	??_C@_1NC@OIIHGCJJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_1CG@LJCPDKEJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAr?$AAi?$AAf?$AAy?$AA_?$AAr?$AAa@ ; `string'
PUBLIC	??_C@_1DG@FJIKMGFD@?$AA?$CC?$AAt?$AAr?$AAa?$AAn?$AAs?$AAp?$AAo?$AAs?$AAe?$AAd?$AA?5?$AAp?$AAo?$AAi@ ; `string'
EXTRN	__imp__invalid_parameter:PROC
EXTRN	__imp__CrtDbgReport:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__CxxFrameHandler4:PROC
EXTRN	__ImageBase:BYTE
pdata	SEGMENT
$pdata$?err_to_mfx@@YA?AW4mfxStatus@@W4RGY_ERR@@@Z DD imagerel $LN5
	DD	imagerel $LN5+130
	DD	imagerel $unwind$?err_to_mfx@@YA?AW4mfxStatus@@W4RGY_ERR@@@Z
$pdata$?err_to_rgy@@YA?AW4RGY_ERR@@W4mfxStatus@@@Z DD imagerel $LN5
	DD	imagerel $LN5+129
	DD	imagerel $unwind$?err_to_rgy@@YA?AW4RGY_ERR@@W4mfxStatus@@@Z
$pdata$?get_err_mes@@YAPEBDW4RGY_ERR@@@Z DD imagerel $LN52
	DD	imagerel $LN52+780
	DD	imagerel $unwind$?get_err_mes@@YAPEBDW4RGY_ERR@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_7ea49bb70acf995ee16f3b0e1ba77072>@@QEBA_NURGYErrMapMFX@@@Z DD imagerel ??R<lambda_7ea49bb70acf995ee16f3b0e1ba77072>@@QEBA_NURGYErrMapMFX@@@Z
	DD	imagerel ??R<lambda_7ea49bb70acf995ee16f3b0e1ba77072>@@QEBA_NURGYErrMapMFX@@@Z+74
	DD	imagerel $unwind$??R<lambda_7ea49bb70acf995ee16f3b0e1ba77072>@@QEBA_NURGYErrMapMFX@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0<lambda_7ea49bb70acf995ee16f3b0e1ba77072>@@QEAA@AEBW4RGY_ERR@@@Z DD imagerel ??0<lambda_7ea49bb70acf995ee16f3b0e1ba77072>@@QEAA@AEBW4RGY_ERR@@@Z
	DD	imagerel ??0<lambda_7ea49bb70acf995ee16f3b0e1ba77072>@@QEAA@AEBW4RGY_ERR@@@Z+32
	DD	imagerel $unwind$??0<lambda_7ea49bb70acf995ee16f3b0e1ba77072>@@QEAA@AEBW4RGY_ERR@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$find_if@PEBURGYErrMapMFX@@V<lambda_7ea49bb70acf995ee16f3b0e1ba77072>@@@std@@YAPEBURGYErrMapMFX@@PEBU1@QEBU1@V<lambda_7ea49bb70acf995ee16f3b0e1ba77072>@@@Z DD imagerel ??$find_if@PEBURGYErrMapMFX@@V<lambda_7ea49bb70acf995ee16f3b0e1ba77072>@@@std@@YAPEBURGYErrMapMFX@@PEBU1@QEBU1@V<lambda_7ea49bb70acf995ee16f3b0e1ba77072>@@@Z
	DD	imagerel ??$find_if@PEBURGYErrMapMFX@@V<lambda_7ea49bb70acf995ee16f3b0e1ba77072>@@@std@@YAPEBURGYErrMapMFX@@PEBU1@QEBU1@V<lambda_7ea49bb70acf995ee16f3b0e1ba77072>@@@Z+168
	DD	imagerel $unwind$??$find_if@PEBURGYErrMapMFX@@V<lambda_7ea49bb70acf995ee16f3b0e1ba77072>@@@std@@YAPEBURGYErrMapMFX@@PEBU1@QEBU1@V<lambda_7ea49bb70acf995ee16f3b0e1ba77072>@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_dabac589461c7a2e6e1fe7373c988653>@@QEBA_NURGYErrMapMFX@@@Z DD imagerel ??R<lambda_dabac589461c7a2e6e1fe7373c988653>@@QEBA_NURGYErrMapMFX@@@Z
	DD	imagerel ??R<lambda_dabac589461c7a2e6e1fe7373c988653>@@QEBA_NURGYErrMapMFX@@@Z+74
	DD	imagerel $unwind$??R<lambda_dabac589461c7a2e6e1fe7373c988653>@@QEBA_NURGYErrMapMFX@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0<lambda_dabac589461c7a2e6e1fe7373c988653>@@QEAA@AEBW4mfxStatus@@@Z DD imagerel ??0<lambda_dabac589461c7a2e6e1fe7373c988653>@@QEAA@AEBW4mfxStatus@@@Z
	DD	imagerel ??0<lambda_dabac589461c7a2e6e1fe7373c988653>@@QEAA@AEBW4mfxStatus@@@Z+32
	DD	imagerel $unwind$??0<lambda_dabac589461c7a2e6e1fe7373c988653>@@QEAA@AEBW4mfxStatus@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$find_if@PEBURGYErrMapMFX@@V<lambda_dabac589461c7a2e6e1fe7373c988653>@@@std@@YAPEBURGYErrMapMFX@@PEBU1@QEBU1@V<lambda_dabac589461c7a2e6e1fe7373c988653>@@@Z DD imagerel ??$find_if@PEBURGYErrMapMFX@@V<lambda_dabac589461c7a2e6e1fe7373c988653>@@@std@@YAPEBURGYErrMapMFX@@PEBU1@QEBU1@V<lambda_dabac589461c7a2e6e1fe7373c988653>@@@Z
	DD	imagerel ??$find_if@PEBURGYErrMapMFX@@V<lambda_dabac589461c7a2e6e1fe7373c988653>@@@std@@YAPEBURGYErrMapMFX@@PEBU1@QEBU1@V<lambda_dabac589461c7a2e6e1fe7373c988653>@@@Z+168
	DD	imagerel $unwind$??$find_if@PEBURGYErrMapMFX@@V<lambda_dabac589461c7a2e6e1fe7373c988653>@@@std@@YAPEBURGYErrMapMFX@@PEBU1@QEBU1@V<lambda_dabac589461c7a2e6e1fe7373c988653>@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Adl_verify_range@PEBURGYErrMapMFX@@PEBU1@@std@@YAXAEBQEBURGYErrMapMFX@@0@Z DD imagerel $LN3
	DD	imagerel $LN3+62
	DD	imagerel $unwind$??$_Adl_verify_range@PEBURGYErrMapMFX@@PEBU1@@std@@YAXAEBQEBURGYErrMapMFX@@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_unwrapped@$$CBURGYErrMapMFX@@@std@@YAPEBURGYErrMapMFX@@QEBU1@@Z DD imagerel $LN3
	DD	imagerel $LN3+13
	DD	imagerel $unwind$??$_Get_unwrapped@$$CBURGYErrMapMFX@@@std@@YAPEBURGYErrMapMFX@@QEBU1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Seek_wrapped@$$CBURGYErrMapMFX@@@std@@YAXAEAPEBURGYErrMapMFX@@QEBU1@@Z DD imagerel $LN3
	DD	imagerel $LN3+26
	DD	imagerel $unwind$??$_Seek_wrapped@$$CBURGYErrMapMFX@@@std@@YAXAEAPEBURGYErrMapMFX@@QEBU1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Verify_range@URGYErrMapMFX@@@std@@YAXQEBURGYErrMapMFX@@0@Z DD imagerel $LN12
	DD	imagerel $LN12+174
	DD	imagerel $unwind$??$_Verify_range@URGYErrMapMFX@@@std@@YAXQEBURGYErrMapMFX@@0@Z
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_1DG@FJIKMGFD@?$AA?$CC?$AAt?$AAr?$AAa?$AAn?$AAs?$AAp?$AAo?$AAs?$AAe?$AAd?$AA?5?$AAp?$AAo?$AAi@
CONST	SEGMENT
??_C@_1DG@FJIKMGFD@?$AA?$CC?$AAt?$AAr?$AAa?$AAn?$AAs?$AAp?$AAo?$AAs?$AAe?$AAd?$AA?5?$AAp?$AAo?$AAi@ DB '"'
	DB	00H, 't', 00H, 'r', 00H, 'a', 00H, 'n', 00H, 's', 00H, 'p', 00H
	DB	'o', 00H, 's', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 'p', 00H, 'o'
	DB	00H, 'i', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, ' ', 00H
	DB	'r', 00H, 'a', 00H, 'n', 00H, 'g', 00H, 'e', 00H, '"', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@LJCPDKEJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAr?$AAi?$AAf?$AAy?$AA_?$AAr?$AAa@
CONST	SEGMENT
??_C@_1CG@LJCPDKEJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAr?$AAi?$AAf?$AAy?$AA_?$AAr?$AAa@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'e', 00H, 'r', 00H, 'i', 00H, 'f', 00H, 'y', 00H, '_', 00H, 'r'
	DB	00H, 'a', 00H, 'n', 00H, 'g', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1NC@OIIHGCJJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
CONST	SEGMENT
??_C@_1NC@OIIHGCJJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ DB 'C'
	DB	00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'F', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'V', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	'\', 00H, '2', 00H, '0', 00H, '1', 00H, '9', 00H, '\', 00H, 'C'
	DB	00H, 'o', 00H, 'm', 00H, 'm', 00H, 'u', 00H, 'n', 00H, 'i', 00H
	DB	't', 00H, 'y', 00H, '\', 00H, 'V', 00H, 'C', 00H, '\', 00H, 'T'
	DB	00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '\', 00H, 'M', 00H
	DB	'S', 00H, 'V', 00H, 'C', 00H, '\', 00H, '1', 00H, '4', 00H, '.'
	DB	00H, '2', 00H, '3', 00H, '.', 00H, '2', 00H, '8', 00H, '1', 00H
	DB	'0', 00H, '5', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l'
	DB	00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H, 'u', 00H
	DB	't', 00H, 'i', 00H, 'l', 00H, 'i', 00H, 't', 00H, 'y', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0GJ@GDKIGMBO@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
CONST	SEGMENT
??_C@_0GJ@GDKIGMBO@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ DB 'C:\Pro'
	DB	'gram Files (x86)\Microsoft Visual Studio\2019\Community\VC\To'
	DB	'ols\MSVC\14.23.28105\include\xutility', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HAJGEHKO@transposed?5pointer?5range@
CONST	SEGMENT
??_C@_0BJ@HAJGEHKO@transposed?5pointer?5range@ DB 'transposed pointer ran'
	DB	'ge', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Verify_range@URGYErrMapMFX@@@std@@YAXQEBURGYErrMapMFX@@0@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Verify_range@URGYErrMapMFX@@@std@@YAXQEBURGYErrMapMFX@@0@Z DB 040H
	DD	imagerel $ip2state$??$_Verify_range@URGYErrMapMFX@@@std@@YAXQEBURGYErrMapMFX@@0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Verify_range@URGYErrMapMFX@@@std@@YAXQEBURGYErrMapMFX@@0@Z DD 022319H
	DD	0700b520fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Verify_range@URGYErrMapMFX@@@std@@YAXQEBURGYErrMapMFX@@0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Seek_wrapped@$$CBURGYErrMapMFX@@@std@@YAXAEAPEBURGYErrMapMFX@@QEBU1@@Z DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_unwrapped@$$CBURGYErrMapMFX@@@std@@YAPEBURGYErrMapMFX@@QEBU1@@Z DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Adl_verify_range@PEBURGYErrMapMFX@@PEBU1@@std@@YAXAEBQEBURGYErrMapMFX@@0@Z DD 022301H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$find_if@PEBURGYErrMapMFX@@V<lambda_dabac589461c7a2e6e1fe7373c988653>@@@std@@YAPEBURGYErrMapMFX@@PEBU1@QEBU1@V<lambda_dabac589461c7a2e6e1fe7373c988653>@@@Z DD 022801H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0<lambda_dabac589461c7a2e6e1fe7373c988653>@@QEAA@AEBW4mfxStatus@@@Z DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_dabac589461c7a2e6e1fe7373c988653>@@QEBA_NURGYErrMapMFX@@@Z DD 022301H
	DD	0700b120fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$find_if@PEBURGYErrMapMFX@@V<lambda_7ea49bb70acf995ee16f3b0e1ba77072>@@@std@@YAPEBURGYErrMapMFX@@PEBU1@QEBU1@V<lambda_7ea49bb70acf995ee16f3b0e1ba77072>@@@Z DD 022801H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0<lambda_7ea49bb70acf995ee16f3b0e1ba77072>@@QEAA@AEBW4RGY_ERR@@@Z DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_7ea49bb70acf995ee16f3b0e1ba77072>@@QEBA_NURGYErrMapMFX@@@Z DD 022301H
	DD	0700b120fH
xdata	ENDS
xdata	SEGMENT
$unwind$?err_to_mfx@@YA?AW4mfxStatus@@W4RGY_ERR@@@Z DD 021c01H
	DD	070057209H
$unwind$?err_to_rgy@@YA?AW4RGY_ERR@@W4mfxStatus@@@Z DD 021c01H
	DD	070057209H
$unwind$?get_err_mes@@YAPEBDW4RGY_ERR@@@Z DD 021c01H
	DD	070051209H
xdata	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xutility
;	COMDAT ??$_Verify_range@URGYErrMapMFX@@@std@@YAXQEBURGYErrMapMFX@@0@Z
_TEXT	SEGMENT
_First$ = 64
_Last$ = 72
??$_Verify_range@URGYErrMapMFX@@@std@@YAXQEBURGYErrMapMFX@@0@Z PROC ; std::_Verify_range<RGYErrMapMFX>, COMDAT

; 191  :     const _Ty* const _First, const _Ty* const _Last) noexcept { // special case range verification for pointers

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 0c 00 00 00	 mov	 ecx, 12
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]
$LN4@Verify_ran:

; 192  :     _STL_VERIFY(_First <= _Last, "transposed pointer range");

  00023	48 8b 44 24 48	 mov	 rax, QWORD PTR _Last$[rsp]
  00028	48 39 44 24 40	 cmp	 QWORD PTR _First$[rsp], rax
  0002d	77 02		 ja	 SHORT $LN7@Verify_ran
  0002f	eb 6d		 jmp	 SHORT $LN9@Verify_ran
$LN7@Verify_ran:
  00031	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BJ@HAJGEHKO@transposed?5pointer?5range@
  00038	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0003d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
  00044	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00049	45 33 c9	 xor	 r9d, r9d
  0004c	41 b8 c0 00 00
	00		 mov	 r8d, 192		; 000000c0H
  00052	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GJ@GDKIGMBO@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
  00059	b9 02 00 00 00	 mov	 ecx, 2
  0005e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__CrtDbgReport
  00064	90		 npad	 1
  00065	83 f8 01	 cmp	 eax, 1
  00068	75 03		 jne	 SHORT $LN11@Verify_ran
  0006a	cc		 int	 3
  0006b	33 c0		 xor	 eax, eax
$LN11@Verify_ran:
  0006d	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00076	41 b9 c0 00 00
	00		 mov	 r9d, 192		; 000000c0H
  0007c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_1NC@OIIHGCJJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  00083	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CG@LJCPDKEJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAr?$AAi?$AAf?$AAy?$AA_?$AAr?$AAa@
  0008a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DG@FJIKMGFD@?$AA?$CC?$AAt?$AAr?$AAa?$AAn?$AAs?$AAp?$AAo?$AAs?$AAe?$AAd?$AA?5?$AAp?$AAo?$AAi@
  00091	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter
  00097	90		 npad	 1
  00098	33 c0		 xor	 eax, eax
  0009a	85 c0		 test	 eax, eax
  0009c	75 93		 jne	 SHORT $LN7@Verify_ran
$LN9@Verify_ran:
  0009e	33 c0		 xor	 eax, eax
  000a0	85 c0		 test	 eax, eax
  000a2	0f 85 7b ff ff
	ff		 jne	 $LN4@Verify_ran

; 193  : }

  000a8	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ac	5f		 pop	 rdi
  000ad	c3		 ret	 0
??$_Verify_range@URGYErrMapMFX@@@std@@YAXQEBURGYErrMapMFX@@0@Z ENDP ; std::_Verify_range<RGYErrMapMFX>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xutility
;	COMDAT ??$_Seek_wrapped@$$CBURGYErrMapMFX@@@std@@YAXAEAPEBURGYErrMapMFX@@QEBU1@@Z
_TEXT	SEGMENT
_It$ = 16
_UIt$ = 24
??$_Seek_wrapped@$$CBURGYErrMapMFX@@@std@@YAXAEAPEBURGYErrMapMFX@@QEBU1@@Z PROC ; std::_Seek_wrapped<RGYErrMapMFX const >, COMDAT

; 435  : constexpr void _Seek_wrapped(_Ty*& _It, _Ty* const _UIt) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi

; 436  :     _It = _UIt;

  0000b	48 8b 44 24 10	 mov	 rax, QWORD PTR _It$[rsp]
  00010	48 8b 4c 24 18	 mov	 rcx, QWORD PTR _UIt$[rsp]
  00015	48 89 08	 mov	 QWORD PTR [rax], rcx

; 437  : }

  00018	5f		 pop	 rdi
  00019	c3		 ret	 0
??$_Seek_wrapped@$$CBURGYErrMapMFX@@@std@@YAXAEAPEBURGYErrMapMFX@@QEBU1@@Z ENDP ; std::_Seek_wrapped<RGYErrMapMFX const >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xutility
;	COMDAT ??$_Get_unwrapped@$$CBURGYErrMapMFX@@@std@@YAPEBURGYErrMapMFX@@QEBU1@@Z
_TEXT	SEGMENT
_Ptr$ = 16
??$_Get_unwrapped@$$CBURGYErrMapMFX@@@std@@YAPEBURGYErrMapMFX@@QEBU1@@Z PROC ; std::_Get_unwrapped<RGYErrMapMFX const >, COMDAT

; 275  : _NODISCARD constexpr _Ty* _Get_unwrapped(_Ty* const _Ptr) { // special case already-unwrapped pointers

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi

; 276  :     return _Ptr;

  00006	48 8b 44 24 10	 mov	 rax, QWORD PTR _Ptr$[rsp]

; 277  : }

  0000b	5f		 pop	 rdi
  0000c	c3		 ret	 0
??$_Get_unwrapped@$$CBURGYErrMapMFX@@@std@@YAPEBURGYErrMapMFX@@QEBU1@@Z ENDP ; std::_Get_unwrapped<RGYErrMapMFX const >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xutility
;	COMDAT ??$_Adl_verify_range@PEBURGYErrMapMFX@@PEBU1@@std@@YAXAEBQEBURGYErrMapMFX@@0@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
??$_Adl_verify_range@PEBURGYErrMapMFX@@PEBU1@@std@@YAXAEBQEBURGYErrMapMFX@@0@Z PROC ; std::_Adl_verify_range<RGYErrMapMFX const *,RGYErrMapMFX const *>, COMDAT

; 217  :     const _Iter& _First, const _Sentinel& _Last) { // check that [_First, _Last) forms an iterator range

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 08 00 00 00	 mov	 ecx, 8
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 218  :     if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 219  :         _Verify_range(_First, _Last);

  00023	48 8b 44 24 38	 mov	 rax, QWORD PTR _Last$[rsp]
  00028	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  0002b	48 8b 44 24 30	 mov	 rax, QWORD PTR _First$[rsp]
  00030	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00033	e8 00 00 00 00	 call	 ??$_Verify_range@URGYErrMapMFX@@@std@@YAXQEBURGYErrMapMFX@@0@Z ; std::_Verify_range<RGYErrMapMFX>

; 220  :     } else {
; 221  :         (void) _First; // TRANSITION, VSO#486357
; 222  :         (void) _Last; // TRANSITION, VSO#486357
; 223  :     }
; 224  : }

  00038	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003c	5f		 pop	 rdi
  0003d	c3		 ret	 0
??$_Adl_verify_range@PEBURGYErrMapMFX@@PEBU1@@std@@YAXAEBQEBURGYErrMapMFX@@0@Z ENDP ; std::_Adl_verify_range<RGYErrMapMFX const *,RGYErrMapMFX const *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\algorithm
;	COMDAT ??$find_if@PEBURGYErrMapMFX@@V<lambda_dabac589461c7a2e6e1fe7373c988653>@@@std@@YAPEBURGYErrMapMFX@@PEBU1@QEBU1@V<lambda_dabac589461c7a2e6e1fe7373c988653>@@@Z
_TEXT	SEGMENT
_UFirst$ = 32
_ULast$ = 40
_First$ = 64
_Last$ = 72
_Pred$ = 80
??$find_if@PEBURGYErrMapMFX@@V<lambda_dabac589461c7a2e6e1fe7373c988653>@@@std@@YAPEBURGYErrMapMFX@@PEBU1@QEBU1@V<lambda_dabac589461c7a2e6e1fe7373c988653>@@@Z PROC ; std::find_if<RGYErrMapMFX const *,<lambda_dabac589461c7a2e6e1fe7373c988653> >, COMDAT

; 138  : _NODISCARD _InIt find_if(_InIt _First, const _InIt _Last, _Pr _Pred) { // find first satisfying _Pred

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 0c 00 00 00	 mov	 ecx, 12
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 139  :     _Adl_verify_range(_First, _Last);

  00028	48 8d 54 24 48	 lea	 rdx, QWORD PTR _Last$[rsp]
  0002d	48 8d 4c 24 40	 lea	 rcx, QWORD PTR _First$[rsp]
  00032	e8 00 00 00 00	 call	 ??$_Adl_verify_range@PEBURGYErrMapMFX@@PEBU1@@std@@YAXAEBQEBURGYErrMapMFX@@0@Z ; std::_Adl_verify_range<RGYErrMapMFX const *,RGYErrMapMFX const *>

; 140  :     auto _UFirst      = _Get_unwrapped(_First);

  00037	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _First$[rsp]
  0003c	e8 00 00 00 00	 call	 ??$_Get_unwrapped@$$CBURGYErrMapMFX@@@std@@YAPEBURGYErrMapMFX@@QEBU1@@Z ; std::_Get_unwrapped<RGYErrMapMFX const >
  00041	48 89 44 24 20	 mov	 QWORD PTR _UFirst$[rsp], rax

; 141  :     const auto _ULast = _Get_unwrapped(_Last);

  00046	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _Last$[rsp]
  0004b	e8 00 00 00 00	 call	 ??$_Get_unwrapped@$$CBURGYErrMapMFX@@@std@@YAPEBURGYErrMapMFX@@QEBU1@@Z ; std::_Get_unwrapped<RGYErrMapMFX const >
  00050	48 89 44 24 28	 mov	 QWORD PTR _ULast$[rsp], rax

; 142  :     for (; _UFirst != _ULast; ++_UFirst) {

  00055	eb 0e		 jmp	 SHORT $LN4@find_if
$LN2@find_if:
  00057	48 8b 44 24 20	 mov	 rax, QWORD PTR _UFirst$[rsp]
  0005c	48 83 c0 08	 add	 rax, 8
  00060	48 89 44 24 20	 mov	 QWORD PTR _UFirst$[rsp], rax
$LN4@find_if:
  00065	48 8b 44 24 28	 mov	 rax, QWORD PTR _ULast$[rsp]
  0006a	48 39 44 24 20	 cmp	 QWORD PTR _UFirst$[rsp], rax
  0006f	74 1d		 je	 SHORT $LN3@find_if

; 143  :         if (_Pred(*_UFirst)) {

  00071	48 8b 44 24 20	 mov	 rax, QWORD PTR _UFirst$[rsp]
  00076	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00079	48 8d 4c 24 50	 lea	 rcx, QWORD PTR _Pred$[rsp]
  0007e	e8 00 00 00 00	 call	 ??R<lambda_dabac589461c7a2e6e1fe7373c988653>@@QEBA_NURGYErrMapMFX@@@Z ; <lambda_dabac589461c7a2e6e1fe7373c988653>::operator()
  00083	0f b6 c0	 movzx	 eax, al
  00086	85 c0		 test	 eax, eax
  00088	74 02		 je	 SHORT $LN5@find_if

; 144  :             break;

  0008a	eb 02		 jmp	 SHORT $LN3@find_if
$LN5@find_if:

; 145  :         }
; 146  :     }

  0008c	eb c9		 jmp	 SHORT $LN2@find_if
$LN3@find_if:

; 147  : 
; 148  :     _Seek_wrapped(_First, _UFirst);

  0008e	48 8b 54 24 20	 mov	 rdx, QWORD PTR _UFirst$[rsp]
  00093	48 8d 4c 24 40	 lea	 rcx, QWORD PTR _First$[rsp]
  00098	e8 00 00 00 00	 call	 ??$_Seek_wrapped@$$CBURGYErrMapMFX@@@std@@YAXAEAPEBURGYErrMapMFX@@QEBU1@@Z ; std::_Seek_wrapped<RGYErrMapMFX const >

; 149  :     return _First;

  0009d	48 8b 44 24 40	 mov	 rax, QWORD PTR _First$[rsp]

; 150  : }

  000a2	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a6	5f		 pop	 rdi
  000a7	c3		 ret	 0
??$find_if@PEBURGYErrMapMFX@@V<lambda_dabac589461c7a2e6e1fe7373c988653>@@@std@@YAPEBURGYErrMapMFX@@PEBU1@QEBU1@V<lambda_dabac589461c7a2e6e1fe7373c988653>@@@Z ENDP ; std::find_if<RGYErrMapMFX const *,<lambda_dabac589461c7a2e6e1fe7373c988653> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\rgy_err.cpp
;	COMDAT ??0<lambda_dabac589461c7a2e6e1fe7373c988653>@@QEAA@AEBW4mfxStatus@@@Z
_TEXT	SEGMENT
this$ = 16
<err>$ = 24
??0<lambda_dabac589461c7a2e6e1fe7373c988653>@@QEAA@AEBW4mfxStatus@@@Z PROC ; <lambda_dabac589461c7a2e6e1fe7373c988653>::<lambda_dabac589461c7a2e6e1fe7373c988653>, COMDAT

; 89   :     });

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 8b 44 24 10	 mov	 rax, QWORD PTR this$[rsp]
  00010	48 8b 4c 24 18	 mov	 rcx, QWORD PTR <err>$[rsp]
  00015	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00017	89 08		 mov	 DWORD PTR [rax], ecx
  00019	48 8b 44 24 10	 mov	 rax, QWORD PTR this$[rsp]
  0001e	5f		 pop	 rdi
  0001f	c3		 ret	 0
??0<lambda_dabac589461c7a2e6e1fe7373c988653>@@QEAA@AEBW4mfxStatus@@@Z ENDP ; <lambda_dabac589461c7a2e6e1fe7373c988653>::<lambda_dabac589461c7a2e6e1fe7373c988653>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\rgy_err.cpp
;	COMDAT ??R<lambda_dabac589461c7a2e6e1fe7373c988653>@@QEBA_NURGYErrMapMFX@@@Z
_TEXT	SEGMENT
tv66 = 0
this$ = 32
map$ = 40
??R<lambda_dabac589461c7a2e6e1fe7373c988653>@@QEBA_NURGYErrMapMFX@@@Z PROC ; <lambda_dabac589461c7a2e6e1fe7373c988653>::operator(), COMDAT

; 87   :     auto ret = std::find_if((const RGYErrMapMFX *)ERR_MAP_MFX, ERR_MAP_FIN, [err](RGYErrMapMFX map) {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 10	 sub	 rsp, 16
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 04 00 00 00	 mov	 ecx, 4
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR [rsp+32]

; 88   :         return map.mfx == err;

  00023	48 8b 44 24 20	 mov	 rax, QWORD PTR this$[rsp]
  00028	8b 00		 mov	 eax, DWORD PTR [rax]
  0002a	39 44 24 2c	 cmp	 DWORD PTR map$[rsp+4], eax
  0002e	75 09		 jne	 SHORT $LN3@operator
  00030	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv66[rsp], 1
  00037	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00039	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv66[rsp], 0
$LN4@operator:
  00040	0f b6 04 24	 movzx	 eax, BYTE PTR tv66[rsp]

; 89   :     });

  00044	48 83 c4 10	 add	 rsp, 16
  00048	5f		 pop	 rdi
  00049	c3		 ret	 0
??R<lambda_dabac589461c7a2e6e1fe7373c988653>@@QEBA_NURGYErrMapMFX@@@Z ENDP ; <lambda_dabac589461c7a2e6e1fe7373c988653>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\algorithm
;	COMDAT ??$find_if@PEBURGYErrMapMFX@@V<lambda_7ea49bb70acf995ee16f3b0e1ba77072>@@@std@@YAPEBURGYErrMapMFX@@PEBU1@QEBU1@V<lambda_7ea49bb70acf995ee16f3b0e1ba77072>@@@Z
_TEXT	SEGMENT
_UFirst$ = 32
_ULast$ = 40
_First$ = 64
_Last$ = 72
_Pred$ = 80
??$find_if@PEBURGYErrMapMFX@@V<lambda_7ea49bb70acf995ee16f3b0e1ba77072>@@@std@@YAPEBURGYErrMapMFX@@PEBU1@QEBU1@V<lambda_7ea49bb70acf995ee16f3b0e1ba77072>@@@Z PROC ; std::find_if<RGYErrMapMFX const *,<lambda_7ea49bb70acf995ee16f3b0e1ba77072> >, COMDAT

; 138  : _NODISCARD _InIt find_if(_InIt _First, const _InIt _Last, _Pr _Pred) { // find first satisfying _Pred

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 0c 00 00 00	 mov	 ecx, 12
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 139  :     _Adl_verify_range(_First, _Last);

  00028	48 8d 54 24 48	 lea	 rdx, QWORD PTR _Last$[rsp]
  0002d	48 8d 4c 24 40	 lea	 rcx, QWORD PTR _First$[rsp]
  00032	e8 00 00 00 00	 call	 ??$_Adl_verify_range@PEBURGYErrMapMFX@@PEBU1@@std@@YAXAEBQEBURGYErrMapMFX@@0@Z ; std::_Adl_verify_range<RGYErrMapMFX const *,RGYErrMapMFX const *>

; 140  :     auto _UFirst      = _Get_unwrapped(_First);

  00037	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _First$[rsp]
  0003c	e8 00 00 00 00	 call	 ??$_Get_unwrapped@$$CBURGYErrMapMFX@@@std@@YAPEBURGYErrMapMFX@@QEBU1@@Z ; std::_Get_unwrapped<RGYErrMapMFX const >
  00041	48 89 44 24 20	 mov	 QWORD PTR _UFirst$[rsp], rax

; 141  :     const auto _ULast = _Get_unwrapped(_Last);

  00046	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _Last$[rsp]
  0004b	e8 00 00 00 00	 call	 ??$_Get_unwrapped@$$CBURGYErrMapMFX@@@std@@YAPEBURGYErrMapMFX@@QEBU1@@Z ; std::_Get_unwrapped<RGYErrMapMFX const >
  00050	48 89 44 24 28	 mov	 QWORD PTR _ULast$[rsp], rax

; 142  :     for (; _UFirst != _ULast; ++_UFirst) {

  00055	eb 0e		 jmp	 SHORT $LN4@find_if
$LN2@find_if:
  00057	48 8b 44 24 20	 mov	 rax, QWORD PTR _UFirst$[rsp]
  0005c	48 83 c0 08	 add	 rax, 8
  00060	48 89 44 24 20	 mov	 QWORD PTR _UFirst$[rsp], rax
$LN4@find_if:
  00065	48 8b 44 24 28	 mov	 rax, QWORD PTR _ULast$[rsp]
  0006a	48 39 44 24 20	 cmp	 QWORD PTR _UFirst$[rsp], rax
  0006f	74 1d		 je	 SHORT $LN3@find_if

; 143  :         if (_Pred(*_UFirst)) {

  00071	48 8b 44 24 20	 mov	 rax, QWORD PTR _UFirst$[rsp]
  00076	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00079	48 8d 4c 24 50	 lea	 rcx, QWORD PTR _Pred$[rsp]
  0007e	e8 00 00 00 00	 call	 ??R<lambda_7ea49bb70acf995ee16f3b0e1ba77072>@@QEBA_NURGYErrMapMFX@@@Z ; <lambda_7ea49bb70acf995ee16f3b0e1ba77072>::operator()
  00083	0f b6 c0	 movzx	 eax, al
  00086	85 c0		 test	 eax, eax
  00088	74 02		 je	 SHORT $LN5@find_if

; 144  :             break;

  0008a	eb 02		 jmp	 SHORT $LN3@find_if
$LN5@find_if:

; 145  :         }
; 146  :     }

  0008c	eb c9		 jmp	 SHORT $LN2@find_if
$LN3@find_if:

; 147  : 
; 148  :     _Seek_wrapped(_First, _UFirst);

  0008e	48 8b 54 24 20	 mov	 rdx, QWORD PTR _UFirst$[rsp]
  00093	48 8d 4c 24 40	 lea	 rcx, QWORD PTR _First$[rsp]
  00098	e8 00 00 00 00	 call	 ??$_Seek_wrapped@$$CBURGYErrMapMFX@@@std@@YAXAEAPEBURGYErrMapMFX@@QEBU1@@Z ; std::_Seek_wrapped<RGYErrMapMFX const >

; 149  :     return _First;

  0009d	48 8b 44 24 40	 mov	 rax, QWORD PTR _First$[rsp]

; 150  : }

  000a2	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a6	5f		 pop	 rdi
  000a7	c3		 ret	 0
??$find_if@PEBURGYErrMapMFX@@V<lambda_7ea49bb70acf995ee16f3b0e1ba77072>@@@std@@YAPEBURGYErrMapMFX@@PEBU1@QEBU1@V<lambda_7ea49bb70acf995ee16f3b0e1ba77072>@@@Z ENDP ; std::find_if<RGYErrMapMFX const *,<lambda_7ea49bb70acf995ee16f3b0e1ba77072> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\rgy_err.cpp
;	COMDAT ??0<lambda_7ea49bb70acf995ee16f3b0e1ba77072>@@QEAA@AEBW4RGY_ERR@@@Z
_TEXT	SEGMENT
this$ = 16
<err>$ = 24
??0<lambda_7ea49bb70acf995ee16f3b0e1ba77072>@@QEAA@AEBW4RGY_ERR@@@Z PROC ; <lambda_7ea49bb70acf995ee16f3b0e1ba77072>::<lambda_7ea49bb70acf995ee16f3b0e1ba77072>, COMDAT

; 81   :     });

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 8b 44 24 10	 mov	 rax, QWORD PTR this$[rsp]
  00010	48 8b 4c 24 18	 mov	 rcx, QWORD PTR <err>$[rsp]
  00015	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00017	89 08		 mov	 DWORD PTR [rax], ecx
  00019	48 8b 44 24 10	 mov	 rax, QWORD PTR this$[rsp]
  0001e	5f		 pop	 rdi
  0001f	c3		 ret	 0
??0<lambda_7ea49bb70acf995ee16f3b0e1ba77072>@@QEAA@AEBW4RGY_ERR@@@Z ENDP ; <lambda_7ea49bb70acf995ee16f3b0e1ba77072>::<lambda_7ea49bb70acf995ee16f3b0e1ba77072>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\rgy_err.cpp
;	COMDAT ??R<lambda_7ea49bb70acf995ee16f3b0e1ba77072>@@QEBA_NURGYErrMapMFX@@@Z
_TEXT	SEGMENT
tv66 = 0
this$ = 32
map$ = 40
??R<lambda_7ea49bb70acf995ee16f3b0e1ba77072>@@QEBA_NURGYErrMapMFX@@@Z PROC ; <lambda_7ea49bb70acf995ee16f3b0e1ba77072>::operator(), COMDAT

; 79   :     auto ret = std::find_if((const RGYErrMapMFX *)ERR_MAP_MFX, ERR_MAP_FIN, [err](RGYErrMapMFX map) {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 10	 sub	 rsp, 16
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 04 00 00 00	 mov	 ecx, 4
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR [rsp+32]

; 80   :         return map.rgy == err;

  00023	48 8b 44 24 20	 mov	 rax, QWORD PTR this$[rsp]
  00028	8b 00		 mov	 eax, DWORD PTR [rax]
  0002a	39 44 24 28	 cmp	 DWORD PTR map$[rsp], eax
  0002e	75 09		 jne	 SHORT $LN3@operator
  00030	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv66[rsp], 1
  00037	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00039	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv66[rsp], 0
$LN4@operator:
  00040	0f b6 04 24	 movzx	 eax, BYTE PTR tv66[rsp]

; 81   :     });

  00044	48 83 c4 10	 add	 rsp, 16
  00048	5f		 pop	 rdi
  00049	c3		 ret	 0
??R<lambda_7ea49bb70acf995ee16f3b0e1ba77072>@@QEBA_NURGYErrMapMFX@@@Z ENDP ; <lambda_7ea49bb70acf995ee16f3b0e1ba77072>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\rgy_err.cpp
_TEXT	SEGMENT
tv64 = 0
sts$ = 32
?get_err_mes@@YAPEBDW4RGY_ERR@@@Z PROC			; get_err_mes

; 201  : const TCHAR *get_err_mes(RGY_ERR sts) {

$LN52:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	57		 push	 rdi
  00005	48 83 ec 10	 sub	 rsp, 16
  00009	48 8b fc	 mov	 rdi, rsp
  0000c	b9 04 00 00 00	 mov	 ecx, 4
  00011	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00016	f3 ab		 rep stosd
  00018	8b 4c 24 20	 mov	 ecx, DWORD PTR [rsp+32]

; 202  :     switch (sts) {

  0001c	8b 44 24 20	 mov	 eax, DWORD PTR sts$[rsp]
  00020	89 04 24	 mov	 DWORD PTR tv64[rsp], eax
  00023	8b 04 24	 mov	 eax, DWORD PTR tv64[rsp]
  00026	83 c0 28	 add	 eax, 40			; 00000028H
  00029	89 04 24	 mov	 DWORD PTR tv64[rsp], eax
  0002c	83 3c 24 2f	 cmp	 DWORD PTR tv64[rsp], 47	; 0000002fH
  00030	0f 87 09 02 00
	00		 ja	 $LN49@get_err_me
  00036	48 63 04 24	 movsxd	 rax, DWORD PTR tv64[rsp]
  0003a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00041	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN51@get_err_me[rcx+rax*4]
  00048	48 03 c1	 add	 rax, rcx
  0004b	ff e0		 jmp	 rax
$LN4@get_err_me:

; 203  :     case RGY_ERR_NONE:                     return _T("no error.");

  0004d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG58888
  00054	e9 ed 01 00 00	 jmp	 $LN1@get_err_me
$LN5@get_err_me:

; 204  :     case RGY_ERR_UNKNOWN:                  return _T("unknown error.");

  00059	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG58890
  00060	e9 e1 01 00 00	 jmp	 $LN1@get_err_me
$LN6@get_err_me:

; 205  :     case RGY_ERR_NULL_PTR:                 return _T("null pointer.");

  00065	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG58892
  0006c	e9 d5 01 00 00	 jmp	 $LN1@get_err_me
$LN7@get_err_me:

; 206  :     case RGY_ERR_UNSUPPORTED:              return _T("undeveloped feature.");

  00071	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG58894
  00078	e9 c9 01 00 00	 jmp	 $LN1@get_err_me
$LN8@get_err_me:

; 207  :     case RGY_ERR_MEMORY_ALLOC:             return _T("failed to allocate memory.");

  0007d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG58896
  00084	e9 bd 01 00 00	 jmp	 $LN1@get_err_me
$LN9@get_err_me:

; 208  :     case RGY_ERR_NOT_ENOUGH_BUFFER:        return _T("insufficient buffer at input/output.");

  00089	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG58898
  00090	e9 b1 01 00 00	 jmp	 $LN1@get_err_me
$LN10@get_err_me:

; 209  :     case RGY_ERR_INVALID_HANDLE:           return _T("invalid handle.");

  00095	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG58900
  0009c	e9 a5 01 00 00	 jmp	 $LN1@get_err_me
$LN11@get_err_me:

; 210  :     case RGY_ERR_LOCK_MEMORY:              return _T("failed to lock the memory block.");

  000a1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG58902
  000a8	e9 99 01 00 00	 jmp	 $LN1@get_err_me
$LN12@get_err_me:

; 211  :     case RGY_ERR_NOT_INITIALIZED:          return _T("member function called before initialization.");

  000ad	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG58904
  000b4	e9 8d 01 00 00	 jmp	 $LN1@get_err_me
$LN13@get_err_me:

; 212  :     case RGY_ERR_NOT_FOUND:                return _T("the specified object is not found.");

  000b9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG58906
  000c0	e9 81 01 00 00	 jmp	 $LN1@get_err_me
$LN14@get_err_me:

; 213  :     case RGY_ERR_MORE_DATA:                return _T("expect more data at input.");

  000c5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG58908
  000cc	e9 75 01 00 00	 jmp	 $LN1@get_err_me
$LN15@get_err_me:

; 214  :     case RGY_ERR_MORE_SURFACE:             return _T("expect more surface at output.");

  000d1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG58910
  000d8	e9 69 01 00 00	 jmp	 $LN1@get_err_me
$LN16@get_err_me:

; 215  :     case RGY_ERR_ABORTED:                  return _T("operation aborted.");

  000dd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG58912
  000e4	e9 5d 01 00 00	 jmp	 $LN1@get_err_me
$LN17@get_err_me:

; 216  :     case RGY_ERR_DEVICE_LOST:              return _T("lose the HW acceleration device.");

  000e9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG58914
  000f0	e9 51 01 00 00	 jmp	 $LN1@get_err_me
$LN18@get_err_me:

; 217  :     case RGY_ERR_INCOMPATIBLE_VIDEO_PARAM: return _T("incompatible video parameters.");

  000f5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG58916
  000fc	e9 45 01 00 00	 jmp	 $LN1@get_err_me
$LN19@get_err_me:

; 218  :     case RGY_ERR_INVALID_VIDEO_PARAM:      return _T("invalid video parameters.");

  00101	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG58918
  00108	e9 39 01 00 00	 jmp	 $LN1@get_err_me
$LN20@get_err_me:

; 219  :     case RGY_ERR_UNDEFINED_BEHAVIOR:       return _T("undefined behavior.");

  0010d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG58920
  00114	e9 2d 01 00 00	 jmp	 $LN1@get_err_me
$LN21@get_err_me:

; 220  :     case RGY_ERR_DEVICE_FAILED:            return _T("device operation failure.");

  00119	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG58922
  00120	e9 21 01 00 00	 jmp	 $LN1@get_err_me
$LN22@get_err_me:

; 221  :     case RGY_ERR_GPU_HANG:                 return _T("gpu hang.");

  00125	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG58924
  0012c	e9 15 01 00 00	 jmp	 $LN1@get_err_me
$LN23@get_err_me:

; 222  :     case RGY_ERR_REALLOC_SURFACE:          return _T("failed to realloc surface.");

  00131	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG58926
  00138	e9 09 01 00 00	 jmp	 $LN1@get_err_me
$LN24@get_err_me:

; 223  :     case RGY_ERR_ACCESS_DENIED:            return _T("access denied");

  0013d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG58928
  00144	e9 fd 00 00 00	 jmp	 $LN1@get_err_me
$LN25@get_err_me:

; 224  :     case RGY_ERR_INVALID_PARAM:            return _T("invalid param.");

  00149	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG58930
  00150	e9 f1 00 00 00	 jmp	 $LN1@get_err_me
$LN26@get_err_me:

; 225  :     case RGY_ERR_OUT_OF_RANGE:             return _T("out pf range.");

  00155	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG58932
  0015c	e9 e5 00 00 00	 jmp	 $LN1@get_err_me
$LN27@get_err_me:

; 226  :     case RGY_ERR_ALREADY_INITIALIZED:      return _T("already initialized.");

  00161	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG58934
  00168	e9 d9 00 00 00	 jmp	 $LN1@get_err_me
$LN28@get_err_me:

; 227  :     case RGY_ERR_INVALID_FORMAT:           return _T("invalid format.");

  0016d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG58936
  00174	e9 cd 00 00 00	 jmp	 $LN1@get_err_me
$LN29@get_err_me:

; 228  :     case RGY_ERR_WRONG_STATE:              return _T("wrong state.");

  00179	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG58938
  00180	e9 c1 00 00 00	 jmp	 $LN1@get_err_me
$LN30@get_err_me:

; 229  :     case RGY_ERR_FILE_OPEN:                return _T("file open error.");

  00185	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG58940
  0018c	e9 b5 00 00 00	 jmp	 $LN1@get_err_me
$LN31@get_err_me:

; 230  :     case RGY_ERR_INPUT_FULL:               return _T("input full.");

  00191	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG58942
  00198	e9 a9 00 00 00	 jmp	 $LN1@get_err_me
$LN32@get_err_me:

; 231  :     case RGY_ERR_INVALID_CODEC:            return _T("invalid codec.");

  0019d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG58944
  001a4	e9 9d 00 00 00	 jmp	 $LN1@get_err_me
$LN33@get_err_me:

; 232  :     case RGY_ERR_INVALID_DATA_TYPE:        return _T("invalid data type.");

  001a9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG58946
  001b0	e9 91 00 00 00	 jmp	 $LN1@get_err_me
$LN34@get_err_me:

; 233  :     case RGY_ERR_INVALID_RESOLUTION:       return _T("invaldi resolution.");

  001b5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG58948
  001bc	e9 85 00 00 00	 jmp	 $LN1@get_err_me
$LN35@get_err_me:

; 234  :     case RGY_ERR_INVALID_DEVICE:           return _T("invalid devices.");

  001c1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG58950
  001c8	eb 7c		 jmp	 SHORT $LN1@get_err_me
$LN36@get_err_me:

; 235  :     case RGY_ERR_INVALID_CALL:             return _T("invalid call sequence.");

  001ca	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG58952
  001d1	eb 73		 jmp	 SHORT $LN1@get_err_me
$LN37@get_err_me:

; 236  :     case RGY_ERR_NO_DEVICE:                return _T("no deivce found.");

  001d3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG58954
  001da	eb 6a		 jmp	 SHORT $LN1@get_err_me
$LN38@get_err_me:

; 237  :     case RGY_ERR_INVALID_VERSION:          return _T("invalid version.");

  001dc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG58956
  001e3	eb 61		 jmp	 SHORT $LN1@get_err_me
$LN39@get_err_me:

; 238  :     case RGY_ERR_MAP_FAILED:               return _T("map failed.");

  001e5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG58958
  001ec	eb 58		 jmp	 SHORT $LN1@get_err_me
$LN40@get_err_me:

; 239  :     case RGY_ERR_CUDA:                     return _T("error in cuda.");

  001ee	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG58960
  001f5	eb 4f		 jmp	 SHORT $LN1@get_err_me
$LN41@get_err_me:

; 240  :     case RGY_ERR_RUN_PROCESS:              return _T("running process failed.");

  001f7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG58962
  001fe	eb 46		 jmp	 SHORT $LN1@get_err_me
$LN42@get_err_me:

; 241  :     case RGY_WRN_IN_EXECUTION:             return _T("the previous asynchrous operation is in execution.");

  00200	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG58964
  00207	eb 3d		 jmp	 SHORT $LN1@get_err_me
$LN43@get_err_me:

; 242  :     case RGY_WRN_DEVICE_BUSY:              return _T("the HW acceleration device is busy.");

  00209	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG58966
  00210	eb 34		 jmp	 SHORT $LN1@get_err_me
$LN44@get_err_me:

; 243  :     case RGY_WRN_VIDEO_PARAM_CHANGED:      return _T("the video parameters are changed during decoding.");

  00212	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG58968
  00219	eb 2b		 jmp	 SHORT $LN1@get_err_me
$LN45@get_err_me:

; 244  :     case RGY_WRN_PARTIAL_ACCELERATION:     return _T("SW is used.");

  0021b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG58970
  00222	eb 22		 jmp	 SHORT $LN1@get_err_me
$LN46@get_err_me:

; 245  :     case RGY_WRN_INCOMPATIBLE_VIDEO_PARAM: return _T("incompatible video parameters.");

  00224	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG58972
  0022b	eb 19		 jmp	 SHORT $LN1@get_err_me
$LN47@get_err_me:

; 246  :     case RGY_WRN_VALUE_NOT_CHANGED:        return _T("the value is saturated based on its valid range.");

  0022d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG58974
  00234	eb 10		 jmp	 SHORT $LN1@get_err_me
$LN48@get_err_me:

; 247  :     case RGY_WRN_OUT_OF_RANGE:             return _T("the value is out of valid range.");

  00236	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG58976
  0023d	eb 07		 jmp	 SHORT $LN1@get_err_me
$LN49@get_err_me:

; 248  :     default:                               return _T("unknown error.");

  0023f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG58978
$LN1@get_err_me:

; 249  :     }
; 250  : }

  00246	48 83 c4 10	 add	 rsp, 16
  0024a	5f		 pop	 rdi
  0024b	c3		 ret	 0
$LN51@get_err_me:
  0024c	00 00 00 00	 DD	 $LN41@get_err_me
  00250	00 00 00 00	 DD	 $LN40@get_err_me
  00254	00 00 00 00	 DD	 $LN39@get_err_me
  00258	00 00 00 00	 DD	 $LN38@get_err_me
  0025c	00 00 00 00	 DD	 $LN36@get_err_me
  00260	00 00 00 00	 DD	 $LN35@get_err_me
  00264	00 00 00 00	 DD	 $LN37@get_err_me
  00268	00 00 00 00	 DD	 $LN34@get_err_me
  0026c	00 00 00 00	 DD	 $LN33@get_err_me
  00270	00 00 00 00	 DD	 $LN32@get_err_me
  00274	00 00 00 00	 DD	 $LN31@get_err_me
  00278	00 00 00 00	 DD	 $LN30@get_err_me
  0027c	00 00 00 00	 DD	 $LN29@get_err_me
  00280	00 00 00 00	 DD	 $LN28@get_err_me
  00284	00 00 00 00	 DD	 $LN27@get_err_me
  00288	00 00 00 00	 DD	 $LN26@get_err_me
  0028c	00 00 00 00	 DD	 $LN25@get_err_me
  00290	00 00 00 00	 DD	 $LN24@get_err_me
  00294	00 00 00 00	 DD	 $LN23@get_err_me
  00298	00 00 00 00	 DD	 $LN22@get_err_me
  0029c	00 00 00 00	 DD	 $LN49@get_err_me
  002a0	00 00 00 00	 DD	 $LN49@get_err_me
  002a4	00 00 00 00	 DD	 $LN49@get_err_me
  002a8	00 00 00 00	 DD	 $LN21@get_err_me
  002ac	00 00 00 00	 DD	 $LN20@get_err_me
  002b0	00 00 00 00	 DD	 $LN19@get_err_me
  002b4	00 00 00 00	 DD	 $LN18@get_err_me
  002b8	00 00 00 00	 DD	 $LN17@get_err_me
  002bc	00 00 00 00	 DD	 $LN16@get_err_me
  002c0	00 00 00 00	 DD	 $LN15@get_err_me
  002c4	00 00 00 00	 DD	 $LN14@get_err_me
  002c8	00 00 00 00	 DD	 $LN13@get_err_me
  002cc	00 00 00 00	 DD	 $LN12@get_err_me
  002d0	00 00 00 00	 DD	 $LN11@get_err_me
  002d4	00 00 00 00	 DD	 $LN10@get_err_me
  002d8	00 00 00 00	 DD	 $LN9@get_err_me
  002dc	00 00 00 00	 DD	 $LN8@get_err_me
  002e0	00 00 00 00	 DD	 $LN7@get_err_me
  002e4	00 00 00 00	 DD	 $LN6@get_err_me
  002e8	00 00 00 00	 DD	 $LN5@get_err_me
  002ec	00 00 00 00	 DD	 $LN4@get_err_me
  002f0	00 00 00 00	 DD	 $LN42@get_err_me
  002f4	00 00 00 00	 DD	 $LN43@get_err_me
  002f8	00 00 00 00	 DD	 $LN44@get_err_me
  002fc	00 00 00 00	 DD	 $LN45@get_err_me
  00300	00 00 00 00	 DD	 $LN46@get_err_me
  00304	00 00 00 00	 DD	 $LN47@get_err_me
  00308	00 00 00 00	 DD	 $LN48@get_err_me
?get_err_mes@@YAPEBDW4RGY_ERR@@@Z ENDP			; get_err_mes
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\rgy_err.cpp
_TEXT	SEGMENT
ERR_MAP_FIN$ = 32
ret$ = 40
$T1 = 48
tv74 = 52
err$ = 80
?err_to_rgy@@YA?AW4RGY_ERR@@W4mfxStatus@@@Z PROC	; err_to_rgy

; 85   : RGY_ERR err_to_rgy(mfxStatus err) {

$LN5:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	57		 push	 rdi
  00005	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00009	48 8b fc	 mov	 rdi, rsp
  0000c	b9 10 00 00 00	 mov	 ecx, 16
  00011	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00016	f3 ab		 rep stosd
  00018	8b 4c 24 50	 mov	 ecx, DWORD PTR [rsp+80]

; 86   :     const RGYErrMapMFX *ERR_MAP_FIN = (const RGYErrMapMFX *)ERR_MAP_MFX + _countof(ERR_MAP_MFX);

  0001c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?ERR_MAP_MFX@@3QBURGYErrMapMFX@@B
  00023	48 05 08 01 00
	00		 add	 rax, 264		; 00000108H
  00029	48 89 44 24 20	 mov	 QWORD PTR ERR_MAP_FIN$[rsp], rax

; 87   :     auto ret = std::find_if((const RGYErrMapMFX *)ERR_MAP_MFX, ERR_MAP_FIN, [err](RGYErrMapMFX map) {

  0002e	48 8d 54 24 50	 lea	 rdx, QWORD PTR err$[rsp]
  00033	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T1[rsp]
  00038	e8 00 00 00 00	 call	 ??0<lambda_dabac589461c7a2e6e1fe7373c988653>@@QEAA@AEBW4mfxStatus@@@Z ; <lambda_dabac589461c7a2e6e1fe7373c988653>::<lambda_dabac589461c7a2e6e1fe7373c988653>
  0003d	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  00040	48 8b 54 24 20	 mov	 rdx, QWORD PTR ERR_MAP_FIN$[rsp]
  00045	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?ERR_MAP_MFX@@3QBURGYErrMapMFX@@B
  0004c	e8 00 00 00 00	 call	 ??$find_if@PEBURGYErrMapMFX@@V<lambda_dabac589461c7a2e6e1fe7373c988653>@@@std@@YAPEBURGYErrMapMFX@@PEBU1@QEBU1@V<lambda_dabac589461c7a2e6e1fe7373c988653>@@@Z ; std::find_if<RGYErrMapMFX const *,<lambda_dabac589461c7a2e6e1fe7373c988653> >
  00051	48 89 44 24 28	 mov	 QWORD PTR ret$[rsp], rax

; 88   :         return map.mfx == err;
; 89   :     });
; 90   :     return (ret == ERR_MAP_FIN) ? RGY_ERR_UNKNOWN : ret->rgy;

  00056	48 8b 44 24 20	 mov	 rax, QWORD PTR ERR_MAP_FIN$[rsp]
  0005b	48 39 44 24 28	 cmp	 QWORD PTR ret$[rsp], rax
  00060	75 0a		 jne	 SHORT $LN3@err_to_rgy
  00062	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  0006a	eb 0b		 jmp	 SHORT $LN4@err_to_rgy
$LN3@err_to_rgy:
  0006c	48 8b 44 24 28	 mov	 rax, QWORD PTR ret$[rsp]
  00071	8b 00		 mov	 eax, DWORD PTR [rax]
  00073	89 44 24 34	 mov	 DWORD PTR tv74[rsp], eax
$LN4@err_to_rgy:
  00077	8b 44 24 34	 mov	 eax, DWORD PTR tv74[rsp]

; 91   : }

  0007b	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0007f	5f		 pop	 rdi
  00080	c3		 ret	 0
?err_to_rgy@@YA?AW4RGY_ERR@@W4mfxStatus@@@Z ENDP	; err_to_rgy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\rgy_err.cpp
_TEXT	SEGMENT
ERR_MAP_FIN$ = 32
ret$ = 40
$T1 = 48
tv74 = 52
err$ = 80
?err_to_mfx@@YA?AW4mfxStatus@@W4RGY_ERR@@@Z PROC	; err_to_mfx

; 77   : mfxStatus err_to_mfx(RGY_ERR err) {

$LN5:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	57		 push	 rdi
  00005	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00009	48 8b fc	 mov	 rdi, rsp
  0000c	b9 10 00 00 00	 mov	 ecx, 16
  00011	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00016	f3 ab		 rep stosd
  00018	8b 4c 24 50	 mov	 ecx, DWORD PTR [rsp+80]

; 78   :     const RGYErrMapMFX *ERR_MAP_FIN = (const RGYErrMapMFX *)ERR_MAP_MFX + _countof(ERR_MAP_MFX);

  0001c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?ERR_MAP_MFX@@3QBURGYErrMapMFX@@B
  00023	48 05 08 01 00
	00		 add	 rax, 264		; 00000108H
  00029	48 89 44 24 20	 mov	 QWORD PTR ERR_MAP_FIN$[rsp], rax

; 79   :     auto ret = std::find_if((const RGYErrMapMFX *)ERR_MAP_MFX, ERR_MAP_FIN, [err](RGYErrMapMFX map) {

  0002e	48 8d 54 24 50	 lea	 rdx, QWORD PTR err$[rsp]
  00033	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T1[rsp]
  00038	e8 00 00 00 00	 call	 ??0<lambda_7ea49bb70acf995ee16f3b0e1ba77072>@@QEAA@AEBW4RGY_ERR@@@Z ; <lambda_7ea49bb70acf995ee16f3b0e1ba77072>::<lambda_7ea49bb70acf995ee16f3b0e1ba77072>
  0003d	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  00040	48 8b 54 24 20	 mov	 rdx, QWORD PTR ERR_MAP_FIN$[rsp]
  00045	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?ERR_MAP_MFX@@3QBURGYErrMapMFX@@B
  0004c	e8 00 00 00 00	 call	 ??$find_if@PEBURGYErrMapMFX@@V<lambda_7ea49bb70acf995ee16f3b0e1ba77072>@@@std@@YAPEBURGYErrMapMFX@@PEBU1@QEBU1@V<lambda_7ea49bb70acf995ee16f3b0e1ba77072>@@@Z ; std::find_if<RGYErrMapMFX const *,<lambda_7ea49bb70acf995ee16f3b0e1ba77072> >
  00051	48 89 44 24 28	 mov	 QWORD PTR ret$[rsp], rax

; 80   :         return map.rgy == err;
; 81   :     });
; 82   :     return (ret == ERR_MAP_FIN) ? MFX_ERR_UNKNOWN : ret->mfx;

  00056	48 8b 44 24 20	 mov	 rax, QWORD PTR ERR_MAP_FIN$[rsp]
  0005b	48 39 44 24 28	 cmp	 QWORD PTR ret$[rsp], rax
  00060	75 0a		 jne	 SHORT $LN3@err_to_mfx
  00062	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  0006a	eb 0c		 jmp	 SHORT $LN4@err_to_mfx
$LN3@err_to_mfx:
  0006c	48 8b 44 24 28	 mov	 rax, QWORD PTR ret$[rsp]
  00071	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00074	89 44 24 34	 mov	 DWORD PTR tv74[rsp], eax
$LN4@err_to_mfx:
  00078	8b 44 24 34	 mov	 eax, DWORD PTR tv74[rsp]

; 83   : }

  0007c	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00080	5f		 pop	 rdi
  00081	c3		 ret	 0
?err_to_mfx@@YA?AW4mfxStatus@@W4RGY_ERR@@@Z ENDP	; err_to_mfx
_TEXT	ENDS
END
