; Listing generated by Microsoft (R) Optimizing Compiler Version 19.23.28106.4 

	TITLE	D:\work\intel\intel_codec\QSVPipeline\rgy_err.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
?ERR_MAP_MFX@@3QBURGYErrMapMFX@@B DD 00H		; ERR_MAP_MFX
	DD	00H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0fffffffeH
	DD	0fffffffeH
	DD	0fffffffdH
	DD	0fffffffdH
	DD	0fffffffcH
	DD	0fffffffcH
	DD	0fffffffbH
	DD	0fffffffbH
	DD	0fffffffaH
	DD	0fffffffaH
	DD	0fffffff9H
	DD	0fffffff9H
	DD	0fffffff8H
	DD	0fffffff8H
	DD	0fffffff7H
	DD	0fffffff7H
	DD	0fffffff6H
	DD	0fffffff6H
	DD	0fffffff5H
	DD	0fffffff5H
	DD	0fffffff4H
	DD	0fffffff4H
	DD	0fffffff3H
	DD	0fffffff3H
	DD	0fffffff2H
	DD	0fffffff2H
	DD	0fffffff1H
	DD	0fffffff1H
	DD	0fffffff0H
	DD	0fffffff0H
	DD	0ffffffefH
	DD	0ffffffefH
	DD	0ffffffeeH
	DD	0ffffffeeH
	DD	0ffffffedH
	DD	0ffffffedH
	DD	0ffffffecH
	DD	0ffffffecH
	DD	0ffffffebH
	DD	0ffffffebH
	DD	0ffffffeaH
	DD	0ffffffeaH
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	03H
	DD	03H
	DD	04H
	DD	04H
	DD	05H
	DD	05H
	DD	06H
	DD	06H
	DD	07H
	DD	07H
	DD	0aH
	DD	0aH
	DD	0bH
	DD	0bH
	DD	0ffffd8f0H
	DD	0ffffd8f0H
$SG59299 DB	'no error.', 00H
	ORG $+2
$SG59301 DB	'unknown error.', 00H
	ORG $+1
$SG59303 DB	'null pointer.', 00H
	ORG $+2
$SG59305 DB	'undeveloped feature.', 00H
	ORG $+3
$SG59307 DB	'failed to allocate memory.', 00H
	ORG $+1
$SG59309 DB	'insufficient buffer at input/output.', 00H
	ORG $+3
$SG59311 DB	'invalid handle.', 00H
$SG59313 DB	'failed to lock the memory block.', 00H
	ORG $+3
$SG59315 DB	'member function called before initialization.', 00H
	ORG $+2
$SG59317 DB	'the specified object is not found.', 00H
	ORG $+1
$SG59319 DB	'expect more data at input.', 00H
	ORG $+1
$SG59321 DB	'expect more surface at output.', 00H
	ORG $+1
$SG59323 DB	'operation aborted.', 00H
	ORG $+1
$SG59325 DB	'lose the HW acceleration device.', 00H
	ORG $+3
$SG59327 DB	'incompatible video parameters.', 00H
	ORG $+1
$SG59329 DB	'invalid video parameters.', 00H
	ORG $+2
$SG59331 DB	'undefined behavior.', 00H
$SG59333 DB	'device operation failure.', 00H
	ORG $+2
$SG59335 DB	'gpu hang.', 00H
	ORG $+2
$SG59337 DB	'failed to realloc surface.', 00H
	ORG $+1
$SG59339 DB	'access denied', 00H
	ORG $+2
$SG59341 DB	'invalid param.', 00H
	ORG $+1
$SG59343 DB	'out pf range.', 00H
	ORG $+2
$SG59345 DB	'already initialized.', 00H
	ORG $+3
$SG59347 DB	'invalid format.', 00H
$SG59349 DB	'wrong state.', 00H
	ORG $+3
$SG59351 DB	'file open error.', 00H
	ORG $+3
$SG59353 DB	'input full.', 00H
$SG59355 DB	'invalid codec.', 00H
	ORG $+1
$SG59357 DB	'invalid data type.', 00H
	ORG $+1
$SG59359 DB	'invaldi resolution.', 00H
$SG59361 DB	'invalid devices.', 00H
	ORG $+3
$SG59363 DB	'invalid call sequence.', 00H
	ORG $+1
$SG59365 DB	'no deivce found.', 00H
	ORG $+3
$SG59367 DB	'invalid version.', 00H
	ORG $+3
$SG59369 DB	'map failed.', 00H
$SG59371 DB	'error in cuda.', 00H
	ORG $+1
$SG59373 DB	'running process failed.', 00H
$SG59375 DB	'the previous asynchrous operation is in execution.', 00H
	ORG $+1
$SG59377 DB	'the HW acceleration device is busy.', 00H
$SG59379 DB	'the video parameters are changed during decoding.', 00H
	ORG $+2
$SG59381 DB	'SW is used.', 00H
$SG59383 DB	'incompatible video parameters.', 00H
	ORG $+1
$SG59385 DB	'the value is saturated based on its valid range.', 00H
	ORG $+3
$SG59387 DB	'the value is out of valid range.', 00H
	ORG $+3
$SG59389 DB	'unknown error.', 00H
CONST	ENDS
PUBLIC	?err_to_mfx@@YA?AW4mfxStatus@@W4RGY_ERR@@@Z	; err_to_mfx
PUBLIC	?err_to_rgy@@YA?AW4RGY_ERR@@W4mfxStatus@@@Z	; err_to_rgy
PUBLIC	?get_err_mes@@YAPBDW4RGY_ERR@@@Z		; get_err_mes
PUBLIC	??$_Adl_verify_range@PBURGYErrMapMFX@@PBU1@@std@@YAXABQBURGYErrMapMFX@@0@Z ; std::_Adl_verify_range<RGYErrMapMFX const *,RGYErrMapMFX const *>
PUBLIC	??$_Get_unwrapped@$$CBURGYErrMapMFX@@@std@@YAPBURGYErrMapMFX@@QBU1@@Z ; std::_Get_unwrapped<RGYErrMapMFX const >
PUBLIC	??$_Seek_wrapped@$$CBURGYErrMapMFX@@@std@@YAXAAPBURGYErrMapMFX@@QBU1@@Z ; std::_Seek_wrapped<RGYErrMapMFX const >
PUBLIC	??$_Verify_range@URGYErrMapMFX@@@std@@YAXQBURGYErrMapMFX@@0@Z ; std::_Verify_range<RGYErrMapMFX>
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_0BJ@HAJGEHKO@transposed?5pointer?5range@	; `string'
PUBLIC	??_C@_0GJ@GDKIGMBO@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ ; `string'
PUBLIC	??_C@_1NC@OIIHGCJJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_1CG@LJCPDKEJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAr?$AAi?$AAf?$AAy?$AA_?$AAr?$AAa@ ; `string'
PUBLIC	??_C@_1DG@FJIKMGFD@?$AA?$CC?$AAt?$AAr?$AAa?$AAn?$AAs?$AAp?$AAo?$AAs?$AAe?$AAd?$AA?5?$AAp?$AAo?$AAi@ ; `string'
EXTRN	__imp___invalid_parameter:PROC
EXTRN	__imp___CrtDbgReport:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_1DG@FJIKMGFD@?$AA?$CC?$AAt?$AAr?$AAa?$AAn?$AAs?$AAp?$AAo?$AAs?$AAe?$AAd?$AA?5?$AAp?$AAo?$AAi@
CONST	SEGMENT
??_C@_1DG@FJIKMGFD@?$AA?$CC?$AAt?$AAr?$AAa?$AAn?$AAs?$AAp?$AAo?$AAs?$AAe?$AAd?$AA?5?$AAp?$AAo?$AAi@ DB '"'
	DB	00H, 't', 00H, 'r', 00H, 'a', 00H, 'n', 00H, 's', 00H, 'p', 00H
	DB	'o', 00H, 's', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 'p', 00H, 'o'
	DB	00H, 'i', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, ' ', 00H
	DB	'r', 00H, 'a', 00H, 'n', 00H, 'g', 00H, 'e', 00H, '"', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@LJCPDKEJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAr?$AAi?$AAf?$AAy?$AA_?$AAr?$AAa@
CONST	SEGMENT
??_C@_1CG@LJCPDKEJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAr?$AAi?$AAf?$AAy?$AA_?$AAr?$AAa@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'e', 00H, 'r', 00H, 'i', 00H, 'f', 00H, 'y', 00H, '_', 00H, 'r'
	DB	00H, 'a', 00H, 'n', 00H, 'g', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1NC@OIIHGCJJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
CONST	SEGMENT
??_C@_1NC@OIIHGCJJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ DB 'C'
	DB	00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'F', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'V', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	'\', 00H, '2', 00H, '0', 00H, '1', 00H, '9', 00H, '\', 00H, 'C'
	DB	00H, 'o', 00H, 'm', 00H, 'm', 00H, 'u', 00H, 'n', 00H, 'i', 00H
	DB	't', 00H, 'y', 00H, '\', 00H, 'V', 00H, 'C', 00H, '\', 00H, 'T'
	DB	00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '\', 00H, 'M', 00H
	DB	'S', 00H, 'V', 00H, 'C', 00H, '\', 00H, '1', 00H, '4', 00H, '.'
	DB	00H, '2', 00H, '3', 00H, '.', 00H, '2', 00H, '8', 00H, '1', 00H
	DB	'0', 00H, '5', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l'
	DB	00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H, 'u', 00H
	DB	't', 00H, 'i', 00H, 'l', 00H, 'i', 00H, 't', 00H, 'y', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0GJ@GDKIGMBO@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
CONST	SEGMENT
??_C@_0GJ@GDKIGMBO@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ DB 'C:\Pro'
	DB	'gram Files (x86)\Microsoft Visual Studio\2019\Community\VC\To'
	DB	'ols\MSVC\14.23.28105\include\xutility', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HAJGEHKO@transposed?5pointer?5range@
CONST	SEGMENT
??_C@_0BJ@HAJGEHKO@transposed?5pointer?5range@ DB 'transposed pointer ran'
	DB	'ge', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Verify_range@URGYErrMapMFX@@@std@@YAXQBURGYErrMapMFX@@0@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xutility
;	COMDAT ??$_Verify_range@URGYErrMapMFX@@@std@@YAXQBURGYErrMapMFX@@0@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Verify_range@URGYErrMapMFX@@@std@@YAXQBURGYErrMapMFX@@0@Z PROC ; std::_Verify_range<RGYErrMapMFX>, COMDAT

; 191  :     const _Ty* const _First, const _Ty* const _Last) noexcept { // special case range verification for pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Verify_range@URGYErrMapMFX@@@std@@YAXQBURGYErrMapMFX@@0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
$LN4@Verify_ran:

; 192  :     _STL_VERIFY(_First <= _Last, "transposed pointer range");

  00023	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00026	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00029	77 02		 ja	 SHORT $LN7@Verify_ran
  0002b	eb 5c		 jmp	 SHORT $LN2@Verify_ran
$LN7@Verify_ran:
  0002d	8b f4		 mov	 esi, esp
  0002f	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@HAJGEHKO@transposed?5pointer?5range@
  00034	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  00039	6a 00		 push	 0
  0003b	68 c0 00 00 00	 push	 192			; 000000c0H
  00040	68 00 00 00 00	 push	 OFFSET ??_C@_0GJ@GDKIGMBO@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
  00045	6a 02		 push	 2
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  0004d	83 c4 18	 add	 esp, 24			; 00000018H
  00050	3b f4		 cmp	 esi, esp
  00052	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00057	83 f8 01	 cmp	 eax, 1
  0005a	75 01		 jne	 SHORT $LN11@Verify_ran
  0005c	cc		 int	 3
$LN11@Verify_ran:
  0005d	8b f4		 mov	 esi, esp
  0005f	6a 00		 push	 0
  00061	68 c0 00 00 00	 push	 192			; 000000c0H
  00066	68 00 00 00 00	 push	 OFFSET ??_C@_1NC@OIIHGCJJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  0006b	68 00 00 00 00	 push	 OFFSET ??_C@_1CG@LJCPDKEJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAr?$AAi?$AAf?$AAy?$AA_?$AAr?$AAa@
  00070	68 00 00 00 00	 push	 OFFSET ??_C@_1DG@FJIKMGFD@?$AA?$CC?$AAt?$AAr?$AAa?$AAn?$AAs?$AAp?$AAo?$AAs?$AAe?$AAd?$AA?5?$AAp?$AAo?$AAi@
  00075	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  0007b	83 c4 14	 add	 esp, 20			; 00000014H
  0007e	3b f4		 cmp	 esi, esp
  00080	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00085	33 d2		 xor	 edx, edx
  00087	75 a4		 jne	 SHORT $LN7@Verify_ran
$LN2@Verify_ran:
  00089	33 c0		 xor	 eax, eax
  0008b	75 96		 jne	 SHORT $LN4@Verify_ran

; 193  : }

  0008d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00090	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00097	59		 pop	 ecx
  00098	5e		 pop	 esi
  00099	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009c	3b ec		 cmp	 ebp, esp
  0009e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a3	8b e5		 mov	 esp, ebp
  000a5	5d		 pop	 ebp
  000a6	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Verify_range@URGYErrMapMFX@@@std@@YAXQBURGYErrMapMFX@@0@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Verify_range@URGYErrMapMFX@@@std@@YAXQBURGYErrMapMFX@@0@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Verify_range@URGYErrMapMFX@@@std@@YAXQBURGYErrMapMFX@@0@Z ENDP ; std::_Verify_range<RGYErrMapMFX>
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xutility
;	COMDAT ??$_Seek_wrapped@$$CBURGYErrMapMFX@@@std@@YAXAAPBURGYErrMapMFX@@QBU1@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
__UIt$ = 12						; size = 4
??$_Seek_wrapped@$$CBURGYErrMapMFX@@@std@@YAXAAPBURGYErrMapMFX@@QBU1@@Z PROC ; std::_Seek_wrapped<RGYErrMapMFX const >, COMDAT

; 435  : constexpr void _Seek_wrapped(_Ty*& _It, _Ty* const _UIt) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 436  :     _It = _UIt;

  00003	8b 45 08	 mov	 eax, DWORD PTR __It$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __UIt$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 437  : }

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
??$_Seek_wrapped@$$CBURGYErrMapMFX@@@std@@YAXAAPBURGYErrMapMFX@@QBU1@@Z ENDP ; std::_Seek_wrapped<RGYErrMapMFX const >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xutility
;	COMDAT ??$_Get_unwrapped@$$CBURGYErrMapMFX@@@std@@YAPBURGYErrMapMFX@@QBU1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Get_unwrapped@$$CBURGYErrMapMFX@@@std@@YAPBURGYErrMapMFX@@QBU1@@Z PROC ; std::_Get_unwrapped<RGYErrMapMFX const >, COMDAT

; 275  : _NODISCARD constexpr _Ty* _Get_unwrapped(_Ty* const _Ptr) { // special case already-unwrapped pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 276  :     return _Ptr;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 277  : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Get_unwrapped@$$CBURGYErrMapMFX@@@std@@YAPBURGYErrMapMFX@@QBU1@@Z ENDP ; std::_Get_unwrapped<RGYErrMapMFX const >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xutility
;	COMDAT ??$_Adl_verify_range@PBURGYErrMapMFX@@PBU1@@std@@YAXABQBURGYErrMapMFX@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Adl_verify_range@PBURGYErrMapMFX@@PBU1@@std@@YAXABQBURGYErrMapMFX@@0@Z PROC ; std::_Adl_verify_range<RGYErrMapMFX const *,RGYErrMapMFX const *>, COMDAT

; 217  :     const _Iter& _First, const _Sentinel& _Last) { // check that [_First, _Last) forms an iterator range

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 218  :     if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 219  :         _Verify_range(_First, _Last);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	51		 push	 ecx
  00009	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0000c	8b 02		 mov	 eax, DWORD PTR [edx]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ??$_Verify_range@URGYErrMapMFX@@@std@@YAXQBURGYErrMapMFX@@0@Z ; std::_Verify_range<RGYErrMapMFX>
  00014	83 c4 08	 add	 esp, 8

; 220  :     } else {
; 221  :         (void) _First; // TRANSITION, VSO#486357
; 222  :         (void) _Last; // TRANSITION, VSO#486357
; 223  :     }
; 224  : }

  00017	3b ec		 cmp	 ebp, esp
  00019	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
??$_Adl_verify_range@PBURGYErrMapMFX@@PBU1@@std@@YAXABQBURGYErrMapMFX@@0@Z ENDP ; std::_Adl_verify_range<RGYErrMapMFX const *,RGYErrMapMFX const *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\algorithm
;	COMDAT ??$find_if@PBURGYErrMapMFX@@V<lambda_dabac589461c7a2e6e1fe7373c988653>@@@std@@YAPBURGYErrMapMFX@@PBU1@QBU1@V<lambda_dabac589461c7a2e6e1fe7373c988653>@@@Z
_TEXT	SEGMENT
__ULast$ = -8						; size = 4
__UFirst$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$find_if@PBURGYErrMapMFX@@V<lambda_dabac589461c7a2e6e1fe7373c988653>@@@std@@YAPBURGYErrMapMFX@@PBU1@QBU1@V<lambda_dabac589461c7a2e6e1fe7373c988653>@@@Z PROC ; std::find_if<RGYErrMapMFX const *,<lambda_dabac589461c7a2e6e1fe7373c988653> >, COMDAT

; 138  : _NODISCARD _InIt find_if(_InIt _First, const _InIt _Last, _Pr _Pred) { // find first satisfying _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 139  :     _Adl_verify_range(_First, _Last);

  00014	8d 45 0c	 lea	 eax, DWORD PTR __Last$[ebp]
  00017	50		 push	 eax
  00018	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0001b	51		 push	 ecx
  0001c	e8 00 00 00 00	 call	 ??$_Adl_verify_range@PBURGYErrMapMFX@@PBU1@@std@@YAXABQBURGYErrMapMFX@@0@Z ; std::_Adl_verify_range<RGYErrMapMFX const *,RGYErrMapMFX const *>
  00021	83 c4 08	 add	 esp, 8

; 140  :     auto _UFirst      = _Get_unwrapped(_First);

  00024	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00027	52		 push	 edx
  00028	e8 00 00 00 00	 call	 ??$_Get_unwrapped@$$CBURGYErrMapMFX@@@std@@YAPBURGYErrMapMFX@@QBU1@@Z ; std::_Get_unwrapped<RGYErrMapMFX const >
  0002d	83 c4 04	 add	 esp, 4
  00030	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax

; 141  :     const auto _ULast = _Get_unwrapped(_Last);

  00033	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 ??$_Get_unwrapped@$$CBURGYErrMapMFX@@@std@@YAPBURGYErrMapMFX@@QBU1@@Z ; std::_Get_unwrapped<RGYErrMapMFX const >
  0003c	83 c4 04	 add	 esp, 4
  0003f	89 45 f8	 mov	 DWORD PTR __ULast$[ebp], eax

; 142  :     for (; _UFirst != _ULast; ++_UFirst) {

  00042	eb 09		 jmp	 SHORT $LN4@find_if
$LN2@find_if:
  00044	8b 4d fc	 mov	 ecx, DWORD PTR __UFirst$[ebp]
  00047	83 c1 08	 add	 ecx, 8
  0004a	89 4d fc	 mov	 DWORD PTR __UFirst$[ebp], ecx
$LN4@find_if:
  0004d	8b 55 fc	 mov	 edx, DWORD PTR __UFirst$[ebp]
  00050	3b 55 f8	 cmp	 edx, DWORD PTR __ULast$[ebp]
  00053	74 1d		 je	 SHORT $LN3@find_if

; 143  :         if (_Pred(*_UFirst)) {

  00055	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00058	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005b	51		 push	 ecx
  0005c	8b 10		 mov	 edx, DWORD PTR [eax]
  0005e	52		 push	 edx
  0005f	8d 4d 10	 lea	 ecx, DWORD PTR __Pred$[ebp]
  00062	e8 00 00 00 00	 call	 ??R<lambda_dabac589461c7a2e6e1fe7373c988653>@@QBE_NURGYErrMapMFX@@@Z ; <lambda_dabac589461c7a2e6e1fe7373c988653>::operator()
  00067	0f b6 c0	 movzx	 eax, al
  0006a	85 c0		 test	 eax, eax
  0006c	74 02		 je	 SHORT $LN5@find_if

; 144  :             break;

  0006e	eb 02		 jmp	 SHORT $LN3@find_if
$LN5@find_if:

; 145  :         }
; 146  :     }

  00070	eb d2		 jmp	 SHORT $LN2@find_if
$LN3@find_if:

; 147  : 
; 148  :     _Seek_wrapped(_First, _UFirst);

  00072	8b 4d fc	 mov	 ecx, DWORD PTR __UFirst$[ebp]
  00075	51		 push	 ecx
  00076	8d 55 08	 lea	 edx, DWORD PTR __First$[ebp]
  00079	52		 push	 edx
  0007a	e8 00 00 00 00	 call	 ??$_Seek_wrapped@$$CBURGYErrMapMFX@@@std@@YAXAAPBURGYErrMapMFX@@QBU1@@Z ; std::_Seek_wrapped<RGYErrMapMFX const >
  0007f	83 c4 08	 add	 esp, 8

; 149  :     return _First;

  00082	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]

; 150  : }

  00085	83 c4 08	 add	 esp, 8
  00088	3b ec		 cmp	 ebp, esp
  0008a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c3		 ret	 0
??$find_if@PBURGYErrMapMFX@@V<lambda_dabac589461c7a2e6e1fe7373c988653>@@@std@@YAPBURGYErrMapMFX@@PBU1@QBU1@V<lambda_dabac589461c7a2e6e1fe7373c988653>@@@Z ENDP ; std::find_if<RGYErrMapMFX const *,<lambda_dabac589461c7a2e6e1fe7373c988653> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\rgy_err.cpp
;	COMDAT ??0<lambda_dabac589461c7a2e6e1fe7373c988653>@@QAE@ABW4mfxStatus@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_<err>$ = 8						; size = 4
??0<lambda_dabac589461c7a2e6e1fe7373c988653>@@QAE@ABW4mfxStatus@@@Z PROC ; <lambda_dabac589461c7a2e6e1fe7373c988653>::<lambda_dabac589461c7a2e6e1fe7373c988653>, COMDAT
; _this$ = ecx

; 89   :     });

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 4d 08	 mov	 ecx, DWORD PTR _<err>$[ebp]
  00014	8b 11		 mov	 edx, DWORD PTR [ecx]
  00016	89 10		 mov	 DWORD PTR [eax], edx
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??0<lambda_dabac589461c7a2e6e1fe7373c988653>@@QAE@ABW4mfxStatus@@@Z ENDP ; <lambda_dabac589461c7a2e6e1fe7373c988653>::<lambda_dabac589461c7a2e6e1fe7373c988653>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\rgy_err.cpp
;	COMDAT ??R<lambda_dabac589461c7a2e6e1fe7373c988653>@@QBE_NURGYErrMapMFX@@@Z
_TEXT	SEGMENT
tv66 = -8						; size = 4
_this$ = -4						; size = 4
_map$ = 8						; size = 8
??R<lambda_dabac589461c7a2e6e1fe7373c988653>@@QBE_NURGYErrMapMFX@@@Z PROC ; <lambda_dabac589461c7a2e6e1fe7373c988653>::operator(), COMDAT
; _this$ = ecx

; 87   :     auto ret = std::find_if((const RGYErrMapMFX *)ERR_MAP_MFX, ERR_MAP_FIN, [err](RGYErrMapMFX map) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 88   :         return map.mfx == err;

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b 4d 0c	 mov	 ecx, DWORD PTR _map$[ebp+4]
  0001d	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0001f	75 09		 jne	 SHORT $LN3@operator
  00021	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
  00028	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  0002a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
$LN4@operator:
  00031	8a 45 f8	 mov	 al, BYTE PTR tv66[ebp]

; 89   :     });

  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c2 08 00	 ret	 8
??R<lambda_dabac589461c7a2e6e1fe7373c988653>@@QBE_NURGYErrMapMFX@@@Z ENDP ; <lambda_dabac589461c7a2e6e1fe7373c988653>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\algorithm
;	COMDAT ??$find_if@PBURGYErrMapMFX@@V<lambda_7ea49bb70acf995ee16f3b0e1ba77072>@@@std@@YAPBURGYErrMapMFX@@PBU1@QBU1@V<lambda_7ea49bb70acf995ee16f3b0e1ba77072>@@@Z
_TEXT	SEGMENT
__ULast$ = -8						; size = 4
__UFirst$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$find_if@PBURGYErrMapMFX@@V<lambda_7ea49bb70acf995ee16f3b0e1ba77072>@@@std@@YAPBURGYErrMapMFX@@PBU1@QBU1@V<lambda_7ea49bb70acf995ee16f3b0e1ba77072>@@@Z PROC ; std::find_if<RGYErrMapMFX const *,<lambda_7ea49bb70acf995ee16f3b0e1ba77072> >, COMDAT

; 138  : _NODISCARD _InIt find_if(_InIt _First, const _InIt _Last, _Pr _Pred) { // find first satisfying _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 139  :     _Adl_verify_range(_First, _Last);

  00014	8d 45 0c	 lea	 eax, DWORD PTR __Last$[ebp]
  00017	50		 push	 eax
  00018	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0001b	51		 push	 ecx
  0001c	e8 00 00 00 00	 call	 ??$_Adl_verify_range@PBURGYErrMapMFX@@PBU1@@std@@YAXABQBURGYErrMapMFX@@0@Z ; std::_Adl_verify_range<RGYErrMapMFX const *,RGYErrMapMFX const *>
  00021	83 c4 08	 add	 esp, 8

; 140  :     auto _UFirst      = _Get_unwrapped(_First);

  00024	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00027	52		 push	 edx
  00028	e8 00 00 00 00	 call	 ??$_Get_unwrapped@$$CBURGYErrMapMFX@@@std@@YAPBURGYErrMapMFX@@QBU1@@Z ; std::_Get_unwrapped<RGYErrMapMFX const >
  0002d	83 c4 04	 add	 esp, 4
  00030	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax

; 141  :     const auto _ULast = _Get_unwrapped(_Last);

  00033	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 ??$_Get_unwrapped@$$CBURGYErrMapMFX@@@std@@YAPBURGYErrMapMFX@@QBU1@@Z ; std::_Get_unwrapped<RGYErrMapMFX const >
  0003c	83 c4 04	 add	 esp, 4
  0003f	89 45 f8	 mov	 DWORD PTR __ULast$[ebp], eax

; 142  :     for (; _UFirst != _ULast; ++_UFirst) {

  00042	eb 09		 jmp	 SHORT $LN4@find_if
$LN2@find_if:
  00044	8b 4d fc	 mov	 ecx, DWORD PTR __UFirst$[ebp]
  00047	83 c1 08	 add	 ecx, 8
  0004a	89 4d fc	 mov	 DWORD PTR __UFirst$[ebp], ecx
$LN4@find_if:
  0004d	8b 55 fc	 mov	 edx, DWORD PTR __UFirst$[ebp]
  00050	3b 55 f8	 cmp	 edx, DWORD PTR __ULast$[ebp]
  00053	74 1d		 je	 SHORT $LN3@find_if

; 143  :         if (_Pred(*_UFirst)) {

  00055	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00058	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005b	51		 push	 ecx
  0005c	8b 10		 mov	 edx, DWORD PTR [eax]
  0005e	52		 push	 edx
  0005f	8d 4d 10	 lea	 ecx, DWORD PTR __Pred$[ebp]
  00062	e8 00 00 00 00	 call	 ??R<lambda_7ea49bb70acf995ee16f3b0e1ba77072>@@QBE_NURGYErrMapMFX@@@Z ; <lambda_7ea49bb70acf995ee16f3b0e1ba77072>::operator()
  00067	0f b6 c0	 movzx	 eax, al
  0006a	85 c0		 test	 eax, eax
  0006c	74 02		 je	 SHORT $LN5@find_if

; 144  :             break;

  0006e	eb 02		 jmp	 SHORT $LN3@find_if
$LN5@find_if:

; 145  :         }
; 146  :     }

  00070	eb d2		 jmp	 SHORT $LN2@find_if
$LN3@find_if:

; 147  : 
; 148  :     _Seek_wrapped(_First, _UFirst);

  00072	8b 4d fc	 mov	 ecx, DWORD PTR __UFirst$[ebp]
  00075	51		 push	 ecx
  00076	8d 55 08	 lea	 edx, DWORD PTR __First$[ebp]
  00079	52		 push	 edx
  0007a	e8 00 00 00 00	 call	 ??$_Seek_wrapped@$$CBURGYErrMapMFX@@@std@@YAXAAPBURGYErrMapMFX@@QBU1@@Z ; std::_Seek_wrapped<RGYErrMapMFX const >
  0007f	83 c4 08	 add	 esp, 8

; 149  :     return _First;

  00082	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]

; 150  : }

  00085	83 c4 08	 add	 esp, 8
  00088	3b ec		 cmp	 ebp, esp
  0008a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c3		 ret	 0
??$find_if@PBURGYErrMapMFX@@V<lambda_7ea49bb70acf995ee16f3b0e1ba77072>@@@std@@YAPBURGYErrMapMFX@@PBU1@QBU1@V<lambda_7ea49bb70acf995ee16f3b0e1ba77072>@@@Z ENDP ; std::find_if<RGYErrMapMFX const *,<lambda_7ea49bb70acf995ee16f3b0e1ba77072> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\rgy_err.cpp
;	COMDAT ??0<lambda_7ea49bb70acf995ee16f3b0e1ba77072>@@QAE@ABW4RGY_ERR@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_<err>$ = 8						; size = 4
??0<lambda_7ea49bb70acf995ee16f3b0e1ba77072>@@QAE@ABW4RGY_ERR@@@Z PROC ; <lambda_7ea49bb70acf995ee16f3b0e1ba77072>::<lambda_7ea49bb70acf995ee16f3b0e1ba77072>, COMDAT
; _this$ = ecx

; 81   :     });

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 4d 08	 mov	 ecx, DWORD PTR _<err>$[ebp]
  00014	8b 11		 mov	 edx, DWORD PTR [ecx]
  00016	89 10		 mov	 DWORD PTR [eax], edx
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??0<lambda_7ea49bb70acf995ee16f3b0e1ba77072>@@QAE@ABW4RGY_ERR@@@Z ENDP ; <lambda_7ea49bb70acf995ee16f3b0e1ba77072>::<lambda_7ea49bb70acf995ee16f3b0e1ba77072>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\rgy_err.cpp
;	COMDAT ??R<lambda_7ea49bb70acf995ee16f3b0e1ba77072>@@QBE_NURGYErrMapMFX@@@Z
_TEXT	SEGMENT
tv66 = -8						; size = 4
_this$ = -4						; size = 4
_map$ = 8						; size = 8
??R<lambda_7ea49bb70acf995ee16f3b0e1ba77072>@@QBE_NURGYErrMapMFX@@@Z PROC ; <lambda_7ea49bb70acf995ee16f3b0e1ba77072>::operator(), COMDAT
; _this$ = ecx

; 79   :     auto ret = std::find_if((const RGYErrMapMFX *)ERR_MAP_MFX, ERR_MAP_FIN, [err](RGYErrMapMFX map) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 80   :         return map.rgy == err;

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR _map$[ebp]
  0001d	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0001f	75 09		 jne	 SHORT $LN3@operator
  00021	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
  00028	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  0002a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
$LN4@operator:
  00031	8a 45 f8	 mov	 al, BYTE PTR tv66[ebp]

; 81   :     });

  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c2 08 00	 ret	 8
??R<lambda_7ea49bb70acf995ee16f3b0e1ba77072>@@QBE_NURGYErrMapMFX@@@Z ENDP ; <lambda_7ea49bb70acf995ee16f3b0e1ba77072>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\rgy_err.cpp
_TEXT	SEGMENT
tv64 = -4						; size = 4
_sts$ = 8						; size = 4
?get_err_mes@@YAPBDW4RGY_ERR@@@Z PROC			; get_err_mes

; 201  : const TCHAR *get_err_mes(RGY_ERR sts) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 202  :     switch (sts) {

  0000b	8b 45 08	 mov	 eax, DWORD PTR _sts$[ebp]
  0000e	89 45 fc	 mov	 DWORD PTR tv64[ebp], eax
  00011	8b 4d fc	 mov	 ecx, DWORD PTR tv64[ebp]
  00014	83 c1 28	 add	 ecx, 40			; 00000028H
  00017	89 4d fc	 mov	 DWORD PTR tv64[ebp], ecx
  0001a	83 7d fc 2f	 cmp	 DWORD PTR tv64[ebp], 47	; 0000002fH
  0001e	0f 87 96 01 00
	00		 ja	 $LN49@get_err_me
  00024	8b 55 fc	 mov	 edx, DWORD PTR tv64[ebp]
  00027	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN51@get_err_me[edx*4]
$LN4@get_err_me:

; 203  :     case RGY_ERR_NONE:                     return _T("no error.");

  0002e	b8 00 00 00 00	 mov	 eax, OFFSET $SG59299
  00033	e9 87 01 00 00	 jmp	 $LN1@get_err_me
$LN5@get_err_me:

; 204  :     case RGY_ERR_UNKNOWN:                  return _T("unknown error.");

  00038	b8 00 00 00 00	 mov	 eax, OFFSET $SG59301
  0003d	e9 7d 01 00 00	 jmp	 $LN1@get_err_me
$LN6@get_err_me:

; 205  :     case RGY_ERR_NULL_PTR:                 return _T("null pointer.");

  00042	b8 00 00 00 00	 mov	 eax, OFFSET $SG59303
  00047	e9 73 01 00 00	 jmp	 $LN1@get_err_me
$LN7@get_err_me:

; 206  :     case RGY_ERR_UNSUPPORTED:              return _T("undeveloped feature.");

  0004c	b8 00 00 00 00	 mov	 eax, OFFSET $SG59305
  00051	e9 69 01 00 00	 jmp	 $LN1@get_err_me
$LN8@get_err_me:

; 207  :     case RGY_ERR_MEMORY_ALLOC:             return _T("failed to allocate memory.");

  00056	b8 00 00 00 00	 mov	 eax, OFFSET $SG59307
  0005b	e9 5f 01 00 00	 jmp	 $LN1@get_err_me
$LN9@get_err_me:

; 208  :     case RGY_ERR_NOT_ENOUGH_BUFFER:        return _T("insufficient buffer at input/output.");

  00060	b8 00 00 00 00	 mov	 eax, OFFSET $SG59309
  00065	e9 55 01 00 00	 jmp	 $LN1@get_err_me
$LN10@get_err_me:

; 209  :     case RGY_ERR_INVALID_HANDLE:           return _T("invalid handle.");

  0006a	b8 00 00 00 00	 mov	 eax, OFFSET $SG59311
  0006f	e9 4b 01 00 00	 jmp	 $LN1@get_err_me
$LN11@get_err_me:

; 210  :     case RGY_ERR_LOCK_MEMORY:              return _T("failed to lock the memory block.");

  00074	b8 00 00 00 00	 mov	 eax, OFFSET $SG59313
  00079	e9 41 01 00 00	 jmp	 $LN1@get_err_me
$LN12@get_err_me:

; 211  :     case RGY_ERR_NOT_INITIALIZED:          return _T("member function called before initialization.");

  0007e	b8 00 00 00 00	 mov	 eax, OFFSET $SG59315
  00083	e9 37 01 00 00	 jmp	 $LN1@get_err_me
$LN13@get_err_me:

; 212  :     case RGY_ERR_NOT_FOUND:                return _T("the specified object is not found.");

  00088	b8 00 00 00 00	 mov	 eax, OFFSET $SG59317
  0008d	e9 2d 01 00 00	 jmp	 $LN1@get_err_me
$LN14@get_err_me:

; 213  :     case RGY_ERR_MORE_DATA:                return _T("expect more data at input.");

  00092	b8 00 00 00 00	 mov	 eax, OFFSET $SG59319
  00097	e9 23 01 00 00	 jmp	 $LN1@get_err_me
$LN15@get_err_me:

; 214  :     case RGY_ERR_MORE_SURFACE:             return _T("expect more surface at output.");

  0009c	b8 00 00 00 00	 mov	 eax, OFFSET $SG59321
  000a1	e9 19 01 00 00	 jmp	 $LN1@get_err_me
$LN16@get_err_me:

; 215  :     case RGY_ERR_ABORTED:                  return _T("operation aborted.");

  000a6	b8 00 00 00 00	 mov	 eax, OFFSET $SG59323
  000ab	e9 0f 01 00 00	 jmp	 $LN1@get_err_me
$LN17@get_err_me:

; 216  :     case RGY_ERR_DEVICE_LOST:              return _T("lose the HW acceleration device.");

  000b0	b8 00 00 00 00	 mov	 eax, OFFSET $SG59325
  000b5	e9 05 01 00 00	 jmp	 $LN1@get_err_me
$LN18@get_err_me:

; 217  :     case RGY_ERR_INCOMPATIBLE_VIDEO_PARAM: return _T("incompatible video parameters.");

  000ba	b8 00 00 00 00	 mov	 eax, OFFSET $SG59327
  000bf	e9 fb 00 00 00	 jmp	 $LN1@get_err_me
$LN19@get_err_me:

; 218  :     case RGY_ERR_INVALID_VIDEO_PARAM:      return _T("invalid video parameters.");

  000c4	b8 00 00 00 00	 mov	 eax, OFFSET $SG59329
  000c9	e9 f1 00 00 00	 jmp	 $LN1@get_err_me
$LN20@get_err_me:

; 219  :     case RGY_ERR_UNDEFINED_BEHAVIOR:       return _T("undefined behavior.");

  000ce	b8 00 00 00 00	 mov	 eax, OFFSET $SG59331
  000d3	e9 e7 00 00 00	 jmp	 $LN1@get_err_me
$LN21@get_err_me:

; 220  :     case RGY_ERR_DEVICE_FAILED:            return _T("device operation failure.");

  000d8	b8 00 00 00 00	 mov	 eax, OFFSET $SG59333
  000dd	e9 dd 00 00 00	 jmp	 $LN1@get_err_me
$LN22@get_err_me:

; 221  :     case RGY_ERR_GPU_HANG:                 return _T("gpu hang.");

  000e2	b8 00 00 00 00	 mov	 eax, OFFSET $SG59335
  000e7	e9 d3 00 00 00	 jmp	 $LN1@get_err_me
$LN23@get_err_me:

; 222  :     case RGY_ERR_REALLOC_SURFACE:          return _T("failed to realloc surface.");

  000ec	b8 00 00 00 00	 mov	 eax, OFFSET $SG59337
  000f1	e9 c9 00 00 00	 jmp	 $LN1@get_err_me
$LN24@get_err_me:

; 223  :     case RGY_ERR_ACCESS_DENIED:            return _T("access denied");

  000f6	b8 00 00 00 00	 mov	 eax, OFFSET $SG59339
  000fb	e9 bf 00 00 00	 jmp	 $LN1@get_err_me
$LN25@get_err_me:

; 224  :     case RGY_ERR_INVALID_PARAM:            return _T("invalid param.");

  00100	b8 00 00 00 00	 mov	 eax, OFFSET $SG59341
  00105	e9 b5 00 00 00	 jmp	 $LN1@get_err_me
$LN26@get_err_me:

; 225  :     case RGY_ERR_OUT_OF_RANGE:             return _T("out pf range.");

  0010a	b8 00 00 00 00	 mov	 eax, OFFSET $SG59343
  0010f	e9 ab 00 00 00	 jmp	 $LN1@get_err_me
$LN27@get_err_me:

; 226  :     case RGY_ERR_ALREADY_INITIALIZED:      return _T("already initialized.");

  00114	b8 00 00 00 00	 mov	 eax, OFFSET $SG59345
  00119	e9 a1 00 00 00	 jmp	 $LN1@get_err_me
$LN28@get_err_me:

; 227  :     case RGY_ERR_INVALID_FORMAT:           return _T("invalid format.");

  0011e	b8 00 00 00 00	 mov	 eax, OFFSET $SG59347
  00123	e9 97 00 00 00	 jmp	 $LN1@get_err_me
$LN29@get_err_me:

; 228  :     case RGY_ERR_WRONG_STATE:              return _T("wrong state.");

  00128	b8 00 00 00 00	 mov	 eax, OFFSET $SG59349
  0012d	e9 8d 00 00 00	 jmp	 $LN1@get_err_me
$LN30@get_err_me:

; 229  :     case RGY_ERR_FILE_OPEN:                return _T("file open error.");

  00132	b8 00 00 00 00	 mov	 eax, OFFSET $SG59351
  00137	e9 83 00 00 00	 jmp	 $LN1@get_err_me
$LN31@get_err_me:

; 230  :     case RGY_ERR_INPUT_FULL:               return _T("input full.");

  0013c	b8 00 00 00 00	 mov	 eax, OFFSET $SG59353
  00141	eb 7c		 jmp	 SHORT $LN1@get_err_me
$LN32@get_err_me:

; 231  :     case RGY_ERR_INVALID_CODEC:            return _T("invalid codec.");

  00143	b8 00 00 00 00	 mov	 eax, OFFSET $SG59355
  00148	eb 75		 jmp	 SHORT $LN1@get_err_me
$LN33@get_err_me:

; 232  :     case RGY_ERR_INVALID_DATA_TYPE:        return _T("invalid data type.");

  0014a	b8 00 00 00 00	 mov	 eax, OFFSET $SG59357
  0014f	eb 6e		 jmp	 SHORT $LN1@get_err_me
$LN34@get_err_me:

; 233  :     case RGY_ERR_INVALID_RESOLUTION:       return _T("invaldi resolution.");

  00151	b8 00 00 00 00	 mov	 eax, OFFSET $SG59359
  00156	eb 67		 jmp	 SHORT $LN1@get_err_me
$LN35@get_err_me:

; 234  :     case RGY_ERR_INVALID_DEVICE:           return _T("invalid devices.");

  00158	b8 00 00 00 00	 mov	 eax, OFFSET $SG59361
  0015d	eb 60		 jmp	 SHORT $LN1@get_err_me
$LN36@get_err_me:

; 235  :     case RGY_ERR_INVALID_CALL:             return _T("invalid call sequence.");

  0015f	b8 00 00 00 00	 mov	 eax, OFFSET $SG59363
  00164	eb 59		 jmp	 SHORT $LN1@get_err_me
$LN37@get_err_me:

; 236  :     case RGY_ERR_NO_DEVICE:                return _T("no deivce found.");

  00166	b8 00 00 00 00	 mov	 eax, OFFSET $SG59365
  0016b	eb 52		 jmp	 SHORT $LN1@get_err_me
$LN38@get_err_me:

; 237  :     case RGY_ERR_INVALID_VERSION:          return _T("invalid version.");

  0016d	b8 00 00 00 00	 mov	 eax, OFFSET $SG59367
  00172	eb 4b		 jmp	 SHORT $LN1@get_err_me
$LN39@get_err_me:

; 238  :     case RGY_ERR_MAP_FAILED:               return _T("map failed.");

  00174	b8 00 00 00 00	 mov	 eax, OFFSET $SG59369
  00179	eb 44		 jmp	 SHORT $LN1@get_err_me
$LN40@get_err_me:

; 239  :     case RGY_ERR_CUDA:                     return _T("error in cuda.");

  0017b	b8 00 00 00 00	 mov	 eax, OFFSET $SG59371
  00180	eb 3d		 jmp	 SHORT $LN1@get_err_me
$LN41@get_err_me:

; 240  :     case RGY_ERR_RUN_PROCESS:              return _T("running process failed.");

  00182	b8 00 00 00 00	 mov	 eax, OFFSET $SG59373
  00187	eb 36		 jmp	 SHORT $LN1@get_err_me
$LN42@get_err_me:

; 241  :     case RGY_WRN_IN_EXECUTION:             return _T("the previous asynchrous operation is in execution.");

  00189	b8 00 00 00 00	 mov	 eax, OFFSET $SG59375
  0018e	eb 2f		 jmp	 SHORT $LN1@get_err_me
$LN43@get_err_me:

; 242  :     case RGY_WRN_DEVICE_BUSY:              return _T("the HW acceleration device is busy.");

  00190	b8 00 00 00 00	 mov	 eax, OFFSET $SG59377
  00195	eb 28		 jmp	 SHORT $LN1@get_err_me
$LN44@get_err_me:

; 243  :     case RGY_WRN_VIDEO_PARAM_CHANGED:      return _T("the video parameters are changed during decoding.");

  00197	b8 00 00 00 00	 mov	 eax, OFFSET $SG59379
  0019c	eb 21		 jmp	 SHORT $LN1@get_err_me
$LN45@get_err_me:

; 244  :     case RGY_WRN_PARTIAL_ACCELERATION:     return _T("SW is used.");

  0019e	b8 00 00 00 00	 mov	 eax, OFFSET $SG59381
  001a3	eb 1a		 jmp	 SHORT $LN1@get_err_me
$LN46@get_err_me:

; 245  :     case RGY_WRN_INCOMPATIBLE_VIDEO_PARAM: return _T("incompatible video parameters.");

  001a5	b8 00 00 00 00	 mov	 eax, OFFSET $SG59383
  001aa	eb 13		 jmp	 SHORT $LN1@get_err_me
$LN47@get_err_me:

; 246  :     case RGY_WRN_VALUE_NOT_CHANGED:        return _T("the value is saturated based on its valid range.");

  001ac	b8 00 00 00 00	 mov	 eax, OFFSET $SG59385
  001b1	eb 0c		 jmp	 SHORT $LN1@get_err_me
$LN48@get_err_me:

; 247  :     case RGY_WRN_OUT_OF_RANGE:             return _T("the value is out of valid range.");

  001b3	b8 00 00 00 00	 mov	 eax, OFFSET $SG59387
  001b8	eb 05		 jmp	 SHORT $LN1@get_err_me
$LN49@get_err_me:

; 248  :     default:                               return _T("unknown error.");

  001ba	b8 00 00 00 00	 mov	 eax, OFFSET $SG59389
$LN1@get_err_me:

; 249  :     }
; 250  : }

  001bf	8b e5		 mov	 esp, ebp
  001c1	5d		 pop	 ebp
  001c2	c3		 ret	 0
  001c3	90		 npad	 1
$LN51@get_err_me:
  001c4	00 00 00 00	 DD	 $LN41@get_err_me
  001c8	00 00 00 00	 DD	 $LN40@get_err_me
  001cc	00 00 00 00	 DD	 $LN39@get_err_me
  001d0	00 00 00 00	 DD	 $LN38@get_err_me
  001d4	00 00 00 00	 DD	 $LN36@get_err_me
  001d8	00 00 00 00	 DD	 $LN35@get_err_me
  001dc	00 00 00 00	 DD	 $LN37@get_err_me
  001e0	00 00 00 00	 DD	 $LN34@get_err_me
  001e4	00 00 00 00	 DD	 $LN33@get_err_me
  001e8	00 00 00 00	 DD	 $LN32@get_err_me
  001ec	00 00 00 00	 DD	 $LN31@get_err_me
  001f0	00 00 00 00	 DD	 $LN30@get_err_me
  001f4	00 00 00 00	 DD	 $LN29@get_err_me
  001f8	00 00 00 00	 DD	 $LN28@get_err_me
  001fc	00 00 00 00	 DD	 $LN27@get_err_me
  00200	00 00 00 00	 DD	 $LN26@get_err_me
  00204	00 00 00 00	 DD	 $LN25@get_err_me
  00208	00 00 00 00	 DD	 $LN24@get_err_me
  0020c	00 00 00 00	 DD	 $LN23@get_err_me
  00210	00 00 00 00	 DD	 $LN22@get_err_me
  00214	00 00 00 00	 DD	 $LN49@get_err_me
  00218	00 00 00 00	 DD	 $LN49@get_err_me
  0021c	00 00 00 00	 DD	 $LN49@get_err_me
  00220	00 00 00 00	 DD	 $LN21@get_err_me
  00224	00 00 00 00	 DD	 $LN20@get_err_me
  00228	00 00 00 00	 DD	 $LN19@get_err_me
  0022c	00 00 00 00	 DD	 $LN18@get_err_me
  00230	00 00 00 00	 DD	 $LN17@get_err_me
  00234	00 00 00 00	 DD	 $LN16@get_err_me
  00238	00 00 00 00	 DD	 $LN15@get_err_me
  0023c	00 00 00 00	 DD	 $LN14@get_err_me
  00240	00 00 00 00	 DD	 $LN13@get_err_me
  00244	00 00 00 00	 DD	 $LN12@get_err_me
  00248	00 00 00 00	 DD	 $LN11@get_err_me
  0024c	00 00 00 00	 DD	 $LN10@get_err_me
  00250	00 00 00 00	 DD	 $LN9@get_err_me
  00254	00 00 00 00	 DD	 $LN8@get_err_me
  00258	00 00 00 00	 DD	 $LN7@get_err_me
  0025c	00 00 00 00	 DD	 $LN6@get_err_me
  00260	00 00 00 00	 DD	 $LN5@get_err_me
  00264	00 00 00 00	 DD	 $LN4@get_err_me
  00268	00 00 00 00	 DD	 $LN42@get_err_me
  0026c	00 00 00 00	 DD	 $LN43@get_err_me
  00270	00 00 00 00	 DD	 $LN44@get_err_me
  00274	00 00 00 00	 DD	 $LN45@get_err_me
  00278	00 00 00 00	 DD	 $LN46@get_err_me
  0027c	00 00 00 00	 DD	 $LN47@get_err_me
  00280	00 00 00 00	 DD	 $LN48@get_err_me
?get_err_mes@@YAPBDW4RGY_ERR@@@Z ENDP			; get_err_mes
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\rgy_err.cpp
_TEXT	SEGMENT
tv74 = -16						; size = 4
$T1 = -12						; size = 4
_ret$ = -8						; size = 4
_ERR_MAP_FIN$ = -4					; size = 4
_err$ = 8						; size = 4
?err_to_rgy@@YA?AW4RGY_ERR@@W4mfxStatus@@@Z PROC	; err_to_rgy

; 85   : RGY_ERR err_to_rgy(mfxStatus err) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000e	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00011	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00014	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 86   :     const RGYErrMapMFX *ERR_MAP_FIN = (const RGYErrMapMFX *)ERR_MAP_MFX + _countof(ERR_MAP_MFX);

  00017	c7 45 fc 08 01
	00 00		 mov	 DWORD PTR _ERR_MAP_FIN$[ebp], OFFSET ?ERR_MAP_MFX@@3QBURGYErrMapMFX@@B+264

; 87   :     auto ret = std::find_if((const RGYErrMapMFX *)ERR_MAP_MFX, ERR_MAP_FIN, [err](RGYErrMapMFX map) {

  0001e	8d 45 08	 lea	 eax, DWORD PTR _err$[ebp]
  00021	50		 push	 eax
  00022	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00025	e8 00 00 00 00	 call	 ??0<lambda_dabac589461c7a2e6e1fe7373c988653>@@QAE@ABW4mfxStatus@@@Z ; <lambda_dabac589461c7a2e6e1fe7373c988653>::<lambda_dabac589461c7a2e6e1fe7373c988653>
  0002a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002c	51		 push	 ecx
  0002d	8b 55 fc	 mov	 edx, DWORD PTR _ERR_MAP_FIN$[ebp]
  00030	52		 push	 edx
  00031	68 00 00 00 00	 push	 OFFSET ?ERR_MAP_MFX@@3QBURGYErrMapMFX@@B
  00036	e8 00 00 00 00	 call	 ??$find_if@PBURGYErrMapMFX@@V<lambda_dabac589461c7a2e6e1fe7373c988653>@@@std@@YAPBURGYErrMapMFX@@PBU1@QBU1@V<lambda_dabac589461c7a2e6e1fe7373c988653>@@@Z ; std::find_if<RGYErrMapMFX const *,<lambda_dabac589461c7a2e6e1fe7373c988653> >
  0003b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003e	89 45 f8	 mov	 DWORD PTR _ret$[ebp], eax

; 88   :         return map.mfx == err;
; 89   :     });
; 90   :     return (ret == ERR_MAP_FIN) ? RGY_ERR_UNKNOWN : ret->rgy;

  00041	8b 45 f8	 mov	 eax, DWORD PTR _ret$[ebp]
  00044	3b 45 fc	 cmp	 eax, DWORD PTR _ERR_MAP_FIN$[ebp]
  00047	75 09		 jne	 SHORT $LN3@err_to_rgy
  00049	c7 45 f0 ff ff
	ff ff		 mov	 DWORD PTR tv74[ebp], -1
  00050	eb 08		 jmp	 SHORT $LN4@err_to_rgy
$LN3@err_to_rgy:
  00052	8b 4d f8	 mov	 ecx, DWORD PTR _ret$[ebp]
  00055	8b 11		 mov	 edx, DWORD PTR [ecx]
  00057	89 55 f0	 mov	 DWORD PTR tv74[ebp], edx
$LN4@err_to_rgy:
  0005a	8b 45 f0	 mov	 eax, DWORD PTR tv74[ebp]

; 91   : }

  0005d	83 c4 10	 add	 esp, 16			; 00000010H
  00060	3b ec		 cmp	 ebp, esp
  00062	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
?err_to_rgy@@YA?AW4RGY_ERR@@W4mfxStatus@@@Z ENDP	; err_to_rgy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\rgy_err.cpp
_TEXT	SEGMENT
tv74 = -16						; size = 4
$T1 = -12						; size = 4
_ret$ = -8						; size = 4
_ERR_MAP_FIN$ = -4					; size = 4
_err$ = 8						; size = 4
?err_to_mfx@@YA?AW4mfxStatus@@W4RGY_ERR@@@Z PROC	; err_to_mfx

; 77   : mfxStatus err_to_mfx(RGY_ERR err) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000e	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00011	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00014	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 78   :     const RGYErrMapMFX *ERR_MAP_FIN = (const RGYErrMapMFX *)ERR_MAP_MFX + _countof(ERR_MAP_MFX);

  00017	c7 45 fc 08 01
	00 00		 mov	 DWORD PTR _ERR_MAP_FIN$[ebp], OFFSET ?ERR_MAP_MFX@@3QBURGYErrMapMFX@@B+264

; 79   :     auto ret = std::find_if((const RGYErrMapMFX *)ERR_MAP_MFX, ERR_MAP_FIN, [err](RGYErrMapMFX map) {

  0001e	8d 45 08	 lea	 eax, DWORD PTR _err$[ebp]
  00021	50		 push	 eax
  00022	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00025	e8 00 00 00 00	 call	 ??0<lambda_7ea49bb70acf995ee16f3b0e1ba77072>@@QAE@ABW4RGY_ERR@@@Z ; <lambda_7ea49bb70acf995ee16f3b0e1ba77072>::<lambda_7ea49bb70acf995ee16f3b0e1ba77072>
  0002a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002c	51		 push	 ecx
  0002d	8b 55 fc	 mov	 edx, DWORD PTR _ERR_MAP_FIN$[ebp]
  00030	52		 push	 edx
  00031	68 00 00 00 00	 push	 OFFSET ?ERR_MAP_MFX@@3QBURGYErrMapMFX@@B
  00036	e8 00 00 00 00	 call	 ??$find_if@PBURGYErrMapMFX@@V<lambda_7ea49bb70acf995ee16f3b0e1ba77072>@@@std@@YAPBURGYErrMapMFX@@PBU1@QBU1@V<lambda_7ea49bb70acf995ee16f3b0e1ba77072>@@@Z ; std::find_if<RGYErrMapMFX const *,<lambda_7ea49bb70acf995ee16f3b0e1ba77072> >
  0003b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003e	89 45 f8	 mov	 DWORD PTR _ret$[ebp], eax

; 80   :         return map.rgy == err;
; 81   :     });
; 82   :     return (ret == ERR_MAP_FIN) ? MFX_ERR_UNKNOWN : ret->mfx;

  00041	8b 45 f8	 mov	 eax, DWORD PTR _ret$[ebp]
  00044	3b 45 fc	 cmp	 eax, DWORD PTR _ERR_MAP_FIN$[ebp]
  00047	75 09		 jne	 SHORT $LN3@err_to_mfx
  00049	c7 45 f0 ff ff
	ff ff		 mov	 DWORD PTR tv74[ebp], -1
  00050	eb 09		 jmp	 SHORT $LN4@err_to_mfx
$LN3@err_to_mfx:
  00052	8b 4d f8	 mov	 ecx, DWORD PTR _ret$[ebp]
  00055	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00058	89 55 f0	 mov	 DWORD PTR tv74[ebp], edx
$LN4@err_to_mfx:
  0005b	8b 45 f0	 mov	 eax, DWORD PTR tv74[ebp]

; 83   : }

  0005e	83 c4 10	 add	 esp, 16			; 00000010H
  00061	3b ec		 cmp	 ebp, esp
  00063	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
?err_to_mfx@@YA?AW4mfxStatus@@W4RGY_ERR@@@Z ENDP	; err_to_mfx
_TEXT	ENDS
END
