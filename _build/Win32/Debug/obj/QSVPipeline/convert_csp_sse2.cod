; Listing generated by Microsoft (R) Optimizing Compiler Version 19.23.28106.4 

	TITLE	D:\work\intel\intel_codec\QSVPipeline\convert_csp_sse2.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG7036	DB	'Invalid', 00H
$SG7037	DB	'nv12', 00H
	ORG $+3
$SG7038	DB	'yv12', 00H
	ORG $+3
$SG7039	DB	'yuy2', 00H
	ORG $+3
$SG7040	DB	'yuv422', 00H
	ORG $+1
$SG7041	DB	'nv16', 00H
	ORG $+3
$SG7042	DB	'yuv444', 00H
	ORG $+1
$SG7043	DB	'yv12(9bit)', 00H
	ORG $+1
$SG7044	DB	'yv12(10bit)', 00H
$SG7045	DB	'yv12(12bit)', 00H
$SG7046	DB	'yv12(14bit)', 00H
$SG7047	DB	'yv12(16bit)', 00H
$SG7048	DB	'p010', 00H
	ORG $+3
$SG7049	DB	'yuv422(9bit)', 00H
	ORG $+3
$SG7050	DB	'yuv422(10bit)', 00H
	ORG $+2
$SG7051	DB	'yuv422(12bit)', 00H
	ORG $+2
$SG7052	DB	'yuv422(14bit)', 00H
	ORG $+2
$SG7053	DB	'yuv422(16bit)', 00H
	ORG $+2
$SG7054	DB	'p210', 00H
	ORG $+3
$SG7055	DB	'yuv444(9bit)', 00H
	ORG $+3
$SG7056	DB	'yuv444(10bit)', 00H
	ORG $+2
$SG7057	DB	'yuv444(12bit)', 00H
	ORG $+2
$SG7058	DB	'yuv444(14bit)', 00H
	ORG $+2
$SG7059	DB	'yuv444(16bit)', 00H
	ORG $+2
$SG7060	DB	'yuva444', 00H
$SG7061	DB	'yuva444(16bit)', 00H
	ORG $+1
$SG7062	DB	'rgb24r', 00H
	ORG $+1
$SG7063	DB	'rgb32r', 00H
	ORG $+1
$SG7064	DB	'rgb24', 00H
	ORG $+2
$SG7065	DB	'rgb32', 00H
	ORG $+2
$SG7066	DB	'bgr24', 00H
	ORG $+2
$SG7067	DB	'bgr32', 00H
	ORG $+2
$SG7068	DB	'rgb', 00H
$SG7069	DB	'rgba', 00H
	ORG $+3
$SG7070	DB	'gbr', 00H
$SG7071	DB	'gbra', 00H
	ORG $+3
$SG7072	DB	'yc48', 00H
	ORG $+3
$SG7073	DB	'y8', 00H
	ORG $+1
$SG7074	DB	'yc16', 00H
	ORG $+11
?Array_Y_L_MA_16@@3QBFB DW 0dbH				; Array_Y_L_MA_16
	DW	01H
	DW	0dbH
	DW	01H
	DW	0dbH
	DW	01H
	DW	0dbH
	DW	01H
	DW	0dbH
	DW	01H
	DW	0dbH
	DW	01H
	DW	0dbH
	DW	01H
	DW	0dbH
	DW	01H
?Array_UV_L_MA_16_420P@@3QBFB DW 0eH			; Array_UV_L_MA_16_420P
	DW	00H
	DW	0eH
	DW	00H
	DW	0eH
	DW	00H
	DW	0eH
	DW	00H
	DW	0eH
	DW	00H
	DW	0eH
	DW	00H
	DW	0eH
	DW	00H
	DW	0eH
	DW	00H
?Array_UV_L_MA_16_420I@@3QAY0BA@$$CBFA DW 02aH		; Array_UV_L_MA_16_420I
	DW	00H
	DW	02aH
	DW	00H
	DW	02aH
	DW	00H
	DW	02aH
	DW	00H
	DW	02aH
	DW	00H
	DW	02aH
	DW	00H
	DW	02aH
	DW	00H
	DW	02aH
	DW	00H
	DW	0eH
	DW	00H
	DW	0eH
	DW	00H
	DW	0eH
	DW	00H
	DW	0eH
	DW	00H
	DW	0eH
	DW	00H
	DW	0eH
	DW	00H
	DW	0eH
	DW	00H
	DW	0eH
	DW	00H
?Array_UV_L_MA_16_444@@3QBFB DW 0eH			; Array_UV_L_MA_16_444
	DW	00H
	DW	0eH
	DW	00H
	DW	0eH
	DW	00H
	DW	0eH
	DW	00H
	DW	0eH
	DW	00H
	DW	0eH
	DW	00H
	DW	0eH
	DW	00H
	DW	0eH
	DW	00H
?Array_MASK_YCP2Y@@3QAY0BA@$$CBFA DW 00H		; Array_MASK_YCP2Y
	DW	0ffffH
	DW	00H
	DW	00H
	DW	0ffffH
	DW	00H
	DW	00H
	DW	0ffffH
	DW	00H
	DW	0ffffH
	DW	00H
	DW	00H
	DW	0ffffH
	DW	00H
	DW	00H
	DW	0ffffH
	DW	00H
	DW	00H
	DW	0ffffH
	DW	00H
	DW	00H
	DW	0ffffH
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	0ffffH
	DW	00H
	DW	00H
	DW	0ffffH
	DW	00H
	DW	00H
?Array_MASK_YCP2UV@@3QAY0BA@$$CBFA DW 0ffffH		; Array_MASK_YCP2UV
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	0ffffH
	DW	0ffffH
	DW	00H
	DW	0ffffH
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	0ffffH
	DW	0ffffH
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	0ffffH
	DW	0ffffH
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	0ffffH
	DW	0ffffH
	DW	00H
	DW	00H
	DW	00H
CONST	ENDS
PUBLIC	?copy_nv12_to_nv12_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; copy_nv12_to_nv12_sse2
PUBLIC	?copy_p010_to_p010_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; copy_p010_to_p010_sse2
PUBLIC	?convert_yuy2_to_nv12_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuy2_to_nv12_sse2
PUBLIC	?convert_yuy2_to_nv12_i_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuy2_to_nv12_i_sse2
PUBLIC	?convert_yv12_to_nv12_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_to_nv12_sse2
PUBLIC	?convert_uv_yv12_to_nv12_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_uv_yv12_to_nv12_sse2
PUBLIC	?convert_gbr_to_rgb32_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_gbr_to_rgb32_sse2
PUBLIC	?convert_rgb32_to_rgb_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_rgb32_to_rgb_sse2
PUBLIC	?convert_bgr32_to_rgb_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_bgr32_to_rgb_sse2
PUBLIC	?convert_rgb32r_to_rgb_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_rgb32r_to_rgb_sse2
PUBLIC	?convert_rgb24_to_rgb24_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_rgb24_to_rgb24_sse2
PUBLIC	??$convert_rgb24_to_rgb24_simd@$0BM@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_rgb24_to_rgb24_simd<28>
PUBLIC	?convert_rgb32_to_rgb32_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_rgb32_to_rgb32_sse2
PUBLIC	??$convert_rgb32_to_rgb32_simd@$0BN@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_rgb32_to_rgb32_simd<29>
PUBLIC	?convert_rgb24r_to_rgb24_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_rgb24r_to_rgb24_sse2
PUBLIC	?convert_rgb32r_to_rgb32_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_rgb32r_to_rgb32_sse2
PUBLIC	?copy_rgb_to_rgb_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; copy_rgb_to_rgb_sse2
PUBLIC	??$copy_rgb_to_rgb@$0PPACABAA@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; copy_rgb_to_rgb<4278321408>
PUBLIC	?copy_gbr_to_rgb_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; copy_gbr_to_rgb_sse2
PUBLIC	??$copy_rgb_to_rgb@$0PPABAAAC@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; copy_rgb_to_rgb<4278255618>
PUBLIC	?convert_yv12_to_p010_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_to_p010_sse2
PUBLIC	?convert_yv12_16_to_nv12_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_16_to_nv12_sse2
PUBLIC	?convert_yv12_14_to_nv12_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_14_to_nv12_sse2
PUBLIC	?convert_yv12_12_to_nv12_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_12_to_nv12_sse2
PUBLIC	?convert_yv12_10_to_nv12_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_10_to_nv12_sse2
PUBLIC	?convert_yv12_09_to_nv12_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_09_to_nv12_sse2
PUBLIC	?convert_yv12_16_to_p010_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_16_to_p010_sse2
PUBLIC	?convert_yv12_14_to_p010_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_14_to_p010_sse2
PUBLIC	?convert_yv12_12_to_p010_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_12_to_p010_sse2
PUBLIC	?convert_yv12_10_to_p010_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_10_to_p010_sse2
PUBLIC	?convert_yv12_09_to_p010_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_09_to_p010_sse2
PUBLIC	?convert_yc48_to_p010_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yc48_to_p010_sse2
PUBLIC	?convert_yc48_to_p010_i_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yc48_to_p010_i_sse2
PUBLIC	?copy_yuv444_to_yuv444_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; copy_yuv444_to_yuv444_sse2
PUBLIC	?convert_yuv444_16_to_yuv444_16_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_16_to_yuv444_16_sse2
PUBLIC	?convert_yuv444_14_to_yuv444_16_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_14_to_yuv444_16_sse2
PUBLIC	?convert_yuv444_12_to_yuv444_16_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_12_to_yuv444_16_sse2
PUBLIC	?convert_yuv444_10_to_yuv444_16_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_10_to_yuv444_16_sse2
PUBLIC	?convert_yuv444_09_to_yuv444_16_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_09_to_yuv444_16_sse2
PUBLIC	?convert_yuv444_to_yuv444_16_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_to_yuv444_16_sse2
PUBLIC	?convert_yuv444_16_to_yuv444_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_16_to_yuv444_sse2
PUBLIC	?convert_yuv444_14_to_yuv444_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_14_to_yuv444_sse2
PUBLIC	?convert_yuv444_12_to_yuv444_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_12_to_yuv444_sse2
PUBLIC	?convert_yuv444_10_to_yuv444_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_10_to_yuv444_sse2
PUBLIC	?convert_yuv444_09_to_yuv444_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_09_to_yuv444_sse2
PUBLIC	?convert_yc48_to_yuv444_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yc48_to_yuv444_sse2
PUBLIC	?convert_yc48_to_yuv444_16bit_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yc48_to_yuv444_16bit_sse2
PUBLIC	?convert_yuv444_16bit_to_yc48_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_16bit_to_yc48_sse2
PUBLIC	?convert_yuv422_to_nv16_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv422_to_nv16_sse2
PUBLIC	?convert_yuv422_to_p210_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv422_to_p210_sse2
PUBLIC	?convert_yuv422_09_to_p210_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv422_09_to_p210_sse2
PUBLIC	?convert_yuv422_10_to_p210_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv422_10_to_p210_sse2
PUBLIC	?convert_yuv422_12_to_p210_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv422_12_to_p210_sse2
PUBLIC	?convert_yuv422_14_to_p210_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv422_14_to_p210_sse2
PUBLIC	?convert_yuv422_16_to_p210_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv422_16_to_p210_sse2
PUBLIC	__xmm@00001000000010000000100000001000
PUBLIC	__xmm@00010001000100010001000100010001
PUBLIC	__xmm@00020002000200020002000200020002
PUBLIC	__xmm@00030003000300030003000300030003
PUBLIC	__xmm@00800080008000800080008000800080
PUBLIC	__xmm@00ff00ff00ff00ff00ff00ff00ff00ff
PUBLIC	__xmm@08000800080008000800080008000800
PUBLIC	__xmm@082f082f082f082f082f082f082f082f
PUBLIC	__xmm@10001000100010001000100010001000
PUBLIC	__xmm@124a124a124a124a124a124a124a124a
PUBLIC	__xmm@12b412b412b412b412b412b412b412b4
PUBLIC	__xmm@ffffffffffffffffffffffffffffffff
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT __xmm@ffffffffffffffffffffffffffffffff
CONST	SEGMENT
__xmm@ffffffffffffffffffffffffffffffff DB 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH
	DB	0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH
CONST	ENDS
;	COMDAT __xmm@12b412b412b412b412b412b412b412b4
CONST	SEGMENT
__xmm@12b412b412b412b412b412b412b412b4 DB 0b4H, 012H, 0b4H, 012H, 0b4H, 012H
	DB	0b4H, 012H, 0b4H, 012H, 0b4H, 012H, 0b4H, 012H, 0b4H, 012H
CONST	ENDS
;	COMDAT __xmm@124a124a124a124a124a124a124a124a
CONST	SEGMENT
__xmm@124a124a124a124a124a124a124a124a DB 'J', 012H, 'J', 012H, 'J', 012H
	DB	'J', 012H, 'J', 012H, 'J', 012H, 'J', 012H, 'J', 012H
CONST	ENDS
;	COMDAT __xmm@10001000100010001000100010001000
CONST	SEGMENT
__xmm@10001000100010001000100010001000 DB 00H, 010H, 00H, 010H, 00H, 010H
	DB	00H, 010H, 00H, 010H, 00H, 010H, 00H, 010H, 00H, 010H
CONST	ENDS
;	COMDAT __xmm@082f082f082f082f082f082f082f082f
CONST	SEGMENT
__xmm@082f082f082f082f082f082f082f082f DB '/', 08H, '/', 08H, '/', 08H, '/'
	DB	08H, '/', 08H, '/', 08H, '/', 08H, '/', 08H
CONST	ENDS
;	COMDAT __xmm@08000800080008000800080008000800
CONST	SEGMENT
__xmm@08000800080008000800080008000800 DB 00H, 08H, 00H, 08H, 00H, 08H, 00H
	DB	08H, 00H, 08H, 00H, 08H, 00H, 08H, 00H, 08H
CONST	ENDS
;	COMDAT __xmm@00ff00ff00ff00ff00ff00ff00ff00ff
CONST	SEGMENT
__xmm@00ff00ff00ff00ff00ff00ff00ff00ff DB 0ffH, 00H, 0ffH, 00H, 0ffH, 00H
	DB	0ffH, 00H, 0ffH, 00H, 0ffH, 00H, 0ffH, 00H, 0ffH, 00H
CONST	ENDS
;	COMDAT __xmm@00800080008000800080008000800080
CONST	SEGMENT
__xmm@00800080008000800080008000800080 DB 080H, 00H, 080H, 00H, 080H, 00H
	DB	080H, 00H, 080H, 00H, 080H, 00H, 080H, 00H, 080H, 00H
CONST	ENDS
;	COMDAT __xmm@00030003000300030003000300030003
CONST	SEGMENT
__xmm@00030003000300030003000300030003 DB 03H, 00H, 03H, 00H, 03H, 00H, 03H
	DB	00H, 03H, 00H, 03H, 00H, 03H, 00H, 03H, 00H
CONST	ENDS
;	COMDAT __xmm@00020002000200020002000200020002
CONST	SEGMENT
__xmm@00020002000200020002000200020002 DB 02H, 00H, 02H, 00H, 02H, 00H, 02H
	DB	00H, 02H, 00H, 02H, 00H, 02H, 00H, 02H, 00H
CONST	ENDS
;	COMDAT __xmm@00010001000100010001000100010001
CONST	SEGMENT
__xmm@00010001000100010001000100010001 DB 01H, 00H, 01H, 00H, 01H, 00H, 01H
	DB	00H, 01H, 00H, 01H, 00H, 01H, 00H, 01H, 00H
CONST	ENDS
;	COMDAT __xmm@00001000000010000000100000001000
CONST	SEGMENT
__xmm@00001000000010000000100000001000 DB 00H, 010H, 00H, 00H, 00H, 010H, 00H
	DB	00H, 00H, 010H, 00H, 00H, 00H, 010H, 00H, 00H
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ?maskY_shuffle@?1??gather_y_u_v_from_yc48@@YAXAAT__m128i@@00@Z@4QBGB
CONST	SEGMENT
?maskY_shuffle@?1??gather_y_u_v_from_yc48@@YAXAAT__m128i@@00@Z@4QBGB DW 0ffffH ; `gather_y_u_v_from_yc48'::`2'::maskY_shuffle
	DW	00H
	DW	0ffffH
	DW	00H
	DW	00H
	DW	0ffffH
	DW	0ffffH
	DW	00H
CONST	ENDS
;	COMDAT ?maskY_select@?1??gather_y_u_v_from_yc48@@YAXAAT__m128i@@00@Z@4QBGB
CONST	SEGMENT
?maskY_select@?1??gather_y_u_v_from_yc48@@YAXAAT__m128i@@00@Z@4QBGB DW 0ffffH ; `gather_y_u_v_from_yc48'::`2'::maskY_select
	DW	00H
	DW	00H
	DW	0ffffH
	DW	00H
	DW	00H
	DW	0ffffH
	DW	00H
CONST	ENDS
;	COMDAT ?VAL@?1??_mm_packus_epi32_simd@@YA?AT__m128i@@T2@0@Z@4QAY03$$CBIA
CONST	SEGMENT
?VAL@?1??_mm_packus_epi32_simd@@YA?AT__m128i@@T2@0@Z@4QAY03$$CBIA DD 08000H ; `_mm_packus_epi32_simd'::`2'::VAL
	DD	08000H
	DD	08000H
	DD	08000H
	DD	080008000H
	DD	080008000H
	DD	080008000H
	DD	080008000H
CONST	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -352						; size = 12
$T2 = -336						; size = 16
$T3 = -320						; size = 16
$T4 = -304						; size = 16
$T5 = -288						; size = 16
$T6 = -272						; size = 16
$T7 = -256						; size = 16
_x$8 = -228						; size = 4
_x2$9 = -224						; size = 16
_x1$10 = -208						; size = 16
_x0$11 = -192						; size = 16
_dst_ptr$12 = -176					; size = 4
_src_v_ptr$13 = -172					; size = 4
_src_u_ptr$14 = -168					; size = 4
_x_fin$15 = -164					; size = 4
_y$16 = -160						; size = 4
_srcVLine$ = -156					; size = 4
_srcULine$ = -152					; size = 4
_src_uv_pitch$ = -148					; size = 4
$T17 = -144						; size = 16
$T18 = -128						; size = 16
_x0$19 = -112						; size = 16
_x$20 = -88						; size = 4
_dst_ptr$21 = -84					; size = 4
_src_ptr$22 = -80					; size = 4
_y$23 = -76						; size = 4
_y_width$ = -72						; size = 4
_dstLine$ = -68						; size = 4
_srcYLine$ = -64					; size = 4
$T24 = -60						; size = 12
_y_range$ = -44						; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yuv422_high_to_p210_simd@$0BA@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv422_high_to_p210_simd<16>

; 1153 : static void __forceinline convert_yuv422_high_to_p210_simd(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 60 01 00
	00		 sub	 esp, 352		; 00000160H
  0001c	57		 push	 edi
  0001d	8d bd a0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-352]
  00023	b9 58 00 00 00	 mov	 ecx, 88			; 00000058H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1154 :     static_assert(8 < in_bit_depth && in_bit_depth <= 16, "in_bit_depth must be 9-16.");
; 1155 :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 1156 :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 1157 :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 1158 :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 1159 :     const int src_y_pitch = src_y_pitch_byte >> 1;

  0007c	8b 53 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  0007f	d1 fa		 sar	 edx, 1
  00081	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 1160 :     const int dst_y_pitch = dst_y_pitch_byte >> 1;

  00084	8b 43 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  00087	d1 f8		 sar	 eax, 1
  00089	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 1161 :     //Y成分のコピー
; 1162 :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  0008c	8b 4b 2c	 mov	 ecx, DWORD PTR _thread_n$[ebx]
  0008f	51		 push	 ecx
  00090	8b 53 28	 mov	 edx, DWORD PTR _thread_id$[ebx]
  00093	52		 push	 edx
  00094	8b 43 20	 mov	 eax, DWORD PTR _height$[ebx]
  00097	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  0009a	50		 push	 eax
  0009b	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  0009e	51		 push	 ecx
  0009f	8d 95 a0 fe ff
	ff		 lea	 edx, DWORD PTR $T1[ebp]
  000a5	52		 push	 edx
  000a6	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  000ab	83 c4 14	 add	 esp, 20			; 00000014H
  000ae	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b0	89 4d c4	 mov	 DWORD PTR $T24[ebp], ecx
  000b3	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000b6	89 55 c8	 mov	 DWORD PTR $T24[ebp+4], edx
  000b9	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000bc	89 45 cc	 mov	 DWORD PTR $T24[ebp+8], eax
  000bf	8b 4d c4	 mov	 ecx, DWORD PTR $T24[ebp]
  000c2	89 4d d4	 mov	 DWORD PTR _y_range$[ebp], ecx
  000c5	8b 55 c8	 mov	 edx, DWORD PTR $T24[ebp+4]
  000c8	89 55 d8	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000cb	8b 45 cc	 mov	 eax, DWORD PTR $T24[ebp+8]
  000ce	89 45 dc	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 1163 :     uint16_t *srcYLine = (uint16_t *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000d1	b9 04 00 00 00	 mov	 ecx, 4
  000d6	6b d1 00	 imul	 edx, ecx, 0
  000d9	8b 45 e8	 mov	 eax, DWORD PTR _src_y_pitch$[ebp]
  000dc	0f af 45 d4	 imul	 eax, DWORD PTR _y_range$[ebp]
  000e0	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  000e3	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  000e6	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  000e9	8b 4d f8	 mov	 ecx, DWORD PTR _crop_left$[ebp]
  000ec	8d 14 48	 lea	 edx, DWORD PTR [eax+ecx*2]
  000ef	89 55 c0	 mov	 DWORD PTR _srcYLine$[ebp], edx

; 1164 :     uint16_t *dstLine = (uint16_t *)dst[0] + dst_y_pitch * y_range.start_dst;

  000f2	b8 04 00 00 00	 mov	 eax, 4
  000f7	6b c8 00	 imul	 ecx, eax, 0
  000fa	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  000fd	0f af 55 d8	 imul	 edx, DWORD PTR _y_range$[ebp+4]
  00101	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  00104	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  00107	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  0010a	89 55 bc	 mov	 DWORD PTR _dstLine$[ebp], edx

; 1165 :     const int y_width = width - crop_right - crop_left;

  0010d	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  00110	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  00113	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  00116	89 45 b8	 mov	 DWORD PTR _y_width$[ebp], eax

; 1166 :     for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  00119	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _y$23[ebp], 0
  00120	eb 21		 jmp	 SHORT $LN4@convert_yu
$LN2@convert_yu:
  00122	8b 4d b4	 mov	 ecx, DWORD PTR _y$23[ebp]
  00125	83 c1 01	 add	 ecx, 1
  00128	89 4d b4	 mov	 DWORD PTR _y$23[ebp], ecx
  0012b	8b 55 e8	 mov	 edx, DWORD PTR _src_y_pitch$[ebp]
  0012e	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$[ebp]
  00131	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00134	89 4d c0	 mov	 DWORD PTR _srcYLine$[ebp], ecx
  00137	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  0013a	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$[ebp]
  0013d	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00140	89 4d bc	 mov	 DWORD PTR _dstLine$[ebp], ecx
$LN4@convert_yu:
  00143	8b 55 b4	 mov	 edx, DWORD PTR _y$23[ebp]
  00146	3b 55 dc	 cmp	 edx, DWORD PTR _y_range$[ebp+8]
  00149	0f 8d 97 00 00
	00		 jge	 $LN3@convert_yu

; 1167 :         if (in_bit_depth == 16) {

  0014f	b8 01 00 00 00	 mov	 eax, 1
  00154	85 c0		 test	 eax, eax
  00156	74 18		 je	 SHORT $LN14@convert_yu

; 1168 :             memcpy_sse((uint8_t *)dstLine, (uint8_t *)srcYLine, y_width * sizeof(uint16_t));

  00158	8b 4d b8	 mov	 ecx, DWORD PTR _y_width$[ebp]
  0015b	d1 e1		 shl	 ecx, 1
  0015d	51		 push	 ecx
  0015e	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$[ebp]
  00161	52		 push	 edx
  00162	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$[ebp]
  00165	50		 push	 eax
  00166	e8 00 00 00 00	 call	 ?memcpy_sse@@YAXPAEPBEH@Z ; memcpy_sse
  0016b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1169 :         } else {

  0016e	eb 71		 jmp	 SHORT $LN15@convert_yu
$LN14@convert_yu:

; 1170 :             uint16_t *src_ptr = srcYLine;

  00170	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$[ebp]
  00173	89 4d b0	 mov	 DWORD PTR _src_ptr$22[ebp], ecx

; 1171 :             uint16_t *dst_ptr = dstLine;

  00176	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$[ebp]
  00179	89 55 ac	 mov	 DWORD PTR _dst_ptr$21[ebp], edx

; 1172 :             for (int x = 0; x < y_width; x += 8, dst_ptr += 8, src_ptr += 8) {

  0017c	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR _x$20[ebp], 0
  00183	eb 1b		 jmp	 SHORT $LN7@convert_yu
$LN5@convert_yu:
  00185	8b 45 a8	 mov	 eax, DWORD PTR _x$20[ebp]
  00188	83 c0 08	 add	 eax, 8
  0018b	89 45 a8	 mov	 DWORD PTR _x$20[ebp], eax
  0018e	8b 4d ac	 mov	 ecx, DWORD PTR _dst_ptr$21[ebp]
  00191	83 c1 10	 add	 ecx, 16			; 00000010H
  00194	89 4d ac	 mov	 DWORD PTR _dst_ptr$21[ebp], ecx
  00197	8b 55 b0	 mov	 edx, DWORD PTR _src_ptr$22[ebp]
  0019a	83 c2 10	 add	 edx, 16			; 00000010H
  0019d	89 55 b0	 mov	 DWORD PTR _src_ptr$22[ebp], edx
$LN7@convert_yu:
  001a0	8b 45 a8	 mov	 eax, DWORD PTR _x$20[ebp]
  001a3	3b 45 b8	 cmp	 eax, DWORD PTR _y_width$[ebp]
  001a6	7d 39		 jge	 SHORT $LN15@convert_yu

; 1173 :                 __m128i x0 = _mm_loadu_si128((const __m128i *)src_ptr);

  001a8	8b 4d b0	 mov	 ecx, DWORD PTR _src_ptr$22[ebp]
  001ab	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  001ae	0f 29 45 80	 movaps	 XMMWORD PTR $T18[ebp], xmm0
  001b2	0f 28 45 80	 movaps	 xmm0, XMMWORD PTR $T18[ebp]
  001b6	0f 29 45 90	 movaps	 XMMWORD PTR _x0$19[ebp], xmm0

; 1174 :                 x0 = _mm_slli_epi16(x0, 16 - in_bit_depth);

  001ba	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR _x0$19[ebp]
  001be	66 0f 71 f0 00	 psllw	 xmm0, 0
  001c3	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR $T17[ebp], xmm0
  001ca	0f 28 85 70 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T17[ebp]
  001d1	0f 29 45 90	 movaps	 XMMWORD PTR _x0$19[ebp], xmm0

; 1175 :                 _mm_storeu_si128((__m128i *)dst_ptr, x0);

  001d5	0f 10 45 90	 movups	 xmm0, XMMWORD PTR _x0$19[ebp]
  001d9	8b 55 ac	 mov	 edx, DWORD PTR _dst_ptr$21[ebp]
  001dc	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 1176 :             }

  001df	eb a4		 jmp	 SHORT $LN5@convert_yu
$LN15@convert_yu:

; 1177 :         }
; 1178 :     }

  001e1	e9 3c ff ff ff	 jmp	 $LN2@convert_yu
$LN3@convert_yu:

; 1179 :     //UV成分のコピー
; 1180 :     const int src_uv_pitch = src_uv_pitch_byte >> 1;

  001e6	8b 43 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebx]
  001e9	d1 f8		 sar	 eax, 1
  001eb	89 85 6c ff ff
	ff		 mov	 DWORD PTR _src_uv_pitch$[ebp], eax

; 1181 :     uint16_t *srcULine = (uint16_t *)src[1] + ((src_uv_pitch * y_range.start_src) + (crop_left >> 1));

  001f1	b9 04 00 00 00	 mov	 ecx, 4
  001f6	c1 e1 00	 shl	 ecx, 0
  001f9	8b 95 6c ff ff
	ff		 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  001ff	0f af 55 d4	 imul	 edx, DWORD PTR _y_range$[ebp]
  00203	8b 45 f8	 mov	 eax, DWORD PTR _crop_left$[ebp]
  00206	d1 f8		 sar	 eax, 1
  00208	03 d0		 add	 edx, eax
  0020a	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  0020d	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  00210	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  00213	89 95 68 ff ff
	ff		 mov	 DWORD PTR _srcULine$[ebp], edx

; 1182 :     uint16_t *srcVLine = (uint16_t *)src[2] + ((src_uv_pitch * y_range.start_src) + (crop_left >> 1));

  00219	b8 04 00 00 00	 mov	 eax, 4
  0021e	d1 e0		 shl	 eax, 1
  00220	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00226	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  0022a	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  0022d	d1 fa		 sar	 edx, 1
  0022f	03 ca		 add	 ecx, edx
  00231	8b 53 0c	 mov	 edx, DWORD PTR _src$[ebx]
  00234	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  00237	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  0023a	89 8d 64 ff ff
	ff		 mov	 DWORD PTR _srcVLine$[ebp], ecx

; 1183 :     dstLine = (uint16_t *)dst[1] + dst_y_pitch * y_range.start_dst;

  00240	ba 04 00 00 00	 mov	 edx, 4
  00245	c1 e2 00	 shl	 edx, 0
  00248	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  0024b	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  0024f	8b 4b 08	 mov	 ecx, DWORD PTR _dst$[ebx]
  00252	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  00255	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  00258	89 45 bc	 mov	 DWORD PTR _dstLine$[ebp], eax

; 1184 :     for (int y = 0; y < y_range.len; y++, srcULine += src_uv_pitch, srcVLine += src_uv_pitch, dstLine += dst_y_pitch) {

  0025b	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _y$16[ebp], 0
  00265	eb 45		 jmp	 SHORT $LN10@convert_yu
$LN8@convert_yu:
  00267	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _y$16[ebp]
  0026d	83 c1 01	 add	 ecx, 1
  00270	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _y$16[ebp], ecx
  00276	8b 95 6c ff ff
	ff		 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  0027c	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _srcULine$[ebp]
  00282	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00285	89 8d 68 ff ff
	ff		 mov	 DWORD PTR _srcULine$[ebp], ecx
  0028b	8b 95 6c ff ff
	ff		 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  00291	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _srcVLine$[ebp]
  00297	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  0029a	89 8d 64 ff ff
	ff		 mov	 DWORD PTR _srcVLine$[ebp], ecx
  002a0	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  002a3	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$[ebp]
  002a6	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  002a9	89 4d bc	 mov	 DWORD PTR _dstLine$[ebp], ecx
$LN10@convert_yu:
  002ac	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _y$16[ebp]
  002b2	3b 55 dc	 cmp	 edx, DWORD PTR _y_range$[ebp+8]
  002b5	0f 8d 7d 01 00
	00		 jge	 $LN1@convert_yu

; 1185 :         const int x_fin = width - crop_right;

  002bb	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  002be	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  002c1	89 85 5c ff ff
	ff		 mov	 DWORD PTR _x_fin$15[ebp], eax

; 1186 :         uint16_t *src_u_ptr = srcULine;

  002c7	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR _srcULine$[ebp]
  002cd	89 8d 58 ff ff
	ff		 mov	 DWORD PTR _src_u_ptr$14[ebp], ecx

; 1187 :         uint16_t *src_v_ptr = srcVLine;

  002d3	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR _srcVLine$[ebp]
  002d9	89 95 54 ff ff
	ff		 mov	 DWORD PTR _src_v_ptr$13[ebp], edx

; 1188 :         uint16_t *dst_ptr = dstLine;

  002df	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$[ebp]
  002e2	89 85 50 ff ff
	ff		 mov	 DWORD PTR _dst_ptr$12[ebp], eax

; 1189 :         __m128i x0, x1, x2;
; 1190 :         for (int x = crop_left; x < x_fin; x += 16, src_u_ptr += 8, src_v_ptr += 8, dst_ptr += 16) {

  002e8	8b 4d f8	 mov	 ecx, DWORD PTR _crop_left$[ebp]
  002eb	89 8d 1c ff ff
	ff		 mov	 DWORD PTR _x$8[ebp], ecx
  002f1	eb 3c		 jmp	 SHORT $LN13@convert_yu
$LN11@convert_yu:
  002f3	8b 95 1c ff ff
	ff		 mov	 edx, DWORD PTR _x$8[ebp]
  002f9	83 c2 10	 add	 edx, 16			; 00000010H
  002fc	89 95 1c ff ff
	ff		 mov	 DWORD PTR _x$8[ebp], edx
  00302	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _src_u_ptr$14[ebp]
  00308	83 c0 10	 add	 eax, 16			; 00000010H
  0030b	89 85 58 ff ff
	ff		 mov	 DWORD PTR _src_u_ptr$14[ebp], eax
  00311	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _src_v_ptr$13[ebp]
  00317	83 c1 10	 add	 ecx, 16			; 00000010H
  0031a	89 8d 54 ff ff
	ff		 mov	 DWORD PTR _src_v_ptr$13[ebp], ecx
  00320	8b 95 50 ff ff
	ff		 mov	 edx, DWORD PTR _dst_ptr$12[ebp]
  00326	83 c2 20	 add	 edx, 32			; 00000020H
  00329	89 95 50 ff ff
	ff		 mov	 DWORD PTR _dst_ptr$12[ebp], edx
$LN13@convert_yu:
  0032f	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR _x$8[ebp]
  00335	3b 85 5c ff ff
	ff		 cmp	 eax, DWORD PTR _x_fin$15[ebp]
  0033b	0f 8d f2 00 00
	00		 jge	 $LN12@convert_yu

; 1191 :             x0 = _mm_loadu_si128((const __m128i *)src_u_ptr);

  00341	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _src_u_ptr$14[ebp]
  00347	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  0034a	0f 29 85 00 ff
	ff ff		 movaps	 XMMWORD PTR $T7[ebp], xmm0
  00351	0f 28 85 00 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T7[ebp]
  00358	0f 29 85 40 ff
	ff ff		 movaps	 XMMWORD PTR _x0$11[ebp], xmm0

; 1192 :             x1 = _mm_loadu_si128((const __m128i *)src_v_ptr);

  0035f	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR _src_v_ptr$13[ebp]
  00365	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  00368	0f 29 85 f0 fe
	ff ff		 movaps	 XMMWORD PTR $T6[ebp], xmm0
  0036f	0f 28 85 f0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T6[ebp]
  00376	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR _x1$10[ebp], xmm0

; 1193 : 
; 1194 :             if (in_bit_depth < 16) {

  0037d	33 c0		 xor	 eax, eax
  0037f	74 42		 je	 SHORT $LN16@convert_yu

; 1195 :                 x0 = _mm_slli_epi16(x0, 16 - in_bit_depth);

  00381	0f 28 85 40 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x0$11[ebp]
  00388	66 0f 71 f0 00	 psllw	 xmm0, 0
  0038d	0f 29 85 e0 fe
	ff ff		 movaps	 XMMWORD PTR $T5[ebp], xmm0
  00394	0f 28 85 e0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T5[ebp]
  0039b	0f 29 85 40 ff
	ff ff		 movaps	 XMMWORD PTR _x0$11[ebp], xmm0

; 1196 :                 x1 = _mm_slli_epi16(x1, 16 - in_bit_depth);

  003a2	0f 28 85 30 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$10[ebp]
  003a9	66 0f 71 f0 00	 psllw	 xmm0, 0
  003ae	0f 29 85 d0 fe
	ff ff		 movaps	 XMMWORD PTR $T4[ebp], xmm0
  003b5	0f 28 85 d0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T4[ebp]
  003bc	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR _x1$10[ebp], xmm0
$LN16@convert_yu:

; 1197 :             }
; 1198 : 
; 1199 :             x2 = _mm_unpackhi_epi16(x0, x1);

  003c3	0f 28 85 40 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x0$11[ebp]
  003ca	66 0f 69 85 30
	ff ff ff	 punpckhwd xmm0, XMMWORD PTR _x1$10[ebp]
  003d2	0f 29 85 c0 fe
	ff ff		 movaps	 XMMWORD PTR $T3[ebp], xmm0
  003d9	0f 28 85 c0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T3[ebp]
  003e0	0f 29 85 20 ff
	ff ff		 movaps	 XMMWORD PTR _x2$9[ebp], xmm0

; 1200 :             x0 = _mm_unpacklo_epi16(x0, x1);

  003e7	0f 28 85 40 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x0$11[ebp]
  003ee	66 0f 61 85 30
	ff ff ff	 punpcklwd xmm0, XMMWORD PTR _x1$10[ebp]
  003f6	0f 29 85 b0 fe
	ff ff		 movaps	 XMMWORD PTR $T2[ebp], xmm0
  003fd	0f 28 85 b0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T2[ebp]
  00404	0f 29 85 40 ff
	ff ff		 movaps	 XMMWORD PTR _x0$11[ebp], xmm0

; 1201 : 
; 1202 :             _mm_storeu_si128((__m128i *)(dst_ptr + 0), x0);

  0040b	0f 10 85 40 ff
	ff ff		 movups	 xmm0, XMMWORD PTR _x0$11[ebp]
  00412	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR _dst_ptr$12[ebp]
  00418	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 1203 :             _mm_storeu_si128((__m128i *)(dst_ptr + 8), x2);

  0041b	0f 10 85 20 ff
	ff ff		 movups	 xmm0, XMMWORD PTR _x2$9[ebp]
  00422	8b 95 50 ff ff
	ff		 mov	 edx, DWORD PTR _dst_ptr$12[ebp]
  00428	83 c2 10	 add	 edx, 16			; 00000010H
  0042b	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 1204 :         }

  0042e	e9 c0 fe ff ff	 jmp	 $LN11@convert_yu
$LN12@convert_yu:

; 1205 :     }

  00433	e9 2f fe ff ff	 jmp	 $LN8@convert_yu
$LN1@convert_yu:

; 1206 : }

  00438	52		 push	 edx
  00439	8b cd		 mov	 ecx, ebp
  0043b	50		 push	 eax
  0043c	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN20@convert_yu
  00442	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00447	58		 pop	 eax
  00448	5a		 pop	 edx
  00449	5f		 pop	 edi
  0044a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0044d	33 cd		 xor	 ecx, ebp
  0044f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00454	8b e5		 mov	 esp, ebp
  00456	5d		 pop	 ebp
  00457	8b e3		 mov	 esp, ebx
  00459	5b		 pop	 ebx
  0045a	c3		 ret	 0
  0045b	90		 npad	 1
$LN20@convert_yu:
  0045c	01 00 00 00	 DD	 1
  00460	00 00 00 00	 DD	 $LN19@convert_yu
$LN19@convert_yu:
  00464	d4 ff ff ff	 DD	 -44			; ffffffd4H
  00468	0c 00 00 00	 DD	 12			; 0000000cH
  0046c	00 00 00 00	 DD	 $LN18@convert_yu
$LN18@convert_yu:
  00470	79		 DB	 121			; 00000079H
  00471	5f		 DB	 95			; 0000005fH
  00472	72		 DB	 114			; 00000072H
  00473	61		 DB	 97			; 00000061H
  00474	6e		 DB	 110			; 0000006eH
  00475	67		 DB	 103			; 00000067H
  00476	65		 DB	 101			; 00000065H
  00477	00		 DB	 0
??$convert_yuv422_high_to_p210_simd@$0BA@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv422_high_to_p210_simd<16>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_sse2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuv422_16_to_p210_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv422_16_to_p210_sse2

; 237  : void convert_yuv422_16_to_p210_sse2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 238  :     convert_yuv422_high_to_p210_simd<16>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yuv422_high_to_p210_simd@$0BA@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv422_high_to_p210_simd<16>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 239  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yuv422_16_to_p210_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv422_16_to_p210_sse2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -352						; size = 12
$T2 = -336						; size = 16
$T3 = -320						; size = 16
$T4 = -304						; size = 16
$T5 = -288						; size = 16
$T6 = -272						; size = 16
$T7 = -256						; size = 16
_x$8 = -228						; size = 4
_x2$9 = -224						; size = 16
_x1$10 = -208						; size = 16
_x0$11 = -192						; size = 16
_dst_ptr$12 = -176					; size = 4
_src_v_ptr$13 = -172					; size = 4
_src_u_ptr$14 = -168					; size = 4
_x_fin$15 = -164					; size = 4
_y$16 = -160						; size = 4
_srcVLine$ = -156					; size = 4
_srcULine$ = -152					; size = 4
_src_uv_pitch$ = -148					; size = 4
$T17 = -144						; size = 16
$T18 = -128						; size = 16
_x0$19 = -112						; size = 16
_x$20 = -88						; size = 4
_dst_ptr$21 = -84					; size = 4
_src_ptr$22 = -80					; size = 4
_y$23 = -76						; size = 4
_y_width$ = -72						; size = 4
_dstLine$ = -68						; size = 4
_srcYLine$ = -64					; size = 4
$T24 = -60						; size = 12
_y_range$ = -44						; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yuv422_high_to_p210_simd@$0O@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv422_high_to_p210_simd<14>

; 1153 : static void __forceinline convert_yuv422_high_to_p210_simd(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 60 01 00
	00		 sub	 esp, 352		; 00000160H
  0001c	57		 push	 edi
  0001d	8d bd a0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-352]
  00023	b9 58 00 00 00	 mov	 ecx, 88			; 00000058H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1154 :     static_assert(8 < in_bit_depth && in_bit_depth <= 16, "in_bit_depth must be 9-16.");
; 1155 :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 1156 :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 1157 :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 1158 :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 1159 :     const int src_y_pitch = src_y_pitch_byte >> 1;

  0007c	8b 53 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  0007f	d1 fa		 sar	 edx, 1
  00081	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 1160 :     const int dst_y_pitch = dst_y_pitch_byte >> 1;

  00084	8b 43 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  00087	d1 f8		 sar	 eax, 1
  00089	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 1161 :     //Y成分のコピー
; 1162 :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  0008c	8b 4b 2c	 mov	 ecx, DWORD PTR _thread_n$[ebx]
  0008f	51		 push	 ecx
  00090	8b 53 28	 mov	 edx, DWORD PTR _thread_id$[ebx]
  00093	52		 push	 edx
  00094	8b 43 20	 mov	 eax, DWORD PTR _height$[ebx]
  00097	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  0009a	50		 push	 eax
  0009b	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  0009e	51		 push	 ecx
  0009f	8d 95 a0 fe ff
	ff		 lea	 edx, DWORD PTR $T1[ebp]
  000a5	52		 push	 edx
  000a6	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  000ab	83 c4 14	 add	 esp, 20			; 00000014H
  000ae	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b0	89 4d c4	 mov	 DWORD PTR $T24[ebp], ecx
  000b3	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000b6	89 55 c8	 mov	 DWORD PTR $T24[ebp+4], edx
  000b9	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000bc	89 45 cc	 mov	 DWORD PTR $T24[ebp+8], eax
  000bf	8b 4d c4	 mov	 ecx, DWORD PTR $T24[ebp]
  000c2	89 4d d4	 mov	 DWORD PTR _y_range$[ebp], ecx
  000c5	8b 55 c8	 mov	 edx, DWORD PTR $T24[ebp+4]
  000c8	89 55 d8	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000cb	8b 45 cc	 mov	 eax, DWORD PTR $T24[ebp+8]
  000ce	89 45 dc	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 1163 :     uint16_t *srcYLine = (uint16_t *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000d1	b9 04 00 00 00	 mov	 ecx, 4
  000d6	6b d1 00	 imul	 edx, ecx, 0
  000d9	8b 45 e8	 mov	 eax, DWORD PTR _src_y_pitch$[ebp]
  000dc	0f af 45 d4	 imul	 eax, DWORD PTR _y_range$[ebp]
  000e0	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  000e3	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  000e6	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  000e9	8b 4d f8	 mov	 ecx, DWORD PTR _crop_left$[ebp]
  000ec	8d 14 48	 lea	 edx, DWORD PTR [eax+ecx*2]
  000ef	89 55 c0	 mov	 DWORD PTR _srcYLine$[ebp], edx

; 1164 :     uint16_t *dstLine = (uint16_t *)dst[0] + dst_y_pitch * y_range.start_dst;

  000f2	b8 04 00 00 00	 mov	 eax, 4
  000f7	6b c8 00	 imul	 ecx, eax, 0
  000fa	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  000fd	0f af 55 d8	 imul	 edx, DWORD PTR _y_range$[ebp+4]
  00101	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  00104	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  00107	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  0010a	89 55 bc	 mov	 DWORD PTR _dstLine$[ebp], edx

; 1165 :     const int y_width = width - crop_right - crop_left;

  0010d	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  00110	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  00113	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  00116	89 45 b8	 mov	 DWORD PTR _y_width$[ebp], eax

; 1166 :     for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  00119	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _y$23[ebp], 0
  00120	eb 21		 jmp	 SHORT $LN4@convert_yu
$LN2@convert_yu:
  00122	8b 4d b4	 mov	 ecx, DWORD PTR _y$23[ebp]
  00125	83 c1 01	 add	 ecx, 1
  00128	89 4d b4	 mov	 DWORD PTR _y$23[ebp], ecx
  0012b	8b 55 e8	 mov	 edx, DWORD PTR _src_y_pitch$[ebp]
  0012e	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$[ebp]
  00131	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00134	89 4d c0	 mov	 DWORD PTR _srcYLine$[ebp], ecx
  00137	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  0013a	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$[ebp]
  0013d	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00140	89 4d bc	 mov	 DWORD PTR _dstLine$[ebp], ecx
$LN4@convert_yu:
  00143	8b 55 b4	 mov	 edx, DWORD PTR _y$23[ebp]
  00146	3b 55 dc	 cmp	 edx, DWORD PTR _y_range$[ebp+8]
  00149	0f 8d 92 00 00
	00		 jge	 $LN3@convert_yu

; 1167 :         if (in_bit_depth == 16) {

  0014f	33 c0		 xor	 eax, eax
  00151	74 18		 je	 SHORT $LN14@convert_yu

; 1168 :             memcpy_sse((uint8_t *)dstLine, (uint8_t *)srcYLine, y_width * sizeof(uint16_t));

  00153	8b 4d b8	 mov	 ecx, DWORD PTR _y_width$[ebp]
  00156	d1 e1		 shl	 ecx, 1
  00158	51		 push	 ecx
  00159	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$[ebp]
  0015c	52		 push	 edx
  0015d	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$[ebp]
  00160	50		 push	 eax
  00161	e8 00 00 00 00	 call	 ?memcpy_sse@@YAXPAEPBEH@Z ; memcpy_sse
  00166	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1169 :         } else {

  00169	eb 71		 jmp	 SHORT $LN15@convert_yu
$LN14@convert_yu:

; 1170 :             uint16_t *src_ptr = srcYLine;

  0016b	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$[ebp]
  0016e	89 4d b0	 mov	 DWORD PTR _src_ptr$22[ebp], ecx

; 1171 :             uint16_t *dst_ptr = dstLine;

  00171	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$[ebp]
  00174	89 55 ac	 mov	 DWORD PTR _dst_ptr$21[ebp], edx

; 1172 :             for (int x = 0; x < y_width; x += 8, dst_ptr += 8, src_ptr += 8) {

  00177	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR _x$20[ebp], 0
  0017e	eb 1b		 jmp	 SHORT $LN7@convert_yu
$LN5@convert_yu:
  00180	8b 45 a8	 mov	 eax, DWORD PTR _x$20[ebp]
  00183	83 c0 08	 add	 eax, 8
  00186	89 45 a8	 mov	 DWORD PTR _x$20[ebp], eax
  00189	8b 4d ac	 mov	 ecx, DWORD PTR _dst_ptr$21[ebp]
  0018c	83 c1 10	 add	 ecx, 16			; 00000010H
  0018f	89 4d ac	 mov	 DWORD PTR _dst_ptr$21[ebp], ecx
  00192	8b 55 b0	 mov	 edx, DWORD PTR _src_ptr$22[ebp]
  00195	83 c2 10	 add	 edx, 16			; 00000010H
  00198	89 55 b0	 mov	 DWORD PTR _src_ptr$22[ebp], edx
$LN7@convert_yu:
  0019b	8b 45 a8	 mov	 eax, DWORD PTR _x$20[ebp]
  0019e	3b 45 b8	 cmp	 eax, DWORD PTR _y_width$[ebp]
  001a1	7d 39		 jge	 SHORT $LN15@convert_yu

; 1173 :                 __m128i x0 = _mm_loadu_si128((const __m128i *)src_ptr);

  001a3	8b 4d b0	 mov	 ecx, DWORD PTR _src_ptr$22[ebp]
  001a6	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  001a9	0f 29 45 80	 movaps	 XMMWORD PTR $T18[ebp], xmm0
  001ad	0f 28 45 80	 movaps	 xmm0, XMMWORD PTR $T18[ebp]
  001b1	0f 29 45 90	 movaps	 XMMWORD PTR _x0$19[ebp], xmm0

; 1174 :                 x0 = _mm_slli_epi16(x0, 16 - in_bit_depth);

  001b5	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR _x0$19[ebp]
  001b9	66 0f 71 f0 02	 psllw	 xmm0, 2
  001be	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR $T17[ebp], xmm0
  001c5	0f 28 85 70 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T17[ebp]
  001cc	0f 29 45 90	 movaps	 XMMWORD PTR _x0$19[ebp], xmm0

; 1175 :                 _mm_storeu_si128((__m128i *)dst_ptr, x0);

  001d0	0f 10 45 90	 movups	 xmm0, XMMWORD PTR _x0$19[ebp]
  001d4	8b 55 ac	 mov	 edx, DWORD PTR _dst_ptr$21[ebp]
  001d7	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 1176 :             }

  001da	eb a4		 jmp	 SHORT $LN5@convert_yu
$LN15@convert_yu:

; 1177 :         }
; 1178 :     }

  001dc	e9 41 ff ff ff	 jmp	 $LN2@convert_yu
$LN3@convert_yu:

; 1179 :     //UV成分のコピー
; 1180 :     const int src_uv_pitch = src_uv_pitch_byte >> 1;

  001e1	8b 43 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebx]
  001e4	d1 f8		 sar	 eax, 1
  001e6	89 85 6c ff ff
	ff		 mov	 DWORD PTR _src_uv_pitch$[ebp], eax

; 1181 :     uint16_t *srcULine = (uint16_t *)src[1] + ((src_uv_pitch * y_range.start_src) + (crop_left >> 1));

  001ec	b9 04 00 00 00	 mov	 ecx, 4
  001f1	c1 e1 00	 shl	 ecx, 0
  001f4	8b 95 6c ff ff
	ff		 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  001fa	0f af 55 d4	 imul	 edx, DWORD PTR _y_range$[ebp]
  001fe	8b 45 f8	 mov	 eax, DWORD PTR _crop_left$[ebp]
  00201	d1 f8		 sar	 eax, 1
  00203	03 d0		 add	 edx, eax
  00205	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  00208	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  0020b	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  0020e	89 95 68 ff ff
	ff		 mov	 DWORD PTR _srcULine$[ebp], edx

; 1182 :     uint16_t *srcVLine = (uint16_t *)src[2] + ((src_uv_pitch * y_range.start_src) + (crop_left >> 1));

  00214	b8 04 00 00 00	 mov	 eax, 4
  00219	d1 e0		 shl	 eax, 1
  0021b	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00221	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  00225	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  00228	d1 fa		 sar	 edx, 1
  0022a	03 ca		 add	 ecx, edx
  0022c	8b 53 0c	 mov	 edx, DWORD PTR _src$[ebx]
  0022f	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  00232	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  00235	89 8d 64 ff ff
	ff		 mov	 DWORD PTR _srcVLine$[ebp], ecx

; 1183 :     dstLine = (uint16_t *)dst[1] + dst_y_pitch * y_range.start_dst;

  0023b	ba 04 00 00 00	 mov	 edx, 4
  00240	c1 e2 00	 shl	 edx, 0
  00243	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  00246	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  0024a	8b 4b 08	 mov	 ecx, DWORD PTR _dst$[ebx]
  0024d	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  00250	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  00253	89 45 bc	 mov	 DWORD PTR _dstLine$[ebp], eax

; 1184 :     for (int y = 0; y < y_range.len; y++, srcULine += src_uv_pitch, srcVLine += src_uv_pitch, dstLine += dst_y_pitch) {

  00256	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _y$16[ebp], 0
  00260	eb 45		 jmp	 SHORT $LN10@convert_yu
$LN8@convert_yu:
  00262	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _y$16[ebp]
  00268	83 c1 01	 add	 ecx, 1
  0026b	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _y$16[ebp], ecx
  00271	8b 95 6c ff ff
	ff		 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  00277	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _srcULine$[ebp]
  0027d	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00280	89 8d 68 ff ff
	ff		 mov	 DWORD PTR _srcULine$[ebp], ecx
  00286	8b 95 6c ff ff
	ff		 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  0028c	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _srcVLine$[ebp]
  00292	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00295	89 8d 64 ff ff
	ff		 mov	 DWORD PTR _srcVLine$[ebp], ecx
  0029b	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  0029e	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$[ebp]
  002a1	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  002a4	89 4d bc	 mov	 DWORD PTR _dstLine$[ebp], ecx
$LN10@convert_yu:
  002a7	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _y$16[ebp]
  002ad	3b 55 dc	 cmp	 edx, DWORD PTR _y_range$[ebp+8]
  002b0	0f 8d 82 01 00
	00		 jge	 $LN1@convert_yu

; 1185 :         const int x_fin = width - crop_right;

  002b6	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  002b9	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  002bc	89 85 5c ff ff
	ff		 mov	 DWORD PTR _x_fin$15[ebp], eax

; 1186 :         uint16_t *src_u_ptr = srcULine;

  002c2	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR _srcULine$[ebp]
  002c8	89 8d 58 ff ff
	ff		 mov	 DWORD PTR _src_u_ptr$14[ebp], ecx

; 1187 :         uint16_t *src_v_ptr = srcVLine;

  002ce	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR _srcVLine$[ebp]
  002d4	89 95 54 ff ff
	ff		 mov	 DWORD PTR _src_v_ptr$13[ebp], edx

; 1188 :         uint16_t *dst_ptr = dstLine;

  002da	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$[ebp]
  002dd	89 85 50 ff ff
	ff		 mov	 DWORD PTR _dst_ptr$12[ebp], eax

; 1189 :         __m128i x0, x1, x2;
; 1190 :         for (int x = crop_left; x < x_fin; x += 16, src_u_ptr += 8, src_v_ptr += 8, dst_ptr += 16) {

  002e3	8b 4d f8	 mov	 ecx, DWORD PTR _crop_left$[ebp]
  002e6	89 8d 1c ff ff
	ff		 mov	 DWORD PTR _x$8[ebp], ecx
  002ec	eb 3c		 jmp	 SHORT $LN13@convert_yu
$LN11@convert_yu:
  002ee	8b 95 1c ff ff
	ff		 mov	 edx, DWORD PTR _x$8[ebp]
  002f4	83 c2 10	 add	 edx, 16			; 00000010H
  002f7	89 95 1c ff ff
	ff		 mov	 DWORD PTR _x$8[ebp], edx
  002fd	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _src_u_ptr$14[ebp]
  00303	83 c0 10	 add	 eax, 16			; 00000010H
  00306	89 85 58 ff ff
	ff		 mov	 DWORD PTR _src_u_ptr$14[ebp], eax
  0030c	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _src_v_ptr$13[ebp]
  00312	83 c1 10	 add	 ecx, 16			; 00000010H
  00315	89 8d 54 ff ff
	ff		 mov	 DWORD PTR _src_v_ptr$13[ebp], ecx
  0031b	8b 95 50 ff ff
	ff		 mov	 edx, DWORD PTR _dst_ptr$12[ebp]
  00321	83 c2 20	 add	 edx, 32			; 00000020H
  00324	89 95 50 ff ff
	ff		 mov	 DWORD PTR _dst_ptr$12[ebp], edx
$LN13@convert_yu:
  0032a	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR _x$8[ebp]
  00330	3b 85 5c ff ff
	ff		 cmp	 eax, DWORD PTR _x_fin$15[ebp]
  00336	0f 8d f7 00 00
	00		 jge	 $LN12@convert_yu

; 1191 :             x0 = _mm_loadu_si128((const __m128i *)src_u_ptr);

  0033c	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _src_u_ptr$14[ebp]
  00342	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00345	0f 29 85 00 ff
	ff ff		 movaps	 XMMWORD PTR $T7[ebp], xmm0
  0034c	0f 28 85 00 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T7[ebp]
  00353	0f 29 85 40 ff
	ff ff		 movaps	 XMMWORD PTR _x0$11[ebp], xmm0

; 1192 :             x1 = _mm_loadu_si128((const __m128i *)src_v_ptr);

  0035a	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR _src_v_ptr$13[ebp]
  00360	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  00363	0f 29 85 f0 fe
	ff ff		 movaps	 XMMWORD PTR $T6[ebp], xmm0
  0036a	0f 28 85 f0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T6[ebp]
  00371	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR _x1$10[ebp], xmm0

; 1193 : 
; 1194 :             if (in_bit_depth < 16) {

  00378	b8 01 00 00 00	 mov	 eax, 1
  0037d	85 c0		 test	 eax, eax
  0037f	74 42		 je	 SHORT $LN16@convert_yu

; 1195 :                 x0 = _mm_slli_epi16(x0, 16 - in_bit_depth);

  00381	0f 28 85 40 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x0$11[ebp]
  00388	66 0f 71 f0 02	 psllw	 xmm0, 2
  0038d	0f 29 85 e0 fe
	ff ff		 movaps	 XMMWORD PTR $T5[ebp], xmm0
  00394	0f 28 85 e0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T5[ebp]
  0039b	0f 29 85 40 ff
	ff ff		 movaps	 XMMWORD PTR _x0$11[ebp], xmm0

; 1196 :                 x1 = _mm_slli_epi16(x1, 16 - in_bit_depth);

  003a2	0f 28 85 30 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$10[ebp]
  003a9	66 0f 71 f0 02	 psllw	 xmm0, 2
  003ae	0f 29 85 d0 fe
	ff ff		 movaps	 XMMWORD PTR $T4[ebp], xmm0
  003b5	0f 28 85 d0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T4[ebp]
  003bc	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR _x1$10[ebp], xmm0
$LN16@convert_yu:

; 1197 :             }
; 1198 : 
; 1199 :             x2 = _mm_unpackhi_epi16(x0, x1);

  003c3	0f 28 85 40 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x0$11[ebp]
  003ca	66 0f 69 85 30
	ff ff ff	 punpckhwd xmm0, XMMWORD PTR _x1$10[ebp]
  003d2	0f 29 85 c0 fe
	ff ff		 movaps	 XMMWORD PTR $T3[ebp], xmm0
  003d9	0f 28 85 c0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T3[ebp]
  003e0	0f 29 85 20 ff
	ff ff		 movaps	 XMMWORD PTR _x2$9[ebp], xmm0

; 1200 :             x0 = _mm_unpacklo_epi16(x0, x1);

  003e7	0f 28 85 40 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x0$11[ebp]
  003ee	66 0f 61 85 30
	ff ff ff	 punpcklwd xmm0, XMMWORD PTR _x1$10[ebp]
  003f6	0f 29 85 b0 fe
	ff ff		 movaps	 XMMWORD PTR $T2[ebp], xmm0
  003fd	0f 28 85 b0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T2[ebp]
  00404	0f 29 85 40 ff
	ff ff		 movaps	 XMMWORD PTR _x0$11[ebp], xmm0

; 1201 : 
; 1202 :             _mm_storeu_si128((__m128i *)(dst_ptr + 0), x0);

  0040b	0f 10 85 40 ff
	ff ff		 movups	 xmm0, XMMWORD PTR _x0$11[ebp]
  00412	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR _dst_ptr$12[ebp]
  00418	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 1203 :             _mm_storeu_si128((__m128i *)(dst_ptr + 8), x2);

  0041b	0f 10 85 20 ff
	ff ff		 movups	 xmm0, XMMWORD PTR _x2$9[ebp]
  00422	8b 95 50 ff ff
	ff		 mov	 edx, DWORD PTR _dst_ptr$12[ebp]
  00428	83 c2 10	 add	 edx, 16			; 00000010H
  0042b	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 1204 :         }

  0042e	e9 bb fe ff ff	 jmp	 $LN11@convert_yu
$LN12@convert_yu:

; 1205 :     }

  00433	e9 2a fe ff ff	 jmp	 $LN8@convert_yu
$LN1@convert_yu:

; 1206 : }

  00438	52		 push	 edx
  00439	8b cd		 mov	 ecx, ebp
  0043b	50		 push	 eax
  0043c	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN20@convert_yu
  00442	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00447	58		 pop	 eax
  00448	5a		 pop	 edx
  00449	5f		 pop	 edi
  0044a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0044d	33 cd		 xor	 ecx, ebp
  0044f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00454	8b e5		 mov	 esp, ebp
  00456	5d		 pop	 ebp
  00457	8b e3		 mov	 esp, ebx
  00459	5b		 pop	 ebx
  0045a	c3		 ret	 0
  0045b	90		 npad	 1
$LN20@convert_yu:
  0045c	01 00 00 00	 DD	 1
  00460	00 00 00 00	 DD	 $LN19@convert_yu
$LN19@convert_yu:
  00464	d4 ff ff ff	 DD	 -44			; ffffffd4H
  00468	0c 00 00 00	 DD	 12			; 0000000cH
  0046c	00 00 00 00	 DD	 $LN18@convert_yu
$LN18@convert_yu:
  00470	79		 DB	 121			; 00000079H
  00471	5f		 DB	 95			; 0000005fH
  00472	72		 DB	 114			; 00000072H
  00473	61		 DB	 97			; 00000061H
  00474	6e		 DB	 110			; 0000006eH
  00475	67		 DB	 103			; 00000067H
  00476	65		 DB	 101			; 00000065H
  00477	00		 DB	 0
??$convert_yuv422_high_to_p210_simd@$0O@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv422_high_to_p210_simd<14>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_sse2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuv422_14_to_p210_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv422_14_to_p210_sse2

; 233  : void convert_yuv422_14_to_p210_sse2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 234  :     convert_yuv422_high_to_p210_simd<14>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yuv422_high_to_p210_simd@$0O@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv422_high_to_p210_simd<14>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 235  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yuv422_14_to_p210_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv422_14_to_p210_sse2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -352						; size = 12
$T2 = -336						; size = 16
$T3 = -320						; size = 16
$T4 = -304						; size = 16
$T5 = -288						; size = 16
$T6 = -272						; size = 16
$T7 = -256						; size = 16
_x$8 = -228						; size = 4
_x2$9 = -224						; size = 16
_x1$10 = -208						; size = 16
_x0$11 = -192						; size = 16
_dst_ptr$12 = -176					; size = 4
_src_v_ptr$13 = -172					; size = 4
_src_u_ptr$14 = -168					; size = 4
_x_fin$15 = -164					; size = 4
_y$16 = -160						; size = 4
_srcVLine$ = -156					; size = 4
_srcULine$ = -152					; size = 4
_src_uv_pitch$ = -148					; size = 4
$T17 = -144						; size = 16
$T18 = -128						; size = 16
_x0$19 = -112						; size = 16
_x$20 = -88						; size = 4
_dst_ptr$21 = -84					; size = 4
_src_ptr$22 = -80					; size = 4
_y$23 = -76						; size = 4
_y_width$ = -72						; size = 4
_dstLine$ = -68						; size = 4
_srcYLine$ = -64					; size = 4
$T24 = -60						; size = 12
_y_range$ = -44						; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yuv422_high_to_p210_simd@$0M@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv422_high_to_p210_simd<12>

; 1153 : static void __forceinline convert_yuv422_high_to_p210_simd(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 60 01 00
	00		 sub	 esp, 352		; 00000160H
  0001c	57		 push	 edi
  0001d	8d bd a0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-352]
  00023	b9 58 00 00 00	 mov	 ecx, 88			; 00000058H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1154 :     static_assert(8 < in_bit_depth && in_bit_depth <= 16, "in_bit_depth must be 9-16.");
; 1155 :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 1156 :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 1157 :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 1158 :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 1159 :     const int src_y_pitch = src_y_pitch_byte >> 1;

  0007c	8b 53 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  0007f	d1 fa		 sar	 edx, 1
  00081	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 1160 :     const int dst_y_pitch = dst_y_pitch_byte >> 1;

  00084	8b 43 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  00087	d1 f8		 sar	 eax, 1
  00089	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 1161 :     //Y成分のコピー
; 1162 :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  0008c	8b 4b 2c	 mov	 ecx, DWORD PTR _thread_n$[ebx]
  0008f	51		 push	 ecx
  00090	8b 53 28	 mov	 edx, DWORD PTR _thread_id$[ebx]
  00093	52		 push	 edx
  00094	8b 43 20	 mov	 eax, DWORD PTR _height$[ebx]
  00097	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  0009a	50		 push	 eax
  0009b	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  0009e	51		 push	 ecx
  0009f	8d 95 a0 fe ff
	ff		 lea	 edx, DWORD PTR $T1[ebp]
  000a5	52		 push	 edx
  000a6	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  000ab	83 c4 14	 add	 esp, 20			; 00000014H
  000ae	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b0	89 4d c4	 mov	 DWORD PTR $T24[ebp], ecx
  000b3	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000b6	89 55 c8	 mov	 DWORD PTR $T24[ebp+4], edx
  000b9	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000bc	89 45 cc	 mov	 DWORD PTR $T24[ebp+8], eax
  000bf	8b 4d c4	 mov	 ecx, DWORD PTR $T24[ebp]
  000c2	89 4d d4	 mov	 DWORD PTR _y_range$[ebp], ecx
  000c5	8b 55 c8	 mov	 edx, DWORD PTR $T24[ebp+4]
  000c8	89 55 d8	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000cb	8b 45 cc	 mov	 eax, DWORD PTR $T24[ebp+8]
  000ce	89 45 dc	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 1163 :     uint16_t *srcYLine = (uint16_t *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000d1	b9 04 00 00 00	 mov	 ecx, 4
  000d6	6b d1 00	 imul	 edx, ecx, 0
  000d9	8b 45 e8	 mov	 eax, DWORD PTR _src_y_pitch$[ebp]
  000dc	0f af 45 d4	 imul	 eax, DWORD PTR _y_range$[ebp]
  000e0	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  000e3	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  000e6	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  000e9	8b 4d f8	 mov	 ecx, DWORD PTR _crop_left$[ebp]
  000ec	8d 14 48	 lea	 edx, DWORD PTR [eax+ecx*2]
  000ef	89 55 c0	 mov	 DWORD PTR _srcYLine$[ebp], edx

; 1164 :     uint16_t *dstLine = (uint16_t *)dst[0] + dst_y_pitch * y_range.start_dst;

  000f2	b8 04 00 00 00	 mov	 eax, 4
  000f7	6b c8 00	 imul	 ecx, eax, 0
  000fa	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  000fd	0f af 55 d8	 imul	 edx, DWORD PTR _y_range$[ebp+4]
  00101	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  00104	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  00107	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  0010a	89 55 bc	 mov	 DWORD PTR _dstLine$[ebp], edx

; 1165 :     const int y_width = width - crop_right - crop_left;

  0010d	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  00110	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  00113	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  00116	89 45 b8	 mov	 DWORD PTR _y_width$[ebp], eax

; 1166 :     for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  00119	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _y$23[ebp], 0
  00120	eb 21		 jmp	 SHORT $LN4@convert_yu
$LN2@convert_yu:
  00122	8b 4d b4	 mov	 ecx, DWORD PTR _y$23[ebp]
  00125	83 c1 01	 add	 ecx, 1
  00128	89 4d b4	 mov	 DWORD PTR _y$23[ebp], ecx
  0012b	8b 55 e8	 mov	 edx, DWORD PTR _src_y_pitch$[ebp]
  0012e	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$[ebp]
  00131	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00134	89 4d c0	 mov	 DWORD PTR _srcYLine$[ebp], ecx
  00137	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  0013a	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$[ebp]
  0013d	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00140	89 4d bc	 mov	 DWORD PTR _dstLine$[ebp], ecx
$LN4@convert_yu:
  00143	8b 55 b4	 mov	 edx, DWORD PTR _y$23[ebp]
  00146	3b 55 dc	 cmp	 edx, DWORD PTR _y_range$[ebp+8]
  00149	0f 8d 92 00 00
	00		 jge	 $LN3@convert_yu

; 1167 :         if (in_bit_depth == 16) {

  0014f	33 c0		 xor	 eax, eax
  00151	74 18		 je	 SHORT $LN14@convert_yu

; 1168 :             memcpy_sse((uint8_t *)dstLine, (uint8_t *)srcYLine, y_width * sizeof(uint16_t));

  00153	8b 4d b8	 mov	 ecx, DWORD PTR _y_width$[ebp]
  00156	d1 e1		 shl	 ecx, 1
  00158	51		 push	 ecx
  00159	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$[ebp]
  0015c	52		 push	 edx
  0015d	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$[ebp]
  00160	50		 push	 eax
  00161	e8 00 00 00 00	 call	 ?memcpy_sse@@YAXPAEPBEH@Z ; memcpy_sse
  00166	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1169 :         } else {

  00169	eb 71		 jmp	 SHORT $LN15@convert_yu
$LN14@convert_yu:

; 1170 :             uint16_t *src_ptr = srcYLine;

  0016b	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$[ebp]
  0016e	89 4d b0	 mov	 DWORD PTR _src_ptr$22[ebp], ecx

; 1171 :             uint16_t *dst_ptr = dstLine;

  00171	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$[ebp]
  00174	89 55 ac	 mov	 DWORD PTR _dst_ptr$21[ebp], edx

; 1172 :             for (int x = 0; x < y_width; x += 8, dst_ptr += 8, src_ptr += 8) {

  00177	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR _x$20[ebp], 0
  0017e	eb 1b		 jmp	 SHORT $LN7@convert_yu
$LN5@convert_yu:
  00180	8b 45 a8	 mov	 eax, DWORD PTR _x$20[ebp]
  00183	83 c0 08	 add	 eax, 8
  00186	89 45 a8	 mov	 DWORD PTR _x$20[ebp], eax
  00189	8b 4d ac	 mov	 ecx, DWORD PTR _dst_ptr$21[ebp]
  0018c	83 c1 10	 add	 ecx, 16			; 00000010H
  0018f	89 4d ac	 mov	 DWORD PTR _dst_ptr$21[ebp], ecx
  00192	8b 55 b0	 mov	 edx, DWORD PTR _src_ptr$22[ebp]
  00195	83 c2 10	 add	 edx, 16			; 00000010H
  00198	89 55 b0	 mov	 DWORD PTR _src_ptr$22[ebp], edx
$LN7@convert_yu:
  0019b	8b 45 a8	 mov	 eax, DWORD PTR _x$20[ebp]
  0019e	3b 45 b8	 cmp	 eax, DWORD PTR _y_width$[ebp]
  001a1	7d 39		 jge	 SHORT $LN15@convert_yu

; 1173 :                 __m128i x0 = _mm_loadu_si128((const __m128i *)src_ptr);

  001a3	8b 4d b0	 mov	 ecx, DWORD PTR _src_ptr$22[ebp]
  001a6	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  001a9	0f 29 45 80	 movaps	 XMMWORD PTR $T18[ebp], xmm0
  001ad	0f 28 45 80	 movaps	 xmm0, XMMWORD PTR $T18[ebp]
  001b1	0f 29 45 90	 movaps	 XMMWORD PTR _x0$19[ebp], xmm0

; 1174 :                 x0 = _mm_slli_epi16(x0, 16 - in_bit_depth);

  001b5	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR _x0$19[ebp]
  001b9	66 0f 71 f0 04	 psllw	 xmm0, 4
  001be	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR $T17[ebp], xmm0
  001c5	0f 28 85 70 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T17[ebp]
  001cc	0f 29 45 90	 movaps	 XMMWORD PTR _x0$19[ebp], xmm0

; 1175 :                 _mm_storeu_si128((__m128i *)dst_ptr, x0);

  001d0	0f 10 45 90	 movups	 xmm0, XMMWORD PTR _x0$19[ebp]
  001d4	8b 55 ac	 mov	 edx, DWORD PTR _dst_ptr$21[ebp]
  001d7	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 1176 :             }

  001da	eb a4		 jmp	 SHORT $LN5@convert_yu
$LN15@convert_yu:

; 1177 :         }
; 1178 :     }

  001dc	e9 41 ff ff ff	 jmp	 $LN2@convert_yu
$LN3@convert_yu:

; 1179 :     //UV成分のコピー
; 1180 :     const int src_uv_pitch = src_uv_pitch_byte >> 1;

  001e1	8b 43 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebx]
  001e4	d1 f8		 sar	 eax, 1
  001e6	89 85 6c ff ff
	ff		 mov	 DWORD PTR _src_uv_pitch$[ebp], eax

; 1181 :     uint16_t *srcULine = (uint16_t *)src[1] + ((src_uv_pitch * y_range.start_src) + (crop_left >> 1));

  001ec	b9 04 00 00 00	 mov	 ecx, 4
  001f1	c1 e1 00	 shl	 ecx, 0
  001f4	8b 95 6c ff ff
	ff		 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  001fa	0f af 55 d4	 imul	 edx, DWORD PTR _y_range$[ebp]
  001fe	8b 45 f8	 mov	 eax, DWORD PTR _crop_left$[ebp]
  00201	d1 f8		 sar	 eax, 1
  00203	03 d0		 add	 edx, eax
  00205	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  00208	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  0020b	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  0020e	89 95 68 ff ff
	ff		 mov	 DWORD PTR _srcULine$[ebp], edx

; 1182 :     uint16_t *srcVLine = (uint16_t *)src[2] + ((src_uv_pitch * y_range.start_src) + (crop_left >> 1));

  00214	b8 04 00 00 00	 mov	 eax, 4
  00219	d1 e0		 shl	 eax, 1
  0021b	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00221	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  00225	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  00228	d1 fa		 sar	 edx, 1
  0022a	03 ca		 add	 ecx, edx
  0022c	8b 53 0c	 mov	 edx, DWORD PTR _src$[ebx]
  0022f	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  00232	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  00235	89 8d 64 ff ff
	ff		 mov	 DWORD PTR _srcVLine$[ebp], ecx

; 1183 :     dstLine = (uint16_t *)dst[1] + dst_y_pitch * y_range.start_dst;

  0023b	ba 04 00 00 00	 mov	 edx, 4
  00240	c1 e2 00	 shl	 edx, 0
  00243	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  00246	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  0024a	8b 4b 08	 mov	 ecx, DWORD PTR _dst$[ebx]
  0024d	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  00250	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  00253	89 45 bc	 mov	 DWORD PTR _dstLine$[ebp], eax

; 1184 :     for (int y = 0; y < y_range.len; y++, srcULine += src_uv_pitch, srcVLine += src_uv_pitch, dstLine += dst_y_pitch) {

  00256	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _y$16[ebp], 0
  00260	eb 45		 jmp	 SHORT $LN10@convert_yu
$LN8@convert_yu:
  00262	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _y$16[ebp]
  00268	83 c1 01	 add	 ecx, 1
  0026b	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _y$16[ebp], ecx
  00271	8b 95 6c ff ff
	ff		 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  00277	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _srcULine$[ebp]
  0027d	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00280	89 8d 68 ff ff
	ff		 mov	 DWORD PTR _srcULine$[ebp], ecx
  00286	8b 95 6c ff ff
	ff		 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  0028c	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _srcVLine$[ebp]
  00292	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00295	89 8d 64 ff ff
	ff		 mov	 DWORD PTR _srcVLine$[ebp], ecx
  0029b	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  0029e	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$[ebp]
  002a1	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  002a4	89 4d bc	 mov	 DWORD PTR _dstLine$[ebp], ecx
$LN10@convert_yu:
  002a7	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _y$16[ebp]
  002ad	3b 55 dc	 cmp	 edx, DWORD PTR _y_range$[ebp+8]
  002b0	0f 8d 82 01 00
	00		 jge	 $LN1@convert_yu

; 1185 :         const int x_fin = width - crop_right;

  002b6	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  002b9	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  002bc	89 85 5c ff ff
	ff		 mov	 DWORD PTR _x_fin$15[ebp], eax

; 1186 :         uint16_t *src_u_ptr = srcULine;

  002c2	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR _srcULine$[ebp]
  002c8	89 8d 58 ff ff
	ff		 mov	 DWORD PTR _src_u_ptr$14[ebp], ecx

; 1187 :         uint16_t *src_v_ptr = srcVLine;

  002ce	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR _srcVLine$[ebp]
  002d4	89 95 54 ff ff
	ff		 mov	 DWORD PTR _src_v_ptr$13[ebp], edx

; 1188 :         uint16_t *dst_ptr = dstLine;

  002da	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$[ebp]
  002dd	89 85 50 ff ff
	ff		 mov	 DWORD PTR _dst_ptr$12[ebp], eax

; 1189 :         __m128i x0, x1, x2;
; 1190 :         for (int x = crop_left; x < x_fin; x += 16, src_u_ptr += 8, src_v_ptr += 8, dst_ptr += 16) {

  002e3	8b 4d f8	 mov	 ecx, DWORD PTR _crop_left$[ebp]
  002e6	89 8d 1c ff ff
	ff		 mov	 DWORD PTR _x$8[ebp], ecx
  002ec	eb 3c		 jmp	 SHORT $LN13@convert_yu
$LN11@convert_yu:
  002ee	8b 95 1c ff ff
	ff		 mov	 edx, DWORD PTR _x$8[ebp]
  002f4	83 c2 10	 add	 edx, 16			; 00000010H
  002f7	89 95 1c ff ff
	ff		 mov	 DWORD PTR _x$8[ebp], edx
  002fd	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _src_u_ptr$14[ebp]
  00303	83 c0 10	 add	 eax, 16			; 00000010H
  00306	89 85 58 ff ff
	ff		 mov	 DWORD PTR _src_u_ptr$14[ebp], eax
  0030c	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _src_v_ptr$13[ebp]
  00312	83 c1 10	 add	 ecx, 16			; 00000010H
  00315	89 8d 54 ff ff
	ff		 mov	 DWORD PTR _src_v_ptr$13[ebp], ecx
  0031b	8b 95 50 ff ff
	ff		 mov	 edx, DWORD PTR _dst_ptr$12[ebp]
  00321	83 c2 20	 add	 edx, 32			; 00000020H
  00324	89 95 50 ff ff
	ff		 mov	 DWORD PTR _dst_ptr$12[ebp], edx
$LN13@convert_yu:
  0032a	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR _x$8[ebp]
  00330	3b 85 5c ff ff
	ff		 cmp	 eax, DWORD PTR _x_fin$15[ebp]
  00336	0f 8d f7 00 00
	00		 jge	 $LN12@convert_yu

; 1191 :             x0 = _mm_loadu_si128((const __m128i *)src_u_ptr);

  0033c	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _src_u_ptr$14[ebp]
  00342	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00345	0f 29 85 00 ff
	ff ff		 movaps	 XMMWORD PTR $T7[ebp], xmm0
  0034c	0f 28 85 00 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T7[ebp]
  00353	0f 29 85 40 ff
	ff ff		 movaps	 XMMWORD PTR _x0$11[ebp], xmm0

; 1192 :             x1 = _mm_loadu_si128((const __m128i *)src_v_ptr);

  0035a	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR _src_v_ptr$13[ebp]
  00360	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  00363	0f 29 85 f0 fe
	ff ff		 movaps	 XMMWORD PTR $T6[ebp], xmm0
  0036a	0f 28 85 f0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T6[ebp]
  00371	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR _x1$10[ebp], xmm0

; 1193 : 
; 1194 :             if (in_bit_depth < 16) {

  00378	b8 01 00 00 00	 mov	 eax, 1
  0037d	85 c0		 test	 eax, eax
  0037f	74 42		 je	 SHORT $LN16@convert_yu

; 1195 :                 x0 = _mm_slli_epi16(x0, 16 - in_bit_depth);

  00381	0f 28 85 40 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x0$11[ebp]
  00388	66 0f 71 f0 04	 psllw	 xmm0, 4
  0038d	0f 29 85 e0 fe
	ff ff		 movaps	 XMMWORD PTR $T5[ebp], xmm0
  00394	0f 28 85 e0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T5[ebp]
  0039b	0f 29 85 40 ff
	ff ff		 movaps	 XMMWORD PTR _x0$11[ebp], xmm0

; 1196 :                 x1 = _mm_slli_epi16(x1, 16 - in_bit_depth);

  003a2	0f 28 85 30 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$10[ebp]
  003a9	66 0f 71 f0 04	 psllw	 xmm0, 4
  003ae	0f 29 85 d0 fe
	ff ff		 movaps	 XMMWORD PTR $T4[ebp], xmm0
  003b5	0f 28 85 d0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T4[ebp]
  003bc	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR _x1$10[ebp], xmm0
$LN16@convert_yu:

; 1197 :             }
; 1198 : 
; 1199 :             x2 = _mm_unpackhi_epi16(x0, x1);

  003c3	0f 28 85 40 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x0$11[ebp]
  003ca	66 0f 69 85 30
	ff ff ff	 punpckhwd xmm0, XMMWORD PTR _x1$10[ebp]
  003d2	0f 29 85 c0 fe
	ff ff		 movaps	 XMMWORD PTR $T3[ebp], xmm0
  003d9	0f 28 85 c0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T3[ebp]
  003e0	0f 29 85 20 ff
	ff ff		 movaps	 XMMWORD PTR _x2$9[ebp], xmm0

; 1200 :             x0 = _mm_unpacklo_epi16(x0, x1);

  003e7	0f 28 85 40 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x0$11[ebp]
  003ee	66 0f 61 85 30
	ff ff ff	 punpcklwd xmm0, XMMWORD PTR _x1$10[ebp]
  003f6	0f 29 85 b0 fe
	ff ff		 movaps	 XMMWORD PTR $T2[ebp], xmm0
  003fd	0f 28 85 b0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T2[ebp]
  00404	0f 29 85 40 ff
	ff ff		 movaps	 XMMWORD PTR _x0$11[ebp], xmm0

; 1201 : 
; 1202 :             _mm_storeu_si128((__m128i *)(dst_ptr + 0), x0);

  0040b	0f 10 85 40 ff
	ff ff		 movups	 xmm0, XMMWORD PTR _x0$11[ebp]
  00412	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR _dst_ptr$12[ebp]
  00418	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 1203 :             _mm_storeu_si128((__m128i *)(dst_ptr + 8), x2);

  0041b	0f 10 85 20 ff
	ff ff		 movups	 xmm0, XMMWORD PTR _x2$9[ebp]
  00422	8b 95 50 ff ff
	ff		 mov	 edx, DWORD PTR _dst_ptr$12[ebp]
  00428	83 c2 10	 add	 edx, 16			; 00000010H
  0042b	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 1204 :         }

  0042e	e9 bb fe ff ff	 jmp	 $LN11@convert_yu
$LN12@convert_yu:

; 1205 :     }

  00433	e9 2a fe ff ff	 jmp	 $LN8@convert_yu
$LN1@convert_yu:

; 1206 : }

  00438	52		 push	 edx
  00439	8b cd		 mov	 ecx, ebp
  0043b	50		 push	 eax
  0043c	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN20@convert_yu
  00442	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00447	58		 pop	 eax
  00448	5a		 pop	 edx
  00449	5f		 pop	 edi
  0044a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0044d	33 cd		 xor	 ecx, ebp
  0044f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00454	8b e5		 mov	 esp, ebp
  00456	5d		 pop	 ebp
  00457	8b e3		 mov	 esp, ebx
  00459	5b		 pop	 ebx
  0045a	c3		 ret	 0
  0045b	90		 npad	 1
$LN20@convert_yu:
  0045c	01 00 00 00	 DD	 1
  00460	00 00 00 00	 DD	 $LN19@convert_yu
$LN19@convert_yu:
  00464	d4 ff ff ff	 DD	 -44			; ffffffd4H
  00468	0c 00 00 00	 DD	 12			; 0000000cH
  0046c	00 00 00 00	 DD	 $LN18@convert_yu
$LN18@convert_yu:
  00470	79		 DB	 121			; 00000079H
  00471	5f		 DB	 95			; 0000005fH
  00472	72		 DB	 114			; 00000072H
  00473	61		 DB	 97			; 00000061H
  00474	6e		 DB	 110			; 0000006eH
  00475	67		 DB	 103			; 00000067H
  00476	65		 DB	 101			; 00000065H
  00477	00		 DB	 0
??$convert_yuv422_high_to_p210_simd@$0M@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv422_high_to_p210_simd<12>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_sse2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuv422_12_to_p210_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv422_12_to_p210_sse2

; 229  : void convert_yuv422_12_to_p210_sse2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 230  :     convert_yuv422_high_to_p210_simd<12>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yuv422_high_to_p210_simd@$0M@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv422_high_to_p210_simd<12>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 231  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yuv422_12_to_p210_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv422_12_to_p210_sse2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -352						; size = 12
$T2 = -336						; size = 16
$T3 = -320						; size = 16
$T4 = -304						; size = 16
$T5 = -288						; size = 16
$T6 = -272						; size = 16
$T7 = -256						; size = 16
_x$8 = -228						; size = 4
_x2$9 = -224						; size = 16
_x1$10 = -208						; size = 16
_x0$11 = -192						; size = 16
_dst_ptr$12 = -176					; size = 4
_src_v_ptr$13 = -172					; size = 4
_src_u_ptr$14 = -168					; size = 4
_x_fin$15 = -164					; size = 4
_y$16 = -160						; size = 4
_srcVLine$ = -156					; size = 4
_srcULine$ = -152					; size = 4
_src_uv_pitch$ = -148					; size = 4
$T17 = -144						; size = 16
$T18 = -128						; size = 16
_x0$19 = -112						; size = 16
_x$20 = -88						; size = 4
_dst_ptr$21 = -84					; size = 4
_src_ptr$22 = -80					; size = 4
_y$23 = -76						; size = 4
_y_width$ = -72						; size = 4
_dstLine$ = -68						; size = 4
_srcYLine$ = -64					; size = 4
$T24 = -60						; size = 12
_y_range$ = -44						; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yuv422_high_to_p210_simd@$09@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv422_high_to_p210_simd<10>

; 1153 : static void __forceinline convert_yuv422_high_to_p210_simd(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 60 01 00
	00		 sub	 esp, 352		; 00000160H
  0001c	57		 push	 edi
  0001d	8d bd a0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-352]
  00023	b9 58 00 00 00	 mov	 ecx, 88			; 00000058H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1154 :     static_assert(8 < in_bit_depth && in_bit_depth <= 16, "in_bit_depth must be 9-16.");
; 1155 :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 1156 :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 1157 :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 1158 :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 1159 :     const int src_y_pitch = src_y_pitch_byte >> 1;

  0007c	8b 53 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  0007f	d1 fa		 sar	 edx, 1
  00081	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 1160 :     const int dst_y_pitch = dst_y_pitch_byte >> 1;

  00084	8b 43 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  00087	d1 f8		 sar	 eax, 1
  00089	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 1161 :     //Y成分のコピー
; 1162 :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  0008c	8b 4b 2c	 mov	 ecx, DWORD PTR _thread_n$[ebx]
  0008f	51		 push	 ecx
  00090	8b 53 28	 mov	 edx, DWORD PTR _thread_id$[ebx]
  00093	52		 push	 edx
  00094	8b 43 20	 mov	 eax, DWORD PTR _height$[ebx]
  00097	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  0009a	50		 push	 eax
  0009b	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  0009e	51		 push	 ecx
  0009f	8d 95 a0 fe ff
	ff		 lea	 edx, DWORD PTR $T1[ebp]
  000a5	52		 push	 edx
  000a6	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  000ab	83 c4 14	 add	 esp, 20			; 00000014H
  000ae	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b0	89 4d c4	 mov	 DWORD PTR $T24[ebp], ecx
  000b3	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000b6	89 55 c8	 mov	 DWORD PTR $T24[ebp+4], edx
  000b9	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000bc	89 45 cc	 mov	 DWORD PTR $T24[ebp+8], eax
  000bf	8b 4d c4	 mov	 ecx, DWORD PTR $T24[ebp]
  000c2	89 4d d4	 mov	 DWORD PTR _y_range$[ebp], ecx
  000c5	8b 55 c8	 mov	 edx, DWORD PTR $T24[ebp+4]
  000c8	89 55 d8	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000cb	8b 45 cc	 mov	 eax, DWORD PTR $T24[ebp+8]
  000ce	89 45 dc	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 1163 :     uint16_t *srcYLine = (uint16_t *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000d1	b9 04 00 00 00	 mov	 ecx, 4
  000d6	6b d1 00	 imul	 edx, ecx, 0
  000d9	8b 45 e8	 mov	 eax, DWORD PTR _src_y_pitch$[ebp]
  000dc	0f af 45 d4	 imul	 eax, DWORD PTR _y_range$[ebp]
  000e0	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  000e3	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  000e6	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  000e9	8b 4d f8	 mov	 ecx, DWORD PTR _crop_left$[ebp]
  000ec	8d 14 48	 lea	 edx, DWORD PTR [eax+ecx*2]
  000ef	89 55 c0	 mov	 DWORD PTR _srcYLine$[ebp], edx

; 1164 :     uint16_t *dstLine = (uint16_t *)dst[0] + dst_y_pitch * y_range.start_dst;

  000f2	b8 04 00 00 00	 mov	 eax, 4
  000f7	6b c8 00	 imul	 ecx, eax, 0
  000fa	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  000fd	0f af 55 d8	 imul	 edx, DWORD PTR _y_range$[ebp+4]
  00101	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  00104	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  00107	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  0010a	89 55 bc	 mov	 DWORD PTR _dstLine$[ebp], edx

; 1165 :     const int y_width = width - crop_right - crop_left;

  0010d	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  00110	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  00113	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  00116	89 45 b8	 mov	 DWORD PTR _y_width$[ebp], eax

; 1166 :     for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  00119	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _y$23[ebp], 0
  00120	eb 21		 jmp	 SHORT $LN4@convert_yu
$LN2@convert_yu:
  00122	8b 4d b4	 mov	 ecx, DWORD PTR _y$23[ebp]
  00125	83 c1 01	 add	 ecx, 1
  00128	89 4d b4	 mov	 DWORD PTR _y$23[ebp], ecx
  0012b	8b 55 e8	 mov	 edx, DWORD PTR _src_y_pitch$[ebp]
  0012e	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$[ebp]
  00131	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00134	89 4d c0	 mov	 DWORD PTR _srcYLine$[ebp], ecx
  00137	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  0013a	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$[ebp]
  0013d	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00140	89 4d bc	 mov	 DWORD PTR _dstLine$[ebp], ecx
$LN4@convert_yu:
  00143	8b 55 b4	 mov	 edx, DWORD PTR _y$23[ebp]
  00146	3b 55 dc	 cmp	 edx, DWORD PTR _y_range$[ebp+8]
  00149	0f 8d 92 00 00
	00		 jge	 $LN3@convert_yu

; 1167 :         if (in_bit_depth == 16) {

  0014f	33 c0		 xor	 eax, eax
  00151	74 18		 je	 SHORT $LN14@convert_yu

; 1168 :             memcpy_sse((uint8_t *)dstLine, (uint8_t *)srcYLine, y_width * sizeof(uint16_t));

  00153	8b 4d b8	 mov	 ecx, DWORD PTR _y_width$[ebp]
  00156	d1 e1		 shl	 ecx, 1
  00158	51		 push	 ecx
  00159	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$[ebp]
  0015c	52		 push	 edx
  0015d	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$[ebp]
  00160	50		 push	 eax
  00161	e8 00 00 00 00	 call	 ?memcpy_sse@@YAXPAEPBEH@Z ; memcpy_sse
  00166	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1169 :         } else {

  00169	eb 71		 jmp	 SHORT $LN15@convert_yu
$LN14@convert_yu:

; 1170 :             uint16_t *src_ptr = srcYLine;

  0016b	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$[ebp]
  0016e	89 4d b0	 mov	 DWORD PTR _src_ptr$22[ebp], ecx

; 1171 :             uint16_t *dst_ptr = dstLine;

  00171	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$[ebp]
  00174	89 55 ac	 mov	 DWORD PTR _dst_ptr$21[ebp], edx

; 1172 :             for (int x = 0; x < y_width; x += 8, dst_ptr += 8, src_ptr += 8) {

  00177	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR _x$20[ebp], 0
  0017e	eb 1b		 jmp	 SHORT $LN7@convert_yu
$LN5@convert_yu:
  00180	8b 45 a8	 mov	 eax, DWORD PTR _x$20[ebp]
  00183	83 c0 08	 add	 eax, 8
  00186	89 45 a8	 mov	 DWORD PTR _x$20[ebp], eax
  00189	8b 4d ac	 mov	 ecx, DWORD PTR _dst_ptr$21[ebp]
  0018c	83 c1 10	 add	 ecx, 16			; 00000010H
  0018f	89 4d ac	 mov	 DWORD PTR _dst_ptr$21[ebp], ecx
  00192	8b 55 b0	 mov	 edx, DWORD PTR _src_ptr$22[ebp]
  00195	83 c2 10	 add	 edx, 16			; 00000010H
  00198	89 55 b0	 mov	 DWORD PTR _src_ptr$22[ebp], edx
$LN7@convert_yu:
  0019b	8b 45 a8	 mov	 eax, DWORD PTR _x$20[ebp]
  0019e	3b 45 b8	 cmp	 eax, DWORD PTR _y_width$[ebp]
  001a1	7d 39		 jge	 SHORT $LN15@convert_yu

; 1173 :                 __m128i x0 = _mm_loadu_si128((const __m128i *)src_ptr);

  001a3	8b 4d b0	 mov	 ecx, DWORD PTR _src_ptr$22[ebp]
  001a6	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  001a9	0f 29 45 80	 movaps	 XMMWORD PTR $T18[ebp], xmm0
  001ad	0f 28 45 80	 movaps	 xmm0, XMMWORD PTR $T18[ebp]
  001b1	0f 29 45 90	 movaps	 XMMWORD PTR _x0$19[ebp], xmm0

; 1174 :                 x0 = _mm_slli_epi16(x0, 16 - in_bit_depth);

  001b5	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR _x0$19[ebp]
  001b9	66 0f 71 f0 06	 psllw	 xmm0, 6
  001be	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR $T17[ebp], xmm0
  001c5	0f 28 85 70 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T17[ebp]
  001cc	0f 29 45 90	 movaps	 XMMWORD PTR _x0$19[ebp], xmm0

; 1175 :                 _mm_storeu_si128((__m128i *)dst_ptr, x0);

  001d0	0f 10 45 90	 movups	 xmm0, XMMWORD PTR _x0$19[ebp]
  001d4	8b 55 ac	 mov	 edx, DWORD PTR _dst_ptr$21[ebp]
  001d7	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 1176 :             }

  001da	eb a4		 jmp	 SHORT $LN5@convert_yu
$LN15@convert_yu:

; 1177 :         }
; 1178 :     }

  001dc	e9 41 ff ff ff	 jmp	 $LN2@convert_yu
$LN3@convert_yu:

; 1179 :     //UV成分のコピー
; 1180 :     const int src_uv_pitch = src_uv_pitch_byte >> 1;

  001e1	8b 43 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebx]
  001e4	d1 f8		 sar	 eax, 1
  001e6	89 85 6c ff ff
	ff		 mov	 DWORD PTR _src_uv_pitch$[ebp], eax

; 1181 :     uint16_t *srcULine = (uint16_t *)src[1] + ((src_uv_pitch * y_range.start_src) + (crop_left >> 1));

  001ec	b9 04 00 00 00	 mov	 ecx, 4
  001f1	c1 e1 00	 shl	 ecx, 0
  001f4	8b 95 6c ff ff
	ff		 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  001fa	0f af 55 d4	 imul	 edx, DWORD PTR _y_range$[ebp]
  001fe	8b 45 f8	 mov	 eax, DWORD PTR _crop_left$[ebp]
  00201	d1 f8		 sar	 eax, 1
  00203	03 d0		 add	 edx, eax
  00205	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  00208	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  0020b	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  0020e	89 95 68 ff ff
	ff		 mov	 DWORD PTR _srcULine$[ebp], edx

; 1182 :     uint16_t *srcVLine = (uint16_t *)src[2] + ((src_uv_pitch * y_range.start_src) + (crop_left >> 1));

  00214	b8 04 00 00 00	 mov	 eax, 4
  00219	d1 e0		 shl	 eax, 1
  0021b	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00221	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  00225	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  00228	d1 fa		 sar	 edx, 1
  0022a	03 ca		 add	 ecx, edx
  0022c	8b 53 0c	 mov	 edx, DWORD PTR _src$[ebx]
  0022f	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  00232	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  00235	89 8d 64 ff ff
	ff		 mov	 DWORD PTR _srcVLine$[ebp], ecx

; 1183 :     dstLine = (uint16_t *)dst[1] + dst_y_pitch * y_range.start_dst;

  0023b	ba 04 00 00 00	 mov	 edx, 4
  00240	c1 e2 00	 shl	 edx, 0
  00243	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  00246	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  0024a	8b 4b 08	 mov	 ecx, DWORD PTR _dst$[ebx]
  0024d	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  00250	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  00253	89 45 bc	 mov	 DWORD PTR _dstLine$[ebp], eax

; 1184 :     for (int y = 0; y < y_range.len; y++, srcULine += src_uv_pitch, srcVLine += src_uv_pitch, dstLine += dst_y_pitch) {

  00256	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _y$16[ebp], 0
  00260	eb 45		 jmp	 SHORT $LN10@convert_yu
$LN8@convert_yu:
  00262	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _y$16[ebp]
  00268	83 c1 01	 add	 ecx, 1
  0026b	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _y$16[ebp], ecx
  00271	8b 95 6c ff ff
	ff		 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  00277	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _srcULine$[ebp]
  0027d	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00280	89 8d 68 ff ff
	ff		 mov	 DWORD PTR _srcULine$[ebp], ecx
  00286	8b 95 6c ff ff
	ff		 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  0028c	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _srcVLine$[ebp]
  00292	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00295	89 8d 64 ff ff
	ff		 mov	 DWORD PTR _srcVLine$[ebp], ecx
  0029b	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  0029e	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$[ebp]
  002a1	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  002a4	89 4d bc	 mov	 DWORD PTR _dstLine$[ebp], ecx
$LN10@convert_yu:
  002a7	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _y$16[ebp]
  002ad	3b 55 dc	 cmp	 edx, DWORD PTR _y_range$[ebp+8]
  002b0	0f 8d 82 01 00
	00		 jge	 $LN1@convert_yu

; 1185 :         const int x_fin = width - crop_right;

  002b6	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  002b9	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  002bc	89 85 5c ff ff
	ff		 mov	 DWORD PTR _x_fin$15[ebp], eax

; 1186 :         uint16_t *src_u_ptr = srcULine;

  002c2	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR _srcULine$[ebp]
  002c8	89 8d 58 ff ff
	ff		 mov	 DWORD PTR _src_u_ptr$14[ebp], ecx

; 1187 :         uint16_t *src_v_ptr = srcVLine;

  002ce	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR _srcVLine$[ebp]
  002d4	89 95 54 ff ff
	ff		 mov	 DWORD PTR _src_v_ptr$13[ebp], edx

; 1188 :         uint16_t *dst_ptr = dstLine;

  002da	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$[ebp]
  002dd	89 85 50 ff ff
	ff		 mov	 DWORD PTR _dst_ptr$12[ebp], eax

; 1189 :         __m128i x0, x1, x2;
; 1190 :         for (int x = crop_left; x < x_fin; x += 16, src_u_ptr += 8, src_v_ptr += 8, dst_ptr += 16) {

  002e3	8b 4d f8	 mov	 ecx, DWORD PTR _crop_left$[ebp]
  002e6	89 8d 1c ff ff
	ff		 mov	 DWORD PTR _x$8[ebp], ecx
  002ec	eb 3c		 jmp	 SHORT $LN13@convert_yu
$LN11@convert_yu:
  002ee	8b 95 1c ff ff
	ff		 mov	 edx, DWORD PTR _x$8[ebp]
  002f4	83 c2 10	 add	 edx, 16			; 00000010H
  002f7	89 95 1c ff ff
	ff		 mov	 DWORD PTR _x$8[ebp], edx
  002fd	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _src_u_ptr$14[ebp]
  00303	83 c0 10	 add	 eax, 16			; 00000010H
  00306	89 85 58 ff ff
	ff		 mov	 DWORD PTR _src_u_ptr$14[ebp], eax
  0030c	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _src_v_ptr$13[ebp]
  00312	83 c1 10	 add	 ecx, 16			; 00000010H
  00315	89 8d 54 ff ff
	ff		 mov	 DWORD PTR _src_v_ptr$13[ebp], ecx
  0031b	8b 95 50 ff ff
	ff		 mov	 edx, DWORD PTR _dst_ptr$12[ebp]
  00321	83 c2 20	 add	 edx, 32			; 00000020H
  00324	89 95 50 ff ff
	ff		 mov	 DWORD PTR _dst_ptr$12[ebp], edx
$LN13@convert_yu:
  0032a	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR _x$8[ebp]
  00330	3b 85 5c ff ff
	ff		 cmp	 eax, DWORD PTR _x_fin$15[ebp]
  00336	0f 8d f7 00 00
	00		 jge	 $LN12@convert_yu

; 1191 :             x0 = _mm_loadu_si128((const __m128i *)src_u_ptr);

  0033c	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _src_u_ptr$14[ebp]
  00342	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00345	0f 29 85 00 ff
	ff ff		 movaps	 XMMWORD PTR $T7[ebp], xmm0
  0034c	0f 28 85 00 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T7[ebp]
  00353	0f 29 85 40 ff
	ff ff		 movaps	 XMMWORD PTR _x0$11[ebp], xmm0

; 1192 :             x1 = _mm_loadu_si128((const __m128i *)src_v_ptr);

  0035a	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR _src_v_ptr$13[ebp]
  00360	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  00363	0f 29 85 f0 fe
	ff ff		 movaps	 XMMWORD PTR $T6[ebp], xmm0
  0036a	0f 28 85 f0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T6[ebp]
  00371	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR _x1$10[ebp], xmm0

; 1193 : 
; 1194 :             if (in_bit_depth < 16) {

  00378	b8 01 00 00 00	 mov	 eax, 1
  0037d	85 c0		 test	 eax, eax
  0037f	74 42		 je	 SHORT $LN16@convert_yu

; 1195 :                 x0 = _mm_slli_epi16(x0, 16 - in_bit_depth);

  00381	0f 28 85 40 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x0$11[ebp]
  00388	66 0f 71 f0 06	 psllw	 xmm0, 6
  0038d	0f 29 85 e0 fe
	ff ff		 movaps	 XMMWORD PTR $T5[ebp], xmm0
  00394	0f 28 85 e0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T5[ebp]
  0039b	0f 29 85 40 ff
	ff ff		 movaps	 XMMWORD PTR _x0$11[ebp], xmm0

; 1196 :                 x1 = _mm_slli_epi16(x1, 16 - in_bit_depth);

  003a2	0f 28 85 30 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$10[ebp]
  003a9	66 0f 71 f0 06	 psllw	 xmm0, 6
  003ae	0f 29 85 d0 fe
	ff ff		 movaps	 XMMWORD PTR $T4[ebp], xmm0
  003b5	0f 28 85 d0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T4[ebp]
  003bc	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR _x1$10[ebp], xmm0
$LN16@convert_yu:

; 1197 :             }
; 1198 : 
; 1199 :             x2 = _mm_unpackhi_epi16(x0, x1);

  003c3	0f 28 85 40 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x0$11[ebp]
  003ca	66 0f 69 85 30
	ff ff ff	 punpckhwd xmm0, XMMWORD PTR _x1$10[ebp]
  003d2	0f 29 85 c0 fe
	ff ff		 movaps	 XMMWORD PTR $T3[ebp], xmm0
  003d9	0f 28 85 c0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T3[ebp]
  003e0	0f 29 85 20 ff
	ff ff		 movaps	 XMMWORD PTR _x2$9[ebp], xmm0

; 1200 :             x0 = _mm_unpacklo_epi16(x0, x1);

  003e7	0f 28 85 40 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x0$11[ebp]
  003ee	66 0f 61 85 30
	ff ff ff	 punpcklwd xmm0, XMMWORD PTR _x1$10[ebp]
  003f6	0f 29 85 b0 fe
	ff ff		 movaps	 XMMWORD PTR $T2[ebp], xmm0
  003fd	0f 28 85 b0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T2[ebp]
  00404	0f 29 85 40 ff
	ff ff		 movaps	 XMMWORD PTR _x0$11[ebp], xmm0

; 1201 : 
; 1202 :             _mm_storeu_si128((__m128i *)(dst_ptr + 0), x0);

  0040b	0f 10 85 40 ff
	ff ff		 movups	 xmm0, XMMWORD PTR _x0$11[ebp]
  00412	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR _dst_ptr$12[ebp]
  00418	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 1203 :             _mm_storeu_si128((__m128i *)(dst_ptr + 8), x2);

  0041b	0f 10 85 20 ff
	ff ff		 movups	 xmm0, XMMWORD PTR _x2$9[ebp]
  00422	8b 95 50 ff ff
	ff		 mov	 edx, DWORD PTR _dst_ptr$12[ebp]
  00428	83 c2 10	 add	 edx, 16			; 00000010H
  0042b	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 1204 :         }

  0042e	e9 bb fe ff ff	 jmp	 $LN11@convert_yu
$LN12@convert_yu:

; 1205 :     }

  00433	e9 2a fe ff ff	 jmp	 $LN8@convert_yu
$LN1@convert_yu:

; 1206 : }

  00438	52		 push	 edx
  00439	8b cd		 mov	 ecx, ebp
  0043b	50		 push	 eax
  0043c	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN20@convert_yu
  00442	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00447	58		 pop	 eax
  00448	5a		 pop	 edx
  00449	5f		 pop	 edi
  0044a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0044d	33 cd		 xor	 ecx, ebp
  0044f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00454	8b e5		 mov	 esp, ebp
  00456	5d		 pop	 ebp
  00457	8b e3		 mov	 esp, ebx
  00459	5b		 pop	 ebx
  0045a	c3		 ret	 0
  0045b	90		 npad	 1
$LN20@convert_yu:
  0045c	01 00 00 00	 DD	 1
  00460	00 00 00 00	 DD	 $LN19@convert_yu
$LN19@convert_yu:
  00464	d4 ff ff ff	 DD	 -44			; ffffffd4H
  00468	0c 00 00 00	 DD	 12			; 0000000cH
  0046c	00 00 00 00	 DD	 $LN18@convert_yu
$LN18@convert_yu:
  00470	79		 DB	 121			; 00000079H
  00471	5f		 DB	 95			; 0000005fH
  00472	72		 DB	 114			; 00000072H
  00473	61		 DB	 97			; 00000061H
  00474	6e		 DB	 110			; 0000006eH
  00475	67		 DB	 103			; 00000067H
  00476	65		 DB	 101			; 00000065H
  00477	00		 DB	 0
??$convert_yuv422_high_to_p210_simd@$09@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv422_high_to_p210_simd<10>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_sse2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuv422_10_to_p210_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv422_10_to_p210_sse2

; 225  : void convert_yuv422_10_to_p210_sse2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 226  :     convert_yuv422_high_to_p210_simd<10>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yuv422_high_to_p210_simd@$09@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv422_high_to_p210_simd<10>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 227  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yuv422_10_to_p210_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv422_10_to_p210_sse2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -352						; size = 12
$T2 = -336						; size = 16
$T3 = -320						; size = 16
$T4 = -304						; size = 16
$T5 = -288						; size = 16
$T6 = -272						; size = 16
$T7 = -256						; size = 16
_x$8 = -228						; size = 4
_x2$9 = -224						; size = 16
_x1$10 = -208						; size = 16
_x0$11 = -192						; size = 16
_dst_ptr$12 = -176					; size = 4
_src_v_ptr$13 = -172					; size = 4
_src_u_ptr$14 = -168					; size = 4
_x_fin$15 = -164					; size = 4
_y$16 = -160						; size = 4
_srcVLine$ = -156					; size = 4
_srcULine$ = -152					; size = 4
_src_uv_pitch$ = -148					; size = 4
$T17 = -144						; size = 16
$T18 = -128						; size = 16
_x0$19 = -112						; size = 16
_x$20 = -88						; size = 4
_dst_ptr$21 = -84					; size = 4
_src_ptr$22 = -80					; size = 4
_y$23 = -76						; size = 4
_y_width$ = -72						; size = 4
_dstLine$ = -68						; size = 4
_srcYLine$ = -64					; size = 4
$T24 = -60						; size = 12
_y_range$ = -44						; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yuv422_high_to_p210_simd@$08@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv422_high_to_p210_simd<9>

; 1153 : static void __forceinline convert_yuv422_high_to_p210_simd(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 60 01 00
	00		 sub	 esp, 352		; 00000160H
  0001c	57		 push	 edi
  0001d	8d bd a0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-352]
  00023	b9 58 00 00 00	 mov	 ecx, 88			; 00000058H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1154 :     static_assert(8 < in_bit_depth && in_bit_depth <= 16, "in_bit_depth must be 9-16.");
; 1155 :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 1156 :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 1157 :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 1158 :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 1159 :     const int src_y_pitch = src_y_pitch_byte >> 1;

  0007c	8b 53 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  0007f	d1 fa		 sar	 edx, 1
  00081	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 1160 :     const int dst_y_pitch = dst_y_pitch_byte >> 1;

  00084	8b 43 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  00087	d1 f8		 sar	 eax, 1
  00089	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 1161 :     //Y成分のコピー
; 1162 :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  0008c	8b 4b 2c	 mov	 ecx, DWORD PTR _thread_n$[ebx]
  0008f	51		 push	 ecx
  00090	8b 53 28	 mov	 edx, DWORD PTR _thread_id$[ebx]
  00093	52		 push	 edx
  00094	8b 43 20	 mov	 eax, DWORD PTR _height$[ebx]
  00097	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  0009a	50		 push	 eax
  0009b	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  0009e	51		 push	 ecx
  0009f	8d 95 a0 fe ff
	ff		 lea	 edx, DWORD PTR $T1[ebp]
  000a5	52		 push	 edx
  000a6	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  000ab	83 c4 14	 add	 esp, 20			; 00000014H
  000ae	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b0	89 4d c4	 mov	 DWORD PTR $T24[ebp], ecx
  000b3	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000b6	89 55 c8	 mov	 DWORD PTR $T24[ebp+4], edx
  000b9	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000bc	89 45 cc	 mov	 DWORD PTR $T24[ebp+8], eax
  000bf	8b 4d c4	 mov	 ecx, DWORD PTR $T24[ebp]
  000c2	89 4d d4	 mov	 DWORD PTR _y_range$[ebp], ecx
  000c5	8b 55 c8	 mov	 edx, DWORD PTR $T24[ebp+4]
  000c8	89 55 d8	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000cb	8b 45 cc	 mov	 eax, DWORD PTR $T24[ebp+8]
  000ce	89 45 dc	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 1163 :     uint16_t *srcYLine = (uint16_t *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000d1	b9 04 00 00 00	 mov	 ecx, 4
  000d6	6b d1 00	 imul	 edx, ecx, 0
  000d9	8b 45 e8	 mov	 eax, DWORD PTR _src_y_pitch$[ebp]
  000dc	0f af 45 d4	 imul	 eax, DWORD PTR _y_range$[ebp]
  000e0	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  000e3	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  000e6	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  000e9	8b 4d f8	 mov	 ecx, DWORD PTR _crop_left$[ebp]
  000ec	8d 14 48	 lea	 edx, DWORD PTR [eax+ecx*2]
  000ef	89 55 c0	 mov	 DWORD PTR _srcYLine$[ebp], edx

; 1164 :     uint16_t *dstLine = (uint16_t *)dst[0] + dst_y_pitch * y_range.start_dst;

  000f2	b8 04 00 00 00	 mov	 eax, 4
  000f7	6b c8 00	 imul	 ecx, eax, 0
  000fa	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  000fd	0f af 55 d8	 imul	 edx, DWORD PTR _y_range$[ebp+4]
  00101	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  00104	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  00107	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  0010a	89 55 bc	 mov	 DWORD PTR _dstLine$[ebp], edx

; 1165 :     const int y_width = width - crop_right - crop_left;

  0010d	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  00110	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  00113	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  00116	89 45 b8	 mov	 DWORD PTR _y_width$[ebp], eax

; 1166 :     for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  00119	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _y$23[ebp], 0
  00120	eb 21		 jmp	 SHORT $LN4@convert_yu
$LN2@convert_yu:
  00122	8b 4d b4	 mov	 ecx, DWORD PTR _y$23[ebp]
  00125	83 c1 01	 add	 ecx, 1
  00128	89 4d b4	 mov	 DWORD PTR _y$23[ebp], ecx
  0012b	8b 55 e8	 mov	 edx, DWORD PTR _src_y_pitch$[ebp]
  0012e	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$[ebp]
  00131	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00134	89 4d c0	 mov	 DWORD PTR _srcYLine$[ebp], ecx
  00137	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  0013a	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$[ebp]
  0013d	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00140	89 4d bc	 mov	 DWORD PTR _dstLine$[ebp], ecx
$LN4@convert_yu:
  00143	8b 55 b4	 mov	 edx, DWORD PTR _y$23[ebp]
  00146	3b 55 dc	 cmp	 edx, DWORD PTR _y_range$[ebp+8]
  00149	0f 8d 92 00 00
	00		 jge	 $LN3@convert_yu

; 1167 :         if (in_bit_depth == 16) {

  0014f	33 c0		 xor	 eax, eax
  00151	74 18		 je	 SHORT $LN14@convert_yu

; 1168 :             memcpy_sse((uint8_t *)dstLine, (uint8_t *)srcYLine, y_width * sizeof(uint16_t));

  00153	8b 4d b8	 mov	 ecx, DWORD PTR _y_width$[ebp]
  00156	d1 e1		 shl	 ecx, 1
  00158	51		 push	 ecx
  00159	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$[ebp]
  0015c	52		 push	 edx
  0015d	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$[ebp]
  00160	50		 push	 eax
  00161	e8 00 00 00 00	 call	 ?memcpy_sse@@YAXPAEPBEH@Z ; memcpy_sse
  00166	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1169 :         } else {

  00169	eb 71		 jmp	 SHORT $LN15@convert_yu
$LN14@convert_yu:

; 1170 :             uint16_t *src_ptr = srcYLine;

  0016b	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$[ebp]
  0016e	89 4d b0	 mov	 DWORD PTR _src_ptr$22[ebp], ecx

; 1171 :             uint16_t *dst_ptr = dstLine;

  00171	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$[ebp]
  00174	89 55 ac	 mov	 DWORD PTR _dst_ptr$21[ebp], edx

; 1172 :             for (int x = 0; x < y_width; x += 8, dst_ptr += 8, src_ptr += 8) {

  00177	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR _x$20[ebp], 0
  0017e	eb 1b		 jmp	 SHORT $LN7@convert_yu
$LN5@convert_yu:
  00180	8b 45 a8	 mov	 eax, DWORD PTR _x$20[ebp]
  00183	83 c0 08	 add	 eax, 8
  00186	89 45 a8	 mov	 DWORD PTR _x$20[ebp], eax
  00189	8b 4d ac	 mov	 ecx, DWORD PTR _dst_ptr$21[ebp]
  0018c	83 c1 10	 add	 ecx, 16			; 00000010H
  0018f	89 4d ac	 mov	 DWORD PTR _dst_ptr$21[ebp], ecx
  00192	8b 55 b0	 mov	 edx, DWORD PTR _src_ptr$22[ebp]
  00195	83 c2 10	 add	 edx, 16			; 00000010H
  00198	89 55 b0	 mov	 DWORD PTR _src_ptr$22[ebp], edx
$LN7@convert_yu:
  0019b	8b 45 a8	 mov	 eax, DWORD PTR _x$20[ebp]
  0019e	3b 45 b8	 cmp	 eax, DWORD PTR _y_width$[ebp]
  001a1	7d 39		 jge	 SHORT $LN15@convert_yu

; 1173 :                 __m128i x0 = _mm_loadu_si128((const __m128i *)src_ptr);

  001a3	8b 4d b0	 mov	 ecx, DWORD PTR _src_ptr$22[ebp]
  001a6	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  001a9	0f 29 45 80	 movaps	 XMMWORD PTR $T18[ebp], xmm0
  001ad	0f 28 45 80	 movaps	 xmm0, XMMWORD PTR $T18[ebp]
  001b1	0f 29 45 90	 movaps	 XMMWORD PTR _x0$19[ebp], xmm0

; 1174 :                 x0 = _mm_slli_epi16(x0, 16 - in_bit_depth);

  001b5	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR _x0$19[ebp]
  001b9	66 0f 71 f0 07	 psllw	 xmm0, 7
  001be	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR $T17[ebp], xmm0
  001c5	0f 28 85 70 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T17[ebp]
  001cc	0f 29 45 90	 movaps	 XMMWORD PTR _x0$19[ebp], xmm0

; 1175 :                 _mm_storeu_si128((__m128i *)dst_ptr, x0);

  001d0	0f 10 45 90	 movups	 xmm0, XMMWORD PTR _x0$19[ebp]
  001d4	8b 55 ac	 mov	 edx, DWORD PTR _dst_ptr$21[ebp]
  001d7	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 1176 :             }

  001da	eb a4		 jmp	 SHORT $LN5@convert_yu
$LN15@convert_yu:

; 1177 :         }
; 1178 :     }

  001dc	e9 41 ff ff ff	 jmp	 $LN2@convert_yu
$LN3@convert_yu:

; 1179 :     //UV成分のコピー
; 1180 :     const int src_uv_pitch = src_uv_pitch_byte >> 1;

  001e1	8b 43 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebx]
  001e4	d1 f8		 sar	 eax, 1
  001e6	89 85 6c ff ff
	ff		 mov	 DWORD PTR _src_uv_pitch$[ebp], eax

; 1181 :     uint16_t *srcULine = (uint16_t *)src[1] + ((src_uv_pitch * y_range.start_src) + (crop_left >> 1));

  001ec	b9 04 00 00 00	 mov	 ecx, 4
  001f1	c1 e1 00	 shl	 ecx, 0
  001f4	8b 95 6c ff ff
	ff		 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  001fa	0f af 55 d4	 imul	 edx, DWORD PTR _y_range$[ebp]
  001fe	8b 45 f8	 mov	 eax, DWORD PTR _crop_left$[ebp]
  00201	d1 f8		 sar	 eax, 1
  00203	03 d0		 add	 edx, eax
  00205	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  00208	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  0020b	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  0020e	89 95 68 ff ff
	ff		 mov	 DWORD PTR _srcULine$[ebp], edx

; 1182 :     uint16_t *srcVLine = (uint16_t *)src[2] + ((src_uv_pitch * y_range.start_src) + (crop_left >> 1));

  00214	b8 04 00 00 00	 mov	 eax, 4
  00219	d1 e0		 shl	 eax, 1
  0021b	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00221	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  00225	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  00228	d1 fa		 sar	 edx, 1
  0022a	03 ca		 add	 ecx, edx
  0022c	8b 53 0c	 mov	 edx, DWORD PTR _src$[ebx]
  0022f	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  00232	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  00235	89 8d 64 ff ff
	ff		 mov	 DWORD PTR _srcVLine$[ebp], ecx

; 1183 :     dstLine = (uint16_t *)dst[1] + dst_y_pitch * y_range.start_dst;

  0023b	ba 04 00 00 00	 mov	 edx, 4
  00240	c1 e2 00	 shl	 edx, 0
  00243	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  00246	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  0024a	8b 4b 08	 mov	 ecx, DWORD PTR _dst$[ebx]
  0024d	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  00250	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  00253	89 45 bc	 mov	 DWORD PTR _dstLine$[ebp], eax

; 1184 :     for (int y = 0; y < y_range.len; y++, srcULine += src_uv_pitch, srcVLine += src_uv_pitch, dstLine += dst_y_pitch) {

  00256	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _y$16[ebp], 0
  00260	eb 45		 jmp	 SHORT $LN10@convert_yu
$LN8@convert_yu:
  00262	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _y$16[ebp]
  00268	83 c1 01	 add	 ecx, 1
  0026b	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _y$16[ebp], ecx
  00271	8b 95 6c ff ff
	ff		 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  00277	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _srcULine$[ebp]
  0027d	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00280	89 8d 68 ff ff
	ff		 mov	 DWORD PTR _srcULine$[ebp], ecx
  00286	8b 95 6c ff ff
	ff		 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  0028c	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _srcVLine$[ebp]
  00292	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00295	89 8d 64 ff ff
	ff		 mov	 DWORD PTR _srcVLine$[ebp], ecx
  0029b	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  0029e	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$[ebp]
  002a1	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  002a4	89 4d bc	 mov	 DWORD PTR _dstLine$[ebp], ecx
$LN10@convert_yu:
  002a7	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _y$16[ebp]
  002ad	3b 55 dc	 cmp	 edx, DWORD PTR _y_range$[ebp+8]
  002b0	0f 8d 82 01 00
	00		 jge	 $LN1@convert_yu

; 1185 :         const int x_fin = width - crop_right;

  002b6	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  002b9	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  002bc	89 85 5c ff ff
	ff		 mov	 DWORD PTR _x_fin$15[ebp], eax

; 1186 :         uint16_t *src_u_ptr = srcULine;

  002c2	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR _srcULine$[ebp]
  002c8	89 8d 58 ff ff
	ff		 mov	 DWORD PTR _src_u_ptr$14[ebp], ecx

; 1187 :         uint16_t *src_v_ptr = srcVLine;

  002ce	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR _srcVLine$[ebp]
  002d4	89 95 54 ff ff
	ff		 mov	 DWORD PTR _src_v_ptr$13[ebp], edx

; 1188 :         uint16_t *dst_ptr = dstLine;

  002da	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$[ebp]
  002dd	89 85 50 ff ff
	ff		 mov	 DWORD PTR _dst_ptr$12[ebp], eax

; 1189 :         __m128i x0, x1, x2;
; 1190 :         for (int x = crop_left; x < x_fin; x += 16, src_u_ptr += 8, src_v_ptr += 8, dst_ptr += 16) {

  002e3	8b 4d f8	 mov	 ecx, DWORD PTR _crop_left$[ebp]
  002e6	89 8d 1c ff ff
	ff		 mov	 DWORD PTR _x$8[ebp], ecx
  002ec	eb 3c		 jmp	 SHORT $LN13@convert_yu
$LN11@convert_yu:
  002ee	8b 95 1c ff ff
	ff		 mov	 edx, DWORD PTR _x$8[ebp]
  002f4	83 c2 10	 add	 edx, 16			; 00000010H
  002f7	89 95 1c ff ff
	ff		 mov	 DWORD PTR _x$8[ebp], edx
  002fd	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _src_u_ptr$14[ebp]
  00303	83 c0 10	 add	 eax, 16			; 00000010H
  00306	89 85 58 ff ff
	ff		 mov	 DWORD PTR _src_u_ptr$14[ebp], eax
  0030c	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _src_v_ptr$13[ebp]
  00312	83 c1 10	 add	 ecx, 16			; 00000010H
  00315	89 8d 54 ff ff
	ff		 mov	 DWORD PTR _src_v_ptr$13[ebp], ecx
  0031b	8b 95 50 ff ff
	ff		 mov	 edx, DWORD PTR _dst_ptr$12[ebp]
  00321	83 c2 20	 add	 edx, 32			; 00000020H
  00324	89 95 50 ff ff
	ff		 mov	 DWORD PTR _dst_ptr$12[ebp], edx
$LN13@convert_yu:
  0032a	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR _x$8[ebp]
  00330	3b 85 5c ff ff
	ff		 cmp	 eax, DWORD PTR _x_fin$15[ebp]
  00336	0f 8d f7 00 00
	00		 jge	 $LN12@convert_yu

; 1191 :             x0 = _mm_loadu_si128((const __m128i *)src_u_ptr);

  0033c	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _src_u_ptr$14[ebp]
  00342	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00345	0f 29 85 00 ff
	ff ff		 movaps	 XMMWORD PTR $T7[ebp], xmm0
  0034c	0f 28 85 00 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T7[ebp]
  00353	0f 29 85 40 ff
	ff ff		 movaps	 XMMWORD PTR _x0$11[ebp], xmm0

; 1192 :             x1 = _mm_loadu_si128((const __m128i *)src_v_ptr);

  0035a	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR _src_v_ptr$13[ebp]
  00360	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  00363	0f 29 85 f0 fe
	ff ff		 movaps	 XMMWORD PTR $T6[ebp], xmm0
  0036a	0f 28 85 f0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T6[ebp]
  00371	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR _x1$10[ebp], xmm0

; 1193 : 
; 1194 :             if (in_bit_depth < 16) {

  00378	b8 01 00 00 00	 mov	 eax, 1
  0037d	85 c0		 test	 eax, eax
  0037f	74 42		 je	 SHORT $LN16@convert_yu

; 1195 :                 x0 = _mm_slli_epi16(x0, 16 - in_bit_depth);

  00381	0f 28 85 40 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x0$11[ebp]
  00388	66 0f 71 f0 07	 psllw	 xmm0, 7
  0038d	0f 29 85 e0 fe
	ff ff		 movaps	 XMMWORD PTR $T5[ebp], xmm0
  00394	0f 28 85 e0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T5[ebp]
  0039b	0f 29 85 40 ff
	ff ff		 movaps	 XMMWORD PTR _x0$11[ebp], xmm0

; 1196 :                 x1 = _mm_slli_epi16(x1, 16 - in_bit_depth);

  003a2	0f 28 85 30 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$10[ebp]
  003a9	66 0f 71 f0 07	 psllw	 xmm0, 7
  003ae	0f 29 85 d0 fe
	ff ff		 movaps	 XMMWORD PTR $T4[ebp], xmm0
  003b5	0f 28 85 d0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T4[ebp]
  003bc	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR _x1$10[ebp], xmm0
$LN16@convert_yu:

; 1197 :             }
; 1198 : 
; 1199 :             x2 = _mm_unpackhi_epi16(x0, x1);

  003c3	0f 28 85 40 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x0$11[ebp]
  003ca	66 0f 69 85 30
	ff ff ff	 punpckhwd xmm0, XMMWORD PTR _x1$10[ebp]
  003d2	0f 29 85 c0 fe
	ff ff		 movaps	 XMMWORD PTR $T3[ebp], xmm0
  003d9	0f 28 85 c0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T3[ebp]
  003e0	0f 29 85 20 ff
	ff ff		 movaps	 XMMWORD PTR _x2$9[ebp], xmm0

; 1200 :             x0 = _mm_unpacklo_epi16(x0, x1);

  003e7	0f 28 85 40 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x0$11[ebp]
  003ee	66 0f 61 85 30
	ff ff ff	 punpcklwd xmm0, XMMWORD PTR _x1$10[ebp]
  003f6	0f 29 85 b0 fe
	ff ff		 movaps	 XMMWORD PTR $T2[ebp], xmm0
  003fd	0f 28 85 b0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T2[ebp]
  00404	0f 29 85 40 ff
	ff ff		 movaps	 XMMWORD PTR _x0$11[ebp], xmm0

; 1201 : 
; 1202 :             _mm_storeu_si128((__m128i *)(dst_ptr + 0), x0);

  0040b	0f 10 85 40 ff
	ff ff		 movups	 xmm0, XMMWORD PTR _x0$11[ebp]
  00412	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR _dst_ptr$12[ebp]
  00418	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 1203 :             _mm_storeu_si128((__m128i *)(dst_ptr + 8), x2);

  0041b	0f 10 85 20 ff
	ff ff		 movups	 xmm0, XMMWORD PTR _x2$9[ebp]
  00422	8b 95 50 ff ff
	ff		 mov	 edx, DWORD PTR _dst_ptr$12[ebp]
  00428	83 c2 10	 add	 edx, 16			; 00000010H
  0042b	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 1204 :         }

  0042e	e9 bb fe ff ff	 jmp	 $LN11@convert_yu
$LN12@convert_yu:

; 1205 :     }

  00433	e9 2a fe ff ff	 jmp	 $LN8@convert_yu
$LN1@convert_yu:

; 1206 : }

  00438	52		 push	 edx
  00439	8b cd		 mov	 ecx, ebp
  0043b	50		 push	 eax
  0043c	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN20@convert_yu
  00442	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00447	58		 pop	 eax
  00448	5a		 pop	 edx
  00449	5f		 pop	 edi
  0044a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0044d	33 cd		 xor	 ecx, ebp
  0044f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00454	8b e5		 mov	 esp, ebp
  00456	5d		 pop	 ebp
  00457	8b e3		 mov	 esp, ebx
  00459	5b		 pop	 ebx
  0045a	c3		 ret	 0
  0045b	90		 npad	 1
$LN20@convert_yu:
  0045c	01 00 00 00	 DD	 1
  00460	00 00 00 00	 DD	 $LN19@convert_yu
$LN19@convert_yu:
  00464	d4 ff ff ff	 DD	 -44			; ffffffd4H
  00468	0c 00 00 00	 DD	 12			; 0000000cH
  0046c	00 00 00 00	 DD	 $LN18@convert_yu
$LN18@convert_yu:
  00470	79		 DB	 121			; 00000079H
  00471	5f		 DB	 95			; 0000005fH
  00472	72		 DB	 114			; 00000072H
  00473	61		 DB	 97			; 00000061H
  00474	6e		 DB	 110			; 0000006eH
  00475	67		 DB	 103			; 00000067H
  00476	65		 DB	 101			; 00000065H
  00477	00		 DB	 0
??$convert_yuv422_high_to_p210_simd@$08@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv422_high_to_p210_simd<9>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_sse2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuv422_09_to_p210_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv422_09_to_p210_sse2

; 221  : void convert_yuv422_09_to_p210_sse2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 222  :     convert_yuv422_high_to_p210_simd<9>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yuv422_high_to_p210_simd@$08@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv422_high_to_p210_simd<9>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 223  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yuv422_09_to_p210_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv422_09_to_p210_sse2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_sse2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuv422_to_p210_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv422_to_p210_sse2

; 217  : void convert_yuv422_to_p210_sse2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 218  :     convert_yuv422_to_p210_simd(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ?convert_yuv422_to_p210_simd@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv422_to_p210_simd
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 219  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yuv422_to_p210_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv422_to_p210_sse2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_sse2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuv422_to_nv16_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv422_to_nv16_sse2

; 213  : void convert_yuv422_to_nv16_sse2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 214  :     convert_yuv422_to_nv16_simd(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ?convert_yuv422_to_nv16_simd@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv422_to_nv16_simd
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 215  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yuv422_to_nv16_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv422_to_nv16_sse2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
tv201 = -300						; size = 4
tv193 = -296						; size = 4
tv153 = -292						; size = 4
$T1 = -288						; size = 12
$T2 = -272						; size = 16
$T3 = -256						; size = 16
$T4 = -240						; size = 16
$T5 = -224						; size = 16
$T6 = -208						; size = 16
$T7 = -192						; size = 16
_ycp$8 = -172						; size = 4
_ycp_fin$9 = -168					; size = 4
_V$10 = -164						; size = 4
_U$11 = -160						; size = 4
_Y$12 = -156						; size = 4
_y$13 = -152						; size = 4
_x3$ = -144						; size = 16
_x2$ = -112						; size = 16
_x1$ = -80						; size = 16
_pixel$ = -52						; size = 4
_V_line$ = -48						; size = 4
_U_line$ = -44						; size = 4
_Y_line$ = -40						; size = 4
$T14 = -36						; size = 12
_y_range$ = -20						; size = 12
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yuv444_16bit_to_yc48_simd@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_16bit_to_yc48_simd<0>

; 1751 : static __forceinline void convert_yuv444_16bit_to_yc48_simd(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 30 01 00
	00		 sub	 esp, 304		; 00000130H
  0001c	57		 push	 edi
  0001d	8d bd d0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-304]
  00023	b9 4c 00 00 00	 mov	 ecx, 76			; 0000004cH
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1752 :     const auto y_range = thread_y_range(0, height, thread_id, thread_n);

  00039	8b 43 2c	 mov	 eax, DWORD PTR _thread_n$[ebx]
  0003c	50		 push	 eax
  0003d	8b 4b 28	 mov	 ecx, DWORD PTR _thread_id$[ebx]
  00040	51		 push	 ecx
  00041	8b 53 20	 mov	 edx, DWORD PTR _height$[ebx]
  00044	52		 push	 edx
  00045	6a 00		 push	 0
  00047	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00053	83 c4 14	 add	 esp, 20			; 00000014H
  00056	8b 08		 mov	 ecx, DWORD PTR [eax]
  00058	89 4d dc	 mov	 DWORD PTR $T14[ebp], ecx
  0005b	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0005e	89 55 e0	 mov	 DWORD PTR $T14[ebp+4], edx
  00061	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00064	89 45 e4	 mov	 DWORD PTR $T14[ebp+8], eax
  00067	8b 4d dc	 mov	 ecx, DWORD PTR $T14[ebp]
  0006a	89 4d ec	 mov	 DWORD PTR _y_range$[ebp], ecx
  0006d	8b 55 e0	 mov	 edx, DWORD PTR $T14[ebp+4]
  00070	89 55 f0	 mov	 DWORD PTR _y_range$[ebp+4], edx
  00073	8b 45 e4	 mov	 eax, DWORD PTR $T14[ebp+8]
  00076	89 45 f4	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 1753 :     char *Y_line = (char *)src[0] + src_y_pitch_byte * y_range.start_src;

  00079	b9 04 00 00 00	 mov	 ecx, 4
  0007e	6b d1 00	 imul	 edx, ecx, 0
  00081	8b 43 14	 mov	 eax, DWORD PTR _src_y_pitch_byte$[ebx]
  00084	0f af 45 ec	 imul	 eax, DWORD PTR _y_range$[ebp]
  00088	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  0008b	03 04 11	 add	 eax, DWORD PTR [ecx+edx]
  0008e	89 45 d8	 mov	 DWORD PTR _Y_line$[ebp], eax

; 1754 :     char *U_line = (char *)src[1] + src_y_pitch_byte * y_range.start_src;

  00091	ba 04 00 00 00	 mov	 edx, 4
  00096	c1 e2 00	 shl	 edx, 0
  00099	8b 43 14	 mov	 eax, DWORD PTR _src_y_pitch_byte$[ebx]
  0009c	0f af 45 ec	 imul	 eax, DWORD PTR _y_range$[ebp]
  000a0	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  000a3	03 04 11	 add	 eax, DWORD PTR [ecx+edx]
  000a6	89 45 d4	 mov	 DWORD PTR _U_line$[ebp], eax

; 1755 :     char *V_line = (char *)src[2] + src_y_pitch_byte * y_range.start_src;

  000a9	ba 04 00 00 00	 mov	 edx, 4
  000ae	d1 e2		 shl	 edx, 1
  000b0	8b 43 14	 mov	 eax, DWORD PTR _src_y_pitch_byte$[ebx]
  000b3	0f af 45 ec	 imul	 eax, DWORD PTR _y_range$[ebp]
  000b7	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  000ba	03 04 11	 add	 eax, DWORD PTR [ecx+edx]
  000bd	89 45 d0	 mov	 DWORD PTR _V_line$[ebp], eax

; 1756 :     char *pixel = (char *)dst[0] + dst_y_pitch_byte * y_range.start_dst;

  000c0	ba 04 00 00 00	 mov	 edx, 4
  000c5	6b c2 00	 imul	 eax, edx, 0
  000c8	8b 4b 1c	 mov	 ecx, DWORD PTR _dst_y_pitch_byte$[ebx]
  000cb	0f af 4d f0	 imul	 ecx, DWORD PTR _y_range$[ebp+4]
  000cf	8b 53 08	 mov	 edx, DWORD PTR _dst$[ebx]
  000d2	03 0c 02	 add	 ecx, DWORD PTR [edx+eax]
  000d5	89 4d cc	 mov	 DWORD PTR _pixel$[ebp], ecx

; 1757 :     __m128i x1, x2, x3;
; 1758 :     for (int y = 0; y < y_range.len; y++, pixel += dst_y_pitch_byte, Y_line += src_y_pitch_byte, U_line += src_y_pitch_byte, V_line += src_y_pitch_byte) {

  000d8	c7 85 68 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _y$13[ebp], 0
  000e2	eb 33		 jmp	 SHORT $LN4@convert_yu
$LN2@convert_yu:
  000e4	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _y$13[ebp]
  000ea	83 c0 01	 add	 eax, 1
  000ed	89 85 68 ff ff
	ff		 mov	 DWORD PTR _y$13[ebp], eax
  000f3	8b 4d cc	 mov	 ecx, DWORD PTR _pixel$[ebp]
  000f6	03 4b 1c	 add	 ecx, DWORD PTR _dst_y_pitch_byte$[ebx]
  000f9	89 4d cc	 mov	 DWORD PTR _pixel$[ebp], ecx
  000fc	8b 55 d8	 mov	 edx, DWORD PTR _Y_line$[ebp]
  000ff	03 53 14	 add	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  00102	89 55 d8	 mov	 DWORD PTR _Y_line$[ebp], edx
  00105	8b 45 d4	 mov	 eax, DWORD PTR _U_line$[ebp]
  00108	03 43 14	 add	 eax, DWORD PTR _src_y_pitch_byte$[ebx]
  0010b	89 45 d4	 mov	 DWORD PTR _U_line$[ebp], eax
  0010e	8b 4d d0	 mov	 ecx, DWORD PTR _V_line$[ebp]
  00111	03 4b 14	 add	 ecx, DWORD PTR _src_y_pitch_byte$[ebx]
  00114	89 4d d0	 mov	 DWORD PTR _V_line$[ebp], ecx
$LN4@convert_yu:
  00117	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR _y$13[ebp]
  0011d	3b 55 f4	 cmp	 edx, DWORD PTR _y_range$[ebp+8]
  00120	0f 8d fe 01 00
	00		 jge	 $LN1@convert_yu

; 1759 :         short *Y = (short *)Y_line;

  00126	8b 45 d8	 mov	 eax, DWORD PTR _Y_line$[ebp]
  00129	89 85 64 ff ff
	ff		 mov	 DWORD PTR _Y$12[ebp], eax

; 1760 :         short *U = (short *)U_line;

  0012f	8b 4d d4	 mov	 ecx, DWORD PTR _U_line$[ebp]
  00132	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _U$11[ebp], ecx

; 1761 :         short *V = (short *)V_line;

  00138	8b 55 d0	 mov	 edx, DWORD PTR _V_line$[ebp]
  0013b	89 95 5c ff ff
	ff		 mov	 DWORD PTR _V$10[ebp], edx

; 1762 :         short *const ycp_fin = (short *)pixel + width * 3;

  00141	6b 43 10 03	 imul	 eax, DWORD PTR _width$[ebx], 3
  00145	8b 4d cc	 mov	 ecx, DWORD PTR _pixel$[ebp]
  00148	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  0014b	89 95 58 ff ff
	ff		 mov	 DWORD PTR _ycp_fin$9[ebp], edx

; 1763 :         for (short *ycp = (short *)pixel; ycp < ycp_fin; ycp += 24, Y += 8, U += 8, V += 8) {

  00151	8b 45 cc	 mov	 eax, DWORD PTR _pixel$[ebp]
  00154	89 85 54 ff ff
	ff		 mov	 DWORD PTR _ycp$8[ebp], eax
  0015a	eb 3c		 jmp	 SHORT $LN7@convert_yu
$LN5@convert_yu:
  0015c	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _ycp$8[ebp]
  00162	83 c1 30	 add	 ecx, 48			; 00000030H
  00165	89 8d 54 ff ff
	ff		 mov	 DWORD PTR _ycp$8[ebp], ecx
  0016b	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR _Y$12[ebp]
  00171	83 c2 10	 add	 edx, 16			; 00000010H
  00174	89 95 64 ff ff
	ff		 mov	 DWORD PTR _Y$12[ebp], edx
  0017a	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _U$11[ebp]
  00180	83 c0 10	 add	 eax, 16			; 00000010H
  00183	89 85 60 ff ff
	ff		 mov	 DWORD PTR _U$11[ebp], eax
  00189	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _V$10[ebp]
  0018f	83 c1 10	 add	 ecx, 16			; 00000010H
  00192	89 8d 5c ff ff
	ff		 mov	 DWORD PTR _V$10[ebp], ecx
$LN7@convert_yu:
  00198	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR _ycp$8[ebp]
  0019e	3b 95 58 ff ff
	ff		 cmp	 edx, DWORD PTR _ycp_fin$9[ebp]
  001a4	0f 83 75 01 00
	00		 jae	 $LN6@convert_yu

; 1764 :             x1 = _mm_loadu_si128((__m128i *)(Y));

  001aa	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _Y$12[ebp]
  001b0	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  001b3	0f 29 85 40 ff
	ff ff		 movaps	 XMMWORD PTR $T7[ebp], xmm0
  001ba	0f 28 85 40 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T7[ebp]
  001c1	0f 29 45 b0	 movaps	 XMMWORD PTR _x1$[ebp], xmm0

; 1765 :             x2 = _mm_loadu_si128((__m128i *)(U));

  001c5	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _U$11[ebp]
  001cb	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  001ce	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR $T6[ebp], xmm0
  001d5	0f 28 85 30 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T6[ebp]
  001dc	0f 29 45 90	 movaps	 XMMWORD PTR _x2$[ebp], xmm0

; 1766 :             x3 = _mm_loadu_si128((__m128i *)(V));

  001e0	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR _V$10[ebp]
  001e6	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  001e9	0f 29 85 20 ff
	ff ff		 movaps	 XMMWORD PTR $T5[ebp], xmm0
  001f0	0f 28 85 20 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T5[ebp]
  001f7	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR _x3$[ebp], xmm0

; 1767 :             x1 = convert_y_range_to_yc48(x1);

  001fe	0f 28 45 b0	 movaps	 xmm0, XMMWORD PTR _x1$[ebp]
  00202	e8 00 00 00 00	 call	 ?convert_y_range_to_yc48@@YA?AT__m128i@@T1@@Z ; convert_y_range_to_yc48
  00207	0f 29 85 10 ff
	ff ff		 movaps	 XMMWORD PTR $T4[ebp], xmm0
  0020e	0f 28 85 10 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T4[ebp]
  00215	0f 29 45 b0	 movaps	 XMMWORD PTR _x1$[ebp], xmm0

; 1768 :             x2 = convert_uv_range_to_yc48(x2);

  00219	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR _x2$[ebp]
  0021d	e8 00 00 00 00	 call	 ?convert_uv_range_to_yc48@@YA?AT__m128i@@T1@@Z ; convert_uv_range_to_yc48
  00222	0f 29 85 00 ff
	ff ff		 movaps	 XMMWORD PTR $T3[ebp], xmm0
  00229	0f 28 85 00 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T3[ebp]
  00230	0f 29 45 90	 movaps	 XMMWORD PTR _x2$[ebp], xmm0

; 1769 :             x3 = convert_uv_range_to_yc48(x3);

  00234	0f 28 85 70 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x3$[ebp]
  0023b	e8 00 00 00 00	 call	 ?convert_uv_range_to_yc48@@YA?AT__m128i@@T1@@Z ; convert_uv_range_to_yc48
  00240	0f 29 85 f0 fe
	ff ff		 movaps	 XMMWORD PTR $T2[ebp], xmm0
  00247	0f 28 85 f0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T2[ebp]
  0024e	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR _x3$[ebp], xmm0

; 1770 :             gather_y_u_v_to_yc48(x1, x2, x3);

  00255	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR _x3$[ebp]
  0025b	50		 push	 eax
  0025c	8d 4d 90	 lea	 ecx, DWORD PTR _x2$[ebp]
  0025f	51		 push	 ecx
  00260	8d 55 b0	 lea	 edx, DWORD PTR _x1$[ebp]
  00263	52		 push	 edx
  00264	e8 00 00 00 00	 call	 ?gather_y_u_v_to_yc48@@YAXAAT__m128i@@00@Z ; gather_y_u_v_to_yc48
  00269	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1771 :             _mm_store_switch_si128((__m128i *)(ycp +  0), x1);

  0026c	33 c0		 xor	 eax, eax
  0026e	74 19		 je	 SHORT $LN9@convert_yu
  00270	0f 28 45 b0	 movaps	 xmm0, XMMWORD PTR _x1$[ebp]
  00274	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _ycp$8[ebp]
  0027a	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  0027d	c7 85 dc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv153[ebp], 0
  00287	eb 17		 jmp	 SHORT $LN10@convert_yu
$LN9@convert_yu:
  00289	0f 10 45 b0	 movups	 xmm0, XMMWORD PTR _x1$[ebp]
  0028d	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR _ycp$8[ebp]
  00293	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0
  00296	c7 85 dc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv153[ebp], 0
$LN10@convert_yu:

; 1772 :             _mm_store_switch_si128((__m128i *)(ycp +  8), x2);

  002a0	33 c0		 xor	 eax, eax
  002a2	74 1c		 je	 SHORT $LN11@convert_yu
  002a4	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR _x2$[ebp]
  002a8	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _ycp$8[ebp]
  002ae	83 c1 10	 add	 ecx, 16			; 00000010H
  002b1	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  002b4	c7 85 d8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv193[ebp], 0
  002be	eb 1a		 jmp	 SHORT $LN12@convert_yu
$LN11@convert_yu:
  002c0	0f 10 45 90	 movups	 xmm0, XMMWORD PTR _x2$[ebp]
  002c4	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR _ycp$8[ebp]
  002ca	83 c2 10	 add	 edx, 16			; 00000010H
  002cd	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0
  002d0	c7 85 d8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv193[ebp], 0
$LN12@convert_yu:

; 1773 :             _mm_store_switch_si128((__m128i *)(ycp + 16), x3);

  002da	33 c0		 xor	 eax, eax
  002dc	74 1f		 je	 SHORT $LN13@convert_yu
  002de	0f 28 85 70 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x3$[ebp]
  002e5	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _ycp$8[ebp]
  002eb	83 c1 20	 add	 ecx, 32			; 00000020H
  002ee	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  002f1	c7 85 d4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv201[ebp], 0
  002fb	eb 1d		 jmp	 SHORT $LN14@convert_yu
$LN13@convert_yu:
  002fd	0f 10 85 70 ff
	ff ff		 movups	 xmm0, XMMWORD PTR _x3$[ebp]
  00304	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR _ycp$8[ebp]
  0030a	83 c2 20	 add	 edx, 32			; 00000020H
  0030d	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0
  00310	c7 85 d4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv201[ebp], 0
$LN14@convert_yu:

; 1774 :         }

  0031a	e9 3d fe ff ff	 jmp	 $LN5@convert_yu
$LN6@convert_yu:

; 1775 :     }

  0031f	e9 c0 fd ff ff	 jmp	 $LN2@convert_yu
$LN1@convert_yu:

; 1776 : }

  00324	52		 push	 edx
  00325	8b cd		 mov	 ecx, ebp
  00327	50		 push	 eax
  00328	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN20@convert_yu
  0032e	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00333	58		 pop	 eax
  00334	5a		 pop	 edx
  00335	5f		 pop	 edi
  00336	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00339	33 cd		 xor	 ecx, ebp
  0033b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00340	8b e5		 mov	 esp, ebp
  00342	5d		 pop	 ebp
  00343	8b e3		 mov	 esp, ebx
  00345	5b		 pop	 ebx
  00346	c3		 ret	 0
  00347	90		 npad	 1
$LN20@convert_yu:
  00348	04 00 00 00	 DD	 4
  0034c	00 00 00 00	 DD	 $LN19@convert_yu
$LN19@convert_yu:
  00350	ec ff ff ff	 DD	 -20			; ffffffecH
  00354	0c 00 00 00	 DD	 12			; 0000000cH
  00358	00 00 00 00	 DD	 $LN15@convert_yu
  0035c	b0 ff ff ff	 DD	 -80			; ffffffb0H
  00360	10 00 00 00	 DD	 16			; 00000010H
  00364	00 00 00 00	 DD	 $LN16@convert_yu
  00368	90 ff ff ff	 DD	 -112			; ffffff90H
  0036c	10 00 00 00	 DD	 16			; 00000010H
  00370	00 00 00 00	 DD	 $LN17@convert_yu
  00374	70 ff ff ff	 DD	 -144			; ffffff70H
  00378	10 00 00 00	 DD	 16			; 00000010H
  0037c	00 00 00 00	 DD	 $LN18@convert_yu
$LN18@convert_yu:
  00380	78		 DB	 120			; 00000078H
  00381	33		 DB	 51			; 00000033H
  00382	00		 DB	 0
$LN17@convert_yu:
  00383	78		 DB	 120			; 00000078H
  00384	32		 DB	 50			; 00000032H
  00385	00		 DB	 0
$LN16@convert_yu:
  00386	78		 DB	 120			; 00000078H
  00387	31		 DB	 49			; 00000031H
  00388	00		 DB	 0
$LN15@convert_yu:
  00389	79		 DB	 121			; 00000079H
  0038a	5f		 DB	 95			; 0000005fH
  0038b	72		 DB	 114			; 00000072H
  0038c	61		 DB	 97			; 00000061H
  0038d	6e		 DB	 110			; 0000006eH
  0038e	67		 DB	 103			; 00000067H
  0038f	65		 DB	 101			; 00000065H
  00390	00		 DB	 0
??$convert_yuv444_16bit_to_yc48_simd@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_16bit_to_yc48_simd<0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_sse2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuv444_16bit_to_yc48_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_16bit_to_yc48_sse2

; 209  : void convert_yuv444_16bit_to_yc48_sse2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 210  :     convert_yuv444_16bit_to_yc48_simd<false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yuv444_16bit_to_yc48_simd@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_16bit_to_yc48_simd<0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 211  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yuv444_16bit_to_yc48_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_16bit_to_yc48_sse2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
tv263 = -636						; size = 4
tv233 = -632						; size = 4
tv203 = -628						; size = 4
$T1 = -624						; size = 12
$T2 = -608						; size = 16
$T3 = -592						; size = 16
$T4 = -576						; size = 16
$T5 = -560						; size = 16
$T6 = -544						; size = 16
$T7 = -528						; size = 16
$T8 = -512						; size = 16
$T9 = -496						; size = 16
$T10 = -480						; size = 16
$T11 = -464						; size = 16
$T12 = -448						; size = 16
$T13 = -432						; size = 16
$T14 = -416						; size = 16
$T15 = -400						; size = 16
$T16 = -384						; size = 16
$T17 = -368						; size = 16
$T18 = -352						; size = 16
$T19 = -336						; size = 16
$T20 = -320						; size = 16
_ycp$21 = -300						; size = 4
_ycp_fin$22 = -296					; size = 4
_V$23 = -292						; size = 4
_U$24 = -288						; size = 4
_Y$25 = -284						; size = 4
_y$26 = -280						; size = 4
_x3$ = -272						; size = 16
_x2$ = -240						; size = 16
_x1$ = -208						; size = 16
$T27 = -176						; size = 16
_xC_YCC$ = -144						; size = 16
$T28 = -112						; size = 16
_xC_pw_one$ = -80					; size = 16
_pixel$ = -52						; size = 4
_V_line$ = -48						; size = 4
_U_line$ = -44						; size = 4
_Y_line$ = -40						; size = 4
$T29 = -36						; size = 12
_y_range$ = -20						; size = 12
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yc48_to_yuv444_16bit_simd@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yc48_to_yuv444_16bit_simd<0>

; 1724 : static __forceinline void convert_yc48_to_yuv444_16bit_simd(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 80 02 00
	00		 sub	 esp, 640		; 00000280H
  0001c	57		 push	 edi
  0001d	8d bd 80 fd ff
	ff		 lea	 edi, DWORD PTR [ebp-640]
  00023	b9 a0 00 00 00	 mov	 ecx, 160		; 000000a0H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1725 :     const auto y_range = thread_y_range(0, height, thread_id, thread_n);

  00039	8b 43 2c	 mov	 eax, DWORD PTR _thread_n$[ebx]
  0003c	50		 push	 eax
  0003d	8b 4b 28	 mov	 ecx, DWORD PTR _thread_id$[ebx]
  00040	51		 push	 ecx
  00041	8b 53 20	 mov	 edx, DWORD PTR _height$[ebx]
  00044	52		 push	 edx
  00045	6a 00		 push	 0
  00047	8d 85 90 fd ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00053	83 c4 14	 add	 esp, 20			; 00000014H
  00056	8b 08		 mov	 ecx, DWORD PTR [eax]
  00058	89 4d dc	 mov	 DWORD PTR $T29[ebp], ecx
  0005b	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0005e	89 55 e0	 mov	 DWORD PTR $T29[ebp+4], edx
  00061	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00064	89 45 e4	 mov	 DWORD PTR $T29[ebp+8], eax
  00067	8b 4d dc	 mov	 ecx, DWORD PTR $T29[ebp]
  0006a	89 4d ec	 mov	 DWORD PTR _y_range$[ebp], ecx
  0006d	8b 55 e0	 mov	 edx, DWORD PTR $T29[ebp+4]
  00070	89 55 f0	 mov	 DWORD PTR _y_range$[ebp+4], edx
  00073	8b 45 e4	 mov	 eax, DWORD PTR $T29[ebp+8]
  00076	89 45 f4	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 1726 :     char *Y_line = (char *)dst[0] + dst_y_pitch_byte + y_range.start_dst;

  00079	b9 04 00 00 00	 mov	 ecx, 4
  0007e	6b d1 00	 imul	 edx, ecx, 0
  00081	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  00084	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00087	03 4b 1c	 add	 ecx, DWORD PTR _dst_y_pitch_byte$[ebx]
  0008a	03 4d f0	 add	 ecx, DWORD PTR _y_range$[ebp+4]
  0008d	89 4d d8	 mov	 DWORD PTR _Y_line$[ebp], ecx

; 1727 :     char *U_line = (char *)dst[1] + dst_y_pitch_byte + y_range.start_dst;

  00090	ba 04 00 00 00	 mov	 edx, 4
  00095	c1 e2 00	 shl	 edx, 0
  00098	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  0009b	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  0009e	03 4b 1c	 add	 ecx, DWORD PTR _dst_y_pitch_byte$[ebx]
  000a1	03 4d f0	 add	 ecx, DWORD PTR _y_range$[ebp+4]
  000a4	89 4d d4	 mov	 DWORD PTR _U_line$[ebp], ecx

; 1728 :     char *V_line = (char *)dst[2] + dst_y_pitch_byte + y_range.start_dst;

  000a7	ba 04 00 00 00	 mov	 edx, 4
  000ac	d1 e2		 shl	 edx, 1
  000ae	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  000b1	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  000b4	03 4b 1c	 add	 ecx, DWORD PTR _dst_y_pitch_byte$[ebx]
  000b7	03 4d f0	 add	 ecx, DWORD PTR _y_range$[ebp+4]
  000ba	89 4d d0	 mov	 DWORD PTR _V_line$[ebp], ecx

; 1729 :     char *pixel = (char *)src[0] + src_y_pitch_byte * y_range.start_src;

  000bd	ba 04 00 00 00	 mov	 edx, 4
  000c2	6b c2 00	 imul	 eax, edx, 0
  000c5	8b 4b 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebx]
  000c8	0f af 4d ec	 imul	 ecx, DWORD PTR _y_range$[ebp]
  000cc	8b 53 0c	 mov	 edx, DWORD PTR _src$[ebx]
  000cf	03 0c 02	 add	 ecx, DWORD PTR [edx+eax]
  000d2	89 4d cc	 mov	 DWORD PTR _pixel$[ebp], ecx

; 1730 :     const __m128i xC_pw_one = _mm_set1_epi16(1);

  000d5	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@00010001000100010001000100010001
  000dc	0f 29 45 90	 movaps	 XMMWORD PTR $T28[ebp], xmm0
  000e0	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR $T28[ebp]
  000e4	0f 29 45 b0	 movaps	 XMMWORD PTR _xC_pw_one$[ebp], xmm0

; 1731 :     const __m128i xC_YCC = _mm_set1_epi32(1<<LSFT_YCC_16);

  000e8	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@00001000000010000000100000001000
  000ef	0f 29 85 50 ff
	ff ff		 movaps	 XMMWORD PTR $T27[ebp], xmm0
  000f6	0f 28 85 50 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T27[ebp]
  000fd	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR _xC_YCC$[ebp], xmm0

; 1732 :     __m128i x1, x2, x3;
; 1733 :     for (int y = 0; y < y_range.len; y++, pixel += src_y_pitch_byte, Y_line += dst_y_pitch_byte, U_line += dst_y_pitch_byte, V_line += dst_y_pitch_byte) {

  00104	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _y$26[ebp], 0
  0010e	eb 33		 jmp	 SHORT $LN4@convert_yc
$LN2@convert_yc:
  00110	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _y$26[ebp]
  00116	83 c0 01	 add	 eax, 1
  00119	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _y$26[ebp], eax
  0011f	8b 4d cc	 mov	 ecx, DWORD PTR _pixel$[ebp]
  00122	03 4b 14	 add	 ecx, DWORD PTR _src_y_pitch_byte$[ebx]
  00125	89 4d cc	 mov	 DWORD PTR _pixel$[ebp], ecx
  00128	8b 55 d8	 mov	 edx, DWORD PTR _Y_line$[ebp]
  0012b	03 53 1c	 add	 edx, DWORD PTR _dst_y_pitch_byte$[ebx]
  0012e	89 55 d8	 mov	 DWORD PTR _Y_line$[ebp], edx
  00131	8b 45 d4	 mov	 eax, DWORD PTR _U_line$[ebp]
  00134	03 43 1c	 add	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  00137	89 45 d4	 mov	 DWORD PTR _U_line$[ebp], eax
  0013a	8b 4d d0	 mov	 ecx, DWORD PTR _V_line$[ebp]
  0013d	03 4b 1c	 add	 ecx, DWORD PTR _dst_y_pitch_byte$[ebx]
  00140	89 4d d0	 mov	 DWORD PTR _V_line$[ebp], ecx
$LN4@convert_yc:
  00143	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _y$26[ebp]
  00149	3b 55 f4	 cmp	 edx, DWORD PTR _y_range$[ebp+8]
  0014c	0f 8d 5d 03 00
	00		 jge	 $LN1@convert_yc

; 1734 :         short *Y = (short *)Y_line;

  00152	8b 45 d8	 mov	 eax, DWORD PTR _Y_line$[ebp]
  00155	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _Y$25[ebp], eax

; 1735 :         short *U = (short *)U_line;

  0015b	8b 4d d4	 mov	 ecx, DWORD PTR _U_line$[ebp]
  0015e	89 8d e0 fe ff
	ff		 mov	 DWORD PTR _U$24[ebp], ecx

; 1736 :         short *V = (short *)V_line;

  00164	8b 55 d0	 mov	 edx, DWORD PTR _V_line$[ebp]
  00167	89 95 dc fe ff
	ff		 mov	 DWORD PTR _V$23[ebp], edx

; 1737 :         short *const ycp_fin = (short *)pixel + width * 3;

  0016d	6b 43 10 03	 imul	 eax, DWORD PTR _width$[ebx], 3
  00171	8b 4d cc	 mov	 ecx, DWORD PTR _pixel$[ebp]
  00174	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00177	89 95 d8 fe ff
	ff		 mov	 DWORD PTR _ycp_fin$22[ebp], edx

; 1738 :         for (short *ycp = (short *)pixel; ycp < ycp_fin; ycp += 24, Y += 8, U += 8, V += 8) {

  0017d	8b 45 cc	 mov	 eax, DWORD PTR _pixel$[ebp]
  00180	89 85 d4 fe ff
	ff		 mov	 DWORD PTR _ycp$21[ebp], eax
  00186	eb 3c		 jmp	 SHORT $LN7@convert_yc
$LN5@convert_yc:
  00188	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR _ycp$21[ebp]
  0018e	83 c1 30	 add	 ecx, 48			; 00000030H
  00191	89 8d d4 fe ff
	ff		 mov	 DWORD PTR _ycp$21[ebp], ecx
  00197	8b 95 e4 fe ff
	ff		 mov	 edx, DWORD PTR _Y$25[ebp]
  0019d	83 c2 10	 add	 edx, 16			; 00000010H
  001a0	89 95 e4 fe ff
	ff		 mov	 DWORD PTR _Y$25[ebp], edx
  001a6	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _U$24[ebp]
  001ac	83 c0 10	 add	 eax, 16			; 00000010H
  001af	89 85 e0 fe ff
	ff		 mov	 DWORD PTR _U$24[ebp], eax
  001b5	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR _V$23[ebp]
  001bb	83 c1 10	 add	 ecx, 16			; 00000010H
  001be	89 8d dc fe ff
	ff		 mov	 DWORD PTR _V$23[ebp], ecx
$LN7@convert_yc:
  001c4	8b 95 d4 fe ff
	ff		 mov	 edx, DWORD PTR _ycp$21[ebp]
  001ca	3b 95 d8 fe ff
	ff		 cmp	 edx, DWORD PTR _ycp_fin$22[ebp]
  001d0	0f 83 d4 02 00
	00		 jae	 $LN6@convert_yc

; 1739 :             x1 = _mm_loadu_si128((__m128i *)(ycp +  0));

  001d6	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR _ycp$21[ebp]
  001dc	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  001df	0f 29 85 c0 fe
	ff ff		 movaps	 XMMWORD PTR $T20[ebp], xmm0
  001e6	0f 28 85 c0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T20[ebp]
  001ed	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR _x1$[ebp], xmm0

; 1740 :             x2 = _mm_loadu_si128((__m128i *)(ycp +  8));

  001f4	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR _ycp$21[ebp]
  001fa	83 c1 10	 add	 ecx, 16			; 00000010H
  001fd	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00200	0f 29 85 b0 fe
	ff ff		 movaps	 XMMWORD PTR $T19[ebp], xmm0
  00207	0f 28 85 b0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T19[ebp]
  0020e	0f 29 85 10 ff
	ff ff		 movaps	 XMMWORD PTR _x2$[ebp], xmm0

; 1741 :             x3 = _mm_loadu_si128((__m128i *)(ycp + 16));

  00215	8b 95 d4 fe ff
	ff		 mov	 edx, DWORD PTR _ycp$21[ebp]
  0021b	83 c2 20	 add	 edx, 32			; 00000020H
  0021e	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  00221	0f 29 85 a0 fe
	ff ff		 movaps	 XMMWORD PTR $T18[ebp], xmm0
  00228	0f 28 85 a0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T18[ebp]
  0022f	0f 29 85 f0 fe
	ff ff		 movaps	 XMMWORD PTR _x3$[ebp], xmm0

; 1742 :             gather_y_u_v_from_yc48(x1, x2, x3);

  00236	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _x3$[ebp]
  0023c	50		 push	 eax
  0023d	8d 8d 10 ff ff
	ff		 lea	 ecx, DWORD PTR _x2$[ebp]
  00243	51		 push	 ecx
  00244	8d 95 30 ff ff
	ff		 lea	 edx, DWORD PTR _x1$[ebp]
  0024a	52		 push	 edx
  0024b	e8 00 00 00 00	 call	 ?gather_y_u_v_from_yc48@@YAXAAT__m128i@@00@Z ; gather_y_u_v_from_yc48
  00250	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1743 :             _mm_store_switch_si128((__m128i *)Y, convert_y_range_from_yc48(x1, xC_Y_L_MA_16, Y_L_RSH_16, xC_YCC, xC_pw_one));

  00253	33 c0		 xor	 eax, eax
  00255	74 54		 je	 SHORT $LN9@convert_yc
  00257	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR ?Array_Y_L_MA_16@@3QBFB
  0025e	0f 29 85 90 fe
	ff ff		 movaps	 XMMWORD PTR $T17[ebp], xmm0
  00265	8d 4d b0	 lea	 ecx, DWORD PTR _xC_pw_one$[ebp]
  00268	51		 push	 ecx
  00269	8d 95 70 ff ff
	ff		 lea	 edx, DWORD PTR _xC_YCC$[ebp]
  0026f	52		 push	 edx
  00270	6a 04		 push	 4
  00272	8d 85 90 fe ff
	ff		 lea	 eax, DWORD PTR $T17[ebp]
  00278	50		 push	 eax
  00279	0f 28 85 30 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$[ebp]
  00280	e8 00 00 00 00	 call	 ?convert_y_range_from_yc48@@YA?AT__m128i@@T1@ABT1@H11@Z ; convert_y_range_from_yc48
  00285	83 c4 10	 add	 esp, 16			; 00000010H
  00288	0f 29 85 80 fe
	ff ff		 movaps	 XMMWORD PTR $T16[ebp], xmm0
  0028f	0f 28 85 80 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T16[ebp]
  00296	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _Y$25[ebp]
  0029c	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  0029f	c7 85 8c fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv203[ebp], 0
  002a9	eb 52		 jmp	 SHORT $LN10@convert_yc
$LN9@convert_yc:
  002ab	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR ?Array_Y_L_MA_16@@3QBFB
  002b2	0f 29 85 70 fe
	ff ff		 movaps	 XMMWORD PTR $T15[ebp], xmm0
  002b9	8d 55 b0	 lea	 edx, DWORD PTR _xC_pw_one$[ebp]
  002bc	52		 push	 edx
  002bd	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR _xC_YCC$[ebp]
  002c3	50		 push	 eax
  002c4	6a 04		 push	 4
  002c6	8d 8d 70 fe ff
	ff		 lea	 ecx, DWORD PTR $T15[ebp]
  002cc	51		 push	 ecx
  002cd	0f 28 85 30 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$[ebp]
  002d4	e8 00 00 00 00	 call	 ?convert_y_range_from_yc48@@YA?AT__m128i@@T1@ABT1@H11@Z ; convert_y_range_from_yc48
  002d9	83 c4 10	 add	 esp, 16			; 00000010H
  002dc	0f 29 85 60 fe
	ff ff		 movaps	 XMMWORD PTR $T14[ebp], xmm0
  002e3	0f 10 85 60 fe
	ff ff		 movups	 xmm0, XMMWORD PTR $T14[ebp]
  002ea	8b 95 e4 fe ff
	ff		 mov	 edx, DWORD PTR _Y$25[ebp]
  002f0	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0
  002f3	c7 85 8c fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv203[ebp], 0
$LN10@convert_yc:

; 1744 :             _mm_store_switch_si128((__m128i *)U, convert_uv_range_from_yc48(x2, _mm_set1_epi16(UV_OFFSET_x1), xC_UV_L_MA_16_444, UV_L_RSH_16_444, xC_YCC, xC_pw_one));

  002fd	33 c0		 xor	 eax, eax
  002ff	74 69		 je	 SHORT $LN11@convert_yc
  00301	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR ?Array_UV_L_MA_16_444@@3QBFB
  00308	0f 29 85 40 fe
	ff ff		 movaps	 XMMWORD PTR $T12[ebp], xmm0
  0030f	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@08000800080008000800080008000800
  00316	0f 29 85 50 fe
	ff ff		 movaps	 XMMWORD PTR $T13[ebp], xmm0
  0031d	8d 4d b0	 lea	 ecx, DWORD PTR _xC_pw_one$[ebp]
  00320	51		 push	 ecx
  00321	0f 28 8d 70 ff
	ff ff		 movaps	 xmm1, XMMWORD PTR _xC_YCC$[ebp]
  00328	6a 00		 push	 0
  0032a	8d 95 40 fe ff
	ff		 lea	 edx, DWORD PTR $T12[ebp]
  00330	52		 push	 edx
  00331	8d 85 50 fe ff
	ff		 lea	 eax, DWORD PTR $T13[ebp]
  00337	50		 push	 eax
  00338	0f 28 85 10 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x2$[ebp]
  0033f	e8 00 00 00 00	 call	 ?convert_uv_range_from_yc48@@YA?AT__m128i@@T1@ABT1@1H01@Z ; convert_uv_range_from_yc48
  00344	83 c4 10	 add	 esp, 16			; 00000010H
  00347	0f 29 85 30 fe
	ff ff		 movaps	 XMMWORD PTR $T11[ebp], xmm0
  0034e	0f 28 85 30 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T11[ebp]
  00355	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR _U$24[ebp]
  0035b	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  0035e	c7 85 88 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv233[ebp], 0
  00368	eb 67		 jmp	 SHORT $LN12@convert_yc
$LN11@convert_yc:
  0036a	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR ?Array_UV_L_MA_16_444@@3QBFB
  00371	0f 29 85 10 fe
	ff ff		 movaps	 XMMWORD PTR $T9[ebp], xmm0
  00378	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@08000800080008000800080008000800
  0037f	0f 29 85 20 fe
	ff ff		 movaps	 XMMWORD PTR $T10[ebp], xmm0
  00386	8d 55 b0	 lea	 edx, DWORD PTR _xC_pw_one$[ebp]
  00389	52		 push	 edx
  0038a	0f 28 8d 70 ff
	ff ff		 movaps	 xmm1, XMMWORD PTR _xC_YCC$[ebp]
  00391	6a 00		 push	 0
  00393	8d 85 10 fe ff
	ff		 lea	 eax, DWORD PTR $T9[ebp]
  00399	50		 push	 eax
  0039a	8d 8d 20 fe ff
	ff		 lea	 ecx, DWORD PTR $T10[ebp]
  003a0	51		 push	 ecx
  003a1	0f 28 85 10 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x2$[ebp]
  003a8	e8 00 00 00 00	 call	 ?convert_uv_range_from_yc48@@YA?AT__m128i@@T1@ABT1@1H01@Z ; convert_uv_range_from_yc48
  003ad	83 c4 10	 add	 esp, 16			; 00000010H
  003b0	0f 29 85 00 fe
	ff ff		 movaps	 XMMWORD PTR $T8[ebp], xmm0
  003b7	0f 10 85 00 fe
	ff ff		 movups	 xmm0, XMMWORD PTR $T8[ebp]
  003be	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR _U$24[ebp]
  003c4	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0
  003c7	c7 85 88 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv233[ebp], 0
$LN12@convert_yc:

; 1745 :             _mm_store_switch_si128((__m128i *)V, convert_uv_range_from_yc48(x3, _mm_set1_epi16(UV_OFFSET_x1), xC_UV_L_MA_16_444, UV_L_RSH_16_444, xC_YCC, xC_pw_one));

  003d1	33 c0		 xor	 eax, eax
  003d3	74 69		 je	 SHORT $LN13@convert_yc
  003d5	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR ?Array_UV_L_MA_16_444@@3QBFB
  003dc	0f 29 85 e0 fd
	ff ff		 movaps	 XMMWORD PTR $T6[ebp], xmm0
  003e3	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@08000800080008000800080008000800
  003ea	0f 29 85 f0 fd
	ff ff		 movaps	 XMMWORD PTR $T7[ebp], xmm0
  003f1	8d 4d b0	 lea	 ecx, DWORD PTR _xC_pw_one$[ebp]
  003f4	51		 push	 ecx
  003f5	0f 28 8d 70 ff
	ff ff		 movaps	 xmm1, XMMWORD PTR _xC_YCC$[ebp]
  003fc	6a 00		 push	 0
  003fe	8d 95 e0 fd ff
	ff		 lea	 edx, DWORD PTR $T6[ebp]
  00404	52		 push	 edx
  00405	8d 85 f0 fd ff
	ff		 lea	 eax, DWORD PTR $T7[ebp]
  0040b	50		 push	 eax
  0040c	0f 28 85 f0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _x3$[ebp]
  00413	e8 00 00 00 00	 call	 ?convert_uv_range_from_yc48@@YA?AT__m128i@@T1@ABT1@1H01@Z ; convert_uv_range_from_yc48
  00418	83 c4 10	 add	 esp, 16			; 00000010H
  0041b	0f 29 85 d0 fd
	ff ff		 movaps	 XMMWORD PTR $T5[ebp], xmm0
  00422	0f 28 85 d0 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T5[ebp]
  00429	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR _V$23[ebp]
  0042f	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  00432	c7 85 84 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv263[ebp], 0
  0043c	eb 67		 jmp	 SHORT $LN14@convert_yc
$LN13@convert_yc:
  0043e	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR ?Array_UV_L_MA_16_444@@3QBFB
  00445	0f 29 85 b0 fd
	ff ff		 movaps	 XMMWORD PTR $T3[ebp], xmm0
  0044c	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@08000800080008000800080008000800
  00453	0f 29 85 c0 fd
	ff ff		 movaps	 XMMWORD PTR $T4[ebp], xmm0
  0045a	8d 55 b0	 lea	 edx, DWORD PTR _xC_pw_one$[ebp]
  0045d	52		 push	 edx
  0045e	0f 28 8d 70 ff
	ff ff		 movaps	 xmm1, XMMWORD PTR _xC_YCC$[ebp]
  00465	6a 00		 push	 0
  00467	8d 85 b0 fd ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  0046d	50		 push	 eax
  0046e	8d 8d c0 fd ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  00474	51		 push	 ecx
  00475	0f 28 85 f0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _x3$[ebp]
  0047c	e8 00 00 00 00	 call	 ?convert_uv_range_from_yc48@@YA?AT__m128i@@T1@ABT1@1H01@Z ; convert_uv_range_from_yc48
  00481	83 c4 10	 add	 esp, 16			; 00000010H
  00484	0f 29 85 a0 fd
	ff ff		 movaps	 XMMWORD PTR $T2[ebp], xmm0
  0048b	0f 10 85 a0 fd
	ff ff		 movups	 xmm0, XMMWORD PTR $T2[ebp]
  00492	8b 95 dc fe ff
	ff		 mov	 edx, DWORD PTR _V$23[ebp]
  00498	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0
  0049b	c7 85 84 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv263[ebp], 0
$LN14@convert_yc:

; 1746 :         }

  004a5	e9 de fc ff ff	 jmp	 $LN5@convert_yc
$LN6@convert_yc:

; 1747 :     }

  004aa	e9 61 fc ff ff	 jmp	 $LN2@convert_yc
$LN1@convert_yc:

; 1748 : }

  004af	52		 push	 edx
  004b0	8b cd		 mov	 ecx, ebp
  004b2	50		 push	 eax
  004b3	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN22@convert_yc
  004b9	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  004be	58		 pop	 eax
  004bf	5a		 pop	 edx
  004c0	5f		 pop	 edi
  004c1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004c4	33 cd		 xor	 ecx, ebp
  004c6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004cb	8b e5		 mov	 esp, ebp
  004cd	5d		 pop	 ebp
  004ce	8b e3		 mov	 esp, ebx
  004d0	5b		 pop	 ebx
  004d1	c3		 ret	 0
  004d2	66 90		 npad	 2
$LN22@convert_yc:
  004d4	06 00 00 00	 DD	 6
  004d8	00 00 00 00	 DD	 $LN21@convert_yc
$LN21@convert_yc:
  004dc	ec ff ff ff	 DD	 -20			; ffffffecH
  004e0	0c 00 00 00	 DD	 12			; 0000000cH
  004e4	00 00 00 00	 DD	 $LN15@convert_yc
  004e8	b0 ff ff ff	 DD	 -80			; ffffffb0H
  004ec	10 00 00 00	 DD	 16			; 00000010H
  004f0	00 00 00 00	 DD	 $LN16@convert_yc
  004f4	70 ff ff ff	 DD	 -144			; ffffff70H
  004f8	10 00 00 00	 DD	 16			; 00000010H
  004fc	00 00 00 00	 DD	 $LN17@convert_yc
  00500	30 ff ff ff	 DD	 -208			; ffffff30H
  00504	10 00 00 00	 DD	 16			; 00000010H
  00508	00 00 00 00	 DD	 $LN18@convert_yc
  0050c	10 ff ff ff	 DD	 -240			; ffffff10H
  00510	10 00 00 00	 DD	 16			; 00000010H
  00514	00 00 00 00	 DD	 $LN19@convert_yc
  00518	f0 fe ff ff	 DD	 -272			; fffffef0H
  0051c	10 00 00 00	 DD	 16			; 00000010H
  00520	00 00 00 00	 DD	 $LN20@convert_yc
$LN20@convert_yc:
  00524	78		 DB	 120			; 00000078H
  00525	33		 DB	 51			; 00000033H
  00526	00		 DB	 0
$LN19@convert_yc:
  00527	78		 DB	 120			; 00000078H
  00528	32		 DB	 50			; 00000032H
  00529	00		 DB	 0
$LN18@convert_yc:
  0052a	78		 DB	 120			; 00000078H
  0052b	31		 DB	 49			; 00000031H
  0052c	00		 DB	 0
$LN17@convert_yc:
  0052d	78		 DB	 120			; 00000078H
  0052e	43		 DB	 67			; 00000043H
  0052f	5f		 DB	 95			; 0000005fH
  00530	59		 DB	 89			; 00000059H
  00531	43		 DB	 67			; 00000043H
  00532	43		 DB	 67			; 00000043H
  00533	00		 DB	 0
$LN16@convert_yc:
  00534	78		 DB	 120			; 00000078H
  00535	43		 DB	 67			; 00000043H
  00536	5f		 DB	 95			; 0000005fH
  00537	70		 DB	 112			; 00000070H
  00538	77		 DB	 119			; 00000077H
  00539	5f		 DB	 95			; 0000005fH
  0053a	6f		 DB	 111			; 0000006fH
  0053b	6e		 DB	 110			; 0000006eH
  0053c	65		 DB	 101			; 00000065H
  0053d	00		 DB	 0
$LN15@convert_yc:
  0053e	79		 DB	 121			; 00000079H
  0053f	5f		 DB	 95			; 0000005fH
  00540	72		 DB	 114			; 00000072H
  00541	61		 DB	 97			; 00000061H
  00542	6e		 DB	 110			; 0000006eH
  00543	67		 DB	 103			; 00000067H
  00544	65		 DB	 101			; 00000065H
  00545	00		 DB	 0
??$convert_yc48_to_yuv444_16bit_simd@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yc48_to_yuv444_16bit_simd<0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_sse2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yc48_to_yuv444_16bit_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yc48_to_yuv444_16bit_sse2

; 205  : void convert_yc48_to_yuv444_16bit_sse2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 206  :     convert_yc48_to_yuv444_16bit_simd<false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yc48_to_yuv444_16bit_simd@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yc48_to_yuv444_16bit_simd<0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 207  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yc48_to_yuv444_16bit_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yc48_to_yuv444_16bit_sse2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
tv334 = -892						; size = 4
tv328 = -888						; size = 4
tv322 = -884						; size = 4
$T1 = -880						; size = 12
$T2 = -864						; size = 16
$T3 = -848						; size = 16
$T4 = -832						; size = 16
$T5 = -816						; size = 16
$T6 = -800						; size = 16
$T7 = -784						; size = 16
$T8 = -768						; size = 16
$T9 = -752						; size = 16
$T10 = -736						; size = 16
$T11 = -720						; size = 16
$T12 = -704						; size = 16
$T13 = -688						; size = 16
$T14 = -672						; size = 16
$T15 = -656						; size = 16
$T16 = -640						; size = 16
$T17 = -624						; size = 16
$T18 = -608						; size = 16
$T19 = -592						; size = 16
$T20 = -576						; size = 16
$T21 = -560						; size = 16
$T22 = -544						; size = 16
$T23 = -528						; size = 16
$T24 = -512						; size = 16
$T25 = -496						; size = 16
$T26 = -480						; size = 16
$T27 = -464						; size = 16
$T28 = -448						; size = 16
$T29 = -432						; size = 16
$T30 = -416						; size = 16
$T31 = -400						; size = 16
$T32 = -384						; size = 16
_ycp$33 = -360						; size = 4
_ycp_fin$34 = -356					; size = 4
_V$35 = -352						; size = 4
_U$36 = -348						; size = 4
_Y$37 = -344						; size = 4
_y$38 = -340						; size = 4
_xV$ = -336						; size = 16
_xU$ = -320						; size = 16
_xY$ = -304						; size = 16
_x3$ = -272						; size = 16
_x2$ = -240						; size = 16
_x1$ = -208						; size = 16
$T39 = -176						; size = 16
_xC_YCC$ = -144						; size = 16
$T40 = -112						; size = 16
_xC_pw_one$ = -80					; size = 16
_ycpLine$ = -52						; size = 4
_VLine$ = -48						; size = 4
_ULine$ = -44						; size = 4
_YLine$ = -40						; size = 4
$T41 = -36						; size = 12
_y_range$ = -20						; size = 12
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yc48_to_yuv444_simd@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yc48_to_yuv444_simd<0>

; 1673 : static void __forceinline convert_yc48_to_yuv444_simd(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 80 03 00
	00		 sub	 esp, 896		; 00000380H
  0001c	57		 push	 edi
  0001d	8d bd 80 fc ff
	ff		 lea	 edi, DWORD PTR [ebp-896]
  00023	b9 e0 00 00 00	 mov	 ecx, 224		; 000000e0H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1674 :     const auto y_range = thread_y_range(0, height, thread_id, thread_n);

  00039	8b 43 2c	 mov	 eax, DWORD PTR _thread_n$[ebx]
  0003c	50		 push	 eax
  0003d	8b 4b 28	 mov	 ecx, DWORD PTR _thread_id$[ebx]
  00040	51		 push	 ecx
  00041	8b 53 20	 mov	 edx, DWORD PTR _height$[ebx]
  00044	52		 push	 edx
  00045	6a 00		 push	 0
  00047	8d 85 90 fc ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00053	83 c4 14	 add	 esp, 20			; 00000014H
  00056	8b 08		 mov	 ecx, DWORD PTR [eax]
  00058	89 4d dc	 mov	 DWORD PTR $T41[ebp], ecx
  0005b	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0005e	89 55 e0	 mov	 DWORD PTR $T41[ebp+4], edx
  00061	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00064	89 45 e4	 mov	 DWORD PTR $T41[ebp+8], eax
  00067	8b 4d dc	 mov	 ecx, DWORD PTR $T41[ebp]
  0006a	89 4d ec	 mov	 DWORD PTR _y_range$[ebp], ecx
  0006d	8b 55 e0	 mov	 edx, DWORD PTR $T41[ebp+4]
  00070	89 55 f0	 mov	 DWORD PTR _y_range$[ebp+4], edx
  00073	8b 45 e4	 mov	 eax, DWORD PTR $T41[ebp+8]
  00076	89 45 f4	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 1675 :     uint8_t *YLine   = (uint8_t *)dst[0] + dst_y_pitch_byte * y_range.start_dst;

  00079	b9 04 00 00 00	 mov	 ecx, 4
  0007e	6b d1 00	 imul	 edx, ecx, 0
  00081	8b 43 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  00084	0f af 45 f0	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  00088	8b 4b 08	 mov	 ecx, DWORD PTR _dst$[ebx]
  0008b	03 04 11	 add	 eax, DWORD PTR [ecx+edx]
  0008e	89 45 d8	 mov	 DWORD PTR _YLine$[ebp], eax

; 1676 :     uint8_t *ULine   = (uint8_t *)dst[1] + dst_y_pitch_byte * y_range.start_dst;

  00091	ba 04 00 00 00	 mov	 edx, 4
  00096	c1 e2 00	 shl	 edx, 0
  00099	8b 43 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  0009c	0f af 45 f0	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  000a0	8b 4b 08	 mov	 ecx, DWORD PTR _dst$[ebx]
  000a3	03 04 11	 add	 eax, DWORD PTR [ecx+edx]
  000a6	89 45 d4	 mov	 DWORD PTR _ULine$[ebp], eax

; 1677 :     uint8_t *VLine   = (uint8_t *)dst[2] + dst_y_pitch_byte * y_range.start_dst;

  000a9	ba 04 00 00 00	 mov	 edx, 4
  000ae	d1 e2		 shl	 edx, 1
  000b0	8b 43 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  000b3	0f af 45 f0	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  000b7	8b 4b 08	 mov	 ecx, DWORD PTR _dst$[ebx]
  000ba	03 04 11	 add	 eax, DWORD PTR [ecx+edx]
  000bd	89 45 d0	 mov	 DWORD PTR _VLine$[ebp], eax

; 1678 :     uint8_t *ycpLine = (uint8_t *)src[0] + src_y_pitch_byte * y_range.start_src;

  000c0	ba 04 00 00 00	 mov	 edx, 4
  000c5	6b c2 00	 imul	 eax, edx, 0
  000c8	8b 4b 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebx]
  000cb	0f af 4d ec	 imul	 ecx, DWORD PTR _y_range$[ebp]
  000cf	8b 53 0c	 mov	 edx, DWORD PTR _src$[ebx]
  000d2	03 0c 02	 add	 ecx, DWORD PTR [edx+eax]
  000d5	89 4d cc	 mov	 DWORD PTR _ycpLine$[ebp], ecx

; 1679 :     const __m128i xC_pw_one = _mm_set1_epi16(1);

  000d8	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@00010001000100010001000100010001
  000df	0f 29 45 90	 movaps	 XMMWORD PTR $T40[ebp], xmm0
  000e3	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR $T40[ebp]
  000e7	0f 29 45 b0	 movaps	 XMMWORD PTR _xC_pw_one$[ebp], xmm0

; 1680 :     const __m128i xC_YCC = _mm_set1_epi32(1<<LSFT_YCC_16);

  000eb	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@00001000000010000000100000001000
  000f2	0f 29 85 50 ff
	ff ff		 movaps	 XMMWORD PTR $T39[ebp], xmm0
  000f9	0f 28 85 50 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T39[ebp]
  00100	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR _xC_YCC$[ebp], xmm0

; 1681 :     __m128i x1, x2, x3, xY, xU, xV;
; 1682 :     for (int y = 0; y < y_range.len; y++, ycpLine += src_y_pitch_byte, YLine += dst_y_pitch_byte, ULine += dst_y_pitch_byte, VLine += dst_y_pitch_byte) {

  00107	c7 85 ac fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _y$38[ebp], 0
  00111	eb 33		 jmp	 SHORT $LN4@convert_yc
$LN2@convert_yc:
  00113	8b 85 ac fe ff
	ff		 mov	 eax, DWORD PTR _y$38[ebp]
  00119	83 c0 01	 add	 eax, 1
  0011c	89 85 ac fe ff
	ff		 mov	 DWORD PTR _y$38[ebp], eax
  00122	8b 4d cc	 mov	 ecx, DWORD PTR _ycpLine$[ebp]
  00125	03 4b 14	 add	 ecx, DWORD PTR _src_y_pitch_byte$[ebx]
  00128	89 4d cc	 mov	 DWORD PTR _ycpLine$[ebp], ecx
  0012b	8b 55 d8	 mov	 edx, DWORD PTR _YLine$[ebp]
  0012e	03 53 1c	 add	 edx, DWORD PTR _dst_y_pitch_byte$[ebx]
  00131	89 55 d8	 mov	 DWORD PTR _YLine$[ebp], edx
  00134	8b 45 d4	 mov	 eax, DWORD PTR _ULine$[ebp]
  00137	03 43 1c	 add	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  0013a	89 45 d4	 mov	 DWORD PTR _ULine$[ebp], eax
  0013d	8b 4d d0	 mov	 ecx, DWORD PTR _VLine$[ebp]
  00140	03 4b 1c	 add	 ecx, DWORD PTR _dst_y_pitch_byte$[ebx]
  00143	89 4d d0	 mov	 DWORD PTR _VLine$[ebp], ecx
$LN4@convert_yc:
  00146	8b 95 ac fe ff
	ff		 mov	 edx, DWORD PTR _y$38[ebp]
  0014c	3b 55 f4	 cmp	 edx, DWORD PTR _y_range$[ebp+8]
  0014f	0f 8d 63 05 00
	00		 jge	 $LN1@convert_yc

; 1683 :         uint8_t *Y = YLine;

  00155	8b 45 d8	 mov	 eax, DWORD PTR _YLine$[ebp]
  00158	89 85 a8 fe ff
	ff		 mov	 DWORD PTR _Y$37[ebp], eax

; 1684 :         uint8_t *U = ULine;

  0015e	8b 4d d4	 mov	 ecx, DWORD PTR _ULine$[ebp]
  00161	89 8d a4 fe ff
	ff		 mov	 DWORD PTR _U$36[ebp], ecx

; 1685 :         uint8_t *V = VLine;

  00167	8b 55 d0	 mov	 edx, DWORD PTR _VLine$[ebp]
  0016a	89 95 a0 fe ff
	ff		 mov	 DWORD PTR _V$35[ebp], edx

; 1686 :         int16_t *const ycp_fin = (int16_t *)ycpLine + width * 3;

  00170	6b 43 10 03	 imul	 eax, DWORD PTR _width$[ebx], 3
  00174	8b 4d cc	 mov	 ecx, DWORD PTR _ycpLine$[ebp]
  00177	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  0017a	89 95 9c fe ff
	ff		 mov	 DWORD PTR _ycp_fin$34[ebp], edx

; 1687 :         for (int16_t *ycp = (int16_t *)ycpLine; ycp < ycp_fin; ycp += 48, Y += 16, U += 16, V += 16) {

  00180	8b 45 cc	 mov	 eax, DWORD PTR _ycpLine$[ebp]
  00183	89 85 98 fe ff
	ff		 mov	 DWORD PTR _ycp$33[ebp], eax
  00189	eb 3c		 jmp	 SHORT $LN7@convert_yc
$LN5@convert_yc:
  0018b	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR _ycp$33[ebp]
  00191	83 c1 60	 add	 ecx, 96			; 00000060H
  00194	89 8d 98 fe ff
	ff		 mov	 DWORD PTR _ycp$33[ebp], ecx
  0019a	8b 95 a8 fe ff
	ff		 mov	 edx, DWORD PTR _Y$37[ebp]
  001a0	83 c2 10	 add	 edx, 16			; 00000010H
  001a3	89 95 a8 fe ff
	ff		 mov	 DWORD PTR _Y$37[ebp], edx
  001a9	8b 85 a4 fe ff
	ff		 mov	 eax, DWORD PTR _U$36[ebp]
  001af	83 c0 10	 add	 eax, 16			; 00000010H
  001b2	89 85 a4 fe ff
	ff		 mov	 DWORD PTR _U$36[ebp], eax
  001b8	8b 8d a0 fe ff
	ff		 mov	 ecx, DWORD PTR _V$35[ebp]
  001be	83 c1 10	 add	 ecx, 16			; 00000010H
  001c1	89 8d a0 fe ff
	ff		 mov	 DWORD PTR _V$35[ebp], ecx
$LN7@convert_yc:
  001c7	8b 95 98 fe ff
	ff		 mov	 edx, DWORD PTR _ycp$33[ebp]
  001cd	3b 95 9c fe ff
	ff		 cmp	 edx, DWORD PTR _ycp_fin$34[ebp]
  001d3	0f 83 da 04 00
	00		 jae	 $LN6@convert_yc

; 1688 :             x1 = _mm_loadu_si128((__m128i *)(ycp +  0));

  001d9	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR _ycp$33[ebp]
  001df	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  001e2	0f 29 85 80 fe
	ff ff		 movaps	 XMMWORD PTR $T32[ebp], xmm0
  001e9	0f 28 85 80 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T32[ebp]
  001f0	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR _x1$[ebp], xmm0

; 1689 :             x2 = _mm_loadu_si128((__m128i *)(ycp +  8));

  001f7	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR _ycp$33[ebp]
  001fd	83 c1 10	 add	 ecx, 16			; 00000010H
  00200	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00203	0f 29 85 70 fe
	ff ff		 movaps	 XMMWORD PTR $T31[ebp], xmm0
  0020a	0f 28 85 70 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T31[ebp]
  00211	0f 29 85 10 ff
	ff ff		 movaps	 XMMWORD PTR _x2$[ebp], xmm0

; 1690 :             x3 = _mm_loadu_si128((__m128i *)(ycp + 16));

  00218	8b 95 98 fe ff
	ff		 mov	 edx, DWORD PTR _ycp$33[ebp]
  0021e	83 c2 20	 add	 edx, 32			; 00000020H
  00221	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  00224	0f 29 85 60 fe
	ff ff		 movaps	 XMMWORD PTR $T30[ebp], xmm0
  0022b	0f 28 85 60 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T30[ebp]
  00232	0f 29 85 f0 fe
	ff ff		 movaps	 XMMWORD PTR _x3$[ebp], xmm0

; 1691 :             gather_y_u_v_from_yc48(x1, x2, x3);

  00239	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _x3$[ebp]
  0023f	50		 push	 eax
  00240	8d 8d 10 ff ff
	ff		 lea	 ecx, DWORD PTR _x2$[ebp]
  00246	51		 push	 ecx
  00247	8d 95 30 ff ff
	ff		 lea	 edx, DWORD PTR _x1$[ebp]
  0024d	52		 push	 edx
  0024e	e8 00 00 00 00	 call	 ?gather_y_u_v_from_yc48@@YAXAAT__m128i@@00@Z ; gather_y_u_v_from_yc48
  00253	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1692 : 
; 1693 :             x1 = convert_y_range_from_yc48(x1, xC_Y_L_MA_16, Y_L_RSH_16, xC_YCC, xC_pw_one);

  00256	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR ?Array_Y_L_MA_16@@3QBFB
  0025d	0f 29 85 50 fe
	ff ff		 movaps	 XMMWORD PTR $T29[ebp], xmm0
  00264	8d 45 b0	 lea	 eax, DWORD PTR _xC_pw_one$[ebp]
  00267	50		 push	 eax
  00268	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR _xC_YCC$[ebp]
  0026e	51		 push	 ecx
  0026f	6a 04		 push	 4
  00271	8d 95 50 fe ff
	ff		 lea	 edx, DWORD PTR $T29[ebp]
  00277	52		 push	 edx
  00278	0f 28 85 30 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$[ebp]
  0027f	e8 00 00 00 00	 call	 ?convert_y_range_from_yc48@@YA?AT__m128i@@T1@ABT1@H11@Z ; convert_y_range_from_yc48
  00284	83 c4 10	 add	 esp, 16			; 00000010H
  00287	0f 29 85 40 fe
	ff ff		 movaps	 XMMWORD PTR $T28[ebp], xmm0
  0028e	0f 28 85 40 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T28[ebp]
  00295	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR _x1$[ebp], xmm0

; 1694 :             x2 = convert_uv_range_from_yc48(x2, _mm_set1_epi16(UV_OFFSET_x1), xC_UV_L_MA_16_444, UV_L_RSH_16_444, xC_YCC, xC_pw_one);

  0029c	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR ?Array_UV_L_MA_16_444@@3QBFB
  002a3	0f 29 85 20 fe
	ff ff		 movaps	 XMMWORD PTR $T26[ebp], xmm0
  002aa	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@08000800080008000800080008000800
  002b1	0f 29 85 30 fe
	ff ff		 movaps	 XMMWORD PTR $T27[ebp], xmm0
  002b8	8d 45 b0	 lea	 eax, DWORD PTR _xC_pw_one$[ebp]
  002bb	50		 push	 eax
  002bc	0f 28 8d 70 ff
	ff ff		 movaps	 xmm1, XMMWORD PTR _xC_YCC$[ebp]
  002c3	6a 00		 push	 0
  002c5	8d 8d 20 fe ff
	ff		 lea	 ecx, DWORD PTR $T26[ebp]
  002cb	51		 push	 ecx
  002cc	8d 95 30 fe ff
	ff		 lea	 edx, DWORD PTR $T27[ebp]
  002d2	52		 push	 edx
  002d3	0f 28 85 10 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x2$[ebp]
  002da	e8 00 00 00 00	 call	 ?convert_uv_range_from_yc48@@YA?AT__m128i@@T1@ABT1@1H01@Z ; convert_uv_range_from_yc48
  002df	83 c4 10	 add	 esp, 16			; 00000010H
  002e2	0f 29 85 10 fe
	ff ff		 movaps	 XMMWORD PTR $T25[ebp], xmm0
  002e9	0f 28 85 10 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T25[ebp]
  002f0	0f 29 85 10 ff
	ff ff		 movaps	 XMMWORD PTR _x2$[ebp], xmm0

; 1695 :             x3 = convert_uv_range_from_yc48(x3, _mm_set1_epi16(UV_OFFSET_x1), xC_UV_L_MA_16_444, UV_L_RSH_16_444, xC_YCC, xC_pw_one);

  002f7	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR ?Array_UV_L_MA_16_444@@3QBFB
  002fe	0f 29 85 f0 fd
	ff ff		 movaps	 XMMWORD PTR $T23[ebp], xmm0
  00305	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@08000800080008000800080008000800
  0030c	0f 29 85 00 fe
	ff ff		 movaps	 XMMWORD PTR $T24[ebp], xmm0
  00313	8d 45 b0	 lea	 eax, DWORD PTR _xC_pw_one$[ebp]
  00316	50		 push	 eax
  00317	0f 28 8d 70 ff
	ff ff		 movaps	 xmm1, XMMWORD PTR _xC_YCC$[ebp]
  0031e	6a 00		 push	 0
  00320	8d 8d f0 fd ff
	ff		 lea	 ecx, DWORD PTR $T23[ebp]
  00326	51		 push	 ecx
  00327	8d 95 00 fe ff
	ff		 lea	 edx, DWORD PTR $T24[ebp]
  0032d	52		 push	 edx
  0032e	0f 28 85 f0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _x3$[ebp]
  00335	e8 00 00 00 00	 call	 ?convert_uv_range_from_yc48@@YA?AT__m128i@@T1@ABT1@1H01@Z ; convert_uv_range_from_yc48
  0033a	83 c4 10	 add	 esp, 16			; 00000010H
  0033d	0f 29 85 e0 fd
	ff ff		 movaps	 XMMWORD PTR $T22[ebp], xmm0
  00344	0f 28 85 e0 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T22[ebp]
  0034b	0f 29 85 f0 fe
	ff ff		 movaps	 XMMWORD PTR _x3$[ebp], xmm0

; 1696 :             xY = _mm_srli_epi16(x1, 8);

  00352	0f 28 85 30 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$[ebp]
  00359	66 0f 71 d0 08	 psrlw	 xmm0, 8
  0035e	0f 29 85 d0 fd
	ff ff		 movaps	 XMMWORD PTR $T21[ebp], xmm0
  00365	0f 28 85 d0 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T21[ebp]
  0036c	0f 29 85 d0 fe
	ff ff		 movaps	 XMMWORD PTR _xY$[ebp], xmm0

; 1697 :             xU = _mm_srli_epi16(x2, 8);

  00373	0f 28 85 10 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x2$[ebp]
  0037a	66 0f 71 d0 08	 psrlw	 xmm0, 8
  0037f	0f 29 85 c0 fd
	ff ff		 movaps	 XMMWORD PTR $T20[ebp], xmm0
  00386	0f 28 85 c0 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T20[ebp]
  0038d	0f 29 85 c0 fe
	ff ff		 movaps	 XMMWORD PTR _xU$[ebp], xmm0

; 1698 :             xV = _mm_srli_epi16(x3, 8);

  00394	0f 28 85 f0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _x3$[ebp]
  0039b	66 0f 71 d0 08	 psrlw	 xmm0, 8
  003a0	0f 29 85 b0 fd
	ff ff		 movaps	 XMMWORD PTR $T19[ebp], xmm0
  003a7	0f 28 85 b0 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T19[ebp]
  003ae	0f 29 85 b0 fe
	ff ff		 movaps	 XMMWORD PTR _xV$[ebp], xmm0

; 1699 : 
; 1700 :             x1 = _mm_loadu_si128((__m128i *)(ycp + 24));

  003b5	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR _ycp$33[ebp]
  003bb	83 c0 30	 add	 eax, 48			; 00000030H
  003be	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  003c1	0f 29 85 a0 fd
	ff ff		 movaps	 XMMWORD PTR $T18[ebp], xmm0
  003c8	0f 28 85 a0 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T18[ebp]
  003cf	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR _x1$[ebp], xmm0

; 1701 :             x2 = _mm_loadu_si128((__m128i *)(ycp + 32));

  003d6	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR _ycp$33[ebp]
  003dc	83 c1 40	 add	 ecx, 64			; 00000040H
  003df	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  003e2	0f 29 85 90 fd
	ff ff		 movaps	 XMMWORD PTR $T17[ebp], xmm0
  003e9	0f 28 85 90 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T17[ebp]
  003f0	0f 29 85 10 ff
	ff ff		 movaps	 XMMWORD PTR _x2$[ebp], xmm0

; 1702 :             x3 = _mm_loadu_si128((__m128i *)(ycp + 40));

  003f7	8b 95 98 fe ff
	ff		 mov	 edx, DWORD PTR _ycp$33[ebp]
  003fd	83 c2 50	 add	 edx, 80			; 00000050H
  00400	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  00403	0f 29 85 80 fd
	ff ff		 movaps	 XMMWORD PTR $T16[ebp], xmm0
  0040a	0f 28 85 80 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T16[ebp]
  00411	0f 29 85 f0 fe
	ff ff		 movaps	 XMMWORD PTR _x3$[ebp], xmm0

; 1703 :             gather_y_u_v_from_yc48(x1, x2, x3);

  00418	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _x3$[ebp]
  0041e	50		 push	 eax
  0041f	8d 8d 10 ff ff
	ff		 lea	 ecx, DWORD PTR _x2$[ebp]
  00425	51		 push	 ecx
  00426	8d 95 30 ff ff
	ff		 lea	 edx, DWORD PTR _x1$[ebp]
  0042c	52		 push	 edx
  0042d	e8 00 00 00 00	 call	 ?gather_y_u_v_from_yc48@@YAXAAT__m128i@@00@Z ; gather_y_u_v_from_yc48
  00432	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1704 : 
; 1705 :             x1 = convert_y_range_from_yc48(x1, xC_Y_L_MA_16, Y_L_RSH_16, xC_YCC, xC_pw_one);

  00435	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR ?Array_Y_L_MA_16@@3QBFB
  0043c	0f 29 85 70 fd
	ff ff		 movaps	 XMMWORD PTR $T15[ebp], xmm0
  00443	8d 45 b0	 lea	 eax, DWORD PTR _xC_pw_one$[ebp]
  00446	50		 push	 eax
  00447	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR _xC_YCC$[ebp]
  0044d	51		 push	 ecx
  0044e	6a 04		 push	 4
  00450	8d 95 70 fd ff
	ff		 lea	 edx, DWORD PTR $T15[ebp]
  00456	52		 push	 edx
  00457	0f 28 85 30 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$[ebp]
  0045e	e8 00 00 00 00	 call	 ?convert_y_range_from_yc48@@YA?AT__m128i@@T1@ABT1@H11@Z ; convert_y_range_from_yc48
  00463	83 c4 10	 add	 esp, 16			; 00000010H
  00466	0f 29 85 60 fd
	ff ff		 movaps	 XMMWORD PTR $T14[ebp], xmm0
  0046d	0f 28 85 60 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T14[ebp]
  00474	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR _x1$[ebp], xmm0

; 1706 :             x2 = convert_uv_range_from_yc48(x2, _mm_set1_epi16(UV_OFFSET_x1), xC_UV_L_MA_16_444, UV_L_RSH_16_444, xC_YCC, xC_pw_one);

  0047b	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR ?Array_UV_L_MA_16_444@@3QBFB
  00482	0f 29 85 40 fd
	ff ff		 movaps	 XMMWORD PTR $T12[ebp], xmm0
  00489	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@08000800080008000800080008000800
  00490	0f 29 85 50 fd
	ff ff		 movaps	 XMMWORD PTR $T13[ebp], xmm0
  00497	8d 45 b0	 lea	 eax, DWORD PTR _xC_pw_one$[ebp]
  0049a	50		 push	 eax
  0049b	0f 28 8d 70 ff
	ff ff		 movaps	 xmm1, XMMWORD PTR _xC_YCC$[ebp]
  004a2	6a 00		 push	 0
  004a4	8d 8d 40 fd ff
	ff		 lea	 ecx, DWORD PTR $T12[ebp]
  004aa	51		 push	 ecx
  004ab	8d 95 50 fd ff
	ff		 lea	 edx, DWORD PTR $T13[ebp]
  004b1	52		 push	 edx
  004b2	0f 28 85 10 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x2$[ebp]
  004b9	e8 00 00 00 00	 call	 ?convert_uv_range_from_yc48@@YA?AT__m128i@@T1@ABT1@1H01@Z ; convert_uv_range_from_yc48
  004be	83 c4 10	 add	 esp, 16			; 00000010H
  004c1	0f 29 85 30 fd
	ff ff		 movaps	 XMMWORD PTR $T11[ebp], xmm0
  004c8	0f 28 85 30 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T11[ebp]
  004cf	0f 29 85 10 ff
	ff ff		 movaps	 XMMWORD PTR _x2$[ebp], xmm0

; 1707 :             x3 = convert_uv_range_from_yc48(x3, _mm_set1_epi16(UV_OFFSET_x1), xC_UV_L_MA_16_444, UV_L_RSH_16_444, xC_YCC, xC_pw_one);

  004d6	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR ?Array_UV_L_MA_16_444@@3QBFB
  004dd	0f 29 85 10 fd
	ff ff		 movaps	 XMMWORD PTR $T9[ebp], xmm0
  004e4	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@08000800080008000800080008000800
  004eb	0f 29 85 20 fd
	ff ff		 movaps	 XMMWORD PTR $T10[ebp], xmm0
  004f2	8d 45 b0	 lea	 eax, DWORD PTR _xC_pw_one$[ebp]
  004f5	50		 push	 eax
  004f6	0f 28 8d 70 ff
	ff ff		 movaps	 xmm1, XMMWORD PTR _xC_YCC$[ebp]
  004fd	6a 00		 push	 0
  004ff	8d 8d 10 fd ff
	ff		 lea	 ecx, DWORD PTR $T9[ebp]
  00505	51		 push	 ecx
  00506	8d 95 20 fd ff
	ff		 lea	 edx, DWORD PTR $T10[ebp]
  0050c	52		 push	 edx
  0050d	0f 28 85 f0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _x3$[ebp]
  00514	e8 00 00 00 00	 call	 ?convert_uv_range_from_yc48@@YA?AT__m128i@@T1@ABT1@1H01@Z ; convert_uv_range_from_yc48
  00519	83 c4 10	 add	 esp, 16			; 00000010H
  0051c	0f 29 85 00 fd
	ff ff		 movaps	 XMMWORD PTR $T8[ebp], xmm0
  00523	0f 28 85 00 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T8[ebp]
  0052a	0f 29 85 f0 fe
	ff ff		 movaps	 XMMWORD PTR _x3$[ebp], xmm0

; 1708 :             x1 = _mm_srli_epi16(x1, 8);

  00531	0f 28 85 30 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$[ebp]
  00538	66 0f 71 d0 08	 psrlw	 xmm0, 8
  0053d	0f 29 85 f0 fc
	ff ff		 movaps	 XMMWORD PTR $T7[ebp], xmm0
  00544	0f 28 85 f0 fc
	ff ff		 movaps	 xmm0, XMMWORD PTR $T7[ebp]
  0054b	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR _x1$[ebp], xmm0

; 1709 :             x2 = _mm_srli_epi16(x2, 8);

  00552	0f 28 85 10 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x2$[ebp]
  00559	66 0f 71 d0 08	 psrlw	 xmm0, 8
  0055e	0f 29 85 e0 fc
	ff ff		 movaps	 XMMWORD PTR $T6[ebp], xmm0
  00565	0f 28 85 e0 fc
	ff ff		 movaps	 xmm0, XMMWORD PTR $T6[ebp]
  0056c	0f 29 85 10 ff
	ff ff		 movaps	 XMMWORD PTR _x2$[ebp], xmm0

; 1710 :             x3 = _mm_srli_epi16(x3, 8);

  00573	0f 28 85 f0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _x3$[ebp]
  0057a	66 0f 71 d0 08	 psrlw	 xmm0, 8
  0057f	0f 29 85 d0 fc
	ff ff		 movaps	 XMMWORD PTR $T5[ebp], xmm0
  00586	0f 28 85 d0 fc
	ff ff		 movaps	 xmm0, XMMWORD PTR $T5[ebp]
  0058d	0f 29 85 f0 fe
	ff ff		 movaps	 XMMWORD PTR _x3$[ebp], xmm0

; 1711 : 
; 1712 :             xY = _mm_packus_epi16(xY, x1);

  00594	0f 28 85 d0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _xY$[ebp]
  0059b	66 0f 67 85 30
	ff ff ff	 packuswb xmm0, XMMWORD PTR _x1$[ebp]
  005a3	0f 29 85 c0 fc
	ff ff		 movaps	 XMMWORD PTR $T4[ebp], xmm0
  005aa	0f 28 85 c0 fc
	ff ff		 movaps	 xmm0, XMMWORD PTR $T4[ebp]
  005b1	0f 29 85 d0 fe
	ff ff		 movaps	 XMMWORD PTR _xY$[ebp], xmm0

; 1713 :             xU = _mm_packus_epi16(xU, x2);

  005b8	0f 28 85 c0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _xU$[ebp]
  005bf	66 0f 67 85 10
	ff ff ff	 packuswb xmm0, XMMWORD PTR _x2$[ebp]
  005c7	0f 29 85 b0 fc
	ff ff		 movaps	 XMMWORD PTR $T3[ebp], xmm0
  005ce	0f 28 85 b0 fc
	ff ff		 movaps	 xmm0, XMMWORD PTR $T3[ebp]
  005d5	0f 29 85 c0 fe
	ff ff		 movaps	 XMMWORD PTR _xU$[ebp], xmm0

; 1714 :             xV = _mm_packus_epi16(xV, x3);

  005dc	0f 28 85 b0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _xV$[ebp]
  005e3	66 0f 67 85 f0
	fe ff ff	 packuswb xmm0, XMMWORD PTR _x3$[ebp]
  005eb	0f 29 85 a0 fc
	ff ff		 movaps	 XMMWORD PTR $T2[ebp], xmm0
  005f2	0f 28 85 a0 fc
	ff ff		 movaps	 xmm0, XMMWORD PTR $T2[ebp]
  005f9	0f 29 85 b0 fe
	ff ff		 movaps	 XMMWORD PTR _xV$[ebp], xmm0

; 1715 : 
; 1716 :             _mm_store_switch_si128((__m128i*)Y, xY);

  00600	33 c0		 xor	 eax, eax
  00602	74 1c		 je	 SHORT $LN9@convert_yc
  00604	0f 28 85 d0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _xY$[ebp]
  0060b	8b 8d a8 fe ff
	ff		 mov	 ecx, DWORD PTR _Y$37[ebp]
  00611	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  00614	c7 85 8c fc ff
	ff 00 00 00 00	 mov	 DWORD PTR tv322[ebp], 0
  0061e	eb 1a		 jmp	 SHORT $LN10@convert_yc
$LN9@convert_yc:
  00620	0f 10 85 d0 fe
	ff ff		 movups	 xmm0, XMMWORD PTR _xY$[ebp]
  00627	8b 95 a8 fe ff
	ff		 mov	 edx, DWORD PTR _Y$37[ebp]
  0062d	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0
  00630	c7 85 8c fc ff
	ff 00 00 00 00	 mov	 DWORD PTR tv322[ebp], 0
$LN10@convert_yc:

; 1717 :             _mm_store_switch_si128((__m128i*)U, xU);

  0063a	33 c0		 xor	 eax, eax
  0063c	74 1c		 je	 SHORT $LN11@convert_yc
  0063e	0f 28 85 c0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _xU$[ebp]
  00645	8b 8d a4 fe ff
	ff		 mov	 ecx, DWORD PTR _U$36[ebp]
  0064b	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  0064e	c7 85 88 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR tv328[ebp], 0
  00658	eb 1a		 jmp	 SHORT $LN12@convert_yc
$LN11@convert_yc:
  0065a	0f 10 85 c0 fe
	ff ff		 movups	 xmm0, XMMWORD PTR _xU$[ebp]
  00661	8b 95 a4 fe ff
	ff		 mov	 edx, DWORD PTR _U$36[ebp]
  00667	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0
  0066a	c7 85 88 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR tv328[ebp], 0
$LN12@convert_yc:

; 1718 :             _mm_store_switch_si128((__m128i*)V, xV);

  00674	33 c0		 xor	 eax, eax
  00676	74 1c		 je	 SHORT $LN13@convert_yc
  00678	0f 28 85 b0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _xV$[ebp]
  0067f	8b 8d a0 fe ff
	ff		 mov	 ecx, DWORD PTR _V$35[ebp]
  00685	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  00688	c7 85 84 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR tv334[ebp], 0
  00692	eb 1a		 jmp	 SHORT $LN14@convert_yc
$LN13@convert_yc:
  00694	0f 10 85 b0 fe
	ff ff		 movups	 xmm0, XMMWORD PTR _xV$[ebp]
  0069b	8b 95 a0 fe ff
	ff		 mov	 edx, DWORD PTR _V$35[ebp]
  006a1	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0
  006a4	c7 85 84 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR tv334[ebp], 0
$LN14@convert_yc:

; 1719 :         }

  006ae	e9 d8 fa ff ff	 jmp	 $LN5@convert_yc
$LN6@convert_yc:

; 1720 :     }

  006b3	e9 5b fa ff ff	 jmp	 $LN2@convert_yc
$LN1@convert_yc:

; 1721 : }

  006b8	52		 push	 edx
  006b9	8b cd		 mov	 ecx, ebp
  006bb	50		 push	 eax
  006bc	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN22@convert_yc
  006c2	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  006c7	58		 pop	 eax
  006c8	5a		 pop	 edx
  006c9	5f		 pop	 edi
  006ca	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  006cd	33 cd		 xor	 ecx, ebp
  006cf	e8 00 00 00 00	 call	 @__security_check_cookie@4
  006d4	8b e5		 mov	 esp, ebp
  006d6	5d		 pop	 ebp
  006d7	8b e3		 mov	 esp, ebx
  006d9	5b		 pop	 ebx
  006da	c3		 ret	 0
  006db	90		 npad	 1
$LN22@convert_yc:
  006dc	06 00 00 00	 DD	 6
  006e0	00 00 00 00	 DD	 $LN21@convert_yc
$LN21@convert_yc:
  006e4	ec ff ff ff	 DD	 -20			; ffffffecH
  006e8	0c 00 00 00	 DD	 12			; 0000000cH
  006ec	00 00 00 00	 DD	 $LN15@convert_yc
  006f0	b0 ff ff ff	 DD	 -80			; ffffffb0H
  006f4	10 00 00 00	 DD	 16			; 00000010H
  006f8	00 00 00 00	 DD	 $LN16@convert_yc
  006fc	70 ff ff ff	 DD	 -144			; ffffff70H
  00700	10 00 00 00	 DD	 16			; 00000010H
  00704	00 00 00 00	 DD	 $LN17@convert_yc
  00708	30 ff ff ff	 DD	 -208			; ffffff30H
  0070c	10 00 00 00	 DD	 16			; 00000010H
  00710	00 00 00 00	 DD	 $LN18@convert_yc
  00714	10 ff ff ff	 DD	 -240			; ffffff10H
  00718	10 00 00 00	 DD	 16			; 00000010H
  0071c	00 00 00 00	 DD	 $LN19@convert_yc
  00720	f0 fe ff ff	 DD	 -272			; fffffef0H
  00724	10 00 00 00	 DD	 16			; 00000010H
  00728	00 00 00 00	 DD	 $LN20@convert_yc
$LN20@convert_yc:
  0072c	78		 DB	 120			; 00000078H
  0072d	33		 DB	 51			; 00000033H
  0072e	00		 DB	 0
$LN19@convert_yc:
  0072f	78		 DB	 120			; 00000078H
  00730	32		 DB	 50			; 00000032H
  00731	00		 DB	 0
$LN18@convert_yc:
  00732	78		 DB	 120			; 00000078H
  00733	31		 DB	 49			; 00000031H
  00734	00		 DB	 0
$LN17@convert_yc:
  00735	78		 DB	 120			; 00000078H
  00736	43		 DB	 67			; 00000043H
  00737	5f		 DB	 95			; 0000005fH
  00738	59		 DB	 89			; 00000059H
  00739	43		 DB	 67			; 00000043H
  0073a	43		 DB	 67			; 00000043H
  0073b	00		 DB	 0
$LN16@convert_yc:
  0073c	78		 DB	 120			; 00000078H
  0073d	43		 DB	 67			; 00000043H
  0073e	5f		 DB	 95			; 0000005fH
  0073f	70		 DB	 112			; 00000070H
  00740	77		 DB	 119			; 00000077H
  00741	5f		 DB	 95			; 0000005fH
  00742	6f		 DB	 111			; 0000006fH
  00743	6e		 DB	 110			; 0000006eH
  00744	65		 DB	 101			; 00000065H
  00745	00		 DB	 0
$LN15@convert_yc:
  00746	79		 DB	 121			; 00000079H
  00747	5f		 DB	 95			; 0000005fH
  00748	72		 DB	 114			; 00000072H
  00749	61		 DB	 97			; 00000061H
  0074a	6e		 DB	 110			; 0000006eH
  0074b	67		 DB	 103			; 00000067H
  0074c	65		 DB	 101			; 00000065H
  0074d	00		 DB	 0
??$convert_yc48_to_yuv444_simd@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yc48_to_yuv444_simd<0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_sse2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yc48_to_yuv444_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yc48_to_yuv444_sse2

; 201  : void convert_yc48_to_yuv444_sse2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 202  :     convert_yc48_to_yuv444_simd<false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yc48_to_yuv444_simd@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yc48_to_yuv444_simd<0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 203  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yc48_to_yuv444_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yc48_to_yuv444_sse2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -224						; size = 12
$T2 = -208						; size = 16
$T3 = -192						; size = 16
$T4 = -176						; size = 16
$T5 = -160						; size = 16
_x1$6 = -144						; size = 16
$T7 = -128						; size = 16
_x0$8 = -112						; size = 16
_x$9 = -88						; size = 4
_dst_ptr$10 = -84					; size = 4
_src_ptr$11 = -80					; size = 4
_y$12 = -76						; size = 4
_y_width$13 = -72					; size = 4
_dstLine$14 = -68					; size = 4
_srcYLine$15 = -64					; size = 4
_i$16 = -60						; size = 4
$T17 = -56						; size = 12
_y_range$ = -40						; size = 12
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yuv444_high_to_yuv444_simd@$08@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_high_to_yuv444_simd<9>

; 1281 : static void __forceinline convert_yuv444_high_to_yuv444_simd(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec e0 00 00
	00		 sub	 esp, 224		; 000000e0H
  0001c	57		 push	 edi
  0001d	8d bd 20 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-224]
  00023	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1282 :     static_assert(8 < in_bit_depth && in_bit_depth <= 16, "in_bit_depth must be 9-16.");
; 1283 :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 1284 :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 1285 :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 1286 :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 1287 :     const int src_y_pitch = src_y_pitch_byte >> 1;

  0007c	8b 53 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  0007f	d1 fa		 sar	 edx, 1
  00081	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 1288 :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00084	8b 43 2c	 mov	 eax, DWORD PTR _thread_n$[ebx]
  00087	50		 push	 eax
  00088	8b 4b 28	 mov	 ecx, DWORD PTR _thread_id$[ebx]
  0008b	51		 push	 ecx
  0008c	8b 53 20	 mov	 edx, DWORD PTR _height$[ebx]
  0008f	2b 55 ec	 sub	 edx, DWORD PTR _crop_bottom$[ebp]
  00092	52		 push	 edx
  00093	8b 45 f4	 mov	 eax, DWORD PTR _crop_up$[ebp]
  00096	50		 push	 eax
  00097	8d 8d 20 ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  0009d	51		 push	 ecx
  0009e	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  000a3	83 c4 14	 add	 esp, 20			; 00000014H
  000a6	8b 10		 mov	 edx, DWORD PTR [eax]
  000a8	89 55 c8	 mov	 DWORD PTR $T17[ebp], edx
  000ab	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ae	89 4d cc	 mov	 DWORD PTR $T17[ebp+4], ecx
  000b1	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000b4	89 55 d0	 mov	 DWORD PTR $T17[ebp+8], edx
  000b7	8b 45 c8	 mov	 eax, DWORD PTR $T17[ebp]
  000ba	89 45 d8	 mov	 DWORD PTR _y_range$[ebp], eax
  000bd	8b 4d cc	 mov	 ecx, DWORD PTR $T17[ebp+4]
  000c0	89 4d dc	 mov	 DWORD PTR _y_range$[ebp+4], ecx
  000c3	8b 55 d0	 mov	 edx, DWORD PTR $T17[ebp+8]
  000c6	89 55 e0	 mov	 DWORD PTR _y_range$[ebp+8], edx

; 1289 :     for (int i = 0; i < 3; i++) {

  000c9	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _i$16[ebp], 0
  000d0	eb 09		 jmp	 SHORT $LN4@convert_yu
$LN2@convert_yu:
  000d2	8b 45 c4	 mov	 eax, DWORD PTR _i$16[ebp]
  000d5	83 c0 01	 add	 eax, 1
  000d8	89 45 c4	 mov	 DWORD PTR _i$16[ebp], eax
$LN4@convert_yu:
  000db	83 7d c4 03	 cmp	 DWORD PTR _i$16[ebp], 3
  000df	0f 8d 4d 01 00
	00		 jge	 $LN1@convert_yu

; 1290 :         uint16_t *srcYLine = (uint16_t *)src[i] + src_y_pitch * y_range.start_src + crop_left;

  000e5	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  000e8	0f af 4d d8	 imul	 ecx, DWORD PTR _y_range$[ebp]
  000ec	8b 55 c4	 mov	 edx, DWORD PTR _i$16[ebp]
  000ef	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  000f2	8b 14 90	 mov	 edx, DWORD PTR [eax+edx*4]
  000f5	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  000f8	8b 4d f8	 mov	 ecx, DWORD PTR _crop_left$[ebp]
  000fb	8d 14 48	 lea	 edx, DWORD PTR [eax+ecx*2]
  000fe	89 55 c0	 mov	 DWORD PTR _srcYLine$15[ebp], edx

; 1291 :         uint8_t *dstLine = (uint8_t *)dst[i] + dst_y_pitch_byte * y_range.start_dst;

  00101	8b 43 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  00104	0f af 45 dc	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  00108	8b 4d c4	 mov	 ecx, DWORD PTR _i$16[ebp]
  0010b	8b 53 08	 mov	 edx, DWORD PTR _dst$[ebx]
  0010e	03 04 8a	 add	 eax, DWORD PTR [edx+ecx*4]
  00111	89 45 bc	 mov	 DWORD PTR _dstLine$14[ebp], eax

; 1292 :         const int y_width = width - crop_right - crop_left;

  00114	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  00117	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  0011a	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  0011d	89 45 b8	 mov	 DWORD PTR _y_width$13[ebp], eax

; 1293 :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch_byte) {

  00120	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _y$12[ebp], 0
  00127	eb 1e		 jmp	 SHORT $LN7@convert_yu
$LN5@convert_yu:
  00129	8b 4d b4	 mov	 ecx, DWORD PTR _y$12[ebp]
  0012c	83 c1 01	 add	 ecx, 1
  0012f	89 4d b4	 mov	 DWORD PTR _y$12[ebp], ecx
  00132	8b 55 e8	 mov	 edx, DWORD PTR _src_y_pitch$[ebp]
  00135	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$15[ebp]
  00138	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  0013b	89 4d c0	 mov	 DWORD PTR _srcYLine$15[ebp], ecx
  0013e	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$14[ebp]
  00141	03 53 1c	 add	 edx, DWORD PTR _dst_y_pitch_byte$[ebx]
  00144	89 55 bc	 mov	 DWORD PTR _dstLine$14[ebp], edx
$LN7@convert_yu:
  00147	8b 45 b4	 mov	 eax, DWORD PTR _y$12[ebp]
  0014a	3b 45 e0	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  0014d	0f 8d da 00 00
	00		 jge	 $LN6@convert_yu

; 1294 :             uint16_t *src_ptr = srcYLine;

  00153	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$15[ebp]
  00156	89 4d b0	 mov	 DWORD PTR _src_ptr$11[ebp], ecx

; 1295 :             uint8_t *dst_ptr = dstLine;

  00159	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$14[ebp]
  0015c	89 55 ac	 mov	 DWORD PTR _dst_ptr$10[ebp], edx

; 1296 :             for (int x = 0; x < y_width; x += 16, dst_ptr += 16, src_ptr += 16) {

  0015f	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR _x$9[ebp], 0
  00166	eb 1b		 jmp	 SHORT $LN10@convert_yu
$LN8@convert_yu:
  00168	8b 45 a8	 mov	 eax, DWORD PTR _x$9[ebp]
  0016b	83 c0 10	 add	 eax, 16			; 00000010H
  0016e	89 45 a8	 mov	 DWORD PTR _x$9[ebp], eax
  00171	8b 4d ac	 mov	 ecx, DWORD PTR _dst_ptr$10[ebp]
  00174	83 c1 10	 add	 ecx, 16			; 00000010H
  00177	89 4d ac	 mov	 DWORD PTR _dst_ptr$10[ebp], ecx
  0017a	8b 55 b0	 mov	 edx, DWORD PTR _src_ptr$11[ebp]
  0017d	83 c2 20	 add	 edx, 32			; 00000020H
  00180	89 55 b0	 mov	 DWORD PTR _src_ptr$11[ebp], edx
$LN10@convert_yu:
  00183	8b 45 a8	 mov	 eax, DWORD PTR _x$9[ebp]
  00186	3b 45 b8	 cmp	 eax, DWORD PTR _y_width$13[ebp]
  00189	0f 8d 99 00 00
	00		 jge	 $LN9@convert_yu

; 1297 :                 __m128i x0 = _mm_loadu_si128((const __m128i *)(src_ptr + 0));

  0018f	8b 4d b0	 mov	 ecx, DWORD PTR _src_ptr$11[ebp]
  00192	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00195	0f 29 45 80	 movaps	 XMMWORD PTR $T7[ebp], xmm0
  00199	0f 28 45 80	 movaps	 xmm0, XMMWORD PTR $T7[ebp]
  0019d	0f 29 45 90	 movaps	 XMMWORD PTR _x0$8[ebp], xmm0

; 1298 :                 __m128i x1 = _mm_loadu_si128((const __m128i *)(src_ptr + 8));

  001a1	8b 55 b0	 mov	 edx, DWORD PTR _src_ptr$11[ebp]
  001a4	83 c2 10	 add	 edx, 16			; 00000010H
  001a7	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  001aa	0f 29 85 60 ff
	ff ff		 movaps	 XMMWORD PTR $T5[ebp], xmm0
  001b1	0f 28 85 60 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T5[ebp]
  001b8	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR _x1$6[ebp], xmm0

; 1299 :                 x0 = _mm_srli_epi16(x0, in_bit_depth - 8);

  001bf	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR _x0$8[ebp]
  001c3	66 0f 71 d0 01	 psrlw	 xmm0, 1
  001c8	0f 29 85 50 ff
	ff ff		 movaps	 XMMWORD PTR $T4[ebp], xmm0
  001cf	0f 28 85 50 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T4[ebp]
  001d6	0f 29 45 90	 movaps	 XMMWORD PTR _x0$8[ebp], xmm0

; 1300 :                 x1 = _mm_srli_epi16(x1, in_bit_depth - 8);

  001da	0f 28 85 70 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$6[ebp]
  001e1	66 0f 71 d0 01	 psrlw	 xmm0, 1
  001e6	0f 29 85 40 ff
	ff ff		 movaps	 XMMWORD PTR $T3[ebp], xmm0
  001ed	0f 28 85 40 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T3[ebp]
  001f4	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR _x1$6[ebp], xmm0

; 1301 :                 x0 = _mm_packus_epi16(x0, x1);

  001fb	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR _x0$8[ebp]
  001ff	66 0f 67 85 70
	ff ff ff	 packuswb xmm0, XMMWORD PTR _x1$6[ebp]
  00207	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR $T2[ebp], xmm0
  0020e	0f 28 85 30 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T2[ebp]
  00215	0f 29 45 90	 movaps	 XMMWORD PTR _x0$8[ebp], xmm0

; 1302 :                 _mm_storeu_si128((__m128i *)dst_ptr, x0);

  00219	0f 10 45 90	 movups	 xmm0, XMMWORD PTR _x0$8[ebp]
  0021d	8b 45 ac	 mov	 eax, DWORD PTR _dst_ptr$10[ebp]
  00220	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 1303 :             }

  00223	e9 40 ff ff ff	 jmp	 $LN8@convert_yu
$LN9@convert_yu:

; 1304 :         }

  00228	e9 fc fe ff ff	 jmp	 $LN5@convert_yu
$LN6@convert_yu:

; 1305 :     }

  0022d	e9 a0 fe ff ff	 jmp	 $LN2@convert_yu
$LN1@convert_yu:

; 1306 : }

  00232	52		 push	 edx
  00233	8b cd		 mov	 ecx, ebp
  00235	50		 push	 eax
  00236	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN14@convert_yu
  0023c	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00241	58		 pop	 eax
  00242	5a		 pop	 edx
  00243	5f		 pop	 edi
  00244	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00247	33 cd		 xor	 ecx, ebp
  00249	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0024e	8b e5		 mov	 esp, ebp
  00250	5d		 pop	 ebp
  00251	8b e3		 mov	 esp, ebx
  00253	5b		 pop	 ebx
  00254	c3		 ret	 0
  00255	0f 1f 00	 npad	 3
$LN14@convert_yu:
  00258	01 00 00 00	 DD	 1
  0025c	00 00 00 00	 DD	 $LN13@convert_yu
$LN13@convert_yu:
  00260	d8 ff ff ff	 DD	 -40			; ffffffd8H
  00264	0c 00 00 00	 DD	 12			; 0000000cH
  00268	00 00 00 00	 DD	 $LN12@convert_yu
$LN12@convert_yu:
  0026c	79		 DB	 121			; 00000079H
  0026d	5f		 DB	 95			; 0000005fH
  0026e	72		 DB	 114			; 00000072H
  0026f	61		 DB	 97			; 00000061H
  00270	6e		 DB	 110			; 0000006eH
  00271	67		 DB	 103			; 00000067H
  00272	65		 DB	 101			; 00000065H
  00273	00		 DB	 0
??$convert_yuv444_high_to_yuv444_simd@$08@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_high_to_yuv444_simd<9>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_sse2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuv444_09_to_yuv444_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_09_to_yuv444_sse2

; 197  : void convert_yuv444_09_to_yuv444_sse2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 198  :     convert_yuv444_high_to_yuv444_simd<9>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yuv444_high_to_yuv444_simd@$08@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_high_to_yuv444_simd<9>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 199  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yuv444_09_to_yuv444_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_09_to_yuv444_sse2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -224						; size = 12
$T2 = -208						; size = 16
$T3 = -192						; size = 16
$T4 = -176						; size = 16
$T5 = -160						; size = 16
_x1$6 = -144						; size = 16
$T7 = -128						; size = 16
_x0$8 = -112						; size = 16
_x$9 = -88						; size = 4
_dst_ptr$10 = -84					; size = 4
_src_ptr$11 = -80					; size = 4
_y$12 = -76						; size = 4
_y_width$13 = -72					; size = 4
_dstLine$14 = -68					; size = 4
_srcYLine$15 = -64					; size = 4
_i$16 = -60						; size = 4
$T17 = -56						; size = 12
_y_range$ = -40						; size = 12
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yuv444_high_to_yuv444_simd@$09@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_high_to_yuv444_simd<10>

; 1281 : static void __forceinline convert_yuv444_high_to_yuv444_simd(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec e0 00 00
	00		 sub	 esp, 224		; 000000e0H
  0001c	57		 push	 edi
  0001d	8d bd 20 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-224]
  00023	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1282 :     static_assert(8 < in_bit_depth && in_bit_depth <= 16, "in_bit_depth must be 9-16.");
; 1283 :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 1284 :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 1285 :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 1286 :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 1287 :     const int src_y_pitch = src_y_pitch_byte >> 1;

  0007c	8b 53 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  0007f	d1 fa		 sar	 edx, 1
  00081	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 1288 :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00084	8b 43 2c	 mov	 eax, DWORD PTR _thread_n$[ebx]
  00087	50		 push	 eax
  00088	8b 4b 28	 mov	 ecx, DWORD PTR _thread_id$[ebx]
  0008b	51		 push	 ecx
  0008c	8b 53 20	 mov	 edx, DWORD PTR _height$[ebx]
  0008f	2b 55 ec	 sub	 edx, DWORD PTR _crop_bottom$[ebp]
  00092	52		 push	 edx
  00093	8b 45 f4	 mov	 eax, DWORD PTR _crop_up$[ebp]
  00096	50		 push	 eax
  00097	8d 8d 20 ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  0009d	51		 push	 ecx
  0009e	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  000a3	83 c4 14	 add	 esp, 20			; 00000014H
  000a6	8b 10		 mov	 edx, DWORD PTR [eax]
  000a8	89 55 c8	 mov	 DWORD PTR $T17[ebp], edx
  000ab	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ae	89 4d cc	 mov	 DWORD PTR $T17[ebp+4], ecx
  000b1	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000b4	89 55 d0	 mov	 DWORD PTR $T17[ebp+8], edx
  000b7	8b 45 c8	 mov	 eax, DWORD PTR $T17[ebp]
  000ba	89 45 d8	 mov	 DWORD PTR _y_range$[ebp], eax
  000bd	8b 4d cc	 mov	 ecx, DWORD PTR $T17[ebp+4]
  000c0	89 4d dc	 mov	 DWORD PTR _y_range$[ebp+4], ecx
  000c3	8b 55 d0	 mov	 edx, DWORD PTR $T17[ebp+8]
  000c6	89 55 e0	 mov	 DWORD PTR _y_range$[ebp+8], edx

; 1289 :     for (int i = 0; i < 3; i++) {

  000c9	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _i$16[ebp], 0
  000d0	eb 09		 jmp	 SHORT $LN4@convert_yu
$LN2@convert_yu:
  000d2	8b 45 c4	 mov	 eax, DWORD PTR _i$16[ebp]
  000d5	83 c0 01	 add	 eax, 1
  000d8	89 45 c4	 mov	 DWORD PTR _i$16[ebp], eax
$LN4@convert_yu:
  000db	83 7d c4 03	 cmp	 DWORD PTR _i$16[ebp], 3
  000df	0f 8d 4d 01 00
	00		 jge	 $LN1@convert_yu

; 1290 :         uint16_t *srcYLine = (uint16_t *)src[i] + src_y_pitch * y_range.start_src + crop_left;

  000e5	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  000e8	0f af 4d d8	 imul	 ecx, DWORD PTR _y_range$[ebp]
  000ec	8b 55 c4	 mov	 edx, DWORD PTR _i$16[ebp]
  000ef	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  000f2	8b 14 90	 mov	 edx, DWORD PTR [eax+edx*4]
  000f5	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  000f8	8b 4d f8	 mov	 ecx, DWORD PTR _crop_left$[ebp]
  000fb	8d 14 48	 lea	 edx, DWORD PTR [eax+ecx*2]
  000fe	89 55 c0	 mov	 DWORD PTR _srcYLine$15[ebp], edx

; 1291 :         uint8_t *dstLine = (uint8_t *)dst[i] + dst_y_pitch_byte * y_range.start_dst;

  00101	8b 43 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  00104	0f af 45 dc	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  00108	8b 4d c4	 mov	 ecx, DWORD PTR _i$16[ebp]
  0010b	8b 53 08	 mov	 edx, DWORD PTR _dst$[ebx]
  0010e	03 04 8a	 add	 eax, DWORD PTR [edx+ecx*4]
  00111	89 45 bc	 mov	 DWORD PTR _dstLine$14[ebp], eax

; 1292 :         const int y_width = width - crop_right - crop_left;

  00114	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  00117	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  0011a	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  0011d	89 45 b8	 mov	 DWORD PTR _y_width$13[ebp], eax

; 1293 :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch_byte) {

  00120	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _y$12[ebp], 0
  00127	eb 1e		 jmp	 SHORT $LN7@convert_yu
$LN5@convert_yu:
  00129	8b 4d b4	 mov	 ecx, DWORD PTR _y$12[ebp]
  0012c	83 c1 01	 add	 ecx, 1
  0012f	89 4d b4	 mov	 DWORD PTR _y$12[ebp], ecx
  00132	8b 55 e8	 mov	 edx, DWORD PTR _src_y_pitch$[ebp]
  00135	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$15[ebp]
  00138	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  0013b	89 4d c0	 mov	 DWORD PTR _srcYLine$15[ebp], ecx
  0013e	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$14[ebp]
  00141	03 53 1c	 add	 edx, DWORD PTR _dst_y_pitch_byte$[ebx]
  00144	89 55 bc	 mov	 DWORD PTR _dstLine$14[ebp], edx
$LN7@convert_yu:
  00147	8b 45 b4	 mov	 eax, DWORD PTR _y$12[ebp]
  0014a	3b 45 e0	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  0014d	0f 8d da 00 00
	00		 jge	 $LN6@convert_yu

; 1294 :             uint16_t *src_ptr = srcYLine;

  00153	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$15[ebp]
  00156	89 4d b0	 mov	 DWORD PTR _src_ptr$11[ebp], ecx

; 1295 :             uint8_t *dst_ptr = dstLine;

  00159	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$14[ebp]
  0015c	89 55 ac	 mov	 DWORD PTR _dst_ptr$10[ebp], edx

; 1296 :             for (int x = 0; x < y_width; x += 16, dst_ptr += 16, src_ptr += 16) {

  0015f	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR _x$9[ebp], 0
  00166	eb 1b		 jmp	 SHORT $LN10@convert_yu
$LN8@convert_yu:
  00168	8b 45 a8	 mov	 eax, DWORD PTR _x$9[ebp]
  0016b	83 c0 10	 add	 eax, 16			; 00000010H
  0016e	89 45 a8	 mov	 DWORD PTR _x$9[ebp], eax
  00171	8b 4d ac	 mov	 ecx, DWORD PTR _dst_ptr$10[ebp]
  00174	83 c1 10	 add	 ecx, 16			; 00000010H
  00177	89 4d ac	 mov	 DWORD PTR _dst_ptr$10[ebp], ecx
  0017a	8b 55 b0	 mov	 edx, DWORD PTR _src_ptr$11[ebp]
  0017d	83 c2 20	 add	 edx, 32			; 00000020H
  00180	89 55 b0	 mov	 DWORD PTR _src_ptr$11[ebp], edx
$LN10@convert_yu:
  00183	8b 45 a8	 mov	 eax, DWORD PTR _x$9[ebp]
  00186	3b 45 b8	 cmp	 eax, DWORD PTR _y_width$13[ebp]
  00189	0f 8d 99 00 00
	00		 jge	 $LN9@convert_yu

; 1297 :                 __m128i x0 = _mm_loadu_si128((const __m128i *)(src_ptr + 0));

  0018f	8b 4d b0	 mov	 ecx, DWORD PTR _src_ptr$11[ebp]
  00192	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00195	0f 29 45 80	 movaps	 XMMWORD PTR $T7[ebp], xmm0
  00199	0f 28 45 80	 movaps	 xmm0, XMMWORD PTR $T7[ebp]
  0019d	0f 29 45 90	 movaps	 XMMWORD PTR _x0$8[ebp], xmm0

; 1298 :                 __m128i x1 = _mm_loadu_si128((const __m128i *)(src_ptr + 8));

  001a1	8b 55 b0	 mov	 edx, DWORD PTR _src_ptr$11[ebp]
  001a4	83 c2 10	 add	 edx, 16			; 00000010H
  001a7	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  001aa	0f 29 85 60 ff
	ff ff		 movaps	 XMMWORD PTR $T5[ebp], xmm0
  001b1	0f 28 85 60 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T5[ebp]
  001b8	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR _x1$6[ebp], xmm0

; 1299 :                 x0 = _mm_srli_epi16(x0, in_bit_depth - 8);

  001bf	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR _x0$8[ebp]
  001c3	66 0f 71 d0 02	 psrlw	 xmm0, 2
  001c8	0f 29 85 50 ff
	ff ff		 movaps	 XMMWORD PTR $T4[ebp], xmm0
  001cf	0f 28 85 50 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T4[ebp]
  001d6	0f 29 45 90	 movaps	 XMMWORD PTR _x0$8[ebp], xmm0

; 1300 :                 x1 = _mm_srli_epi16(x1, in_bit_depth - 8);

  001da	0f 28 85 70 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$6[ebp]
  001e1	66 0f 71 d0 02	 psrlw	 xmm0, 2
  001e6	0f 29 85 40 ff
	ff ff		 movaps	 XMMWORD PTR $T3[ebp], xmm0
  001ed	0f 28 85 40 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T3[ebp]
  001f4	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR _x1$6[ebp], xmm0

; 1301 :                 x0 = _mm_packus_epi16(x0, x1);

  001fb	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR _x0$8[ebp]
  001ff	66 0f 67 85 70
	ff ff ff	 packuswb xmm0, XMMWORD PTR _x1$6[ebp]
  00207	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR $T2[ebp], xmm0
  0020e	0f 28 85 30 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T2[ebp]
  00215	0f 29 45 90	 movaps	 XMMWORD PTR _x0$8[ebp], xmm0

; 1302 :                 _mm_storeu_si128((__m128i *)dst_ptr, x0);

  00219	0f 10 45 90	 movups	 xmm0, XMMWORD PTR _x0$8[ebp]
  0021d	8b 45 ac	 mov	 eax, DWORD PTR _dst_ptr$10[ebp]
  00220	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 1303 :             }

  00223	e9 40 ff ff ff	 jmp	 $LN8@convert_yu
$LN9@convert_yu:

; 1304 :         }

  00228	e9 fc fe ff ff	 jmp	 $LN5@convert_yu
$LN6@convert_yu:

; 1305 :     }

  0022d	e9 a0 fe ff ff	 jmp	 $LN2@convert_yu
$LN1@convert_yu:

; 1306 : }

  00232	52		 push	 edx
  00233	8b cd		 mov	 ecx, ebp
  00235	50		 push	 eax
  00236	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN14@convert_yu
  0023c	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00241	58		 pop	 eax
  00242	5a		 pop	 edx
  00243	5f		 pop	 edi
  00244	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00247	33 cd		 xor	 ecx, ebp
  00249	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0024e	8b e5		 mov	 esp, ebp
  00250	5d		 pop	 ebp
  00251	8b e3		 mov	 esp, ebx
  00253	5b		 pop	 ebx
  00254	c3		 ret	 0
  00255	0f 1f 00	 npad	 3
$LN14@convert_yu:
  00258	01 00 00 00	 DD	 1
  0025c	00 00 00 00	 DD	 $LN13@convert_yu
$LN13@convert_yu:
  00260	d8 ff ff ff	 DD	 -40			; ffffffd8H
  00264	0c 00 00 00	 DD	 12			; 0000000cH
  00268	00 00 00 00	 DD	 $LN12@convert_yu
$LN12@convert_yu:
  0026c	79		 DB	 121			; 00000079H
  0026d	5f		 DB	 95			; 0000005fH
  0026e	72		 DB	 114			; 00000072H
  0026f	61		 DB	 97			; 00000061H
  00270	6e		 DB	 110			; 0000006eH
  00271	67		 DB	 103			; 00000067H
  00272	65		 DB	 101			; 00000065H
  00273	00		 DB	 0
??$convert_yuv444_high_to_yuv444_simd@$09@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_high_to_yuv444_simd<10>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_sse2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuv444_10_to_yuv444_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_10_to_yuv444_sse2

; 193  : void convert_yuv444_10_to_yuv444_sse2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 194  :     convert_yuv444_high_to_yuv444_simd<10>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yuv444_high_to_yuv444_simd@$09@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_high_to_yuv444_simd<10>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 195  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yuv444_10_to_yuv444_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_10_to_yuv444_sse2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -224						; size = 12
$T2 = -208						; size = 16
$T3 = -192						; size = 16
$T4 = -176						; size = 16
$T5 = -160						; size = 16
_x1$6 = -144						; size = 16
$T7 = -128						; size = 16
_x0$8 = -112						; size = 16
_x$9 = -88						; size = 4
_dst_ptr$10 = -84					; size = 4
_src_ptr$11 = -80					; size = 4
_y$12 = -76						; size = 4
_y_width$13 = -72					; size = 4
_dstLine$14 = -68					; size = 4
_srcYLine$15 = -64					; size = 4
_i$16 = -60						; size = 4
$T17 = -56						; size = 12
_y_range$ = -40						; size = 12
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yuv444_high_to_yuv444_simd@$0M@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_high_to_yuv444_simd<12>

; 1281 : static void __forceinline convert_yuv444_high_to_yuv444_simd(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec e0 00 00
	00		 sub	 esp, 224		; 000000e0H
  0001c	57		 push	 edi
  0001d	8d bd 20 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-224]
  00023	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1282 :     static_assert(8 < in_bit_depth && in_bit_depth <= 16, "in_bit_depth must be 9-16.");
; 1283 :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 1284 :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 1285 :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 1286 :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 1287 :     const int src_y_pitch = src_y_pitch_byte >> 1;

  0007c	8b 53 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  0007f	d1 fa		 sar	 edx, 1
  00081	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 1288 :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00084	8b 43 2c	 mov	 eax, DWORD PTR _thread_n$[ebx]
  00087	50		 push	 eax
  00088	8b 4b 28	 mov	 ecx, DWORD PTR _thread_id$[ebx]
  0008b	51		 push	 ecx
  0008c	8b 53 20	 mov	 edx, DWORD PTR _height$[ebx]
  0008f	2b 55 ec	 sub	 edx, DWORD PTR _crop_bottom$[ebp]
  00092	52		 push	 edx
  00093	8b 45 f4	 mov	 eax, DWORD PTR _crop_up$[ebp]
  00096	50		 push	 eax
  00097	8d 8d 20 ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  0009d	51		 push	 ecx
  0009e	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  000a3	83 c4 14	 add	 esp, 20			; 00000014H
  000a6	8b 10		 mov	 edx, DWORD PTR [eax]
  000a8	89 55 c8	 mov	 DWORD PTR $T17[ebp], edx
  000ab	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ae	89 4d cc	 mov	 DWORD PTR $T17[ebp+4], ecx
  000b1	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000b4	89 55 d0	 mov	 DWORD PTR $T17[ebp+8], edx
  000b7	8b 45 c8	 mov	 eax, DWORD PTR $T17[ebp]
  000ba	89 45 d8	 mov	 DWORD PTR _y_range$[ebp], eax
  000bd	8b 4d cc	 mov	 ecx, DWORD PTR $T17[ebp+4]
  000c0	89 4d dc	 mov	 DWORD PTR _y_range$[ebp+4], ecx
  000c3	8b 55 d0	 mov	 edx, DWORD PTR $T17[ebp+8]
  000c6	89 55 e0	 mov	 DWORD PTR _y_range$[ebp+8], edx

; 1289 :     for (int i = 0; i < 3; i++) {

  000c9	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _i$16[ebp], 0
  000d0	eb 09		 jmp	 SHORT $LN4@convert_yu
$LN2@convert_yu:
  000d2	8b 45 c4	 mov	 eax, DWORD PTR _i$16[ebp]
  000d5	83 c0 01	 add	 eax, 1
  000d8	89 45 c4	 mov	 DWORD PTR _i$16[ebp], eax
$LN4@convert_yu:
  000db	83 7d c4 03	 cmp	 DWORD PTR _i$16[ebp], 3
  000df	0f 8d 4d 01 00
	00		 jge	 $LN1@convert_yu

; 1290 :         uint16_t *srcYLine = (uint16_t *)src[i] + src_y_pitch * y_range.start_src + crop_left;

  000e5	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  000e8	0f af 4d d8	 imul	 ecx, DWORD PTR _y_range$[ebp]
  000ec	8b 55 c4	 mov	 edx, DWORD PTR _i$16[ebp]
  000ef	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  000f2	8b 14 90	 mov	 edx, DWORD PTR [eax+edx*4]
  000f5	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  000f8	8b 4d f8	 mov	 ecx, DWORD PTR _crop_left$[ebp]
  000fb	8d 14 48	 lea	 edx, DWORD PTR [eax+ecx*2]
  000fe	89 55 c0	 mov	 DWORD PTR _srcYLine$15[ebp], edx

; 1291 :         uint8_t *dstLine = (uint8_t *)dst[i] + dst_y_pitch_byte * y_range.start_dst;

  00101	8b 43 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  00104	0f af 45 dc	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  00108	8b 4d c4	 mov	 ecx, DWORD PTR _i$16[ebp]
  0010b	8b 53 08	 mov	 edx, DWORD PTR _dst$[ebx]
  0010e	03 04 8a	 add	 eax, DWORD PTR [edx+ecx*4]
  00111	89 45 bc	 mov	 DWORD PTR _dstLine$14[ebp], eax

; 1292 :         const int y_width = width - crop_right - crop_left;

  00114	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  00117	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  0011a	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  0011d	89 45 b8	 mov	 DWORD PTR _y_width$13[ebp], eax

; 1293 :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch_byte) {

  00120	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _y$12[ebp], 0
  00127	eb 1e		 jmp	 SHORT $LN7@convert_yu
$LN5@convert_yu:
  00129	8b 4d b4	 mov	 ecx, DWORD PTR _y$12[ebp]
  0012c	83 c1 01	 add	 ecx, 1
  0012f	89 4d b4	 mov	 DWORD PTR _y$12[ebp], ecx
  00132	8b 55 e8	 mov	 edx, DWORD PTR _src_y_pitch$[ebp]
  00135	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$15[ebp]
  00138	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  0013b	89 4d c0	 mov	 DWORD PTR _srcYLine$15[ebp], ecx
  0013e	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$14[ebp]
  00141	03 53 1c	 add	 edx, DWORD PTR _dst_y_pitch_byte$[ebx]
  00144	89 55 bc	 mov	 DWORD PTR _dstLine$14[ebp], edx
$LN7@convert_yu:
  00147	8b 45 b4	 mov	 eax, DWORD PTR _y$12[ebp]
  0014a	3b 45 e0	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  0014d	0f 8d da 00 00
	00		 jge	 $LN6@convert_yu

; 1294 :             uint16_t *src_ptr = srcYLine;

  00153	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$15[ebp]
  00156	89 4d b0	 mov	 DWORD PTR _src_ptr$11[ebp], ecx

; 1295 :             uint8_t *dst_ptr = dstLine;

  00159	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$14[ebp]
  0015c	89 55 ac	 mov	 DWORD PTR _dst_ptr$10[ebp], edx

; 1296 :             for (int x = 0; x < y_width; x += 16, dst_ptr += 16, src_ptr += 16) {

  0015f	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR _x$9[ebp], 0
  00166	eb 1b		 jmp	 SHORT $LN10@convert_yu
$LN8@convert_yu:
  00168	8b 45 a8	 mov	 eax, DWORD PTR _x$9[ebp]
  0016b	83 c0 10	 add	 eax, 16			; 00000010H
  0016e	89 45 a8	 mov	 DWORD PTR _x$9[ebp], eax
  00171	8b 4d ac	 mov	 ecx, DWORD PTR _dst_ptr$10[ebp]
  00174	83 c1 10	 add	 ecx, 16			; 00000010H
  00177	89 4d ac	 mov	 DWORD PTR _dst_ptr$10[ebp], ecx
  0017a	8b 55 b0	 mov	 edx, DWORD PTR _src_ptr$11[ebp]
  0017d	83 c2 20	 add	 edx, 32			; 00000020H
  00180	89 55 b0	 mov	 DWORD PTR _src_ptr$11[ebp], edx
$LN10@convert_yu:
  00183	8b 45 a8	 mov	 eax, DWORD PTR _x$9[ebp]
  00186	3b 45 b8	 cmp	 eax, DWORD PTR _y_width$13[ebp]
  00189	0f 8d 99 00 00
	00		 jge	 $LN9@convert_yu

; 1297 :                 __m128i x0 = _mm_loadu_si128((const __m128i *)(src_ptr + 0));

  0018f	8b 4d b0	 mov	 ecx, DWORD PTR _src_ptr$11[ebp]
  00192	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00195	0f 29 45 80	 movaps	 XMMWORD PTR $T7[ebp], xmm0
  00199	0f 28 45 80	 movaps	 xmm0, XMMWORD PTR $T7[ebp]
  0019d	0f 29 45 90	 movaps	 XMMWORD PTR _x0$8[ebp], xmm0

; 1298 :                 __m128i x1 = _mm_loadu_si128((const __m128i *)(src_ptr + 8));

  001a1	8b 55 b0	 mov	 edx, DWORD PTR _src_ptr$11[ebp]
  001a4	83 c2 10	 add	 edx, 16			; 00000010H
  001a7	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  001aa	0f 29 85 60 ff
	ff ff		 movaps	 XMMWORD PTR $T5[ebp], xmm0
  001b1	0f 28 85 60 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T5[ebp]
  001b8	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR _x1$6[ebp], xmm0

; 1299 :                 x0 = _mm_srli_epi16(x0, in_bit_depth - 8);

  001bf	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR _x0$8[ebp]
  001c3	66 0f 71 d0 04	 psrlw	 xmm0, 4
  001c8	0f 29 85 50 ff
	ff ff		 movaps	 XMMWORD PTR $T4[ebp], xmm0
  001cf	0f 28 85 50 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T4[ebp]
  001d6	0f 29 45 90	 movaps	 XMMWORD PTR _x0$8[ebp], xmm0

; 1300 :                 x1 = _mm_srli_epi16(x1, in_bit_depth - 8);

  001da	0f 28 85 70 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$6[ebp]
  001e1	66 0f 71 d0 04	 psrlw	 xmm0, 4
  001e6	0f 29 85 40 ff
	ff ff		 movaps	 XMMWORD PTR $T3[ebp], xmm0
  001ed	0f 28 85 40 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T3[ebp]
  001f4	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR _x1$6[ebp], xmm0

; 1301 :                 x0 = _mm_packus_epi16(x0, x1);

  001fb	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR _x0$8[ebp]
  001ff	66 0f 67 85 70
	ff ff ff	 packuswb xmm0, XMMWORD PTR _x1$6[ebp]
  00207	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR $T2[ebp], xmm0
  0020e	0f 28 85 30 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T2[ebp]
  00215	0f 29 45 90	 movaps	 XMMWORD PTR _x0$8[ebp], xmm0

; 1302 :                 _mm_storeu_si128((__m128i *)dst_ptr, x0);

  00219	0f 10 45 90	 movups	 xmm0, XMMWORD PTR _x0$8[ebp]
  0021d	8b 45 ac	 mov	 eax, DWORD PTR _dst_ptr$10[ebp]
  00220	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 1303 :             }

  00223	e9 40 ff ff ff	 jmp	 $LN8@convert_yu
$LN9@convert_yu:

; 1304 :         }

  00228	e9 fc fe ff ff	 jmp	 $LN5@convert_yu
$LN6@convert_yu:

; 1305 :     }

  0022d	e9 a0 fe ff ff	 jmp	 $LN2@convert_yu
$LN1@convert_yu:

; 1306 : }

  00232	52		 push	 edx
  00233	8b cd		 mov	 ecx, ebp
  00235	50		 push	 eax
  00236	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN14@convert_yu
  0023c	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00241	58		 pop	 eax
  00242	5a		 pop	 edx
  00243	5f		 pop	 edi
  00244	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00247	33 cd		 xor	 ecx, ebp
  00249	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0024e	8b e5		 mov	 esp, ebp
  00250	5d		 pop	 ebp
  00251	8b e3		 mov	 esp, ebx
  00253	5b		 pop	 ebx
  00254	c3		 ret	 0
  00255	0f 1f 00	 npad	 3
$LN14@convert_yu:
  00258	01 00 00 00	 DD	 1
  0025c	00 00 00 00	 DD	 $LN13@convert_yu
$LN13@convert_yu:
  00260	d8 ff ff ff	 DD	 -40			; ffffffd8H
  00264	0c 00 00 00	 DD	 12			; 0000000cH
  00268	00 00 00 00	 DD	 $LN12@convert_yu
$LN12@convert_yu:
  0026c	79		 DB	 121			; 00000079H
  0026d	5f		 DB	 95			; 0000005fH
  0026e	72		 DB	 114			; 00000072H
  0026f	61		 DB	 97			; 00000061H
  00270	6e		 DB	 110			; 0000006eH
  00271	67		 DB	 103			; 00000067H
  00272	65		 DB	 101			; 00000065H
  00273	00		 DB	 0
??$convert_yuv444_high_to_yuv444_simd@$0M@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_high_to_yuv444_simd<12>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_sse2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuv444_12_to_yuv444_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_12_to_yuv444_sse2

; 189  : void convert_yuv444_12_to_yuv444_sse2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 190  :     convert_yuv444_high_to_yuv444_simd<12>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yuv444_high_to_yuv444_simd@$0M@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_high_to_yuv444_simd<12>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 191  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yuv444_12_to_yuv444_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_12_to_yuv444_sse2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -224						; size = 12
$T2 = -208						; size = 16
$T3 = -192						; size = 16
$T4 = -176						; size = 16
$T5 = -160						; size = 16
_x1$6 = -144						; size = 16
$T7 = -128						; size = 16
_x0$8 = -112						; size = 16
_x$9 = -88						; size = 4
_dst_ptr$10 = -84					; size = 4
_src_ptr$11 = -80					; size = 4
_y$12 = -76						; size = 4
_y_width$13 = -72					; size = 4
_dstLine$14 = -68					; size = 4
_srcYLine$15 = -64					; size = 4
_i$16 = -60						; size = 4
$T17 = -56						; size = 12
_y_range$ = -40						; size = 12
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yuv444_high_to_yuv444_simd@$0O@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_high_to_yuv444_simd<14>

; 1281 : static void __forceinline convert_yuv444_high_to_yuv444_simd(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec e0 00 00
	00		 sub	 esp, 224		; 000000e0H
  0001c	57		 push	 edi
  0001d	8d bd 20 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-224]
  00023	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1282 :     static_assert(8 < in_bit_depth && in_bit_depth <= 16, "in_bit_depth must be 9-16.");
; 1283 :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 1284 :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 1285 :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 1286 :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 1287 :     const int src_y_pitch = src_y_pitch_byte >> 1;

  0007c	8b 53 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  0007f	d1 fa		 sar	 edx, 1
  00081	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 1288 :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00084	8b 43 2c	 mov	 eax, DWORD PTR _thread_n$[ebx]
  00087	50		 push	 eax
  00088	8b 4b 28	 mov	 ecx, DWORD PTR _thread_id$[ebx]
  0008b	51		 push	 ecx
  0008c	8b 53 20	 mov	 edx, DWORD PTR _height$[ebx]
  0008f	2b 55 ec	 sub	 edx, DWORD PTR _crop_bottom$[ebp]
  00092	52		 push	 edx
  00093	8b 45 f4	 mov	 eax, DWORD PTR _crop_up$[ebp]
  00096	50		 push	 eax
  00097	8d 8d 20 ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  0009d	51		 push	 ecx
  0009e	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  000a3	83 c4 14	 add	 esp, 20			; 00000014H
  000a6	8b 10		 mov	 edx, DWORD PTR [eax]
  000a8	89 55 c8	 mov	 DWORD PTR $T17[ebp], edx
  000ab	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ae	89 4d cc	 mov	 DWORD PTR $T17[ebp+4], ecx
  000b1	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000b4	89 55 d0	 mov	 DWORD PTR $T17[ebp+8], edx
  000b7	8b 45 c8	 mov	 eax, DWORD PTR $T17[ebp]
  000ba	89 45 d8	 mov	 DWORD PTR _y_range$[ebp], eax
  000bd	8b 4d cc	 mov	 ecx, DWORD PTR $T17[ebp+4]
  000c0	89 4d dc	 mov	 DWORD PTR _y_range$[ebp+4], ecx
  000c3	8b 55 d0	 mov	 edx, DWORD PTR $T17[ebp+8]
  000c6	89 55 e0	 mov	 DWORD PTR _y_range$[ebp+8], edx

; 1289 :     for (int i = 0; i < 3; i++) {

  000c9	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _i$16[ebp], 0
  000d0	eb 09		 jmp	 SHORT $LN4@convert_yu
$LN2@convert_yu:
  000d2	8b 45 c4	 mov	 eax, DWORD PTR _i$16[ebp]
  000d5	83 c0 01	 add	 eax, 1
  000d8	89 45 c4	 mov	 DWORD PTR _i$16[ebp], eax
$LN4@convert_yu:
  000db	83 7d c4 03	 cmp	 DWORD PTR _i$16[ebp], 3
  000df	0f 8d 4d 01 00
	00		 jge	 $LN1@convert_yu

; 1290 :         uint16_t *srcYLine = (uint16_t *)src[i] + src_y_pitch * y_range.start_src + crop_left;

  000e5	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  000e8	0f af 4d d8	 imul	 ecx, DWORD PTR _y_range$[ebp]
  000ec	8b 55 c4	 mov	 edx, DWORD PTR _i$16[ebp]
  000ef	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  000f2	8b 14 90	 mov	 edx, DWORD PTR [eax+edx*4]
  000f5	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  000f8	8b 4d f8	 mov	 ecx, DWORD PTR _crop_left$[ebp]
  000fb	8d 14 48	 lea	 edx, DWORD PTR [eax+ecx*2]
  000fe	89 55 c0	 mov	 DWORD PTR _srcYLine$15[ebp], edx

; 1291 :         uint8_t *dstLine = (uint8_t *)dst[i] + dst_y_pitch_byte * y_range.start_dst;

  00101	8b 43 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  00104	0f af 45 dc	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  00108	8b 4d c4	 mov	 ecx, DWORD PTR _i$16[ebp]
  0010b	8b 53 08	 mov	 edx, DWORD PTR _dst$[ebx]
  0010e	03 04 8a	 add	 eax, DWORD PTR [edx+ecx*4]
  00111	89 45 bc	 mov	 DWORD PTR _dstLine$14[ebp], eax

; 1292 :         const int y_width = width - crop_right - crop_left;

  00114	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  00117	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  0011a	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  0011d	89 45 b8	 mov	 DWORD PTR _y_width$13[ebp], eax

; 1293 :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch_byte) {

  00120	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _y$12[ebp], 0
  00127	eb 1e		 jmp	 SHORT $LN7@convert_yu
$LN5@convert_yu:
  00129	8b 4d b4	 mov	 ecx, DWORD PTR _y$12[ebp]
  0012c	83 c1 01	 add	 ecx, 1
  0012f	89 4d b4	 mov	 DWORD PTR _y$12[ebp], ecx
  00132	8b 55 e8	 mov	 edx, DWORD PTR _src_y_pitch$[ebp]
  00135	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$15[ebp]
  00138	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  0013b	89 4d c0	 mov	 DWORD PTR _srcYLine$15[ebp], ecx
  0013e	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$14[ebp]
  00141	03 53 1c	 add	 edx, DWORD PTR _dst_y_pitch_byte$[ebx]
  00144	89 55 bc	 mov	 DWORD PTR _dstLine$14[ebp], edx
$LN7@convert_yu:
  00147	8b 45 b4	 mov	 eax, DWORD PTR _y$12[ebp]
  0014a	3b 45 e0	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  0014d	0f 8d da 00 00
	00		 jge	 $LN6@convert_yu

; 1294 :             uint16_t *src_ptr = srcYLine;

  00153	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$15[ebp]
  00156	89 4d b0	 mov	 DWORD PTR _src_ptr$11[ebp], ecx

; 1295 :             uint8_t *dst_ptr = dstLine;

  00159	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$14[ebp]
  0015c	89 55 ac	 mov	 DWORD PTR _dst_ptr$10[ebp], edx

; 1296 :             for (int x = 0; x < y_width; x += 16, dst_ptr += 16, src_ptr += 16) {

  0015f	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR _x$9[ebp], 0
  00166	eb 1b		 jmp	 SHORT $LN10@convert_yu
$LN8@convert_yu:
  00168	8b 45 a8	 mov	 eax, DWORD PTR _x$9[ebp]
  0016b	83 c0 10	 add	 eax, 16			; 00000010H
  0016e	89 45 a8	 mov	 DWORD PTR _x$9[ebp], eax
  00171	8b 4d ac	 mov	 ecx, DWORD PTR _dst_ptr$10[ebp]
  00174	83 c1 10	 add	 ecx, 16			; 00000010H
  00177	89 4d ac	 mov	 DWORD PTR _dst_ptr$10[ebp], ecx
  0017a	8b 55 b0	 mov	 edx, DWORD PTR _src_ptr$11[ebp]
  0017d	83 c2 20	 add	 edx, 32			; 00000020H
  00180	89 55 b0	 mov	 DWORD PTR _src_ptr$11[ebp], edx
$LN10@convert_yu:
  00183	8b 45 a8	 mov	 eax, DWORD PTR _x$9[ebp]
  00186	3b 45 b8	 cmp	 eax, DWORD PTR _y_width$13[ebp]
  00189	0f 8d 99 00 00
	00		 jge	 $LN9@convert_yu

; 1297 :                 __m128i x0 = _mm_loadu_si128((const __m128i *)(src_ptr + 0));

  0018f	8b 4d b0	 mov	 ecx, DWORD PTR _src_ptr$11[ebp]
  00192	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00195	0f 29 45 80	 movaps	 XMMWORD PTR $T7[ebp], xmm0
  00199	0f 28 45 80	 movaps	 xmm0, XMMWORD PTR $T7[ebp]
  0019d	0f 29 45 90	 movaps	 XMMWORD PTR _x0$8[ebp], xmm0

; 1298 :                 __m128i x1 = _mm_loadu_si128((const __m128i *)(src_ptr + 8));

  001a1	8b 55 b0	 mov	 edx, DWORD PTR _src_ptr$11[ebp]
  001a4	83 c2 10	 add	 edx, 16			; 00000010H
  001a7	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  001aa	0f 29 85 60 ff
	ff ff		 movaps	 XMMWORD PTR $T5[ebp], xmm0
  001b1	0f 28 85 60 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T5[ebp]
  001b8	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR _x1$6[ebp], xmm0

; 1299 :                 x0 = _mm_srli_epi16(x0, in_bit_depth - 8);

  001bf	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR _x0$8[ebp]
  001c3	66 0f 71 d0 06	 psrlw	 xmm0, 6
  001c8	0f 29 85 50 ff
	ff ff		 movaps	 XMMWORD PTR $T4[ebp], xmm0
  001cf	0f 28 85 50 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T4[ebp]
  001d6	0f 29 45 90	 movaps	 XMMWORD PTR _x0$8[ebp], xmm0

; 1300 :                 x1 = _mm_srli_epi16(x1, in_bit_depth - 8);

  001da	0f 28 85 70 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$6[ebp]
  001e1	66 0f 71 d0 06	 psrlw	 xmm0, 6
  001e6	0f 29 85 40 ff
	ff ff		 movaps	 XMMWORD PTR $T3[ebp], xmm0
  001ed	0f 28 85 40 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T3[ebp]
  001f4	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR _x1$6[ebp], xmm0

; 1301 :                 x0 = _mm_packus_epi16(x0, x1);

  001fb	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR _x0$8[ebp]
  001ff	66 0f 67 85 70
	ff ff ff	 packuswb xmm0, XMMWORD PTR _x1$6[ebp]
  00207	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR $T2[ebp], xmm0
  0020e	0f 28 85 30 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T2[ebp]
  00215	0f 29 45 90	 movaps	 XMMWORD PTR _x0$8[ebp], xmm0

; 1302 :                 _mm_storeu_si128((__m128i *)dst_ptr, x0);

  00219	0f 10 45 90	 movups	 xmm0, XMMWORD PTR _x0$8[ebp]
  0021d	8b 45 ac	 mov	 eax, DWORD PTR _dst_ptr$10[ebp]
  00220	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 1303 :             }

  00223	e9 40 ff ff ff	 jmp	 $LN8@convert_yu
$LN9@convert_yu:

; 1304 :         }

  00228	e9 fc fe ff ff	 jmp	 $LN5@convert_yu
$LN6@convert_yu:

; 1305 :     }

  0022d	e9 a0 fe ff ff	 jmp	 $LN2@convert_yu
$LN1@convert_yu:

; 1306 : }

  00232	52		 push	 edx
  00233	8b cd		 mov	 ecx, ebp
  00235	50		 push	 eax
  00236	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN14@convert_yu
  0023c	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00241	58		 pop	 eax
  00242	5a		 pop	 edx
  00243	5f		 pop	 edi
  00244	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00247	33 cd		 xor	 ecx, ebp
  00249	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0024e	8b e5		 mov	 esp, ebp
  00250	5d		 pop	 ebp
  00251	8b e3		 mov	 esp, ebx
  00253	5b		 pop	 ebx
  00254	c3		 ret	 0
  00255	0f 1f 00	 npad	 3
$LN14@convert_yu:
  00258	01 00 00 00	 DD	 1
  0025c	00 00 00 00	 DD	 $LN13@convert_yu
$LN13@convert_yu:
  00260	d8 ff ff ff	 DD	 -40			; ffffffd8H
  00264	0c 00 00 00	 DD	 12			; 0000000cH
  00268	00 00 00 00	 DD	 $LN12@convert_yu
$LN12@convert_yu:
  0026c	79		 DB	 121			; 00000079H
  0026d	5f		 DB	 95			; 0000005fH
  0026e	72		 DB	 114			; 00000072H
  0026f	61		 DB	 97			; 00000061H
  00270	6e		 DB	 110			; 0000006eH
  00271	67		 DB	 103			; 00000067H
  00272	65		 DB	 101			; 00000065H
  00273	00		 DB	 0
??$convert_yuv444_high_to_yuv444_simd@$0O@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_high_to_yuv444_simd<14>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_sse2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuv444_14_to_yuv444_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_14_to_yuv444_sse2

; 185  : void convert_yuv444_14_to_yuv444_sse2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 186  :     convert_yuv444_high_to_yuv444_simd<14>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yuv444_high_to_yuv444_simd@$0O@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_high_to_yuv444_simd<14>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 187  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yuv444_14_to_yuv444_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_14_to_yuv444_sse2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -224						; size = 12
$T2 = -208						; size = 16
$T3 = -192						; size = 16
$T4 = -176						; size = 16
$T5 = -160						; size = 16
_x1$6 = -144						; size = 16
$T7 = -128						; size = 16
_x0$8 = -112						; size = 16
_x$9 = -88						; size = 4
_dst_ptr$10 = -84					; size = 4
_src_ptr$11 = -80					; size = 4
_y$12 = -76						; size = 4
_y_width$13 = -72					; size = 4
_dstLine$14 = -68					; size = 4
_srcYLine$15 = -64					; size = 4
_i$16 = -60						; size = 4
$T17 = -56						; size = 12
_y_range$ = -40						; size = 12
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yuv444_high_to_yuv444_simd@$0BA@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_high_to_yuv444_simd<16>

; 1281 : static void __forceinline convert_yuv444_high_to_yuv444_simd(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec e0 00 00
	00		 sub	 esp, 224		; 000000e0H
  0001c	57		 push	 edi
  0001d	8d bd 20 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-224]
  00023	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1282 :     static_assert(8 < in_bit_depth && in_bit_depth <= 16, "in_bit_depth must be 9-16.");
; 1283 :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 1284 :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 1285 :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 1286 :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 1287 :     const int src_y_pitch = src_y_pitch_byte >> 1;

  0007c	8b 53 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  0007f	d1 fa		 sar	 edx, 1
  00081	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 1288 :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00084	8b 43 2c	 mov	 eax, DWORD PTR _thread_n$[ebx]
  00087	50		 push	 eax
  00088	8b 4b 28	 mov	 ecx, DWORD PTR _thread_id$[ebx]
  0008b	51		 push	 ecx
  0008c	8b 53 20	 mov	 edx, DWORD PTR _height$[ebx]
  0008f	2b 55 ec	 sub	 edx, DWORD PTR _crop_bottom$[ebp]
  00092	52		 push	 edx
  00093	8b 45 f4	 mov	 eax, DWORD PTR _crop_up$[ebp]
  00096	50		 push	 eax
  00097	8d 8d 20 ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  0009d	51		 push	 ecx
  0009e	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  000a3	83 c4 14	 add	 esp, 20			; 00000014H
  000a6	8b 10		 mov	 edx, DWORD PTR [eax]
  000a8	89 55 c8	 mov	 DWORD PTR $T17[ebp], edx
  000ab	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ae	89 4d cc	 mov	 DWORD PTR $T17[ebp+4], ecx
  000b1	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000b4	89 55 d0	 mov	 DWORD PTR $T17[ebp+8], edx
  000b7	8b 45 c8	 mov	 eax, DWORD PTR $T17[ebp]
  000ba	89 45 d8	 mov	 DWORD PTR _y_range$[ebp], eax
  000bd	8b 4d cc	 mov	 ecx, DWORD PTR $T17[ebp+4]
  000c0	89 4d dc	 mov	 DWORD PTR _y_range$[ebp+4], ecx
  000c3	8b 55 d0	 mov	 edx, DWORD PTR $T17[ebp+8]
  000c6	89 55 e0	 mov	 DWORD PTR _y_range$[ebp+8], edx

; 1289 :     for (int i = 0; i < 3; i++) {

  000c9	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _i$16[ebp], 0
  000d0	eb 09		 jmp	 SHORT $LN4@convert_yu
$LN2@convert_yu:
  000d2	8b 45 c4	 mov	 eax, DWORD PTR _i$16[ebp]
  000d5	83 c0 01	 add	 eax, 1
  000d8	89 45 c4	 mov	 DWORD PTR _i$16[ebp], eax
$LN4@convert_yu:
  000db	83 7d c4 03	 cmp	 DWORD PTR _i$16[ebp], 3
  000df	0f 8d 4d 01 00
	00		 jge	 $LN1@convert_yu

; 1290 :         uint16_t *srcYLine = (uint16_t *)src[i] + src_y_pitch * y_range.start_src + crop_left;

  000e5	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  000e8	0f af 4d d8	 imul	 ecx, DWORD PTR _y_range$[ebp]
  000ec	8b 55 c4	 mov	 edx, DWORD PTR _i$16[ebp]
  000ef	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  000f2	8b 14 90	 mov	 edx, DWORD PTR [eax+edx*4]
  000f5	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  000f8	8b 4d f8	 mov	 ecx, DWORD PTR _crop_left$[ebp]
  000fb	8d 14 48	 lea	 edx, DWORD PTR [eax+ecx*2]
  000fe	89 55 c0	 mov	 DWORD PTR _srcYLine$15[ebp], edx

; 1291 :         uint8_t *dstLine = (uint8_t *)dst[i] + dst_y_pitch_byte * y_range.start_dst;

  00101	8b 43 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  00104	0f af 45 dc	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  00108	8b 4d c4	 mov	 ecx, DWORD PTR _i$16[ebp]
  0010b	8b 53 08	 mov	 edx, DWORD PTR _dst$[ebx]
  0010e	03 04 8a	 add	 eax, DWORD PTR [edx+ecx*4]
  00111	89 45 bc	 mov	 DWORD PTR _dstLine$14[ebp], eax

; 1292 :         const int y_width = width - crop_right - crop_left;

  00114	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  00117	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  0011a	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  0011d	89 45 b8	 mov	 DWORD PTR _y_width$13[ebp], eax

; 1293 :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch_byte) {

  00120	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _y$12[ebp], 0
  00127	eb 1e		 jmp	 SHORT $LN7@convert_yu
$LN5@convert_yu:
  00129	8b 4d b4	 mov	 ecx, DWORD PTR _y$12[ebp]
  0012c	83 c1 01	 add	 ecx, 1
  0012f	89 4d b4	 mov	 DWORD PTR _y$12[ebp], ecx
  00132	8b 55 e8	 mov	 edx, DWORD PTR _src_y_pitch$[ebp]
  00135	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$15[ebp]
  00138	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  0013b	89 4d c0	 mov	 DWORD PTR _srcYLine$15[ebp], ecx
  0013e	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$14[ebp]
  00141	03 53 1c	 add	 edx, DWORD PTR _dst_y_pitch_byte$[ebx]
  00144	89 55 bc	 mov	 DWORD PTR _dstLine$14[ebp], edx
$LN7@convert_yu:
  00147	8b 45 b4	 mov	 eax, DWORD PTR _y$12[ebp]
  0014a	3b 45 e0	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  0014d	0f 8d da 00 00
	00		 jge	 $LN6@convert_yu

; 1294 :             uint16_t *src_ptr = srcYLine;

  00153	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$15[ebp]
  00156	89 4d b0	 mov	 DWORD PTR _src_ptr$11[ebp], ecx

; 1295 :             uint8_t *dst_ptr = dstLine;

  00159	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$14[ebp]
  0015c	89 55 ac	 mov	 DWORD PTR _dst_ptr$10[ebp], edx

; 1296 :             for (int x = 0; x < y_width; x += 16, dst_ptr += 16, src_ptr += 16) {

  0015f	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR _x$9[ebp], 0
  00166	eb 1b		 jmp	 SHORT $LN10@convert_yu
$LN8@convert_yu:
  00168	8b 45 a8	 mov	 eax, DWORD PTR _x$9[ebp]
  0016b	83 c0 10	 add	 eax, 16			; 00000010H
  0016e	89 45 a8	 mov	 DWORD PTR _x$9[ebp], eax
  00171	8b 4d ac	 mov	 ecx, DWORD PTR _dst_ptr$10[ebp]
  00174	83 c1 10	 add	 ecx, 16			; 00000010H
  00177	89 4d ac	 mov	 DWORD PTR _dst_ptr$10[ebp], ecx
  0017a	8b 55 b0	 mov	 edx, DWORD PTR _src_ptr$11[ebp]
  0017d	83 c2 20	 add	 edx, 32			; 00000020H
  00180	89 55 b0	 mov	 DWORD PTR _src_ptr$11[ebp], edx
$LN10@convert_yu:
  00183	8b 45 a8	 mov	 eax, DWORD PTR _x$9[ebp]
  00186	3b 45 b8	 cmp	 eax, DWORD PTR _y_width$13[ebp]
  00189	0f 8d 99 00 00
	00		 jge	 $LN9@convert_yu

; 1297 :                 __m128i x0 = _mm_loadu_si128((const __m128i *)(src_ptr + 0));

  0018f	8b 4d b0	 mov	 ecx, DWORD PTR _src_ptr$11[ebp]
  00192	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00195	0f 29 45 80	 movaps	 XMMWORD PTR $T7[ebp], xmm0
  00199	0f 28 45 80	 movaps	 xmm0, XMMWORD PTR $T7[ebp]
  0019d	0f 29 45 90	 movaps	 XMMWORD PTR _x0$8[ebp], xmm0

; 1298 :                 __m128i x1 = _mm_loadu_si128((const __m128i *)(src_ptr + 8));

  001a1	8b 55 b0	 mov	 edx, DWORD PTR _src_ptr$11[ebp]
  001a4	83 c2 10	 add	 edx, 16			; 00000010H
  001a7	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  001aa	0f 29 85 60 ff
	ff ff		 movaps	 XMMWORD PTR $T5[ebp], xmm0
  001b1	0f 28 85 60 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T5[ebp]
  001b8	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR _x1$6[ebp], xmm0

; 1299 :                 x0 = _mm_srli_epi16(x0, in_bit_depth - 8);

  001bf	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR _x0$8[ebp]
  001c3	66 0f 71 d0 08	 psrlw	 xmm0, 8
  001c8	0f 29 85 50 ff
	ff ff		 movaps	 XMMWORD PTR $T4[ebp], xmm0
  001cf	0f 28 85 50 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T4[ebp]
  001d6	0f 29 45 90	 movaps	 XMMWORD PTR _x0$8[ebp], xmm0

; 1300 :                 x1 = _mm_srli_epi16(x1, in_bit_depth - 8);

  001da	0f 28 85 70 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$6[ebp]
  001e1	66 0f 71 d0 08	 psrlw	 xmm0, 8
  001e6	0f 29 85 40 ff
	ff ff		 movaps	 XMMWORD PTR $T3[ebp], xmm0
  001ed	0f 28 85 40 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T3[ebp]
  001f4	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR _x1$6[ebp], xmm0

; 1301 :                 x0 = _mm_packus_epi16(x0, x1);

  001fb	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR _x0$8[ebp]
  001ff	66 0f 67 85 70
	ff ff ff	 packuswb xmm0, XMMWORD PTR _x1$6[ebp]
  00207	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR $T2[ebp], xmm0
  0020e	0f 28 85 30 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T2[ebp]
  00215	0f 29 45 90	 movaps	 XMMWORD PTR _x0$8[ebp], xmm0

; 1302 :                 _mm_storeu_si128((__m128i *)dst_ptr, x0);

  00219	0f 10 45 90	 movups	 xmm0, XMMWORD PTR _x0$8[ebp]
  0021d	8b 45 ac	 mov	 eax, DWORD PTR _dst_ptr$10[ebp]
  00220	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 1303 :             }

  00223	e9 40 ff ff ff	 jmp	 $LN8@convert_yu
$LN9@convert_yu:

; 1304 :         }

  00228	e9 fc fe ff ff	 jmp	 $LN5@convert_yu
$LN6@convert_yu:

; 1305 :     }

  0022d	e9 a0 fe ff ff	 jmp	 $LN2@convert_yu
$LN1@convert_yu:

; 1306 : }

  00232	52		 push	 edx
  00233	8b cd		 mov	 ecx, ebp
  00235	50		 push	 eax
  00236	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN14@convert_yu
  0023c	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00241	58		 pop	 eax
  00242	5a		 pop	 edx
  00243	5f		 pop	 edi
  00244	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00247	33 cd		 xor	 ecx, ebp
  00249	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0024e	8b e5		 mov	 esp, ebp
  00250	5d		 pop	 ebp
  00251	8b e3		 mov	 esp, ebx
  00253	5b		 pop	 ebx
  00254	c3		 ret	 0
  00255	0f 1f 00	 npad	 3
$LN14@convert_yu:
  00258	01 00 00 00	 DD	 1
  0025c	00 00 00 00	 DD	 $LN13@convert_yu
$LN13@convert_yu:
  00260	d8 ff ff ff	 DD	 -40			; ffffffd8H
  00264	0c 00 00 00	 DD	 12			; 0000000cH
  00268	00 00 00 00	 DD	 $LN12@convert_yu
$LN12@convert_yu:
  0026c	79		 DB	 121			; 00000079H
  0026d	5f		 DB	 95			; 0000005fH
  0026e	72		 DB	 114			; 00000072H
  0026f	61		 DB	 97			; 00000061H
  00270	6e		 DB	 110			; 0000006eH
  00271	67		 DB	 103			; 00000067H
  00272	65		 DB	 101			; 00000065H
  00273	00		 DB	 0
??$convert_yuv444_high_to_yuv444_simd@$0BA@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_high_to_yuv444_simd<16>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_sse2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuv444_16_to_yuv444_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_16_to_yuv444_sse2

; 181  : void convert_yuv444_16_to_yuv444_sse2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 182  :     convert_yuv444_high_to_yuv444_simd<16>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yuv444_high_to_yuv444_simd@$0BA@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_high_to_yuv444_simd<16>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 183  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yuv444_16_to_yuv444_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_16_to_yuv444_sse2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_sse2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuv444_to_yuv444_16_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_to_yuv444_16_sse2

; 177  : void convert_yuv444_to_yuv444_16_sse2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 178  :     convert_yuv444_to_yuv444_16_simd(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ?convert_yuv444_to_yuv444_16_simd@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_to_yuv444_16_simd
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 179  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yuv444_to_yuv444_16_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_to_yuv444_16_sse2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -160						; size = 12
$T2 = -144						; size = 16
$T3 = -128						; size = 16
_x0$4 = -112						; size = 16
_x$5 = -92						; size = 4
_dst_ptr$6 = -88					; size = 4
_src_ptr$7 = -84					; size = 4
_y$8 = -80						; size = 4
_y_width$9 = -76					; size = 4
_dstLine$10 = -72					; size = 4
_srcYLine$11 = -68					; size = 4
_i$12 = -64						; size = 4
$T13 = -60						; size = 12
_y_range$ = -44						; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yuv444_high_to_yuv444_16_simd@$08@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_high_to_yuv444_16_simd<9>

; 1251 : static void __forceinline convert_yuv444_high_to_yuv444_16_simd(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec a0 00 00
	00		 sub	 esp, 160		; 000000a0H
  0001c	57		 push	 edi
  0001d	8d bd 60 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-160]
  00023	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1252 :     static_assert(8 < in_bit_depth && in_bit_depth <= 16, "in_bit_depth must be 9-16.");
; 1253 :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 1254 :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 1255 :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 1256 :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 1257 :     const int src_y_pitch = src_y_pitch_byte >> 1;

  0007c	8b 53 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  0007f	d1 fa		 sar	 edx, 1
  00081	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 1258 :     const int dst_y_pitch = dst_y_pitch_byte >> 1;

  00084	8b 43 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  00087	d1 f8		 sar	 eax, 1
  00089	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 1259 :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  0008c	8b 4b 2c	 mov	 ecx, DWORD PTR _thread_n$[ebx]
  0008f	51		 push	 ecx
  00090	8b 53 28	 mov	 edx, DWORD PTR _thread_id$[ebx]
  00093	52		 push	 edx
  00094	8b 43 20	 mov	 eax, DWORD PTR _height$[ebx]
  00097	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  0009a	50		 push	 eax
  0009b	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  0009e	51		 push	 ecx
  0009f	8d 95 60 ff ff
	ff		 lea	 edx, DWORD PTR $T1[ebp]
  000a5	52		 push	 edx
  000a6	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  000ab	83 c4 14	 add	 esp, 20			; 00000014H
  000ae	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b0	89 4d c4	 mov	 DWORD PTR $T13[ebp], ecx
  000b3	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000b6	89 55 c8	 mov	 DWORD PTR $T13[ebp+4], edx
  000b9	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000bc	89 45 cc	 mov	 DWORD PTR $T13[ebp+8], eax
  000bf	8b 4d c4	 mov	 ecx, DWORD PTR $T13[ebp]
  000c2	89 4d d4	 mov	 DWORD PTR _y_range$[ebp], ecx
  000c5	8b 55 c8	 mov	 edx, DWORD PTR $T13[ebp+4]
  000c8	89 55 d8	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000cb	8b 45 cc	 mov	 eax, DWORD PTR $T13[ebp+8]
  000ce	89 45 dc	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 1260 :     for (int i = 0; i < 3; i++) {

  000d1	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _i$12[ebp], 0
  000d8	eb 09		 jmp	 SHORT $LN4@convert_yu
$LN2@convert_yu:
  000da	8b 4d c0	 mov	 ecx, DWORD PTR _i$12[ebp]
  000dd	83 c1 01	 add	 ecx, 1
  000e0	89 4d c0	 mov	 DWORD PTR _i$12[ebp], ecx
$LN4@convert_yu:
  000e3	83 7d c0 03	 cmp	 DWORD PTR _i$12[ebp], 3
  000e7	0f 8d 0b 01 00
	00		 jge	 $LN1@convert_yu

; 1261 :         uint16_t *srcYLine = (uint16_t *)src[i] + src_y_pitch * y_range.start_src + crop_left;

  000ed	8b 55 e8	 mov	 edx, DWORD PTR _src_y_pitch$[ebp]
  000f0	0f af 55 d4	 imul	 edx, DWORD PTR _y_range$[ebp]
  000f4	8b 45 c0	 mov	 eax, DWORD PTR _i$12[ebp]
  000f7	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  000fa	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  000fd	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00100	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  00103	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  00106	89 45 bc	 mov	 DWORD PTR _srcYLine$11[ebp], eax

; 1262 :         uint16_t *dstLine = (uint16_t *)dst[i] + dst_y_pitch * y_range.start_dst;

  00109	8b 4d e4	 mov	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  0010c	0f af 4d d8	 imul	 ecx, DWORD PTR _y_range$[ebp+4]
  00110	8b 55 c0	 mov	 edx, DWORD PTR _i$12[ebp]
  00113	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  00116	8b 14 90	 mov	 edx, DWORD PTR [eax+edx*4]
  00119	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  0011c	89 45 b8	 mov	 DWORD PTR _dstLine$10[ebp], eax

; 1263 :         const int y_width = width - crop_right - crop_left;

  0011f	8b 4b 10	 mov	 ecx, DWORD PTR _width$[ebx]
  00122	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  00125	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  00128	89 4d b4	 mov	 DWORD PTR _y_width$9[ebp], ecx

; 1264 :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  0012b	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _y$8[ebp], 0
  00132	eb 21		 jmp	 SHORT $LN7@convert_yu
$LN5@convert_yu:
  00134	8b 55 b0	 mov	 edx, DWORD PTR _y$8[ebp]
  00137	83 c2 01	 add	 edx, 1
  0013a	89 55 b0	 mov	 DWORD PTR _y$8[ebp], edx
  0013d	8b 45 e8	 mov	 eax, DWORD PTR _src_y_pitch$[ebp]
  00140	8b 4d bc	 mov	 ecx, DWORD PTR _srcYLine$11[ebp]
  00143	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00146	89 55 bc	 mov	 DWORD PTR _srcYLine$11[ebp], edx
  00149	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  0014c	8b 4d b8	 mov	 ecx, DWORD PTR _dstLine$10[ebp]
  0014f	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00152	89 55 b8	 mov	 DWORD PTR _dstLine$10[ebp], edx
$LN7@convert_yu:
  00155	8b 45 b0	 mov	 eax, DWORD PTR _y$8[ebp]
  00158	3b 45 dc	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  0015b	0f 8d 92 00 00
	00		 jge	 $LN6@convert_yu

; 1265 :             if (in_bit_depth == 16) {

  00161	33 c9		 xor	 ecx, ecx
  00163	74 18		 je	 SHORT $LN11@convert_yu

; 1266 :                 memcpy_sse((uint8_t *)dstLine, (uint8_t *)srcYLine, y_width * sizeof(uint16_t));

  00165	8b 55 b4	 mov	 edx, DWORD PTR _y_width$9[ebp]
  00168	d1 e2		 shl	 edx, 1
  0016a	52		 push	 edx
  0016b	8b 45 bc	 mov	 eax, DWORD PTR _srcYLine$11[ebp]
  0016e	50		 push	 eax
  0016f	8b 4d b8	 mov	 ecx, DWORD PTR _dstLine$10[ebp]
  00172	51		 push	 ecx
  00173	e8 00 00 00 00	 call	 ?memcpy_sse@@YAXPAEPBEH@Z ; memcpy_sse
  00178	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1267 :             } else {

  0017b	eb 71		 jmp	 SHORT $LN12@convert_yu
$LN11@convert_yu:

; 1268 :                 uint16_t *src_ptr = srcYLine;

  0017d	8b 55 bc	 mov	 edx, DWORD PTR _srcYLine$11[ebp]
  00180	89 55 ac	 mov	 DWORD PTR _src_ptr$7[ebp], edx

; 1269 :                 uint16_t *dst_ptr = dstLine;

  00183	8b 45 b8	 mov	 eax, DWORD PTR _dstLine$10[ebp]
  00186	89 45 a8	 mov	 DWORD PTR _dst_ptr$6[ebp], eax

; 1270 :                 for (int x = 0; x < y_width; x += 8, dst_ptr += 8, src_ptr += 8) {

  00189	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _x$5[ebp], 0
  00190	eb 1b		 jmp	 SHORT $LN10@convert_yu
$LN8@convert_yu:
  00192	8b 4d a4	 mov	 ecx, DWORD PTR _x$5[ebp]
  00195	83 c1 08	 add	 ecx, 8
  00198	89 4d a4	 mov	 DWORD PTR _x$5[ebp], ecx
  0019b	8b 55 a8	 mov	 edx, DWORD PTR _dst_ptr$6[ebp]
  0019e	83 c2 10	 add	 edx, 16			; 00000010H
  001a1	89 55 a8	 mov	 DWORD PTR _dst_ptr$6[ebp], edx
  001a4	8b 45 ac	 mov	 eax, DWORD PTR _src_ptr$7[ebp]
  001a7	83 c0 10	 add	 eax, 16			; 00000010H
  001aa	89 45 ac	 mov	 DWORD PTR _src_ptr$7[ebp], eax
$LN10@convert_yu:
  001ad	8b 4d a4	 mov	 ecx, DWORD PTR _x$5[ebp]
  001b0	3b 4d b4	 cmp	 ecx, DWORD PTR _y_width$9[ebp]
  001b3	7d 39		 jge	 SHORT $LN12@convert_yu

; 1271 :                     __m128i x0 = _mm_loadu_si128((const __m128i *)src_ptr);

  001b5	8b 55 ac	 mov	 edx, DWORD PTR _src_ptr$7[ebp]
  001b8	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  001bb	0f 29 45 80	 movaps	 XMMWORD PTR $T3[ebp], xmm0
  001bf	0f 28 45 80	 movaps	 xmm0, XMMWORD PTR $T3[ebp]
  001c3	0f 29 45 90	 movaps	 XMMWORD PTR _x0$4[ebp], xmm0

; 1272 :                     x0 = _mm_slli_epi16(x0, 16 - in_bit_depth);

  001c7	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR _x0$4[ebp]
  001cb	66 0f 71 f0 07	 psllw	 xmm0, 7
  001d0	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR $T2[ebp], xmm0
  001d7	0f 28 85 70 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T2[ebp]
  001de	0f 29 45 90	 movaps	 XMMWORD PTR _x0$4[ebp], xmm0

; 1273 :                     _mm_storeu_si128((__m128i *)dst_ptr, x0);

  001e2	0f 10 45 90	 movups	 xmm0, XMMWORD PTR _x0$4[ebp]
  001e6	8b 45 a8	 mov	 eax, DWORD PTR _dst_ptr$6[ebp]
  001e9	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 1274 :                 }

  001ec	eb a4		 jmp	 SHORT $LN8@convert_yu
$LN12@convert_yu:

; 1275 :             }
; 1276 :         }

  001ee	e9 41 ff ff ff	 jmp	 $LN5@convert_yu
$LN6@convert_yu:

; 1277 :     }

  001f3	e9 e2 fe ff ff	 jmp	 $LN2@convert_yu
$LN1@convert_yu:

; 1278 : }

  001f8	52		 push	 edx
  001f9	8b cd		 mov	 ecx, ebp
  001fb	50		 push	 eax
  001fc	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN16@convert_yu
  00202	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00207	58		 pop	 eax
  00208	5a		 pop	 edx
  00209	5f		 pop	 edi
  0020a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0020d	33 cd		 xor	 ecx, ebp
  0020f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00214	8b e5		 mov	 esp, ebp
  00216	5d		 pop	 ebp
  00217	8b e3		 mov	 esp, ebx
  00219	5b		 pop	 ebx
  0021a	c3		 ret	 0
  0021b	90		 npad	 1
$LN16@convert_yu:
  0021c	01 00 00 00	 DD	 1
  00220	00 00 00 00	 DD	 $LN15@convert_yu
$LN15@convert_yu:
  00224	d4 ff ff ff	 DD	 -44			; ffffffd4H
  00228	0c 00 00 00	 DD	 12			; 0000000cH
  0022c	00 00 00 00	 DD	 $LN14@convert_yu
$LN14@convert_yu:
  00230	79		 DB	 121			; 00000079H
  00231	5f		 DB	 95			; 0000005fH
  00232	72		 DB	 114			; 00000072H
  00233	61		 DB	 97			; 00000061H
  00234	6e		 DB	 110			; 0000006eH
  00235	67		 DB	 103			; 00000067H
  00236	65		 DB	 101			; 00000065H
  00237	00		 DB	 0
??$convert_yuv444_high_to_yuv444_16_simd@$08@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_high_to_yuv444_16_simd<9>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_sse2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuv444_09_to_yuv444_16_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_09_to_yuv444_16_sse2

; 173  : void convert_yuv444_09_to_yuv444_16_sse2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 174  :     convert_yuv444_high_to_yuv444_16_simd<9>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yuv444_high_to_yuv444_16_simd@$08@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_high_to_yuv444_16_simd<9>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 175  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yuv444_09_to_yuv444_16_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_09_to_yuv444_16_sse2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -160						; size = 12
$T2 = -144						; size = 16
$T3 = -128						; size = 16
_x0$4 = -112						; size = 16
_x$5 = -92						; size = 4
_dst_ptr$6 = -88					; size = 4
_src_ptr$7 = -84					; size = 4
_y$8 = -80						; size = 4
_y_width$9 = -76					; size = 4
_dstLine$10 = -72					; size = 4
_srcYLine$11 = -68					; size = 4
_i$12 = -64						; size = 4
$T13 = -60						; size = 12
_y_range$ = -44						; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yuv444_high_to_yuv444_16_simd@$09@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_high_to_yuv444_16_simd<10>

; 1251 : static void __forceinline convert_yuv444_high_to_yuv444_16_simd(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec a0 00 00
	00		 sub	 esp, 160		; 000000a0H
  0001c	57		 push	 edi
  0001d	8d bd 60 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-160]
  00023	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1252 :     static_assert(8 < in_bit_depth && in_bit_depth <= 16, "in_bit_depth must be 9-16.");
; 1253 :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 1254 :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 1255 :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 1256 :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 1257 :     const int src_y_pitch = src_y_pitch_byte >> 1;

  0007c	8b 53 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  0007f	d1 fa		 sar	 edx, 1
  00081	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 1258 :     const int dst_y_pitch = dst_y_pitch_byte >> 1;

  00084	8b 43 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  00087	d1 f8		 sar	 eax, 1
  00089	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 1259 :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  0008c	8b 4b 2c	 mov	 ecx, DWORD PTR _thread_n$[ebx]
  0008f	51		 push	 ecx
  00090	8b 53 28	 mov	 edx, DWORD PTR _thread_id$[ebx]
  00093	52		 push	 edx
  00094	8b 43 20	 mov	 eax, DWORD PTR _height$[ebx]
  00097	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  0009a	50		 push	 eax
  0009b	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  0009e	51		 push	 ecx
  0009f	8d 95 60 ff ff
	ff		 lea	 edx, DWORD PTR $T1[ebp]
  000a5	52		 push	 edx
  000a6	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  000ab	83 c4 14	 add	 esp, 20			; 00000014H
  000ae	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b0	89 4d c4	 mov	 DWORD PTR $T13[ebp], ecx
  000b3	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000b6	89 55 c8	 mov	 DWORD PTR $T13[ebp+4], edx
  000b9	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000bc	89 45 cc	 mov	 DWORD PTR $T13[ebp+8], eax
  000bf	8b 4d c4	 mov	 ecx, DWORD PTR $T13[ebp]
  000c2	89 4d d4	 mov	 DWORD PTR _y_range$[ebp], ecx
  000c5	8b 55 c8	 mov	 edx, DWORD PTR $T13[ebp+4]
  000c8	89 55 d8	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000cb	8b 45 cc	 mov	 eax, DWORD PTR $T13[ebp+8]
  000ce	89 45 dc	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 1260 :     for (int i = 0; i < 3; i++) {

  000d1	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _i$12[ebp], 0
  000d8	eb 09		 jmp	 SHORT $LN4@convert_yu
$LN2@convert_yu:
  000da	8b 4d c0	 mov	 ecx, DWORD PTR _i$12[ebp]
  000dd	83 c1 01	 add	 ecx, 1
  000e0	89 4d c0	 mov	 DWORD PTR _i$12[ebp], ecx
$LN4@convert_yu:
  000e3	83 7d c0 03	 cmp	 DWORD PTR _i$12[ebp], 3
  000e7	0f 8d 0b 01 00
	00		 jge	 $LN1@convert_yu

; 1261 :         uint16_t *srcYLine = (uint16_t *)src[i] + src_y_pitch * y_range.start_src + crop_left;

  000ed	8b 55 e8	 mov	 edx, DWORD PTR _src_y_pitch$[ebp]
  000f0	0f af 55 d4	 imul	 edx, DWORD PTR _y_range$[ebp]
  000f4	8b 45 c0	 mov	 eax, DWORD PTR _i$12[ebp]
  000f7	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  000fa	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  000fd	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00100	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  00103	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  00106	89 45 bc	 mov	 DWORD PTR _srcYLine$11[ebp], eax

; 1262 :         uint16_t *dstLine = (uint16_t *)dst[i] + dst_y_pitch * y_range.start_dst;

  00109	8b 4d e4	 mov	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  0010c	0f af 4d d8	 imul	 ecx, DWORD PTR _y_range$[ebp+4]
  00110	8b 55 c0	 mov	 edx, DWORD PTR _i$12[ebp]
  00113	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  00116	8b 14 90	 mov	 edx, DWORD PTR [eax+edx*4]
  00119	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  0011c	89 45 b8	 mov	 DWORD PTR _dstLine$10[ebp], eax

; 1263 :         const int y_width = width - crop_right - crop_left;

  0011f	8b 4b 10	 mov	 ecx, DWORD PTR _width$[ebx]
  00122	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  00125	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  00128	89 4d b4	 mov	 DWORD PTR _y_width$9[ebp], ecx

; 1264 :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  0012b	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _y$8[ebp], 0
  00132	eb 21		 jmp	 SHORT $LN7@convert_yu
$LN5@convert_yu:
  00134	8b 55 b0	 mov	 edx, DWORD PTR _y$8[ebp]
  00137	83 c2 01	 add	 edx, 1
  0013a	89 55 b0	 mov	 DWORD PTR _y$8[ebp], edx
  0013d	8b 45 e8	 mov	 eax, DWORD PTR _src_y_pitch$[ebp]
  00140	8b 4d bc	 mov	 ecx, DWORD PTR _srcYLine$11[ebp]
  00143	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00146	89 55 bc	 mov	 DWORD PTR _srcYLine$11[ebp], edx
  00149	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  0014c	8b 4d b8	 mov	 ecx, DWORD PTR _dstLine$10[ebp]
  0014f	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00152	89 55 b8	 mov	 DWORD PTR _dstLine$10[ebp], edx
$LN7@convert_yu:
  00155	8b 45 b0	 mov	 eax, DWORD PTR _y$8[ebp]
  00158	3b 45 dc	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  0015b	0f 8d 92 00 00
	00		 jge	 $LN6@convert_yu

; 1265 :             if (in_bit_depth == 16) {

  00161	33 c9		 xor	 ecx, ecx
  00163	74 18		 je	 SHORT $LN11@convert_yu

; 1266 :                 memcpy_sse((uint8_t *)dstLine, (uint8_t *)srcYLine, y_width * sizeof(uint16_t));

  00165	8b 55 b4	 mov	 edx, DWORD PTR _y_width$9[ebp]
  00168	d1 e2		 shl	 edx, 1
  0016a	52		 push	 edx
  0016b	8b 45 bc	 mov	 eax, DWORD PTR _srcYLine$11[ebp]
  0016e	50		 push	 eax
  0016f	8b 4d b8	 mov	 ecx, DWORD PTR _dstLine$10[ebp]
  00172	51		 push	 ecx
  00173	e8 00 00 00 00	 call	 ?memcpy_sse@@YAXPAEPBEH@Z ; memcpy_sse
  00178	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1267 :             } else {

  0017b	eb 71		 jmp	 SHORT $LN12@convert_yu
$LN11@convert_yu:

; 1268 :                 uint16_t *src_ptr = srcYLine;

  0017d	8b 55 bc	 mov	 edx, DWORD PTR _srcYLine$11[ebp]
  00180	89 55 ac	 mov	 DWORD PTR _src_ptr$7[ebp], edx

; 1269 :                 uint16_t *dst_ptr = dstLine;

  00183	8b 45 b8	 mov	 eax, DWORD PTR _dstLine$10[ebp]
  00186	89 45 a8	 mov	 DWORD PTR _dst_ptr$6[ebp], eax

; 1270 :                 for (int x = 0; x < y_width; x += 8, dst_ptr += 8, src_ptr += 8) {

  00189	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _x$5[ebp], 0
  00190	eb 1b		 jmp	 SHORT $LN10@convert_yu
$LN8@convert_yu:
  00192	8b 4d a4	 mov	 ecx, DWORD PTR _x$5[ebp]
  00195	83 c1 08	 add	 ecx, 8
  00198	89 4d a4	 mov	 DWORD PTR _x$5[ebp], ecx
  0019b	8b 55 a8	 mov	 edx, DWORD PTR _dst_ptr$6[ebp]
  0019e	83 c2 10	 add	 edx, 16			; 00000010H
  001a1	89 55 a8	 mov	 DWORD PTR _dst_ptr$6[ebp], edx
  001a4	8b 45 ac	 mov	 eax, DWORD PTR _src_ptr$7[ebp]
  001a7	83 c0 10	 add	 eax, 16			; 00000010H
  001aa	89 45 ac	 mov	 DWORD PTR _src_ptr$7[ebp], eax
$LN10@convert_yu:
  001ad	8b 4d a4	 mov	 ecx, DWORD PTR _x$5[ebp]
  001b0	3b 4d b4	 cmp	 ecx, DWORD PTR _y_width$9[ebp]
  001b3	7d 39		 jge	 SHORT $LN12@convert_yu

; 1271 :                     __m128i x0 = _mm_loadu_si128((const __m128i *)src_ptr);

  001b5	8b 55 ac	 mov	 edx, DWORD PTR _src_ptr$7[ebp]
  001b8	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  001bb	0f 29 45 80	 movaps	 XMMWORD PTR $T3[ebp], xmm0
  001bf	0f 28 45 80	 movaps	 xmm0, XMMWORD PTR $T3[ebp]
  001c3	0f 29 45 90	 movaps	 XMMWORD PTR _x0$4[ebp], xmm0

; 1272 :                     x0 = _mm_slli_epi16(x0, 16 - in_bit_depth);

  001c7	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR _x0$4[ebp]
  001cb	66 0f 71 f0 06	 psllw	 xmm0, 6
  001d0	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR $T2[ebp], xmm0
  001d7	0f 28 85 70 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T2[ebp]
  001de	0f 29 45 90	 movaps	 XMMWORD PTR _x0$4[ebp], xmm0

; 1273 :                     _mm_storeu_si128((__m128i *)dst_ptr, x0);

  001e2	0f 10 45 90	 movups	 xmm0, XMMWORD PTR _x0$4[ebp]
  001e6	8b 45 a8	 mov	 eax, DWORD PTR _dst_ptr$6[ebp]
  001e9	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 1274 :                 }

  001ec	eb a4		 jmp	 SHORT $LN8@convert_yu
$LN12@convert_yu:

; 1275 :             }
; 1276 :         }

  001ee	e9 41 ff ff ff	 jmp	 $LN5@convert_yu
$LN6@convert_yu:

; 1277 :     }

  001f3	e9 e2 fe ff ff	 jmp	 $LN2@convert_yu
$LN1@convert_yu:

; 1278 : }

  001f8	52		 push	 edx
  001f9	8b cd		 mov	 ecx, ebp
  001fb	50		 push	 eax
  001fc	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN16@convert_yu
  00202	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00207	58		 pop	 eax
  00208	5a		 pop	 edx
  00209	5f		 pop	 edi
  0020a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0020d	33 cd		 xor	 ecx, ebp
  0020f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00214	8b e5		 mov	 esp, ebp
  00216	5d		 pop	 ebp
  00217	8b e3		 mov	 esp, ebx
  00219	5b		 pop	 ebx
  0021a	c3		 ret	 0
  0021b	90		 npad	 1
$LN16@convert_yu:
  0021c	01 00 00 00	 DD	 1
  00220	00 00 00 00	 DD	 $LN15@convert_yu
$LN15@convert_yu:
  00224	d4 ff ff ff	 DD	 -44			; ffffffd4H
  00228	0c 00 00 00	 DD	 12			; 0000000cH
  0022c	00 00 00 00	 DD	 $LN14@convert_yu
$LN14@convert_yu:
  00230	79		 DB	 121			; 00000079H
  00231	5f		 DB	 95			; 0000005fH
  00232	72		 DB	 114			; 00000072H
  00233	61		 DB	 97			; 00000061H
  00234	6e		 DB	 110			; 0000006eH
  00235	67		 DB	 103			; 00000067H
  00236	65		 DB	 101			; 00000065H
  00237	00		 DB	 0
??$convert_yuv444_high_to_yuv444_16_simd@$09@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_high_to_yuv444_16_simd<10>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_sse2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuv444_10_to_yuv444_16_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_10_to_yuv444_16_sse2

; 169  : void convert_yuv444_10_to_yuv444_16_sse2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 170  :     convert_yuv444_high_to_yuv444_16_simd<10>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yuv444_high_to_yuv444_16_simd@$09@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_high_to_yuv444_16_simd<10>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 171  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yuv444_10_to_yuv444_16_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_10_to_yuv444_16_sse2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -160						; size = 12
$T2 = -144						; size = 16
$T3 = -128						; size = 16
_x0$4 = -112						; size = 16
_x$5 = -92						; size = 4
_dst_ptr$6 = -88					; size = 4
_src_ptr$7 = -84					; size = 4
_y$8 = -80						; size = 4
_y_width$9 = -76					; size = 4
_dstLine$10 = -72					; size = 4
_srcYLine$11 = -68					; size = 4
_i$12 = -64						; size = 4
$T13 = -60						; size = 12
_y_range$ = -44						; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yuv444_high_to_yuv444_16_simd@$0M@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_high_to_yuv444_16_simd<12>

; 1251 : static void __forceinline convert_yuv444_high_to_yuv444_16_simd(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec a0 00 00
	00		 sub	 esp, 160		; 000000a0H
  0001c	57		 push	 edi
  0001d	8d bd 60 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-160]
  00023	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1252 :     static_assert(8 < in_bit_depth && in_bit_depth <= 16, "in_bit_depth must be 9-16.");
; 1253 :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 1254 :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 1255 :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 1256 :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 1257 :     const int src_y_pitch = src_y_pitch_byte >> 1;

  0007c	8b 53 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  0007f	d1 fa		 sar	 edx, 1
  00081	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 1258 :     const int dst_y_pitch = dst_y_pitch_byte >> 1;

  00084	8b 43 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  00087	d1 f8		 sar	 eax, 1
  00089	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 1259 :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  0008c	8b 4b 2c	 mov	 ecx, DWORD PTR _thread_n$[ebx]
  0008f	51		 push	 ecx
  00090	8b 53 28	 mov	 edx, DWORD PTR _thread_id$[ebx]
  00093	52		 push	 edx
  00094	8b 43 20	 mov	 eax, DWORD PTR _height$[ebx]
  00097	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  0009a	50		 push	 eax
  0009b	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  0009e	51		 push	 ecx
  0009f	8d 95 60 ff ff
	ff		 lea	 edx, DWORD PTR $T1[ebp]
  000a5	52		 push	 edx
  000a6	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  000ab	83 c4 14	 add	 esp, 20			; 00000014H
  000ae	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b0	89 4d c4	 mov	 DWORD PTR $T13[ebp], ecx
  000b3	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000b6	89 55 c8	 mov	 DWORD PTR $T13[ebp+4], edx
  000b9	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000bc	89 45 cc	 mov	 DWORD PTR $T13[ebp+8], eax
  000bf	8b 4d c4	 mov	 ecx, DWORD PTR $T13[ebp]
  000c2	89 4d d4	 mov	 DWORD PTR _y_range$[ebp], ecx
  000c5	8b 55 c8	 mov	 edx, DWORD PTR $T13[ebp+4]
  000c8	89 55 d8	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000cb	8b 45 cc	 mov	 eax, DWORD PTR $T13[ebp+8]
  000ce	89 45 dc	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 1260 :     for (int i = 0; i < 3; i++) {

  000d1	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _i$12[ebp], 0
  000d8	eb 09		 jmp	 SHORT $LN4@convert_yu
$LN2@convert_yu:
  000da	8b 4d c0	 mov	 ecx, DWORD PTR _i$12[ebp]
  000dd	83 c1 01	 add	 ecx, 1
  000e0	89 4d c0	 mov	 DWORD PTR _i$12[ebp], ecx
$LN4@convert_yu:
  000e3	83 7d c0 03	 cmp	 DWORD PTR _i$12[ebp], 3
  000e7	0f 8d 0b 01 00
	00		 jge	 $LN1@convert_yu

; 1261 :         uint16_t *srcYLine = (uint16_t *)src[i] + src_y_pitch * y_range.start_src + crop_left;

  000ed	8b 55 e8	 mov	 edx, DWORD PTR _src_y_pitch$[ebp]
  000f0	0f af 55 d4	 imul	 edx, DWORD PTR _y_range$[ebp]
  000f4	8b 45 c0	 mov	 eax, DWORD PTR _i$12[ebp]
  000f7	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  000fa	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  000fd	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00100	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  00103	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  00106	89 45 bc	 mov	 DWORD PTR _srcYLine$11[ebp], eax

; 1262 :         uint16_t *dstLine = (uint16_t *)dst[i] + dst_y_pitch * y_range.start_dst;

  00109	8b 4d e4	 mov	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  0010c	0f af 4d d8	 imul	 ecx, DWORD PTR _y_range$[ebp+4]
  00110	8b 55 c0	 mov	 edx, DWORD PTR _i$12[ebp]
  00113	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  00116	8b 14 90	 mov	 edx, DWORD PTR [eax+edx*4]
  00119	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  0011c	89 45 b8	 mov	 DWORD PTR _dstLine$10[ebp], eax

; 1263 :         const int y_width = width - crop_right - crop_left;

  0011f	8b 4b 10	 mov	 ecx, DWORD PTR _width$[ebx]
  00122	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  00125	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  00128	89 4d b4	 mov	 DWORD PTR _y_width$9[ebp], ecx

; 1264 :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  0012b	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _y$8[ebp], 0
  00132	eb 21		 jmp	 SHORT $LN7@convert_yu
$LN5@convert_yu:
  00134	8b 55 b0	 mov	 edx, DWORD PTR _y$8[ebp]
  00137	83 c2 01	 add	 edx, 1
  0013a	89 55 b0	 mov	 DWORD PTR _y$8[ebp], edx
  0013d	8b 45 e8	 mov	 eax, DWORD PTR _src_y_pitch$[ebp]
  00140	8b 4d bc	 mov	 ecx, DWORD PTR _srcYLine$11[ebp]
  00143	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00146	89 55 bc	 mov	 DWORD PTR _srcYLine$11[ebp], edx
  00149	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  0014c	8b 4d b8	 mov	 ecx, DWORD PTR _dstLine$10[ebp]
  0014f	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00152	89 55 b8	 mov	 DWORD PTR _dstLine$10[ebp], edx
$LN7@convert_yu:
  00155	8b 45 b0	 mov	 eax, DWORD PTR _y$8[ebp]
  00158	3b 45 dc	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  0015b	0f 8d 92 00 00
	00		 jge	 $LN6@convert_yu

; 1265 :             if (in_bit_depth == 16) {

  00161	33 c9		 xor	 ecx, ecx
  00163	74 18		 je	 SHORT $LN11@convert_yu

; 1266 :                 memcpy_sse((uint8_t *)dstLine, (uint8_t *)srcYLine, y_width * sizeof(uint16_t));

  00165	8b 55 b4	 mov	 edx, DWORD PTR _y_width$9[ebp]
  00168	d1 e2		 shl	 edx, 1
  0016a	52		 push	 edx
  0016b	8b 45 bc	 mov	 eax, DWORD PTR _srcYLine$11[ebp]
  0016e	50		 push	 eax
  0016f	8b 4d b8	 mov	 ecx, DWORD PTR _dstLine$10[ebp]
  00172	51		 push	 ecx
  00173	e8 00 00 00 00	 call	 ?memcpy_sse@@YAXPAEPBEH@Z ; memcpy_sse
  00178	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1267 :             } else {

  0017b	eb 71		 jmp	 SHORT $LN12@convert_yu
$LN11@convert_yu:

; 1268 :                 uint16_t *src_ptr = srcYLine;

  0017d	8b 55 bc	 mov	 edx, DWORD PTR _srcYLine$11[ebp]
  00180	89 55 ac	 mov	 DWORD PTR _src_ptr$7[ebp], edx

; 1269 :                 uint16_t *dst_ptr = dstLine;

  00183	8b 45 b8	 mov	 eax, DWORD PTR _dstLine$10[ebp]
  00186	89 45 a8	 mov	 DWORD PTR _dst_ptr$6[ebp], eax

; 1270 :                 for (int x = 0; x < y_width; x += 8, dst_ptr += 8, src_ptr += 8) {

  00189	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _x$5[ebp], 0
  00190	eb 1b		 jmp	 SHORT $LN10@convert_yu
$LN8@convert_yu:
  00192	8b 4d a4	 mov	 ecx, DWORD PTR _x$5[ebp]
  00195	83 c1 08	 add	 ecx, 8
  00198	89 4d a4	 mov	 DWORD PTR _x$5[ebp], ecx
  0019b	8b 55 a8	 mov	 edx, DWORD PTR _dst_ptr$6[ebp]
  0019e	83 c2 10	 add	 edx, 16			; 00000010H
  001a1	89 55 a8	 mov	 DWORD PTR _dst_ptr$6[ebp], edx
  001a4	8b 45 ac	 mov	 eax, DWORD PTR _src_ptr$7[ebp]
  001a7	83 c0 10	 add	 eax, 16			; 00000010H
  001aa	89 45 ac	 mov	 DWORD PTR _src_ptr$7[ebp], eax
$LN10@convert_yu:
  001ad	8b 4d a4	 mov	 ecx, DWORD PTR _x$5[ebp]
  001b0	3b 4d b4	 cmp	 ecx, DWORD PTR _y_width$9[ebp]
  001b3	7d 39		 jge	 SHORT $LN12@convert_yu

; 1271 :                     __m128i x0 = _mm_loadu_si128((const __m128i *)src_ptr);

  001b5	8b 55 ac	 mov	 edx, DWORD PTR _src_ptr$7[ebp]
  001b8	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  001bb	0f 29 45 80	 movaps	 XMMWORD PTR $T3[ebp], xmm0
  001bf	0f 28 45 80	 movaps	 xmm0, XMMWORD PTR $T3[ebp]
  001c3	0f 29 45 90	 movaps	 XMMWORD PTR _x0$4[ebp], xmm0

; 1272 :                     x0 = _mm_slli_epi16(x0, 16 - in_bit_depth);

  001c7	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR _x0$4[ebp]
  001cb	66 0f 71 f0 04	 psllw	 xmm0, 4
  001d0	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR $T2[ebp], xmm0
  001d7	0f 28 85 70 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T2[ebp]
  001de	0f 29 45 90	 movaps	 XMMWORD PTR _x0$4[ebp], xmm0

; 1273 :                     _mm_storeu_si128((__m128i *)dst_ptr, x0);

  001e2	0f 10 45 90	 movups	 xmm0, XMMWORD PTR _x0$4[ebp]
  001e6	8b 45 a8	 mov	 eax, DWORD PTR _dst_ptr$6[ebp]
  001e9	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 1274 :                 }

  001ec	eb a4		 jmp	 SHORT $LN8@convert_yu
$LN12@convert_yu:

; 1275 :             }
; 1276 :         }

  001ee	e9 41 ff ff ff	 jmp	 $LN5@convert_yu
$LN6@convert_yu:

; 1277 :     }

  001f3	e9 e2 fe ff ff	 jmp	 $LN2@convert_yu
$LN1@convert_yu:

; 1278 : }

  001f8	52		 push	 edx
  001f9	8b cd		 mov	 ecx, ebp
  001fb	50		 push	 eax
  001fc	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN16@convert_yu
  00202	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00207	58		 pop	 eax
  00208	5a		 pop	 edx
  00209	5f		 pop	 edi
  0020a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0020d	33 cd		 xor	 ecx, ebp
  0020f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00214	8b e5		 mov	 esp, ebp
  00216	5d		 pop	 ebp
  00217	8b e3		 mov	 esp, ebx
  00219	5b		 pop	 ebx
  0021a	c3		 ret	 0
  0021b	90		 npad	 1
$LN16@convert_yu:
  0021c	01 00 00 00	 DD	 1
  00220	00 00 00 00	 DD	 $LN15@convert_yu
$LN15@convert_yu:
  00224	d4 ff ff ff	 DD	 -44			; ffffffd4H
  00228	0c 00 00 00	 DD	 12			; 0000000cH
  0022c	00 00 00 00	 DD	 $LN14@convert_yu
$LN14@convert_yu:
  00230	79		 DB	 121			; 00000079H
  00231	5f		 DB	 95			; 0000005fH
  00232	72		 DB	 114			; 00000072H
  00233	61		 DB	 97			; 00000061H
  00234	6e		 DB	 110			; 0000006eH
  00235	67		 DB	 103			; 00000067H
  00236	65		 DB	 101			; 00000065H
  00237	00		 DB	 0
??$convert_yuv444_high_to_yuv444_16_simd@$0M@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_high_to_yuv444_16_simd<12>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_sse2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuv444_12_to_yuv444_16_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_12_to_yuv444_16_sse2

; 165  : void convert_yuv444_12_to_yuv444_16_sse2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 166  :     convert_yuv444_high_to_yuv444_16_simd<12>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yuv444_high_to_yuv444_16_simd@$0M@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_high_to_yuv444_16_simd<12>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 167  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yuv444_12_to_yuv444_16_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_12_to_yuv444_16_sse2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -160						; size = 12
$T2 = -144						; size = 16
$T3 = -128						; size = 16
_x0$4 = -112						; size = 16
_x$5 = -92						; size = 4
_dst_ptr$6 = -88					; size = 4
_src_ptr$7 = -84					; size = 4
_y$8 = -80						; size = 4
_y_width$9 = -76					; size = 4
_dstLine$10 = -72					; size = 4
_srcYLine$11 = -68					; size = 4
_i$12 = -64						; size = 4
$T13 = -60						; size = 12
_y_range$ = -44						; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yuv444_high_to_yuv444_16_simd@$0O@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_high_to_yuv444_16_simd<14>

; 1251 : static void __forceinline convert_yuv444_high_to_yuv444_16_simd(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec a0 00 00
	00		 sub	 esp, 160		; 000000a0H
  0001c	57		 push	 edi
  0001d	8d bd 60 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-160]
  00023	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1252 :     static_assert(8 < in_bit_depth && in_bit_depth <= 16, "in_bit_depth must be 9-16.");
; 1253 :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 1254 :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 1255 :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 1256 :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 1257 :     const int src_y_pitch = src_y_pitch_byte >> 1;

  0007c	8b 53 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  0007f	d1 fa		 sar	 edx, 1
  00081	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 1258 :     const int dst_y_pitch = dst_y_pitch_byte >> 1;

  00084	8b 43 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  00087	d1 f8		 sar	 eax, 1
  00089	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 1259 :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  0008c	8b 4b 2c	 mov	 ecx, DWORD PTR _thread_n$[ebx]
  0008f	51		 push	 ecx
  00090	8b 53 28	 mov	 edx, DWORD PTR _thread_id$[ebx]
  00093	52		 push	 edx
  00094	8b 43 20	 mov	 eax, DWORD PTR _height$[ebx]
  00097	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  0009a	50		 push	 eax
  0009b	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  0009e	51		 push	 ecx
  0009f	8d 95 60 ff ff
	ff		 lea	 edx, DWORD PTR $T1[ebp]
  000a5	52		 push	 edx
  000a6	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  000ab	83 c4 14	 add	 esp, 20			; 00000014H
  000ae	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b0	89 4d c4	 mov	 DWORD PTR $T13[ebp], ecx
  000b3	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000b6	89 55 c8	 mov	 DWORD PTR $T13[ebp+4], edx
  000b9	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000bc	89 45 cc	 mov	 DWORD PTR $T13[ebp+8], eax
  000bf	8b 4d c4	 mov	 ecx, DWORD PTR $T13[ebp]
  000c2	89 4d d4	 mov	 DWORD PTR _y_range$[ebp], ecx
  000c5	8b 55 c8	 mov	 edx, DWORD PTR $T13[ebp+4]
  000c8	89 55 d8	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000cb	8b 45 cc	 mov	 eax, DWORD PTR $T13[ebp+8]
  000ce	89 45 dc	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 1260 :     for (int i = 0; i < 3; i++) {

  000d1	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _i$12[ebp], 0
  000d8	eb 09		 jmp	 SHORT $LN4@convert_yu
$LN2@convert_yu:
  000da	8b 4d c0	 mov	 ecx, DWORD PTR _i$12[ebp]
  000dd	83 c1 01	 add	 ecx, 1
  000e0	89 4d c0	 mov	 DWORD PTR _i$12[ebp], ecx
$LN4@convert_yu:
  000e3	83 7d c0 03	 cmp	 DWORD PTR _i$12[ebp], 3
  000e7	0f 8d 0b 01 00
	00		 jge	 $LN1@convert_yu

; 1261 :         uint16_t *srcYLine = (uint16_t *)src[i] + src_y_pitch * y_range.start_src + crop_left;

  000ed	8b 55 e8	 mov	 edx, DWORD PTR _src_y_pitch$[ebp]
  000f0	0f af 55 d4	 imul	 edx, DWORD PTR _y_range$[ebp]
  000f4	8b 45 c0	 mov	 eax, DWORD PTR _i$12[ebp]
  000f7	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  000fa	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  000fd	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00100	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  00103	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  00106	89 45 bc	 mov	 DWORD PTR _srcYLine$11[ebp], eax

; 1262 :         uint16_t *dstLine = (uint16_t *)dst[i] + dst_y_pitch * y_range.start_dst;

  00109	8b 4d e4	 mov	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  0010c	0f af 4d d8	 imul	 ecx, DWORD PTR _y_range$[ebp+4]
  00110	8b 55 c0	 mov	 edx, DWORD PTR _i$12[ebp]
  00113	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  00116	8b 14 90	 mov	 edx, DWORD PTR [eax+edx*4]
  00119	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  0011c	89 45 b8	 mov	 DWORD PTR _dstLine$10[ebp], eax

; 1263 :         const int y_width = width - crop_right - crop_left;

  0011f	8b 4b 10	 mov	 ecx, DWORD PTR _width$[ebx]
  00122	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  00125	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  00128	89 4d b4	 mov	 DWORD PTR _y_width$9[ebp], ecx

; 1264 :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  0012b	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _y$8[ebp], 0
  00132	eb 21		 jmp	 SHORT $LN7@convert_yu
$LN5@convert_yu:
  00134	8b 55 b0	 mov	 edx, DWORD PTR _y$8[ebp]
  00137	83 c2 01	 add	 edx, 1
  0013a	89 55 b0	 mov	 DWORD PTR _y$8[ebp], edx
  0013d	8b 45 e8	 mov	 eax, DWORD PTR _src_y_pitch$[ebp]
  00140	8b 4d bc	 mov	 ecx, DWORD PTR _srcYLine$11[ebp]
  00143	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00146	89 55 bc	 mov	 DWORD PTR _srcYLine$11[ebp], edx
  00149	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  0014c	8b 4d b8	 mov	 ecx, DWORD PTR _dstLine$10[ebp]
  0014f	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00152	89 55 b8	 mov	 DWORD PTR _dstLine$10[ebp], edx
$LN7@convert_yu:
  00155	8b 45 b0	 mov	 eax, DWORD PTR _y$8[ebp]
  00158	3b 45 dc	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  0015b	0f 8d 92 00 00
	00		 jge	 $LN6@convert_yu

; 1265 :             if (in_bit_depth == 16) {

  00161	33 c9		 xor	 ecx, ecx
  00163	74 18		 je	 SHORT $LN11@convert_yu

; 1266 :                 memcpy_sse((uint8_t *)dstLine, (uint8_t *)srcYLine, y_width * sizeof(uint16_t));

  00165	8b 55 b4	 mov	 edx, DWORD PTR _y_width$9[ebp]
  00168	d1 e2		 shl	 edx, 1
  0016a	52		 push	 edx
  0016b	8b 45 bc	 mov	 eax, DWORD PTR _srcYLine$11[ebp]
  0016e	50		 push	 eax
  0016f	8b 4d b8	 mov	 ecx, DWORD PTR _dstLine$10[ebp]
  00172	51		 push	 ecx
  00173	e8 00 00 00 00	 call	 ?memcpy_sse@@YAXPAEPBEH@Z ; memcpy_sse
  00178	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1267 :             } else {

  0017b	eb 71		 jmp	 SHORT $LN12@convert_yu
$LN11@convert_yu:

; 1268 :                 uint16_t *src_ptr = srcYLine;

  0017d	8b 55 bc	 mov	 edx, DWORD PTR _srcYLine$11[ebp]
  00180	89 55 ac	 mov	 DWORD PTR _src_ptr$7[ebp], edx

; 1269 :                 uint16_t *dst_ptr = dstLine;

  00183	8b 45 b8	 mov	 eax, DWORD PTR _dstLine$10[ebp]
  00186	89 45 a8	 mov	 DWORD PTR _dst_ptr$6[ebp], eax

; 1270 :                 for (int x = 0; x < y_width; x += 8, dst_ptr += 8, src_ptr += 8) {

  00189	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _x$5[ebp], 0
  00190	eb 1b		 jmp	 SHORT $LN10@convert_yu
$LN8@convert_yu:
  00192	8b 4d a4	 mov	 ecx, DWORD PTR _x$5[ebp]
  00195	83 c1 08	 add	 ecx, 8
  00198	89 4d a4	 mov	 DWORD PTR _x$5[ebp], ecx
  0019b	8b 55 a8	 mov	 edx, DWORD PTR _dst_ptr$6[ebp]
  0019e	83 c2 10	 add	 edx, 16			; 00000010H
  001a1	89 55 a8	 mov	 DWORD PTR _dst_ptr$6[ebp], edx
  001a4	8b 45 ac	 mov	 eax, DWORD PTR _src_ptr$7[ebp]
  001a7	83 c0 10	 add	 eax, 16			; 00000010H
  001aa	89 45 ac	 mov	 DWORD PTR _src_ptr$7[ebp], eax
$LN10@convert_yu:
  001ad	8b 4d a4	 mov	 ecx, DWORD PTR _x$5[ebp]
  001b0	3b 4d b4	 cmp	 ecx, DWORD PTR _y_width$9[ebp]
  001b3	7d 39		 jge	 SHORT $LN12@convert_yu

; 1271 :                     __m128i x0 = _mm_loadu_si128((const __m128i *)src_ptr);

  001b5	8b 55 ac	 mov	 edx, DWORD PTR _src_ptr$7[ebp]
  001b8	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  001bb	0f 29 45 80	 movaps	 XMMWORD PTR $T3[ebp], xmm0
  001bf	0f 28 45 80	 movaps	 xmm0, XMMWORD PTR $T3[ebp]
  001c3	0f 29 45 90	 movaps	 XMMWORD PTR _x0$4[ebp], xmm0

; 1272 :                     x0 = _mm_slli_epi16(x0, 16 - in_bit_depth);

  001c7	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR _x0$4[ebp]
  001cb	66 0f 71 f0 02	 psllw	 xmm0, 2
  001d0	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR $T2[ebp], xmm0
  001d7	0f 28 85 70 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T2[ebp]
  001de	0f 29 45 90	 movaps	 XMMWORD PTR _x0$4[ebp], xmm0

; 1273 :                     _mm_storeu_si128((__m128i *)dst_ptr, x0);

  001e2	0f 10 45 90	 movups	 xmm0, XMMWORD PTR _x0$4[ebp]
  001e6	8b 45 a8	 mov	 eax, DWORD PTR _dst_ptr$6[ebp]
  001e9	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 1274 :                 }

  001ec	eb a4		 jmp	 SHORT $LN8@convert_yu
$LN12@convert_yu:

; 1275 :             }
; 1276 :         }

  001ee	e9 41 ff ff ff	 jmp	 $LN5@convert_yu
$LN6@convert_yu:

; 1277 :     }

  001f3	e9 e2 fe ff ff	 jmp	 $LN2@convert_yu
$LN1@convert_yu:

; 1278 : }

  001f8	52		 push	 edx
  001f9	8b cd		 mov	 ecx, ebp
  001fb	50		 push	 eax
  001fc	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN16@convert_yu
  00202	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00207	58		 pop	 eax
  00208	5a		 pop	 edx
  00209	5f		 pop	 edi
  0020a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0020d	33 cd		 xor	 ecx, ebp
  0020f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00214	8b e5		 mov	 esp, ebp
  00216	5d		 pop	 ebp
  00217	8b e3		 mov	 esp, ebx
  00219	5b		 pop	 ebx
  0021a	c3		 ret	 0
  0021b	90		 npad	 1
$LN16@convert_yu:
  0021c	01 00 00 00	 DD	 1
  00220	00 00 00 00	 DD	 $LN15@convert_yu
$LN15@convert_yu:
  00224	d4 ff ff ff	 DD	 -44			; ffffffd4H
  00228	0c 00 00 00	 DD	 12			; 0000000cH
  0022c	00 00 00 00	 DD	 $LN14@convert_yu
$LN14@convert_yu:
  00230	79		 DB	 121			; 00000079H
  00231	5f		 DB	 95			; 0000005fH
  00232	72		 DB	 114			; 00000072H
  00233	61		 DB	 97			; 00000061H
  00234	6e		 DB	 110			; 0000006eH
  00235	67		 DB	 103			; 00000067H
  00236	65		 DB	 101			; 00000065H
  00237	00		 DB	 0
??$convert_yuv444_high_to_yuv444_16_simd@$0O@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_high_to_yuv444_16_simd<14>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_sse2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuv444_14_to_yuv444_16_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_14_to_yuv444_16_sse2

; 161  : void convert_yuv444_14_to_yuv444_16_sse2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 162  :     convert_yuv444_high_to_yuv444_16_simd<14>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yuv444_high_to_yuv444_16_simd@$0O@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_high_to_yuv444_16_simd<14>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 163  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yuv444_14_to_yuv444_16_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_14_to_yuv444_16_sse2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -160						; size = 12
$T2 = -144						; size = 16
$T3 = -128						; size = 16
_x0$4 = -112						; size = 16
_x$5 = -92						; size = 4
_dst_ptr$6 = -88					; size = 4
_src_ptr$7 = -84					; size = 4
_y$8 = -80						; size = 4
_y_width$9 = -76					; size = 4
_dstLine$10 = -72					; size = 4
_srcYLine$11 = -68					; size = 4
_i$12 = -64						; size = 4
$T13 = -60						; size = 12
_y_range$ = -44						; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yuv444_high_to_yuv444_16_simd@$0BA@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_high_to_yuv444_16_simd<16>

; 1251 : static void __forceinline convert_yuv444_high_to_yuv444_16_simd(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec a0 00 00
	00		 sub	 esp, 160		; 000000a0H
  0001c	57		 push	 edi
  0001d	8d bd 60 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-160]
  00023	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1252 :     static_assert(8 < in_bit_depth && in_bit_depth <= 16, "in_bit_depth must be 9-16.");
; 1253 :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 1254 :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 1255 :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 1256 :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 1257 :     const int src_y_pitch = src_y_pitch_byte >> 1;

  0007c	8b 53 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  0007f	d1 fa		 sar	 edx, 1
  00081	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 1258 :     const int dst_y_pitch = dst_y_pitch_byte >> 1;

  00084	8b 43 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  00087	d1 f8		 sar	 eax, 1
  00089	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 1259 :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  0008c	8b 4b 2c	 mov	 ecx, DWORD PTR _thread_n$[ebx]
  0008f	51		 push	 ecx
  00090	8b 53 28	 mov	 edx, DWORD PTR _thread_id$[ebx]
  00093	52		 push	 edx
  00094	8b 43 20	 mov	 eax, DWORD PTR _height$[ebx]
  00097	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  0009a	50		 push	 eax
  0009b	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  0009e	51		 push	 ecx
  0009f	8d 95 60 ff ff
	ff		 lea	 edx, DWORD PTR $T1[ebp]
  000a5	52		 push	 edx
  000a6	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  000ab	83 c4 14	 add	 esp, 20			; 00000014H
  000ae	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b0	89 4d c4	 mov	 DWORD PTR $T13[ebp], ecx
  000b3	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000b6	89 55 c8	 mov	 DWORD PTR $T13[ebp+4], edx
  000b9	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000bc	89 45 cc	 mov	 DWORD PTR $T13[ebp+8], eax
  000bf	8b 4d c4	 mov	 ecx, DWORD PTR $T13[ebp]
  000c2	89 4d d4	 mov	 DWORD PTR _y_range$[ebp], ecx
  000c5	8b 55 c8	 mov	 edx, DWORD PTR $T13[ebp+4]
  000c8	89 55 d8	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000cb	8b 45 cc	 mov	 eax, DWORD PTR $T13[ebp+8]
  000ce	89 45 dc	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 1260 :     for (int i = 0; i < 3; i++) {

  000d1	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _i$12[ebp], 0
  000d8	eb 09		 jmp	 SHORT $LN4@convert_yu
$LN2@convert_yu:
  000da	8b 4d c0	 mov	 ecx, DWORD PTR _i$12[ebp]
  000dd	83 c1 01	 add	 ecx, 1
  000e0	89 4d c0	 mov	 DWORD PTR _i$12[ebp], ecx
$LN4@convert_yu:
  000e3	83 7d c0 03	 cmp	 DWORD PTR _i$12[ebp], 3
  000e7	0f 8d 10 01 00
	00		 jge	 $LN1@convert_yu

; 1261 :         uint16_t *srcYLine = (uint16_t *)src[i] + src_y_pitch * y_range.start_src + crop_left;

  000ed	8b 55 e8	 mov	 edx, DWORD PTR _src_y_pitch$[ebp]
  000f0	0f af 55 d4	 imul	 edx, DWORD PTR _y_range$[ebp]
  000f4	8b 45 c0	 mov	 eax, DWORD PTR _i$12[ebp]
  000f7	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  000fa	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  000fd	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00100	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  00103	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  00106	89 45 bc	 mov	 DWORD PTR _srcYLine$11[ebp], eax

; 1262 :         uint16_t *dstLine = (uint16_t *)dst[i] + dst_y_pitch * y_range.start_dst;

  00109	8b 4d e4	 mov	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  0010c	0f af 4d d8	 imul	 ecx, DWORD PTR _y_range$[ebp+4]
  00110	8b 55 c0	 mov	 edx, DWORD PTR _i$12[ebp]
  00113	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  00116	8b 14 90	 mov	 edx, DWORD PTR [eax+edx*4]
  00119	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  0011c	89 45 b8	 mov	 DWORD PTR _dstLine$10[ebp], eax

; 1263 :         const int y_width = width - crop_right - crop_left;

  0011f	8b 4b 10	 mov	 ecx, DWORD PTR _width$[ebx]
  00122	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  00125	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  00128	89 4d b4	 mov	 DWORD PTR _y_width$9[ebp], ecx

; 1264 :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  0012b	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _y$8[ebp], 0
  00132	eb 21		 jmp	 SHORT $LN7@convert_yu
$LN5@convert_yu:
  00134	8b 55 b0	 mov	 edx, DWORD PTR _y$8[ebp]
  00137	83 c2 01	 add	 edx, 1
  0013a	89 55 b0	 mov	 DWORD PTR _y$8[ebp], edx
  0013d	8b 45 e8	 mov	 eax, DWORD PTR _src_y_pitch$[ebp]
  00140	8b 4d bc	 mov	 ecx, DWORD PTR _srcYLine$11[ebp]
  00143	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00146	89 55 bc	 mov	 DWORD PTR _srcYLine$11[ebp], edx
  00149	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  0014c	8b 4d b8	 mov	 ecx, DWORD PTR _dstLine$10[ebp]
  0014f	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00152	89 55 b8	 mov	 DWORD PTR _dstLine$10[ebp], edx
$LN7@convert_yu:
  00155	8b 45 b0	 mov	 eax, DWORD PTR _y$8[ebp]
  00158	3b 45 dc	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  0015b	0f 8d 97 00 00
	00		 jge	 $LN6@convert_yu

; 1265 :             if (in_bit_depth == 16) {

  00161	b9 01 00 00 00	 mov	 ecx, 1
  00166	85 c9		 test	 ecx, ecx
  00168	74 18		 je	 SHORT $LN11@convert_yu

; 1266 :                 memcpy_sse((uint8_t *)dstLine, (uint8_t *)srcYLine, y_width * sizeof(uint16_t));

  0016a	8b 55 b4	 mov	 edx, DWORD PTR _y_width$9[ebp]
  0016d	d1 e2		 shl	 edx, 1
  0016f	52		 push	 edx
  00170	8b 45 bc	 mov	 eax, DWORD PTR _srcYLine$11[ebp]
  00173	50		 push	 eax
  00174	8b 4d b8	 mov	 ecx, DWORD PTR _dstLine$10[ebp]
  00177	51		 push	 ecx
  00178	e8 00 00 00 00	 call	 ?memcpy_sse@@YAXPAEPBEH@Z ; memcpy_sse
  0017d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1267 :             } else {

  00180	eb 71		 jmp	 SHORT $LN12@convert_yu
$LN11@convert_yu:

; 1268 :                 uint16_t *src_ptr = srcYLine;

  00182	8b 55 bc	 mov	 edx, DWORD PTR _srcYLine$11[ebp]
  00185	89 55 ac	 mov	 DWORD PTR _src_ptr$7[ebp], edx

; 1269 :                 uint16_t *dst_ptr = dstLine;

  00188	8b 45 b8	 mov	 eax, DWORD PTR _dstLine$10[ebp]
  0018b	89 45 a8	 mov	 DWORD PTR _dst_ptr$6[ebp], eax

; 1270 :                 for (int x = 0; x < y_width; x += 8, dst_ptr += 8, src_ptr += 8) {

  0018e	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _x$5[ebp], 0
  00195	eb 1b		 jmp	 SHORT $LN10@convert_yu
$LN8@convert_yu:
  00197	8b 4d a4	 mov	 ecx, DWORD PTR _x$5[ebp]
  0019a	83 c1 08	 add	 ecx, 8
  0019d	89 4d a4	 mov	 DWORD PTR _x$5[ebp], ecx
  001a0	8b 55 a8	 mov	 edx, DWORD PTR _dst_ptr$6[ebp]
  001a3	83 c2 10	 add	 edx, 16			; 00000010H
  001a6	89 55 a8	 mov	 DWORD PTR _dst_ptr$6[ebp], edx
  001a9	8b 45 ac	 mov	 eax, DWORD PTR _src_ptr$7[ebp]
  001ac	83 c0 10	 add	 eax, 16			; 00000010H
  001af	89 45 ac	 mov	 DWORD PTR _src_ptr$7[ebp], eax
$LN10@convert_yu:
  001b2	8b 4d a4	 mov	 ecx, DWORD PTR _x$5[ebp]
  001b5	3b 4d b4	 cmp	 ecx, DWORD PTR _y_width$9[ebp]
  001b8	7d 39		 jge	 SHORT $LN12@convert_yu

; 1271 :                     __m128i x0 = _mm_loadu_si128((const __m128i *)src_ptr);

  001ba	8b 55 ac	 mov	 edx, DWORD PTR _src_ptr$7[ebp]
  001bd	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  001c0	0f 29 45 80	 movaps	 XMMWORD PTR $T3[ebp], xmm0
  001c4	0f 28 45 80	 movaps	 xmm0, XMMWORD PTR $T3[ebp]
  001c8	0f 29 45 90	 movaps	 XMMWORD PTR _x0$4[ebp], xmm0

; 1272 :                     x0 = _mm_slli_epi16(x0, 16 - in_bit_depth);

  001cc	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR _x0$4[ebp]
  001d0	66 0f 71 f0 00	 psllw	 xmm0, 0
  001d5	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR $T2[ebp], xmm0
  001dc	0f 28 85 70 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T2[ebp]
  001e3	0f 29 45 90	 movaps	 XMMWORD PTR _x0$4[ebp], xmm0

; 1273 :                     _mm_storeu_si128((__m128i *)dst_ptr, x0);

  001e7	0f 10 45 90	 movups	 xmm0, XMMWORD PTR _x0$4[ebp]
  001eb	8b 45 a8	 mov	 eax, DWORD PTR _dst_ptr$6[ebp]
  001ee	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 1274 :                 }

  001f1	eb a4		 jmp	 SHORT $LN8@convert_yu
$LN12@convert_yu:

; 1275 :             }
; 1276 :         }

  001f3	e9 3c ff ff ff	 jmp	 $LN5@convert_yu
$LN6@convert_yu:

; 1277 :     }

  001f8	e9 dd fe ff ff	 jmp	 $LN2@convert_yu
$LN1@convert_yu:

; 1278 : }

  001fd	52		 push	 edx
  001fe	8b cd		 mov	 ecx, ebp
  00200	50		 push	 eax
  00201	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN16@convert_yu
  00207	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0020c	58		 pop	 eax
  0020d	5a		 pop	 edx
  0020e	5f		 pop	 edi
  0020f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00212	33 cd		 xor	 ecx, ebp
  00214	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00219	8b e5		 mov	 esp, ebp
  0021b	5d		 pop	 ebp
  0021c	8b e3		 mov	 esp, ebx
  0021e	5b		 pop	 ebx
  0021f	c3		 ret	 0
$LN16@convert_yu:
  00220	01 00 00 00	 DD	 1
  00224	00 00 00 00	 DD	 $LN15@convert_yu
$LN15@convert_yu:
  00228	d4 ff ff ff	 DD	 -44			; ffffffd4H
  0022c	0c 00 00 00	 DD	 12			; 0000000cH
  00230	00 00 00 00	 DD	 $LN14@convert_yu
$LN14@convert_yu:
  00234	79		 DB	 121			; 00000079H
  00235	5f		 DB	 95			; 0000005fH
  00236	72		 DB	 114			; 00000072H
  00237	61		 DB	 97			; 00000061H
  00238	6e		 DB	 110			; 0000006eH
  00239	67		 DB	 103			; 00000067H
  0023a	65		 DB	 101			; 00000065H
  0023b	00		 DB	 0
??$convert_yuv444_high_to_yuv444_16_simd@$0BA@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_high_to_yuv444_16_simd<16>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_sse2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuv444_16_to_yuv444_16_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_16_to_yuv444_16_sse2

; 157  : void convert_yuv444_16_to_yuv444_16_sse2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 158  :     convert_yuv444_high_to_yuv444_16_simd<16>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yuv444_high_to_yuv444_16_simd@$0BA@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_high_to_yuv444_16_simd<16>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 159  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yuv444_16_to_yuv444_16_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_16_to_yuv444_16_sse2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_sse2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?copy_yuv444_to_yuv444_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; copy_yuv444_to_yuv444_sse2

; 153  : void copy_yuv444_to_yuv444_sse2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 154  :     copy_yuv444_to_yuv444(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ?copy_yuv444_to_yuv444@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; copy_yuv444_to_yuv444
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 155  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?copy_yuv444_to_yuv444_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; copy_yuv444_to_yuv444_sse2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
tv315 = -704						; size = 4
tv259 = -700						; size = 4
tv214 = -696						; size = 4
tv183 = -692						; size = 4
$T1 = -688						; size = 12
$T2 = -672						; size = 16
$T3 = -656						; size = 16
$T4 = -640						; size = 16
$T5 = -624						; size = 16
$T6 = -608						; size = 16
$T7 = -592						; size = 16
$T8 = -576						; size = 16
$T9 = -560						; size = 16
$T10 = -544						; size = 16
$T11 = -528						; size = 16
$T12 = -512						; size = 16
$T13 = -496						; size = 16
$T14 = -480						; size = 16
$T15 = -464						; size = 16
$T16 = -448						; size = 16
$T17 = -432						; size = 16
$T18 = -416						; size = 16
$T19 = -400						; size = 16
$T20 = -384						; size = 16
$T21 = -368						; size = 16
$T22 = -352						; size = 16
$T23 = -336						; size = 16
_x3$ = -320						; size = 16
_x2$ = -288						; size = 16
_x1$ = -256						; size = 16
_x0$ = -224						; size = 16
$T24 = -196						; size = 12
_y_range$ = -180					; size = 12
_dst_y_pitch$ = -164					; size = 4
$T25 = -160						; size = 16
_xC_YCC$ = -128						; size = 16
$T26 = -96						; size = 16
_xC_pw_one$ = -64					; size = 16
_C$ = -44						; size = 4
_Y$ = -40						; size = 4
_ycpw$ = -36						; size = 4
_ycp$ = -32						; size = 4
_pixel$ = -28						; size = 4
_dst_C$ = -24						; size = 4
_dst_Y$ = -20						; size = 4
_i$ = -16						; size = 4
_y$ = -12						; size = 4
_x$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yc48_to_p010_i_simd@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yc48_to_p010_i_simd<0>

; 1633 : static __forceinline void convert_yc48_to_p010_i_simd(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec c0 02 00
	00		 sub	 esp, 704		; 000002c0H
  0001c	57		 push	 edi
  0001d	8d bd 40 fd ff
	ff		 lea	 edi, DWORD PTR [ebp-704]
  00023	b9 b0 00 00 00	 mov	 ecx, 176		; 000000b0H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1634 :     int x, y, i;
; 1635 :     short *dst_Y = (short *)dst[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 08	 mov	 edx, DWORD PTR _dst$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 ec	 mov	 DWORD PTR _dst_Y$[ebp], eax

; 1636 :     short *dst_C = (short *)dst[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 08	 mov	 edx, DWORD PTR _dst$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 e8	 mov	 DWORD PTR _dst_C$[ebp], eax

; 1637 :     const void  *pixel = src[0];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	6b d1 00	 imul	 edx, ecx, 0
  00063	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  00066	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00069	89 4d e4	 mov	 DWORD PTR _pixel$[ebp], ecx

; 1638 :     const short *ycp, *ycpw;
; 1639 :     short *Y = nullptr, *C = nullptr;

  0006c	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _Y$[ebp], 0
  00073	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _C$[ebp], 0

; 1640 :     const __m128i xC_pw_one = _mm_set1_epi16(1);

  0007a	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@00010001000100010001000100010001
  00081	0f 29 45 a0	 movaps	 XMMWORD PTR $T26[ebp], xmm0
  00085	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR $T26[ebp]
  00089	0f 29 45 c0	 movaps	 XMMWORD PTR _xC_pw_one$[ebp], xmm0

; 1641 :     const __m128i xC_YCC = _mm_set1_epi32(1<<LSFT_YCC_16);

  0008d	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@00001000000010000000100000001000
  00094	0f 29 85 60 ff
	ff ff		 movaps	 XMMWORD PTR $T25[ebp], xmm0
  0009b	0f 28 85 60 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T25[ebp]
  000a2	0f 29 45 80	 movaps	 XMMWORD PTR _xC_YCC$[ebp], xmm0

; 1642 :     const int dst_y_pitch = dst_y_pitch_byte >> 1;

  000a6	8b 53 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebx]
  000a9	d1 fa		 sar	 edx, 1
  000ab	89 95 5c ff ff
	ff		 mov	 DWORD PTR _dst_y_pitch$[ebp], edx

; 1643 :     const auto y_range = thread_y_range(0, height, thread_id, thread_n);

  000b1	8b 43 2c	 mov	 eax, DWORD PTR _thread_n$[ebx]
  000b4	50		 push	 eax
  000b5	8b 4b 28	 mov	 ecx, DWORD PTR _thread_id$[ebx]
  000b8	51		 push	 ecx
  000b9	8b 53 20	 mov	 edx, DWORD PTR _height$[ebx]
  000bc	52		 push	 edx
  000bd	6a 00		 push	 0
  000bf	8d 85 50 fd ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  000c5	50		 push	 eax
  000c6	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  000cb	83 c4 14	 add	 esp, 20			; 00000014H
  000ce	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d0	89 8d 3c ff ff
	ff		 mov	 DWORD PTR $T24[ebp], ecx
  000d6	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000d9	89 95 40 ff ff
	ff		 mov	 DWORD PTR $T24[ebp+4], edx
  000df	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000e2	89 85 44 ff ff
	ff		 mov	 DWORD PTR $T24[ebp+8], eax
  000e8	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR $T24[ebp]
  000ee	89 8d 4c ff ff
	ff		 mov	 DWORD PTR _y_range$[ebp], ecx
  000f4	8b 95 40 ff ff
	ff		 mov	 edx, DWORD PTR $T24[ebp+4]
  000fa	89 95 50 ff ff
	ff		 mov	 DWORD PTR _y_range$[ebp+4], edx
  00100	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR $T24[ebp+8]
  00106	89 85 54 ff ff
	ff		 mov	 DWORD PTR _y_range$[ebp+8], eax

; 1644 :     __m128i x0, x1, x2, x3;
; 1645 :     for (y = y_range.start_src; y < (y_range.start_src + y_range.len); y += 4) {

  0010c	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _y_range$[ebp]
  00112	89 4d f4	 mov	 DWORD PTR _y$[ebp], ecx
  00115	eb 09		 jmp	 SHORT $LN4@convert_yc
$LN2@convert_yc:
  00117	8b 55 f4	 mov	 edx, DWORD PTR _y$[ebp]
  0011a	83 c2 04	 add	 edx, 4
  0011d	89 55 f4	 mov	 DWORD PTR _y$[ebp], edx
$LN4@convert_yc:
  00120	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _y_range$[ebp]
  00126	03 85 54 ff ff
	ff		 add	 eax, DWORD PTR _y_range$[ebp+8]
  0012c	39 45 f4	 cmp	 DWORD PTR _y$[ebp], eax
  0012f	0f 8d 5b 04 00
	00		 jge	 $LN1@convert_yc

; 1646 :         for (i = 0; i < 2; i++) {

  00135	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0013c	eb 09		 jmp	 SHORT $LN7@convert_yc
$LN5@convert_yc:
  0013e	8b 4d f0	 mov	 ecx, DWORD PTR _i$[ebp]
  00141	83 c1 01	 add	 ecx, 1
  00144	89 4d f0	 mov	 DWORD PTR _i$[ebp], ecx
$LN7@convert_yc:
  00147	83 7d f0 02	 cmp	 DWORD PTR _i$[ebp], 2
  0014b	0f 8d 3a 04 00
	00		 jge	 $LN6@convert_yc

; 1647 :             ycp = (short*)pixel + width * (y + i) * 3;

  00151	8b 55 f4	 mov	 edx, DWORD PTR _y$[ebp]
  00154	03 55 f0	 add	 edx, DWORD PTR _i$[ebp]
  00157	0f af 53 10	 imul	 edx, DWORD PTR _width$[ebx]
  0015b	6b c2 03	 imul	 eax, edx, 3
  0015e	8b 4d e4	 mov	 ecx, DWORD PTR _pixel$[ebp]
  00161	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00164	89 55 e0	 mov	 DWORD PTR _ycp$[ebp], edx

; 1648 :             ycpw= ycp + width*2*3;

  00167	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  0016a	d1 e0		 shl	 eax, 1
  0016c	6b c8 03	 imul	 ecx, eax, 3
  0016f	8b 55 e0	 mov	 edx, DWORD PTR _ycp$[ebp]
  00172	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  00175	89 45 dc	 mov	 DWORD PTR _ycpw$[ebp], eax

; 1649 :             Y   = dst_Y + dst_y_pitch * (y + i);

  00178	8b 4d f4	 mov	 ecx, DWORD PTR _y$[ebp]
  0017b	03 4d f0	 add	 ecx, DWORD PTR _i$[ebp]
  0017e	0f af 8d 5c ff
	ff ff		 imul	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  00185	8b 55 ec	 mov	 edx, DWORD PTR _dst_Y$[ebp]
  00188	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  0018b	89 45 d8	 mov	 DWORD PTR _Y$[ebp], eax

; 1650 :             C   = dst_C + dst_y_pitch * (y + i*2) / 2;

  0018e	8b 4d f0	 mov	 ecx, DWORD PTR _i$[ebp]
  00191	8b 55 f4	 mov	 edx, DWORD PTR _y$[ebp]
  00194	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  00197	0f af 85 5c ff
	ff ff		 imul	 eax, DWORD PTR _dst_y_pitch$[ebp]
  0019e	99		 cdq
  0019f	2b c2		 sub	 eax, edx
  001a1	d1 f8		 sar	 eax, 1
  001a3	8b 4d e8	 mov	 ecx, DWORD PTR _dst_C$[ebp]
  001a6	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  001a9	89 55 d4	 mov	 DWORD PTR _C$[ebp], edx

; 1651 :             for (x = 0; x < width; x += 8, ycp += 24, ycpw += 24) {

  001ac	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _x$[ebp], 0
  001b3	eb 1b		 jmp	 SHORT $LN10@convert_yc
$LN8@convert_yc:
  001b5	8b 45 f8	 mov	 eax, DWORD PTR _x$[ebp]
  001b8	83 c0 08	 add	 eax, 8
  001bb	89 45 f8	 mov	 DWORD PTR _x$[ebp], eax
  001be	8b 4d e0	 mov	 ecx, DWORD PTR _ycp$[ebp]
  001c1	83 c1 30	 add	 ecx, 48			; 00000030H
  001c4	89 4d e0	 mov	 DWORD PTR _ycp$[ebp], ecx
  001c7	8b 55 dc	 mov	 edx, DWORD PTR _ycpw$[ebp]
  001ca	83 c2 30	 add	 edx, 48			; 00000030H
  001cd	89 55 dc	 mov	 DWORD PTR _ycpw$[ebp], edx
$LN10@convert_yc:
  001d0	8b 45 f8	 mov	 eax, DWORD PTR _x$[ebp]
  001d3	3b 43 10	 cmp	 eax, DWORD PTR _width$[ebx]
  001d6	0f 8d aa 03 00
	00		 jge	 $LN9@convert_yc

; 1652 :                 x1 = _mm_loadu_si128((__m128i *)(ycp +  0));

  001dc	8b 4d e0	 mov	 ecx, DWORD PTR _ycp$[ebp]
  001df	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  001e2	0f 29 85 b0 fe
	ff ff		 movaps	 XMMWORD PTR $T23[ebp], xmm0
  001e9	0f 28 85 b0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T23[ebp]
  001f0	0f 29 85 00 ff
	ff ff		 movaps	 XMMWORD PTR _x1$[ebp], xmm0

; 1653 :                 x2 = _mm_loadu_si128((__m128i *)(ycp +  8));

  001f7	8b 55 e0	 mov	 edx, DWORD PTR _ycp$[ebp]
  001fa	83 c2 10	 add	 edx, 16			; 00000010H
  001fd	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  00200	0f 29 85 a0 fe
	ff ff		 movaps	 XMMWORD PTR $T22[ebp], xmm0
  00207	0f 28 85 a0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T22[ebp]
  0020e	0f 29 85 e0 fe
	ff ff		 movaps	 XMMWORD PTR _x2$[ebp], xmm0

; 1654 :                 x3 = _mm_loadu_si128((__m128i *)(ycp + 16));

  00215	8b 45 e0	 mov	 eax, DWORD PTR _ycp$[ebp]
  00218	83 c0 20	 add	 eax, 32			; 00000020H
  0021b	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  0021e	0f 29 85 90 fe
	ff ff		 movaps	 XMMWORD PTR $T21[ebp], xmm0
  00225	0f 28 85 90 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T21[ebp]
  0022c	0f 29 85 c0 fe
	ff ff		 movaps	 XMMWORD PTR _x3$[ebp], xmm0

; 1655 :                 _mm_prefetch((const char *)ycpw, _MM_HINT_T1);

  00233	8b 4d dc	 mov	 ecx, DWORD PTR _ycpw$[ebp]
  00236	89 8d 4c fd ff
	ff		 mov	 DWORD PTR tv183[ebp], ecx
  0023c	8b 95 4c fd ff
	ff		 mov	 edx, DWORD PTR tv183[ebp]
  00242	0f 18 12	 prefetcht1 BYTE PTR [edx]

; 1656 :                 gather_y_uv_from_yc48(x1, x2, x3);

  00245	0f 28 85 c0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _x3$[ebp]
  0024c	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR _x2$[ebp]
  00252	50		 push	 eax
  00253	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR _x1$[ebp]
  00259	51		 push	 ecx
  0025a	e8 00 00 00 00	 call	 ?gather_y_uv_from_yc48@@YAXAAT__m128i@@0T1@@Z ; gather_y_uv_from_yc48
  0025f	83 c4 08	 add	 esp, 8

; 1657 :                 x0 = x2;

  00262	0f 28 85 e0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _x2$[ebp]
  00269	0f 29 85 20 ff
	ff ff		 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1658 :                 _mm_store_switch_si128((__m128i *)(Y + x), convert_y_range_from_yc48(x1, xC_Y_L_MA_16, Y_L_RSH_16, xC_YCC, xC_pw_one));

  00270	33 d2		 xor	 edx, edx
  00272	74 52		 je	 SHORT $LN12@convert_yc
  00274	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR ?Array_Y_L_MA_16@@3QBFB
  0027b	0f 29 85 80 fe
	ff ff		 movaps	 XMMWORD PTR $T20[ebp], xmm0
  00282	8d 45 c0	 lea	 eax, DWORD PTR _xC_pw_one$[ebp]
  00285	50		 push	 eax
  00286	8d 4d 80	 lea	 ecx, DWORD PTR _xC_YCC$[ebp]
  00289	51		 push	 ecx
  0028a	6a 04		 push	 4
  0028c	8d 95 80 fe ff
	ff		 lea	 edx, DWORD PTR $T20[ebp]
  00292	52		 push	 edx
  00293	0f 28 85 00 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$[ebp]
  0029a	e8 00 00 00 00	 call	 ?convert_y_range_from_yc48@@YA?AT__m128i@@T1@ABT1@H11@Z ; convert_y_range_from_yc48
  0029f	83 c4 10	 add	 esp, 16			; 00000010H
  002a2	0f 29 85 70 fe
	ff ff		 movaps	 XMMWORD PTR $T19[ebp], xmm0
  002a9	0f 28 85 70 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T19[ebp]
  002b0	8b 45 f8	 mov	 eax, DWORD PTR _x$[ebp]
  002b3	8b 4d d8	 mov	 ecx, DWORD PTR _Y$[ebp]
  002b6	0f 11 04 41	 movups	 XMMWORD PTR [ecx+eax*2], xmm0
  002ba	c7 85 48 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv214[ebp], 0
  002c4	eb 50		 jmp	 SHORT $LN13@convert_yc
$LN12@convert_yc:
  002c6	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR ?Array_Y_L_MA_16@@3QBFB
  002cd	0f 29 85 60 fe
	ff ff		 movaps	 XMMWORD PTR $T18[ebp], xmm0
  002d4	8d 55 c0	 lea	 edx, DWORD PTR _xC_pw_one$[ebp]
  002d7	52		 push	 edx
  002d8	8d 45 80	 lea	 eax, DWORD PTR _xC_YCC$[ebp]
  002db	50		 push	 eax
  002dc	6a 04		 push	 4
  002de	8d 8d 60 fe ff
	ff		 lea	 ecx, DWORD PTR $T18[ebp]
  002e4	51		 push	 ecx
  002e5	0f 28 85 00 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$[ebp]
  002ec	e8 00 00 00 00	 call	 ?convert_y_range_from_yc48@@YA?AT__m128i@@T1@ABT1@H11@Z ; convert_y_range_from_yc48
  002f1	83 c4 10	 add	 esp, 16			; 00000010H
  002f4	0f 29 85 50 fe
	ff ff		 movaps	 XMMWORD PTR $T17[ebp], xmm0
  002fb	0f 10 85 50 fe
	ff ff		 movups	 xmm0, XMMWORD PTR $T17[ebp]
  00302	8b 55 f8	 mov	 edx, DWORD PTR _x$[ebp]
  00305	8b 45 d8	 mov	 eax, DWORD PTR _Y$[ebp]
  00308	0f 11 04 50	 movups	 XMMWORD PTR [eax+edx*2], xmm0
  0030c	c7 85 48 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv214[ebp], 0
$LN13@convert_yc:

; 1659 : 
; 1660 :                 x1 = _mm_loadu_si128((__m128i *)(ycpw +  0));

  00316	8b 4d dc	 mov	 ecx, DWORD PTR _ycpw$[ebp]
  00319	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  0031c	0f 29 85 40 fe
	ff ff		 movaps	 XMMWORD PTR $T16[ebp], xmm0
  00323	0f 28 85 40 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T16[ebp]
  0032a	0f 29 85 00 ff
	ff ff		 movaps	 XMMWORD PTR _x1$[ebp], xmm0

; 1661 :                 x2 = _mm_loadu_si128((__m128i *)(ycpw +  8));

  00331	8b 55 dc	 mov	 edx, DWORD PTR _ycpw$[ebp]
  00334	83 c2 10	 add	 edx, 16			; 00000010H
  00337	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  0033a	0f 29 85 30 fe
	ff ff		 movaps	 XMMWORD PTR $T15[ebp], xmm0
  00341	0f 28 85 30 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T15[ebp]
  00348	0f 29 85 e0 fe
	ff ff		 movaps	 XMMWORD PTR _x2$[ebp], xmm0

; 1662 :                 x3 = _mm_loadu_si128((__m128i *)(ycpw + 16));

  0034f	8b 45 dc	 mov	 eax, DWORD PTR _ycpw$[ebp]
  00352	83 c0 20	 add	 eax, 32			; 00000020H
  00355	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00358	0f 29 85 20 fe
	ff ff		 movaps	 XMMWORD PTR $T14[ebp], xmm0
  0035f	0f 28 85 20 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T14[ebp]
  00366	0f 29 85 c0 fe
	ff ff		 movaps	 XMMWORD PTR _x3$[ebp], xmm0

; 1663 :                 gather_y_uv_from_yc48(x1, x2, x3);

  0036d	0f 28 85 c0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _x3$[ebp]
  00374	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR _x2$[ebp]
  0037a	51		 push	 ecx
  0037b	8d 95 00 ff ff
	ff		 lea	 edx, DWORD PTR _x1$[ebp]
  00381	52		 push	 edx
  00382	e8 00 00 00 00	 call	 ?gather_y_uv_from_yc48@@YAXAAT__m128i@@0T1@@Z ; gather_y_uv_from_yc48
  00387	83 c4 08	 add	 esp, 8

; 1664 :                 _mm_store_switch_si128((__m128i *)(Y + x + dst_y_pitch*2), convert_y_range_from_yc48(x1, xC_Y_L_MA_16, Y_L_RSH_16, xC_YCC, xC_pw_one));

  0038a	33 c0		 xor	 eax, eax
  0038c	74 5d		 je	 SHORT $LN14@convert_yc
  0038e	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR ?Array_Y_L_MA_16@@3QBFB
  00395	0f 29 85 10 fe
	ff ff		 movaps	 XMMWORD PTR $T13[ebp], xmm0
  0039c	8d 4d c0	 lea	 ecx, DWORD PTR _xC_pw_one$[ebp]
  0039f	51		 push	 ecx
  003a0	8d 55 80	 lea	 edx, DWORD PTR _xC_YCC$[ebp]
  003a3	52		 push	 edx
  003a4	6a 04		 push	 4
  003a6	8d 85 10 fe ff
	ff		 lea	 eax, DWORD PTR $T13[ebp]
  003ac	50		 push	 eax
  003ad	0f 28 85 00 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$[ebp]
  003b4	e8 00 00 00 00	 call	 ?convert_y_range_from_yc48@@YA?AT__m128i@@T1@ABT1@H11@Z ; convert_y_range_from_yc48
  003b9	83 c4 10	 add	 esp, 16			; 00000010H
  003bc	0f 29 85 00 fe
	ff ff		 movaps	 XMMWORD PTR $T12[ebp], xmm0
  003c3	0f 28 85 00 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T12[ebp]
  003ca	8b 4d f8	 mov	 ecx, DWORD PTR _x$[ebp]
  003cd	8b 55 d8	 mov	 edx, DWORD PTR _Y$[ebp]
  003d0	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  003d3	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  003d9	d1 e1		 shl	 ecx, 1
  003db	0f 11 04 48	 movups	 XMMWORD PTR [eax+ecx*2], xmm0
  003df	c7 85 44 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv259[ebp], 0
  003e9	eb 5b		 jmp	 SHORT $LN15@convert_yc
$LN14@convert_yc:
  003eb	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR ?Array_Y_L_MA_16@@3QBFB
  003f2	0f 29 85 f0 fd
	ff ff		 movaps	 XMMWORD PTR $T11[ebp], xmm0
  003f9	8d 55 c0	 lea	 edx, DWORD PTR _xC_pw_one$[ebp]
  003fc	52		 push	 edx
  003fd	8d 45 80	 lea	 eax, DWORD PTR _xC_YCC$[ebp]
  00400	50		 push	 eax
  00401	6a 04		 push	 4
  00403	8d 8d f0 fd ff
	ff		 lea	 ecx, DWORD PTR $T11[ebp]
  00409	51		 push	 ecx
  0040a	0f 28 85 00 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$[ebp]
  00411	e8 00 00 00 00	 call	 ?convert_y_range_from_yc48@@YA?AT__m128i@@T1@ABT1@H11@Z ; convert_y_range_from_yc48
  00416	83 c4 10	 add	 esp, 16			; 00000010H
  00419	0f 29 85 e0 fd
	ff ff		 movaps	 XMMWORD PTR $T10[ebp], xmm0
  00420	0f 10 85 e0 fd
	ff ff		 movups	 xmm0, XMMWORD PTR $T10[ebp]
  00427	8b 55 f8	 mov	 edx, DWORD PTR _x$[ebp]
  0042a	8b 45 d8	 mov	 eax, DWORD PTR _Y$[ebp]
  0042d	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00430	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  00436	d1 e2		 shl	 edx, 1
  00438	0f 11 04 51	 movups	 XMMWORD PTR [ecx+edx*2], xmm0
  0043c	c7 85 44 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv259[ebp], 0
$LN15@convert_yc:

; 1665 : 
; 1666 :                 _mm_store_switch_si128((__m128i *)(C + x), convert_uv_range_from_yc48_420i(x0, x2, _mm_set1_epi16(UV_OFFSET_x1), xC_UV_L_MA_16_420I(i), xC_UV_L_MA_16_420I((i+1)&0x01), UV_L_RSH_16_420I, xC_YCC, xC_pw_one));

  00446	33 c0		 xor	 eax, eax
  00448	0f 84 9c 00 00
	00		 je	 $LN16@convert_yc
  0044e	8b 4d f0	 mov	 ecx, DWORD PTR _i$[ebp]
  00451	83 c1 01	 add	 ecx, 1
  00454	83 e1 01	 and	 ecx, 1
  00457	c1 e1 05	 shl	 ecx, 5
  0045a	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?Array_UV_L_MA_16_420I@@3QAY0BA@$$CBFA
  00460	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00463	0f 29 85 b0 fd
	ff ff		 movaps	 XMMWORD PTR $T7[ebp], xmm0
  0046a	8b 55 f0	 mov	 edx, DWORD PTR _i$[ebp]
  0046d	c1 e2 05	 shl	 edx, 5
  00470	81 c2 00 00 00
	00		 add	 edx, OFFSET ?Array_UV_L_MA_16_420I@@3QAY0BA@$$CBFA
  00476	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  00479	0f 29 85 c0 fd
	ff ff		 movaps	 XMMWORD PTR $T8[ebp], xmm0
  00480	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@08000800080008000800080008000800
  00487	0f 29 85 d0 fd
	ff ff		 movaps	 XMMWORD PTR $T9[ebp], xmm0
  0048e	8d 45 c0	 lea	 eax, DWORD PTR _xC_pw_one$[ebp]
  00491	50		 push	 eax
  00492	8d 4d 80	 lea	 ecx, DWORD PTR _xC_YCC$[ebp]
  00495	51		 push	 ecx
  00496	6a 02		 push	 2
  00498	8d 95 b0 fd ff
	ff		 lea	 edx, DWORD PTR $T7[ebp]
  0049e	52		 push	 edx
  0049f	8d 85 c0 fd ff
	ff		 lea	 eax, DWORD PTR $T8[ebp]
  004a5	50		 push	 eax
  004a6	8d 8d d0 fd ff
	ff		 lea	 ecx, DWORD PTR $T9[ebp]
  004ac	51		 push	 ecx
  004ad	0f 28 8d e0 fe
	ff ff		 movaps	 xmm1, XMMWORD PTR _x2$[ebp]
  004b4	0f 28 85 20 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  004bb	e8 00 00 00 00	 call	 ?convert_uv_range_from_yc48_420i@@YA?AT__m128i@@T1@0ABT1@11H11@Z ; convert_uv_range_from_yc48_420i
  004c0	83 c4 18	 add	 esp, 24			; 00000018H
  004c3	0f 29 85 a0 fd
	ff ff		 movaps	 XMMWORD PTR $T6[ebp], xmm0
  004ca	0f 28 85 a0 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T6[ebp]
  004d1	8b 55 f8	 mov	 edx, DWORD PTR _x$[ebp]
  004d4	8b 45 d4	 mov	 eax, DWORD PTR _C$[ebp]
  004d7	0f 11 04 50	 movups	 XMMWORD PTR [eax+edx*2], xmm0
  004db	c7 85 40 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv315[ebp], 0
  004e5	e9 97 00 00 00	 jmp	 $LN17@convert_yc
$LN16@convert_yc:
  004ea	8b 4d f0	 mov	 ecx, DWORD PTR _i$[ebp]
  004ed	83 c1 01	 add	 ecx, 1
  004f0	83 e1 01	 and	 ecx, 1
  004f3	c1 e1 05	 shl	 ecx, 5
  004f6	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?Array_UV_L_MA_16_420I@@3QAY0BA@$$CBFA
  004fc	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  004ff	0f 29 85 70 fd
	ff ff		 movaps	 XMMWORD PTR $T3[ebp], xmm0
  00506	8b 55 f0	 mov	 edx, DWORD PTR _i$[ebp]
  00509	c1 e2 05	 shl	 edx, 5
  0050c	81 c2 00 00 00
	00		 add	 edx, OFFSET ?Array_UV_L_MA_16_420I@@3QAY0BA@$$CBFA
  00512	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  00515	0f 29 85 80 fd
	ff ff		 movaps	 XMMWORD PTR $T4[ebp], xmm0
  0051c	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@08000800080008000800080008000800
  00523	0f 29 85 90 fd
	ff ff		 movaps	 XMMWORD PTR $T5[ebp], xmm0
  0052a	8d 45 c0	 lea	 eax, DWORD PTR _xC_pw_one$[ebp]
  0052d	50		 push	 eax
  0052e	8d 4d 80	 lea	 ecx, DWORD PTR _xC_YCC$[ebp]
  00531	51		 push	 ecx
  00532	6a 02		 push	 2
  00534	8d 95 70 fd ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  0053a	52		 push	 edx
  0053b	8d 85 80 fd ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  00541	50		 push	 eax
  00542	8d 8d 90 fd ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  00548	51		 push	 ecx
  00549	0f 28 8d e0 fe
	ff ff		 movaps	 xmm1, XMMWORD PTR _x2$[ebp]
  00550	0f 28 85 20 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  00557	e8 00 00 00 00	 call	 ?convert_uv_range_from_yc48_420i@@YA?AT__m128i@@T1@0ABT1@11H11@Z ; convert_uv_range_from_yc48_420i
  0055c	83 c4 18	 add	 esp, 24			; 00000018H
  0055f	0f 29 85 60 fd
	ff ff		 movaps	 XMMWORD PTR $T2[ebp], xmm0
  00566	0f 10 85 60 fd
	ff ff		 movups	 xmm0, XMMWORD PTR $T2[ebp]
  0056d	8b 55 f8	 mov	 edx, DWORD PTR _x$[ebp]
  00570	8b 45 d4	 mov	 eax, DWORD PTR _C$[ebp]
  00573	0f 11 04 50	 movups	 XMMWORD PTR [eax+edx*2], xmm0
  00577	c7 85 40 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv315[ebp], 0
$LN17@convert_yc:

; 1667 :             }

  00581	e9 2f fc ff ff	 jmp	 $LN8@convert_yc
$LN9@convert_yc:

; 1668 :         }

  00586	e9 b3 fb ff ff	 jmp	 $LN5@convert_yc
$LN6@convert_yc:

; 1669 :     }

  0058b	e9 87 fb ff ff	 jmp	 $LN2@convert_yc
$LN1@convert_yc:

; 1670 : }

  00590	52		 push	 edx
  00591	8b cd		 mov	 ecx, ebp
  00593	50		 push	 eax
  00594	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN24@convert_yc
  0059a	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0059f	58		 pop	 eax
  005a0	5a		 pop	 edx
  005a1	5f		 pop	 edi
  005a2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005a5	33 cd		 xor	 ecx, ebp
  005a7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005ac	8b e5		 mov	 esp, ebp
  005ae	5d		 pop	 ebp
  005af	8b e3		 mov	 esp, ebx
  005b1	5b		 pop	 ebx
  005b2	c3		 ret	 0
  005b3	90		 npad	 1
$LN24@convert_yc:
  005b4	05 00 00 00	 DD	 5
  005b8	00 00 00 00	 DD	 $LN23@convert_yc
$LN23@convert_yc:
  005bc	c0 ff ff ff	 DD	 -64			; ffffffc0H
  005c0	10 00 00 00	 DD	 16			; 00000010H
  005c4	00 00 00 00	 DD	 $LN18@convert_yc
  005c8	80 ff ff ff	 DD	 -128			; ffffff80H
  005cc	10 00 00 00	 DD	 16			; 00000010H
  005d0	00 00 00 00	 DD	 $LN19@convert_yc
  005d4	4c ff ff ff	 DD	 -180			; ffffff4cH
  005d8	0c 00 00 00	 DD	 12			; 0000000cH
  005dc	00 00 00 00	 DD	 $LN20@convert_yc
  005e0	00 ff ff ff	 DD	 -256			; ffffff00H
  005e4	10 00 00 00	 DD	 16			; 00000010H
  005e8	00 00 00 00	 DD	 $LN21@convert_yc
  005ec	e0 fe ff ff	 DD	 -288			; fffffee0H
  005f0	10 00 00 00	 DD	 16			; 00000010H
  005f4	00 00 00 00	 DD	 $LN22@convert_yc
$LN22@convert_yc:
  005f8	78		 DB	 120			; 00000078H
  005f9	32		 DB	 50			; 00000032H
  005fa	00		 DB	 0
$LN21@convert_yc:
  005fb	78		 DB	 120			; 00000078H
  005fc	31		 DB	 49			; 00000031H
  005fd	00		 DB	 0
$LN20@convert_yc:
  005fe	79		 DB	 121			; 00000079H
  005ff	5f		 DB	 95			; 0000005fH
  00600	72		 DB	 114			; 00000072H
  00601	61		 DB	 97			; 00000061H
  00602	6e		 DB	 110			; 0000006eH
  00603	67		 DB	 103			; 00000067H
  00604	65		 DB	 101			; 00000065H
  00605	00		 DB	 0
$LN19@convert_yc:
  00606	78		 DB	 120			; 00000078H
  00607	43		 DB	 67			; 00000043H
  00608	5f		 DB	 95			; 0000005fH
  00609	59		 DB	 89			; 00000059H
  0060a	43		 DB	 67			; 00000043H
  0060b	43		 DB	 67			; 00000043H
  0060c	00		 DB	 0
$LN18@convert_yc:
  0060d	78		 DB	 120			; 00000078H
  0060e	43		 DB	 67			; 00000043H
  0060f	5f		 DB	 95			; 0000005fH
  00610	70		 DB	 112			; 00000070H
  00611	77		 DB	 119			; 00000077H
  00612	5f		 DB	 95			; 0000005fH
  00613	6f		 DB	 111			; 0000006fH
  00614	6e		 DB	 110			; 0000006eH
  00615	65		 DB	 101			; 00000065H
  00616	00		 DB	 0
??$convert_yc48_to_p010_i_simd@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yc48_to_p010_i_simd<0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_sse2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yc48_to_p010_i_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yc48_to_p010_i_sse2

; 149  : void convert_yc48_to_p010_i_sse2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 150  :     convert_yc48_to_p010_i_simd<false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yc48_to_p010_i_simd@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yc48_to_p010_i_simd<0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 151  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yc48_to_p010_i_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yc48_to_p010_i_sse2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
tv273 = -624						; size = 4
tv250 = -620						; size = 4
tv207 = -616						; size = 4
tv144 = -612						; size = 4
$T1 = -608						; size = 12
$T2 = -592						; size = 16
$T3 = -576						; size = 16
$T4 = -560						; size = 16
$T5 = -544						; size = 16
$T6 = -528						; size = 16
$T7 = -512						; size = 16
$T8 = -496						; size = 16
$T9 = -480						; size = 16
$T10 = -464						; size = 16
$T11 = -448						; size = 16
$T12 = -432						; size = 16
$T13 = -416						; size = 16
$T14 = -400						; size = 16
$T15 = -384						; size = 16
$T16 = -368						; size = 16
$T17 = -352						; size = 16
$T18 = -336						; size = 16
_x3$ = -320						; size = 16
_x2$ = -288						; size = 16
_x1$ = -256						; size = 16
_x0$ = -224						; size = 16
_dst_y_pitch$ = -196					; size = 4
$T19 = -192						; size = 16
_xC_YCC$ = -160						; size = 16
$T20 = -128						; size = 16
_xC_pw_one$ = -96					; size = 16
_C$ = -72						; size = 4
_Y$ = -68						; size = 4
_ycpw$ = -64						; size = 4
_ycp$ = -60						; size = 4
_pixel$ = -56						; size = 4
_dst_C$ = -52						; size = 4
_dst_Y$ = -48						; size = 4
$T21 = -44						; size = 12
_y_range$ = -28						; size = 12
_y$ = -12						; size = 4
_x$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yc48_to_p010_simd@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yc48_to_p010_simd<0>

; 1591 : static __forceinline void convert_yc48_to_p010_simd(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 70 02 00
	00		 sub	 esp, 624		; 00000270H
  0001c	57		 push	 edi
  0001d	8d bd 90 fd ff
	ff		 lea	 edi, DWORD PTR [ebp-624]
  00023	b9 9c 00 00 00	 mov	 ecx, 156		; 0000009cH
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1592 :     int x, y;
; 1593 :     const auto y_range = thread_y_range(0, height, thread_id, thread_n);

  00039	8b 43 2c	 mov	 eax, DWORD PTR _thread_n$[ebx]
  0003c	50		 push	 eax
  0003d	8b 4b 28	 mov	 ecx, DWORD PTR _thread_id$[ebx]
  00040	51		 push	 ecx
  00041	8b 53 20	 mov	 edx, DWORD PTR _height$[ebx]
  00044	52		 push	 edx
  00045	6a 00		 push	 0
  00047	8d 85 a0 fd ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00053	83 c4 14	 add	 esp, 20			; 00000014H
  00056	8b 08		 mov	 ecx, DWORD PTR [eax]
  00058	89 4d d4	 mov	 DWORD PTR $T21[ebp], ecx
  0005b	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0005e	89 55 d8	 mov	 DWORD PTR $T21[ebp+4], edx
  00061	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00064	89 45 dc	 mov	 DWORD PTR $T21[ebp+8], eax
  00067	8b 4d d4	 mov	 ecx, DWORD PTR $T21[ebp]
  0006a	89 4d e4	 mov	 DWORD PTR _y_range$[ebp], ecx
  0006d	8b 55 d8	 mov	 edx, DWORD PTR $T21[ebp+4]
  00070	89 55 e8	 mov	 DWORD PTR _y_range$[ebp+4], edx
  00073	8b 45 dc	 mov	 eax, DWORD PTR $T21[ebp+8]
  00076	89 45 ec	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 1594 :     short *dst_Y = (short *)dst[0];

  00079	b9 04 00 00 00	 mov	 ecx, 4
  0007e	6b d1 00	 imul	 edx, ecx, 0
  00081	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  00084	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00087	89 4d d0	 mov	 DWORD PTR _dst_Y$[ebp], ecx

; 1595 :     short *dst_C = (short *)dst[1];

  0008a	ba 04 00 00 00	 mov	 edx, 4
  0008f	c1 e2 00	 shl	 edx, 0
  00092	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  00095	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00098	89 4d cc	 mov	 DWORD PTR _dst_C$[ebp], ecx

; 1596 :     const void  *pixel = src[0];

  0009b	ba 04 00 00 00	 mov	 edx, 4
  000a0	6b c2 00	 imul	 eax, edx, 0
  000a3	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  000a6	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  000a9	89 55 c8	 mov	 DWORD PTR _pixel$[ebp], edx

; 1597 :     const short *ycp, *ycpw;
; 1598 :     short *Y = NULL, *C = NULL;

  000ac	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _Y$[ebp], 0
  000b3	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _C$[ebp], 0

; 1599 :     const __m128i xC_pw_one = _mm_set1_epi16(1);

  000ba	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@00010001000100010001000100010001
  000c1	0f 29 45 80	 movaps	 XMMWORD PTR $T20[ebp], xmm0
  000c5	0f 28 45 80	 movaps	 xmm0, XMMWORD PTR $T20[ebp]
  000c9	0f 29 45 a0	 movaps	 XMMWORD PTR _xC_pw_one$[ebp], xmm0

; 1600 :     const __m128i xC_YCC = _mm_set1_epi32(1<<LSFT_YCC_16);

  000cd	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@00001000000010000000100000001000
  000d4	0f 29 85 40 ff
	ff ff		 movaps	 XMMWORD PTR $T19[ebp], xmm0
  000db	0f 28 85 40 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T19[ebp]
  000e2	0f 29 85 60 ff
	ff ff		 movaps	 XMMWORD PTR _xC_YCC$[ebp], xmm0

; 1601 :     const int dst_y_pitch = dst_y_pitch_byte >> 1;

  000e9	8b 43 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  000ec	d1 f8		 sar	 eax, 1
  000ee	89 85 3c ff ff
	ff		 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 1602 :     __m128i x0, x1, x2, x3;
; 1603 :     for (y = y_range.start_src; y < (y_range.start_src + y_range.len); y += 2) {

  000f4	8b 4d e4	 mov	 ecx, DWORD PTR _y_range$[ebp]
  000f7	89 4d f4	 mov	 DWORD PTR _y$[ebp], ecx
  000fa	eb 09		 jmp	 SHORT $LN4@convert_yc
$LN2@convert_yc:
  000fc	8b 55 f4	 mov	 edx, DWORD PTR _y$[ebp]
  000ff	83 c2 02	 add	 edx, 2
  00102	89 55 f4	 mov	 DWORD PTR _y$[ebp], edx
$LN4@convert_yc:
  00105	8b 45 e4	 mov	 eax, DWORD PTR _y_range$[ebp]
  00108	03 45 ec	 add	 eax, DWORD PTR _y_range$[ebp+8]
  0010b	39 45 f4	 cmp	 DWORD PTR _y$[ebp], eax
  0010e	0f 8d 95 03 00
	00		 jge	 $LN1@convert_yc

; 1604 :         ycp = (short*)pixel + width * y * 3;

  00114	8b 4b 10	 mov	 ecx, DWORD PTR _width$[ebx]
  00117	0f af 4d f4	 imul	 ecx, DWORD PTR _y$[ebp]
  0011b	6b d1 03	 imul	 edx, ecx, 3
  0011e	8b 45 c8	 mov	 eax, DWORD PTR _pixel$[ebp]
  00121	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00124	89 4d c4	 mov	 DWORD PTR _ycp$[ebp], ecx

; 1605 :         ycpw= ycp + width*3;

  00127	6b 53 10 03	 imul	 edx, DWORD PTR _width$[ebx], 3
  0012b	8b 45 c4	 mov	 eax, DWORD PTR _ycp$[ebp]
  0012e	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00131	89 4d c0	 mov	 DWORD PTR _ycpw$[ebp], ecx

; 1606 :         Y   = dst_Y + dst_y_pitch * y;

  00134	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  0013a	0f af 55 f4	 imul	 edx, DWORD PTR _y$[ebp]
  0013e	8b 45 d0	 mov	 eax, DWORD PTR _dst_Y$[ebp]
  00141	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00144	89 4d bc	 mov	 DWORD PTR _Y$[ebp], ecx

; 1607 :         C   = dst_C + dst_y_pitch * y / 2;

  00147	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  0014d	0f af 45 f4	 imul	 eax, DWORD PTR _y$[ebp]
  00151	99		 cdq
  00152	2b c2		 sub	 eax, edx
  00154	d1 f8		 sar	 eax, 1
  00156	8b 55 cc	 mov	 edx, DWORD PTR _dst_C$[ebp]
  00159	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  0015c	89 45 b8	 mov	 DWORD PTR _C$[ebp], eax

; 1608 :         for (x = 0; x < width; x += 8, ycp += 24, ycpw += 24) {

  0015f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _x$[ebp], 0
  00166	eb 1b		 jmp	 SHORT $LN7@convert_yc
$LN5@convert_yc:
  00168	8b 4d f8	 mov	 ecx, DWORD PTR _x$[ebp]
  0016b	83 c1 08	 add	 ecx, 8
  0016e	89 4d f8	 mov	 DWORD PTR _x$[ebp], ecx
  00171	8b 55 c4	 mov	 edx, DWORD PTR _ycp$[ebp]
  00174	83 c2 30	 add	 edx, 48			; 00000030H
  00177	89 55 c4	 mov	 DWORD PTR _ycp$[ebp], edx
  0017a	8b 45 c0	 mov	 eax, DWORD PTR _ycpw$[ebp]
  0017d	83 c0 30	 add	 eax, 48			; 00000030H
  00180	89 45 c0	 mov	 DWORD PTR _ycpw$[ebp], eax
$LN7@convert_yc:
  00183	8b 4d f8	 mov	 ecx, DWORD PTR _x$[ebp]
  00186	3b 4b 10	 cmp	 ecx, DWORD PTR _width$[ebx]
  00189	0f 8d 15 03 00
	00		 jge	 $LN6@convert_yc

; 1609 :             x1 = _mm_loadu_si128((__m128i *)(ycp +  0));

  0018f	8b 55 c4	 mov	 edx, DWORD PTR _ycp$[ebp]
  00192	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  00195	0f 29 85 b0 fe
	ff ff		 movaps	 XMMWORD PTR $T18[ebp], xmm0
  0019c	0f 28 85 b0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T18[ebp]
  001a3	0f 29 85 00 ff
	ff ff		 movaps	 XMMWORD PTR _x1$[ebp], xmm0

; 1610 :             x2 = _mm_loadu_si128((__m128i *)(ycp +  8));

  001aa	8b 45 c4	 mov	 eax, DWORD PTR _ycp$[ebp]
  001ad	83 c0 10	 add	 eax, 16			; 00000010H
  001b0	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  001b3	0f 29 85 a0 fe
	ff ff		 movaps	 XMMWORD PTR $T17[ebp], xmm0
  001ba	0f 28 85 a0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T17[ebp]
  001c1	0f 29 85 e0 fe
	ff ff		 movaps	 XMMWORD PTR _x2$[ebp], xmm0

; 1611 :             x3 = _mm_loadu_si128((__m128i *)(ycp + 16));

  001c8	8b 4d c4	 mov	 ecx, DWORD PTR _ycp$[ebp]
  001cb	83 c1 20	 add	 ecx, 32			; 00000020H
  001ce	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  001d1	0f 29 85 90 fe
	ff ff		 movaps	 XMMWORD PTR $T16[ebp], xmm0
  001d8	0f 28 85 90 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T16[ebp]
  001df	0f 29 85 c0 fe
	ff ff		 movaps	 XMMWORD PTR _x3$[ebp], xmm0

; 1612 :             _mm_prefetch((const char *)ycpw, _MM_HINT_T1);

  001e6	8b 55 c0	 mov	 edx, DWORD PTR _ycpw$[ebp]
  001e9	89 95 9c fd ff
	ff		 mov	 DWORD PTR tv144[ebp], edx
  001ef	8b 85 9c fd ff
	ff		 mov	 eax, DWORD PTR tv144[ebp]
  001f5	0f 18 10	 prefetcht1 BYTE PTR [eax]

; 1613 :             gather_y_uv_from_yc48(x1, x2, x3);

  001f8	0f 28 85 c0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _x3$[ebp]
  001ff	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR _x2$[ebp]
  00205	51		 push	 ecx
  00206	8d 95 00 ff ff
	ff		 lea	 edx, DWORD PTR _x1$[ebp]
  0020c	52		 push	 edx
  0020d	e8 00 00 00 00	 call	 ?gather_y_uv_from_yc48@@YAXAAT__m128i@@0T1@@Z ; gather_y_uv_from_yc48
  00212	83 c4 08	 add	 esp, 8

; 1614 :             x0 = x2;

  00215	0f 28 85 e0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _x2$[ebp]
  0021c	0f 29 85 20 ff
	ff ff		 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1615 : 
; 1616 :             _mm_store_switch_si128((__m128i *)(Y + x), convert_y_range_from_yc48(x1, xC_Y_L_MA_16, Y_L_RSH_16, xC_YCC, xC_pw_one));

  00223	33 c0		 xor	 eax, eax
  00225	74 55		 je	 SHORT $LN9@convert_yc
  00227	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR ?Array_Y_L_MA_16@@3QBFB
  0022e	0f 29 85 80 fe
	ff ff		 movaps	 XMMWORD PTR $T15[ebp], xmm0
  00235	8d 4d a0	 lea	 ecx, DWORD PTR _xC_pw_one$[ebp]
  00238	51		 push	 ecx
  00239	8d 95 60 ff ff
	ff		 lea	 edx, DWORD PTR _xC_YCC$[ebp]
  0023f	52		 push	 edx
  00240	6a 04		 push	 4
  00242	8d 85 80 fe ff
	ff		 lea	 eax, DWORD PTR $T15[ebp]
  00248	50		 push	 eax
  00249	0f 28 85 00 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$[ebp]
  00250	e8 00 00 00 00	 call	 ?convert_y_range_from_yc48@@YA?AT__m128i@@T1@ABT1@H11@Z ; convert_y_range_from_yc48
  00255	83 c4 10	 add	 esp, 16			; 00000010H
  00258	0f 29 85 70 fe
	ff ff		 movaps	 XMMWORD PTR $T14[ebp], xmm0
  0025f	0f 28 85 70 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T14[ebp]
  00266	8b 4d f8	 mov	 ecx, DWORD PTR _x$[ebp]
  00269	8b 55 bc	 mov	 edx, DWORD PTR _Y$[ebp]
  0026c	0f 11 04 4a	 movups	 XMMWORD PTR [edx+ecx*2], xmm0
  00270	c7 85 98 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv207[ebp], 0
  0027a	eb 53		 jmp	 SHORT $LN10@convert_yc
$LN9@convert_yc:
  0027c	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR ?Array_Y_L_MA_16@@3QBFB
  00283	0f 29 85 60 fe
	ff ff		 movaps	 XMMWORD PTR $T13[ebp], xmm0
  0028a	8d 45 a0	 lea	 eax, DWORD PTR _xC_pw_one$[ebp]
  0028d	50		 push	 eax
  0028e	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR _xC_YCC$[ebp]
  00294	51		 push	 ecx
  00295	6a 04		 push	 4
  00297	8d 95 60 fe ff
	ff		 lea	 edx, DWORD PTR $T13[ebp]
  0029d	52		 push	 edx
  0029e	0f 28 85 00 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$[ebp]
  002a5	e8 00 00 00 00	 call	 ?convert_y_range_from_yc48@@YA?AT__m128i@@T1@ABT1@H11@Z ; convert_y_range_from_yc48
  002aa	83 c4 10	 add	 esp, 16			; 00000010H
  002ad	0f 29 85 50 fe
	ff ff		 movaps	 XMMWORD PTR $T12[ebp], xmm0
  002b4	0f 10 85 50 fe
	ff ff		 movups	 xmm0, XMMWORD PTR $T12[ebp]
  002bb	8b 45 f8	 mov	 eax, DWORD PTR _x$[ebp]
  002be	8b 4d bc	 mov	 ecx, DWORD PTR _Y$[ebp]
  002c1	0f 11 04 41	 movups	 XMMWORD PTR [ecx+eax*2], xmm0
  002c5	c7 85 98 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv207[ebp], 0
$LN10@convert_yc:

; 1617 : 
; 1618 :             x1 = _mm_loadu_si128((__m128i *)(ycpw +  0));

  002cf	8b 55 c0	 mov	 edx, DWORD PTR _ycpw$[ebp]
  002d2	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  002d5	0f 29 85 40 fe
	ff ff		 movaps	 XMMWORD PTR $T11[ebp], xmm0
  002dc	0f 28 85 40 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T11[ebp]
  002e3	0f 29 85 00 ff
	ff ff		 movaps	 XMMWORD PTR _x1$[ebp], xmm0

; 1619 :             x2 = _mm_loadu_si128((__m128i *)(ycpw +  8));

  002ea	8b 45 c0	 mov	 eax, DWORD PTR _ycpw$[ebp]
  002ed	83 c0 10	 add	 eax, 16			; 00000010H
  002f0	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  002f3	0f 29 85 30 fe
	ff ff		 movaps	 XMMWORD PTR $T10[ebp], xmm0
  002fa	0f 28 85 30 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T10[ebp]
  00301	0f 29 85 e0 fe
	ff ff		 movaps	 XMMWORD PTR _x2$[ebp], xmm0

; 1620 :             x3 = _mm_loadu_si128((__m128i *)(ycpw + 16));

  00308	8b 4d c0	 mov	 ecx, DWORD PTR _ycpw$[ebp]
  0030b	83 c1 20	 add	 ecx, 32			; 00000020H
  0030e	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00311	0f 29 85 20 fe
	ff ff		 movaps	 XMMWORD PTR $T9[ebp], xmm0
  00318	0f 28 85 20 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T9[ebp]
  0031f	0f 29 85 c0 fe
	ff ff		 movaps	 XMMWORD PTR _x3$[ebp], xmm0

; 1621 :             gather_y_uv_from_yc48(x1, x2, x3);

  00326	0f 28 85 c0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _x3$[ebp]
  0032d	8d 95 e0 fe ff
	ff		 lea	 edx, DWORD PTR _x2$[ebp]
  00333	52		 push	 edx
  00334	8d 85 00 ff ff
	ff		 lea	 eax, DWORD PTR _x1$[ebp]
  0033a	50		 push	 eax
  0033b	e8 00 00 00 00	 call	 ?gather_y_uv_from_yc48@@YAXAAT__m128i@@0T1@@Z ; gather_y_uv_from_yc48
  00340	83 c4 08	 add	 esp, 8

; 1622 : 
; 1623 :             _mm_store_switch_si128((__m128i *)(Y + x + dst_y_pitch), convert_y_range_from_yc48(x1, xC_Y_L_MA_16, Y_L_RSH_16, xC_YCC, xC_pw_one));

  00343	33 c9		 xor	 ecx, ecx
  00345	74 5e		 je	 SHORT $LN11@convert_yc
  00347	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR ?Array_Y_L_MA_16@@3QBFB
  0034e	0f 29 85 10 fe
	ff ff		 movaps	 XMMWORD PTR $T8[ebp], xmm0
  00355	8d 55 a0	 lea	 edx, DWORD PTR _xC_pw_one$[ebp]
  00358	52		 push	 edx
  00359	8d 85 60 ff ff
	ff		 lea	 eax, DWORD PTR _xC_YCC$[ebp]
  0035f	50		 push	 eax
  00360	6a 04		 push	 4
  00362	8d 8d 10 fe ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp]
  00368	51		 push	 ecx
  00369	0f 28 85 00 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$[ebp]
  00370	e8 00 00 00 00	 call	 ?convert_y_range_from_yc48@@YA?AT__m128i@@T1@ABT1@H11@Z ; convert_y_range_from_yc48
  00375	83 c4 10	 add	 esp, 16			; 00000010H
  00378	0f 29 85 00 fe
	ff ff		 movaps	 XMMWORD PTR $T7[ebp], xmm0
  0037f	0f 28 85 00 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T7[ebp]
  00386	8b 55 f8	 mov	 edx, DWORD PTR _x$[ebp]
  00389	8b 45 bc	 mov	 eax, DWORD PTR _Y$[ebp]
  0038c	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  0038f	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  00395	0f 11 04 51	 movups	 XMMWORD PTR [ecx+edx*2], xmm0
  00399	c7 85 94 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv250[ebp], 0
  003a3	eb 5c		 jmp	 SHORT $LN12@convert_yc
$LN11@convert_yc:
  003a5	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR ?Array_Y_L_MA_16@@3QBFB
  003ac	0f 29 85 f0 fd
	ff ff		 movaps	 XMMWORD PTR $T6[ebp], xmm0
  003b3	8d 45 a0	 lea	 eax, DWORD PTR _xC_pw_one$[ebp]
  003b6	50		 push	 eax
  003b7	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR _xC_YCC$[ebp]
  003bd	51		 push	 ecx
  003be	6a 04		 push	 4
  003c0	8d 95 f0 fd ff
	ff		 lea	 edx, DWORD PTR $T6[ebp]
  003c6	52		 push	 edx
  003c7	0f 28 85 00 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$[ebp]
  003ce	e8 00 00 00 00	 call	 ?convert_y_range_from_yc48@@YA?AT__m128i@@T1@ABT1@H11@Z ; convert_y_range_from_yc48
  003d3	83 c4 10	 add	 esp, 16			; 00000010H
  003d6	0f 29 85 e0 fd
	ff ff		 movaps	 XMMWORD PTR $T5[ebp], xmm0
  003dd	0f 10 85 e0 fd
	ff ff		 movups	 xmm0, XMMWORD PTR $T5[ebp]
  003e4	8b 45 f8	 mov	 eax, DWORD PTR _x$[ebp]
  003e7	8b 4d bc	 mov	 ecx, DWORD PTR _Y$[ebp]
  003ea	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  003ed	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  003f3	0f 11 04 42	 movups	 XMMWORD PTR [edx+eax*2], xmm0
  003f7	c7 85 94 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv250[ebp], 0
$LN12@convert_yc:

; 1624 : 
; 1625 :             x0 = convert_uv_range_from_yc48_yuv420p(x0, x2, _mm_set1_epi16(UV_OFFSET_x2), xC_UV_L_MA_16_420P, UV_L_RSH_16_420P, xC_YCC, xC_pw_one);

  00401	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR ?Array_UV_L_MA_16_420P@@3QBFB
  00408	0f 29 85 c0 fd
	ff ff		 movaps	 XMMWORD PTR $T3[ebp], xmm0
  0040f	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@10001000100010001000100010001000
  00416	0f 29 85 d0 fd
	ff ff		 movaps	 XMMWORD PTR $T4[ebp], xmm0
  0041d	8d 4d a0	 lea	 ecx, DWORD PTR _xC_pw_one$[ebp]
  00420	51		 push	 ecx
  00421	8d 95 60 ff ff
	ff		 lea	 edx, DWORD PTR _xC_YCC$[ebp]
  00427	52		 push	 edx
  00428	6a 01		 push	 1
  0042a	8d 85 c0 fd ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  00430	50		 push	 eax
  00431	8d 8d d0 fd ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  00437	51		 push	 ecx
  00438	0f 28 8d e0 fe
	ff ff		 movaps	 xmm1, XMMWORD PTR _x2$[ebp]
  0043f	0f 28 85 20 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  00446	e8 00 00 00 00	 call	 ?convert_uv_range_from_yc48_yuv420p@@YA?AT__m128i@@T1@0ABT1@1H11@Z ; convert_uv_range_from_yc48_yuv420p
  0044b	83 c4 14	 add	 esp, 20			; 00000014H
  0044e	0f 29 85 b0 fd
	ff ff		 movaps	 XMMWORD PTR $T2[ebp], xmm0
  00455	0f 28 85 b0 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T2[ebp]
  0045c	0f 29 85 20 ff
	ff ff		 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1626 : 
; 1627 :             _mm_store_switch_si128((__m128i *)(C + x), x0);

  00463	33 d2		 xor	 edx, edx
  00465	74 1d		 je	 SHORT $LN13@convert_yc
  00467	0f 28 85 20 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  0046e	8b 45 f8	 mov	 eax, DWORD PTR _x$[ebp]
  00471	8b 4d b8	 mov	 ecx, DWORD PTR _C$[ebp]
  00474	0f 11 04 41	 movups	 XMMWORD PTR [ecx+eax*2], xmm0
  00478	c7 85 90 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv273[ebp], 0
  00482	eb 1b		 jmp	 SHORT $LN14@convert_yc
$LN13@convert_yc:
  00484	0f 10 85 20 ff
	ff ff		 movups	 xmm0, XMMWORD PTR _x0$[ebp]
  0048b	8b 55 f8	 mov	 edx, DWORD PTR _x$[ebp]
  0048e	8b 45 b8	 mov	 eax, DWORD PTR _C$[ebp]
  00491	0f 11 04 50	 movups	 XMMWORD PTR [eax+edx*2], xmm0
  00495	c7 85 90 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv273[ebp], 0
$LN14@convert_yc:

; 1628 :         }

  0049f	e9 c4 fc ff ff	 jmp	 $LN5@convert_yc
$LN6@convert_yc:

; 1629 :     }

  004a4	e9 53 fc ff ff	 jmp	 $LN2@convert_yc
$LN1@convert_yc:

; 1630 : }

  004a9	52		 push	 edx
  004aa	8b cd		 mov	 ecx, ebp
  004ac	50		 push	 eax
  004ad	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN21@convert_yc
  004b3	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  004b8	58		 pop	 eax
  004b9	5a		 pop	 edx
  004ba	5f		 pop	 edi
  004bb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004be	33 cd		 xor	 ecx, ebp
  004c0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004c5	8b e5		 mov	 esp, ebp
  004c7	5d		 pop	 ebp
  004c8	8b e3		 mov	 esp, ebx
  004ca	5b		 pop	 ebx
  004cb	c3		 ret	 0
$LN21@convert_yc:
  004cc	05 00 00 00	 DD	 5
  004d0	00 00 00 00	 DD	 $LN20@convert_yc
$LN20@convert_yc:
  004d4	e4 ff ff ff	 DD	 -28			; ffffffe4H
  004d8	0c 00 00 00	 DD	 12			; 0000000cH
  004dc	00 00 00 00	 DD	 $LN15@convert_yc
  004e0	a0 ff ff ff	 DD	 -96			; ffffffa0H
  004e4	10 00 00 00	 DD	 16			; 00000010H
  004e8	00 00 00 00	 DD	 $LN16@convert_yc
  004ec	60 ff ff ff	 DD	 -160			; ffffff60H
  004f0	10 00 00 00	 DD	 16			; 00000010H
  004f4	00 00 00 00	 DD	 $LN17@convert_yc
  004f8	00 ff ff ff	 DD	 -256			; ffffff00H
  004fc	10 00 00 00	 DD	 16			; 00000010H
  00500	00 00 00 00	 DD	 $LN18@convert_yc
  00504	e0 fe ff ff	 DD	 -288			; fffffee0H
  00508	10 00 00 00	 DD	 16			; 00000010H
  0050c	00 00 00 00	 DD	 $LN19@convert_yc
$LN19@convert_yc:
  00510	78		 DB	 120			; 00000078H
  00511	32		 DB	 50			; 00000032H
  00512	00		 DB	 0
$LN18@convert_yc:
  00513	78		 DB	 120			; 00000078H
  00514	31		 DB	 49			; 00000031H
  00515	00		 DB	 0
$LN17@convert_yc:
  00516	78		 DB	 120			; 00000078H
  00517	43		 DB	 67			; 00000043H
  00518	5f		 DB	 95			; 0000005fH
  00519	59		 DB	 89			; 00000059H
  0051a	43		 DB	 67			; 00000043H
  0051b	43		 DB	 67			; 00000043H
  0051c	00		 DB	 0
$LN16@convert_yc:
  0051d	78		 DB	 120			; 00000078H
  0051e	43		 DB	 67			; 00000043H
  0051f	5f		 DB	 95			; 0000005fH
  00520	70		 DB	 112			; 00000070H
  00521	77		 DB	 119			; 00000077H
  00522	5f		 DB	 95			; 0000005fH
  00523	6f		 DB	 111			; 0000006fH
  00524	6e		 DB	 110			; 0000006eH
  00525	65		 DB	 101			; 00000065H
  00526	00		 DB	 0
$LN15@convert_yc:
  00527	79		 DB	 121			; 00000079H
  00528	5f		 DB	 95			; 0000005fH
  00529	72		 DB	 114			; 00000072H
  0052a	61		 DB	 97			; 00000061H
  0052b	6e		 DB	 110			; 0000006eH
  0052c	67		 DB	 103			; 00000067H
  0052d	65		 DB	 101			; 00000065H
  0052e	00		 DB	 0
??$convert_yc48_to_p010_simd@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yc48_to_p010_simd<0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_sse2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yc48_to_p010_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yc48_to_p010_sse2

; 145  : void convert_yc48_to_p010_sse2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 146  :     convert_yc48_to_p010_simd<false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yc48_to_p010_simd@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yc48_to_p010_simd<0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 147  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yc48_to_p010_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yc48_to_p010_sse2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -416						; size = 12
$T2 = -400						; size = 12
$T3 = -384						; size = 16
$T4 = -368						; size = 16
$T5 = -352						; size = 16
$T6 = -336						; size = 16
$T7 = -320						; size = 16
$T8 = -304						; size = 16
_x$9 = -276						; size = 4
_x2$10 = -272						; size = 16
_x1$11 = -256						; size = 16
_x0$12 = -240						; size = 16
_dst_ptr$13 = -212					; size = 4
_src_v_ptr$14 = -208					; size = 4
_src_u_ptr$15 = -204					; size = 4
_x_fin$16 = -200					; size = 4
_y$17 = -196						; size = 4
_dstLine$ = -192					; size = 4
_srcVLine$ = -188					; size = 4
_srcULine$ = -184					; size = 4
_src_uv_pitch$ = -180					; size = 4
$T18 = -176						; size = 12
_uv_range$ = -160					; size = 12
$T19 = -144						; size = 16
$T20 = -128						; size = 16
_x0$21 = -112						; size = 16
_x$22 = -88						; size = 4
_dst_ptr$23 = -84					; size = 4
_src_ptr$24 = -80					; size = 4
_y$25 = -76						; size = 4
_y_width$26 = -72					; size = 4
_dstLine$27 = -68					; size = 4
_srcYLine$28 = -64					; size = 4
$T29 = -60						; size = 12
_y_range$30 = -44					; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yv12_high_to_p010_simd@$08$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_high_to_p010_simd<9,0>

; 1036 : static void __forceinline convert_yv12_high_to_p010_simd(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec a0 01 00
	00		 sub	 esp, 416		; 000001a0H
  0001c	57		 push	 edi
  0001d	8d bd 60 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-416]
  00023	b9 68 00 00 00	 mov	 ecx, 104		; 00000068H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1037 :     static_assert(8 < in_bit_depth && in_bit_depth <= 16, "in_bit_depth must be 9-16.");
; 1038 :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 1039 :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 1040 :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 1041 :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 1042 :     const int src_y_pitch = src_y_pitch_byte >> 1;

  0007c	8b 53 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  0007f	d1 fa		 sar	 edx, 1
  00081	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 1043 :     const int dst_y_pitch = dst_y_pitch_byte >> 1;

  00084	8b 43 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  00087	d1 f8		 sar	 eax, 1
  00089	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 1044 :     //Y成分のコピー
; 1045 :     if (!uv_only) {

  0008c	b9 01 00 00 00	 mov	 ecx, 1
  00091	85 c9		 test	 ecx, ecx
  00093	0f 84 55 01 00
	00		 je	 $LN14@convert_yv

; 1046 :         const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00099	8b 53 2c	 mov	 edx, DWORD PTR _thread_n$[ebx]
  0009c	52		 push	 edx
  0009d	8b 43 28	 mov	 eax, DWORD PTR _thread_id$[ebx]
  000a0	50		 push	 eax
  000a1	8b 4b 20	 mov	 ecx, DWORD PTR _height$[ebx]
  000a4	2b 4d ec	 sub	 ecx, DWORD PTR _crop_bottom$[ebp]
  000a7	51		 push	 ecx
  000a8	8b 55 f4	 mov	 edx, DWORD PTR _crop_up$[ebp]
  000ab	52		 push	 edx
  000ac	8d 85 70 fe ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  000b2	50		 push	 eax
  000b3	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  000b8	83 c4 14	 add	 esp, 20			; 00000014H
  000bb	8b 08		 mov	 ecx, DWORD PTR [eax]
  000bd	89 4d c4	 mov	 DWORD PTR $T29[ebp], ecx
  000c0	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000c3	89 55 c8	 mov	 DWORD PTR $T29[ebp+4], edx
  000c6	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000c9	89 45 cc	 mov	 DWORD PTR $T29[ebp+8], eax
  000cc	8b 4d c4	 mov	 ecx, DWORD PTR $T29[ebp]
  000cf	89 4d d4	 mov	 DWORD PTR _y_range$30[ebp], ecx
  000d2	8b 55 c8	 mov	 edx, DWORD PTR $T29[ebp+4]
  000d5	89 55 d8	 mov	 DWORD PTR _y_range$30[ebp+4], edx
  000d8	8b 45 cc	 mov	 eax, DWORD PTR $T29[ebp+8]
  000db	89 45 dc	 mov	 DWORD PTR _y_range$30[ebp+8], eax

; 1047 :         uint16_t *srcYLine = (uint16_t *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000de	b9 04 00 00 00	 mov	 ecx, 4
  000e3	6b d1 00	 imul	 edx, ecx, 0
  000e6	8b 45 e8	 mov	 eax, DWORD PTR _src_y_pitch$[ebp]
  000e9	0f af 45 d4	 imul	 eax, DWORD PTR _y_range$30[ebp]
  000ed	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  000f0	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  000f3	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  000f6	8b 4d f8	 mov	 ecx, DWORD PTR _crop_left$[ebp]
  000f9	8d 14 48	 lea	 edx, DWORD PTR [eax+ecx*2]
  000fc	89 55 c0	 mov	 DWORD PTR _srcYLine$28[ebp], edx

; 1048 :         uint16_t *dstLine = (uint16_t *)dst[0] + dst_y_pitch * y_range.start_dst;

  000ff	b8 04 00 00 00	 mov	 eax, 4
  00104	6b c8 00	 imul	 ecx, eax, 0
  00107	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  0010a	0f af 55 d8	 imul	 edx, DWORD PTR _y_range$30[ebp+4]
  0010e	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  00111	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  00114	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  00117	89 55 bc	 mov	 DWORD PTR _dstLine$27[ebp], edx

; 1049 :         const int y_width = width - crop_right - crop_left;

  0011a	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  0011d	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  00120	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  00123	89 45 b8	 mov	 DWORD PTR _y_width$26[ebp], eax

; 1050 :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  00126	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _y$25[ebp], 0
  0012d	eb 21		 jmp	 SHORT $LN4@convert_yv
$LN2@convert_yv:
  0012f	8b 4d b4	 mov	 ecx, DWORD PTR _y$25[ebp]
  00132	83 c1 01	 add	 ecx, 1
  00135	89 4d b4	 mov	 DWORD PTR _y$25[ebp], ecx
  00138	8b 55 e8	 mov	 edx, DWORD PTR _src_y_pitch$[ebp]
  0013b	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$28[ebp]
  0013e	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00141	89 4d c0	 mov	 DWORD PTR _srcYLine$28[ebp], ecx
  00144	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  00147	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$27[ebp]
  0014a	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  0014d	89 4d bc	 mov	 DWORD PTR _dstLine$27[ebp], ecx
$LN4@convert_yv:
  00150	8b 55 b4	 mov	 edx, DWORD PTR _y$25[ebp]
  00153	3b 55 dc	 cmp	 edx, DWORD PTR _y_range$30[ebp+8]
  00156	0f 8d 92 00 00
	00		 jge	 $LN14@convert_yv

; 1051 :             if (in_bit_depth == 16) {

  0015c	33 c0		 xor	 eax, eax
  0015e	74 18		 je	 SHORT $LN15@convert_yv

; 1052 :                 memcpy_sse((uint8_t *)dstLine, (uint8_t *)srcYLine, y_width * sizeof(uint16_t));

  00160	8b 4d b8	 mov	 ecx, DWORD PTR _y_width$26[ebp]
  00163	d1 e1		 shl	 ecx, 1
  00165	51		 push	 ecx
  00166	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$28[ebp]
  00169	52		 push	 edx
  0016a	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$27[ebp]
  0016d	50		 push	 eax
  0016e	e8 00 00 00 00	 call	 ?memcpy_sse@@YAXPAEPBEH@Z ; memcpy_sse
  00173	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1053 :             } else {

  00176	eb 71		 jmp	 SHORT $LN16@convert_yv
$LN15@convert_yv:

; 1054 :                 uint16_t *src_ptr = srcYLine;

  00178	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$28[ebp]
  0017b	89 4d b0	 mov	 DWORD PTR _src_ptr$24[ebp], ecx

; 1055 :                 uint16_t *dst_ptr = dstLine;

  0017e	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$27[ebp]
  00181	89 55 ac	 mov	 DWORD PTR _dst_ptr$23[ebp], edx

; 1056 :                 for (int x = 0; x < y_width; x += 8, dst_ptr += 8, src_ptr += 8) {

  00184	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR _x$22[ebp], 0
  0018b	eb 1b		 jmp	 SHORT $LN7@convert_yv
$LN5@convert_yv:
  0018d	8b 45 a8	 mov	 eax, DWORD PTR _x$22[ebp]
  00190	83 c0 08	 add	 eax, 8
  00193	89 45 a8	 mov	 DWORD PTR _x$22[ebp], eax
  00196	8b 4d ac	 mov	 ecx, DWORD PTR _dst_ptr$23[ebp]
  00199	83 c1 10	 add	 ecx, 16			; 00000010H
  0019c	89 4d ac	 mov	 DWORD PTR _dst_ptr$23[ebp], ecx
  0019f	8b 55 b0	 mov	 edx, DWORD PTR _src_ptr$24[ebp]
  001a2	83 c2 10	 add	 edx, 16			; 00000010H
  001a5	89 55 b0	 mov	 DWORD PTR _src_ptr$24[ebp], edx
$LN7@convert_yv:
  001a8	8b 45 a8	 mov	 eax, DWORD PTR _x$22[ebp]
  001ab	3b 45 b8	 cmp	 eax, DWORD PTR _y_width$26[ebp]
  001ae	7d 39		 jge	 SHORT $LN16@convert_yv

; 1057 :                     __m128i x0 = _mm_loadu_si128((const __m128i *)src_ptr);

  001b0	8b 4d b0	 mov	 ecx, DWORD PTR _src_ptr$24[ebp]
  001b3	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  001b6	0f 29 45 80	 movaps	 XMMWORD PTR $T20[ebp], xmm0
  001ba	0f 28 45 80	 movaps	 xmm0, XMMWORD PTR $T20[ebp]
  001be	0f 29 45 90	 movaps	 XMMWORD PTR _x0$21[ebp], xmm0

; 1058 :                     x0 = _mm_slli_epi16(x0, 16 - in_bit_depth);

  001c2	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR _x0$21[ebp]
  001c6	66 0f 71 f0 07	 psllw	 xmm0, 7
  001cb	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR $T19[ebp], xmm0
  001d2	0f 28 85 70 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T19[ebp]
  001d9	0f 29 45 90	 movaps	 XMMWORD PTR _x0$21[ebp], xmm0

; 1059 :                     _mm_storeu_si128((__m128i *)dst_ptr, x0);

  001dd	0f 10 45 90	 movups	 xmm0, XMMWORD PTR _x0$21[ebp]
  001e1	8b 55 ac	 mov	 edx, DWORD PTR _dst_ptr$23[ebp]
  001e4	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 1060 :                 }

  001e7	eb a4		 jmp	 SHORT $LN5@convert_yv
$LN16@convert_yv:

; 1061 :             }
; 1062 :         }

  001e9	e9 41 ff ff ff	 jmp	 $LN2@convert_yv
$LN14@convert_yv:

; 1063 :     }
; 1064 :     //UV成分のコピー
; 1065 :     const auto uv_range = thread_y_range(crop_up >> 1, (height - crop_bottom) >> 1, thread_id, thread_n);

  001ee	8b 43 2c	 mov	 eax, DWORD PTR _thread_n$[ebx]
  001f1	50		 push	 eax
  001f2	8b 4b 28	 mov	 ecx, DWORD PTR _thread_id$[ebx]
  001f5	51		 push	 ecx
  001f6	8b 53 20	 mov	 edx, DWORD PTR _height$[ebx]
  001f9	2b 55 ec	 sub	 edx, DWORD PTR _crop_bottom$[ebp]
  001fc	d1 fa		 sar	 edx, 1
  001fe	52		 push	 edx
  001ff	8b 45 f4	 mov	 eax, DWORD PTR _crop_up$[ebp]
  00202	d1 f8		 sar	 eax, 1
  00204	50		 push	 eax
  00205	8d 8d 60 fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  0020b	51		 push	 ecx
  0020c	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00211	83 c4 14	 add	 esp, 20			; 00000014H
  00214	8b 10		 mov	 edx, DWORD PTR [eax]
  00216	89 95 50 ff ff
	ff		 mov	 DWORD PTR $T18[ebp], edx
  0021c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0021f	89 8d 54 ff ff
	ff		 mov	 DWORD PTR $T18[ebp+4], ecx
  00225	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00228	89 95 58 ff ff
	ff		 mov	 DWORD PTR $T18[ebp+8], edx
  0022e	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR $T18[ebp]
  00234	89 85 60 ff ff
	ff		 mov	 DWORD PTR _uv_range$[ebp], eax
  0023a	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR $T18[ebp+4]
  00240	89 8d 64 ff ff
	ff		 mov	 DWORD PTR _uv_range$[ebp+4], ecx
  00246	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR $T18[ebp+8]
  0024c	89 95 68 ff ff
	ff		 mov	 DWORD PTR _uv_range$[ebp+8], edx

; 1066 :     const int src_uv_pitch = src_uv_pitch_byte >> 1;

  00252	8b 43 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebx]
  00255	d1 f8		 sar	 eax, 1
  00257	89 85 4c ff ff
	ff		 mov	 DWORD PTR _src_uv_pitch$[ebp], eax

; 1067 :     uint16_t *srcULine = (uint16_t *)src[1] + ((src_uv_pitch * uv_range.start_src) + (crop_left >> 1));

  0025d	b9 04 00 00 00	 mov	 ecx, 4
  00262	c1 e1 00	 shl	 ecx, 0
  00265	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  0026b	0f af 95 60 ff
	ff ff		 imul	 edx, DWORD PTR _uv_range$[ebp]
  00272	8b 45 f8	 mov	 eax, DWORD PTR _crop_left$[ebp]
  00275	d1 f8		 sar	 eax, 1
  00277	03 d0		 add	 edx, eax
  00279	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  0027c	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  0027f	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  00282	89 95 48 ff ff
	ff		 mov	 DWORD PTR _srcULine$[ebp], edx

; 1068 :     uint16_t *srcVLine = (uint16_t *)src[2] + ((src_uv_pitch * uv_range.start_src) + (crop_left >> 1));

  00288	b8 04 00 00 00	 mov	 eax, 4
  0028d	d1 e0		 shl	 eax, 1
  0028f	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00295	0f af 8d 60 ff
	ff ff		 imul	 ecx, DWORD PTR _uv_range$[ebp]
  0029c	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  0029f	d1 fa		 sar	 edx, 1
  002a1	03 ca		 add	 ecx, edx
  002a3	8b 53 0c	 mov	 edx, DWORD PTR _src$[ebx]
  002a6	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  002a9	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  002ac	89 8d 44 ff ff
	ff		 mov	 DWORD PTR _srcVLine$[ebp], ecx

; 1069 :     uint16_t *dstLine = (uint16_t *)dst[1] + dst_y_pitch * uv_range.start_dst;

  002b2	ba 04 00 00 00	 mov	 edx, 4
  002b7	c1 e2 00	 shl	 edx, 0
  002ba	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  002bd	0f af 85 64 ff
	ff ff		 imul	 eax, DWORD PTR _uv_range$[ebp+4]
  002c4	8b 4b 08	 mov	 ecx, DWORD PTR _dst$[ebx]
  002c7	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  002ca	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  002cd	89 85 40 ff ff
	ff		 mov	 DWORD PTR _dstLine$[ebp], eax

; 1070 :     for (int y = 0; y < uv_range.len; y++, srcULine += src_uv_pitch, srcVLine += src_uv_pitch, dstLine += dst_y_pitch) {

  002d3	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _y$17[ebp], 0
  002dd	eb 4b		 jmp	 SHORT $LN10@convert_yv
$LN8@convert_yv:
  002df	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _y$17[ebp]
  002e5	83 c1 01	 add	 ecx, 1
  002e8	89 8d 3c ff ff
	ff		 mov	 DWORD PTR _y$17[ebp], ecx
  002ee	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  002f4	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _srcULine$[ebp]
  002fa	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  002fd	89 8d 48 ff ff
	ff		 mov	 DWORD PTR _srcULine$[ebp], ecx
  00303	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  00309	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _srcVLine$[ebp]
  0030f	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00312	89 8d 44 ff ff
	ff		 mov	 DWORD PTR _srcVLine$[ebp], ecx
  00318	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  0031b	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _dstLine$[ebp]
  00321	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00324	89 8d 40 ff ff
	ff		 mov	 DWORD PTR _dstLine$[ebp], ecx
$LN10@convert_yv:
  0032a	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR _y$17[ebp]
  00330	3b 95 68 ff ff
	ff		 cmp	 edx, DWORD PTR _uv_range$[ebp+8]
  00336	0f 8d 85 01 00
	00		 jge	 $LN1@convert_yv

; 1071 :         const int x_fin = width - crop_right;

  0033c	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  0033f	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  00342	89 85 38 ff ff
	ff		 mov	 DWORD PTR _x_fin$16[ebp], eax

; 1072 :         uint16_t *src_u_ptr = srcULine;

  00348	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR _srcULine$[ebp]
  0034e	89 8d 34 ff ff
	ff		 mov	 DWORD PTR _src_u_ptr$15[ebp], ecx

; 1073 :         uint16_t *src_v_ptr = srcVLine;

  00354	8b 95 44 ff ff
	ff		 mov	 edx, DWORD PTR _srcVLine$[ebp]
  0035a	89 95 30 ff ff
	ff		 mov	 DWORD PTR _src_v_ptr$14[ebp], edx

; 1074 :         uint16_t *dst_ptr = dstLine;

  00360	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _dstLine$[ebp]
  00366	89 85 2c ff ff
	ff		 mov	 DWORD PTR _dst_ptr$13[ebp], eax

; 1075 :         __m128i x0, x1, x2;
; 1076 :         for (int x = crop_left; x < x_fin; x += 16, src_u_ptr += 8, src_v_ptr += 8, dst_ptr += 16) {

  0036c	8b 4d f8	 mov	 ecx, DWORD PTR _crop_left$[ebp]
  0036f	89 8d ec fe ff
	ff		 mov	 DWORD PTR _x$9[ebp], ecx
  00375	eb 3c		 jmp	 SHORT $LN13@convert_yv
$LN11@convert_yv:
  00377	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _x$9[ebp]
  0037d	83 c2 10	 add	 edx, 16			; 00000010H
  00380	89 95 ec fe ff
	ff		 mov	 DWORD PTR _x$9[ebp], edx
  00386	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR _src_u_ptr$15[ebp]
  0038c	83 c0 10	 add	 eax, 16			; 00000010H
  0038f	89 85 34 ff ff
	ff		 mov	 DWORD PTR _src_u_ptr$15[ebp], eax
  00395	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR _src_v_ptr$14[ebp]
  0039b	83 c1 10	 add	 ecx, 16			; 00000010H
  0039e	89 8d 30 ff ff
	ff		 mov	 DWORD PTR _src_v_ptr$14[ebp], ecx
  003a4	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR _dst_ptr$13[ebp]
  003aa	83 c2 20	 add	 edx, 32			; 00000020H
  003ad	89 95 2c ff ff
	ff		 mov	 DWORD PTR _dst_ptr$13[ebp], edx
$LN13@convert_yv:
  003b3	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _x$9[ebp]
  003b9	3b 85 38 ff ff
	ff		 cmp	 eax, DWORD PTR _x_fin$16[ebp]
  003bf	0f 8d f7 00 00
	00		 jge	 $LN12@convert_yv

; 1077 :             x0 = _mm_loadu_si128((const __m128i *)src_u_ptr);

  003c5	8b 8d 34 ff ff
	ff		 mov	 ecx, DWORD PTR _src_u_ptr$15[ebp]
  003cb	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  003ce	0f 29 85 d0 fe
	ff ff		 movaps	 XMMWORD PTR $T8[ebp], xmm0
  003d5	0f 28 85 d0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T8[ebp]
  003dc	0f 29 85 10 ff
	ff ff		 movaps	 XMMWORD PTR _x0$12[ebp], xmm0

; 1078 :             x1 = _mm_loadu_si128((const __m128i *)src_v_ptr);

  003e3	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR _src_v_ptr$14[ebp]
  003e9	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  003ec	0f 29 85 c0 fe
	ff ff		 movaps	 XMMWORD PTR $T7[ebp], xmm0
  003f3	0f 28 85 c0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T7[ebp]
  003fa	0f 29 85 00 ff
	ff ff		 movaps	 XMMWORD PTR _x1$11[ebp], xmm0

; 1079 : 
; 1080 :             if (in_bit_depth < 16) {

  00401	b8 01 00 00 00	 mov	 eax, 1
  00406	85 c0		 test	 eax, eax
  00408	74 42		 je	 SHORT $LN17@convert_yv

; 1081 :                 x0 = _mm_slli_epi16(x0, 16 - in_bit_depth);

  0040a	0f 28 85 10 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x0$12[ebp]
  00411	66 0f 71 f0 07	 psllw	 xmm0, 7
  00416	0f 29 85 b0 fe
	ff ff		 movaps	 XMMWORD PTR $T6[ebp], xmm0
  0041d	0f 28 85 b0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T6[ebp]
  00424	0f 29 85 10 ff
	ff ff		 movaps	 XMMWORD PTR _x0$12[ebp], xmm0

; 1082 :                 x1 = _mm_slli_epi16(x1, 16 - in_bit_depth);

  0042b	0f 28 85 00 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$11[ebp]
  00432	66 0f 71 f0 07	 psllw	 xmm0, 7
  00437	0f 29 85 a0 fe
	ff ff		 movaps	 XMMWORD PTR $T5[ebp], xmm0
  0043e	0f 28 85 a0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T5[ebp]
  00445	0f 29 85 00 ff
	ff ff		 movaps	 XMMWORD PTR _x1$11[ebp], xmm0
$LN17@convert_yv:

; 1083 :             }
; 1084 : 
; 1085 :             x2 = _mm_unpackhi_epi16(x0, x1);

  0044c	0f 28 85 10 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x0$12[ebp]
  00453	66 0f 69 85 00
	ff ff ff	 punpckhwd xmm0, XMMWORD PTR _x1$11[ebp]
  0045b	0f 29 85 90 fe
	ff ff		 movaps	 XMMWORD PTR $T4[ebp], xmm0
  00462	0f 28 85 90 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T4[ebp]
  00469	0f 29 85 f0 fe
	ff ff		 movaps	 XMMWORD PTR _x2$10[ebp], xmm0

; 1086 :             x0 = _mm_unpacklo_epi16(x0, x1);

  00470	0f 28 85 10 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x0$12[ebp]
  00477	66 0f 61 85 00
	ff ff ff	 punpcklwd xmm0, XMMWORD PTR _x1$11[ebp]
  0047f	0f 29 85 80 fe
	ff ff		 movaps	 XMMWORD PTR $T3[ebp], xmm0
  00486	0f 28 85 80 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T3[ebp]
  0048d	0f 29 85 10 ff
	ff ff		 movaps	 XMMWORD PTR _x0$12[ebp], xmm0

; 1087 : 
; 1088 :             _mm_storeu_si128((__m128i *)(dst_ptr + 0), x0);

  00494	0f 10 85 10 ff
	ff ff		 movups	 xmm0, XMMWORD PTR _x0$12[ebp]
  0049b	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR _dst_ptr$13[ebp]
  004a1	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 1089 :             _mm_storeu_si128((__m128i *)(dst_ptr + 8), x2);

  004a4	0f 10 85 f0 fe
	ff ff		 movups	 xmm0, XMMWORD PTR _x2$10[ebp]
  004ab	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR _dst_ptr$13[ebp]
  004b1	83 c2 10	 add	 edx, 16			; 00000010H
  004b4	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 1090 :         }

  004b7	e9 bb fe ff ff	 jmp	 $LN11@convert_yv
$LN12@convert_yv:

; 1091 :     }

  004bc	e9 1e fe ff ff	 jmp	 $LN8@convert_yv
$LN1@convert_yv:

; 1092 : }

  004c1	52		 push	 edx
  004c2	8b cd		 mov	 ecx, ebp
  004c4	50		 push	 eax
  004c5	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN22@convert_yv
  004cb	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  004d0	58		 pop	 eax
  004d1	5a		 pop	 edx
  004d2	5f		 pop	 edi
  004d3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004d6	33 cd		 xor	 ecx, ebp
  004d8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004dd	8b e5		 mov	 esp, ebp
  004df	5d		 pop	 ebp
  004e0	8b e3		 mov	 esp, ebx
  004e2	5b		 pop	 ebx
  004e3	c3		 ret	 0
$LN22@convert_yv:
  004e4	02 00 00 00	 DD	 2
  004e8	00 00 00 00	 DD	 $LN21@convert_yv
$LN21@convert_yv:
  004ec	d4 ff ff ff	 DD	 -44			; ffffffd4H
  004f0	0c 00 00 00	 DD	 12			; 0000000cH
  004f4	00 00 00 00	 DD	 $LN19@convert_yv
  004f8	60 ff ff ff	 DD	 -160			; ffffff60H
  004fc	0c 00 00 00	 DD	 12			; 0000000cH
  00500	00 00 00 00	 DD	 $LN20@convert_yv
$LN20@convert_yv:
  00504	75		 DB	 117			; 00000075H
  00505	76		 DB	 118			; 00000076H
  00506	5f		 DB	 95			; 0000005fH
  00507	72		 DB	 114			; 00000072H
  00508	61		 DB	 97			; 00000061H
  00509	6e		 DB	 110			; 0000006eH
  0050a	67		 DB	 103			; 00000067H
  0050b	65		 DB	 101			; 00000065H
  0050c	00		 DB	 0
$LN19@convert_yv:
  0050d	79		 DB	 121			; 00000079H
  0050e	5f		 DB	 95			; 0000005fH
  0050f	72		 DB	 114			; 00000072H
  00510	61		 DB	 97			; 00000061H
  00511	6e		 DB	 110			; 0000006eH
  00512	67		 DB	 103			; 00000067H
  00513	65		 DB	 101			; 00000065H
  00514	00		 DB	 0
??$convert_yv12_high_to_p010_simd@$08$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_high_to_p010_simd<9,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_sse2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yv12_09_to_p010_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_09_to_p010_sse2

; 141  : void convert_yv12_09_to_p010_sse2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 142  :     convert_yv12_high_to_p010_simd<9, false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yv12_high_to_p010_simd@$08$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_high_to_p010_simd<9,0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 143  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yv12_09_to_p010_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_09_to_p010_sse2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -416						; size = 12
$T2 = -400						; size = 12
$T3 = -384						; size = 16
$T4 = -368						; size = 16
$T5 = -352						; size = 16
$T6 = -336						; size = 16
$T7 = -320						; size = 16
$T8 = -304						; size = 16
_x$9 = -276						; size = 4
_x2$10 = -272						; size = 16
_x1$11 = -256						; size = 16
_x0$12 = -240						; size = 16
_dst_ptr$13 = -212					; size = 4
_src_v_ptr$14 = -208					; size = 4
_src_u_ptr$15 = -204					; size = 4
_x_fin$16 = -200					; size = 4
_y$17 = -196						; size = 4
_dstLine$ = -192					; size = 4
_srcVLine$ = -188					; size = 4
_srcULine$ = -184					; size = 4
_src_uv_pitch$ = -180					; size = 4
$T18 = -176						; size = 12
_uv_range$ = -160					; size = 12
$T19 = -144						; size = 16
$T20 = -128						; size = 16
_x0$21 = -112						; size = 16
_x$22 = -88						; size = 4
_dst_ptr$23 = -84					; size = 4
_src_ptr$24 = -80					; size = 4
_y$25 = -76						; size = 4
_y_width$26 = -72					; size = 4
_dstLine$27 = -68					; size = 4
_srcYLine$28 = -64					; size = 4
$T29 = -60						; size = 12
_y_range$30 = -44					; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yv12_high_to_p010_simd@$09$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_high_to_p010_simd<10,0>

; 1036 : static void __forceinline convert_yv12_high_to_p010_simd(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec a0 01 00
	00		 sub	 esp, 416		; 000001a0H
  0001c	57		 push	 edi
  0001d	8d bd 60 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-416]
  00023	b9 68 00 00 00	 mov	 ecx, 104		; 00000068H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1037 :     static_assert(8 < in_bit_depth && in_bit_depth <= 16, "in_bit_depth must be 9-16.");
; 1038 :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 1039 :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 1040 :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 1041 :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 1042 :     const int src_y_pitch = src_y_pitch_byte >> 1;

  0007c	8b 53 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  0007f	d1 fa		 sar	 edx, 1
  00081	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 1043 :     const int dst_y_pitch = dst_y_pitch_byte >> 1;

  00084	8b 43 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  00087	d1 f8		 sar	 eax, 1
  00089	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 1044 :     //Y成分のコピー
; 1045 :     if (!uv_only) {

  0008c	b9 01 00 00 00	 mov	 ecx, 1
  00091	85 c9		 test	 ecx, ecx
  00093	0f 84 55 01 00
	00		 je	 $LN14@convert_yv

; 1046 :         const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00099	8b 53 2c	 mov	 edx, DWORD PTR _thread_n$[ebx]
  0009c	52		 push	 edx
  0009d	8b 43 28	 mov	 eax, DWORD PTR _thread_id$[ebx]
  000a0	50		 push	 eax
  000a1	8b 4b 20	 mov	 ecx, DWORD PTR _height$[ebx]
  000a4	2b 4d ec	 sub	 ecx, DWORD PTR _crop_bottom$[ebp]
  000a7	51		 push	 ecx
  000a8	8b 55 f4	 mov	 edx, DWORD PTR _crop_up$[ebp]
  000ab	52		 push	 edx
  000ac	8d 85 70 fe ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  000b2	50		 push	 eax
  000b3	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  000b8	83 c4 14	 add	 esp, 20			; 00000014H
  000bb	8b 08		 mov	 ecx, DWORD PTR [eax]
  000bd	89 4d c4	 mov	 DWORD PTR $T29[ebp], ecx
  000c0	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000c3	89 55 c8	 mov	 DWORD PTR $T29[ebp+4], edx
  000c6	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000c9	89 45 cc	 mov	 DWORD PTR $T29[ebp+8], eax
  000cc	8b 4d c4	 mov	 ecx, DWORD PTR $T29[ebp]
  000cf	89 4d d4	 mov	 DWORD PTR _y_range$30[ebp], ecx
  000d2	8b 55 c8	 mov	 edx, DWORD PTR $T29[ebp+4]
  000d5	89 55 d8	 mov	 DWORD PTR _y_range$30[ebp+4], edx
  000d8	8b 45 cc	 mov	 eax, DWORD PTR $T29[ebp+8]
  000db	89 45 dc	 mov	 DWORD PTR _y_range$30[ebp+8], eax

; 1047 :         uint16_t *srcYLine = (uint16_t *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000de	b9 04 00 00 00	 mov	 ecx, 4
  000e3	6b d1 00	 imul	 edx, ecx, 0
  000e6	8b 45 e8	 mov	 eax, DWORD PTR _src_y_pitch$[ebp]
  000e9	0f af 45 d4	 imul	 eax, DWORD PTR _y_range$30[ebp]
  000ed	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  000f0	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  000f3	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  000f6	8b 4d f8	 mov	 ecx, DWORD PTR _crop_left$[ebp]
  000f9	8d 14 48	 lea	 edx, DWORD PTR [eax+ecx*2]
  000fc	89 55 c0	 mov	 DWORD PTR _srcYLine$28[ebp], edx

; 1048 :         uint16_t *dstLine = (uint16_t *)dst[0] + dst_y_pitch * y_range.start_dst;

  000ff	b8 04 00 00 00	 mov	 eax, 4
  00104	6b c8 00	 imul	 ecx, eax, 0
  00107	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  0010a	0f af 55 d8	 imul	 edx, DWORD PTR _y_range$30[ebp+4]
  0010e	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  00111	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  00114	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  00117	89 55 bc	 mov	 DWORD PTR _dstLine$27[ebp], edx

; 1049 :         const int y_width = width - crop_right - crop_left;

  0011a	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  0011d	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  00120	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  00123	89 45 b8	 mov	 DWORD PTR _y_width$26[ebp], eax

; 1050 :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  00126	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _y$25[ebp], 0
  0012d	eb 21		 jmp	 SHORT $LN4@convert_yv
$LN2@convert_yv:
  0012f	8b 4d b4	 mov	 ecx, DWORD PTR _y$25[ebp]
  00132	83 c1 01	 add	 ecx, 1
  00135	89 4d b4	 mov	 DWORD PTR _y$25[ebp], ecx
  00138	8b 55 e8	 mov	 edx, DWORD PTR _src_y_pitch$[ebp]
  0013b	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$28[ebp]
  0013e	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00141	89 4d c0	 mov	 DWORD PTR _srcYLine$28[ebp], ecx
  00144	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  00147	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$27[ebp]
  0014a	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  0014d	89 4d bc	 mov	 DWORD PTR _dstLine$27[ebp], ecx
$LN4@convert_yv:
  00150	8b 55 b4	 mov	 edx, DWORD PTR _y$25[ebp]
  00153	3b 55 dc	 cmp	 edx, DWORD PTR _y_range$30[ebp+8]
  00156	0f 8d 92 00 00
	00		 jge	 $LN14@convert_yv

; 1051 :             if (in_bit_depth == 16) {

  0015c	33 c0		 xor	 eax, eax
  0015e	74 18		 je	 SHORT $LN15@convert_yv

; 1052 :                 memcpy_sse((uint8_t *)dstLine, (uint8_t *)srcYLine, y_width * sizeof(uint16_t));

  00160	8b 4d b8	 mov	 ecx, DWORD PTR _y_width$26[ebp]
  00163	d1 e1		 shl	 ecx, 1
  00165	51		 push	 ecx
  00166	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$28[ebp]
  00169	52		 push	 edx
  0016a	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$27[ebp]
  0016d	50		 push	 eax
  0016e	e8 00 00 00 00	 call	 ?memcpy_sse@@YAXPAEPBEH@Z ; memcpy_sse
  00173	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1053 :             } else {

  00176	eb 71		 jmp	 SHORT $LN16@convert_yv
$LN15@convert_yv:

; 1054 :                 uint16_t *src_ptr = srcYLine;

  00178	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$28[ebp]
  0017b	89 4d b0	 mov	 DWORD PTR _src_ptr$24[ebp], ecx

; 1055 :                 uint16_t *dst_ptr = dstLine;

  0017e	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$27[ebp]
  00181	89 55 ac	 mov	 DWORD PTR _dst_ptr$23[ebp], edx

; 1056 :                 for (int x = 0; x < y_width; x += 8, dst_ptr += 8, src_ptr += 8) {

  00184	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR _x$22[ebp], 0
  0018b	eb 1b		 jmp	 SHORT $LN7@convert_yv
$LN5@convert_yv:
  0018d	8b 45 a8	 mov	 eax, DWORD PTR _x$22[ebp]
  00190	83 c0 08	 add	 eax, 8
  00193	89 45 a8	 mov	 DWORD PTR _x$22[ebp], eax
  00196	8b 4d ac	 mov	 ecx, DWORD PTR _dst_ptr$23[ebp]
  00199	83 c1 10	 add	 ecx, 16			; 00000010H
  0019c	89 4d ac	 mov	 DWORD PTR _dst_ptr$23[ebp], ecx
  0019f	8b 55 b0	 mov	 edx, DWORD PTR _src_ptr$24[ebp]
  001a2	83 c2 10	 add	 edx, 16			; 00000010H
  001a5	89 55 b0	 mov	 DWORD PTR _src_ptr$24[ebp], edx
$LN7@convert_yv:
  001a8	8b 45 a8	 mov	 eax, DWORD PTR _x$22[ebp]
  001ab	3b 45 b8	 cmp	 eax, DWORD PTR _y_width$26[ebp]
  001ae	7d 39		 jge	 SHORT $LN16@convert_yv

; 1057 :                     __m128i x0 = _mm_loadu_si128((const __m128i *)src_ptr);

  001b0	8b 4d b0	 mov	 ecx, DWORD PTR _src_ptr$24[ebp]
  001b3	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  001b6	0f 29 45 80	 movaps	 XMMWORD PTR $T20[ebp], xmm0
  001ba	0f 28 45 80	 movaps	 xmm0, XMMWORD PTR $T20[ebp]
  001be	0f 29 45 90	 movaps	 XMMWORD PTR _x0$21[ebp], xmm0

; 1058 :                     x0 = _mm_slli_epi16(x0, 16 - in_bit_depth);

  001c2	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR _x0$21[ebp]
  001c6	66 0f 71 f0 06	 psllw	 xmm0, 6
  001cb	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR $T19[ebp], xmm0
  001d2	0f 28 85 70 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T19[ebp]
  001d9	0f 29 45 90	 movaps	 XMMWORD PTR _x0$21[ebp], xmm0

; 1059 :                     _mm_storeu_si128((__m128i *)dst_ptr, x0);

  001dd	0f 10 45 90	 movups	 xmm0, XMMWORD PTR _x0$21[ebp]
  001e1	8b 55 ac	 mov	 edx, DWORD PTR _dst_ptr$23[ebp]
  001e4	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 1060 :                 }

  001e7	eb a4		 jmp	 SHORT $LN5@convert_yv
$LN16@convert_yv:

; 1061 :             }
; 1062 :         }

  001e9	e9 41 ff ff ff	 jmp	 $LN2@convert_yv
$LN14@convert_yv:

; 1063 :     }
; 1064 :     //UV成分のコピー
; 1065 :     const auto uv_range = thread_y_range(crop_up >> 1, (height - crop_bottom) >> 1, thread_id, thread_n);

  001ee	8b 43 2c	 mov	 eax, DWORD PTR _thread_n$[ebx]
  001f1	50		 push	 eax
  001f2	8b 4b 28	 mov	 ecx, DWORD PTR _thread_id$[ebx]
  001f5	51		 push	 ecx
  001f6	8b 53 20	 mov	 edx, DWORD PTR _height$[ebx]
  001f9	2b 55 ec	 sub	 edx, DWORD PTR _crop_bottom$[ebp]
  001fc	d1 fa		 sar	 edx, 1
  001fe	52		 push	 edx
  001ff	8b 45 f4	 mov	 eax, DWORD PTR _crop_up$[ebp]
  00202	d1 f8		 sar	 eax, 1
  00204	50		 push	 eax
  00205	8d 8d 60 fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  0020b	51		 push	 ecx
  0020c	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00211	83 c4 14	 add	 esp, 20			; 00000014H
  00214	8b 10		 mov	 edx, DWORD PTR [eax]
  00216	89 95 50 ff ff
	ff		 mov	 DWORD PTR $T18[ebp], edx
  0021c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0021f	89 8d 54 ff ff
	ff		 mov	 DWORD PTR $T18[ebp+4], ecx
  00225	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00228	89 95 58 ff ff
	ff		 mov	 DWORD PTR $T18[ebp+8], edx
  0022e	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR $T18[ebp]
  00234	89 85 60 ff ff
	ff		 mov	 DWORD PTR _uv_range$[ebp], eax
  0023a	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR $T18[ebp+4]
  00240	89 8d 64 ff ff
	ff		 mov	 DWORD PTR _uv_range$[ebp+4], ecx
  00246	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR $T18[ebp+8]
  0024c	89 95 68 ff ff
	ff		 mov	 DWORD PTR _uv_range$[ebp+8], edx

; 1066 :     const int src_uv_pitch = src_uv_pitch_byte >> 1;

  00252	8b 43 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebx]
  00255	d1 f8		 sar	 eax, 1
  00257	89 85 4c ff ff
	ff		 mov	 DWORD PTR _src_uv_pitch$[ebp], eax

; 1067 :     uint16_t *srcULine = (uint16_t *)src[1] + ((src_uv_pitch * uv_range.start_src) + (crop_left >> 1));

  0025d	b9 04 00 00 00	 mov	 ecx, 4
  00262	c1 e1 00	 shl	 ecx, 0
  00265	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  0026b	0f af 95 60 ff
	ff ff		 imul	 edx, DWORD PTR _uv_range$[ebp]
  00272	8b 45 f8	 mov	 eax, DWORD PTR _crop_left$[ebp]
  00275	d1 f8		 sar	 eax, 1
  00277	03 d0		 add	 edx, eax
  00279	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  0027c	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  0027f	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  00282	89 95 48 ff ff
	ff		 mov	 DWORD PTR _srcULine$[ebp], edx

; 1068 :     uint16_t *srcVLine = (uint16_t *)src[2] + ((src_uv_pitch * uv_range.start_src) + (crop_left >> 1));

  00288	b8 04 00 00 00	 mov	 eax, 4
  0028d	d1 e0		 shl	 eax, 1
  0028f	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00295	0f af 8d 60 ff
	ff ff		 imul	 ecx, DWORD PTR _uv_range$[ebp]
  0029c	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  0029f	d1 fa		 sar	 edx, 1
  002a1	03 ca		 add	 ecx, edx
  002a3	8b 53 0c	 mov	 edx, DWORD PTR _src$[ebx]
  002a6	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  002a9	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  002ac	89 8d 44 ff ff
	ff		 mov	 DWORD PTR _srcVLine$[ebp], ecx

; 1069 :     uint16_t *dstLine = (uint16_t *)dst[1] + dst_y_pitch * uv_range.start_dst;

  002b2	ba 04 00 00 00	 mov	 edx, 4
  002b7	c1 e2 00	 shl	 edx, 0
  002ba	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  002bd	0f af 85 64 ff
	ff ff		 imul	 eax, DWORD PTR _uv_range$[ebp+4]
  002c4	8b 4b 08	 mov	 ecx, DWORD PTR _dst$[ebx]
  002c7	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  002ca	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  002cd	89 85 40 ff ff
	ff		 mov	 DWORD PTR _dstLine$[ebp], eax

; 1070 :     for (int y = 0; y < uv_range.len; y++, srcULine += src_uv_pitch, srcVLine += src_uv_pitch, dstLine += dst_y_pitch) {

  002d3	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _y$17[ebp], 0
  002dd	eb 4b		 jmp	 SHORT $LN10@convert_yv
$LN8@convert_yv:
  002df	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _y$17[ebp]
  002e5	83 c1 01	 add	 ecx, 1
  002e8	89 8d 3c ff ff
	ff		 mov	 DWORD PTR _y$17[ebp], ecx
  002ee	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  002f4	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _srcULine$[ebp]
  002fa	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  002fd	89 8d 48 ff ff
	ff		 mov	 DWORD PTR _srcULine$[ebp], ecx
  00303	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  00309	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _srcVLine$[ebp]
  0030f	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00312	89 8d 44 ff ff
	ff		 mov	 DWORD PTR _srcVLine$[ebp], ecx
  00318	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  0031b	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _dstLine$[ebp]
  00321	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00324	89 8d 40 ff ff
	ff		 mov	 DWORD PTR _dstLine$[ebp], ecx
$LN10@convert_yv:
  0032a	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR _y$17[ebp]
  00330	3b 95 68 ff ff
	ff		 cmp	 edx, DWORD PTR _uv_range$[ebp+8]
  00336	0f 8d 85 01 00
	00		 jge	 $LN1@convert_yv

; 1071 :         const int x_fin = width - crop_right;

  0033c	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  0033f	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  00342	89 85 38 ff ff
	ff		 mov	 DWORD PTR _x_fin$16[ebp], eax

; 1072 :         uint16_t *src_u_ptr = srcULine;

  00348	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR _srcULine$[ebp]
  0034e	89 8d 34 ff ff
	ff		 mov	 DWORD PTR _src_u_ptr$15[ebp], ecx

; 1073 :         uint16_t *src_v_ptr = srcVLine;

  00354	8b 95 44 ff ff
	ff		 mov	 edx, DWORD PTR _srcVLine$[ebp]
  0035a	89 95 30 ff ff
	ff		 mov	 DWORD PTR _src_v_ptr$14[ebp], edx

; 1074 :         uint16_t *dst_ptr = dstLine;

  00360	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _dstLine$[ebp]
  00366	89 85 2c ff ff
	ff		 mov	 DWORD PTR _dst_ptr$13[ebp], eax

; 1075 :         __m128i x0, x1, x2;
; 1076 :         for (int x = crop_left; x < x_fin; x += 16, src_u_ptr += 8, src_v_ptr += 8, dst_ptr += 16) {

  0036c	8b 4d f8	 mov	 ecx, DWORD PTR _crop_left$[ebp]
  0036f	89 8d ec fe ff
	ff		 mov	 DWORD PTR _x$9[ebp], ecx
  00375	eb 3c		 jmp	 SHORT $LN13@convert_yv
$LN11@convert_yv:
  00377	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _x$9[ebp]
  0037d	83 c2 10	 add	 edx, 16			; 00000010H
  00380	89 95 ec fe ff
	ff		 mov	 DWORD PTR _x$9[ebp], edx
  00386	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR _src_u_ptr$15[ebp]
  0038c	83 c0 10	 add	 eax, 16			; 00000010H
  0038f	89 85 34 ff ff
	ff		 mov	 DWORD PTR _src_u_ptr$15[ebp], eax
  00395	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR _src_v_ptr$14[ebp]
  0039b	83 c1 10	 add	 ecx, 16			; 00000010H
  0039e	89 8d 30 ff ff
	ff		 mov	 DWORD PTR _src_v_ptr$14[ebp], ecx
  003a4	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR _dst_ptr$13[ebp]
  003aa	83 c2 20	 add	 edx, 32			; 00000020H
  003ad	89 95 2c ff ff
	ff		 mov	 DWORD PTR _dst_ptr$13[ebp], edx
$LN13@convert_yv:
  003b3	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _x$9[ebp]
  003b9	3b 85 38 ff ff
	ff		 cmp	 eax, DWORD PTR _x_fin$16[ebp]
  003bf	0f 8d f7 00 00
	00		 jge	 $LN12@convert_yv

; 1077 :             x0 = _mm_loadu_si128((const __m128i *)src_u_ptr);

  003c5	8b 8d 34 ff ff
	ff		 mov	 ecx, DWORD PTR _src_u_ptr$15[ebp]
  003cb	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  003ce	0f 29 85 d0 fe
	ff ff		 movaps	 XMMWORD PTR $T8[ebp], xmm0
  003d5	0f 28 85 d0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T8[ebp]
  003dc	0f 29 85 10 ff
	ff ff		 movaps	 XMMWORD PTR _x0$12[ebp], xmm0

; 1078 :             x1 = _mm_loadu_si128((const __m128i *)src_v_ptr);

  003e3	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR _src_v_ptr$14[ebp]
  003e9	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  003ec	0f 29 85 c0 fe
	ff ff		 movaps	 XMMWORD PTR $T7[ebp], xmm0
  003f3	0f 28 85 c0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T7[ebp]
  003fa	0f 29 85 00 ff
	ff ff		 movaps	 XMMWORD PTR _x1$11[ebp], xmm0

; 1079 : 
; 1080 :             if (in_bit_depth < 16) {

  00401	b8 01 00 00 00	 mov	 eax, 1
  00406	85 c0		 test	 eax, eax
  00408	74 42		 je	 SHORT $LN17@convert_yv

; 1081 :                 x0 = _mm_slli_epi16(x0, 16 - in_bit_depth);

  0040a	0f 28 85 10 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x0$12[ebp]
  00411	66 0f 71 f0 06	 psllw	 xmm0, 6
  00416	0f 29 85 b0 fe
	ff ff		 movaps	 XMMWORD PTR $T6[ebp], xmm0
  0041d	0f 28 85 b0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T6[ebp]
  00424	0f 29 85 10 ff
	ff ff		 movaps	 XMMWORD PTR _x0$12[ebp], xmm0

; 1082 :                 x1 = _mm_slli_epi16(x1, 16 - in_bit_depth);

  0042b	0f 28 85 00 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$11[ebp]
  00432	66 0f 71 f0 06	 psllw	 xmm0, 6
  00437	0f 29 85 a0 fe
	ff ff		 movaps	 XMMWORD PTR $T5[ebp], xmm0
  0043e	0f 28 85 a0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T5[ebp]
  00445	0f 29 85 00 ff
	ff ff		 movaps	 XMMWORD PTR _x1$11[ebp], xmm0
$LN17@convert_yv:

; 1083 :             }
; 1084 : 
; 1085 :             x2 = _mm_unpackhi_epi16(x0, x1);

  0044c	0f 28 85 10 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x0$12[ebp]
  00453	66 0f 69 85 00
	ff ff ff	 punpckhwd xmm0, XMMWORD PTR _x1$11[ebp]
  0045b	0f 29 85 90 fe
	ff ff		 movaps	 XMMWORD PTR $T4[ebp], xmm0
  00462	0f 28 85 90 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T4[ebp]
  00469	0f 29 85 f0 fe
	ff ff		 movaps	 XMMWORD PTR _x2$10[ebp], xmm0

; 1086 :             x0 = _mm_unpacklo_epi16(x0, x1);

  00470	0f 28 85 10 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x0$12[ebp]
  00477	66 0f 61 85 00
	ff ff ff	 punpcklwd xmm0, XMMWORD PTR _x1$11[ebp]
  0047f	0f 29 85 80 fe
	ff ff		 movaps	 XMMWORD PTR $T3[ebp], xmm0
  00486	0f 28 85 80 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T3[ebp]
  0048d	0f 29 85 10 ff
	ff ff		 movaps	 XMMWORD PTR _x0$12[ebp], xmm0

; 1087 : 
; 1088 :             _mm_storeu_si128((__m128i *)(dst_ptr + 0), x0);

  00494	0f 10 85 10 ff
	ff ff		 movups	 xmm0, XMMWORD PTR _x0$12[ebp]
  0049b	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR _dst_ptr$13[ebp]
  004a1	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 1089 :             _mm_storeu_si128((__m128i *)(dst_ptr + 8), x2);

  004a4	0f 10 85 f0 fe
	ff ff		 movups	 xmm0, XMMWORD PTR _x2$10[ebp]
  004ab	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR _dst_ptr$13[ebp]
  004b1	83 c2 10	 add	 edx, 16			; 00000010H
  004b4	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 1090 :         }

  004b7	e9 bb fe ff ff	 jmp	 $LN11@convert_yv
$LN12@convert_yv:

; 1091 :     }

  004bc	e9 1e fe ff ff	 jmp	 $LN8@convert_yv
$LN1@convert_yv:

; 1092 : }

  004c1	52		 push	 edx
  004c2	8b cd		 mov	 ecx, ebp
  004c4	50		 push	 eax
  004c5	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN22@convert_yv
  004cb	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  004d0	58		 pop	 eax
  004d1	5a		 pop	 edx
  004d2	5f		 pop	 edi
  004d3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004d6	33 cd		 xor	 ecx, ebp
  004d8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004dd	8b e5		 mov	 esp, ebp
  004df	5d		 pop	 ebp
  004e0	8b e3		 mov	 esp, ebx
  004e2	5b		 pop	 ebx
  004e3	c3		 ret	 0
$LN22@convert_yv:
  004e4	02 00 00 00	 DD	 2
  004e8	00 00 00 00	 DD	 $LN21@convert_yv
$LN21@convert_yv:
  004ec	d4 ff ff ff	 DD	 -44			; ffffffd4H
  004f0	0c 00 00 00	 DD	 12			; 0000000cH
  004f4	00 00 00 00	 DD	 $LN19@convert_yv
  004f8	60 ff ff ff	 DD	 -160			; ffffff60H
  004fc	0c 00 00 00	 DD	 12			; 0000000cH
  00500	00 00 00 00	 DD	 $LN20@convert_yv
$LN20@convert_yv:
  00504	75		 DB	 117			; 00000075H
  00505	76		 DB	 118			; 00000076H
  00506	5f		 DB	 95			; 0000005fH
  00507	72		 DB	 114			; 00000072H
  00508	61		 DB	 97			; 00000061H
  00509	6e		 DB	 110			; 0000006eH
  0050a	67		 DB	 103			; 00000067H
  0050b	65		 DB	 101			; 00000065H
  0050c	00		 DB	 0
$LN19@convert_yv:
  0050d	79		 DB	 121			; 00000079H
  0050e	5f		 DB	 95			; 0000005fH
  0050f	72		 DB	 114			; 00000072H
  00510	61		 DB	 97			; 00000061H
  00511	6e		 DB	 110			; 0000006eH
  00512	67		 DB	 103			; 00000067H
  00513	65		 DB	 101			; 00000065H
  00514	00		 DB	 0
??$convert_yv12_high_to_p010_simd@$09$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_high_to_p010_simd<10,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_sse2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yv12_10_to_p010_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_10_to_p010_sse2

; 137  : void convert_yv12_10_to_p010_sse2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 138  :     convert_yv12_high_to_p010_simd<10, false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yv12_high_to_p010_simd@$09$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_high_to_p010_simd<10,0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 139  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yv12_10_to_p010_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_10_to_p010_sse2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -416						; size = 12
$T2 = -400						; size = 12
$T3 = -384						; size = 16
$T4 = -368						; size = 16
$T5 = -352						; size = 16
$T6 = -336						; size = 16
$T7 = -320						; size = 16
$T8 = -304						; size = 16
_x$9 = -276						; size = 4
_x2$10 = -272						; size = 16
_x1$11 = -256						; size = 16
_x0$12 = -240						; size = 16
_dst_ptr$13 = -212					; size = 4
_src_v_ptr$14 = -208					; size = 4
_src_u_ptr$15 = -204					; size = 4
_x_fin$16 = -200					; size = 4
_y$17 = -196						; size = 4
_dstLine$ = -192					; size = 4
_srcVLine$ = -188					; size = 4
_srcULine$ = -184					; size = 4
_src_uv_pitch$ = -180					; size = 4
$T18 = -176						; size = 12
_uv_range$ = -160					; size = 12
$T19 = -144						; size = 16
$T20 = -128						; size = 16
_x0$21 = -112						; size = 16
_x$22 = -88						; size = 4
_dst_ptr$23 = -84					; size = 4
_src_ptr$24 = -80					; size = 4
_y$25 = -76						; size = 4
_y_width$26 = -72					; size = 4
_dstLine$27 = -68					; size = 4
_srcYLine$28 = -64					; size = 4
$T29 = -60						; size = 12
_y_range$30 = -44					; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yv12_high_to_p010_simd@$0M@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_high_to_p010_simd<12,0>

; 1036 : static void __forceinline convert_yv12_high_to_p010_simd(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec a0 01 00
	00		 sub	 esp, 416		; 000001a0H
  0001c	57		 push	 edi
  0001d	8d bd 60 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-416]
  00023	b9 68 00 00 00	 mov	 ecx, 104		; 00000068H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1037 :     static_assert(8 < in_bit_depth && in_bit_depth <= 16, "in_bit_depth must be 9-16.");
; 1038 :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 1039 :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 1040 :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 1041 :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 1042 :     const int src_y_pitch = src_y_pitch_byte >> 1;

  0007c	8b 53 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  0007f	d1 fa		 sar	 edx, 1
  00081	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 1043 :     const int dst_y_pitch = dst_y_pitch_byte >> 1;

  00084	8b 43 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  00087	d1 f8		 sar	 eax, 1
  00089	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 1044 :     //Y成分のコピー
; 1045 :     if (!uv_only) {

  0008c	b9 01 00 00 00	 mov	 ecx, 1
  00091	85 c9		 test	 ecx, ecx
  00093	0f 84 55 01 00
	00		 je	 $LN14@convert_yv

; 1046 :         const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00099	8b 53 2c	 mov	 edx, DWORD PTR _thread_n$[ebx]
  0009c	52		 push	 edx
  0009d	8b 43 28	 mov	 eax, DWORD PTR _thread_id$[ebx]
  000a0	50		 push	 eax
  000a1	8b 4b 20	 mov	 ecx, DWORD PTR _height$[ebx]
  000a4	2b 4d ec	 sub	 ecx, DWORD PTR _crop_bottom$[ebp]
  000a7	51		 push	 ecx
  000a8	8b 55 f4	 mov	 edx, DWORD PTR _crop_up$[ebp]
  000ab	52		 push	 edx
  000ac	8d 85 70 fe ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  000b2	50		 push	 eax
  000b3	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  000b8	83 c4 14	 add	 esp, 20			; 00000014H
  000bb	8b 08		 mov	 ecx, DWORD PTR [eax]
  000bd	89 4d c4	 mov	 DWORD PTR $T29[ebp], ecx
  000c0	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000c3	89 55 c8	 mov	 DWORD PTR $T29[ebp+4], edx
  000c6	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000c9	89 45 cc	 mov	 DWORD PTR $T29[ebp+8], eax
  000cc	8b 4d c4	 mov	 ecx, DWORD PTR $T29[ebp]
  000cf	89 4d d4	 mov	 DWORD PTR _y_range$30[ebp], ecx
  000d2	8b 55 c8	 mov	 edx, DWORD PTR $T29[ebp+4]
  000d5	89 55 d8	 mov	 DWORD PTR _y_range$30[ebp+4], edx
  000d8	8b 45 cc	 mov	 eax, DWORD PTR $T29[ebp+8]
  000db	89 45 dc	 mov	 DWORD PTR _y_range$30[ebp+8], eax

; 1047 :         uint16_t *srcYLine = (uint16_t *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000de	b9 04 00 00 00	 mov	 ecx, 4
  000e3	6b d1 00	 imul	 edx, ecx, 0
  000e6	8b 45 e8	 mov	 eax, DWORD PTR _src_y_pitch$[ebp]
  000e9	0f af 45 d4	 imul	 eax, DWORD PTR _y_range$30[ebp]
  000ed	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  000f0	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  000f3	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  000f6	8b 4d f8	 mov	 ecx, DWORD PTR _crop_left$[ebp]
  000f9	8d 14 48	 lea	 edx, DWORD PTR [eax+ecx*2]
  000fc	89 55 c0	 mov	 DWORD PTR _srcYLine$28[ebp], edx

; 1048 :         uint16_t *dstLine = (uint16_t *)dst[0] + dst_y_pitch * y_range.start_dst;

  000ff	b8 04 00 00 00	 mov	 eax, 4
  00104	6b c8 00	 imul	 ecx, eax, 0
  00107	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  0010a	0f af 55 d8	 imul	 edx, DWORD PTR _y_range$30[ebp+4]
  0010e	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  00111	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  00114	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  00117	89 55 bc	 mov	 DWORD PTR _dstLine$27[ebp], edx

; 1049 :         const int y_width = width - crop_right - crop_left;

  0011a	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  0011d	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  00120	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  00123	89 45 b8	 mov	 DWORD PTR _y_width$26[ebp], eax

; 1050 :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  00126	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _y$25[ebp], 0
  0012d	eb 21		 jmp	 SHORT $LN4@convert_yv
$LN2@convert_yv:
  0012f	8b 4d b4	 mov	 ecx, DWORD PTR _y$25[ebp]
  00132	83 c1 01	 add	 ecx, 1
  00135	89 4d b4	 mov	 DWORD PTR _y$25[ebp], ecx
  00138	8b 55 e8	 mov	 edx, DWORD PTR _src_y_pitch$[ebp]
  0013b	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$28[ebp]
  0013e	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00141	89 4d c0	 mov	 DWORD PTR _srcYLine$28[ebp], ecx
  00144	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  00147	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$27[ebp]
  0014a	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  0014d	89 4d bc	 mov	 DWORD PTR _dstLine$27[ebp], ecx
$LN4@convert_yv:
  00150	8b 55 b4	 mov	 edx, DWORD PTR _y$25[ebp]
  00153	3b 55 dc	 cmp	 edx, DWORD PTR _y_range$30[ebp+8]
  00156	0f 8d 92 00 00
	00		 jge	 $LN14@convert_yv

; 1051 :             if (in_bit_depth == 16) {

  0015c	33 c0		 xor	 eax, eax
  0015e	74 18		 je	 SHORT $LN15@convert_yv

; 1052 :                 memcpy_sse((uint8_t *)dstLine, (uint8_t *)srcYLine, y_width * sizeof(uint16_t));

  00160	8b 4d b8	 mov	 ecx, DWORD PTR _y_width$26[ebp]
  00163	d1 e1		 shl	 ecx, 1
  00165	51		 push	 ecx
  00166	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$28[ebp]
  00169	52		 push	 edx
  0016a	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$27[ebp]
  0016d	50		 push	 eax
  0016e	e8 00 00 00 00	 call	 ?memcpy_sse@@YAXPAEPBEH@Z ; memcpy_sse
  00173	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1053 :             } else {

  00176	eb 71		 jmp	 SHORT $LN16@convert_yv
$LN15@convert_yv:

; 1054 :                 uint16_t *src_ptr = srcYLine;

  00178	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$28[ebp]
  0017b	89 4d b0	 mov	 DWORD PTR _src_ptr$24[ebp], ecx

; 1055 :                 uint16_t *dst_ptr = dstLine;

  0017e	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$27[ebp]
  00181	89 55 ac	 mov	 DWORD PTR _dst_ptr$23[ebp], edx

; 1056 :                 for (int x = 0; x < y_width; x += 8, dst_ptr += 8, src_ptr += 8) {

  00184	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR _x$22[ebp], 0
  0018b	eb 1b		 jmp	 SHORT $LN7@convert_yv
$LN5@convert_yv:
  0018d	8b 45 a8	 mov	 eax, DWORD PTR _x$22[ebp]
  00190	83 c0 08	 add	 eax, 8
  00193	89 45 a8	 mov	 DWORD PTR _x$22[ebp], eax
  00196	8b 4d ac	 mov	 ecx, DWORD PTR _dst_ptr$23[ebp]
  00199	83 c1 10	 add	 ecx, 16			; 00000010H
  0019c	89 4d ac	 mov	 DWORD PTR _dst_ptr$23[ebp], ecx
  0019f	8b 55 b0	 mov	 edx, DWORD PTR _src_ptr$24[ebp]
  001a2	83 c2 10	 add	 edx, 16			; 00000010H
  001a5	89 55 b0	 mov	 DWORD PTR _src_ptr$24[ebp], edx
$LN7@convert_yv:
  001a8	8b 45 a8	 mov	 eax, DWORD PTR _x$22[ebp]
  001ab	3b 45 b8	 cmp	 eax, DWORD PTR _y_width$26[ebp]
  001ae	7d 39		 jge	 SHORT $LN16@convert_yv

; 1057 :                     __m128i x0 = _mm_loadu_si128((const __m128i *)src_ptr);

  001b0	8b 4d b0	 mov	 ecx, DWORD PTR _src_ptr$24[ebp]
  001b3	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  001b6	0f 29 45 80	 movaps	 XMMWORD PTR $T20[ebp], xmm0
  001ba	0f 28 45 80	 movaps	 xmm0, XMMWORD PTR $T20[ebp]
  001be	0f 29 45 90	 movaps	 XMMWORD PTR _x0$21[ebp], xmm0

; 1058 :                     x0 = _mm_slli_epi16(x0, 16 - in_bit_depth);

  001c2	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR _x0$21[ebp]
  001c6	66 0f 71 f0 04	 psllw	 xmm0, 4
  001cb	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR $T19[ebp], xmm0
  001d2	0f 28 85 70 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T19[ebp]
  001d9	0f 29 45 90	 movaps	 XMMWORD PTR _x0$21[ebp], xmm0

; 1059 :                     _mm_storeu_si128((__m128i *)dst_ptr, x0);

  001dd	0f 10 45 90	 movups	 xmm0, XMMWORD PTR _x0$21[ebp]
  001e1	8b 55 ac	 mov	 edx, DWORD PTR _dst_ptr$23[ebp]
  001e4	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 1060 :                 }

  001e7	eb a4		 jmp	 SHORT $LN5@convert_yv
$LN16@convert_yv:

; 1061 :             }
; 1062 :         }

  001e9	e9 41 ff ff ff	 jmp	 $LN2@convert_yv
$LN14@convert_yv:

; 1063 :     }
; 1064 :     //UV成分のコピー
; 1065 :     const auto uv_range = thread_y_range(crop_up >> 1, (height - crop_bottom) >> 1, thread_id, thread_n);

  001ee	8b 43 2c	 mov	 eax, DWORD PTR _thread_n$[ebx]
  001f1	50		 push	 eax
  001f2	8b 4b 28	 mov	 ecx, DWORD PTR _thread_id$[ebx]
  001f5	51		 push	 ecx
  001f6	8b 53 20	 mov	 edx, DWORD PTR _height$[ebx]
  001f9	2b 55 ec	 sub	 edx, DWORD PTR _crop_bottom$[ebp]
  001fc	d1 fa		 sar	 edx, 1
  001fe	52		 push	 edx
  001ff	8b 45 f4	 mov	 eax, DWORD PTR _crop_up$[ebp]
  00202	d1 f8		 sar	 eax, 1
  00204	50		 push	 eax
  00205	8d 8d 60 fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  0020b	51		 push	 ecx
  0020c	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00211	83 c4 14	 add	 esp, 20			; 00000014H
  00214	8b 10		 mov	 edx, DWORD PTR [eax]
  00216	89 95 50 ff ff
	ff		 mov	 DWORD PTR $T18[ebp], edx
  0021c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0021f	89 8d 54 ff ff
	ff		 mov	 DWORD PTR $T18[ebp+4], ecx
  00225	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00228	89 95 58 ff ff
	ff		 mov	 DWORD PTR $T18[ebp+8], edx
  0022e	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR $T18[ebp]
  00234	89 85 60 ff ff
	ff		 mov	 DWORD PTR _uv_range$[ebp], eax
  0023a	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR $T18[ebp+4]
  00240	89 8d 64 ff ff
	ff		 mov	 DWORD PTR _uv_range$[ebp+4], ecx
  00246	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR $T18[ebp+8]
  0024c	89 95 68 ff ff
	ff		 mov	 DWORD PTR _uv_range$[ebp+8], edx

; 1066 :     const int src_uv_pitch = src_uv_pitch_byte >> 1;

  00252	8b 43 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebx]
  00255	d1 f8		 sar	 eax, 1
  00257	89 85 4c ff ff
	ff		 mov	 DWORD PTR _src_uv_pitch$[ebp], eax

; 1067 :     uint16_t *srcULine = (uint16_t *)src[1] + ((src_uv_pitch * uv_range.start_src) + (crop_left >> 1));

  0025d	b9 04 00 00 00	 mov	 ecx, 4
  00262	c1 e1 00	 shl	 ecx, 0
  00265	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  0026b	0f af 95 60 ff
	ff ff		 imul	 edx, DWORD PTR _uv_range$[ebp]
  00272	8b 45 f8	 mov	 eax, DWORD PTR _crop_left$[ebp]
  00275	d1 f8		 sar	 eax, 1
  00277	03 d0		 add	 edx, eax
  00279	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  0027c	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  0027f	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  00282	89 95 48 ff ff
	ff		 mov	 DWORD PTR _srcULine$[ebp], edx

; 1068 :     uint16_t *srcVLine = (uint16_t *)src[2] + ((src_uv_pitch * uv_range.start_src) + (crop_left >> 1));

  00288	b8 04 00 00 00	 mov	 eax, 4
  0028d	d1 e0		 shl	 eax, 1
  0028f	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00295	0f af 8d 60 ff
	ff ff		 imul	 ecx, DWORD PTR _uv_range$[ebp]
  0029c	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  0029f	d1 fa		 sar	 edx, 1
  002a1	03 ca		 add	 ecx, edx
  002a3	8b 53 0c	 mov	 edx, DWORD PTR _src$[ebx]
  002a6	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  002a9	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  002ac	89 8d 44 ff ff
	ff		 mov	 DWORD PTR _srcVLine$[ebp], ecx

; 1069 :     uint16_t *dstLine = (uint16_t *)dst[1] + dst_y_pitch * uv_range.start_dst;

  002b2	ba 04 00 00 00	 mov	 edx, 4
  002b7	c1 e2 00	 shl	 edx, 0
  002ba	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  002bd	0f af 85 64 ff
	ff ff		 imul	 eax, DWORD PTR _uv_range$[ebp+4]
  002c4	8b 4b 08	 mov	 ecx, DWORD PTR _dst$[ebx]
  002c7	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  002ca	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  002cd	89 85 40 ff ff
	ff		 mov	 DWORD PTR _dstLine$[ebp], eax

; 1070 :     for (int y = 0; y < uv_range.len; y++, srcULine += src_uv_pitch, srcVLine += src_uv_pitch, dstLine += dst_y_pitch) {

  002d3	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _y$17[ebp], 0
  002dd	eb 4b		 jmp	 SHORT $LN10@convert_yv
$LN8@convert_yv:
  002df	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _y$17[ebp]
  002e5	83 c1 01	 add	 ecx, 1
  002e8	89 8d 3c ff ff
	ff		 mov	 DWORD PTR _y$17[ebp], ecx
  002ee	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  002f4	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _srcULine$[ebp]
  002fa	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  002fd	89 8d 48 ff ff
	ff		 mov	 DWORD PTR _srcULine$[ebp], ecx
  00303	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  00309	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _srcVLine$[ebp]
  0030f	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00312	89 8d 44 ff ff
	ff		 mov	 DWORD PTR _srcVLine$[ebp], ecx
  00318	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  0031b	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _dstLine$[ebp]
  00321	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00324	89 8d 40 ff ff
	ff		 mov	 DWORD PTR _dstLine$[ebp], ecx
$LN10@convert_yv:
  0032a	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR _y$17[ebp]
  00330	3b 95 68 ff ff
	ff		 cmp	 edx, DWORD PTR _uv_range$[ebp+8]
  00336	0f 8d 85 01 00
	00		 jge	 $LN1@convert_yv

; 1071 :         const int x_fin = width - crop_right;

  0033c	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  0033f	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  00342	89 85 38 ff ff
	ff		 mov	 DWORD PTR _x_fin$16[ebp], eax

; 1072 :         uint16_t *src_u_ptr = srcULine;

  00348	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR _srcULine$[ebp]
  0034e	89 8d 34 ff ff
	ff		 mov	 DWORD PTR _src_u_ptr$15[ebp], ecx

; 1073 :         uint16_t *src_v_ptr = srcVLine;

  00354	8b 95 44 ff ff
	ff		 mov	 edx, DWORD PTR _srcVLine$[ebp]
  0035a	89 95 30 ff ff
	ff		 mov	 DWORD PTR _src_v_ptr$14[ebp], edx

; 1074 :         uint16_t *dst_ptr = dstLine;

  00360	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _dstLine$[ebp]
  00366	89 85 2c ff ff
	ff		 mov	 DWORD PTR _dst_ptr$13[ebp], eax

; 1075 :         __m128i x0, x1, x2;
; 1076 :         for (int x = crop_left; x < x_fin; x += 16, src_u_ptr += 8, src_v_ptr += 8, dst_ptr += 16) {

  0036c	8b 4d f8	 mov	 ecx, DWORD PTR _crop_left$[ebp]
  0036f	89 8d ec fe ff
	ff		 mov	 DWORD PTR _x$9[ebp], ecx
  00375	eb 3c		 jmp	 SHORT $LN13@convert_yv
$LN11@convert_yv:
  00377	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _x$9[ebp]
  0037d	83 c2 10	 add	 edx, 16			; 00000010H
  00380	89 95 ec fe ff
	ff		 mov	 DWORD PTR _x$9[ebp], edx
  00386	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR _src_u_ptr$15[ebp]
  0038c	83 c0 10	 add	 eax, 16			; 00000010H
  0038f	89 85 34 ff ff
	ff		 mov	 DWORD PTR _src_u_ptr$15[ebp], eax
  00395	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR _src_v_ptr$14[ebp]
  0039b	83 c1 10	 add	 ecx, 16			; 00000010H
  0039e	89 8d 30 ff ff
	ff		 mov	 DWORD PTR _src_v_ptr$14[ebp], ecx
  003a4	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR _dst_ptr$13[ebp]
  003aa	83 c2 20	 add	 edx, 32			; 00000020H
  003ad	89 95 2c ff ff
	ff		 mov	 DWORD PTR _dst_ptr$13[ebp], edx
$LN13@convert_yv:
  003b3	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _x$9[ebp]
  003b9	3b 85 38 ff ff
	ff		 cmp	 eax, DWORD PTR _x_fin$16[ebp]
  003bf	0f 8d f7 00 00
	00		 jge	 $LN12@convert_yv

; 1077 :             x0 = _mm_loadu_si128((const __m128i *)src_u_ptr);

  003c5	8b 8d 34 ff ff
	ff		 mov	 ecx, DWORD PTR _src_u_ptr$15[ebp]
  003cb	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  003ce	0f 29 85 d0 fe
	ff ff		 movaps	 XMMWORD PTR $T8[ebp], xmm0
  003d5	0f 28 85 d0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T8[ebp]
  003dc	0f 29 85 10 ff
	ff ff		 movaps	 XMMWORD PTR _x0$12[ebp], xmm0

; 1078 :             x1 = _mm_loadu_si128((const __m128i *)src_v_ptr);

  003e3	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR _src_v_ptr$14[ebp]
  003e9	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  003ec	0f 29 85 c0 fe
	ff ff		 movaps	 XMMWORD PTR $T7[ebp], xmm0
  003f3	0f 28 85 c0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T7[ebp]
  003fa	0f 29 85 00 ff
	ff ff		 movaps	 XMMWORD PTR _x1$11[ebp], xmm0

; 1079 : 
; 1080 :             if (in_bit_depth < 16) {

  00401	b8 01 00 00 00	 mov	 eax, 1
  00406	85 c0		 test	 eax, eax
  00408	74 42		 je	 SHORT $LN17@convert_yv

; 1081 :                 x0 = _mm_slli_epi16(x0, 16 - in_bit_depth);

  0040a	0f 28 85 10 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x0$12[ebp]
  00411	66 0f 71 f0 04	 psllw	 xmm0, 4
  00416	0f 29 85 b0 fe
	ff ff		 movaps	 XMMWORD PTR $T6[ebp], xmm0
  0041d	0f 28 85 b0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T6[ebp]
  00424	0f 29 85 10 ff
	ff ff		 movaps	 XMMWORD PTR _x0$12[ebp], xmm0

; 1082 :                 x1 = _mm_slli_epi16(x1, 16 - in_bit_depth);

  0042b	0f 28 85 00 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$11[ebp]
  00432	66 0f 71 f0 04	 psllw	 xmm0, 4
  00437	0f 29 85 a0 fe
	ff ff		 movaps	 XMMWORD PTR $T5[ebp], xmm0
  0043e	0f 28 85 a0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T5[ebp]
  00445	0f 29 85 00 ff
	ff ff		 movaps	 XMMWORD PTR _x1$11[ebp], xmm0
$LN17@convert_yv:

; 1083 :             }
; 1084 : 
; 1085 :             x2 = _mm_unpackhi_epi16(x0, x1);

  0044c	0f 28 85 10 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x0$12[ebp]
  00453	66 0f 69 85 00
	ff ff ff	 punpckhwd xmm0, XMMWORD PTR _x1$11[ebp]
  0045b	0f 29 85 90 fe
	ff ff		 movaps	 XMMWORD PTR $T4[ebp], xmm0
  00462	0f 28 85 90 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T4[ebp]
  00469	0f 29 85 f0 fe
	ff ff		 movaps	 XMMWORD PTR _x2$10[ebp], xmm0

; 1086 :             x0 = _mm_unpacklo_epi16(x0, x1);

  00470	0f 28 85 10 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x0$12[ebp]
  00477	66 0f 61 85 00
	ff ff ff	 punpcklwd xmm0, XMMWORD PTR _x1$11[ebp]
  0047f	0f 29 85 80 fe
	ff ff		 movaps	 XMMWORD PTR $T3[ebp], xmm0
  00486	0f 28 85 80 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T3[ebp]
  0048d	0f 29 85 10 ff
	ff ff		 movaps	 XMMWORD PTR _x0$12[ebp], xmm0

; 1087 : 
; 1088 :             _mm_storeu_si128((__m128i *)(dst_ptr + 0), x0);

  00494	0f 10 85 10 ff
	ff ff		 movups	 xmm0, XMMWORD PTR _x0$12[ebp]
  0049b	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR _dst_ptr$13[ebp]
  004a1	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 1089 :             _mm_storeu_si128((__m128i *)(dst_ptr + 8), x2);

  004a4	0f 10 85 f0 fe
	ff ff		 movups	 xmm0, XMMWORD PTR _x2$10[ebp]
  004ab	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR _dst_ptr$13[ebp]
  004b1	83 c2 10	 add	 edx, 16			; 00000010H
  004b4	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 1090 :         }

  004b7	e9 bb fe ff ff	 jmp	 $LN11@convert_yv
$LN12@convert_yv:

; 1091 :     }

  004bc	e9 1e fe ff ff	 jmp	 $LN8@convert_yv
$LN1@convert_yv:

; 1092 : }

  004c1	52		 push	 edx
  004c2	8b cd		 mov	 ecx, ebp
  004c4	50		 push	 eax
  004c5	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN22@convert_yv
  004cb	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  004d0	58		 pop	 eax
  004d1	5a		 pop	 edx
  004d2	5f		 pop	 edi
  004d3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004d6	33 cd		 xor	 ecx, ebp
  004d8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004dd	8b e5		 mov	 esp, ebp
  004df	5d		 pop	 ebp
  004e0	8b e3		 mov	 esp, ebx
  004e2	5b		 pop	 ebx
  004e3	c3		 ret	 0
$LN22@convert_yv:
  004e4	02 00 00 00	 DD	 2
  004e8	00 00 00 00	 DD	 $LN21@convert_yv
$LN21@convert_yv:
  004ec	d4 ff ff ff	 DD	 -44			; ffffffd4H
  004f0	0c 00 00 00	 DD	 12			; 0000000cH
  004f4	00 00 00 00	 DD	 $LN19@convert_yv
  004f8	60 ff ff ff	 DD	 -160			; ffffff60H
  004fc	0c 00 00 00	 DD	 12			; 0000000cH
  00500	00 00 00 00	 DD	 $LN20@convert_yv
$LN20@convert_yv:
  00504	75		 DB	 117			; 00000075H
  00505	76		 DB	 118			; 00000076H
  00506	5f		 DB	 95			; 0000005fH
  00507	72		 DB	 114			; 00000072H
  00508	61		 DB	 97			; 00000061H
  00509	6e		 DB	 110			; 0000006eH
  0050a	67		 DB	 103			; 00000067H
  0050b	65		 DB	 101			; 00000065H
  0050c	00		 DB	 0
$LN19@convert_yv:
  0050d	79		 DB	 121			; 00000079H
  0050e	5f		 DB	 95			; 0000005fH
  0050f	72		 DB	 114			; 00000072H
  00510	61		 DB	 97			; 00000061H
  00511	6e		 DB	 110			; 0000006eH
  00512	67		 DB	 103			; 00000067H
  00513	65		 DB	 101			; 00000065H
  00514	00		 DB	 0
??$convert_yv12_high_to_p010_simd@$0M@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_high_to_p010_simd<12,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_sse2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yv12_12_to_p010_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_12_to_p010_sse2

; 133  : void convert_yv12_12_to_p010_sse2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 134  :     convert_yv12_high_to_p010_simd<12, false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yv12_high_to_p010_simd@$0M@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_high_to_p010_simd<12,0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 135  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yv12_12_to_p010_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_12_to_p010_sse2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -416						; size = 12
$T2 = -400						; size = 12
$T3 = -384						; size = 16
$T4 = -368						; size = 16
$T5 = -352						; size = 16
$T6 = -336						; size = 16
$T7 = -320						; size = 16
$T8 = -304						; size = 16
_x$9 = -276						; size = 4
_x2$10 = -272						; size = 16
_x1$11 = -256						; size = 16
_x0$12 = -240						; size = 16
_dst_ptr$13 = -212					; size = 4
_src_v_ptr$14 = -208					; size = 4
_src_u_ptr$15 = -204					; size = 4
_x_fin$16 = -200					; size = 4
_y$17 = -196						; size = 4
_dstLine$ = -192					; size = 4
_srcVLine$ = -188					; size = 4
_srcULine$ = -184					; size = 4
_src_uv_pitch$ = -180					; size = 4
$T18 = -176						; size = 12
_uv_range$ = -160					; size = 12
$T19 = -144						; size = 16
$T20 = -128						; size = 16
_x0$21 = -112						; size = 16
_x$22 = -88						; size = 4
_dst_ptr$23 = -84					; size = 4
_src_ptr$24 = -80					; size = 4
_y$25 = -76						; size = 4
_y_width$26 = -72					; size = 4
_dstLine$27 = -68					; size = 4
_srcYLine$28 = -64					; size = 4
$T29 = -60						; size = 12
_y_range$30 = -44					; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yv12_high_to_p010_simd@$0O@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_high_to_p010_simd<14,0>

; 1036 : static void __forceinline convert_yv12_high_to_p010_simd(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec a0 01 00
	00		 sub	 esp, 416		; 000001a0H
  0001c	57		 push	 edi
  0001d	8d bd 60 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-416]
  00023	b9 68 00 00 00	 mov	 ecx, 104		; 00000068H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1037 :     static_assert(8 < in_bit_depth && in_bit_depth <= 16, "in_bit_depth must be 9-16.");
; 1038 :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 1039 :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 1040 :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 1041 :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 1042 :     const int src_y_pitch = src_y_pitch_byte >> 1;

  0007c	8b 53 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  0007f	d1 fa		 sar	 edx, 1
  00081	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 1043 :     const int dst_y_pitch = dst_y_pitch_byte >> 1;

  00084	8b 43 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  00087	d1 f8		 sar	 eax, 1
  00089	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 1044 :     //Y成分のコピー
; 1045 :     if (!uv_only) {

  0008c	b9 01 00 00 00	 mov	 ecx, 1
  00091	85 c9		 test	 ecx, ecx
  00093	0f 84 55 01 00
	00		 je	 $LN14@convert_yv

; 1046 :         const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00099	8b 53 2c	 mov	 edx, DWORD PTR _thread_n$[ebx]
  0009c	52		 push	 edx
  0009d	8b 43 28	 mov	 eax, DWORD PTR _thread_id$[ebx]
  000a0	50		 push	 eax
  000a1	8b 4b 20	 mov	 ecx, DWORD PTR _height$[ebx]
  000a4	2b 4d ec	 sub	 ecx, DWORD PTR _crop_bottom$[ebp]
  000a7	51		 push	 ecx
  000a8	8b 55 f4	 mov	 edx, DWORD PTR _crop_up$[ebp]
  000ab	52		 push	 edx
  000ac	8d 85 70 fe ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  000b2	50		 push	 eax
  000b3	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  000b8	83 c4 14	 add	 esp, 20			; 00000014H
  000bb	8b 08		 mov	 ecx, DWORD PTR [eax]
  000bd	89 4d c4	 mov	 DWORD PTR $T29[ebp], ecx
  000c0	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000c3	89 55 c8	 mov	 DWORD PTR $T29[ebp+4], edx
  000c6	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000c9	89 45 cc	 mov	 DWORD PTR $T29[ebp+8], eax
  000cc	8b 4d c4	 mov	 ecx, DWORD PTR $T29[ebp]
  000cf	89 4d d4	 mov	 DWORD PTR _y_range$30[ebp], ecx
  000d2	8b 55 c8	 mov	 edx, DWORD PTR $T29[ebp+4]
  000d5	89 55 d8	 mov	 DWORD PTR _y_range$30[ebp+4], edx
  000d8	8b 45 cc	 mov	 eax, DWORD PTR $T29[ebp+8]
  000db	89 45 dc	 mov	 DWORD PTR _y_range$30[ebp+8], eax

; 1047 :         uint16_t *srcYLine = (uint16_t *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000de	b9 04 00 00 00	 mov	 ecx, 4
  000e3	6b d1 00	 imul	 edx, ecx, 0
  000e6	8b 45 e8	 mov	 eax, DWORD PTR _src_y_pitch$[ebp]
  000e9	0f af 45 d4	 imul	 eax, DWORD PTR _y_range$30[ebp]
  000ed	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  000f0	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  000f3	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  000f6	8b 4d f8	 mov	 ecx, DWORD PTR _crop_left$[ebp]
  000f9	8d 14 48	 lea	 edx, DWORD PTR [eax+ecx*2]
  000fc	89 55 c0	 mov	 DWORD PTR _srcYLine$28[ebp], edx

; 1048 :         uint16_t *dstLine = (uint16_t *)dst[0] + dst_y_pitch * y_range.start_dst;

  000ff	b8 04 00 00 00	 mov	 eax, 4
  00104	6b c8 00	 imul	 ecx, eax, 0
  00107	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  0010a	0f af 55 d8	 imul	 edx, DWORD PTR _y_range$30[ebp+4]
  0010e	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  00111	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  00114	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  00117	89 55 bc	 mov	 DWORD PTR _dstLine$27[ebp], edx

; 1049 :         const int y_width = width - crop_right - crop_left;

  0011a	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  0011d	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  00120	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  00123	89 45 b8	 mov	 DWORD PTR _y_width$26[ebp], eax

; 1050 :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  00126	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _y$25[ebp], 0
  0012d	eb 21		 jmp	 SHORT $LN4@convert_yv
$LN2@convert_yv:
  0012f	8b 4d b4	 mov	 ecx, DWORD PTR _y$25[ebp]
  00132	83 c1 01	 add	 ecx, 1
  00135	89 4d b4	 mov	 DWORD PTR _y$25[ebp], ecx
  00138	8b 55 e8	 mov	 edx, DWORD PTR _src_y_pitch$[ebp]
  0013b	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$28[ebp]
  0013e	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00141	89 4d c0	 mov	 DWORD PTR _srcYLine$28[ebp], ecx
  00144	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  00147	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$27[ebp]
  0014a	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  0014d	89 4d bc	 mov	 DWORD PTR _dstLine$27[ebp], ecx
$LN4@convert_yv:
  00150	8b 55 b4	 mov	 edx, DWORD PTR _y$25[ebp]
  00153	3b 55 dc	 cmp	 edx, DWORD PTR _y_range$30[ebp+8]
  00156	0f 8d 92 00 00
	00		 jge	 $LN14@convert_yv

; 1051 :             if (in_bit_depth == 16) {

  0015c	33 c0		 xor	 eax, eax
  0015e	74 18		 je	 SHORT $LN15@convert_yv

; 1052 :                 memcpy_sse((uint8_t *)dstLine, (uint8_t *)srcYLine, y_width * sizeof(uint16_t));

  00160	8b 4d b8	 mov	 ecx, DWORD PTR _y_width$26[ebp]
  00163	d1 e1		 shl	 ecx, 1
  00165	51		 push	 ecx
  00166	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$28[ebp]
  00169	52		 push	 edx
  0016a	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$27[ebp]
  0016d	50		 push	 eax
  0016e	e8 00 00 00 00	 call	 ?memcpy_sse@@YAXPAEPBEH@Z ; memcpy_sse
  00173	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1053 :             } else {

  00176	eb 71		 jmp	 SHORT $LN16@convert_yv
$LN15@convert_yv:

; 1054 :                 uint16_t *src_ptr = srcYLine;

  00178	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$28[ebp]
  0017b	89 4d b0	 mov	 DWORD PTR _src_ptr$24[ebp], ecx

; 1055 :                 uint16_t *dst_ptr = dstLine;

  0017e	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$27[ebp]
  00181	89 55 ac	 mov	 DWORD PTR _dst_ptr$23[ebp], edx

; 1056 :                 for (int x = 0; x < y_width; x += 8, dst_ptr += 8, src_ptr += 8) {

  00184	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR _x$22[ebp], 0
  0018b	eb 1b		 jmp	 SHORT $LN7@convert_yv
$LN5@convert_yv:
  0018d	8b 45 a8	 mov	 eax, DWORD PTR _x$22[ebp]
  00190	83 c0 08	 add	 eax, 8
  00193	89 45 a8	 mov	 DWORD PTR _x$22[ebp], eax
  00196	8b 4d ac	 mov	 ecx, DWORD PTR _dst_ptr$23[ebp]
  00199	83 c1 10	 add	 ecx, 16			; 00000010H
  0019c	89 4d ac	 mov	 DWORD PTR _dst_ptr$23[ebp], ecx
  0019f	8b 55 b0	 mov	 edx, DWORD PTR _src_ptr$24[ebp]
  001a2	83 c2 10	 add	 edx, 16			; 00000010H
  001a5	89 55 b0	 mov	 DWORD PTR _src_ptr$24[ebp], edx
$LN7@convert_yv:
  001a8	8b 45 a8	 mov	 eax, DWORD PTR _x$22[ebp]
  001ab	3b 45 b8	 cmp	 eax, DWORD PTR _y_width$26[ebp]
  001ae	7d 39		 jge	 SHORT $LN16@convert_yv

; 1057 :                     __m128i x0 = _mm_loadu_si128((const __m128i *)src_ptr);

  001b0	8b 4d b0	 mov	 ecx, DWORD PTR _src_ptr$24[ebp]
  001b3	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  001b6	0f 29 45 80	 movaps	 XMMWORD PTR $T20[ebp], xmm0
  001ba	0f 28 45 80	 movaps	 xmm0, XMMWORD PTR $T20[ebp]
  001be	0f 29 45 90	 movaps	 XMMWORD PTR _x0$21[ebp], xmm0

; 1058 :                     x0 = _mm_slli_epi16(x0, 16 - in_bit_depth);

  001c2	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR _x0$21[ebp]
  001c6	66 0f 71 f0 02	 psllw	 xmm0, 2
  001cb	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR $T19[ebp], xmm0
  001d2	0f 28 85 70 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T19[ebp]
  001d9	0f 29 45 90	 movaps	 XMMWORD PTR _x0$21[ebp], xmm0

; 1059 :                     _mm_storeu_si128((__m128i *)dst_ptr, x0);

  001dd	0f 10 45 90	 movups	 xmm0, XMMWORD PTR _x0$21[ebp]
  001e1	8b 55 ac	 mov	 edx, DWORD PTR _dst_ptr$23[ebp]
  001e4	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 1060 :                 }

  001e7	eb a4		 jmp	 SHORT $LN5@convert_yv
$LN16@convert_yv:

; 1061 :             }
; 1062 :         }

  001e9	e9 41 ff ff ff	 jmp	 $LN2@convert_yv
$LN14@convert_yv:

; 1063 :     }
; 1064 :     //UV成分のコピー
; 1065 :     const auto uv_range = thread_y_range(crop_up >> 1, (height - crop_bottom) >> 1, thread_id, thread_n);

  001ee	8b 43 2c	 mov	 eax, DWORD PTR _thread_n$[ebx]
  001f1	50		 push	 eax
  001f2	8b 4b 28	 mov	 ecx, DWORD PTR _thread_id$[ebx]
  001f5	51		 push	 ecx
  001f6	8b 53 20	 mov	 edx, DWORD PTR _height$[ebx]
  001f9	2b 55 ec	 sub	 edx, DWORD PTR _crop_bottom$[ebp]
  001fc	d1 fa		 sar	 edx, 1
  001fe	52		 push	 edx
  001ff	8b 45 f4	 mov	 eax, DWORD PTR _crop_up$[ebp]
  00202	d1 f8		 sar	 eax, 1
  00204	50		 push	 eax
  00205	8d 8d 60 fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  0020b	51		 push	 ecx
  0020c	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00211	83 c4 14	 add	 esp, 20			; 00000014H
  00214	8b 10		 mov	 edx, DWORD PTR [eax]
  00216	89 95 50 ff ff
	ff		 mov	 DWORD PTR $T18[ebp], edx
  0021c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0021f	89 8d 54 ff ff
	ff		 mov	 DWORD PTR $T18[ebp+4], ecx
  00225	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00228	89 95 58 ff ff
	ff		 mov	 DWORD PTR $T18[ebp+8], edx
  0022e	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR $T18[ebp]
  00234	89 85 60 ff ff
	ff		 mov	 DWORD PTR _uv_range$[ebp], eax
  0023a	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR $T18[ebp+4]
  00240	89 8d 64 ff ff
	ff		 mov	 DWORD PTR _uv_range$[ebp+4], ecx
  00246	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR $T18[ebp+8]
  0024c	89 95 68 ff ff
	ff		 mov	 DWORD PTR _uv_range$[ebp+8], edx

; 1066 :     const int src_uv_pitch = src_uv_pitch_byte >> 1;

  00252	8b 43 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebx]
  00255	d1 f8		 sar	 eax, 1
  00257	89 85 4c ff ff
	ff		 mov	 DWORD PTR _src_uv_pitch$[ebp], eax

; 1067 :     uint16_t *srcULine = (uint16_t *)src[1] + ((src_uv_pitch * uv_range.start_src) + (crop_left >> 1));

  0025d	b9 04 00 00 00	 mov	 ecx, 4
  00262	c1 e1 00	 shl	 ecx, 0
  00265	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  0026b	0f af 95 60 ff
	ff ff		 imul	 edx, DWORD PTR _uv_range$[ebp]
  00272	8b 45 f8	 mov	 eax, DWORD PTR _crop_left$[ebp]
  00275	d1 f8		 sar	 eax, 1
  00277	03 d0		 add	 edx, eax
  00279	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  0027c	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  0027f	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  00282	89 95 48 ff ff
	ff		 mov	 DWORD PTR _srcULine$[ebp], edx

; 1068 :     uint16_t *srcVLine = (uint16_t *)src[2] + ((src_uv_pitch * uv_range.start_src) + (crop_left >> 1));

  00288	b8 04 00 00 00	 mov	 eax, 4
  0028d	d1 e0		 shl	 eax, 1
  0028f	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00295	0f af 8d 60 ff
	ff ff		 imul	 ecx, DWORD PTR _uv_range$[ebp]
  0029c	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  0029f	d1 fa		 sar	 edx, 1
  002a1	03 ca		 add	 ecx, edx
  002a3	8b 53 0c	 mov	 edx, DWORD PTR _src$[ebx]
  002a6	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  002a9	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  002ac	89 8d 44 ff ff
	ff		 mov	 DWORD PTR _srcVLine$[ebp], ecx

; 1069 :     uint16_t *dstLine = (uint16_t *)dst[1] + dst_y_pitch * uv_range.start_dst;

  002b2	ba 04 00 00 00	 mov	 edx, 4
  002b7	c1 e2 00	 shl	 edx, 0
  002ba	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  002bd	0f af 85 64 ff
	ff ff		 imul	 eax, DWORD PTR _uv_range$[ebp+4]
  002c4	8b 4b 08	 mov	 ecx, DWORD PTR _dst$[ebx]
  002c7	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  002ca	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  002cd	89 85 40 ff ff
	ff		 mov	 DWORD PTR _dstLine$[ebp], eax

; 1070 :     for (int y = 0; y < uv_range.len; y++, srcULine += src_uv_pitch, srcVLine += src_uv_pitch, dstLine += dst_y_pitch) {

  002d3	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _y$17[ebp], 0
  002dd	eb 4b		 jmp	 SHORT $LN10@convert_yv
$LN8@convert_yv:
  002df	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _y$17[ebp]
  002e5	83 c1 01	 add	 ecx, 1
  002e8	89 8d 3c ff ff
	ff		 mov	 DWORD PTR _y$17[ebp], ecx
  002ee	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  002f4	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _srcULine$[ebp]
  002fa	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  002fd	89 8d 48 ff ff
	ff		 mov	 DWORD PTR _srcULine$[ebp], ecx
  00303	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  00309	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _srcVLine$[ebp]
  0030f	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00312	89 8d 44 ff ff
	ff		 mov	 DWORD PTR _srcVLine$[ebp], ecx
  00318	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  0031b	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _dstLine$[ebp]
  00321	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00324	89 8d 40 ff ff
	ff		 mov	 DWORD PTR _dstLine$[ebp], ecx
$LN10@convert_yv:
  0032a	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR _y$17[ebp]
  00330	3b 95 68 ff ff
	ff		 cmp	 edx, DWORD PTR _uv_range$[ebp+8]
  00336	0f 8d 85 01 00
	00		 jge	 $LN1@convert_yv

; 1071 :         const int x_fin = width - crop_right;

  0033c	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  0033f	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  00342	89 85 38 ff ff
	ff		 mov	 DWORD PTR _x_fin$16[ebp], eax

; 1072 :         uint16_t *src_u_ptr = srcULine;

  00348	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR _srcULine$[ebp]
  0034e	89 8d 34 ff ff
	ff		 mov	 DWORD PTR _src_u_ptr$15[ebp], ecx

; 1073 :         uint16_t *src_v_ptr = srcVLine;

  00354	8b 95 44 ff ff
	ff		 mov	 edx, DWORD PTR _srcVLine$[ebp]
  0035a	89 95 30 ff ff
	ff		 mov	 DWORD PTR _src_v_ptr$14[ebp], edx

; 1074 :         uint16_t *dst_ptr = dstLine;

  00360	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _dstLine$[ebp]
  00366	89 85 2c ff ff
	ff		 mov	 DWORD PTR _dst_ptr$13[ebp], eax

; 1075 :         __m128i x0, x1, x2;
; 1076 :         for (int x = crop_left; x < x_fin; x += 16, src_u_ptr += 8, src_v_ptr += 8, dst_ptr += 16) {

  0036c	8b 4d f8	 mov	 ecx, DWORD PTR _crop_left$[ebp]
  0036f	89 8d ec fe ff
	ff		 mov	 DWORD PTR _x$9[ebp], ecx
  00375	eb 3c		 jmp	 SHORT $LN13@convert_yv
$LN11@convert_yv:
  00377	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _x$9[ebp]
  0037d	83 c2 10	 add	 edx, 16			; 00000010H
  00380	89 95 ec fe ff
	ff		 mov	 DWORD PTR _x$9[ebp], edx
  00386	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR _src_u_ptr$15[ebp]
  0038c	83 c0 10	 add	 eax, 16			; 00000010H
  0038f	89 85 34 ff ff
	ff		 mov	 DWORD PTR _src_u_ptr$15[ebp], eax
  00395	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR _src_v_ptr$14[ebp]
  0039b	83 c1 10	 add	 ecx, 16			; 00000010H
  0039e	89 8d 30 ff ff
	ff		 mov	 DWORD PTR _src_v_ptr$14[ebp], ecx
  003a4	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR _dst_ptr$13[ebp]
  003aa	83 c2 20	 add	 edx, 32			; 00000020H
  003ad	89 95 2c ff ff
	ff		 mov	 DWORD PTR _dst_ptr$13[ebp], edx
$LN13@convert_yv:
  003b3	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _x$9[ebp]
  003b9	3b 85 38 ff ff
	ff		 cmp	 eax, DWORD PTR _x_fin$16[ebp]
  003bf	0f 8d f7 00 00
	00		 jge	 $LN12@convert_yv

; 1077 :             x0 = _mm_loadu_si128((const __m128i *)src_u_ptr);

  003c5	8b 8d 34 ff ff
	ff		 mov	 ecx, DWORD PTR _src_u_ptr$15[ebp]
  003cb	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  003ce	0f 29 85 d0 fe
	ff ff		 movaps	 XMMWORD PTR $T8[ebp], xmm0
  003d5	0f 28 85 d0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T8[ebp]
  003dc	0f 29 85 10 ff
	ff ff		 movaps	 XMMWORD PTR _x0$12[ebp], xmm0

; 1078 :             x1 = _mm_loadu_si128((const __m128i *)src_v_ptr);

  003e3	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR _src_v_ptr$14[ebp]
  003e9	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  003ec	0f 29 85 c0 fe
	ff ff		 movaps	 XMMWORD PTR $T7[ebp], xmm0
  003f3	0f 28 85 c0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T7[ebp]
  003fa	0f 29 85 00 ff
	ff ff		 movaps	 XMMWORD PTR _x1$11[ebp], xmm0

; 1079 : 
; 1080 :             if (in_bit_depth < 16) {

  00401	b8 01 00 00 00	 mov	 eax, 1
  00406	85 c0		 test	 eax, eax
  00408	74 42		 je	 SHORT $LN17@convert_yv

; 1081 :                 x0 = _mm_slli_epi16(x0, 16 - in_bit_depth);

  0040a	0f 28 85 10 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x0$12[ebp]
  00411	66 0f 71 f0 02	 psllw	 xmm0, 2
  00416	0f 29 85 b0 fe
	ff ff		 movaps	 XMMWORD PTR $T6[ebp], xmm0
  0041d	0f 28 85 b0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T6[ebp]
  00424	0f 29 85 10 ff
	ff ff		 movaps	 XMMWORD PTR _x0$12[ebp], xmm0

; 1082 :                 x1 = _mm_slli_epi16(x1, 16 - in_bit_depth);

  0042b	0f 28 85 00 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$11[ebp]
  00432	66 0f 71 f0 02	 psllw	 xmm0, 2
  00437	0f 29 85 a0 fe
	ff ff		 movaps	 XMMWORD PTR $T5[ebp], xmm0
  0043e	0f 28 85 a0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T5[ebp]
  00445	0f 29 85 00 ff
	ff ff		 movaps	 XMMWORD PTR _x1$11[ebp], xmm0
$LN17@convert_yv:

; 1083 :             }
; 1084 : 
; 1085 :             x2 = _mm_unpackhi_epi16(x0, x1);

  0044c	0f 28 85 10 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x0$12[ebp]
  00453	66 0f 69 85 00
	ff ff ff	 punpckhwd xmm0, XMMWORD PTR _x1$11[ebp]
  0045b	0f 29 85 90 fe
	ff ff		 movaps	 XMMWORD PTR $T4[ebp], xmm0
  00462	0f 28 85 90 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T4[ebp]
  00469	0f 29 85 f0 fe
	ff ff		 movaps	 XMMWORD PTR _x2$10[ebp], xmm0

; 1086 :             x0 = _mm_unpacklo_epi16(x0, x1);

  00470	0f 28 85 10 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x0$12[ebp]
  00477	66 0f 61 85 00
	ff ff ff	 punpcklwd xmm0, XMMWORD PTR _x1$11[ebp]
  0047f	0f 29 85 80 fe
	ff ff		 movaps	 XMMWORD PTR $T3[ebp], xmm0
  00486	0f 28 85 80 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T3[ebp]
  0048d	0f 29 85 10 ff
	ff ff		 movaps	 XMMWORD PTR _x0$12[ebp], xmm0

; 1087 : 
; 1088 :             _mm_storeu_si128((__m128i *)(dst_ptr + 0), x0);

  00494	0f 10 85 10 ff
	ff ff		 movups	 xmm0, XMMWORD PTR _x0$12[ebp]
  0049b	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR _dst_ptr$13[ebp]
  004a1	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 1089 :             _mm_storeu_si128((__m128i *)(dst_ptr + 8), x2);

  004a4	0f 10 85 f0 fe
	ff ff		 movups	 xmm0, XMMWORD PTR _x2$10[ebp]
  004ab	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR _dst_ptr$13[ebp]
  004b1	83 c2 10	 add	 edx, 16			; 00000010H
  004b4	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 1090 :         }

  004b7	e9 bb fe ff ff	 jmp	 $LN11@convert_yv
$LN12@convert_yv:

; 1091 :     }

  004bc	e9 1e fe ff ff	 jmp	 $LN8@convert_yv
$LN1@convert_yv:

; 1092 : }

  004c1	52		 push	 edx
  004c2	8b cd		 mov	 ecx, ebp
  004c4	50		 push	 eax
  004c5	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN22@convert_yv
  004cb	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  004d0	58		 pop	 eax
  004d1	5a		 pop	 edx
  004d2	5f		 pop	 edi
  004d3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004d6	33 cd		 xor	 ecx, ebp
  004d8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004dd	8b e5		 mov	 esp, ebp
  004df	5d		 pop	 ebp
  004e0	8b e3		 mov	 esp, ebx
  004e2	5b		 pop	 ebx
  004e3	c3		 ret	 0
$LN22@convert_yv:
  004e4	02 00 00 00	 DD	 2
  004e8	00 00 00 00	 DD	 $LN21@convert_yv
$LN21@convert_yv:
  004ec	d4 ff ff ff	 DD	 -44			; ffffffd4H
  004f0	0c 00 00 00	 DD	 12			; 0000000cH
  004f4	00 00 00 00	 DD	 $LN19@convert_yv
  004f8	60 ff ff ff	 DD	 -160			; ffffff60H
  004fc	0c 00 00 00	 DD	 12			; 0000000cH
  00500	00 00 00 00	 DD	 $LN20@convert_yv
$LN20@convert_yv:
  00504	75		 DB	 117			; 00000075H
  00505	76		 DB	 118			; 00000076H
  00506	5f		 DB	 95			; 0000005fH
  00507	72		 DB	 114			; 00000072H
  00508	61		 DB	 97			; 00000061H
  00509	6e		 DB	 110			; 0000006eH
  0050a	67		 DB	 103			; 00000067H
  0050b	65		 DB	 101			; 00000065H
  0050c	00		 DB	 0
$LN19@convert_yv:
  0050d	79		 DB	 121			; 00000079H
  0050e	5f		 DB	 95			; 0000005fH
  0050f	72		 DB	 114			; 00000072H
  00510	61		 DB	 97			; 00000061H
  00511	6e		 DB	 110			; 0000006eH
  00512	67		 DB	 103			; 00000067H
  00513	65		 DB	 101			; 00000065H
  00514	00		 DB	 0
??$convert_yv12_high_to_p010_simd@$0O@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_high_to_p010_simd<14,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_sse2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yv12_14_to_p010_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_14_to_p010_sse2

; 129  : void convert_yv12_14_to_p010_sse2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 130  :     convert_yv12_high_to_p010_simd<14, false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yv12_high_to_p010_simd@$0O@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_high_to_p010_simd<14,0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 131  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yv12_14_to_p010_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_14_to_p010_sse2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -416						; size = 12
$T2 = -400						; size = 12
$T3 = -384						; size = 16
$T4 = -368						; size = 16
$T5 = -352						; size = 16
$T6 = -336						; size = 16
$T7 = -320						; size = 16
$T8 = -304						; size = 16
_x$9 = -276						; size = 4
_x2$10 = -272						; size = 16
_x1$11 = -256						; size = 16
_x0$12 = -240						; size = 16
_dst_ptr$13 = -212					; size = 4
_src_v_ptr$14 = -208					; size = 4
_src_u_ptr$15 = -204					; size = 4
_x_fin$16 = -200					; size = 4
_y$17 = -196						; size = 4
_dstLine$ = -192					; size = 4
_srcVLine$ = -188					; size = 4
_srcULine$ = -184					; size = 4
_src_uv_pitch$ = -180					; size = 4
$T18 = -176						; size = 12
_uv_range$ = -160					; size = 12
$T19 = -144						; size = 16
$T20 = -128						; size = 16
_x0$21 = -112						; size = 16
_x$22 = -88						; size = 4
_dst_ptr$23 = -84					; size = 4
_src_ptr$24 = -80					; size = 4
_y$25 = -76						; size = 4
_y_width$26 = -72					; size = 4
_dstLine$27 = -68					; size = 4
_srcYLine$28 = -64					; size = 4
$T29 = -60						; size = 12
_y_range$30 = -44					; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yv12_high_to_p010_simd@$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_high_to_p010_simd<16,0>

; 1036 : static void __forceinline convert_yv12_high_to_p010_simd(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec a0 01 00
	00		 sub	 esp, 416		; 000001a0H
  0001c	57		 push	 edi
  0001d	8d bd 60 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-416]
  00023	b9 68 00 00 00	 mov	 ecx, 104		; 00000068H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1037 :     static_assert(8 < in_bit_depth && in_bit_depth <= 16, "in_bit_depth must be 9-16.");
; 1038 :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 1039 :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 1040 :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 1041 :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 1042 :     const int src_y_pitch = src_y_pitch_byte >> 1;

  0007c	8b 53 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  0007f	d1 fa		 sar	 edx, 1
  00081	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 1043 :     const int dst_y_pitch = dst_y_pitch_byte >> 1;

  00084	8b 43 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  00087	d1 f8		 sar	 eax, 1
  00089	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 1044 :     //Y成分のコピー
; 1045 :     if (!uv_only) {

  0008c	b9 01 00 00 00	 mov	 ecx, 1
  00091	85 c9		 test	 ecx, ecx
  00093	0f 84 5a 01 00
	00		 je	 $LN14@convert_yv

; 1046 :         const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00099	8b 53 2c	 mov	 edx, DWORD PTR _thread_n$[ebx]
  0009c	52		 push	 edx
  0009d	8b 43 28	 mov	 eax, DWORD PTR _thread_id$[ebx]
  000a0	50		 push	 eax
  000a1	8b 4b 20	 mov	 ecx, DWORD PTR _height$[ebx]
  000a4	2b 4d ec	 sub	 ecx, DWORD PTR _crop_bottom$[ebp]
  000a7	51		 push	 ecx
  000a8	8b 55 f4	 mov	 edx, DWORD PTR _crop_up$[ebp]
  000ab	52		 push	 edx
  000ac	8d 85 70 fe ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  000b2	50		 push	 eax
  000b3	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  000b8	83 c4 14	 add	 esp, 20			; 00000014H
  000bb	8b 08		 mov	 ecx, DWORD PTR [eax]
  000bd	89 4d c4	 mov	 DWORD PTR $T29[ebp], ecx
  000c0	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000c3	89 55 c8	 mov	 DWORD PTR $T29[ebp+4], edx
  000c6	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000c9	89 45 cc	 mov	 DWORD PTR $T29[ebp+8], eax
  000cc	8b 4d c4	 mov	 ecx, DWORD PTR $T29[ebp]
  000cf	89 4d d4	 mov	 DWORD PTR _y_range$30[ebp], ecx
  000d2	8b 55 c8	 mov	 edx, DWORD PTR $T29[ebp+4]
  000d5	89 55 d8	 mov	 DWORD PTR _y_range$30[ebp+4], edx
  000d8	8b 45 cc	 mov	 eax, DWORD PTR $T29[ebp+8]
  000db	89 45 dc	 mov	 DWORD PTR _y_range$30[ebp+8], eax

; 1047 :         uint16_t *srcYLine = (uint16_t *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000de	b9 04 00 00 00	 mov	 ecx, 4
  000e3	6b d1 00	 imul	 edx, ecx, 0
  000e6	8b 45 e8	 mov	 eax, DWORD PTR _src_y_pitch$[ebp]
  000e9	0f af 45 d4	 imul	 eax, DWORD PTR _y_range$30[ebp]
  000ed	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  000f0	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  000f3	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  000f6	8b 4d f8	 mov	 ecx, DWORD PTR _crop_left$[ebp]
  000f9	8d 14 48	 lea	 edx, DWORD PTR [eax+ecx*2]
  000fc	89 55 c0	 mov	 DWORD PTR _srcYLine$28[ebp], edx

; 1048 :         uint16_t *dstLine = (uint16_t *)dst[0] + dst_y_pitch * y_range.start_dst;

  000ff	b8 04 00 00 00	 mov	 eax, 4
  00104	6b c8 00	 imul	 ecx, eax, 0
  00107	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  0010a	0f af 55 d8	 imul	 edx, DWORD PTR _y_range$30[ebp+4]
  0010e	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  00111	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  00114	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  00117	89 55 bc	 mov	 DWORD PTR _dstLine$27[ebp], edx

; 1049 :         const int y_width = width - crop_right - crop_left;

  0011a	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  0011d	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  00120	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  00123	89 45 b8	 mov	 DWORD PTR _y_width$26[ebp], eax

; 1050 :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  00126	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _y$25[ebp], 0
  0012d	eb 21		 jmp	 SHORT $LN4@convert_yv
$LN2@convert_yv:
  0012f	8b 4d b4	 mov	 ecx, DWORD PTR _y$25[ebp]
  00132	83 c1 01	 add	 ecx, 1
  00135	89 4d b4	 mov	 DWORD PTR _y$25[ebp], ecx
  00138	8b 55 e8	 mov	 edx, DWORD PTR _src_y_pitch$[ebp]
  0013b	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$28[ebp]
  0013e	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00141	89 4d c0	 mov	 DWORD PTR _srcYLine$28[ebp], ecx
  00144	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  00147	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$27[ebp]
  0014a	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  0014d	89 4d bc	 mov	 DWORD PTR _dstLine$27[ebp], ecx
$LN4@convert_yv:
  00150	8b 55 b4	 mov	 edx, DWORD PTR _y$25[ebp]
  00153	3b 55 dc	 cmp	 edx, DWORD PTR _y_range$30[ebp+8]
  00156	0f 8d 97 00 00
	00		 jge	 $LN14@convert_yv

; 1051 :             if (in_bit_depth == 16) {

  0015c	b8 01 00 00 00	 mov	 eax, 1
  00161	85 c0		 test	 eax, eax
  00163	74 18		 je	 SHORT $LN15@convert_yv

; 1052 :                 memcpy_sse((uint8_t *)dstLine, (uint8_t *)srcYLine, y_width * sizeof(uint16_t));

  00165	8b 4d b8	 mov	 ecx, DWORD PTR _y_width$26[ebp]
  00168	d1 e1		 shl	 ecx, 1
  0016a	51		 push	 ecx
  0016b	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$28[ebp]
  0016e	52		 push	 edx
  0016f	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$27[ebp]
  00172	50		 push	 eax
  00173	e8 00 00 00 00	 call	 ?memcpy_sse@@YAXPAEPBEH@Z ; memcpy_sse
  00178	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1053 :             } else {

  0017b	eb 71		 jmp	 SHORT $LN16@convert_yv
$LN15@convert_yv:

; 1054 :                 uint16_t *src_ptr = srcYLine;

  0017d	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$28[ebp]
  00180	89 4d b0	 mov	 DWORD PTR _src_ptr$24[ebp], ecx

; 1055 :                 uint16_t *dst_ptr = dstLine;

  00183	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$27[ebp]
  00186	89 55 ac	 mov	 DWORD PTR _dst_ptr$23[ebp], edx

; 1056 :                 for (int x = 0; x < y_width; x += 8, dst_ptr += 8, src_ptr += 8) {

  00189	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR _x$22[ebp], 0
  00190	eb 1b		 jmp	 SHORT $LN7@convert_yv
$LN5@convert_yv:
  00192	8b 45 a8	 mov	 eax, DWORD PTR _x$22[ebp]
  00195	83 c0 08	 add	 eax, 8
  00198	89 45 a8	 mov	 DWORD PTR _x$22[ebp], eax
  0019b	8b 4d ac	 mov	 ecx, DWORD PTR _dst_ptr$23[ebp]
  0019e	83 c1 10	 add	 ecx, 16			; 00000010H
  001a1	89 4d ac	 mov	 DWORD PTR _dst_ptr$23[ebp], ecx
  001a4	8b 55 b0	 mov	 edx, DWORD PTR _src_ptr$24[ebp]
  001a7	83 c2 10	 add	 edx, 16			; 00000010H
  001aa	89 55 b0	 mov	 DWORD PTR _src_ptr$24[ebp], edx
$LN7@convert_yv:
  001ad	8b 45 a8	 mov	 eax, DWORD PTR _x$22[ebp]
  001b0	3b 45 b8	 cmp	 eax, DWORD PTR _y_width$26[ebp]
  001b3	7d 39		 jge	 SHORT $LN16@convert_yv

; 1057 :                     __m128i x0 = _mm_loadu_si128((const __m128i *)src_ptr);

  001b5	8b 4d b0	 mov	 ecx, DWORD PTR _src_ptr$24[ebp]
  001b8	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  001bb	0f 29 45 80	 movaps	 XMMWORD PTR $T20[ebp], xmm0
  001bf	0f 28 45 80	 movaps	 xmm0, XMMWORD PTR $T20[ebp]
  001c3	0f 29 45 90	 movaps	 XMMWORD PTR _x0$21[ebp], xmm0

; 1058 :                     x0 = _mm_slli_epi16(x0, 16 - in_bit_depth);

  001c7	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR _x0$21[ebp]
  001cb	66 0f 71 f0 00	 psllw	 xmm0, 0
  001d0	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR $T19[ebp], xmm0
  001d7	0f 28 85 70 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T19[ebp]
  001de	0f 29 45 90	 movaps	 XMMWORD PTR _x0$21[ebp], xmm0

; 1059 :                     _mm_storeu_si128((__m128i *)dst_ptr, x0);

  001e2	0f 10 45 90	 movups	 xmm0, XMMWORD PTR _x0$21[ebp]
  001e6	8b 55 ac	 mov	 edx, DWORD PTR _dst_ptr$23[ebp]
  001e9	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 1060 :                 }

  001ec	eb a4		 jmp	 SHORT $LN5@convert_yv
$LN16@convert_yv:

; 1061 :             }
; 1062 :         }

  001ee	e9 3c ff ff ff	 jmp	 $LN2@convert_yv
$LN14@convert_yv:

; 1063 :     }
; 1064 :     //UV成分のコピー
; 1065 :     const auto uv_range = thread_y_range(crop_up >> 1, (height - crop_bottom) >> 1, thread_id, thread_n);

  001f3	8b 43 2c	 mov	 eax, DWORD PTR _thread_n$[ebx]
  001f6	50		 push	 eax
  001f7	8b 4b 28	 mov	 ecx, DWORD PTR _thread_id$[ebx]
  001fa	51		 push	 ecx
  001fb	8b 53 20	 mov	 edx, DWORD PTR _height$[ebx]
  001fe	2b 55 ec	 sub	 edx, DWORD PTR _crop_bottom$[ebp]
  00201	d1 fa		 sar	 edx, 1
  00203	52		 push	 edx
  00204	8b 45 f4	 mov	 eax, DWORD PTR _crop_up$[ebp]
  00207	d1 f8		 sar	 eax, 1
  00209	50		 push	 eax
  0020a	8d 8d 60 fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  00210	51		 push	 ecx
  00211	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00216	83 c4 14	 add	 esp, 20			; 00000014H
  00219	8b 10		 mov	 edx, DWORD PTR [eax]
  0021b	89 95 50 ff ff
	ff		 mov	 DWORD PTR $T18[ebp], edx
  00221	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00224	89 8d 54 ff ff
	ff		 mov	 DWORD PTR $T18[ebp+4], ecx
  0022a	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0022d	89 95 58 ff ff
	ff		 mov	 DWORD PTR $T18[ebp+8], edx
  00233	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR $T18[ebp]
  00239	89 85 60 ff ff
	ff		 mov	 DWORD PTR _uv_range$[ebp], eax
  0023f	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR $T18[ebp+4]
  00245	89 8d 64 ff ff
	ff		 mov	 DWORD PTR _uv_range$[ebp+4], ecx
  0024b	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR $T18[ebp+8]
  00251	89 95 68 ff ff
	ff		 mov	 DWORD PTR _uv_range$[ebp+8], edx

; 1066 :     const int src_uv_pitch = src_uv_pitch_byte >> 1;

  00257	8b 43 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebx]
  0025a	d1 f8		 sar	 eax, 1
  0025c	89 85 4c ff ff
	ff		 mov	 DWORD PTR _src_uv_pitch$[ebp], eax

; 1067 :     uint16_t *srcULine = (uint16_t *)src[1] + ((src_uv_pitch * uv_range.start_src) + (crop_left >> 1));

  00262	b9 04 00 00 00	 mov	 ecx, 4
  00267	c1 e1 00	 shl	 ecx, 0
  0026a	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  00270	0f af 95 60 ff
	ff ff		 imul	 edx, DWORD PTR _uv_range$[ebp]
  00277	8b 45 f8	 mov	 eax, DWORD PTR _crop_left$[ebp]
  0027a	d1 f8		 sar	 eax, 1
  0027c	03 d0		 add	 edx, eax
  0027e	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  00281	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  00284	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  00287	89 95 48 ff ff
	ff		 mov	 DWORD PTR _srcULine$[ebp], edx

; 1068 :     uint16_t *srcVLine = (uint16_t *)src[2] + ((src_uv_pitch * uv_range.start_src) + (crop_left >> 1));

  0028d	b8 04 00 00 00	 mov	 eax, 4
  00292	d1 e0		 shl	 eax, 1
  00294	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  0029a	0f af 8d 60 ff
	ff ff		 imul	 ecx, DWORD PTR _uv_range$[ebp]
  002a1	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  002a4	d1 fa		 sar	 edx, 1
  002a6	03 ca		 add	 ecx, edx
  002a8	8b 53 0c	 mov	 edx, DWORD PTR _src$[ebx]
  002ab	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  002ae	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  002b1	89 8d 44 ff ff
	ff		 mov	 DWORD PTR _srcVLine$[ebp], ecx

; 1069 :     uint16_t *dstLine = (uint16_t *)dst[1] + dst_y_pitch * uv_range.start_dst;

  002b7	ba 04 00 00 00	 mov	 edx, 4
  002bc	c1 e2 00	 shl	 edx, 0
  002bf	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  002c2	0f af 85 64 ff
	ff ff		 imul	 eax, DWORD PTR _uv_range$[ebp+4]
  002c9	8b 4b 08	 mov	 ecx, DWORD PTR _dst$[ebx]
  002cc	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  002cf	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  002d2	89 85 40 ff ff
	ff		 mov	 DWORD PTR _dstLine$[ebp], eax

; 1070 :     for (int y = 0; y < uv_range.len; y++, srcULine += src_uv_pitch, srcVLine += src_uv_pitch, dstLine += dst_y_pitch) {

  002d8	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _y$17[ebp], 0
  002e2	eb 4b		 jmp	 SHORT $LN10@convert_yv
$LN8@convert_yv:
  002e4	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _y$17[ebp]
  002ea	83 c1 01	 add	 ecx, 1
  002ed	89 8d 3c ff ff
	ff		 mov	 DWORD PTR _y$17[ebp], ecx
  002f3	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  002f9	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _srcULine$[ebp]
  002ff	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00302	89 8d 48 ff ff
	ff		 mov	 DWORD PTR _srcULine$[ebp], ecx
  00308	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  0030e	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _srcVLine$[ebp]
  00314	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00317	89 8d 44 ff ff
	ff		 mov	 DWORD PTR _srcVLine$[ebp], ecx
  0031d	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  00320	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _dstLine$[ebp]
  00326	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00329	89 8d 40 ff ff
	ff		 mov	 DWORD PTR _dstLine$[ebp], ecx
$LN10@convert_yv:
  0032f	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR _y$17[ebp]
  00335	3b 95 68 ff ff
	ff		 cmp	 edx, DWORD PTR _uv_range$[ebp+8]
  0033b	0f 8d 80 01 00
	00		 jge	 $LN1@convert_yv

; 1071 :         const int x_fin = width - crop_right;

  00341	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  00344	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  00347	89 85 38 ff ff
	ff		 mov	 DWORD PTR _x_fin$16[ebp], eax

; 1072 :         uint16_t *src_u_ptr = srcULine;

  0034d	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR _srcULine$[ebp]
  00353	89 8d 34 ff ff
	ff		 mov	 DWORD PTR _src_u_ptr$15[ebp], ecx

; 1073 :         uint16_t *src_v_ptr = srcVLine;

  00359	8b 95 44 ff ff
	ff		 mov	 edx, DWORD PTR _srcVLine$[ebp]
  0035f	89 95 30 ff ff
	ff		 mov	 DWORD PTR _src_v_ptr$14[ebp], edx

; 1074 :         uint16_t *dst_ptr = dstLine;

  00365	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _dstLine$[ebp]
  0036b	89 85 2c ff ff
	ff		 mov	 DWORD PTR _dst_ptr$13[ebp], eax

; 1075 :         __m128i x0, x1, x2;
; 1076 :         for (int x = crop_left; x < x_fin; x += 16, src_u_ptr += 8, src_v_ptr += 8, dst_ptr += 16) {

  00371	8b 4d f8	 mov	 ecx, DWORD PTR _crop_left$[ebp]
  00374	89 8d ec fe ff
	ff		 mov	 DWORD PTR _x$9[ebp], ecx
  0037a	eb 3c		 jmp	 SHORT $LN13@convert_yv
$LN11@convert_yv:
  0037c	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _x$9[ebp]
  00382	83 c2 10	 add	 edx, 16			; 00000010H
  00385	89 95 ec fe ff
	ff		 mov	 DWORD PTR _x$9[ebp], edx
  0038b	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR _src_u_ptr$15[ebp]
  00391	83 c0 10	 add	 eax, 16			; 00000010H
  00394	89 85 34 ff ff
	ff		 mov	 DWORD PTR _src_u_ptr$15[ebp], eax
  0039a	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR _src_v_ptr$14[ebp]
  003a0	83 c1 10	 add	 ecx, 16			; 00000010H
  003a3	89 8d 30 ff ff
	ff		 mov	 DWORD PTR _src_v_ptr$14[ebp], ecx
  003a9	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR _dst_ptr$13[ebp]
  003af	83 c2 20	 add	 edx, 32			; 00000020H
  003b2	89 95 2c ff ff
	ff		 mov	 DWORD PTR _dst_ptr$13[ebp], edx
$LN13@convert_yv:
  003b8	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _x$9[ebp]
  003be	3b 85 38 ff ff
	ff		 cmp	 eax, DWORD PTR _x_fin$16[ebp]
  003c4	0f 8d f2 00 00
	00		 jge	 $LN12@convert_yv

; 1077 :             x0 = _mm_loadu_si128((const __m128i *)src_u_ptr);

  003ca	8b 8d 34 ff ff
	ff		 mov	 ecx, DWORD PTR _src_u_ptr$15[ebp]
  003d0	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  003d3	0f 29 85 d0 fe
	ff ff		 movaps	 XMMWORD PTR $T8[ebp], xmm0
  003da	0f 28 85 d0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T8[ebp]
  003e1	0f 29 85 10 ff
	ff ff		 movaps	 XMMWORD PTR _x0$12[ebp], xmm0

; 1078 :             x1 = _mm_loadu_si128((const __m128i *)src_v_ptr);

  003e8	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR _src_v_ptr$14[ebp]
  003ee	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  003f1	0f 29 85 c0 fe
	ff ff		 movaps	 XMMWORD PTR $T7[ebp], xmm0
  003f8	0f 28 85 c0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T7[ebp]
  003ff	0f 29 85 00 ff
	ff ff		 movaps	 XMMWORD PTR _x1$11[ebp], xmm0

; 1079 : 
; 1080 :             if (in_bit_depth < 16) {

  00406	33 c0		 xor	 eax, eax
  00408	74 42		 je	 SHORT $LN17@convert_yv

; 1081 :                 x0 = _mm_slli_epi16(x0, 16 - in_bit_depth);

  0040a	0f 28 85 10 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x0$12[ebp]
  00411	66 0f 71 f0 00	 psllw	 xmm0, 0
  00416	0f 29 85 b0 fe
	ff ff		 movaps	 XMMWORD PTR $T6[ebp], xmm0
  0041d	0f 28 85 b0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T6[ebp]
  00424	0f 29 85 10 ff
	ff ff		 movaps	 XMMWORD PTR _x0$12[ebp], xmm0

; 1082 :                 x1 = _mm_slli_epi16(x1, 16 - in_bit_depth);

  0042b	0f 28 85 00 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$11[ebp]
  00432	66 0f 71 f0 00	 psllw	 xmm0, 0
  00437	0f 29 85 a0 fe
	ff ff		 movaps	 XMMWORD PTR $T5[ebp], xmm0
  0043e	0f 28 85 a0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T5[ebp]
  00445	0f 29 85 00 ff
	ff ff		 movaps	 XMMWORD PTR _x1$11[ebp], xmm0
$LN17@convert_yv:

; 1083 :             }
; 1084 : 
; 1085 :             x2 = _mm_unpackhi_epi16(x0, x1);

  0044c	0f 28 85 10 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x0$12[ebp]
  00453	66 0f 69 85 00
	ff ff ff	 punpckhwd xmm0, XMMWORD PTR _x1$11[ebp]
  0045b	0f 29 85 90 fe
	ff ff		 movaps	 XMMWORD PTR $T4[ebp], xmm0
  00462	0f 28 85 90 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T4[ebp]
  00469	0f 29 85 f0 fe
	ff ff		 movaps	 XMMWORD PTR _x2$10[ebp], xmm0

; 1086 :             x0 = _mm_unpacklo_epi16(x0, x1);

  00470	0f 28 85 10 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x0$12[ebp]
  00477	66 0f 61 85 00
	ff ff ff	 punpcklwd xmm0, XMMWORD PTR _x1$11[ebp]
  0047f	0f 29 85 80 fe
	ff ff		 movaps	 XMMWORD PTR $T3[ebp], xmm0
  00486	0f 28 85 80 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T3[ebp]
  0048d	0f 29 85 10 ff
	ff ff		 movaps	 XMMWORD PTR _x0$12[ebp], xmm0

; 1087 : 
; 1088 :             _mm_storeu_si128((__m128i *)(dst_ptr + 0), x0);

  00494	0f 10 85 10 ff
	ff ff		 movups	 xmm0, XMMWORD PTR _x0$12[ebp]
  0049b	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR _dst_ptr$13[ebp]
  004a1	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 1089 :             _mm_storeu_si128((__m128i *)(dst_ptr + 8), x2);

  004a4	0f 10 85 f0 fe
	ff ff		 movups	 xmm0, XMMWORD PTR _x2$10[ebp]
  004ab	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR _dst_ptr$13[ebp]
  004b1	83 c2 10	 add	 edx, 16			; 00000010H
  004b4	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 1090 :         }

  004b7	e9 c0 fe ff ff	 jmp	 $LN11@convert_yv
$LN12@convert_yv:

; 1091 :     }

  004bc	e9 23 fe ff ff	 jmp	 $LN8@convert_yv
$LN1@convert_yv:

; 1092 : }

  004c1	52		 push	 edx
  004c2	8b cd		 mov	 ecx, ebp
  004c4	50		 push	 eax
  004c5	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN22@convert_yv
  004cb	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  004d0	58		 pop	 eax
  004d1	5a		 pop	 edx
  004d2	5f		 pop	 edi
  004d3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004d6	33 cd		 xor	 ecx, ebp
  004d8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004dd	8b e5		 mov	 esp, ebp
  004df	5d		 pop	 ebp
  004e0	8b e3		 mov	 esp, ebx
  004e2	5b		 pop	 ebx
  004e3	c3		 ret	 0
$LN22@convert_yv:
  004e4	02 00 00 00	 DD	 2
  004e8	00 00 00 00	 DD	 $LN21@convert_yv
$LN21@convert_yv:
  004ec	d4 ff ff ff	 DD	 -44			; ffffffd4H
  004f0	0c 00 00 00	 DD	 12			; 0000000cH
  004f4	00 00 00 00	 DD	 $LN19@convert_yv
  004f8	60 ff ff ff	 DD	 -160			; ffffff60H
  004fc	0c 00 00 00	 DD	 12			; 0000000cH
  00500	00 00 00 00	 DD	 $LN20@convert_yv
$LN20@convert_yv:
  00504	75		 DB	 117			; 00000075H
  00505	76		 DB	 118			; 00000076H
  00506	5f		 DB	 95			; 0000005fH
  00507	72		 DB	 114			; 00000072H
  00508	61		 DB	 97			; 00000061H
  00509	6e		 DB	 110			; 0000006eH
  0050a	67		 DB	 103			; 00000067H
  0050b	65		 DB	 101			; 00000065H
  0050c	00		 DB	 0
$LN19@convert_yv:
  0050d	79		 DB	 121			; 00000079H
  0050e	5f		 DB	 95			; 0000005fH
  0050f	72		 DB	 114			; 00000072H
  00510	61		 DB	 97			; 00000061H
  00511	6e		 DB	 110			; 0000006eH
  00512	67		 DB	 103			; 00000067H
  00513	65		 DB	 101			; 00000065H
  00514	00		 DB	 0
??$convert_yv12_high_to_p010_simd@$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_high_to_p010_simd<16,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_sse2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yv12_16_to_p010_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_16_to_p010_sse2

; 125  : void convert_yv12_16_to_p010_sse2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 126  :     convert_yv12_high_to_p010_simd<16, false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yv12_high_to_p010_simd@$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_high_to_p010_simd<16,0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 127  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yv12_16_to_p010_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_16_to_p010_sse2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -528						; size = 12
$T2 = -512						; size = 12
$T3 = -496						; size = 16
$T4 = -480						; size = 16
$T5 = -464						; size = 16
$T6 = -448						; size = 16
$T7 = -432						; size = 16
$T8 = -416						; size = 16
_xMaskHighByte$9 = -400					; size = 16
$T10 = -384						; size = 16
$T11 = -368						; size = 16
$T12 = -352						; size = 16
$T13 = -336						; size = 16
_x1$14 = -320						; size = 16
_x0$15 = -304						; size = 16
_dst_ptr_fin$16 = -280					; size = 4
_dst_ptr$17 = -276					; size = 4
_src_v_ptr$18 = -272					; size = 4
_src_u_ptr$19 = -268					; size = 4
_x_fin$20 = -264					; size = 4
_y$21 = -260						; size = 4
_dstLine$ = -256					; size = 4
_srcVLine$ = -252					; size = 4
_srcULine$ = -248					; size = 4
_src_uv_pitch$ = -244					; size = 4
$T22 = -240						; size = 12
_uv_range$ = -224					; size = 12
$T23 = -208						; size = 16
$T24 = -192						; size = 16
$T25 = -176						; size = 16
$T26 = -160						; size = 16
$T27 = -144						; size = 16
_x1$28 = -128						; size = 16
_x0$29 = -112						; size = 16
_src_ptr_fin$30 = -84					; size = 4
_src_ptr$31 = -80					; size = 4
_dst_ptr$32 = -76					; size = 4
_y$33 = -72						; size = 4
_y_width$34 = -68					; size = 4
_dstLine$35 = -64					; size = 4
_srcYLine$36 = -60					; size = 4
$T37 = -56						; size = 12
_y_range$38 = -40					; size = 12
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yv12_high_to_nv12_simd@$08$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_high_to_nv12_simd<9,0>

; 972  : static void convert_yv12_high_to_nv12_simd(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 10 02 00
	00		 sub	 esp, 528		; 00000210H
  0001c	57		 push	 edi
  0001d	8d bd f0 fd ff
	ff		 lea	 edi, DWORD PTR [ebp-528]
  00023	b9 84 00 00 00	 mov	 ecx, 132		; 00000084H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 973  :     static_assert(8 < in_bit_depth && in_bit_depth <= 16, "in_bit_depth must be 9-16.");
; 974  :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 975  :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 976  :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 977  :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 978  :     const int src_y_pitch = src_y_pitch_byte >> 1;

  0007c	8b 53 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  0007f	d1 fa		 sar	 edx, 1
  00081	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 979  :     //Y成分のコピー
; 980  :     if (!uv_only) {

  00084	b8 01 00 00 00	 mov	 eax, 1
  00089	85 c0		 test	 eax, eax
  0008b	0f 84 8d 01 00
	00		 je	 $LN14@convert_yv

; 981  :         const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00091	8b 4b 2c	 mov	 ecx, DWORD PTR _thread_n$[ebx]
  00094	51		 push	 ecx
  00095	8b 53 28	 mov	 edx, DWORD PTR _thread_id$[ebx]
  00098	52		 push	 edx
  00099	8b 43 20	 mov	 eax, DWORD PTR _height$[ebx]
  0009c	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  0009f	50		 push	 eax
  000a0	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  000a3	51		 push	 ecx
  000a4	8d 95 00 fe ff
	ff		 lea	 edx, DWORD PTR $T2[ebp]
  000aa	52		 push	 edx
  000ab	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  000b0	83 c4 14	 add	 esp, 20			; 00000014H
  000b3	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b5	89 4d c8	 mov	 DWORD PTR $T37[ebp], ecx
  000b8	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000bb	89 55 cc	 mov	 DWORD PTR $T37[ebp+4], edx
  000be	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000c1	89 45 d0	 mov	 DWORD PTR $T37[ebp+8], eax
  000c4	8b 4d c8	 mov	 ecx, DWORD PTR $T37[ebp]
  000c7	89 4d d8	 mov	 DWORD PTR _y_range$38[ebp], ecx
  000ca	8b 55 cc	 mov	 edx, DWORD PTR $T37[ebp+4]
  000cd	89 55 dc	 mov	 DWORD PTR _y_range$38[ebp+4], edx
  000d0	8b 45 d0	 mov	 eax, DWORD PTR $T37[ebp+8]
  000d3	89 45 e0	 mov	 DWORD PTR _y_range$38[ebp+8], eax

; 982  :         uint16_t *srcYLine = (uint16_t *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000d6	b9 04 00 00 00	 mov	 ecx, 4
  000db	6b d1 00	 imul	 edx, ecx, 0
  000de	8b 45 e8	 mov	 eax, DWORD PTR _src_y_pitch$[ebp]
  000e1	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$38[ebp]
  000e5	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  000e8	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  000eb	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  000ee	8b 4d f8	 mov	 ecx, DWORD PTR _crop_left$[ebp]
  000f1	8d 14 48	 lea	 edx, DWORD PTR [eax+ecx*2]
  000f4	89 55 c4	 mov	 DWORD PTR _srcYLine$36[ebp], edx

; 983  :         uint8_t *dstLine  = (uint8_t *)dst[0] + dst_y_pitch_byte * y_range.start_dst;

  000f7	b8 04 00 00 00	 mov	 eax, 4
  000fc	6b c8 00	 imul	 ecx, eax, 0
  000ff	8b 53 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebx]
  00102	0f af 55 dc	 imul	 edx, DWORD PTR _y_range$38[ebp+4]
  00106	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  00109	03 14 08	 add	 edx, DWORD PTR [eax+ecx]
  0010c	89 55 c0	 mov	 DWORD PTR _dstLine$35[ebp], edx

; 984  :         const int y_width = width - crop_right - crop_left;

  0010f	8b 4b 10	 mov	 ecx, DWORD PTR _width$[ebx]
  00112	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  00115	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  00118	89 4d bc	 mov	 DWORD PTR _y_width$34[ebp], ecx

; 985  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch_byte) {

  0011b	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _y$33[ebp], 0
  00122	eb 1e		 jmp	 SHORT $LN4@convert_yv
$LN2@convert_yv:
  00124	8b 55 b8	 mov	 edx, DWORD PTR _y$33[ebp]
  00127	83 c2 01	 add	 edx, 1
  0012a	89 55 b8	 mov	 DWORD PTR _y$33[ebp], edx
  0012d	8b 45 e8	 mov	 eax, DWORD PTR _src_y_pitch$[ebp]
  00130	8b 4d c4	 mov	 ecx, DWORD PTR _srcYLine$36[ebp]
  00133	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00136	89 55 c4	 mov	 DWORD PTR _srcYLine$36[ebp], edx
  00139	8b 45 c0	 mov	 eax, DWORD PTR _dstLine$35[ebp]
  0013c	03 43 1c	 add	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  0013f	89 45 c0	 mov	 DWORD PTR _dstLine$35[ebp], eax
$LN4@convert_yv:
  00142	8b 4d b8	 mov	 ecx, DWORD PTR _y$33[ebp]
  00145	3b 4d e0	 cmp	 ecx, DWORD PTR _y_range$38[ebp+8]
  00148	0f 8d d0 00 00
	00		 jge	 $LN14@convert_yv

; 986  :             uint8_t *dst_ptr = dstLine;

  0014e	8b 55 c0	 mov	 edx, DWORD PTR _dstLine$35[ebp]
  00151	89 55 b4	 mov	 DWORD PTR _dst_ptr$32[ebp], edx

; 987  :             uint16_t *src_ptr = srcYLine;

  00154	8b 45 c4	 mov	 eax, DWORD PTR _srcYLine$36[ebp]
  00157	89 45 b0	 mov	 DWORD PTR _src_ptr$31[ebp], eax

; 988  :             uint16_t *src_ptr_fin = src_ptr + y_width;

  0015a	8b 4d bc	 mov	 ecx, DWORD PTR _y_width$34[ebp]
  0015d	8b 55 b0	 mov	 edx, DWORD PTR _src_ptr$31[ebp]
  00160	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  00163	89 45 ac	 mov	 DWORD PTR _src_ptr_fin$30[ebp], eax

; 989  :             __m128i x0, x1;
; 990  :             for (; src_ptr < src_ptr_fin; dst_ptr += 16, src_ptr += 16) {

  00166	eb 12		 jmp	 SHORT $LN7@convert_yv
$LN5@convert_yv:
  00168	8b 4d b4	 mov	 ecx, DWORD PTR _dst_ptr$32[ebp]
  0016b	83 c1 10	 add	 ecx, 16			; 00000010H
  0016e	89 4d b4	 mov	 DWORD PTR _dst_ptr$32[ebp], ecx
  00171	8b 55 b0	 mov	 edx, DWORD PTR _src_ptr$31[ebp]
  00174	83 c2 20	 add	 edx, 32			; 00000020H
  00177	89 55 b0	 mov	 DWORD PTR _src_ptr$31[ebp], edx
$LN7@convert_yv:
  0017a	8b 45 b0	 mov	 eax, DWORD PTR _src_ptr$31[ebp]
  0017d	3b 45 ac	 cmp	 eax, DWORD PTR _src_ptr_fin$30[ebp]
  00180	0f 83 93 00 00
	00		 jae	 $LN6@convert_yv

; 991  :                 x0 = _mm_loadu_si128((const __m128i *)(src_ptr + 0));

  00186	8b 4d b0	 mov	 ecx, DWORD PTR _src_ptr$31[ebp]
  00189	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  0018c	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR $T27[ebp], xmm0
  00193	0f 28 85 70 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T27[ebp]
  0019a	0f 29 45 90	 movaps	 XMMWORD PTR _x0$29[ebp], xmm0

; 992  :                 x1 = _mm_loadu_si128((const __m128i *)(src_ptr + 8));

  0019e	8b 55 b0	 mov	 edx, DWORD PTR _src_ptr$31[ebp]
  001a1	83 c2 10	 add	 edx, 16			; 00000010H
  001a4	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  001a7	0f 29 85 60 ff
	ff ff		 movaps	 XMMWORD PTR $T26[ebp], xmm0
  001ae	0f 28 85 60 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T26[ebp]
  001b5	0f 29 45 80	 movaps	 XMMWORD PTR _x1$28[ebp], xmm0

; 993  : 
; 994  :                 x0 = _mm_srli_epi16(x0, in_bit_depth - 8);

  001b9	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR _x0$29[ebp]
  001bd	66 0f 71 d0 01	 psrlw	 xmm0, 1
  001c2	0f 29 85 50 ff
	ff ff		 movaps	 XMMWORD PTR $T25[ebp], xmm0
  001c9	0f 28 85 50 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T25[ebp]
  001d0	0f 29 45 90	 movaps	 XMMWORD PTR _x0$29[ebp], xmm0

; 995  :                 x1 = _mm_srli_epi16(x1, in_bit_depth - 8);

  001d4	0f 28 45 80	 movaps	 xmm0, XMMWORD PTR _x1$28[ebp]
  001d8	66 0f 71 d0 01	 psrlw	 xmm0, 1
  001dd	0f 29 85 40 ff
	ff ff		 movaps	 XMMWORD PTR $T24[ebp], xmm0
  001e4	0f 28 85 40 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T24[ebp]
  001eb	0f 29 45 80	 movaps	 XMMWORD PTR _x1$28[ebp], xmm0

; 996  : 
; 997  :                 x0 = _mm_packus_epi16(x0, x1);

  001ef	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR _x0$29[ebp]
  001f3	66 0f 67 45 80	 packuswb xmm0, XMMWORD PTR _x1$28[ebp]
  001f8	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR $T23[ebp], xmm0
  001ff	0f 28 85 30 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T23[ebp]
  00206	0f 29 45 90	 movaps	 XMMWORD PTR _x0$29[ebp], xmm0

; 998  : 
; 999  :                 _mm_storeu_si128((__m128i *)(dst_ptr + 0), x0);

  0020a	0f 10 45 90	 movups	 xmm0, XMMWORD PTR _x0$29[ebp]
  0020e	8b 45 b4	 mov	 eax, DWORD PTR _dst_ptr$32[ebp]
  00211	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 1000 :             }

  00214	e9 4f ff ff ff	 jmp	 $LN5@convert_yv
$LN6@convert_yv:

; 1001 :         }

  00219	e9 06 ff ff ff	 jmp	 $LN2@convert_yv
$LN14@convert_yv:

; 1002 :     }
; 1003 :     //UV成分のコピー
; 1004 :     const auto uv_range = thread_y_range(crop_up >> 1, (height - crop_bottom) >> 1, thread_id, thread_n);

  0021e	8b 4b 2c	 mov	 ecx, DWORD PTR _thread_n$[ebx]
  00221	51		 push	 ecx
  00222	8b 53 28	 mov	 edx, DWORD PTR _thread_id$[ebx]
  00225	52		 push	 edx
  00226	8b 43 20	 mov	 eax, DWORD PTR _height$[ebx]
  00229	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  0022c	d1 f8		 sar	 eax, 1
  0022e	50		 push	 eax
  0022f	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  00232	d1 f9		 sar	 ecx, 1
  00234	51		 push	 ecx
  00235	8d 95 f0 fd ff
	ff		 lea	 edx, DWORD PTR $T1[ebp]
  0023b	52		 push	 edx
  0023c	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00241	83 c4 14	 add	 esp, 20			; 00000014H
  00244	8b 08		 mov	 ecx, DWORD PTR [eax]
  00246	89 8d 10 ff ff
	ff		 mov	 DWORD PTR $T22[ebp], ecx
  0024c	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0024f	89 95 14 ff ff
	ff		 mov	 DWORD PTR $T22[ebp+4], edx
  00255	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00258	89 85 18 ff ff
	ff		 mov	 DWORD PTR $T22[ebp+8], eax
  0025e	8b 8d 10 ff ff
	ff		 mov	 ecx, DWORD PTR $T22[ebp]
  00264	89 8d 20 ff ff
	ff		 mov	 DWORD PTR _uv_range$[ebp], ecx
  0026a	8b 95 14 ff ff
	ff		 mov	 edx, DWORD PTR $T22[ebp+4]
  00270	89 95 24 ff ff
	ff		 mov	 DWORD PTR _uv_range$[ebp+4], edx
  00276	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR $T22[ebp+8]
  0027c	89 85 28 ff ff
	ff		 mov	 DWORD PTR _uv_range$[ebp+8], eax

; 1005 :     const int src_uv_pitch = src_uv_pitch_byte >> 1;

  00282	8b 4b 18	 mov	 ecx, DWORD PTR _src_uv_pitch_byte$[ebx]
  00285	d1 f9		 sar	 ecx, 1
  00287	89 8d 0c ff ff
	ff		 mov	 DWORD PTR _src_uv_pitch$[ebp], ecx

; 1006 :     uint16_t *srcULine = (uint16_t *)src[1] + ((src_uv_pitch * uv_range.start_src) + (crop_left >> 1));

  0028d	ba 04 00 00 00	 mov	 edx, 4
  00292	c1 e2 00	 shl	 edx, 0
  00295	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  0029b	0f af 85 20 ff
	ff ff		 imul	 eax, DWORD PTR _uv_range$[ebp]
  002a2	8b 4d f8	 mov	 ecx, DWORD PTR _crop_left$[ebp]
  002a5	d1 f9		 sar	 ecx, 1
  002a7	03 c1		 add	 eax, ecx
  002a9	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  002ac	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  002af	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  002b2	89 85 08 ff ff
	ff		 mov	 DWORD PTR _srcULine$[ebp], eax

; 1007 :     uint16_t *srcVLine = (uint16_t *)src[2] + ((src_uv_pitch * uv_range.start_src) + (crop_left >> 1));

  002b8	b9 04 00 00 00	 mov	 ecx, 4
  002bd	d1 e1		 shl	 ecx, 1
  002bf	8b 95 0c ff ff
	ff		 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  002c5	0f af 95 20 ff
	ff ff		 imul	 edx, DWORD PTR _uv_range$[ebp]
  002cc	8b 45 f8	 mov	 eax, DWORD PTR _crop_left$[ebp]
  002cf	d1 f8		 sar	 eax, 1
  002d1	03 d0		 add	 edx, eax
  002d3	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  002d6	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  002d9	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  002dc	89 95 04 ff ff
	ff		 mov	 DWORD PTR _srcVLine$[ebp], edx

; 1008 :     uint8_t *dstLine  = (uint8_t *)dst[1] + dst_y_pitch_byte * uv_range.start_dst;

  002e2	b8 04 00 00 00	 mov	 eax, 4
  002e7	c1 e0 00	 shl	 eax, 0
  002ea	8b 4b 1c	 mov	 ecx, DWORD PTR _dst_y_pitch_byte$[ebx]
  002ed	0f af 8d 24 ff
	ff ff		 imul	 ecx, DWORD PTR _uv_range$[ebp+4]
  002f4	8b 53 08	 mov	 edx, DWORD PTR _dst$[ebx]
  002f7	03 0c 02	 add	 ecx, DWORD PTR [edx+eax]
  002fa	89 8d 00 ff ff
	ff		 mov	 DWORD PTR _dstLine$[ebp], ecx

; 1009 :     for (int y = 0; y < uv_range.len; y++, srcULine += src_uv_pitch, srcVLine += src_uv_pitch, dstLine += dst_y_pitch_byte) {

  00300	c7 85 fc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _y$21[ebp], 0
  0030a	eb 48		 jmp	 SHORT $LN10@convert_yv
$LN8@convert_yv:
  0030c	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR _y$21[ebp]
  00312	83 c0 01	 add	 eax, 1
  00315	89 85 fc fe ff
	ff		 mov	 DWORD PTR _y$21[ebp], eax
  0031b	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00321	8b 95 08 ff ff
	ff		 mov	 edx, DWORD PTR _srcULine$[ebp]
  00327	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  0032a	89 85 08 ff ff
	ff		 mov	 DWORD PTR _srcULine$[ebp], eax
  00330	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00336	8b 95 04 ff ff
	ff		 mov	 edx, DWORD PTR _srcVLine$[ebp]
  0033c	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  0033f	89 85 04 ff ff
	ff		 mov	 DWORD PTR _srcVLine$[ebp], eax
  00345	8b 8d 00 ff ff
	ff		 mov	 ecx, DWORD PTR _dstLine$[ebp]
  0034b	03 4b 1c	 add	 ecx, DWORD PTR _dst_y_pitch_byte$[ebx]
  0034e	89 8d 00 ff ff
	ff		 mov	 DWORD PTR _dstLine$[ebp], ecx
$LN10@convert_yv:
  00354	8b 95 fc fe ff
	ff		 mov	 edx, DWORD PTR _y$21[ebp]
  0035a	3b 95 28 ff ff
	ff		 cmp	 edx, DWORD PTR _uv_range$[ebp+8]
  00360	0f 8d ae 01 00
	00		 jge	 $LN1@convert_yv

; 1010 :         const int x_fin = width - crop_right;

  00366	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  00369	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  0036c	89 85 f8 fe ff
	ff		 mov	 DWORD PTR _x_fin$20[ebp], eax

; 1011 :         uint16_t *src_u_ptr = srcULine;

  00372	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR _srcULine$[ebp]
  00378	89 8d f4 fe ff
	ff		 mov	 DWORD PTR _src_u_ptr$19[ebp], ecx

; 1012 :         uint16_t *src_v_ptr = srcVLine;

  0037e	8b 95 04 ff ff
	ff		 mov	 edx, DWORD PTR _srcVLine$[ebp]
  00384	89 95 f0 fe ff
	ff		 mov	 DWORD PTR _src_v_ptr$18[ebp], edx

; 1013 :         uint8_t *dst_ptr = dstLine;

  0038a	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR _dstLine$[ebp]
  00390	89 85 ec fe ff
	ff		 mov	 DWORD PTR _dst_ptr$17[ebp], eax

; 1014 :         uint8_t *dst_ptr_fin = dst_ptr + x_fin;

  00396	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _dst_ptr$17[ebp]
  0039c	03 8d f8 fe ff
	ff		 add	 ecx, DWORD PTR _x_fin$20[ebp]
  003a2	89 8d e8 fe ff
	ff		 mov	 DWORD PTR _dst_ptr_fin$16[ebp], ecx

; 1015 :         __m128i x0, x1;
; 1016 :         for (; dst_ptr < dst_ptr_fin; src_u_ptr += 8, src_v_ptr += 8, dst_ptr += 16) {

  003a8	eb 2d		 jmp	 SHORT $LN13@convert_yv
$LN11@convert_yv:
  003aa	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR _src_u_ptr$19[ebp]
  003b0	83 c2 10	 add	 edx, 16			; 00000010H
  003b3	89 95 f4 fe ff
	ff		 mov	 DWORD PTR _src_u_ptr$19[ebp], edx
  003b9	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _src_v_ptr$18[ebp]
  003bf	83 c0 10	 add	 eax, 16			; 00000010H
  003c2	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _src_v_ptr$18[ebp], eax
  003c8	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _dst_ptr$17[ebp]
  003ce	83 c1 10	 add	 ecx, 16			; 00000010H
  003d1	89 8d ec fe ff
	ff		 mov	 DWORD PTR _dst_ptr$17[ebp], ecx
$LN13@convert_yv:
  003d7	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _dst_ptr$17[ebp]
  003dd	3b 95 e8 fe ff
	ff		 cmp	 edx, DWORD PTR _dst_ptr_fin$16[ebp]
  003e3	0f 83 26 01 00
	00		 jae	 $LN12@convert_yv

; 1017 :             x0 = _mm_loadu_si128((const __m128i *)src_u_ptr);

  003e9	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _src_u_ptr$19[ebp]
  003ef	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  003f2	0f 29 85 b0 fe
	ff ff		 movaps	 XMMWORD PTR $T13[ebp], xmm0
  003f9	0f 28 85 b0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T13[ebp]
  00400	0f 29 85 d0 fe
	ff ff		 movaps	 XMMWORD PTR _x0$15[ebp], xmm0

; 1018 :             x1 = _mm_loadu_si128((const __m128i *)src_v_ptr);

  00407	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR _src_v_ptr$18[ebp]
  0040d	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00410	0f 29 85 a0 fe
	ff ff		 movaps	 XMMWORD PTR $T12[ebp], xmm0
  00417	0f 28 85 a0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T12[ebp]
  0041e	0f 29 85 c0 fe
	ff ff		 movaps	 XMMWORD PTR _x1$14[ebp], xmm0

; 1019 : 
; 1020 :             x0 = _mm_srli_epi16(x0, in_bit_depth - 8);

  00425	0f 28 85 d0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _x0$15[ebp]
  0042c	66 0f 71 d0 01	 psrlw	 xmm0, 1
  00431	0f 29 85 90 fe
	ff ff		 movaps	 XMMWORD PTR $T11[ebp], xmm0
  00438	0f 28 85 90 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T11[ebp]
  0043f	0f 29 85 d0 fe
	ff ff		 movaps	 XMMWORD PTR _x0$15[ebp], xmm0

; 1021 :             x1 = _mm_slli_epi16(x1, 16 - in_bit_depth);

  00446	0f 28 85 c0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$14[ebp]
  0044d	66 0f 71 f0 07	 psllw	 xmm0, 7
  00452	0f 29 85 80 fe
	ff ff		 movaps	 XMMWORD PTR $T10[ebp], xmm0
  00459	0f 28 85 80 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T10[ebp]
  00460	0f 29 85 c0 fe
	ff ff		 movaps	 XMMWORD PTR _x1$14[ebp], xmm0

; 1022 :             const __m128i xMaskHighByte = _mm_slli_epi16(_mm_cmpeq_epi8(_mm_setzero_si128(), _mm_setzero_si128()), 8);

  00467	0f 57 c0	 xorps	 xmm0, xmm0
  0046a	0f 29 85 50 fe
	ff ff		 movaps	 XMMWORD PTR $T7[ebp], xmm0
  00471	0f 57 c0	 xorps	 xmm0, xmm0
  00474	0f 29 85 60 fe
	ff ff		 movaps	 XMMWORD PTR $T8[ebp], xmm0
  0047b	0f 28 85 60 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T8[ebp]
  00482	66 0f 74 85 50
	fe ff ff	 pcmpeqb xmm0, XMMWORD PTR $T7[ebp]
  0048a	0f 29 85 40 fe
	ff ff		 movaps	 XMMWORD PTR $T6[ebp], xmm0
  00491	0f 28 85 40 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T6[ebp]
  00498	66 0f 71 f0 08	 psllw	 xmm0, 8
  0049d	0f 29 85 30 fe
	ff ff		 movaps	 XMMWORD PTR $T5[ebp], xmm0
  004a4	0f 28 85 30 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T5[ebp]
  004ab	0f 29 85 70 fe
	ff ff		 movaps	 XMMWORD PTR _xMaskHighByte$9[ebp], xmm0

; 1023 :             x1 = _mm_and_si128(x1, xMaskHighByte);

  004b2	0f 28 85 c0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$14[ebp]
  004b9	66 0f db 85 70
	fe ff ff	 pand	 xmm0, XMMWORD PTR _xMaskHighByte$9[ebp]
  004c1	0f 29 85 20 fe
	ff ff		 movaps	 XMMWORD PTR $T4[ebp], xmm0
  004c8	0f 28 85 20 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T4[ebp]
  004cf	0f 29 85 c0 fe
	ff ff		 movaps	 XMMWORD PTR _x1$14[ebp], xmm0

; 1024 : 
; 1025 :             x0 = _mm_or_si128(x0, x1);

  004d6	0f 28 85 d0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _x0$15[ebp]
  004dd	66 0f eb 85 c0
	fe ff ff	 por	 xmm0, XMMWORD PTR _x1$14[ebp]
  004e5	0f 29 85 10 fe
	ff ff		 movaps	 XMMWORD PTR $T3[ebp], xmm0
  004ec	0f 28 85 10 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T3[ebp]
  004f3	0f 29 85 d0 fe
	ff ff		 movaps	 XMMWORD PTR _x0$15[ebp], xmm0

; 1026 : 
; 1027 :             _mm_storeu_si128((__m128i *)(dst_ptr +  0), x0);

  004fa	0f 10 85 d0 fe
	ff ff		 movups	 xmm0, XMMWORD PTR _x0$15[ebp]
  00501	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _dst_ptr$17[ebp]
  00507	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 1028 :         }

  0050a	e9 9b fe ff ff	 jmp	 $LN11@convert_yv
$LN12@convert_yv:

; 1029 :     }

  0050f	e9 f8 fd ff ff	 jmp	 $LN8@convert_yv
$LN1@convert_yv:

; 1030 : }

  00514	52		 push	 edx
  00515	8b cd		 mov	 ecx, ebp
  00517	50		 push	 eax
  00518	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN19@convert_yv
  0051e	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00523	58		 pop	 eax
  00524	5a		 pop	 edx
  00525	5f		 pop	 edi
  00526	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00529	33 cd		 xor	 ecx, ebp
  0052b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00530	8b e5		 mov	 esp, ebp
  00532	5d		 pop	 ebp
  00533	8b e3		 mov	 esp, ebx
  00535	5b		 pop	 ebx
  00536	c3		 ret	 0
  00537	90		 npad	 1
$LN19@convert_yv:
  00538	02 00 00 00	 DD	 2
  0053c	00 00 00 00	 DD	 $LN18@convert_yv
$LN18@convert_yv:
  00540	d8 ff ff ff	 DD	 -40			; ffffffd8H
  00544	0c 00 00 00	 DD	 12			; 0000000cH
  00548	00 00 00 00	 DD	 $LN16@convert_yv
  0054c	20 ff ff ff	 DD	 -224			; ffffff20H
  00550	0c 00 00 00	 DD	 12			; 0000000cH
  00554	00 00 00 00	 DD	 $LN17@convert_yv
$LN17@convert_yv:
  00558	75		 DB	 117			; 00000075H
  00559	76		 DB	 118			; 00000076H
  0055a	5f		 DB	 95			; 0000005fH
  0055b	72		 DB	 114			; 00000072H
  0055c	61		 DB	 97			; 00000061H
  0055d	6e		 DB	 110			; 0000006eH
  0055e	67		 DB	 103			; 00000067H
  0055f	65		 DB	 101			; 00000065H
  00560	00		 DB	 0
$LN16@convert_yv:
  00561	79		 DB	 121			; 00000079H
  00562	5f		 DB	 95			; 0000005fH
  00563	72		 DB	 114			; 00000072H
  00564	61		 DB	 97			; 00000061H
  00565	6e		 DB	 110			; 0000006eH
  00566	67		 DB	 103			; 00000067H
  00567	65		 DB	 101			; 00000065H
  00568	00		 DB	 0
??$convert_yv12_high_to_nv12_simd@$08$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_high_to_nv12_simd<9,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_sse2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yv12_09_to_nv12_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_09_to_nv12_sse2

; 121  : void convert_yv12_09_to_nv12_sse2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 122  :     convert_yv12_high_to_nv12_simd<9, false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yv12_high_to_nv12_simd@$08$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_high_to_nv12_simd<9,0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 123  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yv12_09_to_nv12_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_09_to_nv12_sse2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -528						; size = 12
$T2 = -512						; size = 12
$T3 = -496						; size = 16
$T4 = -480						; size = 16
$T5 = -464						; size = 16
$T6 = -448						; size = 16
$T7 = -432						; size = 16
$T8 = -416						; size = 16
_xMaskHighByte$9 = -400					; size = 16
$T10 = -384						; size = 16
$T11 = -368						; size = 16
$T12 = -352						; size = 16
$T13 = -336						; size = 16
_x1$14 = -320						; size = 16
_x0$15 = -304						; size = 16
_dst_ptr_fin$16 = -280					; size = 4
_dst_ptr$17 = -276					; size = 4
_src_v_ptr$18 = -272					; size = 4
_src_u_ptr$19 = -268					; size = 4
_x_fin$20 = -264					; size = 4
_y$21 = -260						; size = 4
_dstLine$ = -256					; size = 4
_srcVLine$ = -252					; size = 4
_srcULine$ = -248					; size = 4
_src_uv_pitch$ = -244					; size = 4
$T22 = -240						; size = 12
_uv_range$ = -224					; size = 12
$T23 = -208						; size = 16
$T24 = -192						; size = 16
$T25 = -176						; size = 16
$T26 = -160						; size = 16
$T27 = -144						; size = 16
_x1$28 = -128						; size = 16
_x0$29 = -112						; size = 16
_src_ptr_fin$30 = -84					; size = 4
_src_ptr$31 = -80					; size = 4
_dst_ptr$32 = -76					; size = 4
_y$33 = -72						; size = 4
_y_width$34 = -68					; size = 4
_dstLine$35 = -64					; size = 4
_srcYLine$36 = -60					; size = 4
$T37 = -56						; size = 12
_y_range$38 = -40					; size = 12
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yv12_high_to_nv12_simd@$09$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_high_to_nv12_simd<10,0>

; 972  : static void convert_yv12_high_to_nv12_simd(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 10 02 00
	00		 sub	 esp, 528		; 00000210H
  0001c	57		 push	 edi
  0001d	8d bd f0 fd ff
	ff		 lea	 edi, DWORD PTR [ebp-528]
  00023	b9 84 00 00 00	 mov	 ecx, 132		; 00000084H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 973  :     static_assert(8 < in_bit_depth && in_bit_depth <= 16, "in_bit_depth must be 9-16.");
; 974  :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 975  :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 976  :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 977  :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 978  :     const int src_y_pitch = src_y_pitch_byte >> 1;

  0007c	8b 53 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  0007f	d1 fa		 sar	 edx, 1
  00081	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 979  :     //Y成分のコピー
; 980  :     if (!uv_only) {

  00084	b8 01 00 00 00	 mov	 eax, 1
  00089	85 c0		 test	 eax, eax
  0008b	0f 84 8d 01 00
	00		 je	 $LN14@convert_yv

; 981  :         const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00091	8b 4b 2c	 mov	 ecx, DWORD PTR _thread_n$[ebx]
  00094	51		 push	 ecx
  00095	8b 53 28	 mov	 edx, DWORD PTR _thread_id$[ebx]
  00098	52		 push	 edx
  00099	8b 43 20	 mov	 eax, DWORD PTR _height$[ebx]
  0009c	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  0009f	50		 push	 eax
  000a0	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  000a3	51		 push	 ecx
  000a4	8d 95 00 fe ff
	ff		 lea	 edx, DWORD PTR $T2[ebp]
  000aa	52		 push	 edx
  000ab	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  000b0	83 c4 14	 add	 esp, 20			; 00000014H
  000b3	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b5	89 4d c8	 mov	 DWORD PTR $T37[ebp], ecx
  000b8	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000bb	89 55 cc	 mov	 DWORD PTR $T37[ebp+4], edx
  000be	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000c1	89 45 d0	 mov	 DWORD PTR $T37[ebp+8], eax
  000c4	8b 4d c8	 mov	 ecx, DWORD PTR $T37[ebp]
  000c7	89 4d d8	 mov	 DWORD PTR _y_range$38[ebp], ecx
  000ca	8b 55 cc	 mov	 edx, DWORD PTR $T37[ebp+4]
  000cd	89 55 dc	 mov	 DWORD PTR _y_range$38[ebp+4], edx
  000d0	8b 45 d0	 mov	 eax, DWORD PTR $T37[ebp+8]
  000d3	89 45 e0	 mov	 DWORD PTR _y_range$38[ebp+8], eax

; 982  :         uint16_t *srcYLine = (uint16_t *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000d6	b9 04 00 00 00	 mov	 ecx, 4
  000db	6b d1 00	 imul	 edx, ecx, 0
  000de	8b 45 e8	 mov	 eax, DWORD PTR _src_y_pitch$[ebp]
  000e1	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$38[ebp]
  000e5	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  000e8	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  000eb	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  000ee	8b 4d f8	 mov	 ecx, DWORD PTR _crop_left$[ebp]
  000f1	8d 14 48	 lea	 edx, DWORD PTR [eax+ecx*2]
  000f4	89 55 c4	 mov	 DWORD PTR _srcYLine$36[ebp], edx

; 983  :         uint8_t *dstLine  = (uint8_t *)dst[0] + dst_y_pitch_byte * y_range.start_dst;

  000f7	b8 04 00 00 00	 mov	 eax, 4
  000fc	6b c8 00	 imul	 ecx, eax, 0
  000ff	8b 53 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebx]
  00102	0f af 55 dc	 imul	 edx, DWORD PTR _y_range$38[ebp+4]
  00106	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  00109	03 14 08	 add	 edx, DWORD PTR [eax+ecx]
  0010c	89 55 c0	 mov	 DWORD PTR _dstLine$35[ebp], edx

; 984  :         const int y_width = width - crop_right - crop_left;

  0010f	8b 4b 10	 mov	 ecx, DWORD PTR _width$[ebx]
  00112	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  00115	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  00118	89 4d bc	 mov	 DWORD PTR _y_width$34[ebp], ecx

; 985  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch_byte) {

  0011b	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _y$33[ebp], 0
  00122	eb 1e		 jmp	 SHORT $LN4@convert_yv
$LN2@convert_yv:
  00124	8b 55 b8	 mov	 edx, DWORD PTR _y$33[ebp]
  00127	83 c2 01	 add	 edx, 1
  0012a	89 55 b8	 mov	 DWORD PTR _y$33[ebp], edx
  0012d	8b 45 e8	 mov	 eax, DWORD PTR _src_y_pitch$[ebp]
  00130	8b 4d c4	 mov	 ecx, DWORD PTR _srcYLine$36[ebp]
  00133	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00136	89 55 c4	 mov	 DWORD PTR _srcYLine$36[ebp], edx
  00139	8b 45 c0	 mov	 eax, DWORD PTR _dstLine$35[ebp]
  0013c	03 43 1c	 add	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  0013f	89 45 c0	 mov	 DWORD PTR _dstLine$35[ebp], eax
$LN4@convert_yv:
  00142	8b 4d b8	 mov	 ecx, DWORD PTR _y$33[ebp]
  00145	3b 4d e0	 cmp	 ecx, DWORD PTR _y_range$38[ebp+8]
  00148	0f 8d d0 00 00
	00		 jge	 $LN14@convert_yv

; 986  :             uint8_t *dst_ptr = dstLine;

  0014e	8b 55 c0	 mov	 edx, DWORD PTR _dstLine$35[ebp]
  00151	89 55 b4	 mov	 DWORD PTR _dst_ptr$32[ebp], edx

; 987  :             uint16_t *src_ptr = srcYLine;

  00154	8b 45 c4	 mov	 eax, DWORD PTR _srcYLine$36[ebp]
  00157	89 45 b0	 mov	 DWORD PTR _src_ptr$31[ebp], eax

; 988  :             uint16_t *src_ptr_fin = src_ptr + y_width;

  0015a	8b 4d bc	 mov	 ecx, DWORD PTR _y_width$34[ebp]
  0015d	8b 55 b0	 mov	 edx, DWORD PTR _src_ptr$31[ebp]
  00160	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  00163	89 45 ac	 mov	 DWORD PTR _src_ptr_fin$30[ebp], eax

; 989  :             __m128i x0, x1;
; 990  :             for (; src_ptr < src_ptr_fin; dst_ptr += 16, src_ptr += 16) {

  00166	eb 12		 jmp	 SHORT $LN7@convert_yv
$LN5@convert_yv:
  00168	8b 4d b4	 mov	 ecx, DWORD PTR _dst_ptr$32[ebp]
  0016b	83 c1 10	 add	 ecx, 16			; 00000010H
  0016e	89 4d b4	 mov	 DWORD PTR _dst_ptr$32[ebp], ecx
  00171	8b 55 b0	 mov	 edx, DWORD PTR _src_ptr$31[ebp]
  00174	83 c2 20	 add	 edx, 32			; 00000020H
  00177	89 55 b0	 mov	 DWORD PTR _src_ptr$31[ebp], edx
$LN7@convert_yv:
  0017a	8b 45 b0	 mov	 eax, DWORD PTR _src_ptr$31[ebp]
  0017d	3b 45 ac	 cmp	 eax, DWORD PTR _src_ptr_fin$30[ebp]
  00180	0f 83 93 00 00
	00		 jae	 $LN6@convert_yv

; 991  :                 x0 = _mm_loadu_si128((const __m128i *)(src_ptr + 0));

  00186	8b 4d b0	 mov	 ecx, DWORD PTR _src_ptr$31[ebp]
  00189	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  0018c	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR $T27[ebp], xmm0
  00193	0f 28 85 70 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T27[ebp]
  0019a	0f 29 45 90	 movaps	 XMMWORD PTR _x0$29[ebp], xmm0

; 992  :                 x1 = _mm_loadu_si128((const __m128i *)(src_ptr + 8));

  0019e	8b 55 b0	 mov	 edx, DWORD PTR _src_ptr$31[ebp]
  001a1	83 c2 10	 add	 edx, 16			; 00000010H
  001a4	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  001a7	0f 29 85 60 ff
	ff ff		 movaps	 XMMWORD PTR $T26[ebp], xmm0
  001ae	0f 28 85 60 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T26[ebp]
  001b5	0f 29 45 80	 movaps	 XMMWORD PTR _x1$28[ebp], xmm0

; 993  : 
; 994  :                 x0 = _mm_srli_epi16(x0, in_bit_depth - 8);

  001b9	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR _x0$29[ebp]
  001bd	66 0f 71 d0 02	 psrlw	 xmm0, 2
  001c2	0f 29 85 50 ff
	ff ff		 movaps	 XMMWORD PTR $T25[ebp], xmm0
  001c9	0f 28 85 50 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T25[ebp]
  001d0	0f 29 45 90	 movaps	 XMMWORD PTR _x0$29[ebp], xmm0

; 995  :                 x1 = _mm_srli_epi16(x1, in_bit_depth - 8);

  001d4	0f 28 45 80	 movaps	 xmm0, XMMWORD PTR _x1$28[ebp]
  001d8	66 0f 71 d0 02	 psrlw	 xmm0, 2
  001dd	0f 29 85 40 ff
	ff ff		 movaps	 XMMWORD PTR $T24[ebp], xmm0
  001e4	0f 28 85 40 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T24[ebp]
  001eb	0f 29 45 80	 movaps	 XMMWORD PTR _x1$28[ebp], xmm0

; 996  : 
; 997  :                 x0 = _mm_packus_epi16(x0, x1);

  001ef	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR _x0$29[ebp]
  001f3	66 0f 67 45 80	 packuswb xmm0, XMMWORD PTR _x1$28[ebp]
  001f8	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR $T23[ebp], xmm0
  001ff	0f 28 85 30 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T23[ebp]
  00206	0f 29 45 90	 movaps	 XMMWORD PTR _x0$29[ebp], xmm0

; 998  : 
; 999  :                 _mm_storeu_si128((__m128i *)(dst_ptr + 0), x0);

  0020a	0f 10 45 90	 movups	 xmm0, XMMWORD PTR _x0$29[ebp]
  0020e	8b 45 b4	 mov	 eax, DWORD PTR _dst_ptr$32[ebp]
  00211	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 1000 :             }

  00214	e9 4f ff ff ff	 jmp	 $LN5@convert_yv
$LN6@convert_yv:

; 1001 :         }

  00219	e9 06 ff ff ff	 jmp	 $LN2@convert_yv
$LN14@convert_yv:

; 1002 :     }
; 1003 :     //UV成分のコピー
; 1004 :     const auto uv_range = thread_y_range(crop_up >> 1, (height - crop_bottom) >> 1, thread_id, thread_n);

  0021e	8b 4b 2c	 mov	 ecx, DWORD PTR _thread_n$[ebx]
  00221	51		 push	 ecx
  00222	8b 53 28	 mov	 edx, DWORD PTR _thread_id$[ebx]
  00225	52		 push	 edx
  00226	8b 43 20	 mov	 eax, DWORD PTR _height$[ebx]
  00229	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  0022c	d1 f8		 sar	 eax, 1
  0022e	50		 push	 eax
  0022f	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  00232	d1 f9		 sar	 ecx, 1
  00234	51		 push	 ecx
  00235	8d 95 f0 fd ff
	ff		 lea	 edx, DWORD PTR $T1[ebp]
  0023b	52		 push	 edx
  0023c	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00241	83 c4 14	 add	 esp, 20			; 00000014H
  00244	8b 08		 mov	 ecx, DWORD PTR [eax]
  00246	89 8d 10 ff ff
	ff		 mov	 DWORD PTR $T22[ebp], ecx
  0024c	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0024f	89 95 14 ff ff
	ff		 mov	 DWORD PTR $T22[ebp+4], edx
  00255	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00258	89 85 18 ff ff
	ff		 mov	 DWORD PTR $T22[ebp+8], eax
  0025e	8b 8d 10 ff ff
	ff		 mov	 ecx, DWORD PTR $T22[ebp]
  00264	89 8d 20 ff ff
	ff		 mov	 DWORD PTR _uv_range$[ebp], ecx
  0026a	8b 95 14 ff ff
	ff		 mov	 edx, DWORD PTR $T22[ebp+4]
  00270	89 95 24 ff ff
	ff		 mov	 DWORD PTR _uv_range$[ebp+4], edx
  00276	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR $T22[ebp+8]
  0027c	89 85 28 ff ff
	ff		 mov	 DWORD PTR _uv_range$[ebp+8], eax

; 1005 :     const int src_uv_pitch = src_uv_pitch_byte >> 1;

  00282	8b 4b 18	 mov	 ecx, DWORD PTR _src_uv_pitch_byte$[ebx]
  00285	d1 f9		 sar	 ecx, 1
  00287	89 8d 0c ff ff
	ff		 mov	 DWORD PTR _src_uv_pitch$[ebp], ecx

; 1006 :     uint16_t *srcULine = (uint16_t *)src[1] + ((src_uv_pitch * uv_range.start_src) + (crop_left >> 1));

  0028d	ba 04 00 00 00	 mov	 edx, 4
  00292	c1 e2 00	 shl	 edx, 0
  00295	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  0029b	0f af 85 20 ff
	ff ff		 imul	 eax, DWORD PTR _uv_range$[ebp]
  002a2	8b 4d f8	 mov	 ecx, DWORD PTR _crop_left$[ebp]
  002a5	d1 f9		 sar	 ecx, 1
  002a7	03 c1		 add	 eax, ecx
  002a9	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  002ac	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  002af	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  002b2	89 85 08 ff ff
	ff		 mov	 DWORD PTR _srcULine$[ebp], eax

; 1007 :     uint16_t *srcVLine = (uint16_t *)src[2] + ((src_uv_pitch * uv_range.start_src) + (crop_left >> 1));

  002b8	b9 04 00 00 00	 mov	 ecx, 4
  002bd	d1 e1		 shl	 ecx, 1
  002bf	8b 95 0c ff ff
	ff		 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  002c5	0f af 95 20 ff
	ff ff		 imul	 edx, DWORD PTR _uv_range$[ebp]
  002cc	8b 45 f8	 mov	 eax, DWORD PTR _crop_left$[ebp]
  002cf	d1 f8		 sar	 eax, 1
  002d1	03 d0		 add	 edx, eax
  002d3	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  002d6	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  002d9	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  002dc	89 95 04 ff ff
	ff		 mov	 DWORD PTR _srcVLine$[ebp], edx

; 1008 :     uint8_t *dstLine  = (uint8_t *)dst[1] + dst_y_pitch_byte * uv_range.start_dst;

  002e2	b8 04 00 00 00	 mov	 eax, 4
  002e7	c1 e0 00	 shl	 eax, 0
  002ea	8b 4b 1c	 mov	 ecx, DWORD PTR _dst_y_pitch_byte$[ebx]
  002ed	0f af 8d 24 ff
	ff ff		 imul	 ecx, DWORD PTR _uv_range$[ebp+4]
  002f4	8b 53 08	 mov	 edx, DWORD PTR _dst$[ebx]
  002f7	03 0c 02	 add	 ecx, DWORD PTR [edx+eax]
  002fa	89 8d 00 ff ff
	ff		 mov	 DWORD PTR _dstLine$[ebp], ecx

; 1009 :     for (int y = 0; y < uv_range.len; y++, srcULine += src_uv_pitch, srcVLine += src_uv_pitch, dstLine += dst_y_pitch_byte) {

  00300	c7 85 fc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _y$21[ebp], 0
  0030a	eb 48		 jmp	 SHORT $LN10@convert_yv
$LN8@convert_yv:
  0030c	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR _y$21[ebp]
  00312	83 c0 01	 add	 eax, 1
  00315	89 85 fc fe ff
	ff		 mov	 DWORD PTR _y$21[ebp], eax
  0031b	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00321	8b 95 08 ff ff
	ff		 mov	 edx, DWORD PTR _srcULine$[ebp]
  00327	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  0032a	89 85 08 ff ff
	ff		 mov	 DWORD PTR _srcULine$[ebp], eax
  00330	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00336	8b 95 04 ff ff
	ff		 mov	 edx, DWORD PTR _srcVLine$[ebp]
  0033c	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  0033f	89 85 04 ff ff
	ff		 mov	 DWORD PTR _srcVLine$[ebp], eax
  00345	8b 8d 00 ff ff
	ff		 mov	 ecx, DWORD PTR _dstLine$[ebp]
  0034b	03 4b 1c	 add	 ecx, DWORD PTR _dst_y_pitch_byte$[ebx]
  0034e	89 8d 00 ff ff
	ff		 mov	 DWORD PTR _dstLine$[ebp], ecx
$LN10@convert_yv:
  00354	8b 95 fc fe ff
	ff		 mov	 edx, DWORD PTR _y$21[ebp]
  0035a	3b 95 28 ff ff
	ff		 cmp	 edx, DWORD PTR _uv_range$[ebp+8]
  00360	0f 8d ae 01 00
	00		 jge	 $LN1@convert_yv

; 1010 :         const int x_fin = width - crop_right;

  00366	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  00369	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  0036c	89 85 f8 fe ff
	ff		 mov	 DWORD PTR _x_fin$20[ebp], eax

; 1011 :         uint16_t *src_u_ptr = srcULine;

  00372	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR _srcULine$[ebp]
  00378	89 8d f4 fe ff
	ff		 mov	 DWORD PTR _src_u_ptr$19[ebp], ecx

; 1012 :         uint16_t *src_v_ptr = srcVLine;

  0037e	8b 95 04 ff ff
	ff		 mov	 edx, DWORD PTR _srcVLine$[ebp]
  00384	89 95 f0 fe ff
	ff		 mov	 DWORD PTR _src_v_ptr$18[ebp], edx

; 1013 :         uint8_t *dst_ptr = dstLine;

  0038a	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR _dstLine$[ebp]
  00390	89 85 ec fe ff
	ff		 mov	 DWORD PTR _dst_ptr$17[ebp], eax

; 1014 :         uint8_t *dst_ptr_fin = dst_ptr + x_fin;

  00396	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _dst_ptr$17[ebp]
  0039c	03 8d f8 fe ff
	ff		 add	 ecx, DWORD PTR _x_fin$20[ebp]
  003a2	89 8d e8 fe ff
	ff		 mov	 DWORD PTR _dst_ptr_fin$16[ebp], ecx

; 1015 :         __m128i x0, x1;
; 1016 :         for (; dst_ptr < dst_ptr_fin; src_u_ptr += 8, src_v_ptr += 8, dst_ptr += 16) {

  003a8	eb 2d		 jmp	 SHORT $LN13@convert_yv
$LN11@convert_yv:
  003aa	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR _src_u_ptr$19[ebp]
  003b0	83 c2 10	 add	 edx, 16			; 00000010H
  003b3	89 95 f4 fe ff
	ff		 mov	 DWORD PTR _src_u_ptr$19[ebp], edx
  003b9	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _src_v_ptr$18[ebp]
  003bf	83 c0 10	 add	 eax, 16			; 00000010H
  003c2	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _src_v_ptr$18[ebp], eax
  003c8	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _dst_ptr$17[ebp]
  003ce	83 c1 10	 add	 ecx, 16			; 00000010H
  003d1	89 8d ec fe ff
	ff		 mov	 DWORD PTR _dst_ptr$17[ebp], ecx
$LN13@convert_yv:
  003d7	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _dst_ptr$17[ebp]
  003dd	3b 95 e8 fe ff
	ff		 cmp	 edx, DWORD PTR _dst_ptr_fin$16[ebp]
  003e3	0f 83 26 01 00
	00		 jae	 $LN12@convert_yv

; 1017 :             x0 = _mm_loadu_si128((const __m128i *)src_u_ptr);

  003e9	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _src_u_ptr$19[ebp]
  003ef	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  003f2	0f 29 85 b0 fe
	ff ff		 movaps	 XMMWORD PTR $T13[ebp], xmm0
  003f9	0f 28 85 b0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T13[ebp]
  00400	0f 29 85 d0 fe
	ff ff		 movaps	 XMMWORD PTR _x0$15[ebp], xmm0

; 1018 :             x1 = _mm_loadu_si128((const __m128i *)src_v_ptr);

  00407	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR _src_v_ptr$18[ebp]
  0040d	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00410	0f 29 85 a0 fe
	ff ff		 movaps	 XMMWORD PTR $T12[ebp], xmm0
  00417	0f 28 85 a0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T12[ebp]
  0041e	0f 29 85 c0 fe
	ff ff		 movaps	 XMMWORD PTR _x1$14[ebp], xmm0

; 1019 : 
; 1020 :             x0 = _mm_srli_epi16(x0, in_bit_depth - 8);

  00425	0f 28 85 d0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _x0$15[ebp]
  0042c	66 0f 71 d0 02	 psrlw	 xmm0, 2
  00431	0f 29 85 90 fe
	ff ff		 movaps	 XMMWORD PTR $T11[ebp], xmm0
  00438	0f 28 85 90 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T11[ebp]
  0043f	0f 29 85 d0 fe
	ff ff		 movaps	 XMMWORD PTR _x0$15[ebp], xmm0

; 1021 :             x1 = _mm_slli_epi16(x1, 16 - in_bit_depth);

  00446	0f 28 85 c0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$14[ebp]
  0044d	66 0f 71 f0 06	 psllw	 xmm0, 6
  00452	0f 29 85 80 fe
	ff ff		 movaps	 XMMWORD PTR $T10[ebp], xmm0
  00459	0f 28 85 80 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T10[ebp]
  00460	0f 29 85 c0 fe
	ff ff		 movaps	 XMMWORD PTR _x1$14[ebp], xmm0

; 1022 :             const __m128i xMaskHighByte = _mm_slli_epi16(_mm_cmpeq_epi8(_mm_setzero_si128(), _mm_setzero_si128()), 8);

  00467	0f 57 c0	 xorps	 xmm0, xmm0
  0046a	0f 29 85 50 fe
	ff ff		 movaps	 XMMWORD PTR $T7[ebp], xmm0
  00471	0f 57 c0	 xorps	 xmm0, xmm0
  00474	0f 29 85 60 fe
	ff ff		 movaps	 XMMWORD PTR $T8[ebp], xmm0
  0047b	0f 28 85 60 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T8[ebp]
  00482	66 0f 74 85 50
	fe ff ff	 pcmpeqb xmm0, XMMWORD PTR $T7[ebp]
  0048a	0f 29 85 40 fe
	ff ff		 movaps	 XMMWORD PTR $T6[ebp], xmm0
  00491	0f 28 85 40 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T6[ebp]
  00498	66 0f 71 f0 08	 psllw	 xmm0, 8
  0049d	0f 29 85 30 fe
	ff ff		 movaps	 XMMWORD PTR $T5[ebp], xmm0
  004a4	0f 28 85 30 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T5[ebp]
  004ab	0f 29 85 70 fe
	ff ff		 movaps	 XMMWORD PTR _xMaskHighByte$9[ebp], xmm0

; 1023 :             x1 = _mm_and_si128(x1, xMaskHighByte);

  004b2	0f 28 85 c0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$14[ebp]
  004b9	66 0f db 85 70
	fe ff ff	 pand	 xmm0, XMMWORD PTR _xMaskHighByte$9[ebp]
  004c1	0f 29 85 20 fe
	ff ff		 movaps	 XMMWORD PTR $T4[ebp], xmm0
  004c8	0f 28 85 20 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T4[ebp]
  004cf	0f 29 85 c0 fe
	ff ff		 movaps	 XMMWORD PTR _x1$14[ebp], xmm0

; 1024 : 
; 1025 :             x0 = _mm_or_si128(x0, x1);

  004d6	0f 28 85 d0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _x0$15[ebp]
  004dd	66 0f eb 85 c0
	fe ff ff	 por	 xmm0, XMMWORD PTR _x1$14[ebp]
  004e5	0f 29 85 10 fe
	ff ff		 movaps	 XMMWORD PTR $T3[ebp], xmm0
  004ec	0f 28 85 10 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T3[ebp]
  004f3	0f 29 85 d0 fe
	ff ff		 movaps	 XMMWORD PTR _x0$15[ebp], xmm0

; 1026 : 
; 1027 :             _mm_storeu_si128((__m128i *)(dst_ptr +  0), x0);

  004fa	0f 10 85 d0 fe
	ff ff		 movups	 xmm0, XMMWORD PTR _x0$15[ebp]
  00501	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _dst_ptr$17[ebp]
  00507	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 1028 :         }

  0050a	e9 9b fe ff ff	 jmp	 $LN11@convert_yv
$LN12@convert_yv:

; 1029 :     }

  0050f	e9 f8 fd ff ff	 jmp	 $LN8@convert_yv
$LN1@convert_yv:

; 1030 : }

  00514	52		 push	 edx
  00515	8b cd		 mov	 ecx, ebp
  00517	50		 push	 eax
  00518	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN19@convert_yv
  0051e	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00523	58		 pop	 eax
  00524	5a		 pop	 edx
  00525	5f		 pop	 edi
  00526	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00529	33 cd		 xor	 ecx, ebp
  0052b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00530	8b e5		 mov	 esp, ebp
  00532	5d		 pop	 ebp
  00533	8b e3		 mov	 esp, ebx
  00535	5b		 pop	 ebx
  00536	c3		 ret	 0
  00537	90		 npad	 1
$LN19@convert_yv:
  00538	02 00 00 00	 DD	 2
  0053c	00 00 00 00	 DD	 $LN18@convert_yv
$LN18@convert_yv:
  00540	d8 ff ff ff	 DD	 -40			; ffffffd8H
  00544	0c 00 00 00	 DD	 12			; 0000000cH
  00548	00 00 00 00	 DD	 $LN16@convert_yv
  0054c	20 ff ff ff	 DD	 -224			; ffffff20H
  00550	0c 00 00 00	 DD	 12			; 0000000cH
  00554	00 00 00 00	 DD	 $LN17@convert_yv
$LN17@convert_yv:
  00558	75		 DB	 117			; 00000075H
  00559	76		 DB	 118			; 00000076H
  0055a	5f		 DB	 95			; 0000005fH
  0055b	72		 DB	 114			; 00000072H
  0055c	61		 DB	 97			; 00000061H
  0055d	6e		 DB	 110			; 0000006eH
  0055e	67		 DB	 103			; 00000067H
  0055f	65		 DB	 101			; 00000065H
  00560	00		 DB	 0
$LN16@convert_yv:
  00561	79		 DB	 121			; 00000079H
  00562	5f		 DB	 95			; 0000005fH
  00563	72		 DB	 114			; 00000072H
  00564	61		 DB	 97			; 00000061H
  00565	6e		 DB	 110			; 0000006eH
  00566	67		 DB	 103			; 00000067H
  00567	65		 DB	 101			; 00000065H
  00568	00		 DB	 0
??$convert_yv12_high_to_nv12_simd@$09$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_high_to_nv12_simd<10,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_sse2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yv12_10_to_nv12_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_10_to_nv12_sse2

; 117  : void convert_yv12_10_to_nv12_sse2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 118  :     convert_yv12_high_to_nv12_simd<10, false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yv12_high_to_nv12_simd@$09$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_high_to_nv12_simd<10,0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 119  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yv12_10_to_nv12_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_10_to_nv12_sse2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -528						; size = 12
$T2 = -512						; size = 12
$T3 = -496						; size = 16
$T4 = -480						; size = 16
$T5 = -464						; size = 16
$T6 = -448						; size = 16
$T7 = -432						; size = 16
$T8 = -416						; size = 16
_xMaskHighByte$9 = -400					; size = 16
$T10 = -384						; size = 16
$T11 = -368						; size = 16
$T12 = -352						; size = 16
$T13 = -336						; size = 16
_x1$14 = -320						; size = 16
_x0$15 = -304						; size = 16
_dst_ptr_fin$16 = -280					; size = 4
_dst_ptr$17 = -276					; size = 4
_src_v_ptr$18 = -272					; size = 4
_src_u_ptr$19 = -268					; size = 4
_x_fin$20 = -264					; size = 4
_y$21 = -260						; size = 4
_dstLine$ = -256					; size = 4
_srcVLine$ = -252					; size = 4
_srcULine$ = -248					; size = 4
_src_uv_pitch$ = -244					; size = 4
$T22 = -240						; size = 12
_uv_range$ = -224					; size = 12
$T23 = -208						; size = 16
$T24 = -192						; size = 16
$T25 = -176						; size = 16
$T26 = -160						; size = 16
$T27 = -144						; size = 16
_x1$28 = -128						; size = 16
_x0$29 = -112						; size = 16
_src_ptr_fin$30 = -84					; size = 4
_src_ptr$31 = -80					; size = 4
_dst_ptr$32 = -76					; size = 4
_y$33 = -72						; size = 4
_y_width$34 = -68					; size = 4
_dstLine$35 = -64					; size = 4
_srcYLine$36 = -60					; size = 4
$T37 = -56						; size = 12
_y_range$38 = -40					; size = 12
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yv12_high_to_nv12_simd@$0M@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_high_to_nv12_simd<12,0>

; 972  : static void convert_yv12_high_to_nv12_simd(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 10 02 00
	00		 sub	 esp, 528		; 00000210H
  0001c	57		 push	 edi
  0001d	8d bd f0 fd ff
	ff		 lea	 edi, DWORD PTR [ebp-528]
  00023	b9 84 00 00 00	 mov	 ecx, 132		; 00000084H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 973  :     static_assert(8 < in_bit_depth && in_bit_depth <= 16, "in_bit_depth must be 9-16.");
; 974  :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 975  :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 976  :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 977  :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 978  :     const int src_y_pitch = src_y_pitch_byte >> 1;

  0007c	8b 53 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  0007f	d1 fa		 sar	 edx, 1
  00081	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 979  :     //Y成分のコピー
; 980  :     if (!uv_only) {

  00084	b8 01 00 00 00	 mov	 eax, 1
  00089	85 c0		 test	 eax, eax
  0008b	0f 84 8d 01 00
	00		 je	 $LN14@convert_yv

; 981  :         const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00091	8b 4b 2c	 mov	 ecx, DWORD PTR _thread_n$[ebx]
  00094	51		 push	 ecx
  00095	8b 53 28	 mov	 edx, DWORD PTR _thread_id$[ebx]
  00098	52		 push	 edx
  00099	8b 43 20	 mov	 eax, DWORD PTR _height$[ebx]
  0009c	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  0009f	50		 push	 eax
  000a0	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  000a3	51		 push	 ecx
  000a4	8d 95 00 fe ff
	ff		 lea	 edx, DWORD PTR $T2[ebp]
  000aa	52		 push	 edx
  000ab	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  000b0	83 c4 14	 add	 esp, 20			; 00000014H
  000b3	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b5	89 4d c8	 mov	 DWORD PTR $T37[ebp], ecx
  000b8	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000bb	89 55 cc	 mov	 DWORD PTR $T37[ebp+4], edx
  000be	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000c1	89 45 d0	 mov	 DWORD PTR $T37[ebp+8], eax
  000c4	8b 4d c8	 mov	 ecx, DWORD PTR $T37[ebp]
  000c7	89 4d d8	 mov	 DWORD PTR _y_range$38[ebp], ecx
  000ca	8b 55 cc	 mov	 edx, DWORD PTR $T37[ebp+4]
  000cd	89 55 dc	 mov	 DWORD PTR _y_range$38[ebp+4], edx
  000d0	8b 45 d0	 mov	 eax, DWORD PTR $T37[ebp+8]
  000d3	89 45 e0	 mov	 DWORD PTR _y_range$38[ebp+8], eax

; 982  :         uint16_t *srcYLine = (uint16_t *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000d6	b9 04 00 00 00	 mov	 ecx, 4
  000db	6b d1 00	 imul	 edx, ecx, 0
  000de	8b 45 e8	 mov	 eax, DWORD PTR _src_y_pitch$[ebp]
  000e1	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$38[ebp]
  000e5	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  000e8	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  000eb	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  000ee	8b 4d f8	 mov	 ecx, DWORD PTR _crop_left$[ebp]
  000f1	8d 14 48	 lea	 edx, DWORD PTR [eax+ecx*2]
  000f4	89 55 c4	 mov	 DWORD PTR _srcYLine$36[ebp], edx

; 983  :         uint8_t *dstLine  = (uint8_t *)dst[0] + dst_y_pitch_byte * y_range.start_dst;

  000f7	b8 04 00 00 00	 mov	 eax, 4
  000fc	6b c8 00	 imul	 ecx, eax, 0
  000ff	8b 53 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebx]
  00102	0f af 55 dc	 imul	 edx, DWORD PTR _y_range$38[ebp+4]
  00106	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  00109	03 14 08	 add	 edx, DWORD PTR [eax+ecx]
  0010c	89 55 c0	 mov	 DWORD PTR _dstLine$35[ebp], edx

; 984  :         const int y_width = width - crop_right - crop_left;

  0010f	8b 4b 10	 mov	 ecx, DWORD PTR _width$[ebx]
  00112	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  00115	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  00118	89 4d bc	 mov	 DWORD PTR _y_width$34[ebp], ecx

; 985  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch_byte) {

  0011b	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _y$33[ebp], 0
  00122	eb 1e		 jmp	 SHORT $LN4@convert_yv
$LN2@convert_yv:
  00124	8b 55 b8	 mov	 edx, DWORD PTR _y$33[ebp]
  00127	83 c2 01	 add	 edx, 1
  0012a	89 55 b8	 mov	 DWORD PTR _y$33[ebp], edx
  0012d	8b 45 e8	 mov	 eax, DWORD PTR _src_y_pitch$[ebp]
  00130	8b 4d c4	 mov	 ecx, DWORD PTR _srcYLine$36[ebp]
  00133	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00136	89 55 c4	 mov	 DWORD PTR _srcYLine$36[ebp], edx
  00139	8b 45 c0	 mov	 eax, DWORD PTR _dstLine$35[ebp]
  0013c	03 43 1c	 add	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  0013f	89 45 c0	 mov	 DWORD PTR _dstLine$35[ebp], eax
$LN4@convert_yv:
  00142	8b 4d b8	 mov	 ecx, DWORD PTR _y$33[ebp]
  00145	3b 4d e0	 cmp	 ecx, DWORD PTR _y_range$38[ebp+8]
  00148	0f 8d d0 00 00
	00		 jge	 $LN14@convert_yv

; 986  :             uint8_t *dst_ptr = dstLine;

  0014e	8b 55 c0	 mov	 edx, DWORD PTR _dstLine$35[ebp]
  00151	89 55 b4	 mov	 DWORD PTR _dst_ptr$32[ebp], edx

; 987  :             uint16_t *src_ptr = srcYLine;

  00154	8b 45 c4	 mov	 eax, DWORD PTR _srcYLine$36[ebp]
  00157	89 45 b0	 mov	 DWORD PTR _src_ptr$31[ebp], eax

; 988  :             uint16_t *src_ptr_fin = src_ptr + y_width;

  0015a	8b 4d bc	 mov	 ecx, DWORD PTR _y_width$34[ebp]
  0015d	8b 55 b0	 mov	 edx, DWORD PTR _src_ptr$31[ebp]
  00160	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  00163	89 45 ac	 mov	 DWORD PTR _src_ptr_fin$30[ebp], eax

; 989  :             __m128i x0, x1;
; 990  :             for (; src_ptr < src_ptr_fin; dst_ptr += 16, src_ptr += 16) {

  00166	eb 12		 jmp	 SHORT $LN7@convert_yv
$LN5@convert_yv:
  00168	8b 4d b4	 mov	 ecx, DWORD PTR _dst_ptr$32[ebp]
  0016b	83 c1 10	 add	 ecx, 16			; 00000010H
  0016e	89 4d b4	 mov	 DWORD PTR _dst_ptr$32[ebp], ecx
  00171	8b 55 b0	 mov	 edx, DWORD PTR _src_ptr$31[ebp]
  00174	83 c2 20	 add	 edx, 32			; 00000020H
  00177	89 55 b0	 mov	 DWORD PTR _src_ptr$31[ebp], edx
$LN7@convert_yv:
  0017a	8b 45 b0	 mov	 eax, DWORD PTR _src_ptr$31[ebp]
  0017d	3b 45 ac	 cmp	 eax, DWORD PTR _src_ptr_fin$30[ebp]
  00180	0f 83 93 00 00
	00		 jae	 $LN6@convert_yv

; 991  :                 x0 = _mm_loadu_si128((const __m128i *)(src_ptr + 0));

  00186	8b 4d b0	 mov	 ecx, DWORD PTR _src_ptr$31[ebp]
  00189	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  0018c	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR $T27[ebp], xmm0
  00193	0f 28 85 70 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T27[ebp]
  0019a	0f 29 45 90	 movaps	 XMMWORD PTR _x0$29[ebp], xmm0

; 992  :                 x1 = _mm_loadu_si128((const __m128i *)(src_ptr + 8));

  0019e	8b 55 b0	 mov	 edx, DWORD PTR _src_ptr$31[ebp]
  001a1	83 c2 10	 add	 edx, 16			; 00000010H
  001a4	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  001a7	0f 29 85 60 ff
	ff ff		 movaps	 XMMWORD PTR $T26[ebp], xmm0
  001ae	0f 28 85 60 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T26[ebp]
  001b5	0f 29 45 80	 movaps	 XMMWORD PTR _x1$28[ebp], xmm0

; 993  : 
; 994  :                 x0 = _mm_srli_epi16(x0, in_bit_depth - 8);

  001b9	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR _x0$29[ebp]
  001bd	66 0f 71 d0 04	 psrlw	 xmm0, 4
  001c2	0f 29 85 50 ff
	ff ff		 movaps	 XMMWORD PTR $T25[ebp], xmm0
  001c9	0f 28 85 50 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T25[ebp]
  001d0	0f 29 45 90	 movaps	 XMMWORD PTR _x0$29[ebp], xmm0

; 995  :                 x1 = _mm_srli_epi16(x1, in_bit_depth - 8);

  001d4	0f 28 45 80	 movaps	 xmm0, XMMWORD PTR _x1$28[ebp]
  001d8	66 0f 71 d0 04	 psrlw	 xmm0, 4
  001dd	0f 29 85 40 ff
	ff ff		 movaps	 XMMWORD PTR $T24[ebp], xmm0
  001e4	0f 28 85 40 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T24[ebp]
  001eb	0f 29 45 80	 movaps	 XMMWORD PTR _x1$28[ebp], xmm0

; 996  : 
; 997  :                 x0 = _mm_packus_epi16(x0, x1);

  001ef	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR _x0$29[ebp]
  001f3	66 0f 67 45 80	 packuswb xmm0, XMMWORD PTR _x1$28[ebp]
  001f8	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR $T23[ebp], xmm0
  001ff	0f 28 85 30 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T23[ebp]
  00206	0f 29 45 90	 movaps	 XMMWORD PTR _x0$29[ebp], xmm0

; 998  : 
; 999  :                 _mm_storeu_si128((__m128i *)(dst_ptr + 0), x0);

  0020a	0f 10 45 90	 movups	 xmm0, XMMWORD PTR _x0$29[ebp]
  0020e	8b 45 b4	 mov	 eax, DWORD PTR _dst_ptr$32[ebp]
  00211	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 1000 :             }

  00214	e9 4f ff ff ff	 jmp	 $LN5@convert_yv
$LN6@convert_yv:

; 1001 :         }

  00219	e9 06 ff ff ff	 jmp	 $LN2@convert_yv
$LN14@convert_yv:

; 1002 :     }
; 1003 :     //UV成分のコピー
; 1004 :     const auto uv_range = thread_y_range(crop_up >> 1, (height - crop_bottom) >> 1, thread_id, thread_n);

  0021e	8b 4b 2c	 mov	 ecx, DWORD PTR _thread_n$[ebx]
  00221	51		 push	 ecx
  00222	8b 53 28	 mov	 edx, DWORD PTR _thread_id$[ebx]
  00225	52		 push	 edx
  00226	8b 43 20	 mov	 eax, DWORD PTR _height$[ebx]
  00229	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  0022c	d1 f8		 sar	 eax, 1
  0022e	50		 push	 eax
  0022f	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  00232	d1 f9		 sar	 ecx, 1
  00234	51		 push	 ecx
  00235	8d 95 f0 fd ff
	ff		 lea	 edx, DWORD PTR $T1[ebp]
  0023b	52		 push	 edx
  0023c	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00241	83 c4 14	 add	 esp, 20			; 00000014H
  00244	8b 08		 mov	 ecx, DWORD PTR [eax]
  00246	89 8d 10 ff ff
	ff		 mov	 DWORD PTR $T22[ebp], ecx
  0024c	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0024f	89 95 14 ff ff
	ff		 mov	 DWORD PTR $T22[ebp+4], edx
  00255	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00258	89 85 18 ff ff
	ff		 mov	 DWORD PTR $T22[ebp+8], eax
  0025e	8b 8d 10 ff ff
	ff		 mov	 ecx, DWORD PTR $T22[ebp]
  00264	89 8d 20 ff ff
	ff		 mov	 DWORD PTR _uv_range$[ebp], ecx
  0026a	8b 95 14 ff ff
	ff		 mov	 edx, DWORD PTR $T22[ebp+4]
  00270	89 95 24 ff ff
	ff		 mov	 DWORD PTR _uv_range$[ebp+4], edx
  00276	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR $T22[ebp+8]
  0027c	89 85 28 ff ff
	ff		 mov	 DWORD PTR _uv_range$[ebp+8], eax

; 1005 :     const int src_uv_pitch = src_uv_pitch_byte >> 1;

  00282	8b 4b 18	 mov	 ecx, DWORD PTR _src_uv_pitch_byte$[ebx]
  00285	d1 f9		 sar	 ecx, 1
  00287	89 8d 0c ff ff
	ff		 mov	 DWORD PTR _src_uv_pitch$[ebp], ecx

; 1006 :     uint16_t *srcULine = (uint16_t *)src[1] + ((src_uv_pitch * uv_range.start_src) + (crop_left >> 1));

  0028d	ba 04 00 00 00	 mov	 edx, 4
  00292	c1 e2 00	 shl	 edx, 0
  00295	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  0029b	0f af 85 20 ff
	ff ff		 imul	 eax, DWORD PTR _uv_range$[ebp]
  002a2	8b 4d f8	 mov	 ecx, DWORD PTR _crop_left$[ebp]
  002a5	d1 f9		 sar	 ecx, 1
  002a7	03 c1		 add	 eax, ecx
  002a9	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  002ac	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  002af	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  002b2	89 85 08 ff ff
	ff		 mov	 DWORD PTR _srcULine$[ebp], eax

; 1007 :     uint16_t *srcVLine = (uint16_t *)src[2] + ((src_uv_pitch * uv_range.start_src) + (crop_left >> 1));

  002b8	b9 04 00 00 00	 mov	 ecx, 4
  002bd	d1 e1		 shl	 ecx, 1
  002bf	8b 95 0c ff ff
	ff		 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  002c5	0f af 95 20 ff
	ff ff		 imul	 edx, DWORD PTR _uv_range$[ebp]
  002cc	8b 45 f8	 mov	 eax, DWORD PTR _crop_left$[ebp]
  002cf	d1 f8		 sar	 eax, 1
  002d1	03 d0		 add	 edx, eax
  002d3	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  002d6	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  002d9	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  002dc	89 95 04 ff ff
	ff		 mov	 DWORD PTR _srcVLine$[ebp], edx

; 1008 :     uint8_t *dstLine  = (uint8_t *)dst[1] + dst_y_pitch_byte * uv_range.start_dst;

  002e2	b8 04 00 00 00	 mov	 eax, 4
  002e7	c1 e0 00	 shl	 eax, 0
  002ea	8b 4b 1c	 mov	 ecx, DWORD PTR _dst_y_pitch_byte$[ebx]
  002ed	0f af 8d 24 ff
	ff ff		 imul	 ecx, DWORD PTR _uv_range$[ebp+4]
  002f4	8b 53 08	 mov	 edx, DWORD PTR _dst$[ebx]
  002f7	03 0c 02	 add	 ecx, DWORD PTR [edx+eax]
  002fa	89 8d 00 ff ff
	ff		 mov	 DWORD PTR _dstLine$[ebp], ecx

; 1009 :     for (int y = 0; y < uv_range.len; y++, srcULine += src_uv_pitch, srcVLine += src_uv_pitch, dstLine += dst_y_pitch_byte) {

  00300	c7 85 fc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _y$21[ebp], 0
  0030a	eb 48		 jmp	 SHORT $LN10@convert_yv
$LN8@convert_yv:
  0030c	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR _y$21[ebp]
  00312	83 c0 01	 add	 eax, 1
  00315	89 85 fc fe ff
	ff		 mov	 DWORD PTR _y$21[ebp], eax
  0031b	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00321	8b 95 08 ff ff
	ff		 mov	 edx, DWORD PTR _srcULine$[ebp]
  00327	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  0032a	89 85 08 ff ff
	ff		 mov	 DWORD PTR _srcULine$[ebp], eax
  00330	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00336	8b 95 04 ff ff
	ff		 mov	 edx, DWORD PTR _srcVLine$[ebp]
  0033c	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  0033f	89 85 04 ff ff
	ff		 mov	 DWORD PTR _srcVLine$[ebp], eax
  00345	8b 8d 00 ff ff
	ff		 mov	 ecx, DWORD PTR _dstLine$[ebp]
  0034b	03 4b 1c	 add	 ecx, DWORD PTR _dst_y_pitch_byte$[ebx]
  0034e	89 8d 00 ff ff
	ff		 mov	 DWORD PTR _dstLine$[ebp], ecx
$LN10@convert_yv:
  00354	8b 95 fc fe ff
	ff		 mov	 edx, DWORD PTR _y$21[ebp]
  0035a	3b 95 28 ff ff
	ff		 cmp	 edx, DWORD PTR _uv_range$[ebp+8]
  00360	0f 8d ae 01 00
	00		 jge	 $LN1@convert_yv

; 1010 :         const int x_fin = width - crop_right;

  00366	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  00369	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  0036c	89 85 f8 fe ff
	ff		 mov	 DWORD PTR _x_fin$20[ebp], eax

; 1011 :         uint16_t *src_u_ptr = srcULine;

  00372	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR _srcULine$[ebp]
  00378	89 8d f4 fe ff
	ff		 mov	 DWORD PTR _src_u_ptr$19[ebp], ecx

; 1012 :         uint16_t *src_v_ptr = srcVLine;

  0037e	8b 95 04 ff ff
	ff		 mov	 edx, DWORD PTR _srcVLine$[ebp]
  00384	89 95 f0 fe ff
	ff		 mov	 DWORD PTR _src_v_ptr$18[ebp], edx

; 1013 :         uint8_t *dst_ptr = dstLine;

  0038a	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR _dstLine$[ebp]
  00390	89 85 ec fe ff
	ff		 mov	 DWORD PTR _dst_ptr$17[ebp], eax

; 1014 :         uint8_t *dst_ptr_fin = dst_ptr + x_fin;

  00396	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _dst_ptr$17[ebp]
  0039c	03 8d f8 fe ff
	ff		 add	 ecx, DWORD PTR _x_fin$20[ebp]
  003a2	89 8d e8 fe ff
	ff		 mov	 DWORD PTR _dst_ptr_fin$16[ebp], ecx

; 1015 :         __m128i x0, x1;
; 1016 :         for (; dst_ptr < dst_ptr_fin; src_u_ptr += 8, src_v_ptr += 8, dst_ptr += 16) {

  003a8	eb 2d		 jmp	 SHORT $LN13@convert_yv
$LN11@convert_yv:
  003aa	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR _src_u_ptr$19[ebp]
  003b0	83 c2 10	 add	 edx, 16			; 00000010H
  003b3	89 95 f4 fe ff
	ff		 mov	 DWORD PTR _src_u_ptr$19[ebp], edx
  003b9	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _src_v_ptr$18[ebp]
  003bf	83 c0 10	 add	 eax, 16			; 00000010H
  003c2	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _src_v_ptr$18[ebp], eax
  003c8	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _dst_ptr$17[ebp]
  003ce	83 c1 10	 add	 ecx, 16			; 00000010H
  003d1	89 8d ec fe ff
	ff		 mov	 DWORD PTR _dst_ptr$17[ebp], ecx
$LN13@convert_yv:
  003d7	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _dst_ptr$17[ebp]
  003dd	3b 95 e8 fe ff
	ff		 cmp	 edx, DWORD PTR _dst_ptr_fin$16[ebp]
  003e3	0f 83 26 01 00
	00		 jae	 $LN12@convert_yv

; 1017 :             x0 = _mm_loadu_si128((const __m128i *)src_u_ptr);

  003e9	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _src_u_ptr$19[ebp]
  003ef	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  003f2	0f 29 85 b0 fe
	ff ff		 movaps	 XMMWORD PTR $T13[ebp], xmm0
  003f9	0f 28 85 b0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T13[ebp]
  00400	0f 29 85 d0 fe
	ff ff		 movaps	 XMMWORD PTR _x0$15[ebp], xmm0

; 1018 :             x1 = _mm_loadu_si128((const __m128i *)src_v_ptr);

  00407	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR _src_v_ptr$18[ebp]
  0040d	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00410	0f 29 85 a0 fe
	ff ff		 movaps	 XMMWORD PTR $T12[ebp], xmm0
  00417	0f 28 85 a0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T12[ebp]
  0041e	0f 29 85 c0 fe
	ff ff		 movaps	 XMMWORD PTR _x1$14[ebp], xmm0

; 1019 : 
; 1020 :             x0 = _mm_srli_epi16(x0, in_bit_depth - 8);

  00425	0f 28 85 d0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _x0$15[ebp]
  0042c	66 0f 71 d0 04	 psrlw	 xmm0, 4
  00431	0f 29 85 90 fe
	ff ff		 movaps	 XMMWORD PTR $T11[ebp], xmm0
  00438	0f 28 85 90 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T11[ebp]
  0043f	0f 29 85 d0 fe
	ff ff		 movaps	 XMMWORD PTR _x0$15[ebp], xmm0

; 1021 :             x1 = _mm_slli_epi16(x1, 16 - in_bit_depth);

  00446	0f 28 85 c0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$14[ebp]
  0044d	66 0f 71 f0 04	 psllw	 xmm0, 4
  00452	0f 29 85 80 fe
	ff ff		 movaps	 XMMWORD PTR $T10[ebp], xmm0
  00459	0f 28 85 80 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T10[ebp]
  00460	0f 29 85 c0 fe
	ff ff		 movaps	 XMMWORD PTR _x1$14[ebp], xmm0

; 1022 :             const __m128i xMaskHighByte = _mm_slli_epi16(_mm_cmpeq_epi8(_mm_setzero_si128(), _mm_setzero_si128()), 8);

  00467	0f 57 c0	 xorps	 xmm0, xmm0
  0046a	0f 29 85 50 fe
	ff ff		 movaps	 XMMWORD PTR $T7[ebp], xmm0
  00471	0f 57 c0	 xorps	 xmm0, xmm0
  00474	0f 29 85 60 fe
	ff ff		 movaps	 XMMWORD PTR $T8[ebp], xmm0
  0047b	0f 28 85 60 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T8[ebp]
  00482	66 0f 74 85 50
	fe ff ff	 pcmpeqb xmm0, XMMWORD PTR $T7[ebp]
  0048a	0f 29 85 40 fe
	ff ff		 movaps	 XMMWORD PTR $T6[ebp], xmm0
  00491	0f 28 85 40 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T6[ebp]
  00498	66 0f 71 f0 08	 psllw	 xmm0, 8
  0049d	0f 29 85 30 fe
	ff ff		 movaps	 XMMWORD PTR $T5[ebp], xmm0
  004a4	0f 28 85 30 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T5[ebp]
  004ab	0f 29 85 70 fe
	ff ff		 movaps	 XMMWORD PTR _xMaskHighByte$9[ebp], xmm0

; 1023 :             x1 = _mm_and_si128(x1, xMaskHighByte);

  004b2	0f 28 85 c0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$14[ebp]
  004b9	66 0f db 85 70
	fe ff ff	 pand	 xmm0, XMMWORD PTR _xMaskHighByte$9[ebp]
  004c1	0f 29 85 20 fe
	ff ff		 movaps	 XMMWORD PTR $T4[ebp], xmm0
  004c8	0f 28 85 20 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T4[ebp]
  004cf	0f 29 85 c0 fe
	ff ff		 movaps	 XMMWORD PTR _x1$14[ebp], xmm0

; 1024 : 
; 1025 :             x0 = _mm_or_si128(x0, x1);

  004d6	0f 28 85 d0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _x0$15[ebp]
  004dd	66 0f eb 85 c0
	fe ff ff	 por	 xmm0, XMMWORD PTR _x1$14[ebp]
  004e5	0f 29 85 10 fe
	ff ff		 movaps	 XMMWORD PTR $T3[ebp], xmm0
  004ec	0f 28 85 10 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T3[ebp]
  004f3	0f 29 85 d0 fe
	ff ff		 movaps	 XMMWORD PTR _x0$15[ebp], xmm0

; 1026 : 
; 1027 :             _mm_storeu_si128((__m128i *)(dst_ptr +  0), x0);

  004fa	0f 10 85 d0 fe
	ff ff		 movups	 xmm0, XMMWORD PTR _x0$15[ebp]
  00501	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _dst_ptr$17[ebp]
  00507	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 1028 :         }

  0050a	e9 9b fe ff ff	 jmp	 $LN11@convert_yv
$LN12@convert_yv:

; 1029 :     }

  0050f	e9 f8 fd ff ff	 jmp	 $LN8@convert_yv
$LN1@convert_yv:

; 1030 : }

  00514	52		 push	 edx
  00515	8b cd		 mov	 ecx, ebp
  00517	50		 push	 eax
  00518	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN19@convert_yv
  0051e	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00523	58		 pop	 eax
  00524	5a		 pop	 edx
  00525	5f		 pop	 edi
  00526	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00529	33 cd		 xor	 ecx, ebp
  0052b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00530	8b e5		 mov	 esp, ebp
  00532	5d		 pop	 ebp
  00533	8b e3		 mov	 esp, ebx
  00535	5b		 pop	 ebx
  00536	c3		 ret	 0
  00537	90		 npad	 1
$LN19@convert_yv:
  00538	02 00 00 00	 DD	 2
  0053c	00 00 00 00	 DD	 $LN18@convert_yv
$LN18@convert_yv:
  00540	d8 ff ff ff	 DD	 -40			; ffffffd8H
  00544	0c 00 00 00	 DD	 12			; 0000000cH
  00548	00 00 00 00	 DD	 $LN16@convert_yv
  0054c	20 ff ff ff	 DD	 -224			; ffffff20H
  00550	0c 00 00 00	 DD	 12			; 0000000cH
  00554	00 00 00 00	 DD	 $LN17@convert_yv
$LN17@convert_yv:
  00558	75		 DB	 117			; 00000075H
  00559	76		 DB	 118			; 00000076H
  0055a	5f		 DB	 95			; 0000005fH
  0055b	72		 DB	 114			; 00000072H
  0055c	61		 DB	 97			; 00000061H
  0055d	6e		 DB	 110			; 0000006eH
  0055e	67		 DB	 103			; 00000067H
  0055f	65		 DB	 101			; 00000065H
  00560	00		 DB	 0
$LN16@convert_yv:
  00561	79		 DB	 121			; 00000079H
  00562	5f		 DB	 95			; 0000005fH
  00563	72		 DB	 114			; 00000072H
  00564	61		 DB	 97			; 00000061H
  00565	6e		 DB	 110			; 0000006eH
  00566	67		 DB	 103			; 00000067H
  00567	65		 DB	 101			; 00000065H
  00568	00		 DB	 0
??$convert_yv12_high_to_nv12_simd@$0M@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_high_to_nv12_simd<12,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_sse2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yv12_12_to_nv12_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_12_to_nv12_sse2

; 113  : void convert_yv12_12_to_nv12_sse2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 114  :     convert_yv12_high_to_nv12_simd<12, false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yv12_high_to_nv12_simd@$0M@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_high_to_nv12_simd<12,0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 115  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yv12_12_to_nv12_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_12_to_nv12_sse2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -528						; size = 12
$T2 = -512						; size = 12
$T3 = -496						; size = 16
$T4 = -480						; size = 16
$T5 = -464						; size = 16
$T6 = -448						; size = 16
$T7 = -432						; size = 16
$T8 = -416						; size = 16
_xMaskHighByte$9 = -400					; size = 16
$T10 = -384						; size = 16
$T11 = -368						; size = 16
$T12 = -352						; size = 16
$T13 = -336						; size = 16
_x1$14 = -320						; size = 16
_x0$15 = -304						; size = 16
_dst_ptr_fin$16 = -280					; size = 4
_dst_ptr$17 = -276					; size = 4
_src_v_ptr$18 = -272					; size = 4
_src_u_ptr$19 = -268					; size = 4
_x_fin$20 = -264					; size = 4
_y$21 = -260						; size = 4
_dstLine$ = -256					; size = 4
_srcVLine$ = -252					; size = 4
_srcULine$ = -248					; size = 4
_src_uv_pitch$ = -244					; size = 4
$T22 = -240						; size = 12
_uv_range$ = -224					; size = 12
$T23 = -208						; size = 16
$T24 = -192						; size = 16
$T25 = -176						; size = 16
$T26 = -160						; size = 16
$T27 = -144						; size = 16
_x1$28 = -128						; size = 16
_x0$29 = -112						; size = 16
_src_ptr_fin$30 = -84					; size = 4
_src_ptr$31 = -80					; size = 4
_dst_ptr$32 = -76					; size = 4
_y$33 = -72						; size = 4
_y_width$34 = -68					; size = 4
_dstLine$35 = -64					; size = 4
_srcYLine$36 = -60					; size = 4
$T37 = -56						; size = 12
_y_range$38 = -40					; size = 12
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yv12_high_to_nv12_simd@$0O@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_high_to_nv12_simd<14,0>

; 972  : static void convert_yv12_high_to_nv12_simd(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 10 02 00
	00		 sub	 esp, 528		; 00000210H
  0001c	57		 push	 edi
  0001d	8d bd f0 fd ff
	ff		 lea	 edi, DWORD PTR [ebp-528]
  00023	b9 84 00 00 00	 mov	 ecx, 132		; 00000084H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 973  :     static_assert(8 < in_bit_depth && in_bit_depth <= 16, "in_bit_depth must be 9-16.");
; 974  :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 975  :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 976  :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 977  :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 978  :     const int src_y_pitch = src_y_pitch_byte >> 1;

  0007c	8b 53 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  0007f	d1 fa		 sar	 edx, 1
  00081	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 979  :     //Y成分のコピー
; 980  :     if (!uv_only) {

  00084	b8 01 00 00 00	 mov	 eax, 1
  00089	85 c0		 test	 eax, eax
  0008b	0f 84 8d 01 00
	00		 je	 $LN14@convert_yv

; 981  :         const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00091	8b 4b 2c	 mov	 ecx, DWORD PTR _thread_n$[ebx]
  00094	51		 push	 ecx
  00095	8b 53 28	 mov	 edx, DWORD PTR _thread_id$[ebx]
  00098	52		 push	 edx
  00099	8b 43 20	 mov	 eax, DWORD PTR _height$[ebx]
  0009c	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  0009f	50		 push	 eax
  000a0	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  000a3	51		 push	 ecx
  000a4	8d 95 00 fe ff
	ff		 lea	 edx, DWORD PTR $T2[ebp]
  000aa	52		 push	 edx
  000ab	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  000b0	83 c4 14	 add	 esp, 20			; 00000014H
  000b3	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b5	89 4d c8	 mov	 DWORD PTR $T37[ebp], ecx
  000b8	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000bb	89 55 cc	 mov	 DWORD PTR $T37[ebp+4], edx
  000be	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000c1	89 45 d0	 mov	 DWORD PTR $T37[ebp+8], eax
  000c4	8b 4d c8	 mov	 ecx, DWORD PTR $T37[ebp]
  000c7	89 4d d8	 mov	 DWORD PTR _y_range$38[ebp], ecx
  000ca	8b 55 cc	 mov	 edx, DWORD PTR $T37[ebp+4]
  000cd	89 55 dc	 mov	 DWORD PTR _y_range$38[ebp+4], edx
  000d0	8b 45 d0	 mov	 eax, DWORD PTR $T37[ebp+8]
  000d3	89 45 e0	 mov	 DWORD PTR _y_range$38[ebp+8], eax

; 982  :         uint16_t *srcYLine = (uint16_t *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000d6	b9 04 00 00 00	 mov	 ecx, 4
  000db	6b d1 00	 imul	 edx, ecx, 0
  000de	8b 45 e8	 mov	 eax, DWORD PTR _src_y_pitch$[ebp]
  000e1	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$38[ebp]
  000e5	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  000e8	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  000eb	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  000ee	8b 4d f8	 mov	 ecx, DWORD PTR _crop_left$[ebp]
  000f1	8d 14 48	 lea	 edx, DWORD PTR [eax+ecx*2]
  000f4	89 55 c4	 mov	 DWORD PTR _srcYLine$36[ebp], edx

; 983  :         uint8_t *dstLine  = (uint8_t *)dst[0] + dst_y_pitch_byte * y_range.start_dst;

  000f7	b8 04 00 00 00	 mov	 eax, 4
  000fc	6b c8 00	 imul	 ecx, eax, 0
  000ff	8b 53 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebx]
  00102	0f af 55 dc	 imul	 edx, DWORD PTR _y_range$38[ebp+4]
  00106	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  00109	03 14 08	 add	 edx, DWORD PTR [eax+ecx]
  0010c	89 55 c0	 mov	 DWORD PTR _dstLine$35[ebp], edx

; 984  :         const int y_width = width - crop_right - crop_left;

  0010f	8b 4b 10	 mov	 ecx, DWORD PTR _width$[ebx]
  00112	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  00115	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  00118	89 4d bc	 mov	 DWORD PTR _y_width$34[ebp], ecx

; 985  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch_byte) {

  0011b	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _y$33[ebp], 0
  00122	eb 1e		 jmp	 SHORT $LN4@convert_yv
$LN2@convert_yv:
  00124	8b 55 b8	 mov	 edx, DWORD PTR _y$33[ebp]
  00127	83 c2 01	 add	 edx, 1
  0012a	89 55 b8	 mov	 DWORD PTR _y$33[ebp], edx
  0012d	8b 45 e8	 mov	 eax, DWORD PTR _src_y_pitch$[ebp]
  00130	8b 4d c4	 mov	 ecx, DWORD PTR _srcYLine$36[ebp]
  00133	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00136	89 55 c4	 mov	 DWORD PTR _srcYLine$36[ebp], edx
  00139	8b 45 c0	 mov	 eax, DWORD PTR _dstLine$35[ebp]
  0013c	03 43 1c	 add	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  0013f	89 45 c0	 mov	 DWORD PTR _dstLine$35[ebp], eax
$LN4@convert_yv:
  00142	8b 4d b8	 mov	 ecx, DWORD PTR _y$33[ebp]
  00145	3b 4d e0	 cmp	 ecx, DWORD PTR _y_range$38[ebp+8]
  00148	0f 8d d0 00 00
	00		 jge	 $LN14@convert_yv

; 986  :             uint8_t *dst_ptr = dstLine;

  0014e	8b 55 c0	 mov	 edx, DWORD PTR _dstLine$35[ebp]
  00151	89 55 b4	 mov	 DWORD PTR _dst_ptr$32[ebp], edx

; 987  :             uint16_t *src_ptr = srcYLine;

  00154	8b 45 c4	 mov	 eax, DWORD PTR _srcYLine$36[ebp]
  00157	89 45 b0	 mov	 DWORD PTR _src_ptr$31[ebp], eax

; 988  :             uint16_t *src_ptr_fin = src_ptr + y_width;

  0015a	8b 4d bc	 mov	 ecx, DWORD PTR _y_width$34[ebp]
  0015d	8b 55 b0	 mov	 edx, DWORD PTR _src_ptr$31[ebp]
  00160	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  00163	89 45 ac	 mov	 DWORD PTR _src_ptr_fin$30[ebp], eax

; 989  :             __m128i x0, x1;
; 990  :             for (; src_ptr < src_ptr_fin; dst_ptr += 16, src_ptr += 16) {

  00166	eb 12		 jmp	 SHORT $LN7@convert_yv
$LN5@convert_yv:
  00168	8b 4d b4	 mov	 ecx, DWORD PTR _dst_ptr$32[ebp]
  0016b	83 c1 10	 add	 ecx, 16			; 00000010H
  0016e	89 4d b4	 mov	 DWORD PTR _dst_ptr$32[ebp], ecx
  00171	8b 55 b0	 mov	 edx, DWORD PTR _src_ptr$31[ebp]
  00174	83 c2 20	 add	 edx, 32			; 00000020H
  00177	89 55 b0	 mov	 DWORD PTR _src_ptr$31[ebp], edx
$LN7@convert_yv:
  0017a	8b 45 b0	 mov	 eax, DWORD PTR _src_ptr$31[ebp]
  0017d	3b 45 ac	 cmp	 eax, DWORD PTR _src_ptr_fin$30[ebp]
  00180	0f 83 93 00 00
	00		 jae	 $LN6@convert_yv

; 991  :                 x0 = _mm_loadu_si128((const __m128i *)(src_ptr + 0));

  00186	8b 4d b0	 mov	 ecx, DWORD PTR _src_ptr$31[ebp]
  00189	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  0018c	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR $T27[ebp], xmm0
  00193	0f 28 85 70 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T27[ebp]
  0019a	0f 29 45 90	 movaps	 XMMWORD PTR _x0$29[ebp], xmm0

; 992  :                 x1 = _mm_loadu_si128((const __m128i *)(src_ptr + 8));

  0019e	8b 55 b0	 mov	 edx, DWORD PTR _src_ptr$31[ebp]
  001a1	83 c2 10	 add	 edx, 16			; 00000010H
  001a4	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  001a7	0f 29 85 60 ff
	ff ff		 movaps	 XMMWORD PTR $T26[ebp], xmm0
  001ae	0f 28 85 60 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T26[ebp]
  001b5	0f 29 45 80	 movaps	 XMMWORD PTR _x1$28[ebp], xmm0

; 993  : 
; 994  :                 x0 = _mm_srli_epi16(x0, in_bit_depth - 8);

  001b9	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR _x0$29[ebp]
  001bd	66 0f 71 d0 06	 psrlw	 xmm0, 6
  001c2	0f 29 85 50 ff
	ff ff		 movaps	 XMMWORD PTR $T25[ebp], xmm0
  001c9	0f 28 85 50 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T25[ebp]
  001d0	0f 29 45 90	 movaps	 XMMWORD PTR _x0$29[ebp], xmm0

; 995  :                 x1 = _mm_srli_epi16(x1, in_bit_depth - 8);

  001d4	0f 28 45 80	 movaps	 xmm0, XMMWORD PTR _x1$28[ebp]
  001d8	66 0f 71 d0 06	 psrlw	 xmm0, 6
  001dd	0f 29 85 40 ff
	ff ff		 movaps	 XMMWORD PTR $T24[ebp], xmm0
  001e4	0f 28 85 40 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T24[ebp]
  001eb	0f 29 45 80	 movaps	 XMMWORD PTR _x1$28[ebp], xmm0

; 996  : 
; 997  :                 x0 = _mm_packus_epi16(x0, x1);

  001ef	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR _x0$29[ebp]
  001f3	66 0f 67 45 80	 packuswb xmm0, XMMWORD PTR _x1$28[ebp]
  001f8	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR $T23[ebp], xmm0
  001ff	0f 28 85 30 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T23[ebp]
  00206	0f 29 45 90	 movaps	 XMMWORD PTR _x0$29[ebp], xmm0

; 998  : 
; 999  :                 _mm_storeu_si128((__m128i *)(dst_ptr + 0), x0);

  0020a	0f 10 45 90	 movups	 xmm0, XMMWORD PTR _x0$29[ebp]
  0020e	8b 45 b4	 mov	 eax, DWORD PTR _dst_ptr$32[ebp]
  00211	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 1000 :             }

  00214	e9 4f ff ff ff	 jmp	 $LN5@convert_yv
$LN6@convert_yv:

; 1001 :         }

  00219	e9 06 ff ff ff	 jmp	 $LN2@convert_yv
$LN14@convert_yv:

; 1002 :     }
; 1003 :     //UV成分のコピー
; 1004 :     const auto uv_range = thread_y_range(crop_up >> 1, (height - crop_bottom) >> 1, thread_id, thread_n);

  0021e	8b 4b 2c	 mov	 ecx, DWORD PTR _thread_n$[ebx]
  00221	51		 push	 ecx
  00222	8b 53 28	 mov	 edx, DWORD PTR _thread_id$[ebx]
  00225	52		 push	 edx
  00226	8b 43 20	 mov	 eax, DWORD PTR _height$[ebx]
  00229	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  0022c	d1 f8		 sar	 eax, 1
  0022e	50		 push	 eax
  0022f	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  00232	d1 f9		 sar	 ecx, 1
  00234	51		 push	 ecx
  00235	8d 95 f0 fd ff
	ff		 lea	 edx, DWORD PTR $T1[ebp]
  0023b	52		 push	 edx
  0023c	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00241	83 c4 14	 add	 esp, 20			; 00000014H
  00244	8b 08		 mov	 ecx, DWORD PTR [eax]
  00246	89 8d 10 ff ff
	ff		 mov	 DWORD PTR $T22[ebp], ecx
  0024c	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0024f	89 95 14 ff ff
	ff		 mov	 DWORD PTR $T22[ebp+4], edx
  00255	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00258	89 85 18 ff ff
	ff		 mov	 DWORD PTR $T22[ebp+8], eax
  0025e	8b 8d 10 ff ff
	ff		 mov	 ecx, DWORD PTR $T22[ebp]
  00264	89 8d 20 ff ff
	ff		 mov	 DWORD PTR _uv_range$[ebp], ecx
  0026a	8b 95 14 ff ff
	ff		 mov	 edx, DWORD PTR $T22[ebp+4]
  00270	89 95 24 ff ff
	ff		 mov	 DWORD PTR _uv_range$[ebp+4], edx
  00276	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR $T22[ebp+8]
  0027c	89 85 28 ff ff
	ff		 mov	 DWORD PTR _uv_range$[ebp+8], eax

; 1005 :     const int src_uv_pitch = src_uv_pitch_byte >> 1;

  00282	8b 4b 18	 mov	 ecx, DWORD PTR _src_uv_pitch_byte$[ebx]
  00285	d1 f9		 sar	 ecx, 1
  00287	89 8d 0c ff ff
	ff		 mov	 DWORD PTR _src_uv_pitch$[ebp], ecx

; 1006 :     uint16_t *srcULine = (uint16_t *)src[1] + ((src_uv_pitch * uv_range.start_src) + (crop_left >> 1));

  0028d	ba 04 00 00 00	 mov	 edx, 4
  00292	c1 e2 00	 shl	 edx, 0
  00295	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  0029b	0f af 85 20 ff
	ff ff		 imul	 eax, DWORD PTR _uv_range$[ebp]
  002a2	8b 4d f8	 mov	 ecx, DWORD PTR _crop_left$[ebp]
  002a5	d1 f9		 sar	 ecx, 1
  002a7	03 c1		 add	 eax, ecx
  002a9	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  002ac	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  002af	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  002b2	89 85 08 ff ff
	ff		 mov	 DWORD PTR _srcULine$[ebp], eax

; 1007 :     uint16_t *srcVLine = (uint16_t *)src[2] + ((src_uv_pitch * uv_range.start_src) + (crop_left >> 1));

  002b8	b9 04 00 00 00	 mov	 ecx, 4
  002bd	d1 e1		 shl	 ecx, 1
  002bf	8b 95 0c ff ff
	ff		 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  002c5	0f af 95 20 ff
	ff ff		 imul	 edx, DWORD PTR _uv_range$[ebp]
  002cc	8b 45 f8	 mov	 eax, DWORD PTR _crop_left$[ebp]
  002cf	d1 f8		 sar	 eax, 1
  002d1	03 d0		 add	 edx, eax
  002d3	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  002d6	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  002d9	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  002dc	89 95 04 ff ff
	ff		 mov	 DWORD PTR _srcVLine$[ebp], edx

; 1008 :     uint8_t *dstLine  = (uint8_t *)dst[1] + dst_y_pitch_byte * uv_range.start_dst;

  002e2	b8 04 00 00 00	 mov	 eax, 4
  002e7	c1 e0 00	 shl	 eax, 0
  002ea	8b 4b 1c	 mov	 ecx, DWORD PTR _dst_y_pitch_byte$[ebx]
  002ed	0f af 8d 24 ff
	ff ff		 imul	 ecx, DWORD PTR _uv_range$[ebp+4]
  002f4	8b 53 08	 mov	 edx, DWORD PTR _dst$[ebx]
  002f7	03 0c 02	 add	 ecx, DWORD PTR [edx+eax]
  002fa	89 8d 00 ff ff
	ff		 mov	 DWORD PTR _dstLine$[ebp], ecx

; 1009 :     for (int y = 0; y < uv_range.len; y++, srcULine += src_uv_pitch, srcVLine += src_uv_pitch, dstLine += dst_y_pitch_byte) {

  00300	c7 85 fc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _y$21[ebp], 0
  0030a	eb 48		 jmp	 SHORT $LN10@convert_yv
$LN8@convert_yv:
  0030c	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR _y$21[ebp]
  00312	83 c0 01	 add	 eax, 1
  00315	89 85 fc fe ff
	ff		 mov	 DWORD PTR _y$21[ebp], eax
  0031b	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00321	8b 95 08 ff ff
	ff		 mov	 edx, DWORD PTR _srcULine$[ebp]
  00327	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  0032a	89 85 08 ff ff
	ff		 mov	 DWORD PTR _srcULine$[ebp], eax
  00330	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00336	8b 95 04 ff ff
	ff		 mov	 edx, DWORD PTR _srcVLine$[ebp]
  0033c	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  0033f	89 85 04 ff ff
	ff		 mov	 DWORD PTR _srcVLine$[ebp], eax
  00345	8b 8d 00 ff ff
	ff		 mov	 ecx, DWORD PTR _dstLine$[ebp]
  0034b	03 4b 1c	 add	 ecx, DWORD PTR _dst_y_pitch_byte$[ebx]
  0034e	89 8d 00 ff ff
	ff		 mov	 DWORD PTR _dstLine$[ebp], ecx
$LN10@convert_yv:
  00354	8b 95 fc fe ff
	ff		 mov	 edx, DWORD PTR _y$21[ebp]
  0035a	3b 95 28 ff ff
	ff		 cmp	 edx, DWORD PTR _uv_range$[ebp+8]
  00360	0f 8d ae 01 00
	00		 jge	 $LN1@convert_yv

; 1010 :         const int x_fin = width - crop_right;

  00366	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  00369	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  0036c	89 85 f8 fe ff
	ff		 mov	 DWORD PTR _x_fin$20[ebp], eax

; 1011 :         uint16_t *src_u_ptr = srcULine;

  00372	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR _srcULine$[ebp]
  00378	89 8d f4 fe ff
	ff		 mov	 DWORD PTR _src_u_ptr$19[ebp], ecx

; 1012 :         uint16_t *src_v_ptr = srcVLine;

  0037e	8b 95 04 ff ff
	ff		 mov	 edx, DWORD PTR _srcVLine$[ebp]
  00384	89 95 f0 fe ff
	ff		 mov	 DWORD PTR _src_v_ptr$18[ebp], edx

; 1013 :         uint8_t *dst_ptr = dstLine;

  0038a	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR _dstLine$[ebp]
  00390	89 85 ec fe ff
	ff		 mov	 DWORD PTR _dst_ptr$17[ebp], eax

; 1014 :         uint8_t *dst_ptr_fin = dst_ptr + x_fin;

  00396	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _dst_ptr$17[ebp]
  0039c	03 8d f8 fe ff
	ff		 add	 ecx, DWORD PTR _x_fin$20[ebp]
  003a2	89 8d e8 fe ff
	ff		 mov	 DWORD PTR _dst_ptr_fin$16[ebp], ecx

; 1015 :         __m128i x0, x1;
; 1016 :         for (; dst_ptr < dst_ptr_fin; src_u_ptr += 8, src_v_ptr += 8, dst_ptr += 16) {

  003a8	eb 2d		 jmp	 SHORT $LN13@convert_yv
$LN11@convert_yv:
  003aa	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR _src_u_ptr$19[ebp]
  003b0	83 c2 10	 add	 edx, 16			; 00000010H
  003b3	89 95 f4 fe ff
	ff		 mov	 DWORD PTR _src_u_ptr$19[ebp], edx
  003b9	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _src_v_ptr$18[ebp]
  003bf	83 c0 10	 add	 eax, 16			; 00000010H
  003c2	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _src_v_ptr$18[ebp], eax
  003c8	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _dst_ptr$17[ebp]
  003ce	83 c1 10	 add	 ecx, 16			; 00000010H
  003d1	89 8d ec fe ff
	ff		 mov	 DWORD PTR _dst_ptr$17[ebp], ecx
$LN13@convert_yv:
  003d7	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _dst_ptr$17[ebp]
  003dd	3b 95 e8 fe ff
	ff		 cmp	 edx, DWORD PTR _dst_ptr_fin$16[ebp]
  003e3	0f 83 26 01 00
	00		 jae	 $LN12@convert_yv

; 1017 :             x0 = _mm_loadu_si128((const __m128i *)src_u_ptr);

  003e9	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _src_u_ptr$19[ebp]
  003ef	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  003f2	0f 29 85 b0 fe
	ff ff		 movaps	 XMMWORD PTR $T13[ebp], xmm0
  003f9	0f 28 85 b0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T13[ebp]
  00400	0f 29 85 d0 fe
	ff ff		 movaps	 XMMWORD PTR _x0$15[ebp], xmm0

; 1018 :             x1 = _mm_loadu_si128((const __m128i *)src_v_ptr);

  00407	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR _src_v_ptr$18[ebp]
  0040d	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00410	0f 29 85 a0 fe
	ff ff		 movaps	 XMMWORD PTR $T12[ebp], xmm0
  00417	0f 28 85 a0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T12[ebp]
  0041e	0f 29 85 c0 fe
	ff ff		 movaps	 XMMWORD PTR _x1$14[ebp], xmm0

; 1019 : 
; 1020 :             x0 = _mm_srli_epi16(x0, in_bit_depth - 8);

  00425	0f 28 85 d0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _x0$15[ebp]
  0042c	66 0f 71 d0 06	 psrlw	 xmm0, 6
  00431	0f 29 85 90 fe
	ff ff		 movaps	 XMMWORD PTR $T11[ebp], xmm0
  00438	0f 28 85 90 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T11[ebp]
  0043f	0f 29 85 d0 fe
	ff ff		 movaps	 XMMWORD PTR _x0$15[ebp], xmm0

; 1021 :             x1 = _mm_slli_epi16(x1, 16 - in_bit_depth);

  00446	0f 28 85 c0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$14[ebp]
  0044d	66 0f 71 f0 02	 psllw	 xmm0, 2
  00452	0f 29 85 80 fe
	ff ff		 movaps	 XMMWORD PTR $T10[ebp], xmm0
  00459	0f 28 85 80 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T10[ebp]
  00460	0f 29 85 c0 fe
	ff ff		 movaps	 XMMWORD PTR _x1$14[ebp], xmm0

; 1022 :             const __m128i xMaskHighByte = _mm_slli_epi16(_mm_cmpeq_epi8(_mm_setzero_si128(), _mm_setzero_si128()), 8);

  00467	0f 57 c0	 xorps	 xmm0, xmm0
  0046a	0f 29 85 50 fe
	ff ff		 movaps	 XMMWORD PTR $T7[ebp], xmm0
  00471	0f 57 c0	 xorps	 xmm0, xmm0
  00474	0f 29 85 60 fe
	ff ff		 movaps	 XMMWORD PTR $T8[ebp], xmm0
  0047b	0f 28 85 60 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T8[ebp]
  00482	66 0f 74 85 50
	fe ff ff	 pcmpeqb xmm0, XMMWORD PTR $T7[ebp]
  0048a	0f 29 85 40 fe
	ff ff		 movaps	 XMMWORD PTR $T6[ebp], xmm0
  00491	0f 28 85 40 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T6[ebp]
  00498	66 0f 71 f0 08	 psllw	 xmm0, 8
  0049d	0f 29 85 30 fe
	ff ff		 movaps	 XMMWORD PTR $T5[ebp], xmm0
  004a4	0f 28 85 30 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T5[ebp]
  004ab	0f 29 85 70 fe
	ff ff		 movaps	 XMMWORD PTR _xMaskHighByte$9[ebp], xmm0

; 1023 :             x1 = _mm_and_si128(x1, xMaskHighByte);

  004b2	0f 28 85 c0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$14[ebp]
  004b9	66 0f db 85 70
	fe ff ff	 pand	 xmm0, XMMWORD PTR _xMaskHighByte$9[ebp]
  004c1	0f 29 85 20 fe
	ff ff		 movaps	 XMMWORD PTR $T4[ebp], xmm0
  004c8	0f 28 85 20 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T4[ebp]
  004cf	0f 29 85 c0 fe
	ff ff		 movaps	 XMMWORD PTR _x1$14[ebp], xmm0

; 1024 : 
; 1025 :             x0 = _mm_or_si128(x0, x1);

  004d6	0f 28 85 d0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _x0$15[ebp]
  004dd	66 0f eb 85 c0
	fe ff ff	 por	 xmm0, XMMWORD PTR _x1$14[ebp]
  004e5	0f 29 85 10 fe
	ff ff		 movaps	 XMMWORD PTR $T3[ebp], xmm0
  004ec	0f 28 85 10 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T3[ebp]
  004f3	0f 29 85 d0 fe
	ff ff		 movaps	 XMMWORD PTR _x0$15[ebp], xmm0

; 1026 : 
; 1027 :             _mm_storeu_si128((__m128i *)(dst_ptr +  0), x0);

  004fa	0f 10 85 d0 fe
	ff ff		 movups	 xmm0, XMMWORD PTR _x0$15[ebp]
  00501	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _dst_ptr$17[ebp]
  00507	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 1028 :         }

  0050a	e9 9b fe ff ff	 jmp	 $LN11@convert_yv
$LN12@convert_yv:

; 1029 :     }

  0050f	e9 f8 fd ff ff	 jmp	 $LN8@convert_yv
$LN1@convert_yv:

; 1030 : }

  00514	52		 push	 edx
  00515	8b cd		 mov	 ecx, ebp
  00517	50		 push	 eax
  00518	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN19@convert_yv
  0051e	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00523	58		 pop	 eax
  00524	5a		 pop	 edx
  00525	5f		 pop	 edi
  00526	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00529	33 cd		 xor	 ecx, ebp
  0052b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00530	8b e5		 mov	 esp, ebp
  00532	5d		 pop	 ebp
  00533	8b e3		 mov	 esp, ebx
  00535	5b		 pop	 ebx
  00536	c3		 ret	 0
  00537	90		 npad	 1
$LN19@convert_yv:
  00538	02 00 00 00	 DD	 2
  0053c	00 00 00 00	 DD	 $LN18@convert_yv
$LN18@convert_yv:
  00540	d8 ff ff ff	 DD	 -40			; ffffffd8H
  00544	0c 00 00 00	 DD	 12			; 0000000cH
  00548	00 00 00 00	 DD	 $LN16@convert_yv
  0054c	20 ff ff ff	 DD	 -224			; ffffff20H
  00550	0c 00 00 00	 DD	 12			; 0000000cH
  00554	00 00 00 00	 DD	 $LN17@convert_yv
$LN17@convert_yv:
  00558	75		 DB	 117			; 00000075H
  00559	76		 DB	 118			; 00000076H
  0055a	5f		 DB	 95			; 0000005fH
  0055b	72		 DB	 114			; 00000072H
  0055c	61		 DB	 97			; 00000061H
  0055d	6e		 DB	 110			; 0000006eH
  0055e	67		 DB	 103			; 00000067H
  0055f	65		 DB	 101			; 00000065H
  00560	00		 DB	 0
$LN16@convert_yv:
  00561	79		 DB	 121			; 00000079H
  00562	5f		 DB	 95			; 0000005fH
  00563	72		 DB	 114			; 00000072H
  00564	61		 DB	 97			; 00000061H
  00565	6e		 DB	 110			; 0000006eH
  00566	67		 DB	 103			; 00000067H
  00567	65		 DB	 101			; 00000065H
  00568	00		 DB	 0
??$convert_yv12_high_to_nv12_simd@$0O@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_high_to_nv12_simd<14,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_sse2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yv12_14_to_nv12_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_14_to_nv12_sse2

; 109  : void convert_yv12_14_to_nv12_sse2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 110  :     convert_yv12_high_to_nv12_simd<14, false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yv12_high_to_nv12_simd@$0O@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_high_to_nv12_simd<14,0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 111  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yv12_14_to_nv12_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_14_to_nv12_sse2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -528						; size = 12
$T2 = -512						; size = 12
$T3 = -496						; size = 16
$T4 = -480						; size = 16
$T5 = -464						; size = 16
$T6 = -448						; size = 16
$T7 = -432						; size = 16
$T8 = -416						; size = 16
_xMaskHighByte$9 = -400					; size = 16
$T10 = -384						; size = 16
$T11 = -368						; size = 16
$T12 = -352						; size = 16
$T13 = -336						; size = 16
_x1$14 = -320						; size = 16
_x0$15 = -304						; size = 16
_dst_ptr_fin$16 = -280					; size = 4
_dst_ptr$17 = -276					; size = 4
_src_v_ptr$18 = -272					; size = 4
_src_u_ptr$19 = -268					; size = 4
_x_fin$20 = -264					; size = 4
_y$21 = -260						; size = 4
_dstLine$ = -256					; size = 4
_srcVLine$ = -252					; size = 4
_srcULine$ = -248					; size = 4
_src_uv_pitch$ = -244					; size = 4
$T22 = -240						; size = 12
_uv_range$ = -224					; size = 12
$T23 = -208						; size = 16
$T24 = -192						; size = 16
$T25 = -176						; size = 16
$T26 = -160						; size = 16
$T27 = -144						; size = 16
_x1$28 = -128						; size = 16
_x0$29 = -112						; size = 16
_src_ptr_fin$30 = -84					; size = 4
_src_ptr$31 = -80					; size = 4
_dst_ptr$32 = -76					; size = 4
_y$33 = -72						; size = 4
_y_width$34 = -68					; size = 4
_dstLine$35 = -64					; size = 4
_srcYLine$36 = -60					; size = 4
$T37 = -56						; size = 12
_y_range$38 = -40					; size = 12
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yv12_high_to_nv12_simd@$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_high_to_nv12_simd<16,0>

; 972  : static void convert_yv12_high_to_nv12_simd(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 10 02 00
	00		 sub	 esp, 528		; 00000210H
  0001c	57		 push	 edi
  0001d	8d bd f0 fd ff
	ff		 lea	 edi, DWORD PTR [ebp-528]
  00023	b9 84 00 00 00	 mov	 ecx, 132		; 00000084H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 973  :     static_assert(8 < in_bit_depth && in_bit_depth <= 16, "in_bit_depth must be 9-16.");
; 974  :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 975  :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 976  :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 977  :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 978  :     const int src_y_pitch = src_y_pitch_byte >> 1;

  0007c	8b 53 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  0007f	d1 fa		 sar	 edx, 1
  00081	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 979  :     //Y成分のコピー
; 980  :     if (!uv_only) {

  00084	b8 01 00 00 00	 mov	 eax, 1
  00089	85 c0		 test	 eax, eax
  0008b	0f 84 8d 01 00
	00		 je	 $LN14@convert_yv

; 981  :         const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00091	8b 4b 2c	 mov	 ecx, DWORD PTR _thread_n$[ebx]
  00094	51		 push	 ecx
  00095	8b 53 28	 mov	 edx, DWORD PTR _thread_id$[ebx]
  00098	52		 push	 edx
  00099	8b 43 20	 mov	 eax, DWORD PTR _height$[ebx]
  0009c	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  0009f	50		 push	 eax
  000a0	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  000a3	51		 push	 ecx
  000a4	8d 95 00 fe ff
	ff		 lea	 edx, DWORD PTR $T2[ebp]
  000aa	52		 push	 edx
  000ab	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  000b0	83 c4 14	 add	 esp, 20			; 00000014H
  000b3	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b5	89 4d c8	 mov	 DWORD PTR $T37[ebp], ecx
  000b8	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000bb	89 55 cc	 mov	 DWORD PTR $T37[ebp+4], edx
  000be	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000c1	89 45 d0	 mov	 DWORD PTR $T37[ebp+8], eax
  000c4	8b 4d c8	 mov	 ecx, DWORD PTR $T37[ebp]
  000c7	89 4d d8	 mov	 DWORD PTR _y_range$38[ebp], ecx
  000ca	8b 55 cc	 mov	 edx, DWORD PTR $T37[ebp+4]
  000cd	89 55 dc	 mov	 DWORD PTR _y_range$38[ebp+4], edx
  000d0	8b 45 d0	 mov	 eax, DWORD PTR $T37[ebp+8]
  000d3	89 45 e0	 mov	 DWORD PTR _y_range$38[ebp+8], eax

; 982  :         uint16_t *srcYLine = (uint16_t *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000d6	b9 04 00 00 00	 mov	 ecx, 4
  000db	6b d1 00	 imul	 edx, ecx, 0
  000de	8b 45 e8	 mov	 eax, DWORD PTR _src_y_pitch$[ebp]
  000e1	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$38[ebp]
  000e5	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  000e8	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  000eb	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  000ee	8b 4d f8	 mov	 ecx, DWORD PTR _crop_left$[ebp]
  000f1	8d 14 48	 lea	 edx, DWORD PTR [eax+ecx*2]
  000f4	89 55 c4	 mov	 DWORD PTR _srcYLine$36[ebp], edx

; 983  :         uint8_t *dstLine  = (uint8_t *)dst[0] + dst_y_pitch_byte * y_range.start_dst;

  000f7	b8 04 00 00 00	 mov	 eax, 4
  000fc	6b c8 00	 imul	 ecx, eax, 0
  000ff	8b 53 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebx]
  00102	0f af 55 dc	 imul	 edx, DWORD PTR _y_range$38[ebp+4]
  00106	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  00109	03 14 08	 add	 edx, DWORD PTR [eax+ecx]
  0010c	89 55 c0	 mov	 DWORD PTR _dstLine$35[ebp], edx

; 984  :         const int y_width = width - crop_right - crop_left;

  0010f	8b 4b 10	 mov	 ecx, DWORD PTR _width$[ebx]
  00112	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  00115	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  00118	89 4d bc	 mov	 DWORD PTR _y_width$34[ebp], ecx

; 985  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch_byte) {

  0011b	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _y$33[ebp], 0
  00122	eb 1e		 jmp	 SHORT $LN4@convert_yv
$LN2@convert_yv:
  00124	8b 55 b8	 mov	 edx, DWORD PTR _y$33[ebp]
  00127	83 c2 01	 add	 edx, 1
  0012a	89 55 b8	 mov	 DWORD PTR _y$33[ebp], edx
  0012d	8b 45 e8	 mov	 eax, DWORD PTR _src_y_pitch$[ebp]
  00130	8b 4d c4	 mov	 ecx, DWORD PTR _srcYLine$36[ebp]
  00133	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00136	89 55 c4	 mov	 DWORD PTR _srcYLine$36[ebp], edx
  00139	8b 45 c0	 mov	 eax, DWORD PTR _dstLine$35[ebp]
  0013c	03 43 1c	 add	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  0013f	89 45 c0	 mov	 DWORD PTR _dstLine$35[ebp], eax
$LN4@convert_yv:
  00142	8b 4d b8	 mov	 ecx, DWORD PTR _y$33[ebp]
  00145	3b 4d e0	 cmp	 ecx, DWORD PTR _y_range$38[ebp+8]
  00148	0f 8d d0 00 00
	00		 jge	 $LN14@convert_yv

; 986  :             uint8_t *dst_ptr = dstLine;

  0014e	8b 55 c0	 mov	 edx, DWORD PTR _dstLine$35[ebp]
  00151	89 55 b4	 mov	 DWORD PTR _dst_ptr$32[ebp], edx

; 987  :             uint16_t *src_ptr = srcYLine;

  00154	8b 45 c4	 mov	 eax, DWORD PTR _srcYLine$36[ebp]
  00157	89 45 b0	 mov	 DWORD PTR _src_ptr$31[ebp], eax

; 988  :             uint16_t *src_ptr_fin = src_ptr + y_width;

  0015a	8b 4d bc	 mov	 ecx, DWORD PTR _y_width$34[ebp]
  0015d	8b 55 b0	 mov	 edx, DWORD PTR _src_ptr$31[ebp]
  00160	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  00163	89 45 ac	 mov	 DWORD PTR _src_ptr_fin$30[ebp], eax

; 989  :             __m128i x0, x1;
; 990  :             for (; src_ptr < src_ptr_fin; dst_ptr += 16, src_ptr += 16) {

  00166	eb 12		 jmp	 SHORT $LN7@convert_yv
$LN5@convert_yv:
  00168	8b 4d b4	 mov	 ecx, DWORD PTR _dst_ptr$32[ebp]
  0016b	83 c1 10	 add	 ecx, 16			; 00000010H
  0016e	89 4d b4	 mov	 DWORD PTR _dst_ptr$32[ebp], ecx
  00171	8b 55 b0	 mov	 edx, DWORD PTR _src_ptr$31[ebp]
  00174	83 c2 20	 add	 edx, 32			; 00000020H
  00177	89 55 b0	 mov	 DWORD PTR _src_ptr$31[ebp], edx
$LN7@convert_yv:
  0017a	8b 45 b0	 mov	 eax, DWORD PTR _src_ptr$31[ebp]
  0017d	3b 45 ac	 cmp	 eax, DWORD PTR _src_ptr_fin$30[ebp]
  00180	0f 83 93 00 00
	00		 jae	 $LN6@convert_yv

; 991  :                 x0 = _mm_loadu_si128((const __m128i *)(src_ptr + 0));

  00186	8b 4d b0	 mov	 ecx, DWORD PTR _src_ptr$31[ebp]
  00189	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  0018c	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR $T27[ebp], xmm0
  00193	0f 28 85 70 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T27[ebp]
  0019a	0f 29 45 90	 movaps	 XMMWORD PTR _x0$29[ebp], xmm0

; 992  :                 x1 = _mm_loadu_si128((const __m128i *)(src_ptr + 8));

  0019e	8b 55 b0	 mov	 edx, DWORD PTR _src_ptr$31[ebp]
  001a1	83 c2 10	 add	 edx, 16			; 00000010H
  001a4	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  001a7	0f 29 85 60 ff
	ff ff		 movaps	 XMMWORD PTR $T26[ebp], xmm0
  001ae	0f 28 85 60 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T26[ebp]
  001b5	0f 29 45 80	 movaps	 XMMWORD PTR _x1$28[ebp], xmm0

; 993  : 
; 994  :                 x0 = _mm_srli_epi16(x0, in_bit_depth - 8);

  001b9	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR _x0$29[ebp]
  001bd	66 0f 71 d0 08	 psrlw	 xmm0, 8
  001c2	0f 29 85 50 ff
	ff ff		 movaps	 XMMWORD PTR $T25[ebp], xmm0
  001c9	0f 28 85 50 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T25[ebp]
  001d0	0f 29 45 90	 movaps	 XMMWORD PTR _x0$29[ebp], xmm0

; 995  :                 x1 = _mm_srli_epi16(x1, in_bit_depth - 8);

  001d4	0f 28 45 80	 movaps	 xmm0, XMMWORD PTR _x1$28[ebp]
  001d8	66 0f 71 d0 08	 psrlw	 xmm0, 8
  001dd	0f 29 85 40 ff
	ff ff		 movaps	 XMMWORD PTR $T24[ebp], xmm0
  001e4	0f 28 85 40 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T24[ebp]
  001eb	0f 29 45 80	 movaps	 XMMWORD PTR _x1$28[ebp], xmm0

; 996  : 
; 997  :                 x0 = _mm_packus_epi16(x0, x1);

  001ef	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR _x0$29[ebp]
  001f3	66 0f 67 45 80	 packuswb xmm0, XMMWORD PTR _x1$28[ebp]
  001f8	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR $T23[ebp], xmm0
  001ff	0f 28 85 30 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T23[ebp]
  00206	0f 29 45 90	 movaps	 XMMWORD PTR _x0$29[ebp], xmm0

; 998  : 
; 999  :                 _mm_storeu_si128((__m128i *)(dst_ptr + 0), x0);

  0020a	0f 10 45 90	 movups	 xmm0, XMMWORD PTR _x0$29[ebp]
  0020e	8b 45 b4	 mov	 eax, DWORD PTR _dst_ptr$32[ebp]
  00211	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 1000 :             }

  00214	e9 4f ff ff ff	 jmp	 $LN5@convert_yv
$LN6@convert_yv:

; 1001 :         }

  00219	e9 06 ff ff ff	 jmp	 $LN2@convert_yv
$LN14@convert_yv:

; 1002 :     }
; 1003 :     //UV成分のコピー
; 1004 :     const auto uv_range = thread_y_range(crop_up >> 1, (height - crop_bottom) >> 1, thread_id, thread_n);

  0021e	8b 4b 2c	 mov	 ecx, DWORD PTR _thread_n$[ebx]
  00221	51		 push	 ecx
  00222	8b 53 28	 mov	 edx, DWORD PTR _thread_id$[ebx]
  00225	52		 push	 edx
  00226	8b 43 20	 mov	 eax, DWORD PTR _height$[ebx]
  00229	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  0022c	d1 f8		 sar	 eax, 1
  0022e	50		 push	 eax
  0022f	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  00232	d1 f9		 sar	 ecx, 1
  00234	51		 push	 ecx
  00235	8d 95 f0 fd ff
	ff		 lea	 edx, DWORD PTR $T1[ebp]
  0023b	52		 push	 edx
  0023c	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00241	83 c4 14	 add	 esp, 20			; 00000014H
  00244	8b 08		 mov	 ecx, DWORD PTR [eax]
  00246	89 8d 10 ff ff
	ff		 mov	 DWORD PTR $T22[ebp], ecx
  0024c	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0024f	89 95 14 ff ff
	ff		 mov	 DWORD PTR $T22[ebp+4], edx
  00255	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00258	89 85 18 ff ff
	ff		 mov	 DWORD PTR $T22[ebp+8], eax
  0025e	8b 8d 10 ff ff
	ff		 mov	 ecx, DWORD PTR $T22[ebp]
  00264	89 8d 20 ff ff
	ff		 mov	 DWORD PTR _uv_range$[ebp], ecx
  0026a	8b 95 14 ff ff
	ff		 mov	 edx, DWORD PTR $T22[ebp+4]
  00270	89 95 24 ff ff
	ff		 mov	 DWORD PTR _uv_range$[ebp+4], edx
  00276	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR $T22[ebp+8]
  0027c	89 85 28 ff ff
	ff		 mov	 DWORD PTR _uv_range$[ebp+8], eax

; 1005 :     const int src_uv_pitch = src_uv_pitch_byte >> 1;

  00282	8b 4b 18	 mov	 ecx, DWORD PTR _src_uv_pitch_byte$[ebx]
  00285	d1 f9		 sar	 ecx, 1
  00287	89 8d 0c ff ff
	ff		 mov	 DWORD PTR _src_uv_pitch$[ebp], ecx

; 1006 :     uint16_t *srcULine = (uint16_t *)src[1] + ((src_uv_pitch * uv_range.start_src) + (crop_left >> 1));

  0028d	ba 04 00 00 00	 mov	 edx, 4
  00292	c1 e2 00	 shl	 edx, 0
  00295	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  0029b	0f af 85 20 ff
	ff ff		 imul	 eax, DWORD PTR _uv_range$[ebp]
  002a2	8b 4d f8	 mov	 ecx, DWORD PTR _crop_left$[ebp]
  002a5	d1 f9		 sar	 ecx, 1
  002a7	03 c1		 add	 eax, ecx
  002a9	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  002ac	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  002af	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  002b2	89 85 08 ff ff
	ff		 mov	 DWORD PTR _srcULine$[ebp], eax

; 1007 :     uint16_t *srcVLine = (uint16_t *)src[2] + ((src_uv_pitch * uv_range.start_src) + (crop_left >> 1));

  002b8	b9 04 00 00 00	 mov	 ecx, 4
  002bd	d1 e1		 shl	 ecx, 1
  002bf	8b 95 0c ff ff
	ff		 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  002c5	0f af 95 20 ff
	ff ff		 imul	 edx, DWORD PTR _uv_range$[ebp]
  002cc	8b 45 f8	 mov	 eax, DWORD PTR _crop_left$[ebp]
  002cf	d1 f8		 sar	 eax, 1
  002d1	03 d0		 add	 edx, eax
  002d3	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  002d6	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  002d9	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  002dc	89 95 04 ff ff
	ff		 mov	 DWORD PTR _srcVLine$[ebp], edx

; 1008 :     uint8_t *dstLine  = (uint8_t *)dst[1] + dst_y_pitch_byte * uv_range.start_dst;

  002e2	b8 04 00 00 00	 mov	 eax, 4
  002e7	c1 e0 00	 shl	 eax, 0
  002ea	8b 4b 1c	 mov	 ecx, DWORD PTR _dst_y_pitch_byte$[ebx]
  002ed	0f af 8d 24 ff
	ff ff		 imul	 ecx, DWORD PTR _uv_range$[ebp+4]
  002f4	8b 53 08	 mov	 edx, DWORD PTR _dst$[ebx]
  002f7	03 0c 02	 add	 ecx, DWORD PTR [edx+eax]
  002fa	89 8d 00 ff ff
	ff		 mov	 DWORD PTR _dstLine$[ebp], ecx

; 1009 :     for (int y = 0; y < uv_range.len; y++, srcULine += src_uv_pitch, srcVLine += src_uv_pitch, dstLine += dst_y_pitch_byte) {

  00300	c7 85 fc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _y$21[ebp], 0
  0030a	eb 48		 jmp	 SHORT $LN10@convert_yv
$LN8@convert_yv:
  0030c	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR _y$21[ebp]
  00312	83 c0 01	 add	 eax, 1
  00315	89 85 fc fe ff
	ff		 mov	 DWORD PTR _y$21[ebp], eax
  0031b	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00321	8b 95 08 ff ff
	ff		 mov	 edx, DWORD PTR _srcULine$[ebp]
  00327	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  0032a	89 85 08 ff ff
	ff		 mov	 DWORD PTR _srcULine$[ebp], eax
  00330	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00336	8b 95 04 ff ff
	ff		 mov	 edx, DWORD PTR _srcVLine$[ebp]
  0033c	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  0033f	89 85 04 ff ff
	ff		 mov	 DWORD PTR _srcVLine$[ebp], eax
  00345	8b 8d 00 ff ff
	ff		 mov	 ecx, DWORD PTR _dstLine$[ebp]
  0034b	03 4b 1c	 add	 ecx, DWORD PTR _dst_y_pitch_byte$[ebx]
  0034e	89 8d 00 ff ff
	ff		 mov	 DWORD PTR _dstLine$[ebp], ecx
$LN10@convert_yv:
  00354	8b 95 fc fe ff
	ff		 mov	 edx, DWORD PTR _y$21[ebp]
  0035a	3b 95 28 ff ff
	ff		 cmp	 edx, DWORD PTR _uv_range$[ebp+8]
  00360	0f 8d ae 01 00
	00		 jge	 $LN1@convert_yv

; 1010 :         const int x_fin = width - crop_right;

  00366	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  00369	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  0036c	89 85 f8 fe ff
	ff		 mov	 DWORD PTR _x_fin$20[ebp], eax

; 1011 :         uint16_t *src_u_ptr = srcULine;

  00372	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR _srcULine$[ebp]
  00378	89 8d f4 fe ff
	ff		 mov	 DWORD PTR _src_u_ptr$19[ebp], ecx

; 1012 :         uint16_t *src_v_ptr = srcVLine;

  0037e	8b 95 04 ff ff
	ff		 mov	 edx, DWORD PTR _srcVLine$[ebp]
  00384	89 95 f0 fe ff
	ff		 mov	 DWORD PTR _src_v_ptr$18[ebp], edx

; 1013 :         uint8_t *dst_ptr = dstLine;

  0038a	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR _dstLine$[ebp]
  00390	89 85 ec fe ff
	ff		 mov	 DWORD PTR _dst_ptr$17[ebp], eax

; 1014 :         uint8_t *dst_ptr_fin = dst_ptr + x_fin;

  00396	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _dst_ptr$17[ebp]
  0039c	03 8d f8 fe ff
	ff		 add	 ecx, DWORD PTR _x_fin$20[ebp]
  003a2	89 8d e8 fe ff
	ff		 mov	 DWORD PTR _dst_ptr_fin$16[ebp], ecx

; 1015 :         __m128i x0, x1;
; 1016 :         for (; dst_ptr < dst_ptr_fin; src_u_ptr += 8, src_v_ptr += 8, dst_ptr += 16) {

  003a8	eb 2d		 jmp	 SHORT $LN13@convert_yv
$LN11@convert_yv:
  003aa	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR _src_u_ptr$19[ebp]
  003b0	83 c2 10	 add	 edx, 16			; 00000010H
  003b3	89 95 f4 fe ff
	ff		 mov	 DWORD PTR _src_u_ptr$19[ebp], edx
  003b9	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _src_v_ptr$18[ebp]
  003bf	83 c0 10	 add	 eax, 16			; 00000010H
  003c2	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _src_v_ptr$18[ebp], eax
  003c8	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _dst_ptr$17[ebp]
  003ce	83 c1 10	 add	 ecx, 16			; 00000010H
  003d1	89 8d ec fe ff
	ff		 mov	 DWORD PTR _dst_ptr$17[ebp], ecx
$LN13@convert_yv:
  003d7	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _dst_ptr$17[ebp]
  003dd	3b 95 e8 fe ff
	ff		 cmp	 edx, DWORD PTR _dst_ptr_fin$16[ebp]
  003e3	0f 83 26 01 00
	00		 jae	 $LN12@convert_yv

; 1017 :             x0 = _mm_loadu_si128((const __m128i *)src_u_ptr);

  003e9	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _src_u_ptr$19[ebp]
  003ef	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  003f2	0f 29 85 b0 fe
	ff ff		 movaps	 XMMWORD PTR $T13[ebp], xmm0
  003f9	0f 28 85 b0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T13[ebp]
  00400	0f 29 85 d0 fe
	ff ff		 movaps	 XMMWORD PTR _x0$15[ebp], xmm0

; 1018 :             x1 = _mm_loadu_si128((const __m128i *)src_v_ptr);

  00407	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR _src_v_ptr$18[ebp]
  0040d	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00410	0f 29 85 a0 fe
	ff ff		 movaps	 XMMWORD PTR $T12[ebp], xmm0
  00417	0f 28 85 a0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T12[ebp]
  0041e	0f 29 85 c0 fe
	ff ff		 movaps	 XMMWORD PTR _x1$14[ebp], xmm0

; 1019 : 
; 1020 :             x0 = _mm_srli_epi16(x0, in_bit_depth - 8);

  00425	0f 28 85 d0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _x0$15[ebp]
  0042c	66 0f 71 d0 08	 psrlw	 xmm0, 8
  00431	0f 29 85 90 fe
	ff ff		 movaps	 XMMWORD PTR $T11[ebp], xmm0
  00438	0f 28 85 90 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T11[ebp]
  0043f	0f 29 85 d0 fe
	ff ff		 movaps	 XMMWORD PTR _x0$15[ebp], xmm0

; 1021 :             x1 = _mm_slli_epi16(x1, 16 - in_bit_depth);

  00446	0f 28 85 c0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$14[ebp]
  0044d	66 0f 71 f0 00	 psllw	 xmm0, 0
  00452	0f 29 85 80 fe
	ff ff		 movaps	 XMMWORD PTR $T10[ebp], xmm0
  00459	0f 28 85 80 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T10[ebp]
  00460	0f 29 85 c0 fe
	ff ff		 movaps	 XMMWORD PTR _x1$14[ebp], xmm0

; 1022 :             const __m128i xMaskHighByte = _mm_slli_epi16(_mm_cmpeq_epi8(_mm_setzero_si128(), _mm_setzero_si128()), 8);

  00467	0f 57 c0	 xorps	 xmm0, xmm0
  0046a	0f 29 85 50 fe
	ff ff		 movaps	 XMMWORD PTR $T7[ebp], xmm0
  00471	0f 57 c0	 xorps	 xmm0, xmm0
  00474	0f 29 85 60 fe
	ff ff		 movaps	 XMMWORD PTR $T8[ebp], xmm0
  0047b	0f 28 85 60 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T8[ebp]
  00482	66 0f 74 85 50
	fe ff ff	 pcmpeqb xmm0, XMMWORD PTR $T7[ebp]
  0048a	0f 29 85 40 fe
	ff ff		 movaps	 XMMWORD PTR $T6[ebp], xmm0
  00491	0f 28 85 40 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T6[ebp]
  00498	66 0f 71 f0 08	 psllw	 xmm0, 8
  0049d	0f 29 85 30 fe
	ff ff		 movaps	 XMMWORD PTR $T5[ebp], xmm0
  004a4	0f 28 85 30 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T5[ebp]
  004ab	0f 29 85 70 fe
	ff ff		 movaps	 XMMWORD PTR _xMaskHighByte$9[ebp], xmm0

; 1023 :             x1 = _mm_and_si128(x1, xMaskHighByte);

  004b2	0f 28 85 c0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$14[ebp]
  004b9	66 0f db 85 70
	fe ff ff	 pand	 xmm0, XMMWORD PTR _xMaskHighByte$9[ebp]
  004c1	0f 29 85 20 fe
	ff ff		 movaps	 XMMWORD PTR $T4[ebp], xmm0
  004c8	0f 28 85 20 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T4[ebp]
  004cf	0f 29 85 c0 fe
	ff ff		 movaps	 XMMWORD PTR _x1$14[ebp], xmm0

; 1024 : 
; 1025 :             x0 = _mm_or_si128(x0, x1);

  004d6	0f 28 85 d0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _x0$15[ebp]
  004dd	66 0f eb 85 c0
	fe ff ff	 por	 xmm0, XMMWORD PTR _x1$14[ebp]
  004e5	0f 29 85 10 fe
	ff ff		 movaps	 XMMWORD PTR $T3[ebp], xmm0
  004ec	0f 28 85 10 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T3[ebp]
  004f3	0f 29 85 d0 fe
	ff ff		 movaps	 XMMWORD PTR _x0$15[ebp], xmm0

; 1026 : 
; 1027 :             _mm_storeu_si128((__m128i *)(dst_ptr +  0), x0);

  004fa	0f 10 85 d0 fe
	ff ff		 movups	 xmm0, XMMWORD PTR _x0$15[ebp]
  00501	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _dst_ptr$17[ebp]
  00507	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 1028 :         }

  0050a	e9 9b fe ff ff	 jmp	 $LN11@convert_yv
$LN12@convert_yv:

; 1029 :     }

  0050f	e9 f8 fd ff ff	 jmp	 $LN8@convert_yv
$LN1@convert_yv:

; 1030 : }

  00514	52		 push	 edx
  00515	8b cd		 mov	 ecx, ebp
  00517	50		 push	 eax
  00518	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN19@convert_yv
  0051e	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00523	58		 pop	 eax
  00524	5a		 pop	 edx
  00525	5f		 pop	 edi
  00526	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00529	33 cd		 xor	 ecx, ebp
  0052b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00530	8b e5		 mov	 esp, ebp
  00532	5d		 pop	 ebp
  00533	8b e3		 mov	 esp, ebx
  00535	5b		 pop	 ebx
  00536	c3		 ret	 0
  00537	90		 npad	 1
$LN19@convert_yv:
  00538	02 00 00 00	 DD	 2
  0053c	00 00 00 00	 DD	 $LN18@convert_yv
$LN18@convert_yv:
  00540	d8 ff ff ff	 DD	 -40			; ffffffd8H
  00544	0c 00 00 00	 DD	 12			; 0000000cH
  00548	00 00 00 00	 DD	 $LN16@convert_yv
  0054c	20 ff ff ff	 DD	 -224			; ffffff20H
  00550	0c 00 00 00	 DD	 12			; 0000000cH
  00554	00 00 00 00	 DD	 $LN17@convert_yv
$LN17@convert_yv:
  00558	75		 DB	 117			; 00000075H
  00559	76		 DB	 118			; 00000076H
  0055a	5f		 DB	 95			; 0000005fH
  0055b	72		 DB	 114			; 00000072H
  0055c	61		 DB	 97			; 00000061H
  0055d	6e		 DB	 110			; 0000006eH
  0055e	67		 DB	 103			; 00000067H
  0055f	65		 DB	 101			; 00000065H
  00560	00		 DB	 0
$LN16@convert_yv:
  00561	79		 DB	 121			; 00000079H
  00562	5f		 DB	 95			; 0000005fH
  00563	72		 DB	 114			; 00000072H
  00564	61		 DB	 97			; 00000061H
  00565	6e		 DB	 110			; 0000006eH
  00566	67		 DB	 103			; 00000067H
  00567	65		 DB	 101			; 00000065H
  00568	00		 DB	 0
??$convert_yv12_high_to_nv12_simd@$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_high_to_nv12_simd<16,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_sse2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yv12_16_to_nv12_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_16_to_nv12_sse2

; 105  : void convert_yv12_16_to_nv12_sse2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 106  :     convert_yv12_high_to_nv12_simd<16, false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yv12_high_to_nv12_simd@$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_high_to_nv12_simd<16,0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 107  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yv12_16_to_nv12_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_16_to_nv12_sse2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -752						; size = 12
$T2 = -736						; size = 12
$T3 = -720						; size = 16
$T4 = -704						; size = 16
$T5 = -688						; size = 16
$T6 = -672						; size = 16
$T7 = -656						; size = 16
$T8 = -640						; size = 16
$T9 = -624						; size = 16
$T10 = -608						; size = 16
$T11 = -592						; size = 16
$T12 = -576						; size = 16
$T13 = -560						; size = 16
$T14 = -544						; size = 16
$T15 = -528						; size = 16
$T16 = -512						; size = 16
$T17 = -496						; size = 16
$T18 = -480						; size = 16
$T19 = -464						; size = 16
$T20 = -448						; size = 16
$T21 = -432						; size = 16
$T22 = -416						; size = 16
_x3$23 = -400						; size = 16
_x2$24 = -384						; size = 16
_x1$25 = -368						; size = 16
_x0$26 = -352						; size = 16
_dst_ptr_fin$27 = -324					; size = 4
_dst_ptr$28 = -320					; size = 4
_src_v_ptr$29 = -316					; size = 4
_src_u_ptr$30 = -312					; size = 4
_x_fin$31 = -308					; size = 4
_y$32 = -304						; size = 4
_dstLine$ = -300					; size = 4
_srcVLine$ = -296					; size = 4
_srcULine$ = -292					; size = 4
$T33 = -288						; size = 12
_uv_range$ = -272					; size = 12
$T34 = -256						; size = 16
$T35 = -240						; size = 16
$T36 = -224						; size = 16
$T37 = -208						; size = 16
$T38 = -192						; size = 16
$T39 = -176						; size = 16
$T40 = -160						; size = 16
$T41 = -144						; size = 16
$T42 = -128						; size = 16
_x1$43 = -112						; size = 16
_x0$44 = -96						; size = 16
_src_ptr_fin$45 = -80					; size = 4
_src_ptr$46 = -76					; size = 4
_dst_ptr$47 = -72					; size = 4
_y$48 = -68						; size = 4
_y_width$49 = -64					; size = 4
_dstLine$50 = -60					; size = 4
_srcYLine$51 = -56					; size = 4
$T52 = -52						; size = 12
_y_range$53 = -36					; size = 12
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yv12_to_p010_simd@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_to_p010_simd<0>

; 908  : static void convert_yv12_to_p010_simd(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec f0 02 00
	00		 sub	 esp, 752		; 000002f0H
  0001c	57		 push	 edi
  0001d	8d bd 10 fd ff
	ff		 lea	 edi, DWORD PTR [ebp-752]
  00023	b9 bc 00 00 00	 mov	 ecx, 188		; 000000bcH
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 909  :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 910  :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 911  :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 912  :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 913  :     //Y成分のコピー
; 914  :     if (!uv_only) {

  0007c	ba 01 00 00 00	 mov	 edx, 1
  00081	85 d2		 test	 edx, edx
  00083	0f 84 c6 01 00
	00		 je	 $LN14@convert_yv

; 915  :         const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00089	8b 43 2c	 mov	 eax, DWORD PTR _thread_n$[ebx]
  0008c	50		 push	 eax
  0008d	8b 4b 28	 mov	 ecx, DWORD PTR _thread_id$[ebx]
  00090	51		 push	 ecx
  00091	8b 53 20	 mov	 edx, DWORD PTR _height$[ebx]
  00094	2b 55 ec	 sub	 edx, DWORD PTR _crop_bottom$[ebp]
  00097	52		 push	 edx
  00098	8b 45 f4	 mov	 eax, DWORD PTR _crop_up$[ebp]
  0009b	50		 push	 eax
  0009c	8d 8d 20 fd ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  000a2	51		 push	 ecx
  000a3	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  000a8	83 c4 14	 add	 esp, 20			; 00000014H
  000ab	8b 10		 mov	 edx, DWORD PTR [eax]
  000ad	89 55 cc	 mov	 DWORD PTR $T52[ebp], edx
  000b0	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000b3	89 4d d0	 mov	 DWORD PTR $T52[ebp+4], ecx
  000b6	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000b9	89 55 d4	 mov	 DWORD PTR $T52[ebp+8], edx
  000bc	8b 45 cc	 mov	 eax, DWORD PTR $T52[ebp]
  000bf	89 45 dc	 mov	 DWORD PTR _y_range$53[ebp], eax
  000c2	8b 4d d0	 mov	 ecx, DWORD PTR $T52[ebp+4]
  000c5	89 4d e0	 mov	 DWORD PTR _y_range$53[ebp+4], ecx
  000c8	8b 55 d4	 mov	 edx, DWORD PTR $T52[ebp+8]
  000cb	89 55 e4	 mov	 DWORD PTR _y_range$53[ebp+8], edx

; 916  :         uint8_t *srcYLine = (uint8_t *)src[0] + src_y_pitch_byte * y_range.start_src + crop_left;

  000ce	b8 04 00 00 00	 mov	 eax, 4
  000d3	6b c8 00	 imul	 ecx, eax, 0
  000d6	8b 53 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  000d9	0f af 55 dc	 imul	 edx, DWORD PTR _y_range$53[ebp]
  000dd	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  000e0	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  000e3	03 ca		 add	 ecx, edx
  000e5	03 4d f8	 add	 ecx, DWORD PTR _crop_left$[ebp]
  000e8	89 4d c8	 mov	 DWORD PTR _srcYLine$51[ebp], ecx

; 917  :         uint8_t *dstLine  = (uint8_t *)dst[0] + dst_y_pitch_byte * y_range.start_dst;

  000eb	ba 04 00 00 00	 mov	 edx, 4
  000f0	6b c2 00	 imul	 eax, edx, 0
  000f3	8b 4b 1c	 mov	 ecx, DWORD PTR _dst_y_pitch_byte$[ebx]
  000f6	0f af 4d e0	 imul	 ecx, DWORD PTR _y_range$53[ebp+4]
  000fa	8b 53 08	 mov	 edx, DWORD PTR _dst$[ebx]
  000fd	03 0c 02	 add	 ecx, DWORD PTR [edx+eax]
  00100	89 4d c4	 mov	 DWORD PTR _dstLine$50[ebp], ecx

; 918  :         const int y_width = width - crop_right - crop_left;

  00103	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  00106	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  00109	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  0010c	89 45 c0	 mov	 DWORD PTR _y_width$49[ebp], eax

; 919  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch_byte, dstLine += dst_y_pitch_byte) {

  0010f	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _y$48[ebp], 0
  00116	eb 1b		 jmp	 SHORT $LN4@convert_yv
$LN2@convert_yv:
  00118	8b 4d bc	 mov	 ecx, DWORD PTR _y$48[ebp]
  0011b	83 c1 01	 add	 ecx, 1
  0011e	89 4d bc	 mov	 DWORD PTR _y$48[ebp], ecx
  00121	8b 55 c8	 mov	 edx, DWORD PTR _srcYLine$51[ebp]
  00124	03 53 14	 add	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  00127	89 55 c8	 mov	 DWORD PTR _srcYLine$51[ebp], edx
  0012a	8b 45 c4	 mov	 eax, DWORD PTR _dstLine$50[ebp]
  0012d	03 43 1c	 add	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  00130	89 45 c4	 mov	 DWORD PTR _dstLine$50[ebp], eax
$LN4@convert_yv:
  00133	8b 4d bc	 mov	 ecx, DWORD PTR _y$48[ebp]
  00136	3b 4d e4	 cmp	 ecx, DWORD PTR _y_range$53[ebp+8]
  00139	0f 8d 10 01 00
	00		 jge	 $LN14@convert_yv

; 920  :             uint16_t *dst_ptr = (uint16_t *)dstLine;

  0013f	8b 55 c4	 mov	 edx, DWORD PTR _dstLine$50[ebp]
  00142	89 55 b8	 mov	 DWORD PTR _dst_ptr$47[ebp], edx

; 921  :             uint8_t *src_ptr = srcYLine;

  00145	8b 45 c8	 mov	 eax, DWORD PTR _srcYLine$51[ebp]
  00148	89 45 b4	 mov	 DWORD PTR _src_ptr$46[ebp], eax

; 922  :             uint8_t *src_ptr_fin = src_ptr + y_width;

  0014b	8b 4d b4	 mov	 ecx, DWORD PTR _src_ptr$46[ebp]
  0014e	03 4d c0	 add	 ecx, DWORD PTR _y_width$49[ebp]
  00151	89 4d b0	 mov	 DWORD PTR _src_ptr_fin$45[ebp], ecx

; 923  :             __m128i x0, x1;
; 924  :             for (; src_ptr < src_ptr_fin; dst_ptr += 16, src_ptr += 16) {

  00154	eb 12		 jmp	 SHORT $LN7@convert_yv
$LN5@convert_yv:
  00156	8b 55 b8	 mov	 edx, DWORD PTR _dst_ptr$47[ebp]
  00159	83 c2 20	 add	 edx, 32			; 00000020H
  0015c	89 55 b8	 mov	 DWORD PTR _dst_ptr$47[ebp], edx
  0015f	8b 45 b4	 mov	 eax, DWORD PTR _src_ptr$46[ebp]
  00162	83 c0 10	 add	 eax, 16			; 00000010H
  00165	89 45 b4	 mov	 DWORD PTR _src_ptr$46[ebp], eax
$LN7@convert_yv:
  00168	8b 4d b4	 mov	 ecx, DWORD PTR _src_ptr$46[ebp]
  0016b	3b 4d b0	 cmp	 ecx, DWORD PTR _src_ptr_fin$45[ebp]
  0016e	0f 83 d6 00 00
	00		 jae	 $LN6@convert_yv

; 925  :                 x1 = _mm_loadu_si128((const __m128i *)src_ptr);

  00174	8b 55 b4	 mov	 edx, DWORD PTR _src_ptr$46[ebp]
  00177	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  0017a	0f 29 45 80	 movaps	 XMMWORD PTR $T42[ebp], xmm0
  0017e	0f 28 45 80	 movaps	 xmm0, XMMWORD PTR $T42[ebp]
  00182	0f 29 45 90	 movaps	 XMMWORD PTR _x1$43[ebp], xmm0

; 926  :                 x0 = _mm_unpacklo_epi8(_mm_setzero_si128(), x1);

  00186	0f 57 c0	 xorps	 xmm0, xmm0
  00189	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR $T41[ebp], xmm0
  00190	0f 28 85 70 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T41[ebp]
  00197	66 0f 60 45 90	 punpcklbw xmm0, XMMWORD PTR _x1$43[ebp]
  0019c	0f 29 85 60 ff
	ff ff		 movaps	 XMMWORD PTR $T40[ebp], xmm0
  001a3	0f 28 85 60 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T40[ebp]
  001aa	0f 29 45 a0	 movaps	 XMMWORD PTR _x0$44[ebp], xmm0

; 927  :                 x1 = _mm_unpackhi_epi8(_mm_setzero_si128(), x1);

  001ae	0f 57 c0	 xorps	 xmm0, xmm0
  001b1	0f 29 85 50 ff
	ff ff		 movaps	 XMMWORD PTR $T39[ebp], xmm0
  001b8	0f 28 85 50 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T39[ebp]
  001bf	66 0f 68 45 90	 punpckhbw xmm0, XMMWORD PTR _x1$43[ebp]
  001c4	0f 29 85 40 ff
	ff ff		 movaps	 XMMWORD PTR $T38[ebp], xmm0
  001cb	0f 28 85 40 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T38[ebp]
  001d2	0f 29 45 90	 movaps	 XMMWORD PTR _x1$43[ebp], xmm0

; 928  :                 x0 = _mm_add_epi16(x0, _mm_set1_epi16(2 << 6));

  001d6	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@00800080008000800080008000800080
  001dd	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR $T37[ebp], xmm0
  001e4	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _x0$44[ebp]
  001e8	66 0f fd 85 30
	ff ff ff	 paddw	 xmm0, XMMWORD PTR $T37[ebp]
  001f0	0f 29 85 20 ff
	ff ff		 movaps	 XMMWORD PTR $T36[ebp], xmm0
  001f7	0f 28 85 20 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T36[ebp]
  001fe	0f 29 45 a0	 movaps	 XMMWORD PTR _x0$44[ebp], xmm0

; 929  :                 x1 = _mm_add_epi16(x1, _mm_set1_epi16(2 << 6));

  00202	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@00800080008000800080008000800080
  00209	0f 29 85 10 ff
	ff ff		 movaps	 XMMWORD PTR $T35[ebp], xmm0
  00210	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR _x1$43[ebp]
  00214	66 0f fd 85 10
	ff ff ff	 paddw	 xmm0, XMMWORD PTR $T35[ebp]
  0021c	0f 29 85 00 ff
	ff ff		 movaps	 XMMWORD PTR $T34[ebp], xmm0
  00223	0f 28 85 00 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T34[ebp]
  0022a	0f 29 45 90	 movaps	 XMMWORD PTR _x1$43[ebp], xmm0

; 930  :                 _mm_storeu_si128((__m128i *)(dst_ptr + 0), x0);

  0022e	0f 10 45 a0	 movups	 xmm0, XMMWORD PTR _x0$44[ebp]
  00232	8b 45 b8	 mov	 eax, DWORD PTR _dst_ptr$47[ebp]
  00235	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 931  :                 _mm_storeu_si128((__m128i *)(dst_ptr + 8), x1);

  00238	0f 10 45 90	 movups	 xmm0, XMMWORD PTR _x1$43[ebp]
  0023c	8b 4d b8	 mov	 ecx, DWORD PTR _dst_ptr$47[ebp]
  0023f	83 c1 10	 add	 ecx, 16			; 00000010H
  00242	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 932  :             }

  00245	e9 0c ff ff ff	 jmp	 $LN5@convert_yv
$LN6@convert_yv:

; 933  :         }

  0024a	e9 c9 fe ff ff	 jmp	 $LN2@convert_yv
$LN14@convert_yv:

; 934  :     }
; 935  :     //UV成分のコピー
; 936  :     const auto uv_range = thread_y_range(crop_up >> 1, (height - crop_bottom) >> 1, thread_id, thread_n);

  0024f	8b 53 2c	 mov	 edx, DWORD PTR _thread_n$[ebx]
  00252	52		 push	 edx
  00253	8b 43 28	 mov	 eax, DWORD PTR _thread_id$[ebx]
  00256	50		 push	 eax
  00257	8b 4b 20	 mov	 ecx, DWORD PTR _height$[ebx]
  0025a	2b 4d ec	 sub	 ecx, DWORD PTR _crop_bottom$[ebp]
  0025d	d1 f9		 sar	 ecx, 1
  0025f	51		 push	 ecx
  00260	8b 55 f4	 mov	 edx, DWORD PTR _crop_up$[ebp]
  00263	d1 fa		 sar	 edx, 1
  00265	52		 push	 edx
  00266	8d 85 10 fd ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  0026c	50		 push	 eax
  0026d	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00272	83 c4 14	 add	 esp, 20			; 00000014H
  00275	8b 08		 mov	 ecx, DWORD PTR [eax]
  00277	89 8d e0 fe ff
	ff		 mov	 DWORD PTR $T33[ebp], ecx
  0027d	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00280	89 95 e4 fe ff
	ff		 mov	 DWORD PTR $T33[ebp+4], edx
  00286	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00289	89 85 e8 fe ff
	ff		 mov	 DWORD PTR $T33[ebp+8], eax
  0028f	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR $T33[ebp]
  00295	89 8d f0 fe ff
	ff		 mov	 DWORD PTR _uv_range$[ebp], ecx
  0029b	8b 95 e4 fe ff
	ff		 mov	 edx, DWORD PTR $T33[ebp+4]
  002a1	89 95 f4 fe ff
	ff		 mov	 DWORD PTR _uv_range$[ebp+4], edx
  002a7	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR $T33[ebp+8]
  002ad	89 85 f8 fe ff
	ff		 mov	 DWORD PTR _uv_range$[ebp+8], eax

; 937  :     uint8_t *srcULine = (uint8_t *)src[1] + ((src_uv_pitch_byte * uv_range.start_src) + (crop_left >> 1));

  002b3	b9 04 00 00 00	 mov	 ecx, 4
  002b8	c1 e1 00	 shl	 ecx, 0
  002bb	8b 53 18	 mov	 edx, DWORD PTR _src_uv_pitch_byte$[ebx]
  002be	0f af 95 f0 fe
	ff ff		 imul	 edx, DWORD PTR _uv_range$[ebp]
  002c5	8b 45 f8	 mov	 eax, DWORD PTR _crop_left$[ebp]
  002c8	d1 f8		 sar	 eax, 1
  002ca	03 d0		 add	 edx, eax
  002cc	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  002cf	03 14 08	 add	 edx, DWORD PTR [eax+ecx]
  002d2	89 95 dc fe ff
	ff		 mov	 DWORD PTR _srcULine$[ebp], edx

; 938  :     uint8_t *srcVLine = (uint8_t *)src[2] + ((src_uv_pitch_byte * uv_range.start_src) + (crop_left >> 1));

  002d8	b9 04 00 00 00	 mov	 ecx, 4
  002dd	d1 e1		 shl	 ecx, 1
  002df	8b 53 18	 mov	 edx, DWORD PTR _src_uv_pitch_byte$[ebx]
  002e2	0f af 95 f0 fe
	ff ff		 imul	 edx, DWORD PTR _uv_range$[ebp]
  002e9	8b 45 f8	 mov	 eax, DWORD PTR _crop_left$[ebp]
  002ec	d1 f8		 sar	 eax, 1
  002ee	03 d0		 add	 edx, eax
  002f0	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  002f3	03 14 08	 add	 edx, DWORD PTR [eax+ecx]
  002f6	89 95 d8 fe ff
	ff		 mov	 DWORD PTR _srcVLine$[ebp], edx

; 939  :     uint8_t *dstLine  = (uint8_t *)dst[1] + dst_y_pitch_byte * uv_range.start_dst;

  002fc	b9 04 00 00 00	 mov	 ecx, 4
  00301	c1 e1 00	 shl	 ecx, 0
  00304	8b 53 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebx]
  00307	0f af 95 f4 fe
	ff ff		 imul	 edx, DWORD PTR _uv_range$[ebp+4]
  0030e	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  00311	03 14 08	 add	 edx, DWORD PTR [eax+ecx]
  00314	89 95 d4 fe ff
	ff		 mov	 DWORD PTR _dstLine$[ebp], edx

; 940  :     for (int y = 0; y < uv_range.len; y++, srcULine += src_uv_pitch_byte, srcVLine += src_uv_pitch_byte, dstLine += dst_y_pitch_byte) {

  0031a	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _y$32[ebp], 0
  00324	eb 3c		 jmp	 SHORT $LN10@convert_yv
$LN8@convert_yv:
  00326	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR _y$32[ebp]
  0032c	83 c1 01	 add	 ecx, 1
  0032f	89 8d d0 fe ff
	ff		 mov	 DWORD PTR _y$32[ebp], ecx
  00335	8b 95 dc fe ff
	ff		 mov	 edx, DWORD PTR _srcULine$[ebp]
  0033b	03 53 18	 add	 edx, DWORD PTR _src_uv_pitch_byte$[ebx]
  0033e	89 95 dc fe ff
	ff		 mov	 DWORD PTR _srcULine$[ebp], edx
  00344	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _srcVLine$[ebp]
  0034a	03 43 18	 add	 eax, DWORD PTR _src_uv_pitch_byte$[ebx]
  0034d	89 85 d8 fe ff
	ff		 mov	 DWORD PTR _srcVLine$[ebp], eax
  00353	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR _dstLine$[ebp]
  00359	03 4b 1c	 add	 ecx, DWORD PTR _dst_y_pitch_byte$[ebx]
  0035c	89 8d d4 fe ff
	ff		 mov	 DWORD PTR _dstLine$[ebp], ecx
$LN10@convert_yv:
  00362	8b 95 d0 fe ff
	ff		 mov	 edx, DWORD PTR _y$32[ebp]
  00368	3b 95 f8 fe ff
	ff		 cmp	 edx, DWORD PTR _uv_range$[ebp+8]
  0036e	0f 8d dd 02 00
	00		 jge	 $LN1@convert_yv

; 941  :         const int x_fin = width - crop_right;

  00374	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  00377	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  0037a	89 85 cc fe ff
	ff		 mov	 DWORD PTR _x_fin$31[ebp], eax

; 942  :         uint8_t *src_u_ptr = srcULine;

  00380	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR _srcULine$[ebp]
  00386	89 8d c8 fe ff
	ff		 mov	 DWORD PTR _src_u_ptr$30[ebp], ecx

; 943  :         uint8_t *src_v_ptr = srcVLine;

  0038c	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR _srcVLine$[ebp]
  00392	89 95 c4 fe ff
	ff		 mov	 DWORD PTR _src_v_ptr$29[ebp], edx

; 944  :         uint16_t *dst_ptr = (uint16_t *)dstLine;

  00398	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR _dstLine$[ebp]
  0039e	89 85 c0 fe ff
	ff		 mov	 DWORD PTR _dst_ptr$28[ebp], eax

; 945  :         uint16_t *dst_ptr_fin = dst_ptr + x_fin;

  003a4	8b 8d cc fe ff
	ff		 mov	 ecx, DWORD PTR _x_fin$31[ebp]
  003aa	8b 95 c0 fe ff
	ff		 mov	 edx, DWORD PTR _dst_ptr$28[ebp]
  003b0	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  003b3	89 85 bc fe ff
	ff		 mov	 DWORD PTR _dst_ptr_fin$27[ebp], eax

; 946  :         __m128i x0, x1, x2, x3;
; 947  :         for (; dst_ptr < dst_ptr_fin; src_u_ptr += 16, src_v_ptr += 16, dst_ptr += 32) {

  003b9	eb 2d		 jmp	 SHORT $LN13@convert_yv
$LN11@convert_yv:
  003bb	8b 8d c8 fe ff
	ff		 mov	 ecx, DWORD PTR _src_u_ptr$30[ebp]
  003c1	83 c1 10	 add	 ecx, 16			; 00000010H
  003c4	89 8d c8 fe ff
	ff		 mov	 DWORD PTR _src_u_ptr$30[ebp], ecx
  003ca	8b 95 c4 fe ff
	ff		 mov	 edx, DWORD PTR _src_v_ptr$29[ebp]
  003d0	83 c2 10	 add	 edx, 16			; 00000010H
  003d3	89 95 c4 fe ff
	ff		 mov	 DWORD PTR _src_v_ptr$29[ebp], edx
  003d9	8b 85 c0 fe ff
	ff		 mov	 eax, DWORD PTR _dst_ptr$28[ebp]
  003df	83 c0 40	 add	 eax, 64			; 00000040H
  003e2	89 85 c0 fe ff
	ff		 mov	 DWORD PTR _dst_ptr$28[ebp], eax
$LN13@convert_yv:
  003e8	8b 8d c0 fe ff
	ff		 mov	 ecx, DWORD PTR _dst_ptr$28[ebp]
  003ee	3b 8d bc fe ff
	ff		 cmp	 ecx, DWORD PTR _dst_ptr_fin$27[ebp]
  003f4	0f 83 52 02 00
	00		 jae	 $LN12@convert_yv

; 948  :             x0 = _mm_loadu_si128((const __m128i *)src_u_ptr);

  003fa	8b 95 c8 fe ff
	ff		 mov	 edx, DWORD PTR _src_u_ptr$30[ebp]
  00400	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  00403	0f 29 85 60 fe
	ff ff		 movaps	 XMMWORD PTR $T22[ebp], xmm0
  0040a	0f 28 85 60 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T22[ebp]
  00411	0f 29 85 a0 fe
	ff ff		 movaps	 XMMWORD PTR _x0$26[ebp], xmm0

; 949  :             x2 = _mm_loadu_si128((const __m128i *)src_v_ptr);

  00418	8b 85 c4 fe ff
	ff		 mov	 eax, DWORD PTR _src_v_ptr$29[ebp]
  0041e	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00421	0f 29 85 50 fe
	ff ff		 movaps	 XMMWORD PTR $T21[ebp], xmm0
  00428	0f 28 85 50 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T21[ebp]
  0042f	0f 29 85 80 fe
	ff ff		 movaps	 XMMWORD PTR _x2$24[ebp], xmm0

; 950  :             x1 = _mm_unpacklo_epi8(x0, x2);

  00436	0f 28 85 a0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _x0$26[ebp]
  0043d	66 0f 60 85 80
	fe ff ff	 punpcklbw xmm0, XMMWORD PTR _x2$24[ebp]
  00445	0f 29 85 40 fe
	ff ff		 movaps	 XMMWORD PTR $T20[ebp], xmm0
  0044c	0f 28 85 40 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T20[ebp]
  00453	0f 29 85 90 fe
	ff ff		 movaps	 XMMWORD PTR _x1$25[ebp], xmm0

; 951  :             x3 = _mm_unpackhi_epi8(x0, x2);

  0045a	0f 28 85 a0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _x0$26[ebp]
  00461	66 0f 68 85 80
	fe ff ff	 punpckhbw xmm0, XMMWORD PTR _x2$24[ebp]
  00469	0f 29 85 30 fe
	ff ff		 movaps	 XMMWORD PTR $T19[ebp], xmm0
  00470	0f 28 85 30 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T19[ebp]
  00477	0f 29 85 70 fe
	ff ff		 movaps	 XMMWORD PTR _x3$23[ebp], xmm0

; 952  : 
; 953  :             x0 = _mm_unpacklo_epi8(_mm_setzero_si128(), x1);

  0047e	0f 57 c0	 xorps	 xmm0, xmm0
  00481	0f 29 85 20 fe
	ff ff		 movaps	 XMMWORD PTR $T18[ebp], xmm0
  00488	0f 28 85 20 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T18[ebp]
  0048f	66 0f 60 85 90
	fe ff ff	 punpcklbw xmm0, XMMWORD PTR _x1$25[ebp]
  00497	0f 29 85 10 fe
	ff ff		 movaps	 XMMWORD PTR $T17[ebp], xmm0
  0049e	0f 28 85 10 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T17[ebp]
  004a5	0f 29 85 a0 fe
	ff ff		 movaps	 XMMWORD PTR _x0$26[ebp], xmm0

; 954  :             x1 = _mm_unpackhi_epi8(_mm_setzero_si128(), x1);

  004ac	0f 57 c0	 xorps	 xmm0, xmm0
  004af	0f 29 85 00 fe
	ff ff		 movaps	 XMMWORD PTR $T16[ebp], xmm0
  004b6	0f 28 85 00 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T16[ebp]
  004bd	66 0f 68 85 90
	fe ff ff	 punpckhbw xmm0, XMMWORD PTR _x1$25[ebp]
  004c5	0f 29 85 f0 fd
	ff ff		 movaps	 XMMWORD PTR $T15[ebp], xmm0
  004cc	0f 28 85 f0 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T15[ebp]
  004d3	0f 29 85 90 fe
	ff ff		 movaps	 XMMWORD PTR _x1$25[ebp], xmm0

; 955  :             x0 = _mm_add_epi16(x0, _mm_set1_epi16(2 << 6));

  004da	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@00800080008000800080008000800080
  004e1	0f 29 85 e0 fd
	ff ff		 movaps	 XMMWORD PTR $T14[ebp], xmm0
  004e8	0f 28 85 a0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _x0$26[ebp]
  004ef	66 0f fd 85 e0
	fd ff ff	 paddw	 xmm0, XMMWORD PTR $T14[ebp]
  004f7	0f 29 85 d0 fd
	ff ff		 movaps	 XMMWORD PTR $T13[ebp], xmm0
  004fe	0f 28 85 d0 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T13[ebp]
  00505	0f 29 85 a0 fe
	ff ff		 movaps	 XMMWORD PTR _x0$26[ebp], xmm0

; 956  :             x1 = _mm_add_epi16(x1, _mm_set1_epi16(2 << 6));

  0050c	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@00800080008000800080008000800080
  00513	0f 29 85 c0 fd
	ff ff		 movaps	 XMMWORD PTR $T12[ebp], xmm0
  0051a	0f 28 85 90 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$25[ebp]
  00521	66 0f fd 85 c0
	fd ff ff	 paddw	 xmm0, XMMWORD PTR $T12[ebp]
  00529	0f 29 85 b0 fd
	ff ff		 movaps	 XMMWORD PTR $T11[ebp], xmm0
  00530	0f 28 85 b0 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T11[ebp]
  00537	0f 29 85 90 fe
	ff ff		 movaps	 XMMWORD PTR _x1$25[ebp], xmm0

; 957  : 
; 958  :             x2 = _mm_unpacklo_epi8(_mm_setzero_si128(), x3);

  0053e	0f 57 c0	 xorps	 xmm0, xmm0
  00541	0f 29 85 a0 fd
	ff ff		 movaps	 XMMWORD PTR $T10[ebp], xmm0
  00548	0f 28 85 a0 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T10[ebp]
  0054f	66 0f 60 85 70
	fe ff ff	 punpcklbw xmm0, XMMWORD PTR _x3$23[ebp]
  00557	0f 29 85 90 fd
	ff ff		 movaps	 XMMWORD PTR $T9[ebp], xmm0
  0055e	0f 28 85 90 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T9[ebp]
  00565	0f 29 85 80 fe
	ff ff		 movaps	 XMMWORD PTR _x2$24[ebp], xmm0

; 959  :             x3 = _mm_unpackhi_epi8(_mm_setzero_si128(), x3);

  0056c	0f 57 c0	 xorps	 xmm0, xmm0
  0056f	0f 29 85 80 fd
	ff ff		 movaps	 XMMWORD PTR $T8[ebp], xmm0
  00576	0f 28 85 80 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T8[ebp]
  0057d	66 0f 68 85 70
	fe ff ff	 punpckhbw xmm0, XMMWORD PTR _x3$23[ebp]
  00585	0f 29 85 70 fd
	ff ff		 movaps	 XMMWORD PTR $T7[ebp], xmm0
  0058c	0f 28 85 70 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T7[ebp]
  00593	0f 29 85 70 fe
	ff ff		 movaps	 XMMWORD PTR _x3$23[ebp], xmm0

; 960  :             x2 = _mm_add_epi16(x2, _mm_set1_epi16(2 << 6));

  0059a	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@00800080008000800080008000800080
  005a1	0f 29 85 60 fd
	ff ff		 movaps	 XMMWORD PTR $T6[ebp], xmm0
  005a8	0f 28 85 80 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _x2$24[ebp]
  005af	66 0f fd 85 60
	fd ff ff	 paddw	 xmm0, XMMWORD PTR $T6[ebp]
  005b7	0f 29 85 50 fd
	ff ff		 movaps	 XMMWORD PTR $T5[ebp], xmm0
  005be	0f 28 85 50 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T5[ebp]
  005c5	0f 29 85 80 fe
	ff ff		 movaps	 XMMWORD PTR _x2$24[ebp], xmm0

; 961  :             x3 = _mm_add_epi16(x3, _mm_set1_epi16(2 << 6));

  005cc	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@00800080008000800080008000800080
  005d3	0f 29 85 40 fd
	ff ff		 movaps	 XMMWORD PTR $T4[ebp], xmm0
  005da	0f 28 85 70 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _x3$23[ebp]
  005e1	66 0f fd 85 40
	fd ff ff	 paddw	 xmm0, XMMWORD PTR $T4[ebp]
  005e9	0f 29 85 30 fd
	ff ff		 movaps	 XMMWORD PTR $T3[ebp], xmm0
  005f0	0f 28 85 30 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T3[ebp]
  005f7	0f 29 85 70 fe
	ff ff		 movaps	 XMMWORD PTR _x3$23[ebp], xmm0

; 962  : 
; 963  :             _mm_storeu_si128((__m128i *)(dst_ptr +  0), x0);

  005fe	0f 10 85 a0 fe
	ff ff		 movups	 xmm0, XMMWORD PTR _x0$26[ebp]
  00605	8b 8d c0 fe ff
	ff		 mov	 ecx, DWORD PTR _dst_ptr$28[ebp]
  0060b	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 964  :             _mm_storeu_si128((__m128i *)(dst_ptr +  8), x1);

  0060e	0f 10 85 90 fe
	ff ff		 movups	 xmm0, XMMWORD PTR _x1$25[ebp]
  00615	8b 95 c0 fe ff
	ff		 mov	 edx, DWORD PTR _dst_ptr$28[ebp]
  0061b	83 c2 10	 add	 edx, 16			; 00000010H
  0061e	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 965  :             _mm_storeu_si128((__m128i *)(dst_ptr + 16), x2);

  00621	0f 10 85 80 fe
	ff ff		 movups	 xmm0, XMMWORD PTR _x2$24[ebp]
  00628	8b 85 c0 fe ff
	ff		 mov	 eax, DWORD PTR _dst_ptr$28[ebp]
  0062e	83 c0 20	 add	 eax, 32			; 00000020H
  00631	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 966  :             _mm_storeu_si128((__m128i *)(dst_ptr + 24), x3);

  00634	0f 10 85 70 fe
	ff ff		 movups	 xmm0, XMMWORD PTR _x3$23[ebp]
  0063b	8b 8d c0 fe ff
	ff		 mov	 ecx, DWORD PTR _dst_ptr$28[ebp]
  00641	83 c1 30	 add	 ecx, 48			; 00000030H
  00644	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 967  :         }

  00647	e9 6f fd ff ff	 jmp	 $LN11@convert_yv
$LN12@convert_yv:

; 968  :     }

  0064c	e9 d5 fc ff ff	 jmp	 $LN8@convert_yv
$LN1@convert_yv:

; 969  : }

  00651	52		 push	 edx
  00652	8b cd		 mov	 ecx, ebp
  00654	50		 push	 eax
  00655	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN19@convert_yv
  0065b	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00660	58		 pop	 eax
  00661	5a		 pop	 edx
  00662	5f		 pop	 edi
  00663	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00666	33 cd		 xor	 ecx, ebp
  00668	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0066d	8b e5		 mov	 esp, ebp
  0066f	5d		 pop	 ebp
  00670	8b e3		 mov	 esp, ebx
  00672	5b		 pop	 ebx
  00673	c3		 ret	 0
$LN19@convert_yv:
  00674	02 00 00 00	 DD	 2
  00678	00 00 00 00	 DD	 $LN18@convert_yv
$LN18@convert_yv:
  0067c	dc ff ff ff	 DD	 -36			; ffffffdcH
  00680	0c 00 00 00	 DD	 12			; 0000000cH
  00684	00 00 00 00	 DD	 $LN16@convert_yv
  00688	f0 fe ff ff	 DD	 -272			; fffffef0H
  0068c	0c 00 00 00	 DD	 12			; 0000000cH
  00690	00 00 00 00	 DD	 $LN17@convert_yv
$LN17@convert_yv:
  00694	75		 DB	 117			; 00000075H
  00695	76		 DB	 118			; 00000076H
  00696	5f		 DB	 95			; 0000005fH
  00697	72		 DB	 114			; 00000072H
  00698	61		 DB	 97			; 00000061H
  00699	6e		 DB	 110			; 0000006eH
  0069a	67		 DB	 103			; 00000067H
  0069b	65		 DB	 101			; 00000065H
  0069c	00		 DB	 0
$LN16@convert_yv:
  0069d	79		 DB	 121			; 00000079H
  0069e	5f		 DB	 95			; 0000005fH
  0069f	72		 DB	 114			; 00000072H
  006a0	61		 DB	 97			; 00000061H
  006a1	6e		 DB	 110			; 0000006eH
  006a2	67		 DB	 103			; 00000067H
  006a3	65		 DB	 101			; 00000065H
  006a4	00		 DB	 0
??$convert_yv12_to_p010_simd@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_to_p010_simd<0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_sse2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yv12_to_p010_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_to_p010_sse2

; 101  : void convert_yv12_to_p010_sse2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 102  :     convert_yv12_to_p010_simd<false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yv12_to_p010_simd@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_to_p010_simd<0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 103  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yv12_to_p010_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_to_p010_sse2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
;	COMDAT ??$copy_rgb_to_rgb@$0PPABAAAC@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
_TEXT	SEGMENT
$T1 = -84						; size = 12
_y$2 = -72						; size = 4
_y_width$3 = -68					; size = 4
_dstLine$4 = -64					; size = 4
_srcYLine$5 = -60					; size = 4
_i$6 = -56						; size = 4
$T7 = -52						; size = 12
_y_range$ = -36						; size = 12
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$copy_rgb_to_rgb@$0PPABAAAC@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; copy_rgb_to_rgb<4278255618>, COMDAT

; 891  : void copy_rgb_to_rgb(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	57		 push	 edi
  00007	8d 7d ac	 lea	 edi, DWORD PTR [ebp-84]
  0000a	b9 15 00 00 00	 mov	 ecx, 21			; 00000015H
  0000f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00014	f3 ab		 rep stosd
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 892  :     const int crop_left   = crop[0];

  00020	b8 04 00 00 00	 mov	 eax, 4
  00025	6b c8 00	 imul	 ecx, eax, 0
  00028	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  0002b	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0002e	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 893  :     const int crop_up     = crop[1];

  00031	b9 04 00 00 00	 mov	 ecx, 4
  00036	c1 e1 00	 shl	 ecx, 0
  00039	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  0003c	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0003f	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 894  :     const int crop_right  = crop[2];

  00042	b9 04 00 00 00	 mov	 ecx, 4
  00047	d1 e1		 shl	 ecx, 1
  00049	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  0004c	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0004f	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 895  :     const int crop_bottom = crop[3];

  00052	b9 04 00 00 00	 mov	 ecx, 4
  00057	6b d1 03	 imul	 edx, ecx, 3
  0005a	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  0005d	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00060	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 896  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00063	8b 55 2c	 mov	 edx, DWORD PTR _thread_n$[ebp]
  00066	52		 push	 edx
  00067	8b 45 28	 mov	 eax, DWORD PTR _thread_id$[ebp]
  0006a	50		 push	 eax
  0006b	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  0006e	2b 4d ec	 sub	 ecx, DWORD PTR _crop_bottom$[ebp]
  00071	51		 push	 ecx
  00072	8b 55 f4	 mov	 edx, DWORD PTR _crop_up$[ebp]
  00075	52		 push	 edx
  00076	8d 45 ac	 lea	 eax, DWORD PTR $T1[ebp]
  00079	50		 push	 eax
  0007a	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  0007f	83 c4 14	 add	 esp, 20			; 00000014H
  00082	8b 08		 mov	 ecx, DWORD PTR [eax]
  00084	89 4d cc	 mov	 DWORD PTR $T7[ebp], ecx
  00087	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0008a	89 55 d0	 mov	 DWORD PTR $T7[ebp+4], edx
  0008d	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00090	89 45 d4	 mov	 DWORD PTR $T7[ebp+8], eax
  00093	8b 4d cc	 mov	 ecx, DWORD PTR $T7[ebp]
  00096	89 4d dc	 mov	 DWORD PTR _y_range$[ebp], ecx
  00099	8b 55 d0	 mov	 edx, DWORD PTR $T7[ebp+4]
  0009c	89 55 e0	 mov	 DWORD PTR _y_range$[ebp+4], edx
  0009f	8b 45 d4	 mov	 eax, DWORD PTR $T7[ebp+8]
  000a2	89 45 e4	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 897  :     for (int i = 0; i < 3; i++) {

  000a5	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _i$6[ebp], 0
  000ac	eb 09		 jmp	 SHORT $LN4@copy_rgb_t
$LN2@copy_rgb_t:
  000ae	8b 4d c8	 mov	 ecx, DWORD PTR _i$6[ebp]
  000b1	83 c1 01	 add	 ecx, 1
  000b4	89 4d c8	 mov	 DWORD PTR _i$6[ebp], ecx
$LN4@copy_rgb_t:
  000b7	83 7d c8 03	 cmp	 DWORD PTR _i$6[ebp], 3
  000bb	0f 8d 8e 00 00
	00		 jge	 $LN1@copy_rgb_t

; 898  :         uint8_t *srcYLine = (uint8_t *)src[(plane_from >> (i*8)) & 0xff] + src_y_pitch_byte * y_range.start_src + crop_left;

  000c1	8b 4d c8	 mov	 ecx, DWORD PTR _i$6[ebp]
  000c4	c1 e1 03	 shl	 ecx, 3
  000c7	ba 02 00 01 ff	 mov	 edx, -16711678		; ff010002H
  000cc	d3 ea		 shr	 edx, cl
  000ce	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  000d4	8b 45 14	 mov	 eax, DWORD PTR _src_y_pitch_byte$[ebp]
  000d7	0f af 45 dc	 imul	 eax, DWORD PTR _y_range$[ebp]
  000db	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  000de	8b 14 91	 mov	 edx, DWORD PTR [ecx+edx*4]
  000e1	03 d0		 add	 edx, eax
  000e3	03 55 f8	 add	 edx, DWORD PTR _crop_left$[ebp]
  000e6	89 55 c4	 mov	 DWORD PTR _srcYLine$5[ebp], edx

; 899  :         uint8_t *dstLine = (uint8_t *)dst[i] + dst_y_pitch_byte * y_range.start_dst;

  000e9	8b 45 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  000ec	0f af 45 e0	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  000f0	8b 4d c8	 mov	 ecx, DWORD PTR _i$6[ebp]
  000f3	8b 55 08	 mov	 edx, DWORD PTR _dst$[ebp]
  000f6	03 04 8a	 add	 eax, DWORD PTR [edx+ecx*4]
  000f9	89 45 c0	 mov	 DWORD PTR _dstLine$4[ebp], eax

; 900  :         const int y_width = width - crop_right - crop_left;

  000fc	8b 45 10	 mov	 eax, DWORD PTR _width$[ebp]
  000ff	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  00102	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  00105	89 45 bc	 mov	 DWORD PTR _y_width$3[ebp], eax

; 901  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch_byte, dstLine += dst_y_pitch_byte) {

  00108	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _y$2[ebp], 0
  0010f	eb 1b		 jmp	 SHORT $LN7@copy_rgb_t
$LN5@copy_rgb_t:
  00111	8b 4d b8	 mov	 ecx, DWORD PTR _y$2[ebp]
  00114	83 c1 01	 add	 ecx, 1
  00117	89 4d b8	 mov	 DWORD PTR _y$2[ebp], ecx
  0011a	8b 55 c4	 mov	 edx, DWORD PTR _srcYLine$5[ebp]
  0011d	03 55 14	 add	 edx, DWORD PTR _src_y_pitch_byte$[ebp]
  00120	89 55 c4	 mov	 DWORD PTR _srcYLine$5[ebp], edx
  00123	8b 45 c0	 mov	 eax, DWORD PTR _dstLine$4[ebp]
  00126	03 45 1c	 add	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  00129	89 45 c0	 mov	 DWORD PTR _dstLine$4[ebp], eax
$LN7@copy_rgb_t:
  0012c	8b 4d b8	 mov	 ecx, DWORD PTR _y$2[ebp]
  0012f	3b 4d e4	 cmp	 ecx, DWORD PTR _y_range$[ebp+8]
  00132	7d 16		 jge	 SHORT $LN6@copy_rgb_t

; 902  :             memcpy_sse(dstLine, srcYLine, y_width);

  00134	8b 55 bc	 mov	 edx, DWORD PTR _y_width$3[ebp]
  00137	52		 push	 edx
  00138	8b 45 c4	 mov	 eax, DWORD PTR _srcYLine$5[ebp]
  0013b	50		 push	 eax
  0013c	8b 4d c0	 mov	 ecx, DWORD PTR _dstLine$4[ebp]
  0013f	51		 push	 ecx
  00140	e8 00 00 00 00	 call	 ?memcpy_sse@@YAXPAEPBEH@Z ; memcpy_sse
  00145	83 c4 0c	 add	 esp, 12			; 0000000cH

; 903  :         }

  00148	eb c7		 jmp	 SHORT $LN5@copy_rgb_t
$LN6@copy_rgb_t:

; 904  :     }

  0014a	e9 5f ff ff ff	 jmp	 $LN2@copy_rgb_t
$LN1@copy_rgb_t:

; 905  : }

  0014f	52		 push	 edx
  00150	8b cd		 mov	 ecx, ebp
  00152	50		 push	 eax
  00153	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN11@copy_rgb_t
  00159	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0015e	58		 pop	 eax
  0015f	5a		 pop	 edx
  00160	5f		 pop	 edi
  00161	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00164	33 cd		 xor	 ecx, ebp
  00166	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0016b	83 c4 54	 add	 esp, 84			; 00000054H
  0016e	3b ec		 cmp	 ebp, esp
  00170	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00175	8b e5		 mov	 esp, ebp
  00177	5d		 pop	 ebp
  00178	c3		 ret	 0
  00179	0f 1f 00	 npad	 3
$LN11@copy_rgb_t:
  0017c	01 00 00 00	 DD	 1
  00180	00 00 00 00	 DD	 $LN10@copy_rgb_t
$LN10@copy_rgb_t:
  00184	dc ff ff ff	 DD	 -36			; ffffffdcH
  00188	0c 00 00 00	 DD	 12			; 0000000cH
  0018c	00 00 00 00	 DD	 $LN9@copy_rgb_t
$LN9@copy_rgb_t:
  00190	79		 DB	 121			; 00000079H
  00191	5f		 DB	 95			; 0000005fH
  00192	72		 DB	 114			; 00000072H
  00193	61		 DB	 97			; 00000061H
  00194	6e		 DB	 110			; 0000006eH
  00195	67		 DB	 103			; 00000067H
  00196	65		 DB	 101			; 00000065H
  00197	00		 DB	 0
??$copy_rgb_to_rgb@$0PPABAAAC@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; copy_rgb_to_rgb<4278255618>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_sse2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?copy_gbr_to_rgb_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC	; copy_gbr_to_rgb_sse2

; 97   : void copy_gbr_to_rgb_sse2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 98   :     copy_rgb_to_rgb<RGB_PLANE(2, 0, 1, -1)>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$copy_rgb_to_rgb@$0PPABAAAC@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; copy_rgb_to_rgb<4278255618>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 99   : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?copy_gbr_to_rgb_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP	; copy_gbr_to_rgb_sse2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
;	COMDAT ??$copy_rgb_to_rgb@$0PPACABAA@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
_TEXT	SEGMENT
$T1 = -84						; size = 12
_y$2 = -72						; size = 4
_y_width$3 = -68					; size = 4
_dstLine$4 = -64					; size = 4
_srcYLine$5 = -60					; size = 4
_i$6 = -56						; size = 4
$T7 = -52						; size = 12
_y_range$ = -36						; size = 12
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$copy_rgb_to_rgb@$0PPACABAA@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; copy_rgb_to_rgb<4278321408>, COMDAT

; 891  : void copy_rgb_to_rgb(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	57		 push	 edi
  00007	8d 7d ac	 lea	 edi, DWORD PTR [ebp-84]
  0000a	b9 15 00 00 00	 mov	 ecx, 21			; 00000015H
  0000f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00014	f3 ab		 rep stosd
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 892  :     const int crop_left   = crop[0];

  00020	b8 04 00 00 00	 mov	 eax, 4
  00025	6b c8 00	 imul	 ecx, eax, 0
  00028	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  0002b	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0002e	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 893  :     const int crop_up     = crop[1];

  00031	b9 04 00 00 00	 mov	 ecx, 4
  00036	c1 e1 00	 shl	 ecx, 0
  00039	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  0003c	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0003f	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 894  :     const int crop_right  = crop[2];

  00042	b9 04 00 00 00	 mov	 ecx, 4
  00047	d1 e1		 shl	 ecx, 1
  00049	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  0004c	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0004f	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 895  :     const int crop_bottom = crop[3];

  00052	b9 04 00 00 00	 mov	 ecx, 4
  00057	6b d1 03	 imul	 edx, ecx, 3
  0005a	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  0005d	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00060	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 896  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00063	8b 55 2c	 mov	 edx, DWORD PTR _thread_n$[ebp]
  00066	52		 push	 edx
  00067	8b 45 28	 mov	 eax, DWORD PTR _thread_id$[ebp]
  0006a	50		 push	 eax
  0006b	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  0006e	2b 4d ec	 sub	 ecx, DWORD PTR _crop_bottom$[ebp]
  00071	51		 push	 ecx
  00072	8b 55 f4	 mov	 edx, DWORD PTR _crop_up$[ebp]
  00075	52		 push	 edx
  00076	8d 45 ac	 lea	 eax, DWORD PTR $T1[ebp]
  00079	50		 push	 eax
  0007a	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  0007f	83 c4 14	 add	 esp, 20			; 00000014H
  00082	8b 08		 mov	 ecx, DWORD PTR [eax]
  00084	89 4d cc	 mov	 DWORD PTR $T7[ebp], ecx
  00087	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0008a	89 55 d0	 mov	 DWORD PTR $T7[ebp+4], edx
  0008d	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00090	89 45 d4	 mov	 DWORD PTR $T7[ebp+8], eax
  00093	8b 4d cc	 mov	 ecx, DWORD PTR $T7[ebp]
  00096	89 4d dc	 mov	 DWORD PTR _y_range$[ebp], ecx
  00099	8b 55 d0	 mov	 edx, DWORD PTR $T7[ebp+4]
  0009c	89 55 e0	 mov	 DWORD PTR _y_range$[ebp+4], edx
  0009f	8b 45 d4	 mov	 eax, DWORD PTR $T7[ebp+8]
  000a2	89 45 e4	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 897  :     for (int i = 0; i < 3; i++) {

  000a5	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _i$6[ebp], 0
  000ac	eb 09		 jmp	 SHORT $LN4@copy_rgb_t
$LN2@copy_rgb_t:
  000ae	8b 4d c8	 mov	 ecx, DWORD PTR _i$6[ebp]
  000b1	83 c1 01	 add	 ecx, 1
  000b4	89 4d c8	 mov	 DWORD PTR _i$6[ebp], ecx
$LN4@copy_rgb_t:
  000b7	83 7d c8 03	 cmp	 DWORD PTR _i$6[ebp], 3
  000bb	0f 8d 8e 00 00
	00		 jge	 $LN1@copy_rgb_t

; 898  :         uint8_t *srcYLine = (uint8_t *)src[(plane_from >> (i*8)) & 0xff] + src_y_pitch_byte * y_range.start_src + crop_left;

  000c1	8b 4d c8	 mov	 ecx, DWORD PTR _i$6[ebp]
  000c4	c1 e1 03	 shl	 ecx, 3
  000c7	ba 00 01 02 ff	 mov	 edx, -16645888		; ff020100H
  000cc	d3 ea		 shr	 edx, cl
  000ce	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  000d4	8b 45 14	 mov	 eax, DWORD PTR _src_y_pitch_byte$[ebp]
  000d7	0f af 45 dc	 imul	 eax, DWORD PTR _y_range$[ebp]
  000db	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  000de	8b 14 91	 mov	 edx, DWORD PTR [ecx+edx*4]
  000e1	03 d0		 add	 edx, eax
  000e3	03 55 f8	 add	 edx, DWORD PTR _crop_left$[ebp]
  000e6	89 55 c4	 mov	 DWORD PTR _srcYLine$5[ebp], edx

; 899  :         uint8_t *dstLine = (uint8_t *)dst[i] + dst_y_pitch_byte * y_range.start_dst;

  000e9	8b 45 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  000ec	0f af 45 e0	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  000f0	8b 4d c8	 mov	 ecx, DWORD PTR _i$6[ebp]
  000f3	8b 55 08	 mov	 edx, DWORD PTR _dst$[ebp]
  000f6	03 04 8a	 add	 eax, DWORD PTR [edx+ecx*4]
  000f9	89 45 c0	 mov	 DWORD PTR _dstLine$4[ebp], eax

; 900  :         const int y_width = width - crop_right - crop_left;

  000fc	8b 45 10	 mov	 eax, DWORD PTR _width$[ebp]
  000ff	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  00102	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  00105	89 45 bc	 mov	 DWORD PTR _y_width$3[ebp], eax

; 901  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch_byte, dstLine += dst_y_pitch_byte) {

  00108	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _y$2[ebp], 0
  0010f	eb 1b		 jmp	 SHORT $LN7@copy_rgb_t
$LN5@copy_rgb_t:
  00111	8b 4d b8	 mov	 ecx, DWORD PTR _y$2[ebp]
  00114	83 c1 01	 add	 ecx, 1
  00117	89 4d b8	 mov	 DWORD PTR _y$2[ebp], ecx
  0011a	8b 55 c4	 mov	 edx, DWORD PTR _srcYLine$5[ebp]
  0011d	03 55 14	 add	 edx, DWORD PTR _src_y_pitch_byte$[ebp]
  00120	89 55 c4	 mov	 DWORD PTR _srcYLine$5[ebp], edx
  00123	8b 45 c0	 mov	 eax, DWORD PTR _dstLine$4[ebp]
  00126	03 45 1c	 add	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  00129	89 45 c0	 mov	 DWORD PTR _dstLine$4[ebp], eax
$LN7@copy_rgb_t:
  0012c	8b 4d b8	 mov	 ecx, DWORD PTR _y$2[ebp]
  0012f	3b 4d e4	 cmp	 ecx, DWORD PTR _y_range$[ebp+8]
  00132	7d 16		 jge	 SHORT $LN6@copy_rgb_t

; 902  :             memcpy_sse(dstLine, srcYLine, y_width);

  00134	8b 55 bc	 mov	 edx, DWORD PTR _y_width$3[ebp]
  00137	52		 push	 edx
  00138	8b 45 c4	 mov	 eax, DWORD PTR _srcYLine$5[ebp]
  0013b	50		 push	 eax
  0013c	8b 4d c0	 mov	 ecx, DWORD PTR _dstLine$4[ebp]
  0013f	51		 push	 ecx
  00140	e8 00 00 00 00	 call	 ?memcpy_sse@@YAXPAEPBEH@Z ; memcpy_sse
  00145	83 c4 0c	 add	 esp, 12			; 0000000cH

; 903  :         }

  00148	eb c7		 jmp	 SHORT $LN5@copy_rgb_t
$LN6@copy_rgb_t:

; 904  :     }

  0014a	e9 5f ff ff ff	 jmp	 $LN2@copy_rgb_t
$LN1@copy_rgb_t:

; 905  : }

  0014f	52		 push	 edx
  00150	8b cd		 mov	 ecx, ebp
  00152	50		 push	 eax
  00153	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN11@copy_rgb_t
  00159	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0015e	58		 pop	 eax
  0015f	5a		 pop	 edx
  00160	5f		 pop	 edi
  00161	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00164	33 cd		 xor	 ecx, ebp
  00166	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0016b	83 c4 54	 add	 esp, 84			; 00000054H
  0016e	3b ec		 cmp	 ebp, esp
  00170	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00175	8b e5		 mov	 esp, ebp
  00177	5d		 pop	 ebp
  00178	c3		 ret	 0
  00179	0f 1f 00	 npad	 3
$LN11@copy_rgb_t:
  0017c	01 00 00 00	 DD	 1
  00180	00 00 00 00	 DD	 $LN10@copy_rgb_t
$LN10@copy_rgb_t:
  00184	dc ff ff ff	 DD	 -36			; ffffffdcH
  00188	0c 00 00 00	 DD	 12			; 0000000cH
  0018c	00 00 00 00	 DD	 $LN9@copy_rgb_t
$LN9@copy_rgb_t:
  00190	79		 DB	 121			; 00000079H
  00191	5f		 DB	 95			; 0000005fH
  00192	72		 DB	 114			; 00000072H
  00193	61		 DB	 97			; 00000061H
  00194	6e		 DB	 110			; 0000006eH
  00195	67		 DB	 103			; 00000067H
  00196	65		 DB	 101			; 00000065H
  00197	00		 DB	 0
??$copy_rgb_to_rgb@$0PPACABAA@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; copy_rgb_to_rgb<4278321408>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_sse2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?copy_rgb_to_rgb_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC	; copy_rgb_to_rgb_sse2

; 93   : void copy_rgb_to_rgb_sse2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 94   :     copy_rgb_to_rgb<RGB_PLANE(0, 1, 2, -1)>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$copy_rgb_to_rgb@$0PPACABAA@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; copy_rgb_to_rgb<4278321408>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 95   : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?copy_rgb_to_rgb_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP	; copy_rgb_to_rgb_sse2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_sse2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_rgb32r_to_rgb32_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_rgb32r_to_rgb32_sse2

; 89   : void convert_rgb32r_to_rgb32_sse2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 90   :     convert_rgb32r_to_rgb32_simd(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ?convert_rgb32r_to_rgb32_simd@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_rgb32r_to_rgb32_simd
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 91   : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_rgb32r_to_rgb32_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_rgb32r_to_rgb32_sse2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_sse2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_rgb24r_to_rgb24_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_rgb24r_to_rgb24_sse2

; 85   : void convert_rgb24r_to_rgb24_sse2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 86   :     convert_rgb24r_to_rgb24_simd(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ?convert_rgb24r_to_rgb24_simd@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_rgb24r_to_rgb24_simd
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 87   : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_rgb24r_to_rgb24_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_rgb24r_to_rgb24_sse2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
;	COMDAT ??$convert_rgb32_to_rgb32_simd@$0BN@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
_TEXT	SEGMENT
$T1 = -80						; size = 12
_y$2 = -68						; size = 4
_x_width$ = -64						; size = 4
_dstLine$ = -60						; size = 4
_srcLine$ = -56						; size = 4
$T3 = -52						; size = 12
_y_range$ = -36						; size = 12
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_rgb32_to_rgb32_simd@$0BN@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_rgb32_to_rgb32_simd<29>, COMDAT

; 829  : void convert_rgb32_to_rgb32_simd(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	57		 push	 edi
  00007	8d 7d b0	 lea	 edi, DWORD PTR [ebp-80]
  0000a	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  0000f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00014	f3 ab		 rep stosd
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 830  :     const int crop_left   = crop[0];

  00020	b8 04 00 00 00	 mov	 eax, 4
  00025	6b c8 00	 imul	 ecx, eax, 0
  00028	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  0002b	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0002e	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 831  :     const int crop_up     = crop[1];

  00031	b9 04 00 00 00	 mov	 ecx, 4
  00036	c1 e1 00	 shl	 ecx, 0
  00039	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  0003c	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0003f	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 832  :     const int crop_right  = crop[2];

  00042	b9 04 00 00 00	 mov	 ecx, 4
  00047	d1 e1		 shl	 ecx, 1
  00049	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  0004c	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0004f	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 833  :     const int crop_bottom = crop[3];

  00052	b9 04 00 00 00	 mov	 ecx, 4
  00057	6b d1 03	 imul	 edx, ecx, 3
  0005a	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  0005d	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00060	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 834  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00063	8b 55 2c	 mov	 edx, DWORD PTR _thread_n$[ebp]
  00066	52		 push	 edx
  00067	8b 45 28	 mov	 eax, DWORD PTR _thread_id$[ebp]
  0006a	50		 push	 eax
  0006b	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  0006e	2b 4d ec	 sub	 ecx, DWORD PTR _crop_bottom$[ebp]
  00071	51		 push	 ecx
  00072	8b 55 f4	 mov	 edx, DWORD PTR _crop_up$[ebp]
  00075	52		 push	 edx
  00076	8d 45 b0	 lea	 eax, DWORD PTR $T1[ebp]
  00079	50		 push	 eax
  0007a	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  0007f	83 c4 14	 add	 esp, 20			; 00000014H
  00082	8b 08		 mov	 ecx, DWORD PTR [eax]
  00084	89 4d cc	 mov	 DWORD PTR $T3[ebp], ecx
  00087	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0008a	89 55 d0	 mov	 DWORD PTR $T3[ebp+4], edx
  0008d	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00090	89 45 d4	 mov	 DWORD PTR $T3[ebp+8], eax
  00093	8b 4d cc	 mov	 ecx, DWORD PTR $T3[ebp]
  00096	89 4d dc	 mov	 DWORD PTR _y_range$[ebp], ecx
  00099	8b 55 d0	 mov	 edx, DWORD PTR $T3[ebp+4]
  0009c	89 55 e0	 mov	 DWORD PTR _y_range$[ebp+4], edx
  0009f	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp+8]
  000a2	89 45 e4	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 835  :     uint8_t *srcLine = (uint8_t *)src[0] + src_y_pitch_byte * y_range.start_src + crop_left * 4;

  000a5	b9 04 00 00 00	 mov	 ecx, 4
  000aa	6b d1 00	 imul	 edx, ecx, 0
  000ad	8b 45 14	 mov	 eax, DWORD PTR _src_y_pitch_byte$[ebp]
  000b0	0f af 45 dc	 imul	 eax, DWORD PTR _y_range$[ebp]
  000b4	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  000b7	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  000ba	03 d0		 add	 edx, eax
  000bc	8b 45 f8	 mov	 eax, DWORD PTR _crop_left$[ebp]
  000bf	8d 0c 82	 lea	 ecx, DWORD PTR [edx+eax*4]
  000c2	89 4d c8	 mov	 DWORD PTR _srcLine$[ebp], ecx

; 836  :     uint8_t *dstLine = (uint8_t *)dst[0] + dst_y_pitch_byte * y_range.start_dst;

  000c5	ba 04 00 00 00	 mov	 edx, 4
  000ca	6b c2 00	 imul	 eax, edx, 0
  000cd	8b 4d 1c	 mov	 ecx, DWORD PTR _dst_y_pitch_byte$[ebp]
  000d0	0f af 4d e0	 imul	 ecx, DWORD PTR _y_range$[ebp+4]
  000d4	8b 55 08	 mov	 edx, DWORD PTR _dst$[ebp]
  000d7	03 0c 02	 add	 ecx, DWORD PTR [edx+eax]
  000da	89 4d c4	 mov	 DWORD PTR _dstLine$[ebp], ecx

; 837  :     const int x_width = width - crop_right - crop_left;

  000dd	8b 45 10	 mov	 eax, DWORD PTR _width$[ebp]
  000e0	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  000e3	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  000e6	89 45 c0	 mov	 DWORD PTR _x_width$[ebp], eax

; 838  :     if (csp_from == RGY_CSP_RGB24) {

  000e9	33 c9		 xor	 ecx, ecx
  000eb	74 45		 je	 SHORT $LN1@convert_rg

; 839  :     for (int y = 0; y < y_range.len; y++, dstLine += dst_y_pitch_byte, srcLine += src_y_pitch_byte) {

  000ed	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _y$2[ebp], 0
  000f4	eb 1b		 jmp	 SHORT $LN4@convert_rg
$LN2@convert_rg:
  000f6	8b 55 bc	 mov	 edx, DWORD PTR _y$2[ebp]
  000f9	83 c2 01	 add	 edx, 1
  000fc	89 55 bc	 mov	 DWORD PTR _y$2[ebp], edx
  000ff	8b 45 c4	 mov	 eax, DWORD PTR _dstLine$[ebp]
  00102	03 45 1c	 add	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  00105	89 45 c4	 mov	 DWORD PTR _dstLine$[ebp], eax
  00108	8b 4d c8	 mov	 ecx, DWORD PTR _srcLine$[ebp]
  0010b	03 4d 14	 add	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  0010e	89 4d c8	 mov	 DWORD PTR _srcLine$[ebp], ecx
$LN4@convert_rg:
  00111	8b 55 bc	 mov	 edx, DWORD PTR _y$2[ebp]
  00114	3b 55 e4	 cmp	 edx, DWORD PTR _y_range$[ebp+8]
  00117	7d 19		 jge	 SHORT $LN1@convert_rg

; 840  :         memcpy_sse(dstLine, srcLine, x_width * 4);

  00119	8b 45 c0	 mov	 eax, DWORD PTR _x_width$[ebp]
  0011c	c1 e0 02	 shl	 eax, 2
  0011f	50		 push	 eax
  00120	8b 4d c8	 mov	 ecx, DWORD PTR _srcLine$[ebp]
  00123	51		 push	 ecx
  00124	8b 55 c4	 mov	 edx, DWORD PTR _dstLine$[ebp]
  00127	52		 push	 edx
  00128	e8 00 00 00 00	 call	 ?memcpy_sse@@YAXPAEPBEH@Z ; memcpy_sse
  0012d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 841  :     }

  00130	eb c4		 jmp	 SHORT $LN2@convert_rg
$LN1@convert_rg:

; 842  :     } else {
; 843  : #if USE_SSSE3
; 844  :         static_assert(csp_from == RGY_CSP_BGR32 || csp_from == RGY_CSP_RGB32, "invalid csp");
; 845  :         alignas(16) const char MASK_BGR4_TO_RGB4[] = { 2, 1, 0, 3, 6, 5, 4, 7, 10, 9, 8, 11, 14, 13, 12, 15 };
; 846  :         alignas(16) const char MASK_GBR4_TO_RGB4[] = { 2, 0, 1, 3, 6, 4, 5, 7, 10, 8, 9, 11, 14, 12, 13, 15 };
; 847  :         const char *mask = nullptr;
; 848  :         switch (csp_from) {
; 849  :         //case RGY_CSP_GBR32: mask = MASK_GBR4_TO_RGB4; break;
; 850  :         case RGY_CSP_BGR32:
; 851  :         default:            mask = MASK_BGR4_TO_RGB4; break;
; 852  :         }
; 853  :         for (int y = 0; y < y_range.len; y++, dstLine += dst_y_pitch_byte, srcLine += src_y_pitch_byte) {
; 854  :             uint8_t *ptr_dst = dstLine;
; 855  :             uint8_t *ptr_src = srcLine;
; 856  :             for (int x = 0; x < x_width - 4; x += 4, ptr_dst += 16, ptr_src += 16) {
; 857  :                 __m128i src0 = _mm_loadu_si128((const __m128i *)(ptr_src +  0));
; 858  :                 __m128i x0 = _mm_shuffle_epi8(src0, _mm_load_si128((__m128i *)(mask +  0)));
; 859  :                 _mm_storeu_si128((__m128i *)(ptr_dst +  0), x0);
; 860  :             }
; 861  :             if (x_width % 4) {
; 862  :                 int x_offest = 4 - (x_width % 4);
; 863  :                 ptr_dst -= x_offest * 4;
; 864  :                 ptr_src -= x_offest * 4;
; 865  :             }
; 866  :             __m128i src0 = _mm_loadu_si128((const __m128i *)(ptr_src +  0));
; 867  :             __m128i x0 = _mm_shuffle_epi8(src0, _mm_load_si128((__m128i *)(mask +  0)));
; 868  :             _mm_storeu_si128((__m128i *)(ptr_dst +  0), x0);
; 869  :         }
; 870  : #else
; 871  :         static_assert(csp_from == RGY_CSP_RGB32, "invalid csp");
; 872  : #endif
; 873  :     }
; 874  : }

  00132	52		 push	 edx
  00133	8b cd		 mov	 ecx, ebp
  00135	50		 push	 eax
  00136	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN10@convert_rg
  0013c	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00141	58		 pop	 eax
  00142	5a		 pop	 edx
  00143	5f		 pop	 edi
  00144	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00147	33 cd		 xor	 ecx, ebp
  00149	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0014e	83 c4 50	 add	 esp, 80			; 00000050H
  00151	3b ec		 cmp	 ebp, esp
  00153	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00158	8b e5		 mov	 esp, ebp
  0015a	5d		 pop	 ebp
  0015b	c3		 ret	 0
$LN10@convert_rg:
  0015c	01 00 00 00	 DD	 1
  00160	00 00 00 00	 DD	 $LN9@convert_rg
$LN9@convert_rg:
  00164	dc ff ff ff	 DD	 -36			; ffffffdcH
  00168	0c 00 00 00	 DD	 12			; 0000000cH
  0016c	00 00 00 00	 DD	 $LN8@convert_rg
$LN8@convert_rg:
  00170	79		 DB	 121			; 00000079H
  00171	5f		 DB	 95			; 0000005fH
  00172	72		 DB	 114			; 00000072H
  00173	61		 DB	 97			; 00000061H
  00174	6e		 DB	 110			; 0000006eH
  00175	67		 DB	 103			; 00000067H
  00176	65		 DB	 101			; 00000065H
  00177	00		 DB	 0
??$convert_rgb32_to_rgb32_simd@$0BN@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_rgb32_to_rgb32_simd<29>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_sse2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_rgb32_to_rgb32_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_rgb32_to_rgb32_sse2

; 81   : void convert_rgb32_to_rgb32_sse2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 82   :     convert_rgb32_to_rgb32_simd<RGY_CSP_RGB32>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_rgb32_to_rgb32_simd@$0BN@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_rgb32_to_rgb32_simd<29>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 83   : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_rgb32_to_rgb32_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_rgb32_to_rgb32_sse2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
;	COMDAT ??$convert_rgb24_to_rgb24_simd@$0BM@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
_TEXT	SEGMENT
$T1 = -80						; size = 12
_y$2 = -68						; size = 4
_x_width$ = -64						; size = 4
_dstLine$ = -60						; size = 4
_srcLine$ = -56						; size = 4
$T3 = -52						; size = 12
_y_range$ = -36						; size = 12
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_rgb24_to_rgb24_simd@$0BM@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_rgb24_to_rgb24_simd<28>, COMDAT

; 741  : void convert_rgb24_to_rgb24_simd(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	57		 push	 edi
  00007	8d 7d b0	 lea	 edi, DWORD PTR [ebp-80]
  0000a	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  0000f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00014	f3 ab		 rep stosd
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 742  :     const int crop_left   = crop[0];

  00020	b8 04 00 00 00	 mov	 eax, 4
  00025	6b c8 00	 imul	 ecx, eax, 0
  00028	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  0002b	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0002e	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 743  :     const int crop_up     = crop[1];

  00031	b9 04 00 00 00	 mov	 ecx, 4
  00036	c1 e1 00	 shl	 ecx, 0
  00039	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  0003c	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0003f	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 744  :     const int crop_right  = crop[2];

  00042	b9 04 00 00 00	 mov	 ecx, 4
  00047	d1 e1		 shl	 ecx, 1
  00049	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  0004c	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0004f	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 745  :     const int crop_bottom = crop[3];

  00052	b9 04 00 00 00	 mov	 ecx, 4
  00057	6b d1 03	 imul	 edx, ecx, 3
  0005a	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  0005d	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00060	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 746  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00063	8b 55 2c	 mov	 edx, DWORD PTR _thread_n$[ebp]
  00066	52		 push	 edx
  00067	8b 45 28	 mov	 eax, DWORD PTR _thread_id$[ebp]
  0006a	50		 push	 eax
  0006b	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  0006e	2b 4d ec	 sub	 ecx, DWORD PTR _crop_bottom$[ebp]
  00071	51		 push	 ecx
  00072	8b 55 f4	 mov	 edx, DWORD PTR _crop_up$[ebp]
  00075	52		 push	 edx
  00076	8d 45 b0	 lea	 eax, DWORD PTR $T1[ebp]
  00079	50		 push	 eax
  0007a	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  0007f	83 c4 14	 add	 esp, 20			; 00000014H
  00082	8b 08		 mov	 ecx, DWORD PTR [eax]
  00084	89 4d cc	 mov	 DWORD PTR $T3[ebp], ecx
  00087	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0008a	89 55 d0	 mov	 DWORD PTR $T3[ebp+4], edx
  0008d	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00090	89 45 d4	 mov	 DWORD PTR $T3[ebp+8], eax
  00093	8b 4d cc	 mov	 ecx, DWORD PTR $T3[ebp]
  00096	89 4d dc	 mov	 DWORD PTR _y_range$[ebp], ecx
  00099	8b 55 d0	 mov	 edx, DWORD PTR $T3[ebp+4]
  0009c	89 55 e0	 mov	 DWORD PTR _y_range$[ebp+4], edx
  0009f	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp+8]
  000a2	89 45 e4	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 747  :     uint8_t *srcLine = (uint8_t *)src[0] + src_y_pitch_byte * y_range.start_src + crop_left * 3;

  000a5	b9 04 00 00 00	 mov	 ecx, 4
  000aa	6b d1 00	 imul	 edx, ecx, 0
  000ad	8b 45 14	 mov	 eax, DWORD PTR _src_y_pitch_byte$[ebp]
  000b0	0f af 45 dc	 imul	 eax, DWORD PTR _y_range$[ebp]
  000b4	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  000b7	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  000ba	03 d0		 add	 edx, eax
  000bc	6b 45 f8 03	 imul	 eax, DWORD PTR _crop_left$[ebp], 3
  000c0	03 d0		 add	 edx, eax
  000c2	89 55 c8	 mov	 DWORD PTR _srcLine$[ebp], edx

; 748  :     uint8_t *dstLine = (uint8_t *)dst[0] + dst_y_pitch_byte * y_range.start_dst;

  000c5	b9 04 00 00 00	 mov	 ecx, 4
  000ca	6b d1 00	 imul	 edx, ecx, 0
  000cd	8b 45 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  000d0	0f af 45 e0	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  000d4	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  000d7	03 04 11	 add	 eax, DWORD PTR [ecx+edx]
  000da	89 45 c4	 mov	 DWORD PTR _dstLine$[ebp], eax

; 749  :     const int x_width = width - crop_right - crop_left;

  000dd	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  000e0	2b 55 f0	 sub	 edx, DWORD PTR _crop_right$[ebp]
  000e3	2b 55 f8	 sub	 edx, DWORD PTR _crop_left$[ebp]
  000e6	89 55 c0	 mov	 DWORD PTR _x_width$[ebp], edx

; 750  :     if (csp_from == RGY_CSP_RGB24) {

  000e9	b8 01 00 00 00	 mov	 eax, 1
  000ee	85 c0		 test	 eax, eax
  000f0	74 43		 je	 SHORT $LN1@convert_rg

; 751  :         for (int y = 0; y < y_range.len; y++, dstLine += dst_y_pitch_byte, srcLine += src_y_pitch_byte) {

  000f2	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _y$2[ebp], 0
  000f9	eb 1b		 jmp	 SHORT $LN4@convert_rg
$LN2@convert_rg:
  000fb	8b 4d bc	 mov	 ecx, DWORD PTR _y$2[ebp]
  000fe	83 c1 01	 add	 ecx, 1
  00101	89 4d bc	 mov	 DWORD PTR _y$2[ebp], ecx
  00104	8b 55 c4	 mov	 edx, DWORD PTR _dstLine$[ebp]
  00107	03 55 1c	 add	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0010a	89 55 c4	 mov	 DWORD PTR _dstLine$[ebp], edx
  0010d	8b 45 c8	 mov	 eax, DWORD PTR _srcLine$[ebp]
  00110	03 45 14	 add	 eax, DWORD PTR _src_y_pitch_byte$[ebp]
  00113	89 45 c8	 mov	 DWORD PTR _srcLine$[ebp], eax
$LN4@convert_rg:
  00116	8b 4d bc	 mov	 ecx, DWORD PTR _y$2[ebp]
  00119	3b 4d e4	 cmp	 ecx, DWORD PTR _y_range$[ebp+8]
  0011c	7d 17		 jge	 SHORT $LN1@convert_rg

; 752  :             memcpy_sse(dstLine, srcLine, x_width * 3);

  0011e	6b 55 c0 03	 imul	 edx, DWORD PTR _x_width$[ebp], 3
  00122	52		 push	 edx
  00123	8b 45 c8	 mov	 eax, DWORD PTR _srcLine$[ebp]
  00126	50		 push	 eax
  00127	8b 4d c4	 mov	 ecx, DWORD PTR _dstLine$[ebp]
  0012a	51		 push	 ecx
  0012b	e8 00 00 00 00	 call	 ?memcpy_sse@@YAXPAEPBEH@Z ; memcpy_sse
  00130	83 c4 0c	 add	 esp, 12			; 0000000cH

; 753  :         }

  00133	eb c6		 jmp	 SHORT $LN2@convert_rg
$LN1@convert_rg:

; 754  :     } else {
; 755  : #if USE_SSSE3
; 756  :         static_assert(csp_from == RGY_CSP_BGR24 || csp_from == RGY_CSP_RGB24, "invalid csp");
; 757  :         alignas(16) const char MASK_BGR3_TO_RGB3[] = {
; 758  :              2,  1,  0,  5,  4,  3,  8,  7,  6, 11, 10,  9, 14, 13, 12, -1, //[0]->[0]
; 759  :             -1, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, //[0]->[1]
; 760  :             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  1, //[1]->[0]
; 761  :              0, -1,  4,  3,  2,  7,  6,  5, 10,  9,  8, 13, 12, 11, -1, 15, //[1]->[1]
; 762  :             14, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, //[1]->[2]
; 763  :             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  0, -1, //[2]->[1]
; 764  :             -1,  3,  2,  1,  6,  5,  4,  9,  8,  7, 12, 11, 10, 15, 14, 13  //[2]->[2]
; 765  :         };
; 766  :         const char *mask;
; 767  :         switch (csp_from) {
; 768  :         case RGY_CSP_BGR24:
; 769  :         default: mask = MASK_BGR3_TO_RGB3; break;
; 770  :         }
; 771  :         for (int y = 0; y < y_range.len; y++, dstLine += dst_y_pitch_byte, srcLine += src_y_pitch_byte) {
; 772  :             uint8_t *ptr_dst = dstLine;
; 773  :             uint8_t *ptr_src = srcLine;
; 774  :             for (int x = 0; x < x_width - 16; x += 16, ptr_dst += 48, ptr_src += 48) {
; 775  :                 __m128i src0 = _mm_loadu_si128((const __m128i *)(ptr_src +  0));
; 776  :                 __m128i src1 = _mm_loadu_si128((const __m128i *)(ptr_src + 16));
; 777  :                 __m128i src2 = _mm_loadu_si128((const __m128i *)(ptr_src + 32));
; 778  :                 __m128i x0 = _mm_shuffle_epi8(src0, _mm_load_si128((__m128i *)(mask +  0)));
; 779  :                 __m128i x1 = _mm_shuffle_epi8(src0, _mm_load_si128((__m128i *)(mask + 16)));
; 780  :                 x0 = _mm_or_si128(x0, _mm_shuffle_epi8(src1, _mm_load_si128((__m128i *)(mask + 32))));
; 781  :                 x1 = _mm_or_si128(x1, _mm_shuffle_epi8(src1, _mm_load_si128((__m128i *)(mask + 48))));
; 782  :                 __m128i x2 = _mm_shuffle_epi8(src1, _mm_load_si128((__m128i *)(mask + 64)));
; 783  :                 x1 = _mm_or_si128(x1, _mm_shuffle_epi8(src2, _mm_load_si128((__m128i *)(mask + 80))));
; 784  :                 x2 = _mm_or_si128(x2, _mm_shuffle_epi8(src2, _mm_load_si128((__m128i *)(mask + 96))));
; 785  :                 _mm_storeu_si128((__m128i *)(ptr_dst +  0), x0);
; 786  :                 _mm_storeu_si128((__m128i *)(ptr_dst + 16), x1);
; 787  :                 _mm_storeu_si128((__m128i *)(ptr_dst + 32), x2);
; 788  :             }
; 789  :             if (x_width % 16) {
; 790  :                 int x_offest = 16 - (x_width % 16);
; 791  :                 ptr_dst -= x_offest * 3;
; 792  :                 ptr_src -= x_offest * 3;
; 793  :             }
; 794  :             __m128i src0 = _mm_loadu_si128((const __m128i *)(ptr_src +  0));
; 795  :             __m128i src1 = _mm_loadu_si128((const __m128i *)(ptr_src + 16));
; 796  :             __m128i src2 = _mm_loadu_si128((const __m128i *)(ptr_src + 32));
; 797  :             __m128i x0 = _mm_shuffle_epi8(src0, _mm_load_si128((__m128i *)(mask +  0)));
; 798  :             __m128i x1 = _mm_shuffle_epi8(src0, _mm_load_si128((__m128i *)(mask + 16)));
; 799  :             x0 = _mm_or_si128(x0, _mm_shuffle_epi8(src1, _mm_load_si128((__m128i *)(mask + 32))));
; 800  :             x1 = _mm_or_si128(x1, _mm_shuffle_epi8(src1, _mm_load_si128((__m128i *)(mask + 48))));
; 801  :             __m128i x2 = _mm_shuffle_epi8(src1, _mm_load_si128((__m128i *)(mask + 64)));
; 802  :             x1 = _mm_or_si128(x1, _mm_shuffle_epi8(src2, _mm_load_si128((__m128i *)(mask + 80))));
; 803  :             x2 = _mm_or_si128(x2, _mm_shuffle_epi8(src2, _mm_load_si128((__m128i *)(mask + 96))));
; 804  :             _mm_storeu_si128((__m128i *)(ptr_dst +  0), x0);
; 805  :             _mm_storeu_si128((__m128i *)(ptr_dst + 16), x1);
; 806  :             _mm_storeu_si128((__m128i *)(ptr_dst + 32), x2);
; 807  :         }
; 808  : #else
; 809  :         static_assert(csp_from == RGY_CSP_RGB24, "invalid csp");
; 810  : #endif
; 811  :     }
; 812  : }

  00135	52		 push	 edx
  00136	8b cd		 mov	 ecx, ebp
  00138	50		 push	 eax
  00139	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN10@convert_rg
  0013f	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00144	58		 pop	 eax
  00145	5a		 pop	 edx
  00146	5f		 pop	 edi
  00147	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0014a	33 cd		 xor	 ecx, ebp
  0014c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00151	83 c4 50	 add	 esp, 80			; 00000050H
  00154	3b ec		 cmp	 ebp, esp
  00156	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0015b	8b e5		 mov	 esp, ebp
  0015d	5d		 pop	 ebp
  0015e	c3		 ret	 0
  0015f	90		 npad	 1
$LN10@convert_rg:
  00160	01 00 00 00	 DD	 1
  00164	00 00 00 00	 DD	 $LN9@convert_rg
$LN9@convert_rg:
  00168	dc ff ff ff	 DD	 -36			; ffffffdcH
  0016c	0c 00 00 00	 DD	 12			; 0000000cH
  00170	00 00 00 00	 DD	 $LN8@convert_rg
$LN8@convert_rg:
  00174	79		 DB	 121			; 00000079H
  00175	5f		 DB	 95			; 0000005fH
  00176	72		 DB	 114			; 00000072H
  00177	61		 DB	 97			; 00000061H
  00178	6e		 DB	 110			; 0000006eH
  00179	67		 DB	 103			; 00000067H
  0017a	65		 DB	 101			; 00000065H
  0017b	00		 DB	 0
??$convert_rgb24_to_rgb24_simd@$0BM@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_rgb24_to_rgb24_simd<28>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_sse2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_rgb24_to_rgb24_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_rgb24_to_rgb24_sse2

; 77   : void convert_rgb24_to_rgb24_sse2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 78   :     convert_rgb24_to_rgb24_simd<RGY_CSP_RGB24>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_rgb24_to_rgb24_simd@$0BM@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_rgb24_to_rgb24_simd<28>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 79   : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_rgb24_to_rgb24_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_rgb24_to_rgb24_sse2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
tv130 = -1332						; size = 4
$T1 = -1328						; size = 12
$T2 = -1312						; size = 16
$T3 = -1296						; size = 16
$T4 = -1280						; size = 16
_x2$5 = -1264						; size = 16
$T6 = -1248						; size = 16
$T7 = -1232						; size = 16
$T8 = -1216						; size = 16
_x1$9 = -1200						; size = 16
$T10 = -1184						; size = 16
$T11 = -1168						; size = 16
$T12 = -1152						; size = 16
_x0$13 = -1136						; size = 16
$T14 = -1120						; size = 16
$T15 = -1104						; size = 16
$T16 = -1088						; size = 16
_x13_1$17 = -1072					; size = 16
$T18 = -1056						; size = 16
$T19 = -1040						; size = 16
$T20 = -1024						; size = 16
_x13_0$21 = -1008					; size = 16
$T22 = -992						; size = 16
$T23 = -976						; size = 16
$T24 = -960						; size = 16
_x02_1$25 = -944					; size = 16
$T26 = -928						; size = 16
$T27 = -912						; size = 16
$T28 = -896						; size = 16
_x02_0$29 = -880					; size = 16
$T30 = -864						; size = 16
_xSrc3$31 = -848					; size = 16
$T32 = -832						; size = 16
_xSrc2$33 = -816					; size = 16
$T34 = -800						; size = 16
_xSrc1$35 = -784					; size = 16
$T36 = -768						; size = 16
_xSrc0$37 = -752					; size = 16
_x_offset$38 = -724					; size = 4
$T39 = -720						; size = 16
$T40 = -704						; size = 16
$T41 = -688						; size = 16
_x2$42 = -672						; size = 16
$T43 = -656						; size = 16
$T44 = -640						; size = 16
$T45 = -624						; size = 16
_x1$46 = -608						; size = 16
$T47 = -592						; size = 16
$T48 = -576						; size = 16
$T49 = -560						; size = 16
_x0$50 = -544						; size = 16
$T51 = -528						; size = 16
$T52 = -512						; size = 16
$T53 = -496						; size = 16
_x13_1$54 = -480					; size = 16
$T55 = -464						; size = 16
$T56 = -448						; size = 16
$T57 = -432						; size = 16
_x13_0$58 = -416					; size = 16
$T59 = -400						; size = 16
$T60 = -384						; size = 16
$T61 = -368						; size = 16
_x02_1$62 = -352					; size = 16
$T63 = -336						; size = 16
$T64 = -320						; size = 16
$T65 = -304						; size = 16
_x02_0$66 = -288					; size = 16
$T67 = -272						; size = 16
_xSrc3$68 = -256					; size = 16
$T69 = -240						; size = 16
_xSrc2$70 = -224					; size = 16
$T71 = -208						; size = 16
_xSrc1$72 = -192					; size = 16
$T73 = -176						; size = 16
_xSrc0$74 = -160					; size = 16
_x_fin$75 = -140					; size = 4
_x$76 = -136						; size = 4
_ptr_dst2$77 = -132					; size = 4
_ptr_dst1$78 = -128					; size = 4
_ptr_dst0$79 = -124					; size = 4
_ptr_src$80 = -120					; size = 4
_y$81 = -116						; size = 4
$T82 = -112						; size = 16
_xMask$ = -96						; size = 16
_srcLine$ = -68						; size = 4
_dst2Line$ = -64					; size = 4
_dst1Line$ = -60					; size = 4
_dst0Line$ = -56					; size = 4
$T83 = -52						; size = 12
_y_range$ = -36						; size = 12
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_rgb32_to_rgb_simd@$0PPAAABAC@$00@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_rgb32_to_rgb_simd<4278190338,1>

; 607  : static void __forceinline convert_rgb32_to_rgb_simd(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 40 05 00
	00		 sub	 esp, 1344		; 00000540H
  0001c	57		 push	 edi
  0001d	8d bd c0 fa ff
	ff		 lea	 edi, DWORD PTR [ebp-1344]
  00023	b9 50 01 00 00	 mov	 ecx, 336		; 00000150H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 608  :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 609  :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 610  :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 611  :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 612  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  0007c	8b 53 2c	 mov	 edx, DWORD PTR _thread_n$[ebx]
  0007f	52		 push	 edx
  00080	8b 43 28	 mov	 eax, DWORD PTR _thread_id$[ebx]
  00083	50		 push	 eax
  00084	8b 4b 20	 mov	 ecx, DWORD PTR _height$[ebx]
  00087	2b 4d ec	 sub	 ecx, DWORD PTR _crop_bottom$[ebp]
  0008a	51		 push	 ecx
  0008b	8b 55 f4	 mov	 edx, DWORD PTR _crop_up$[ebp]
  0008e	52		 push	 edx
  0008f	8d 85 d0 fa ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  00095	50		 push	 eax
  00096	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  0009b	83 c4 14	 add	 esp, 20			; 00000014H
  0009e	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a0	89 4d cc	 mov	 DWORD PTR $T83[ebp], ecx
  000a3	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a6	89 55 d0	 mov	 DWORD PTR $T83[ebp+4], edx
  000a9	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000ac	89 45 d4	 mov	 DWORD PTR $T83[ebp+8], eax
  000af	8b 4d cc	 mov	 ecx, DWORD PTR $T83[ebp]
  000b2	89 4d dc	 mov	 DWORD PTR _y_range$[ebp], ecx
  000b5	8b 55 d0	 mov	 edx, DWORD PTR $T83[ebp+4]
  000b8	89 55 e0	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000bb	8b 45 d4	 mov	 eax, DWORD PTR $T83[ebp+8]
  000be	89 45 e4	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 613  :     uint8_t *dst0Line = (uint8_t *)dst[(plane_from >>  0) & 0xff] + dst_y_pitch_byte * y_range.start_dst;

  000c1	b9 04 00 00 00	 mov	 ecx, 4
  000c6	d1 e1		 shl	 ecx, 1
  000c8	8b 53 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebx]
  000cb	0f af 55 e0	 imul	 edx, DWORD PTR _y_range$[ebp+4]
  000cf	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  000d2	03 14 08	 add	 edx, DWORD PTR [eax+ecx]
  000d5	89 55 c8	 mov	 DWORD PTR _dst0Line$[ebp], edx

; 614  :     uint8_t *dst1Line = (uint8_t *)dst[(plane_from >>  8) & 0xff] + dst_y_pitch_byte * y_range.start_dst;

  000d8	b9 04 00 00 00	 mov	 ecx, 4
  000dd	c1 e1 00	 shl	 ecx, 0
  000e0	8b 53 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebx]
  000e3	0f af 55 e0	 imul	 edx, DWORD PTR _y_range$[ebp+4]
  000e7	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  000ea	03 14 08	 add	 edx, DWORD PTR [eax+ecx]
  000ed	89 55 c4	 mov	 DWORD PTR _dst1Line$[ebp], edx

; 615  :     uint8_t *dst2Line = (uint8_t *)dst[(plane_from >> 16) & 0xff] + dst_y_pitch_byte * y_range.start_dst;

  000f0	b9 04 00 00 00	 mov	 ecx, 4
  000f5	6b d1 00	 imul	 edx, ecx, 0
  000f8	8b 43 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  000fb	0f af 45 e0	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  000ff	8b 4b 08	 mov	 ecx, DWORD PTR _dst$[ebx]
  00102	03 04 11	 add	 eax, DWORD PTR [ecx+edx]
  00105	89 45 c0	 mov	 DWORD PTR _dst2Line$[ebp], eax

; 616  :     uint8_t *srcLine  = (uint8_t *)src[0] + src_y_pitch_byte * ((source_reverse) ? (height - crop_bottom - y_range.start_src - 1) : y_range.start_src) + crop_left * 4;

  00108	ba 01 00 00 00	 mov	 edx, 1
  0010d	85 d2		 test	 edx, edx
  0010f	74 14		 je	 SHORT $LN11@convert_rg
  00111	8b 43 20	 mov	 eax, DWORD PTR _height$[ebx]
  00114	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  00117	2b 45 dc	 sub	 eax, DWORD PTR _y_range$[ebp]
  0011a	83 e8 01	 sub	 eax, 1
  0011d	89 85 cc fa ff
	ff		 mov	 DWORD PTR tv130[ebp], eax
  00123	eb 09		 jmp	 SHORT $LN12@convert_rg
$LN11@convert_rg:
  00125	8b 4d dc	 mov	 ecx, DWORD PTR _y_range$[ebp]
  00128	89 8d cc fa ff
	ff		 mov	 DWORD PTR tv130[ebp], ecx
$LN12@convert_rg:
  0012e	ba 04 00 00 00	 mov	 edx, 4
  00133	6b c2 00	 imul	 eax, edx, 0
  00136	8b 4b 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebx]
  00139	0f af 8d cc fa
	ff ff		 imul	 ecx, DWORD PTR tv130[ebp]
  00140	8b 53 0c	 mov	 edx, DWORD PTR _src$[ebx]
  00143	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  00146	03 c1		 add	 eax, ecx
  00148	8b 4d f8	 mov	 ecx, DWORD PTR _crop_left$[ebp]
  0014b	8d 14 88	 lea	 edx, DWORD PTR [eax+ecx*4]
  0014e	89 55 bc	 mov	 DWORD PTR _srcLine$[ebp], edx

; 617  :     __m128i xMask = _mm_set1_epi16(0xff);

  00151	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@00ff00ff00ff00ff00ff00ff00ff00ff
  00158	0f 29 45 90	 movaps	 XMMWORD PTR $T82[ebp], xmm0
  0015c	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR $T82[ebp]
  00160	0f 29 45 a0	 movaps	 XMMWORD PTR _xMask$[ebp], xmm0

; 618  :     if (source_reverse) {

  00164	b8 01 00 00 00	 mov	 eax, 1
  00169	85 c0		 test	 eax, eax
  0016b	74 07		 je	 SHORT $LN8@convert_rg

; 619  :         src_y_pitch_byte = -1 * src_y_pitch_byte;

  0016d	6b 4b 14 ff	 imul	 ecx, DWORD PTR _src_y_pitch_byte$[ebx], -1
  00171	89 4b 14	 mov	 DWORD PTR _src_y_pitch_byte$[ebx], ecx
$LN8@convert_rg:

; 620  :     }
; 621  :     for (int y = 0; y < y_range.len; y++, srcLine += src_y_pitch_byte, dst0Line += dst_y_pitch_byte, dst1Line += dst_y_pitch_byte, dst2Line += dst_y_pitch_byte) {

  00174	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR _y$81[ebp], 0
  0017b	eb 2d		 jmp	 SHORT $LN4@convert_rg
$LN2@convert_rg:
  0017d	8b 55 8c	 mov	 edx, DWORD PTR _y$81[ebp]
  00180	83 c2 01	 add	 edx, 1
  00183	89 55 8c	 mov	 DWORD PTR _y$81[ebp], edx
  00186	8b 45 bc	 mov	 eax, DWORD PTR _srcLine$[ebp]
  00189	03 43 14	 add	 eax, DWORD PTR _src_y_pitch_byte$[ebx]
  0018c	89 45 bc	 mov	 DWORD PTR _srcLine$[ebp], eax
  0018f	8b 4d c8	 mov	 ecx, DWORD PTR _dst0Line$[ebp]
  00192	03 4b 1c	 add	 ecx, DWORD PTR _dst_y_pitch_byte$[ebx]
  00195	89 4d c8	 mov	 DWORD PTR _dst0Line$[ebp], ecx
  00198	8b 55 c4	 mov	 edx, DWORD PTR _dst1Line$[ebp]
  0019b	03 53 1c	 add	 edx, DWORD PTR _dst_y_pitch_byte$[ebx]
  0019e	89 55 c4	 mov	 DWORD PTR _dst1Line$[ebp], edx
  001a1	8b 45 c0	 mov	 eax, DWORD PTR _dst2Line$[ebp]
  001a4	03 43 1c	 add	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  001a7	89 45 c0	 mov	 DWORD PTR _dst2Line$[ebp], eax
$LN4@convert_rg:
  001aa	8b 4d 8c	 mov	 ecx, DWORD PTR _y$81[ebp]
  001ad	3b 4d e4	 cmp	 ecx, DWORD PTR _y_range$[ebp+8]
  001b0	0f 8d 2c 06 00
	00		 jge	 $LN1@convert_rg

; 622  :         uint8_t *ptr_src  = srcLine;

  001b6	8b 55 bc	 mov	 edx, DWORD PTR _srcLine$[ebp]
  001b9	89 55 88	 mov	 DWORD PTR _ptr_src$80[ebp], edx

; 623  :         uint8_t *ptr_dst0 = dst0Line;

  001bc	8b 45 c8	 mov	 eax, DWORD PTR _dst0Line$[ebp]
  001bf	89 45 84	 mov	 DWORD PTR _ptr_dst0$79[ebp], eax

; 624  :         uint8_t *ptr_dst1 = dst1Line;

  001c2	8b 4d c4	 mov	 ecx, DWORD PTR _dst1Line$[ebp]
  001c5	89 4d 80	 mov	 DWORD PTR _ptr_dst1$78[ebp], ecx

; 625  :         uint8_t *ptr_dst2 = dst2Line;

  001c8	8b 55 c0	 mov	 edx, DWORD PTR _dst2Line$[ebp]
  001cb	89 95 7c ff ff
	ff		 mov	 DWORD PTR _ptr_dst2$77[ebp], edx

; 626  :         int x = 0, x_fin = width - crop_left - crop_right - 16;

  001d1	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _x$76[ebp], 0
  001db	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  001de	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  001e1	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  001e4	83 e8 10	 sub	 eax, 16			; 00000010H
  001e7	89 85 74 ff ff
	ff		 mov	 DWORD PTR _x_fin$75[ebp], eax

; 627  :         for (; x < x_fin; x += 16, ptr_src += 64, ptr_dst0 += 16, ptr_dst1 += 16, ptr_dst2 += 16) {

  001ed	eb 39		 jmp	 SHORT $LN7@convert_rg
$LN5@convert_rg:
  001ef	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _x$76[ebp]
  001f5	83 c1 10	 add	 ecx, 16			; 00000010H
  001f8	89 8d 78 ff ff
	ff		 mov	 DWORD PTR _x$76[ebp], ecx
  001fe	8b 55 88	 mov	 edx, DWORD PTR _ptr_src$80[ebp]
  00201	83 c2 40	 add	 edx, 64			; 00000040H
  00204	89 55 88	 mov	 DWORD PTR _ptr_src$80[ebp], edx
  00207	8b 45 84	 mov	 eax, DWORD PTR _ptr_dst0$79[ebp]
  0020a	83 c0 10	 add	 eax, 16			; 00000010H
  0020d	89 45 84	 mov	 DWORD PTR _ptr_dst0$79[ebp], eax
  00210	8b 4d 80	 mov	 ecx, DWORD PTR _ptr_dst1$78[ebp]
  00213	83 c1 10	 add	 ecx, 16			; 00000010H
  00216	89 4d 80	 mov	 DWORD PTR _ptr_dst1$78[ebp], ecx
  00219	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR _ptr_dst2$77[ebp]
  0021f	83 c2 10	 add	 edx, 16			; 00000010H
  00222	89 95 7c ff ff
	ff		 mov	 DWORD PTR _ptr_dst2$77[ebp], edx
$LN7@convert_rg:
  00228	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _x$76[ebp]
  0022e	3b 85 74 ff ff
	ff		 cmp	 eax, DWORD PTR _x_fin$75[ebp]
  00234	0f 8d aa 02 00
	00		 jge	 $LN6@convert_rg

; 628  :             __m128i xSrc0 = _mm_loadu_si128((__m128i *)(ptr_src +  0));

  0023a	8b 4d 88	 mov	 ecx, DWORD PTR _ptr_src$80[ebp]
  0023d	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00240	0f 29 85 50 ff
	ff ff		 movaps	 XMMWORD PTR $T73[ebp], xmm0
  00247	0f 28 85 50 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T73[ebp]
  0024e	0f 29 85 60 ff
	ff ff		 movaps	 XMMWORD PTR _xSrc0$74[ebp], xmm0

; 629  :             __m128i xSrc1 = _mm_loadu_si128((__m128i *)(ptr_src + 16));

  00255	8b 55 88	 mov	 edx, DWORD PTR _ptr_src$80[ebp]
  00258	83 c2 10	 add	 edx, 16			; 00000010H
  0025b	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  0025e	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR $T71[ebp], xmm0
  00265	0f 28 85 30 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T71[ebp]
  0026c	0f 29 85 40 ff
	ff ff		 movaps	 XMMWORD PTR _xSrc1$72[ebp], xmm0

; 630  :             __m128i xSrc2 = _mm_loadu_si128((__m128i *)(ptr_src + 32));

  00273	8b 45 88	 mov	 eax, DWORD PTR _ptr_src$80[ebp]
  00276	83 c0 20	 add	 eax, 32			; 00000020H
  00279	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  0027c	0f 29 85 10 ff
	ff ff		 movaps	 XMMWORD PTR $T69[ebp], xmm0
  00283	0f 28 85 10 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T69[ebp]
  0028a	0f 29 85 20 ff
	ff ff		 movaps	 XMMWORD PTR _xSrc2$70[ebp], xmm0

; 631  :             __m128i xSrc3 = _mm_loadu_si128((__m128i *)(ptr_src + 48));

  00291	8b 4d 88	 mov	 ecx, DWORD PTR _ptr_src$80[ebp]
  00294	83 c1 30	 add	 ecx, 48			; 00000030H
  00297	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  0029a	0f 29 85 f0 fe
	ff ff		 movaps	 XMMWORD PTR $T67[ebp], xmm0
  002a1	0f 28 85 f0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T67[ebp]
  002a8	0f 29 85 00 ff
	ff ff		 movaps	 XMMWORD PTR _xSrc3$68[ebp], xmm0

; 632  : 
; 633  :             __m128i x02_0 = _mm_packus_epi16(_mm_and_si128(xMask, xSrc0), _mm_and_si128(xMask, xSrc1));

  002af	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _xMask$[ebp]
  002b3	66 0f db 85 40
	ff ff ff	 pand	 xmm0, XMMWORD PTR _xSrc1$72[ebp]
  002bb	0f 29 85 c0 fe
	ff ff		 movaps	 XMMWORD PTR $T64[ebp], xmm0
  002c2	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _xMask$[ebp]
  002c6	66 0f db 85 60
	ff ff ff	 pand	 xmm0, XMMWORD PTR _xSrc0$74[ebp]
  002ce	0f 29 85 d0 fe
	ff ff		 movaps	 XMMWORD PTR $T65[ebp], xmm0
  002d5	0f 28 85 d0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T65[ebp]
  002dc	66 0f 67 85 c0
	fe ff ff	 packuswb xmm0, XMMWORD PTR $T64[ebp]
  002e4	0f 29 85 b0 fe
	ff ff		 movaps	 XMMWORD PTR $T63[ebp], xmm0
  002eb	0f 28 85 b0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T63[ebp]
  002f2	0f 29 85 e0 fe
	ff ff		 movaps	 XMMWORD PTR _x02_0$66[ebp], xmm0

; 634  :             __m128i x02_1 = _mm_packus_epi16(_mm_and_si128(xMask, xSrc2), _mm_and_si128(xMask, xSrc3));

  002f9	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _xMask$[ebp]
  002fd	66 0f db 85 00
	ff ff ff	 pand	 xmm0, XMMWORD PTR _xSrc3$68[ebp]
  00305	0f 29 85 80 fe
	ff ff		 movaps	 XMMWORD PTR $T60[ebp], xmm0
  0030c	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _xMask$[ebp]
  00310	66 0f db 85 20
	ff ff ff	 pand	 xmm0, XMMWORD PTR _xSrc2$70[ebp]
  00318	0f 29 85 90 fe
	ff ff		 movaps	 XMMWORD PTR $T61[ebp], xmm0
  0031f	0f 28 85 90 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T61[ebp]
  00326	66 0f 67 85 80
	fe ff ff	 packuswb xmm0, XMMWORD PTR $T60[ebp]
  0032e	0f 29 85 70 fe
	ff ff		 movaps	 XMMWORD PTR $T59[ebp], xmm0
  00335	0f 28 85 70 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T59[ebp]
  0033c	0f 29 85 a0 fe
	ff ff		 movaps	 XMMWORD PTR _x02_1$62[ebp], xmm0

; 635  :             __m128i x13_0 = _mm_packus_epi16(_mm_srli_epi16(xSrc0, 8), _mm_srli_epi16(xSrc1, 8));

  00343	0f 28 85 40 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _xSrc1$72[ebp]
  0034a	66 0f 71 d0 08	 psrlw	 xmm0, 8
  0034f	0f 29 85 40 fe
	ff ff		 movaps	 XMMWORD PTR $T56[ebp], xmm0
  00356	0f 28 85 60 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _xSrc0$74[ebp]
  0035d	66 0f 71 d0 08	 psrlw	 xmm0, 8
  00362	0f 29 85 50 fe
	ff ff		 movaps	 XMMWORD PTR $T57[ebp], xmm0
  00369	0f 28 85 50 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T57[ebp]
  00370	66 0f 67 85 40
	fe ff ff	 packuswb xmm0, XMMWORD PTR $T56[ebp]
  00378	0f 29 85 30 fe
	ff ff		 movaps	 XMMWORD PTR $T55[ebp], xmm0
  0037f	0f 28 85 30 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T55[ebp]
  00386	0f 29 85 60 fe
	ff ff		 movaps	 XMMWORD PTR _x13_0$58[ebp], xmm0

; 636  :             __m128i x13_1 = _mm_packus_epi16(_mm_srli_epi16(xSrc2, 8), _mm_srli_epi16(xSrc3, 8));

  0038d	0f 28 85 00 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _xSrc3$68[ebp]
  00394	66 0f 71 d0 08	 psrlw	 xmm0, 8
  00399	0f 29 85 00 fe
	ff ff		 movaps	 XMMWORD PTR $T52[ebp], xmm0
  003a0	0f 28 85 20 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _xSrc2$70[ebp]
  003a7	66 0f 71 d0 08	 psrlw	 xmm0, 8
  003ac	0f 29 85 10 fe
	ff ff		 movaps	 XMMWORD PTR $T53[ebp], xmm0
  003b3	0f 28 85 10 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T53[ebp]
  003ba	66 0f 67 85 00
	fe ff ff	 packuswb xmm0, XMMWORD PTR $T52[ebp]
  003c2	0f 29 85 f0 fd
	ff ff		 movaps	 XMMWORD PTR $T51[ebp], xmm0
  003c9	0f 28 85 f0 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T51[ebp]
  003d0	0f 29 85 20 fe
	ff ff		 movaps	 XMMWORD PTR _x13_1$54[ebp], xmm0

; 637  : 
; 638  :             __m128i x0 = _mm_packus_epi16(_mm_and_si128(xMask, x02_0), _mm_and_si128(xMask, x02_1));

  003d7	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _xMask$[ebp]
  003db	66 0f db 85 a0
	fe ff ff	 pand	 xmm0, XMMWORD PTR _x02_1$62[ebp]
  003e3	0f 29 85 c0 fd
	ff ff		 movaps	 XMMWORD PTR $T48[ebp], xmm0
  003ea	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _xMask$[ebp]
  003ee	66 0f db 85 e0
	fe ff ff	 pand	 xmm0, XMMWORD PTR _x02_0$66[ebp]
  003f6	0f 29 85 d0 fd
	ff ff		 movaps	 XMMWORD PTR $T49[ebp], xmm0
  003fd	0f 28 85 d0 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T49[ebp]
  00404	66 0f 67 85 c0
	fd ff ff	 packuswb xmm0, XMMWORD PTR $T48[ebp]
  0040c	0f 29 85 b0 fd
	ff ff		 movaps	 XMMWORD PTR $T47[ebp], xmm0
  00413	0f 28 85 b0 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T47[ebp]
  0041a	0f 29 85 e0 fd
	ff ff		 movaps	 XMMWORD PTR _x0$50[ebp], xmm0

; 639  :             __m128i x1 = _mm_packus_epi16(_mm_and_si128(xMask, x13_0), _mm_and_si128(xMask, x13_1));

  00421	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _xMask$[ebp]
  00425	66 0f db 85 20
	fe ff ff	 pand	 xmm0, XMMWORD PTR _x13_1$54[ebp]
  0042d	0f 29 85 80 fd
	ff ff		 movaps	 XMMWORD PTR $T44[ebp], xmm0
  00434	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _xMask$[ebp]
  00438	66 0f db 85 60
	fe ff ff	 pand	 xmm0, XMMWORD PTR _x13_0$58[ebp]
  00440	0f 29 85 90 fd
	ff ff		 movaps	 XMMWORD PTR $T45[ebp], xmm0
  00447	0f 28 85 90 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T45[ebp]
  0044e	66 0f 67 85 80
	fd ff ff	 packuswb xmm0, XMMWORD PTR $T44[ebp]
  00456	0f 29 85 70 fd
	ff ff		 movaps	 XMMWORD PTR $T43[ebp], xmm0
  0045d	0f 28 85 70 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T43[ebp]
  00464	0f 29 85 a0 fd
	ff ff		 movaps	 XMMWORD PTR _x1$46[ebp], xmm0

; 640  :             __m128i x2 = _mm_packus_epi16(_mm_srli_epi16(x02_0, 8), _mm_srli_epi16(x02_1, 8));

  0046b	0f 28 85 a0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _x02_1$62[ebp]
  00472	66 0f 71 d0 08	 psrlw	 xmm0, 8
  00477	0f 29 85 40 fd
	ff ff		 movaps	 XMMWORD PTR $T40[ebp], xmm0
  0047e	0f 28 85 e0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _x02_0$66[ebp]
  00485	66 0f 71 d0 08	 psrlw	 xmm0, 8
  0048a	0f 29 85 50 fd
	ff ff		 movaps	 XMMWORD PTR $T41[ebp], xmm0
  00491	0f 28 85 50 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T41[ebp]
  00498	66 0f 67 85 40
	fd ff ff	 packuswb xmm0, XMMWORD PTR $T40[ebp]
  004a0	0f 29 85 30 fd
	ff ff		 movaps	 XMMWORD PTR $T39[ebp], xmm0
  004a7	0f 28 85 30 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T39[ebp]
  004ae	0f 29 85 60 fd
	ff ff		 movaps	 XMMWORD PTR _x2$42[ebp], xmm0

; 641  :             //__m128i x3 = _mm_packus_epi16(_mm_srli_epi16(x13_0, 8), _mm_srli_epi16(x13_1, 8));
; 642  : 
; 643  :             _mm_storeu_si128((__m128i *)ptr_dst0, x0);

  004b5	0f 10 85 e0 fd
	ff ff		 movups	 xmm0, XMMWORD PTR _x0$50[ebp]
  004bc	8b 55 84	 mov	 edx, DWORD PTR _ptr_dst0$79[ebp]
  004bf	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 644  :             _mm_storeu_si128((__m128i *)ptr_dst1, x1);

  004c2	0f 10 85 a0 fd
	ff ff		 movups	 xmm0, XMMWORD PTR _x1$46[ebp]
  004c9	8b 45 80	 mov	 eax, DWORD PTR _ptr_dst1$78[ebp]
  004cc	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 645  :             _mm_storeu_si128((__m128i *)ptr_dst2, x2);

  004cf	0f 10 85 60 fd
	ff ff		 movups	 xmm0, XMMWORD PTR _x2$42[ebp]
  004d6	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _ptr_dst2$77[ebp]
  004dc	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 646  :         }

  004df	e9 0b fd ff ff	 jmp	 $LN5@convert_rg
$LN6@convert_rg:

; 647  :         if (width & 15) {

  004e4	8b 53 10	 mov	 edx, DWORD PTR _width$[ebx]
  004e7	83 e2 0f	 and	 edx, 15			; 0000000fH
  004ea	74 4c		 je	 SHORT $LN9@convert_rg

; 648  :             int x_offset = (16 - (width & 15));

  004ec	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  004ef	83 e0 0f	 and	 eax, 15			; 0000000fH
  004f2	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  004f7	2b c8		 sub	 ecx, eax
  004f9	89 8d 2c fd ff
	ff		 mov	 DWORD PTR _x_offset$38[ebp], ecx

; 649  :             ptr_src -= x_offset * 3;

  004ff	6b 95 2c fd ff
	ff 03		 imul	 edx, DWORD PTR _x_offset$38[ebp], 3
  00506	8b 45 88	 mov	 eax, DWORD PTR _ptr_src$80[ebp]
  00509	2b c2		 sub	 eax, edx
  0050b	89 45 88	 mov	 DWORD PTR _ptr_src$80[ebp], eax

; 650  :             ptr_dst0 -= x_offset;

  0050e	8b 4d 84	 mov	 ecx, DWORD PTR _ptr_dst0$79[ebp]
  00511	2b 8d 2c fd ff
	ff		 sub	 ecx, DWORD PTR _x_offset$38[ebp]
  00517	89 4d 84	 mov	 DWORD PTR _ptr_dst0$79[ebp], ecx

; 651  :             ptr_dst1 -= x_offset;

  0051a	8b 55 80	 mov	 edx, DWORD PTR _ptr_dst1$78[ebp]
  0051d	2b 95 2c fd ff
	ff		 sub	 edx, DWORD PTR _x_offset$38[ebp]
  00523	89 55 80	 mov	 DWORD PTR _ptr_dst1$78[ebp], edx

; 652  :             ptr_dst2 -= x_offset;

  00526	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _ptr_dst2$77[ebp]
  0052c	2b 85 2c fd ff
	ff		 sub	 eax, DWORD PTR _x_offset$38[ebp]
  00532	89 85 7c ff ff
	ff		 mov	 DWORD PTR _ptr_dst2$77[ebp], eax
$LN9@convert_rg:

; 653  :         }
; 654  :         __m128i xSrc0 = _mm_loadu_si128((__m128i *)(ptr_src +  0));

  00538	8b 4d 88	 mov	 ecx, DWORD PTR _ptr_src$80[ebp]
  0053b	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  0053e	0f 29 85 00 fd
	ff ff		 movaps	 XMMWORD PTR $T36[ebp], xmm0
  00545	0f 28 85 00 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T36[ebp]
  0054c	0f 29 85 10 fd
	ff ff		 movaps	 XMMWORD PTR _xSrc0$37[ebp], xmm0

; 655  :         __m128i xSrc1 = _mm_loadu_si128((__m128i *)(ptr_src + 16));

  00553	8b 55 88	 mov	 edx, DWORD PTR _ptr_src$80[ebp]
  00556	83 c2 10	 add	 edx, 16			; 00000010H
  00559	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  0055c	0f 29 85 e0 fc
	ff ff		 movaps	 XMMWORD PTR $T34[ebp], xmm0
  00563	0f 28 85 e0 fc
	ff ff		 movaps	 xmm0, XMMWORD PTR $T34[ebp]
  0056a	0f 29 85 f0 fc
	ff ff		 movaps	 XMMWORD PTR _xSrc1$35[ebp], xmm0

; 656  :         __m128i xSrc2 = _mm_loadu_si128((__m128i *)(ptr_src + 32));

  00571	8b 45 88	 mov	 eax, DWORD PTR _ptr_src$80[ebp]
  00574	83 c0 20	 add	 eax, 32			; 00000020H
  00577	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  0057a	0f 29 85 c0 fc
	ff ff		 movaps	 XMMWORD PTR $T32[ebp], xmm0
  00581	0f 28 85 c0 fc
	ff ff		 movaps	 xmm0, XMMWORD PTR $T32[ebp]
  00588	0f 29 85 d0 fc
	ff ff		 movaps	 XMMWORD PTR _xSrc2$33[ebp], xmm0

; 657  :         __m128i xSrc3 = _mm_loadu_si128((__m128i *)(ptr_src + 48));

  0058f	8b 4d 88	 mov	 ecx, DWORD PTR _ptr_src$80[ebp]
  00592	83 c1 30	 add	 ecx, 48			; 00000030H
  00595	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00598	0f 29 85 a0 fc
	ff ff		 movaps	 XMMWORD PTR $T30[ebp], xmm0
  0059f	0f 28 85 a0 fc
	ff ff		 movaps	 xmm0, XMMWORD PTR $T30[ebp]
  005a6	0f 29 85 b0 fc
	ff ff		 movaps	 XMMWORD PTR _xSrc3$31[ebp], xmm0

; 658  : 
; 659  :         __m128i x02_0 = _mm_packus_epi16(_mm_and_si128(xMask, xSrc0), _mm_and_si128(xMask, xSrc1));

  005ad	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _xMask$[ebp]
  005b1	66 0f db 85 f0
	fc ff ff	 pand	 xmm0, XMMWORD PTR _xSrc1$35[ebp]
  005b9	0f 29 85 70 fc
	ff ff		 movaps	 XMMWORD PTR $T27[ebp], xmm0
  005c0	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _xMask$[ebp]
  005c4	66 0f db 85 10
	fd ff ff	 pand	 xmm0, XMMWORD PTR _xSrc0$37[ebp]
  005cc	0f 29 85 80 fc
	ff ff		 movaps	 XMMWORD PTR $T28[ebp], xmm0
  005d3	0f 28 85 80 fc
	ff ff		 movaps	 xmm0, XMMWORD PTR $T28[ebp]
  005da	66 0f 67 85 70
	fc ff ff	 packuswb xmm0, XMMWORD PTR $T27[ebp]
  005e2	0f 29 85 60 fc
	ff ff		 movaps	 XMMWORD PTR $T26[ebp], xmm0
  005e9	0f 28 85 60 fc
	ff ff		 movaps	 xmm0, XMMWORD PTR $T26[ebp]
  005f0	0f 29 85 90 fc
	ff ff		 movaps	 XMMWORD PTR _x02_0$29[ebp], xmm0

; 660  :         __m128i x02_1 = _mm_packus_epi16(_mm_and_si128(xMask, xSrc2), _mm_and_si128(xMask, xSrc3));

  005f7	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _xMask$[ebp]
  005fb	66 0f db 85 b0
	fc ff ff	 pand	 xmm0, XMMWORD PTR _xSrc3$31[ebp]
  00603	0f 29 85 30 fc
	ff ff		 movaps	 XMMWORD PTR $T23[ebp], xmm0
  0060a	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _xMask$[ebp]
  0060e	66 0f db 85 d0
	fc ff ff	 pand	 xmm0, XMMWORD PTR _xSrc2$33[ebp]
  00616	0f 29 85 40 fc
	ff ff		 movaps	 XMMWORD PTR $T24[ebp], xmm0
  0061d	0f 28 85 40 fc
	ff ff		 movaps	 xmm0, XMMWORD PTR $T24[ebp]
  00624	66 0f 67 85 30
	fc ff ff	 packuswb xmm0, XMMWORD PTR $T23[ebp]
  0062c	0f 29 85 20 fc
	ff ff		 movaps	 XMMWORD PTR $T22[ebp], xmm0
  00633	0f 28 85 20 fc
	ff ff		 movaps	 xmm0, XMMWORD PTR $T22[ebp]
  0063a	0f 29 85 50 fc
	ff ff		 movaps	 XMMWORD PTR _x02_1$25[ebp], xmm0

; 661  :         __m128i x13_0 = _mm_packus_epi16(_mm_srli_epi16(xSrc0, 8), _mm_srli_epi16(xSrc1, 8));

  00641	0f 28 85 f0 fc
	ff ff		 movaps	 xmm0, XMMWORD PTR _xSrc1$35[ebp]
  00648	66 0f 71 d0 08	 psrlw	 xmm0, 8
  0064d	0f 29 85 f0 fb
	ff ff		 movaps	 XMMWORD PTR $T19[ebp], xmm0
  00654	0f 28 85 10 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR _xSrc0$37[ebp]
  0065b	66 0f 71 d0 08	 psrlw	 xmm0, 8
  00660	0f 29 85 00 fc
	ff ff		 movaps	 XMMWORD PTR $T20[ebp], xmm0
  00667	0f 28 85 00 fc
	ff ff		 movaps	 xmm0, XMMWORD PTR $T20[ebp]
  0066e	66 0f 67 85 f0
	fb ff ff	 packuswb xmm0, XMMWORD PTR $T19[ebp]
  00676	0f 29 85 e0 fb
	ff ff		 movaps	 XMMWORD PTR $T18[ebp], xmm0
  0067d	0f 28 85 e0 fb
	ff ff		 movaps	 xmm0, XMMWORD PTR $T18[ebp]
  00684	0f 29 85 10 fc
	ff ff		 movaps	 XMMWORD PTR _x13_0$21[ebp], xmm0

; 662  :         __m128i x13_1 = _mm_packus_epi16(_mm_srli_epi16(xSrc2, 8), _mm_srli_epi16(xSrc3, 8));

  0068b	0f 28 85 b0 fc
	ff ff		 movaps	 xmm0, XMMWORD PTR _xSrc3$31[ebp]
  00692	66 0f 71 d0 08	 psrlw	 xmm0, 8
  00697	0f 29 85 b0 fb
	ff ff		 movaps	 XMMWORD PTR $T15[ebp], xmm0
  0069e	0f 28 85 d0 fc
	ff ff		 movaps	 xmm0, XMMWORD PTR _xSrc2$33[ebp]
  006a5	66 0f 71 d0 08	 psrlw	 xmm0, 8
  006aa	0f 29 85 c0 fb
	ff ff		 movaps	 XMMWORD PTR $T16[ebp], xmm0
  006b1	0f 28 85 c0 fb
	ff ff		 movaps	 xmm0, XMMWORD PTR $T16[ebp]
  006b8	66 0f 67 85 b0
	fb ff ff	 packuswb xmm0, XMMWORD PTR $T15[ebp]
  006c0	0f 29 85 a0 fb
	ff ff		 movaps	 XMMWORD PTR $T14[ebp], xmm0
  006c7	0f 28 85 a0 fb
	ff ff		 movaps	 xmm0, XMMWORD PTR $T14[ebp]
  006ce	0f 29 85 d0 fb
	ff ff		 movaps	 XMMWORD PTR _x13_1$17[ebp], xmm0

; 663  : 
; 664  :         __m128i x0 = _mm_packus_epi16(_mm_and_si128(xMask, x02_0), _mm_and_si128(xMask, x02_1));

  006d5	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _xMask$[ebp]
  006d9	66 0f db 85 50
	fc ff ff	 pand	 xmm0, XMMWORD PTR _x02_1$25[ebp]
  006e1	0f 29 85 70 fb
	ff ff		 movaps	 XMMWORD PTR $T11[ebp], xmm0
  006e8	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _xMask$[ebp]
  006ec	66 0f db 85 90
	fc ff ff	 pand	 xmm0, XMMWORD PTR _x02_0$29[ebp]
  006f4	0f 29 85 80 fb
	ff ff		 movaps	 XMMWORD PTR $T12[ebp], xmm0
  006fb	0f 28 85 80 fb
	ff ff		 movaps	 xmm0, XMMWORD PTR $T12[ebp]
  00702	66 0f 67 85 70
	fb ff ff	 packuswb xmm0, XMMWORD PTR $T11[ebp]
  0070a	0f 29 85 60 fb
	ff ff		 movaps	 XMMWORD PTR $T10[ebp], xmm0
  00711	0f 28 85 60 fb
	ff ff		 movaps	 xmm0, XMMWORD PTR $T10[ebp]
  00718	0f 29 85 90 fb
	ff ff		 movaps	 XMMWORD PTR _x0$13[ebp], xmm0

; 665  :         __m128i x1 = _mm_packus_epi16(_mm_and_si128(xMask, x13_0), _mm_and_si128(xMask, x13_1));

  0071f	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _xMask$[ebp]
  00723	66 0f db 85 d0
	fb ff ff	 pand	 xmm0, XMMWORD PTR _x13_1$17[ebp]
  0072b	0f 29 85 30 fb
	ff ff		 movaps	 XMMWORD PTR $T7[ebp], xmm0
  00732	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _xMask$[ebp]
  00736	66 0f db 85 10
	fc ff ff	 pand	 xmm0, XMMWORD PTR _x13_0$21[ebp]
  0073e	0f 29 85 40 fb
	ff ff		 movaps	 XMMWORD PTR $T8[ebp], xmm0
  00745	0f 28 85 40 fb
	ff ff		 movaps	 xmm0, XMMWORD PTR $T8[ebp]
  0074c	66 0f 67 85 30
	fb ff ff	 packuswb xmm0, XMMWORD PTR $T7[ebp]
  00754	0f 29 85 20 fb
	ff ff		 movaps	 XMMWORD PTR $T6[ebp], xmm0
  0075b	0f 28 85 20 fb
	ff ff		 movaps	 xmm0, XMMWORD PTR $T6[ebp]
  00762	0f 29 85 50 fb
	ff ff		 movaps	 XMMWORD PTR _x1$9[ebp], xmm0

; 666  :         __m128i x2 = _mm_packus_epi16(_mm_srli_epi16(x02_0, 8), _mm_srli_epi16(x02_1, 8));

  00769	0f 28 85 50 fc
	ff ff		 movaps	 xmm0, XMMWORD PTR _x02_1$25[ebp]
  00770	66 0f 71 d0 08	 psrlw	 xmm0, 8
  00775	0f 29 85 f0 fa
	ff ff		 movaps	 XMMWORD PTR $T3[ebp], xmm0
  0077c	0f 28 85 90 fc
	ff ff		 movaps	 xmm0, XMMWORD PTR _x02_0$29[ebp]
  00783	66 0f 71 d0 08	 psrlw	 xmm0, 8
  00788	0f 29 85 00 fb
	ff ff		 movaps	 XMMWORD PTR $T4[ebp], xmm0
  0078f	0f 28 85 00 fb
	ff ff		 movaps	 xmm0, XMMWORD PTR $T4[ebp]
  00796	66 0f 67 85 f0
	fa ff ff	 packuswb xmm0, XMMWORD PTR $T3[ebp]
  0079e	0f 29 85 e0 fa
	ff ff		 movaps	 XMMWORD PTR $T2[ebp], xmm0
  007a5	0f 28 85 e0 fa
	ff ff		 movaps	 xmm0, XMMWORD PTR $T2[ebp]
  007ac	0f 29 85 10 fb
	ff ff		 movaps	 XMMWORD PTR _x2$5[ebp], xmm0

; 667  :         //__m128i x3 = _mm_packus_epi16(_mm_srli_epi16(x13_0), 8), _mm_srli_epi16(x13_1), 8));
; 668  : 
; 669  :         _mm_storeu_si128((__m128i *)ptr_dst0, x0);

  007b3	0f 10 85 90 fb
	ff ff		 movups	 xmm0, XMMWORD PTR _x0$13[ebp]
  007ba	8b 55 84	 mov	 edx, DWORD PTR _ptr_dst0$79[ebp]
  007bd	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 670  :         _mm_storeu_si128((__m128i *)ptr_dst1, x1);

  007c0	0f 10 85 50 fb
	ff ff		 movups	 xmm0, XMMWORD PTR _x1$9[ebp]
  007c7	8b 45 80	 mov	 eax, DWORD PTR _ptr_dst1$78[ebp]
  007ca	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 671  :         _mm_storeu_si128((__m128i *)ptr_dst2, x2);

  007cd	0f 10 85 10 fb
	ff ff		 movups	 xmm0, XMMWORD PTR _x2$5[ebp]
  007d4	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _ptr_dst2$77[ebp]
  007da	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 672  :     }

  007dd	e9 9b f9 ff ff	 jmp	 $LN2@convert_rg
$LN1@convert_rg:

; 673  : }

  007e2	52		 push	 edx
  007e3	8b cd		 mov	 ecx, ebp
  007e5	50		 push	 eax
  007e6	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN15@convert_rg
  007ec	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  007f1	58		 pop	 eax
  007f2	5a		 pop	 edx
  007f3	5f		 pop	 edi
  007f4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  007f7	33 cd		 xor	 ecx, ebp
  007f9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  007fe	8b e5		 mov	 esp, ebp
  00800	5d		 pop	 ebp
  00801	8b e3		 mov	 esp, ebx
  00803	5b		 pop	 ebx
  00804	c3		 ret	 0
  00805	0f 1f 00	 npad	 3
$LN15@convert_rg:
  00808	01 00 00 00	 DD	 1
  0080c	00 00 00 00	 DD	 $LN14@convert_rg
$LN14@convert_rg:
  00810	dc ff ff ff	 DD	 -36			; ffffffdcH
  00814	0c 00 00 00	 DD	 12			; 0000000cH
  00818	00 00 00 00	 DD	 $LN13@convert_rg
$LN13@convert_rg:
  0081c	79		 DB	 121			; 00000079H
  0081d	5f		 DB	 95			; 0000005fH
  0081e	72		 DB	 114			; 00000072H
  0081f	61		 DB	 97			; 00000061H
  00820	6e		 DB	 110			; 0000006eH
  00821	67		 DB	 103			; 00000067H
  00822	65		 DB	 101			; 00000065H
  00823	00		 DB	 0
??$convert_rgb32_to_rgb_simd@$0PPAAABAC@$00@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_rgb32_to_rgb_simd<4278190338,1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_sse2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_rgb32r_to_rgb_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_rgb32r_to_rgb_sse2

; 73   : void convert_rgb32r_to_rgb_sse2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 74   :     convert_rgb32_to_rgb_simd<RGB_PLANE(2, 1, 0, -1), true>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_rgb32_to_rgb_simd@$0PPAAABAC@$00@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_rgb32_to_rgb_simd<4278190338,1>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 75   : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_rgb32r_to_rgb_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_rgb32r_to_rgb_sse2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
tv130 = -1332						; size = 4
$T1 = -1328						; size = 12
$T2 = -1312						; size = 16
$T3 = -1296						; size = 16
$T4 = -1280						; size = 16
_x2$5 = -1264						; size = 16
$T6 = -1248						; size = 16
$T7 = -1232						; size = 16
$T8 = -1216						; size = 16
_x1$9 = -1200						; size = 16
$T10 = -1184						; size = 16
$T11 = -1168						; size = 16
$T12 = -1152						; size = 16
_x0$13 = -1136						; size = 16
$T14 = -1120						; size = 16
$T15 = -1104						; size = 16
$T16 = -1088						; size = 16
_x13_1$17 = -1072					; size = 16
$T18 = -1056						; size = 16
$T19 = -1040						; size = 16
$T20 = -1024						; size = 16
_x13_0$21 = -1008					; size = 16
$T22 = -992						; size = 16
$T23 = -976						; size = 16
$T24 = -960						; size = 16
_x02_1$25 = -944					; size = 16
$T26 = -928						; size = 16
$T27 = -912						; size = 16
$T28 = -896						; size = 16
_x02_0$29 = -880					; size = 16
$T30 = -864						; size = 16
_xSrc3$31 = -848					; size = 16
$T32 = -832						; size = 16
_xSrc2$33 = -816					; size = 16
$T34 = -800						; size = 16
_xSrc1$35 = -784					; size = 16
$T36 = -768						; size = 16
_xSrc0$37 = -752					; size = 16
_x_offset$38 = -724					; size = 4
$T39 = -720						; size = 16
$T40 = -704						; size = 16
$T41 = -688						; size = 16
_x2$42 = -672						; size = 16
$T43 = -656						; size = 16
$T44 = -640						; size = 16
$T45 = -624						; size = 16
_x1$46 = -608						; size = 16
$T47 = -592						; size = 16
$T48 = -576						; size = 16
$T49 = -560						; size = 16
_x0$50 = -544						; size = 16
$T51 = -528						; size = 16
$T52 = -512						; size = 16
$T53 = -496						; size = 16
_x13_1$54 = -480					; size = 16
$T55 = -464						; size = 16
$T56 = -448						; size = 16
$T57 = -432						; size = 16
_x13_0$58 = -416					; size = 16
$T59 = -400						; size = 16
$T60 = -384						; size = 16
$T61 = -368						; size = 16
_x02_1$62 = -352					; size = 16
$T63 = -336						; size = 16
$T64 = -320						; size = 16
$T65 = -304						; size = 16
_x02_0$66 = -288					; size = 16
$T67 = -272						; size = 16
_xSrc3$68 = -256					; size = 16
$T69 = -240						; size = 16
_xSrc2$70 = -224					; size = 16
$T71 = -208						; size = 16
_xSrc1$72 = -192					; size = 16
$T73 = -176						; size = 16
_xSrc0$74 = -160					; size = 16
_x_fin$75 = -140					; size = 4
_x$76 = -136						; size = 4
_ptr_dst2$77 = -132					; size = 4
_ptr_dst1$78 = -128					; size = 4
_ptr_dst0$79 = -124					; size = 4
_ptr_src$80 = -120					; size = 4
_y$81 = -116						; size = 4
$T82 = -112						; size = 16
_xMask$ = -96						; size = 16
_srcLine$ = -68						; size = 4
_dst2Line$ = -64					; size = 4
_dst1Line$ = -60					; size = 4
_dst0Line$ = -56					; size = 4
$T83 = -52						; size = 12
_y_range$ = -36						; size = 12
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_rgb32_to_rgb_simd@$0PPACABAA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_rgb32_to_rgb_simd<4278321408,0>

; 607  : static void __forceinline convert_rgb32_to_rgb_simd(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 40 05 00
	00		 sub	 esp, 1344		; 00000540H
  0001c	57		 push	 edi
  0001d	8d bd c0 fa ff
	ff		 lea	 edi, DWORD PTR [ebp-1344]
  00023	b9 50 01 00 00	 mov	 ecx, 336		; 00000150H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 608  :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 609  :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 610  :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 611  :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 612  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  0007c	8b 53 2c	 mov	 edx, DWORD PTR _thread_n$[ebx]
  0007f	52		 push	 edx
  00080	8b 43 28	 mov	 eax, DWORD PTR _thread_id$[ebx]
  00083	50		 push	 eax
  00084	8b 4b 20	 mov	 ecx, DWORD PTR _height$[ebx]
  00087	2b 4d ec	 sub	 ecx, DWORD PTR _crop_bottom$[ebp]
  0008a	51		 push	 ecx
  0008b	8b 55 f4	 mov	 edx, DWORD PTR _crop_up$[ebp]
  0008e	52		 push	 edx
  0008f	8d 85 d0 fa ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  00095	50		 push	 eax
  00096	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  0009b	83 c4 14	 add	 esp, 20			; 00000014H
  0009e	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a0	89 4d cc	 mov	 DWORD PTR $T83[ebp], ecx
  000a3	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a6	89 55 d0	 mov	 DWORD PTR $T83[ebp+4], edx
  000a9	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000ac	89 45 d4	 mov	 DWORD PTR $T83[ebp+8], eax
  000af	8b 4d cc	 mov	 ecx, DWORD PTR $T83[ebp]
  000b2	89 4d dc	 mov	 DWORD PTR _y_range$[ebp], ecx
  000b5	8b 55 d0	 mov	 edx, DWORD PTR $T83[ebp+4]
  000b8	89 55 e0	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000bb	8b 45 d4	 mov	 eax, DWORD PTR $T83[ebp+8]
  000be	89 45 e4	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 613  :     uint8_t *dst0Line = (uint8_t *)dst[(plane_from >>  0) & 0xff] + dst_y_pitch_byte * y_range.start_dst;

  000c1	b9 04 00 00 00	 mov	 ecx, 4
  000c6	6b d1 00	 imul	 edx, ecx, 0
  000c9	8b 43 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  000cc	0f af 45 e0	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  000d0	8b 4b 08	 mov	 ecx, DWORD PTR _dst$[ebx]
  000d3	03 04 11	 add	 eax, DWORD PTR [ecx+edx]
  000d6	89 45 c8	 mov	 DWORD PTR _dst0Line$[ebp], eax

; 614  :     uint8_t *dst1Line = (uint8_t *)dst[(plane_from >>  8) & 0xff] + dst_y_pitch_byte * y_range.start_dst;

  000d9	ba 04 00 00 00	 mov	 edx, 4
  000de	c1 e2 00	 shl	 edx, 0
  000e1	8b 43 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  000e4	0f af 45 e0	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  000e8	8b 4b 08	 mov	 ecx, DWORD PTR _dst$[ebx]
  000eb	03 04 11	 add	 eax, DWORD PTR [ecx+edx]
  000ee	89 45 c4	 mov	 DWORD PTR _dst1Line$[ebp], eax

; 615  :     uint8_t *dst2Line = (uint8_t *)dst[(plane_from >> 16) & 0xff] + dst_y_pitch_byte * y_range.start_dst;

  000f1	ba 04 00 00 00	 mov	 edx, 4
  000f6	d1 e2		 shl	 edx, 1
  000f8	8b 43 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  000fb	0f af 45 e0	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  000ff	8b 4b 08	 mov	 ecx, DWORD PTR _dst$[ebx]
  00102	03 04 11	 add	 eax, DWORD PTR [ecx+edx]
  00105	89 45 c0	 mov	 DWORD PTR _dst2Line$[ebp], eax

; 616  :     uint8_t *srcLine  = (uint8_t *)src[0] + src_y_pitch_byte * ((source_reverse) ? (height - crop_bottom - y_range.start_src - 1) : y_range.start_src) + crop_left * 4;

  00108	33 d2		 xor	 edx, edx
  0010a	74 14		 je	 SHORT $LN11@convert_rg
  0010c	8b 43 20	 mov	 eax, DWORD PTR _height$[ebx]
  0010f	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  00112	2b 45 dc	 sub	 eax, DWORD PTR _y_range$[ebp]
  00115	83 e8 01	 sub	 eax, 1
  00118	89 85 cc fa ff
	ff		 mov	 DWORD PTR tv130[ebp], eax
  0011e	eb 09		 jmp	 SHORT $LN12@convert_rg
$LN11@convert_rg:
  00120	8b 4d dc	 mov	 ecx, DWORD PTR _y_range$[ebp]
  00123	89 8d cc fa ff
	ff		 mov	 DWORD PTR tv130[ebp], ecx
$LN12@convert_rg:
  00129	ba 04 00 00 00	 mov	 edx, 4
  0012e	6b c2 00	 imul	 eax, edx, 0
  00131	8b 4b 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebx]
  00134	0f af 8d cc fa
	ff ff		 imul	 ecx, DWORD PTR tv130[ebp]
  0013b	8b 53 0c	 mov	 edx, DWORD PTR _src$[ebx]
  0013e	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  00141	03 c1		 add	 eax, ecx
  00143	8b 4d f8	 mov	 ecx, DWORD PTR _crop_left$[ebp]
  00146	8d 14 88	 lea	 edx, DWORD PTR [eax+ecx*4]
  00149	89 55 bc	 mov	 DWORD PTR _srcLine$[ebp], edx

; 617  :     __m128i xMask = _mm_set1_epi16(0xff);

  0014c	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@00ff00ff00ff00ff00ff00ff00ff00ff
  00153	0f 29 45 90	 movaps	 XMMWORD PTR $T82[ebp], xmm0
  00157	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR $T82[ebp]
  0015b	0f 29 45 a0	 movaps	 XMMWORD PTR _xMask$[ebp], xmm0

; 618  :     if (source_reverse) {

  0015f	33 c0		 xor	 eax, eax
  00161	74 07		 je	 SHORT $LN8@convert_rg

; 619  :         src_y_pitch_byte = -1 * src_y_pitch_byte;

  00163	6b 4b 14 ff	 imul	 ecx, DWORD PTR _src_y_pitch_byte$[ebx], -1
  00167	89 4b 14	 mov	 DWORD PTR _src_y_pitch_byte$[ebx], ecx
$LN8@convert_rg:

; 620  :     }
; 621  :     for (int y = 0; y < y_range.len; y++, srcLine += src_y_pitch_byte, dst0Line += dst_y_pitch_byte, dst1Line += dst_y_pitch_byte, dst2Line += dst_y_pitch_byte) {

  0016a	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR _y$81[ebp], 0
  00171	eb 2d		 jmp	 SHORT $LN4@convert_rg
$LN2@convert_rg:
  00173	8b 55 8c	 mov	 edx, DWORD PTR _y$81[ebp]
  00176	83 c2 01	 add	 edx, 1
  00179	89 55 8c	 mov	 DWORD PTR _y$81[ebp], edx
  0017c	8b 45 bc	 mov	 eax, DWORD PTR _srcLine$[ebp]
  0017f	03 43 14	 add	 eax, DWORD PTR _src_y_pitch_byte$[ebx]
  00182	89 45 bc	 mov	 DWORD PTR _srcLine$[ebp], eax
  00185	8b 4d c8	 mov	 ecx, DWORD PTR _dst0Line$[ebp]
  00188	03 4b 1c	 add	 ecx, DWORD PTR _dst_y_pitch_byte$[ebx]
  0018b	89 4d c8	 mov	 DWORD PTR _dst0Line$[ebp], ecx
  0018e	8b 55 c4	 mov	 edx, DWORD PTR _dst1Line$[ebp]
  00191	03 53 1c	 add	 edx, DWORD PTR _dst_y_pitch_byte$[ebx]
  00194	89 55 c4	 mov	 DWORD PTR _dst1Line$[ebp], edx
  00197	8b 45 c0	 mov	 eax, DWORD PTR _dst2Line$[ebp]
  0019a	03 43 1c	 add	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  0019d	89 45 c0	 mov	 DWORD PTR _dst2Line$[ebp], eax
$LN4@convert_rg:
  001a0	8b 4d 8c	 mov	 ecx, DWORD PTR _y$81[ebp]
  001a3	3b 4d e4	 cmp	 ecx, DWORD PTR _y_range$[ebp+8]
  001a6	0f 8d 2c 06 00
	00		 jge	 $LN1@convert_rg

; 622  :         uint8_t *ptr_src  = srcLine;

  001ac	8b 55 bc	 mov	 edx, DWORD PTR _srcLine$[ebp]
  001af	89 55 88	 mov	 DWORD PTR _ptr_src$80[ebp], edx

; 623  :         uint8_t *ptr_dst0 = dst0Line;

  001b2	8b 45 c8	 mov	 eax, DWORD PTR _dst0Line$[ebp]
  001b5	89 45 84	 mov	 DWORD PTR _ptr_dst0$79[ebp], eax

; 624  :         uint8_t *ptr_dst1 = dst1Line;

  001b8	8b 4d c4	 mov	 ecx, DWORD PTR _dst1Line$[ebp]
  001bb	89 4d 80	 mov	 DWORD PTR _ptr_dst1$78[ebp], ecx

; 625  :         uint8_t *ptr_dst2 = dst2Line;

  001be	8b 55 c0	 mov	 edx, DWORD PTR _dst2Line$[ebp]
  001c1	89 95 7c ff ff
	ff		 mov	 DWORD PTR _ptr_dst2$77[ebp], edx

; 626  :         int x = 0, x_fin = width - crop_left - crop_right - 16;

  001c7	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _x$76[ebp], 0
  001d1	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  001d4	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  001d7	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  001da	83 e8 10	 sub	 eax, 16			; 00000010H
  001dd	89 85 74 ff ff
	ff		 mov	 DWORD PTR _x_fin$75[ebp], eax

; 627  :         for (; x < x_fin; x += 16, ptr_src += 64, ptr_dst0 += 16, ptr_dst1 += 16, ptr_dst2 += 16) {

  001e3	eb 39		 jmp	 SHORT $LN7@convert_rg
$LN5@convert_rg:
  001e5	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _x$76[ebp]
  001eb	83 c1 10	 add	 ecx, 16			; 00000010H
  001ee	89 8d 78 ff ff
	ff		 mov	 DWORD PTR _x$76[ebp], ecx
  001f4	8b 55 88	 mov	 edx, DWORD PTR _ptr_src$80[ebp]
  001f7	83 c2 40	 add	 edx, 64			; 00000040H
  001fa	89 55 88	 mov	 DWORD PTR _ptr_src$80[ebp], edx
  001fd	8b 45 84	 mov	 eax, DWORD PTR _ptr_dst0$79[ebp]
  00200	83 c0 10	 add	 eax, 16			; 00000010H
  00203	89 45 84	 mov	 DWORD PTR _ptr_dst0$79[ebp], eax
  00206	8b 4d 80	 mov	 ecx, DWORD PTR _ptr_dst1$78[ebp]
  00209	83 c1 10	 add	 ecx, 16			; 00000010H
  0020c	89 4d 80	 mov	 DWORD PTR _ptr_dst1$78[ebp], ecx
  0020f	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR _ptr_dst2$77[ebp]
  00215	83 c2 10	 add	 edx, 16			; 00000010H
  00218	89 95 7c ff ff
	ff		 mov	 DWORD PTR _ptr_dst2$77[ebp], edx
$LN7@convert_rg:
  0021e	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _x$76[ebp]
  00224	3b 85 74 ff ff
	ff		 cmp	 eax, DWORD PTR _x_fin$75[ebp]
  0022a	0f 8d aa 02 00
	00		 jge	 $LN6@convert_rg

; 628  :             __m128i xSrc0 = _mm_loadu_si128((__m128i *)(ptr_src +  0));

  00230	8b 4d 88	 mov	 ecx, DWORD PTR _ptr_src$80[ebp]
  00233	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00236	0f 29 85 50 ff
	ff ff		 movaps	 XMMWORD PTR $T73[ebp], xmm0
  0023d	0f 28 85 50 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T73[ebp]
  00244	0f 29 85 60 ff
	ff ff		 movaps	 XMMWORD PTR _xSrc0$74[ebp], xmm0

; 629  :             __m128i xSrc1 = _mm_loadu_si128((__m128i *)(ptr_src + 16));

  0024b	8b 55 88	 mov	 edx, DWORD PTR _ptr_src$80[ebp]
  0024e	83 c2 10	 add	 edx, 16			; 00000010H
  00251	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  00254	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR $T71[ebp], xmm0
  0025b	0f 28 85 30 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T71[ebp]
  00262	0f 29 85 40 ff
	ff ff		 movaps	 XMMWORD PTR _xSrc1$72[ebp], xmm0

; 630  :             __m128i xSrc2 = _mm_loadu_si128((__m128i *)(ptr_src + 32));

  00269	8b 45 88	 mov	 eax, DWORD PTR _ptr_src$80[ebp]
  0026c	83 c0 20	 add	 eax, 32			; 00000020H
  0026f	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00272	0f 29 85 10 ff
	ff ff		 movaps	 XMMWORD PTR $T69[ebp], xmm0
  00279	0f 28 85 10 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T69[ebp]
  00280	0f 29 85 20 ff
	ff ff		 movaps	 XMMWORD PTR _xSrc2$70[ebp], xmm0

; 631  :             __m128i xSrc3 = _mm_loadu_si128((__m128i *)(ptr_src + 48));

  00287	8b 4d 88	 mov	 ecx, DWORD PTR _ptr_src$80[ebp]
  0028a	83 c1 30	 add	 ecx, 48			; 00000030H
  0028d	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00290	0f 29 85 f0 fe
	ff ff		 movaps	 XMMWORD PTR $T67[ebp], xmm0
  00297	0f 28 85 f0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T67[ebp]
  0029e	0f 29 85 00 ff
	ff ff		 movaps	 XMMWORD PTR _xSrc3$68[ebp], xmm0

; 632  : 
; 633  :             __m128i x02_0 = _mm_packus_epi16(_mm_and_si128(xMask, xSrc0), _mm_and_si128(xMask, xSrc1));

  002a5	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _xMask$[ebp]
  002a9	66 0f db 85 40
	ff ff ff	 pand	 xmm0, XMMWORD PTR _xSrc1$72[ebp]
  002b1	0f 29 85 c0 fe
	ff ff		 movaps	 XMMWORD PTR $T64[ebp], xmm0
  002b8	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _xMask$[ebp]
  002bc	66 0f db 85 60
	ff ff ff	 pand	 xmm0, XMMWORD PTR _xSrc0$74[ebp]
  002c4	0f 29 85 d0 fe
	ff ff		 movaps	 XMMWORD PTR $T65[ebp], xmm0
  002cb	0f 28 85 d0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T65[ebp]
  002d2	66 0f 67 85 c0
	fe ff ff	 packuswb xmm0, XMMWORD PTR $T64[ebp]
  002da	0f 29 85 b0 fe
	ff ff		 movaps	 XMMWORD PTR $T63[ebp], xmm0
  002e1	0f 28 85 b0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T63[ebp]
  002e8	0f 29 85 e0 fe
	ff ff		 movaps	 XMMWORD PTR _x02_0$66[ebp], xmm0

; 634  :             __m128i x02_1 = _mm_packus_epi16(_mm_and_si128(xMask, xSrc2), _mm_and_si128(xMask, xSrc3));

  002ef	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _xMask$[ebp]
  002f3	66 0f db 85 00
	ff ff ff	 pand	 xmm0, XMMWORD PTR _xSrc3$68[ebp]
  002fb	0f 29 85 80 fe
	ff ff		 movaps	 XMMWORD PTR $T60[ebp], xmm0
  00302	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _xMask$[ebp]
  00306	66 0f db 85 20
	ff ff ff	 pand	 xmm0, XMMWORD PTR _xSrc2$70[ebp]
  0030e	0f 29 85 90 fe
	ff ff		 movaps	 XMMWORD PTR $T61[ebp], xmm0
  00315	0f 28 85 90 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T61[ebp]
  0031c	66 0f 67 85 80
	fe ff ff	 packuswb xmm0, XMMWORD PTR $T60[ebp]
  00324	0f 29 85 70 fe
	ff ff		 movaps	 XMMWORD PTR $T59[ebp], xmm0
  0032b	0f 28 85 70 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T59[ebp]
  00332	0f 29 85 a0 fe
	ff ff		 movaps	 XMMWORD PTR _x02_1$62[ebp], xmm0

; 635  :             __m128i x13_0 = _mm_packus_epi16(_mm_srli_epi16(xSrc0, 8), _mm_srli_epi16(xSrc1, 8));

  00339	0f 28 85 40 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _xSrc1$72[ebp]
  00340	66 0f 71 d0 08	 psrlw	 xmm0, 8
  00345	0f 29 85 40 fe
	ff ff		 movaps	 XMMWORD PTR $T56[ebp], xmm0
  0034c	0f 28 85 60 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _xSrc0$74[ebp]
  00353	66 0f 71 d0 08	 psrlw	 xmm0, 8
  00358	0f 29 85 50 fe
	ff ff		 movaps	 XMMWORD PTR $T57[ebp], xmm0
  0035f	0f 28 85 50 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T57[ebp]
  00366	66 0f 67 85 40
	fe ff ff	 packuswb xmm0, XMMWORD PTR $T56[ebp]
  0036e	0f 29 85 30 fe
	ff ff		 movaps	 XMMWORD PTR $T55[ebp], xmm0
  00375	0f 28 85 30 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T55[ebp]
  0037c	0f 29 85 60 fe
	ff ff		 movaps	 XMMWORD PTR _x13_0$58[ebp], xmm0

; 636  :             __m128i x13_1 = _mm_packus_epi16(_mm_srli_epi16(xSrc2, 8), _mm_srli_epi16(xSrc3, 8));

  00383	0f 28 85 00 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _xSrc3$68[ebp]
  0038a	66 0f 71 d0 08	 psrlw	 xmm0, 8
  0038f	0f 29 85 00 fe
	ff ff		 movaps	 XMMWORD PTR $T52[ebp], xmm0
  00396	0f 28 85 20 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _xSrc2$70[ebp]
  0039d	66 0f 71 d0 08	 psrlw	 xmm0, 8
  003a2	0f 29 85 10 fe
	ff ff		 movaps	 XMMWORD PTR $T53[ebp], xmm0
  003a9	0f 28 85 10 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T53[ebp]
  003b0	66 0f 67 85 00
	fe ff ff	 packuswb xmm0, XMMWORD PTR $T52[ebp]
  003b8	0f 29 85 f0 fd
	ff ff		 movaps	 XMMWORD PTR $T51[ebp], xmm0
  003bf	0f 28 85 f0 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T51[ebp]
  003c6	0f 29 85 20 fe
	ff ff		 movaps	 XMMWORD PTR _x13_1$54[ebp], xmm0

; 637  : 
; 638  :             __m128i x0 = _mm_packus_epi16(_mm_and_si128(xMask, x02_0), _mm_and_si128(xMask, x02_1));

  003cd	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _xMask$[ebp]
  003d1	66 0f db 85 a0
	fe ff ff	 pand	 xmm0, XMMWORD PTR _x02_1$62[ebp]
  003d9	0f 29 85 c0 fd
	ff ff		 movaps	 XMMWORD PTR $T48[ebp], xmm0
  003e0	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _xMask$[ebp]
  003e4	66 0f db 85 e0
	fe ff ff	 pand	 xmm0, XMMWORD PTR _x02_0$66[ebp]
  003ec	0f 29 85 d0 fd
	ff ff		 movaps	 XMMWORD PTR $T49[ebp], xmm0
  003f3	0f 28 85 d0 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T49[ebp]
  003fa	66 0f 67 85 c0
	fd ff ff	 packuswb xmm0, XMMWORD PTR $T48[ebp]
  00402	0f 29 85 b0 fd
	ff ff		 movaps	 XMMWORD PTR $T47[ebp], xmm0
  00409	0f 28 85 b0 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T47[ebp]
  00410	0f 29 85 e0 fd
	ff ff		 movaps	 XMMWORD PTR _x0$50[ebp], xmm0

; 639  :             __m128i x1 = _mm_packus_epi16(_mm_and_si128(xMask, x13_0), _mm_and_si128(xMask, x13_1));

  00417	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _xMask$[ebp]
  0041b	66 0f db 85 20
	fe ff ff	 pand	 xmm0, XMMWORD PTR _x13_1$54[ebp]
  00423	0f 29 85 80 fd
	ff ff		 movaps	 XMMWORD PTR $T44[ebp], xmm0
  0042a	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _xMask$[ebp]
  0042e	66 0f db 85 60
	fe ff ff	 pand	 xmm0, XMMWORD PTR _x13_0$58[ebp]
  00436	0f 29 85 90 fd
	ff ff		 movaps	 XMMWORD PTR $T45[ebp], xmm0
  0043d	0f 28 85 90 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T45[ebp]
  00444	66 0f 67 85 80
	fd ff ff	 packuswb xmm0, XMMWORD PTR $T44[ebp]
  0044c	0f 29 85 70 fd
	ff ff		 movaps	 XMMWORD PTR $T43[ebp], xmm0
  00453	0f 28 85 70 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T43[ebp]
  0045a	0f 29 85 a0 fd
	ff ff		 movaps	 XMMWORD PTR _x1$46[ebp], xmm0

; 640  :             __m128i x2 = _mm_packus_epi16(_mm_srli_epi16(x02_0, 8), _mm_srli_epi16(x02_1, 8));

  00461	0f 28 85 a0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _x02_1$62[ebp]
  00468	66 0f 71 d0 08	 psrlw	 xmm0, 8
  0046d	0f 29 85 40 fd
	ff ff		 movaps	 XMMWORD PTR $T40[ebp], xmm0
  00474	0f 28 85 e0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _x02_0$66[ebp]
  0047b	66 0f 71 d0 08	 psrlw	 xmm0, 8
  00480	0f 29 85 50 fd
	ff ff		 movaps	 XMMWORD PTR $T41[ebp], xmm0
  00487	0f 28 85 50 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T41[ebp]
  0048e	66 0f 67 85 40
	fd ff ff	 packuswb xmm0, XMMWORD PTR $T40[ebp]
  00496	0f 29 85 30 fd
	ff ff		 movaps	 XMMWORD PTR $T39[ebp], xmm0
  0049d	0f 28 85 30 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T39[ebp]
  004a4	0f 29 85 60 fd
	ff ff		 movaps	 XMMWORD PTR _x2$42[ebp], xmm0

; 641  :             //__m128i x3 = _mm_packus_epi16(_mm_srli_epi16(x13_0, 8), _mm_srli_epi16(x13_1, 8));
; 642  : 
; 643  :             _mm_storeu_si128((__m128i *)ptr_dst0, x0);

  004ab	0f 10 85 e0 fd
	ff ff		 movups	 xmm0, XMMWORD PTR _x0$50[ebp]
  004b2	8b 55 84	 mov	 edx, DWORD PTR _ptr_dst0$79[ebp]
  004b5	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 644  :             _mm_storeu_si128((__m128i *)ptr_dst1, x1);

  004b8	0f 10 85 a0 fd
	ff ff		 movups	 xmm0, XMMWORD PTR _x1$46[ebp]
  004bf	8b 45 80	 mov	 eax, DWORD PTR _ptr_dst1$78[ebp]
  004c2	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 645  :             _mm_storeu_si128((__m128i *)ptr_dst2, x2);

  004c5	0f 10 85 60 fd
	ff ff		 movups	 xmm0, XMMWORD PTR _x2$42[ebp]
  004cc	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _ptr_dst2$77[ebp]
  004d2	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 646  :         }

  004d5	e9 0b fd ff ff	 jmp	 $LN5@convert_rg
$LN6@convert_rg:

; 647  :         if (width & 15) {

  004da	8b 53 10	 mov	 edx, DWORD PTR _width$[ebx]
  004dd	83 e2 0f	 and	 edx, 15			; 0000000fH
  004e0	74 4c		 je	 SHORT $LN9@convert_rg

; 648  :             int x_offset = (16 - (width & 15));

  004e2	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  004e5	83 e0 0f	 and	 eax, 15			; 0000000fH
  004e8	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  004ed	2b c8		 sub	 ecx, eax
  004ef	89 8d 2c fd ff
	ff		 mov	 DWORD PTR _x_offset$38[ebp], ecx

; 649  :             ptr_src -= x_offset * 3;

  004f5	6b 95 2c fd ff
	ff 03		 imul	 edx, DWORD PTR _x_offset$38[ebp], 3
  004fc	8b 45 88	 mov	 eax, DWORD PTR _ptr_src$80[ebp]
  004ff	2b c2		 sub	 eax, edx
  00501	89 45 88	 mov	 DWORD PTR _ptr_src$80[ebp], eax

; 650  :             ptr_dst0 -= x_offset;

  00504	8b 4d 84	 mov	 ecx, DWORD PTR _ptr_dst0$79[ebp]
  00507	2b 8d 2c fd ff
	ff		 sub	 ecx, DWORD PTR _x_offset$38[ebp]
  0050d	89 4d 84	 mov	 DWORD PTR _ptr_dst0$79[ebp], ecx

; 651  :             ptr_dst1 -= x_offset;

  00510	8b 55 80	 mov	 edx, DWORD PTR _ptr_dst1$78[ebp]
  00513	2b 95 2c fd ff
	ff		 sub	 edx, DWORD PTR _x_offset$38[ebp]
  00519	89 55 80	 mov	 DWORD PTR _ptr_dst1$78[ebp], edx

; 652  :             ptr_dst2 -= x_offset;

  0051c	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _ptr_dst2$77[ebp]
  00522	2b 85 2c fd ff
	ff		 sub	 eax, DWORD PTR _x_offset$38[ebp]
  00528	89 85 7c ff ff
	ff		 mov	 DWORD PTR _ptr_dst2$77[ebp], eax
$LN9@convert_rg:

; 653  :         }
; 654  :         __m128i xSrc0 = _mm_loadu_si128((__m128i *)(ptr_src +  0));

  0052e	8b 4d 88	 mov	 ecx, DWORD PTR _ptr_src$80[ebp]
  00531	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00534	0f 29 85 00 fd
	ff ff		 movaps	 XMMWORD PTR $T36[ebp], xmm0
  0053b	0f 28 85 00 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T36[ebp]
  00542	0f 29 85 10 fd
	ff ff		 movaps	 XMMWORD PTR _xSrc0$37[ebp], xmm0

; 655  :         __m128i xSrc1 = _mm_loadu_si128((__m128i *)(ptr_src + 16));

  00549	8b 55 88	 mov	 edx, DWORD PTR _ptr_src$80[ebp]
  0054c	83 c2 10	 add	 edx, 16			; 00000010H
  0054f	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  00552	0f 29 85 e0 fc
	ff ff		 movaps	 XMMWORD PTR $T34[ebp], xmm0
  00559	0f 28 85 e0 fc
	ff ff		 movaps	 xmm0, XMMWORD PTR $T34[ebp]
  00560	0f 29 85 f0 fc
	ff ff		 movaps	 XMMWORD PTR _xSrc1$35[ebp], xmm0

; 656  :         __m128i xSrc2 = _mm_loadu_si128((__m128i *)(ptr_src + 32));

  00567	8b 45 88	 mov	 eax, DWORD PTR _ptr_src$80[ebp]
  0056a	83 c0 20	 add	 eax, 32			; 00000020H
  0056d	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00570	0f 29 85 c0 fc
	ff ff		 movaps	 XMMWORD PTR $T32[ebp], xmm0
  00577	0f 28 85 c0 fc
	ff ff		 movaps	 xmm0, XMMWORD PTR $T32[ebp]
  0057e	0f 29 85 d0 fc
	ff ff		 movaps	 XMMWORD PTR _xSrc2$33[ebp], xmm0

; 657  :         __m128i xSrc3 = _mm_loadu_si128((__m128i *)(ptr_src + 48));

  00585	8b 4d 88	 mov	 ecx, DWORD PTR _ptr_src$80[ebp]
  00588	83 c1 30	 add	 ecx, 48			; 00000030H
  0058b	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  0058e	0f 29 85 a0 fc
	ff ff		 movaps	 XMMWORD PTR $T30[ebp], xmm0
  00595	0f 28 85 a0 fc
	ff ff		 movaps	 xmm0, XMMWORD PTR $T30[ebp]
  0059c	0f 29 85 b0 fc
	ff ff		 movaps	 XMMWORD PTR _xSrc3$31[ebp], xmm0

; 658  : 
; 659  :         __m128i x02_0 = _mm_packus_epi16(_mm_and_si128(xMask, xSrc0), _mm_and_si128(xMask, xSrc1));

  005a3	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _xMask$[ebp]
  005a7	66 0f db 85 f0
	fc ff ff	 pand	 xmm0, XMMWORD PTR _xSrc1$35[ebp]
  005af	0f 29 85 70 fc
	ff ff		 movaps	 XMMWORD PTR $T27[ebp], xmm0
  005b6	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _xMask$[ebp]
  005ba	66 0f db 85 10
	fd ff ff	 pand	 xmm0, XMMWORD PTR _xSrc0$37[ebp]
  005c2	0f 29 85 80 fc
	ff ff		 movaps	 XMMWORD PTR $T28[ebp], xmm0
  005c9	0f 28 85 80 fc
	ff ff		 movaps	 xmm0, XMMWORD PTR $T28[ebp]
  005d0	66 0f 67 85 70
	fc ff ff	 packuswb xmm0, XMMWORD PTR $T27[ebp]
  005d8	0f 29 85 60 fc
	ff ff		 movaps	 XMMWORD PTR $T26[ebp], xmm0
  005df	0f 28 85 60 fc
	ff ff		 movaps	 xmm0, XMMWORD PTR $T26[ebp]
  005e6	0f 29 85 90 fc
	ff ff		 movaps	 XMMWORD PTR _x02_0$29[ebp], xmm0

; 660  :         __m128i x02_1 = _mm_packus_epi16(_mm_and_si128(xMask, xSrc2), _mm_and_si128(xMask, xSrc3));

  005ed	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _xMask$[ebp]
  005f1	66 0f db 85 b0
	fc ff ff	 pand	 xmm0, XMMWORD PTR _xSrc3$31[ebp]
  005f9	0f 29 85 30 fc
	ff ff		 movaps	 XMMWORD PTR $T23[ebp], xmm0
  00600	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _xMask$[ebp]
  00604	66 0f db 85 d0
	fc ff ff	 pand	 xmm0, XMMWORD PTR _xSrc2$33[ebp]
  0060c	0f 29 85 40 fc
	ff ff		 movaps	 XMMWORD PTR $T24[ebp], xmm0
  00613	0f 28 85 40 fc
	ff ff		 movaps	 xmm0, XMMWORD PTR $T24[ebp]
  0061a	66 0f 67 85 30
	fc ff ff	 packuswb xmm0, XMMWORD PTR $T23[ebp]
  00622	0f 29 85 20 fc
	ff ff		 movaps	 XMMWORD PTR $T22[ebp], xmm0
  00629	0f 28 85 20 fc
	ff ff		 movaps	 xmm0, XMMWORD PTR $T22[ebp]
  00630	0f 29 85 50 fc
	ff ff		 movaps	 XMMWORD PTR _x02_1$25[ebp], xmm0

; 661  :         __m128i x13_0 = _mm_packus_epi16(_mm_srli_epi16(xSrc0, 8), _mm_srli_epi16(xSrc1, 8));

  00637	0f 28 85 f0 fc
	ff ff		 movaps	 xmm0, XMMWORD PTR _xSrc1$35[ebp]
  0063e	66 0f 71 d0 08	 psrlw	 xmm0, 8
  00643	0f 29 85 f0 fb
	ff ff		 movaps	 XMMWORD PTR $T19[ebp], xmm0
  0064a	0f 28 85 10 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR _xSrc0$37[ebp]
  00651	66 0f 71 d0 08	 psrlw	 xmm0, 8
  00656	0f 29 85 00 fc
	ff ff		 movaps	 XMMWORD PTR $T20[ebp], xmm0
  0065d	0f 28 85 00 fc
	ff ff		 movaps	 xmm0, XMMWORD PTR $T20[ebp]
  00664	66 0f 67 85 f0
	fb ff ff	 packuswb xmm0, XMMWORD PTR $T19[ebp]
  0066c	0f 29 85 e0 fb
	ff ff		 movaps	 XMMWORD PTR $T18[ebp], xmm0
  00673	0f 28 85 e0 fb
	ff ff		 movaps	 xmm0, XMMWORD PTR $T18[ebp]
  0067a	0f 29 85 10 fc
	ff ff		 movaps	 XMMWORD PTR _x13_0$21[ebp], xmm0

; 662  :         __m128i x13_1 = _mm_packus_epi16(_mm_srli_epi16(xSrc2, 8), _mm_srli_epi16(xSrc3, 8));

  00681	0f 28 85 b0 fc
	ff ff		 movaps	 xmm0, XMMWORD PTR _xSrc3$31[ebp]
  00688	66 0f 71 d0 08	 psrlw	 xmm0, 8
  0068d	0f 29 85 b0 fb
	ff ff		 movaps	 XMMWORD PTR $T15[ebp], xmm0
  00694	0f 28 85 d0 fc
	ff ff		 movaps	 xmm0, XMMWORD PTR _xSrc2$33[ebp]
  0069b	66 0f 71 d0 08	 psrlw	 xmm0, 8
  006a0	0f 29 85 c0 fb
	ff ff		 movaps	 XMMWORD PTR $T16[ebp], xmm0
  006a7	0f 28 85 c0 fb
	ff ff		 movaps	 xmm0, XMMWORD PTR $T16[ebp]
  006ae	66 0f 67 85 b0
	fb ff ff	 packuswb xmm0, XMMWORD PTR $T15[ebp]
  006b6	0f 29 85 a0 fb
	ff ff		 movaps	 XMMWORD PTR $T14[ebp], xmm0
  006bd	0f 28 85 a0 fb
	ff ff		 movaps	 xmm0, XMMWORD PTR $T14[ebp]
  006c4	0f 29 85 d0 fb
	ff ff		 movaps	 XMMWORD PTR _x13_1$17[ebp], xmm0

; 663  : 
; 664  :         __m128i x0 = _mm_packus_epi16(_mm_and_si128(xMask, x02_0), _mm_and_si128(xMask, x02_1));

  006cb	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _xMask$[ebp]
  006cf	66 0f db 85 50
	fc ff ff	 pand	 xmm0, XMMWORD PTR _x02_1$25[ebp]
  006d7	0f 29 85 70 fb
	ff ff		 movaps	 XMMWORD PTR $T11[ebp], xmm0
  006de	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _xMask$[ebp]
  006e2	66 0f db 85 90
	fc ff ff	 pand	 xmm0, XMMWORD PTR _x02_0$29[ebp]
  006ea	0f 29 85 80 fb
	ff ff		 movaps	 XMMWORD PTR $T12[ebp], xmm0
  006f1	0f 28 85 80 fb
	ff ff		 movaps	 xmm0, XMMWORD PTR $T12[ebp]
  006f8	66 0f 67 85 70
	fb ff ff	 packuswb xmm0, XMMWORD PTR $T11[ebp]
  00700	0f 29 85 60 fb
	ff ff		 movaps	 XMMWORD PTR $T10[ebp], xmm0
  00707	0f 28 85 60 fb
	ff ff		 movaps	 xmm0, XMMWORD PTR $T10[ebp]
  0070e	0f 29 85 90 fb
	ff ff		 movaps	 XMMWORD PTR _x0$13[ebp], xmm0

; 665  :         __m128i x1 = _mm_packus_epi16(_mm_and_si128(xMask, x13_0), _mm_and_si128(xMask, x13_1));

  00715	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _xMask$[ebp]
  00719	66 0f db 85 d0
	fb ff ff	 pand	 xmm0, XMMWORD PTR _x13_1$17[ebp]
  00721	0f 29 85 30 fb
	ff ff		 movaps	 XMMWORD PTR $T7[ebp], xmm0
  00728	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _xMask$[ebp]
  0072c	66 0f db 85 10
	fc ff ff	 pand	 xmm0, XMMWORD PTR _x13_0$21[ebp]
  00734	0f 29 85 40 fb
	ff ff		 movaps	 XMMWORD PTR $T8[ebp], xmm0
  0073b	0f 28 85 40 fb
	ff ff		 movaps	 xmm0, XMMWORD PTR $T8[ebp]
  00742	66 0f 67 85 30
	fb ff ff	 packuswb xmm0, XMMWORD PTR $T7[ebp]
  0074a	0f 29 85 20 fb
	ff ff		 movaps	 XMMWORD PTR $T6[ebp], xmm0
  00751	0f 28 85 20 fb
	ff ff		 movaps	 xmm0, XMMWORD PTR $T6[ebp]
  00758	0f 29 85 50 fb
	ff ff		 movaps	 XMMWORD PTR _x1$9[ebp], xmm0

; 666  :         __m128i x2 = _mm_packus_epi16(_mm_srli_epi16(x02_0, 8), _mm_srli_epi16(x02_1, 8));

  0075f	0f 28 85 50 fc
	ff ff		 movaps	 xmm0, XMMWORD PTR _x02_1$25[ebp]
  00766	66 0f 71 d0 08	 psrlw	 xmm0, 8
  0076b	0f 29 85 f0 fa
	ff ff		 movaps	 XMMWORD PTR $T3[ebp], xmm0
  00772	0f 28 85 90 fc
	ff ff		 movaps	 xmm0, XMMWORD PTR _x02_0$29[ebp]
  00779	66 0f 71 d0 08	 psrlw	 xmm0, 8
  0077e	0f 29 85 00 fb
	ff ff		 movaps	 XMMWORD PTR $T4[ebp], xmm0
  00785	0f 28 85 00 fb
	ff ff		 movaps	 xmm0, XMMWORD PTR $T4[ebp]
  0078c	66 0f 67 85 f0
	fa ff ff	 packuswb xmm0, XMMWORD PTR $T3[ebp]
  00794	0f 29 85 e0 fa
	ff ff		 movaps	 XMMWORD PTR $T2[ebp], xmm0
  0079b	0f 28 85 e0 fa
	ff ff		 movaps	 xmm0, XMMWORD PTR $T2[ebp]
  007a2	0f 29 85 10 fb
	ff ff		 movaps	 XMMWORD PTR _x2$5[ebp], xmm0

; 667  :         //__m128i x3 = _mm_packus_epi16(_mm_srli_epi16(x13_0), 8), _mm_srli_epi16(x13_1), 8));
; 668  : 
; 669  :         _mm_storeu_si128((__m128i *)ptr_dst0, x0);

  007a9	0f 10 85 90 fb
	ff ff		 movups	 xmm0, XMMWORD PTR _x0$13[ebp]
  007b0	8b 55 84	 mov	 edx, DWORD PTR _ptr_dst0$79[ebp]
  007b3	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 670  :         _mm_storeu_si128((__m128i *)ptr_dst1, x1);

  007b6	0f 10 85 50 fb
	ff ff		 movups	 xmm0, XMMWORD PTR _x1$9[ebp]
  007bd	8b 45 80	 mov	 eax, DWORD PTR _ptr_dst1$78[ebp]
  007c0	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 671  :         _mm_storeu_si128((__m128i *)ptr_dst2, x2);

  007c3	0f 10 85 10 fb
	ff ff		 movups	 xmm0, XMMWORD PTR _x2$5[ebp]
  007ca	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _ptr_dst2$77[ebp]
  007d0	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 672  :     }

  007d3	e9 9b f9 ff ff	 jmp	 $LN2@convert_rg
$LN1@convert_rg:

; 673  : }

  007d8	52		 push	 edx
  007d9	8b cd		 mov	 ecx, ebp
  007db	50		 push	 eax
  007dc	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN15@convert_rg
  007e2	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  007e7	58		 pop	 eax
  007e8	5a		 pop	 edx
  007e9	5f		 pop	 edi
  007ea	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  007ed	33 cd		 xor	 ecx, ebp
  007ef	e8 00 00 00 00	 call	 @__security_check_cookie@4
  007f4	8b e5		 mov	 esp, ebp
  007f6	5d		 pop	 ebp
  007f7	8b e3		 mov	 esp, ebx
  007f9	5b		 pop	 ebx
  007fa	c3		 ret	 0
  007fb	90		 npad	 1
$LN15@convert_rg:
  007fc	01 00 00 00	 DD	 1
  00800	00 00 00 00	 DD	 $LN14@convert_rg
$LN14@convert_rg:
  00804	dc ff ff ff	 DD	 -36			; ffffffdcH
  00808	0c 00 00 00	 DD	 12			; 0000000cH
  0080c	00 00 00 00	 DD	 $LN13@convert_rg
$LN13@convert_rg:
  00810	79		 DB	 121			; 00000079H
  00811	5f		 DB	 95			; 0000005fH
  00812	72		 DB	 114			; 00000072H
  00813	61		 DB	 97			; 00000061H
  00814	6e		 DB	 110			; 0000006eH
  00815	67		 DB	 103			; 00000067H
  00816	65		 DB	 101			; 00000065H
  00817	00		 DB	 0
??$convert_rgb32_to_rgb_simd@$0PPACABAA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_rgb32_to_rgb_simd<4278321408,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_sse2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_bgr32_to_rgb_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_bgr32_to_rgb_sse2

; 69   : void convert_bgr32_to_rgb_sse2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 70   :     convert_rgb32_to_rgb_simd<RGB_PLANE(0, 1, 2, -1), false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_rgb32_to_rgb_simd@$0PPACABAA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_rgb32_to_rgb_simd<4278321408,0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 71   : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_bgr32_to_rgb_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_bgr32_to_rgb_sse2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
tv130 = -1332						; size = 4
$T1 = -1328						; size = 12
$T2 = -1312						; size = 16
$T3 = -1296						; size = 16
$T4 = -1280						; size = 16
_x2$5 = -1264						; size = 16
$T6 = -1248						; size = 16
$T7 = -1232						; size = 16
$T8 = -1216						; size = 16
_x1$9 = -1200						; size = 16
$T10 = -1184						; size = 16
$T11 = -1168						; size = 16
$T12 = -1152						; size = 16
_x0$13 = -1136						; size = 16
$T14 = -1120						; size = 16
$T15 = -1104						; size = 16
$T16 = -1088						; size = 16
_x13_1$17 = -1072					; size = 16
$T18 = -1056						; size = 16
$T19 = -1040						; size = 16
$T20 = -1024						; size = 16
_x13_0$21 = -1008					; size = 16
$T22 = -992						; size = 16
$T23 = -976						; size = 16
$T24 = -960						; size = 16
_x02_1$25 = -944					; size = 16
$T26 = -928						; size = 16
$T27 = -912						; size = 16
$T28 = -896						; size = 16
_x02_0$29 = -880					; size = 16
$T30 = -864						; size = 16
_xSrc3$31 = -848					; size = 16
$T32 = -832						; size = 16
_xSrc2$33 = -816					; size = 16
$T34 = -800						; size = 16
_xSrc1$35 = -784					; size = 16
$T36 = -768						; size = 16
_xSrc0$37 = -752					; size = 16
_x_offset$38 = -724					; size = 4
$T39 = -720						; size = 16
$T40 = -704						; size = 16
$T41 = -688						; size = 16
_x2$42 = -672						; size = 16
$T43 = -656						; size = 16
$T44 = -640						; size = 16
$T45 = -624						; size = 16
_x1$46 = -608						; size = 16
$T47 = -592						; size = 16
$T48 = -576						; size = 16
$T49 = -560						; size = 16
_x0$50 = -544						; size = 16
$T51 = -528						; size = 16
$T52 = -512						; size = 16
$T53 = -496						; size = 16
_x13_1$54 = -480					; size = 16
$T55 = -464						; size = 16
$T56 = -448						; size = 16
$T57 = -432						; size = 16
_x13_0$58 = -416					; size = 16
$T59 = -400						; size = 16
$T60 = -384						; size = 16
$T61 = -368						; size = 16
_x02_1$62 = -352					; size = 16
$T63 = -336						; size = 16
$T64 = -320						; size = 16
$T65 = -304						; size = 16
_x02_0$66 = -288					; size = 16
$T67 = -272						; size = 16
_xSrc3$68 = -256					; size = 16
$T69 = -240						; size = 16
_xSrc2$70 = -224					; size = 16
$T71 = -208						; size = 16
_xSrc1$72 = -192					; size = 16
$T73 = -176						; size = 16
_xSrc0$74 = -160					; size = 16
_x_fin$75 = -140					; size = 4
_x$76 = -136						; size = 4
_ptr_dst2$77 = -132					; size = 4
_ptr_dst1$78 = -128					; size = 4
_ptr_dst0$79 = -124					; size = 4
_ptr_src$80 = -120					; size = 4
_y$81 = -116						; size = 4
$T82 = -112						; size = 16
_xMask$ = -96						; size = 16
_srcLine$ = -68						; size = 4
_dst2Line$ = -64					; size = 4
_dst1Line$ = -60					; size = 4
_dst0Line$ = -56					; size = 4
$T83 = -52						; size = 12
_y_range$ = -36						; size = 12
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_rgb32_to_rgb_simd@$0PPAAABAC@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_rgb32_to_rgb_simd<4278190338,0>

; 607  : static void __forceinline convert_rgb32_to_rgb_simd(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 40 05 00
	00		 sub	 esp, 1344		; 00000540H
  0001c	57		 push	 edi
  0001d	8d bd c0 fa ff
	ff		 lea	 edi, DWORD PTR [ebp-1344]
  00023	b9 50 01 00 00	 mov	 ecx, 336		; 00000150H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 608  :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 609  :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 610  :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 611  :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 612  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  0007c	8b 53 2c	 mov	 edx, DWORD PTR _thread_n$[ebx]
  0007f	52		 push	 edx
  00080	8b 43 28	 mov	 eax, DWORD PTR _thread_id$[ebx]
  00083	50		 push	 eax
  00084	8b 4b 20	 mov	 ecx, DWORD PTR _height$[ebx]
  00087	2b 4d ec	 sub	 ecx, DWORD PTR _crop_bottom$[ebp]
  0008a	51		 push	 ecx
  0008b	8b 55 f4	 mov	 edx, DWORD PTR _crop_up$[ebp]
  0008e	52		 push	 edx
  0008f	8d 85 d0 fa ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  00095	50		 push	 eax
  00096	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  0009b	83 c4 14	 add	 esp, 20			; 00000014H
  0009e	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a0	89 4d cc	 mov	 DWORD PTR $T83[ebp], ecx
  000a3	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a6	89 55 d0	 mov	 DWORD PTR $T83[ebp+4], edx
  000a9	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000ac	89 45 d4	 mov	 DWORD PTR $T83[ebp+8], eax
  000af	8b 4d cc	 mov	 ecx, DWORD PTR $T83[ebp]
  000b2	89 4d dc	 mov	 DWORD PTR _y_range$[ebp], ecx
  000b5	8b 55 d0	 mov	 edx, DWORD PTR $T83[ebp+4]
  000b8	89 55 e0	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000bb	8b 45 d4	 mov	 eax, DWORD PTR $T83[ebp+8]
  000be	89 45 e4	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 613  :     uint8_t *dst0Line = (uint8_t *)dst[(plane_from >>  0) & 0xff] + dst_y_pitch_byte * y_range.start_dst;

  000c1	b9 04 00 00 00	 mov	 ecx, 4
  000c6	d1 e1		 shl	 ecx, 1
  000c8	8b 53 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebx]
  000cb	0f af 55 e0	 imul	 edx, DWORD PTR _y_range$[ebp+4]
  000cf	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  000d2	03 14 08	 add	 edx, DWORD PTR [eax+ecx]
  000d5	89 55 c8	 mov	 DWORD PTR _dst0Line$[ebp], edx

; 614  :     uint8_t *dst1Line = (uint8_t *)dst[(plane_from >>  8) & 0xff] + dst_y_pitch_byte * y_range.start_dst;

  000d8	b9 04 00 00 00	 mov	 ecx, 4
  000dd	c1 e1 00	 shl	 ecx, 0
  000e0	8b 53 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebx]
  000e3	0f af 55 e0	 imul	 edx, DWORD PTR _y_range$[ebp+4]
  000e7	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  000ea	03 14 08	 add	 edx, DWORD PTR [eax+ecx]
  000ed	89 55 c4	 mov	 DWORD PTR _dst1Line$[ebp], edx

; 615  :     uint8_t *dst2Line = (uint8_t *)dst[(plane_from >> 16) & 0xff] + dst_y_pitch_byte * y_range.start_dst;

  000f0	b9 04 00 00 00	 mov	 ecx, 4
  000f5	6b d1 00	 imul	 edx, ecx, 0
  000f8	8b 43 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  000fb	0f af 45 e0	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  000ff	8b 4b 08	 mov	 ecx, DWORD PTR _dst$[ebx]
  00102	03 04 11	 add	 eax, DWORD PTR [ecx+edx]
  00105	89 45 c0	 mov	 DWORD PTR _dst2Line$[ebp], eax

; 616  :     uint8_t *srcLine  = (uint8_t *)src[0] + src_y_pitch_byte * ((source_reverse) ? (height - crop_bottom - y_range.start_src - 1) : y_range.start_src) + crop_left * 4;

  00108	33 d2		 xor	 edx, edx
  0010a	74 14		 je	 SHORT $LN11@convert_rg
  0010c	8b 43 20	 mov	 eax, DWORD PTR _height$[ebx]
  0010f	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  00112	2b 45 dc	 sub	 eax, DWORD PTR _y_range$[ebp]
  00115	83 e8 01	 sub	 eax, 1
  00118	89 85 cc fa ff
	ff		 mov	 DWORD PTR tv130[ebp], eax
  0011e	eb 09		 jmp	 SHORT $LN12@convert_rg
$LN11@convert_rg:
  00120	8b 4d dc	 mov	 ecx, DWORD PTR _y_range$[ebp]
  00123	89 8d cc fa ff
	ff		 mov	 DWORD PTR tv130[ebp], ecx
$LN12@convert_rg:
  00129	ba 04 00 00 00	 mov	 edx, 4
  0012e	6b c2 00	 imul	 eax, edx, 0
  00131	8b 4b 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebx]
  00134	0f af 8d cc fa
	ff ff		 imul	 ecx, DWORD PTR tv130[ebp]
  0013b	8b 53 0c	 mov	 edx, DWORD PTR _src$[ebx]
  0013e	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  00141	03 c1		 add	 eax, ecx
  00143	8b 4d f8	 mov	 ecx, DWORD PTR _crop_left$[ebp]
  00146	8d 14 88	 lea	 edx, DWORD PTR [eax+ecx*4]
  00149	89 55 bc	 mov	 DWORD PTR _srcLine$[ebp], edx

; 617  :     __m128i xMask = _mm_set1_epi16(0xff);

  0014c	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@00ff00ff00ff00ff00ff00ff00ff00ff
  00153	0f 29 45 90	 movaps	 XMMWORD PTR $T82[ebp], xmm0
  00157	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR $T82[ebp]
  0015b	0f 29 45 a0	 movaps	 XMMWORD PTR _xMask$[ebp], xmm0

; 618  :     if (source_reverse) {

  0015f	33 c0		 xor	 eax, eax
  00161	74 07		 je	 SHORT $LN8@convert_rg

; 619  :         src_y_pitch_byte = -1 * src_y_pitch_byte;

  00163	6b 4b 14 ff	 imul	 ecx, DWORD PTR _src_y_pitch_byte$[ebx], -1
  00167	89 4b 14	 mov	 DWORD PTR _src_y_pitch_byte$[ebx], ecx
$LN8@convert_rg:

; 620  :     }
; 621  :     for (int y = 0; y < y_range.len; y++, srcLine += src_y_pitch_byte, dst0Line += dst_y_pitch_byte, dst1Line += dst_y_pitch_byte, dst2Line += dst_y_pitch_byte) {

  0016a	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR _y$81[ebp], 0
  00171	eb 2d		 jmp	 SHORT $LN4@convert_rg
$LN2@convert_rg:
  00173	8b 55 8c	 mov	 edx, DWORD PTR _y$81[ebp]
  00176	83 c2 01	 add	 edx, 1
  00179	89 55 8c	 mov	 DWORD PTR _y$81[ebp], edx
  0017c	8b 45 bc	 mov	 eax, DWORD PTR _srcLine$[ebp]
  0017f	03 43 14	 add	 eax, DWORD PTR _src_y_pitch_byte$[ebx]
  00182	89 45 bc	 mov	 DWORD PTR _srcLine$[ebp], eax
  00185	8b 4d c8	 mov	 ecx, DWORD PTR _dst0Line$[ebp]
  00188	03 4b 1c	 add	 ecx, DWORD PTR _dst_y_pitch_byte$[ebx]
  0018b	89 4d c8	 mov	 DWORD PTR _dst0Line$[ebp], ecx
  0018e	8b 55 c4	 mov	 edx, DWORD PTR _dst1Line$[ebp]
  00191	03 53 1c	 add	 edx, DWORD PTR _dst_y_pitch_byte$[ebx]
  00194	89 55 c4	 mov	 DWORD PTR _dst1Line$[ebp], edx
  00197	8b 45 c0	 mov	 eax, DWORD PTR _dst2Line$[ebp]
  0019a	03 43 1c	 add	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  0019d	89 45 c0	 mov	 DWORD PTR _dst2Line$[ebp], eax
$LN4@convert_rg:
  001a0	8b 4d 8c	 mov	 ecx, DWORD PTR _y$81[ebp]
  001a3	3b 4d e4	 cmp	 ecx, DWORD PTR _y_range$[ebp+8]
  001a6	0f 8d 2c 06 00
	00		 jge	 $LN1@convert_rg

; 622  :         uint8_t *ptr_src  = srcLine;

  001ac	8b 55 bc	 mov	 edx, DWORD PTR _srcLine$[ebp]
  001af	89 55 88	 mov	 DWORD PTR _ptr_src$80[ebp], edx

; 623  :         uint8_t *ptr_dst0 = dst0Line;

  001b2	8b 45 c8	 mov	 eax, DWORD PTR _dst0Line$[ebp]
  001b5	89 45 84	 mov	 DWORD PTR _ptr_dst0$79[ebp], eax

; 624  :         uint8_t *ptr_dst1 = dst1Line;

  001b8	8b 4d c4	 mov	 ecx, DWORD PTR _dst1Line$[ebp]
  001bb	89 4d 80	 mov	 DWORD PTR _ptr_dst1$78[ebp], ecx

; 625  :         uint8_t *ptr_dst2 = dst2Line;

  001be	8b 55 c0	 mov	 edx, DWORD PTR _dst2Line$[ebp]
  001c1	89 95 7c ff ff
	ff		 mov	 DWORD PTR _ptr_dst2$77[ebp], edx

; 626  :         int x = 0, x_fin = width - crop_left - crop_right - 16;

  001c7	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _x$76[ebp], 0
  001d1	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  001d4	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  001d7	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  001da	83 e8 10	 sub	 eax, 16			; 00000010H
  001dd	89 85 74 ff ff
	ff		 mov	 DWORD PTR _x_fin$75[ebp], eax

; 627  :         for (; x < x_fin; x += 16, ptr_src += 64, ptr_dst0 += 16, ptr_dst1 += 16, ptr_dst2 += 16) {

  001e3	eb 39		 jmp	 SHORT $LN7@convert_rg
$LN5@convert_rg:
  001e5	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _x$76[ebp]
  001eb	83 c1 10	 add	 ecx, 16			; 00000010H
  001ee	89 8d 78 ff ff
	ff		 mov	 DWORD PTR _x$76[ebp], ecx
  001f4	8b 55 88	 mov	 edx, DWORD PTR _ptr_src$80[ebp]
  001f7	83 c2 40	 add	 edx, 64			; 00000040H
  001fa	89 55 88	 mov	 DWORD PTR _ptr_src$80[ebp], edx
  001fd	8b 45 84	 mov	 eax, DWORD PTR _ptr_dst0$79[ebp]
  00200	83 c0 10	 add	 eax, 16			; 00000010H
  00203	89 45 84	 mov	 DWORD PTR _ptr_dst0$79[ebp], eax
  00206	8b 4d 80	 mov	 ecx, DWORD PTR _ptr_dst1$78[ebp]
  00209	83 c1 10	 add	 ecx, 16			; 00000010H
  0020c	89 4d 80	 mov	 DWORD PTR _ptr_dst1$78[ebp], ecx
  0020f	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR _ptr_dst2$77[ebp]
  00215	83 c2 10	 add	 edx, 16			; 00000010H
  00218	89 95 7c ff ff
	ff		 mov	 DWORD PTR _ptr_dst2$77[ebp], edx
$LN7@convert_rg:
  0021e	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _x$76[ebp]
  00224	3b 85 74 ff ff
	ff		 cmp	 eax, DWORD PTR _x_fin$75[ebp]
  0022a	0f 8d aa 02 00
	00		 jge	 $LN6@convert_rg

; 628  :             __m128i xSrc0 = _mm_loadu_si128((__m128i *)(ptr_src +  0));

  00230	8b 4d 88	 mov	 ecx, DWORD PTR _ptr_src$80[ebp]
  00233	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00236	0f 29 85 50 ff
	ff ff		 movaps	 XMMWORD PTR $T73[ebp], xmm0
  0023d	0f 28 85 50 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T73[ebp]
  00244	0f 29 85 60 ff
	ff ff		 movaps	 XMMWORD PTR _xSrc0$74[ebp], xmm0

; 629  :             __m128i xSrc1 = _mm_loadu_si128((__m128i *)(ptr_src + 16));

  0024b	8b 55 88	 mov	 edx, DWORD PTR _ptr_src$80[ebp]
  0024e	83 c2 10	 add	 edx, 16			; 00000010H
  00251	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  00254	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR $T71[ebp], xmm0
  0025b	0f 28 85 30 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T71[ebp]
  00262	0f 29 85 40 ff
	ff ff		 movaps	 XMMWORD PTR _xSrc1$72[ebp], xmm0

; 630  :             __m128i xSrc2 = _mm_loadu_si128((__m128i *)(ptr_src + 32));

  00269	8b 45 88	 mov	 eax, DWORD PTR _ptr_src$80[ebp]
  0026c	83 c0 20	 add	 eax, 32			; 00000020H
  0026f	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00272	0f 29 85 10 ff
	ff ff		 movaps	 XMMWORD PTR $T69[ebp], xmm0
  00279	0f 28 85 10 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T69[ebp]
  00280	0f 29 85 20 ff
	ff ff		 movaps	 XMMWORD PTR _xSrc2$70[ebp], xmm0

; 631  :             __m128i xSrc3 = _mm_loadu_si128((__m128i *)(ptr_src + 48));

  00287	8b 4d 88	 mov	 ecx, DWORD PTR _ptr_src$80[ebp]
  0028a	83 c1 30	 add	 ecx, 48			; 00000030H
  0028d	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00290	0f 29 85 f0 fe
	ff ff		 movaps	 XMMWORD PTR $T67[ebp], xmm0
  00297	0f 28 85 f0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T67[ebp]
  0029e	0f 29 85 00 ff
	ff ff		 movaps	 XMMWORD PTR _xSrc3$68[ebp], xmm0

; 632  : 
; 633  :             __m128i x02_0 = _mm_packus_epi16(_mm_and_si128(xMask, xSrc0), _mm_and_si128(xMask, xSrc1));

  002a5	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _xMask$[ebp]
  002a9	66 0f db 85 40
	ff ff ff	 pand	 xmm0, XMMWORD PTR _xSrc1$72[ebp]
  002b1	0f 29 85 c0 fe
	ff ff		 movaps	 XMMWORD PTR $T64[ebp], xmm0
  002b8	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _xMask$[ebp]
  002bc	66 0f db 85 60
	ff ff ff	 pand	 xmm0, XMMWORD PTR _xSrc0$74[ebp]
  002c4	0f 29 85 d0 fe
	ff ff		 movaps	 XMMWORD PTR $T65[ebp], xmm0
  002cb	0f 28 85 d0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T65[ebp]
  002d2	66 0f 67 85 c0
	fe ff ff	 packuswb xmm0, XMMWORD PTR $T64[ebp]
  002da	0f 29 85 b0 fe
	ff ff		 movaps	 XMMWORD PTR $T63[ebp], xmm0
  002e1	0f 28 85 b0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T63[ebp]
  002e8	0f 29 85 e0 fe
	ff ff		 movaps	 XMMWORD PTR _x02_0$66[ebp], xmm0

; 634  :             __m128i x02_1 = _mm_packus_epi16(_mm_and_si128(xMask, xSrc2), _mm_and_si128(xMask, xSrc3));

  002ef	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _xMask$[ebp]
  002f3	66 0f db 85 00
	ff ff ff	 pand	 xmm0, XMMWORD PTR _xSrc3$68[ebp]
  002fb	0f 29 85 80 fe
	ff ff		 movaps	 XMMWORD PTR $T60[ebp], xmm0
  00302	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _xMask$[ebp]
  00306	66 0f db 85 20
	ff ff ff	 pand	 xmm0, XMMWORD PTR _xSrc2$70[ebp]
  0030e	0f 29 85 90 fe
	ff ff		 movaps	 XMMWORD PTR $T61[ebp], xmm0
  00315	0f 28 85 90 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T61[ebp]
  0031c	66 0f 67 85 80
	fe ff ff	 packuswb xmm0, XMMWORD PTR $T60[ebp]
  00324	0f 29 85 70 fe
	ff ff		 movaps	 XMMWORD PTR $T59[ebp], xmm0
  0032b	0f 28 85 70 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T59[ebp]
  00332	0f 29 85 a0 fe
	ff ff		 movaps	 XMMWORD PTR _x02_1$62[ebp], xmm0

; 635  :             __m128i x13_0 = _mm_packus_epi16(_mm_srli_epi16(xSrc0, 8), _mm_srli_epi16(xSrc1, 8));

  00339	0f 28 85 40 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _xSrc1$72[ebp]
  00340	66 0f 71 d0 08	 psrlw	 xmm0, 8
  00345	0f 29 85 40 fe
	ff ff		 movaps	 XMMWORD PTR $T56[ebp], xmm0
  0034c	0f 28 85 60 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _xSrc0$74[ebp]
  00353	66 0f 71 d0 08	 psrlw	 xmm0, 8
  00358	0f 29 85 50 fe
	ff ff		 movaps	 XMMWORD PTR $T57[ebp], xmm0
  0035f	0f 28 85 50 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T57[ebp]
  00366	66 0f 67 85 40
	fe ff ff	 packuswb xmm0, XMMWORD PTR $T56[ebp]
  0036e	0f 29 85 30 fe
	ff ff		 movaps	 XMMWORD PTR $T55[ebp], xmm0
  00375	0f 28 85 30 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T55[ebp]
  0037c	0f 29 85 60 fe
	ff ff		 movaps	 XMMWORD PTR _x13_0$58[ebp], xmm0

; 636  :             __m128i x13_1 = _mm_packus_epi16(_mm_srli_epi16(xSrc2, 8), _mm_srli_epi16(xSrc3, 8));

  00383	0f 28 85 00 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _xSrc3$68[ebp]
  0038a	66 0f 71 d0 08	 psrlw	 xmm0, 8
  0038f	0f 29 85 00 fe
	ff ff		 movaps	 XMMWORD PTR $T52[ebp], xmm0
  00396	0f 28 85 20 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _xSrc2$70[ebp]
  0039d	66 0f 71 d0 08	 psrlw	 xmm0, 8
  003a2	0f 29 85 10 fe
	ff ff		 movaps	 XMMWORD PTR $T53[ebp], xmm0
  003a9	0f 28 85 10 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T53[ebp]
  003b0	66 0f 67 85 00
	fe ff ff	 packuswb xmm0, XMMWORD PTR $T52[ebp]
  003b8	0f 29 85 f0 fd
	ff ff		 movaps	 XMMWORD PTR $T51[ebp], xmm0
  003bf	0f 28 85 f0 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T51[ebp]
  003c6	0f 29 85 20 fe
	ff ff		 movaps	 XMMWORD PTR _x13_1$54[ebp], xmm0

; 637  : 
; 638  :             __m128i x0 = _mm_packus_epi16(_mm_and_si128(xMask, x02_0), _mm_and_si128(xMask, x02_1));

  003cd	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _xMask$[ebp]
  003d1	66 0f db 85 a0
	fe ff ff	 pand	 xmm0, XMMWORD PTR _x02_1$62[ebp]
  003d9	0f 29 85 c0 fd
	ff ff		 movaps	 XMMWORD PTR $T48[ebp], xmm0
  003e0	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _xMask$[ebp]
  003e4	66 0f db 85 e0
	fe ff ff	 pand	 xmm0, XMMWORD PTR _x02_0$66[ebp]
  003ec	0f 29 85 d0 fd
	ff ff		 movaps	 XMMWORD PTR $T49[ebp], xmm0
  003f3	0f 28 85 d0 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T49[ebp]
  003fa	66 0f 67 85 c0
	fd ff ff	 packuswb xmm0, XMMWORD PTR $T48[ebp]
  00402	0f 29 85 b0 fd
	ff ff		 movaps	 XMMWORD PTR $T47[ebp], xmm0
  00409	0f 28 85 b0 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T47[ebp]
  00410	0f 29 85 e0 fd
	ff ff		 movaps	 XMMWORD PTR _x0$50[ebp], xmm0

; 639  :             __m128i x1 = _mm_packus_epi16(_mm_and_si128(xMask, x13_0), _mm_and_si128(xMask, x13_1));

  00417	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _xMask$[ebp]
  0041b	66 0f db 85 20
	fe ff ff	 pand	 xmm0, XMMWORD PTR _x13_1$54[ebp]
  00423	0f 29 85 80 fd
	ff ff		 movaps	 XMMWORD PTR $T44[ebp], xmm0
  0042a	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _xMask$[ebp]
  0042e	66 0f db 85 60
	fe ff ff	 pand	 xmm0, XMMWORD PTR _x13_0$58[ebp]
  00436	0f 29 85 90 fd
	ff ff		 movaps	 XMMWORD PTR $T45[ebp], xmm0
  0043d	0f 28 85 90 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T45[ebp]
  00444	66 0f 67 85 80
	fd ff ff	 packuswb xmm0, XMMWORD PTR $T44[ebp]
  0044c	0f 29 85 70 fd
	ff ff		 movaps	 XMMWORD PTR $T43[ebp], xmm0
  00453	0f 28 85 70 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T43[ebp]
  0045a	0f 29 85 a0 fd
	ff ff		 movaps	 XMMWORD PTR _x1$46[ebp], xmm0

; 640  :             __m128i x2 = _mm_packus_epi16(_mm_srli_epi16(x02_0, 8), _mm_srli_epi16(x02_1, 8));

  00461	0f 28 85 a0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _x02_1$62[ebp]
  00468	66 0f 71 d0 08	 psrlw	 xmm0, 8
  0046d	0f 29 85 40 fd
	ff ff		 movaps	 XMMWORD PTR $T40[ebp], xmm0
  00474	0f 28 85 e0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _x02_0$66[ebp]
  0047b	66 0f 71 d0 08	 psrlw	 xmm0, 8
  00480	0f 29 85 50 fd
	ff ff		 movaps	 XMMWORD PTR $T41[ebp], xmm0
  00487	0f 28 85 50 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T41[ebp]
  0048e	66 0f 67 85 40
	fd ff ff	 packuswb xmm0, XMMWORD PTR $T40[ebp]
  00496	0f 29 85 30 fd
	ff ff		 movaps	 XMMWORD PTR $T39[ebp], xmm0
  0049d	0f 28 85 30 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T39[ebp]
  004a4	0f 29 85 60 fd
	ff ff		 movaps	 XMMWORD PTR _x2$42[ebp], xmm0

; 641  :             //__m128i x3 = _mm_packus_epi16(_mm_srli_epi16(x13_0, 8), _mm_srli_epi16(x13_1, 8));
; 642  : 
; 643  :             _mm_storeu_si128((__m128i *)ptr_dst0, x0);

  004ab	0f 10 85 e0 fd
	ff ff		 movups	 xmm0, XMMWORD PTR _x0$50[ebp]
  004b2	8b 55 84	 mov	 edx, DWORD PTR _ptr_dst0$79[ebp]
  004b5	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 644  :             _mm_storeu_si128((__m128i *)ptr_dst1, x1);

  004b8	0f 10 85 a0 fd
	ff ff		 movups	 xmm0, XMMWORD PTR _x1$46[ebp]
  004bf	8b 45 80	 mov	 eax, DWORD PTR _ptr_dst1$78[ebp]
  004c2	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 645  :             _mm_storeu_si128((__m128i *)ptr_dst2, x2);

  004c5	0f 10 85 60 fd
	ff ff		 movups	 xmm0, XMMWORD PTR _x2$42[ebp]
  004cc	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _ptr_dst2$77[ebp]
  004d2	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 646  :         }

  004d5	e9 0b fd ff ff	 jmp	 $LN5@convert_rg
$LN6@convert_rg:

; 647  :         if (width & 15) {

  004da	8b 53 10	 mov	 edx, DWORD PTR _width$[ebx]
  004dd	83 e2 0f	 and	 edx, 15			; 0000000fH
  004e0	74 4c		 je	 SHORT $LN9@convert_rg

; 648  :             int x_offset = (16 - (width & 15));

  004e2	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  004e5	83 e0 0f	 and	 eax, 15			; 0000000fH
  004e8	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  004ed	2b c8		 sub	 ecx, eax
  004ef	89 8d 2c fd ff
	ff		 mov	 DWORD PTR _x_offset$38[ebp], ecx

; 649  :             ptr_src -= x_offset * 3;

  004f5	6b 95 2c fd ff
	ff 03		 imul	 edx, DWORD PTR _x_offset$38[ebp], 3
  004fc	8b 45 88	 mov	 eax, DWORD PTR _ptr_src$80[ebp]
  004ff	2b c2		 sub	 eax, edx
  00501	89 45 88	 mov	 DWORD PTR _ptr_src$80[ebp], eax

; 650  :             ptr_dst0 -= x_offset;

  00504	8b 4d 84	 mov	 ecx, DWORD PTR _ptr_dst0$79[ebp]
  00507	2b 8d 2c fd ff
	ff		 sub	 ecx, DWORD PTR _x_offset$38[ebp]
  0050d	89 4d 84	 mov	 DWORD PTR _ptr_dst0$79[ebp], ecx

; 651  :             ptr_dst1 -= x_offset;

  00510	8b 55 80	 mov	 edx, DWORD PTR _ptr_dst1$78[ebp]
  00513	2b 95 2c fd ff
	ff		 sub	 edx, DWORD PTR _x_offset$38[ebp]
  00519	89 55 80	 mov	 DWORD PTR _ptr_dst1$78[ebp], edx

; 652  :             ptr_dst2 -= x_offset;

  0051c	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _ptr_dst2$77[ebp]
  00522	2b 85 2c fd ff
	ff		 sub	 eax, DWORD PTR _x_offset$38[ebp]
  00528	89 85 7c ff ff
	ff		 mov	 DWORD PTR _ptr_dst2$77[ebp], eax
$LN9@convert_rg:

; 653  :         }
; 654  :         __m128i xSrc0 = _mm_loadu_si128((__m128i *)(ptr_src +  0));

  0052e	8b 4d 88	 mov	 ecx, DWORD PTR _ptr_src$80[ebp]
  00531	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00534	0f 29 85 00 fd
	ff ff		 movaps	 XMMWORD PTR $T36[ebp], xmm0
  0053b	0f 28 85 00 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T36[ebp]
  00542	0f 29 85 10 fd
	ff ff		 movaps	 XMMWORD PTR _xSrc0$37[ebp], xmm0

; 655  :         __m128i xSrc1 = _mm_loadu_si128((__m128i *)(ptr_src + 16));

  00549	8b 55 88	 mov	 edx, DWORD PTR _ptr_src$80[ebp]
  0054c	83 c2 10	 add	 edx, 16			; 00000010H
  0054f	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  00552	0f 29 85 e0 fc
	ff ff		 movaps	 XMMWORD PTR $T34[ebp], xmm0
  00559	0f 28 85 e0 fc
	ff ff		 movaps	 xmm0, XMMWORD PTR $T34[ebp]
  00560	0f 29 85 f0 fc
	ff ff		 movaps	 XMMWORD PTR _xSrc1$35[ebp], xmm0

; 656  :         __m128i xSrc2 = _mm_loadu_si128((__m128i *)(ptr_src + 32));

  00567	8b 45 88	 mov	 eax, DWORD PTR _ptr_src$80[ebp]
  0056a	83 c0 20	 add	 eax, 32			; 00000020H
  0056d	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00570	0f 29 85 c0 fc
	ff ff		 movaps	 XMMWORD PTR $T32[ebp], xmm0
  00577	0f 28 85 c0 fc
	ff ff		 movaps	 xmm0, XMMWORD PTR $T32[ebp]
  0057e	0f 29 85 d0 fc
	ff ff		 movaps	 XMMWORD PTR _xSrc2$33[ebp], xmm0

; 657  :         __m128i xSrc3 = _mm_loadu_si128((__m128i *)(ptr_src + 48));

  00585	8b 4d 88	 mov	 ecx, DWORD PTR _ptr_src$80[ebp]
  00588	83 c1 30	 add	 ecx, 48			; 00000030H
  0058b	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  0058e	0f 29 85 a0 fc
	ff ff		 movaps	 XMMWORD PTR $T30[ebp], xmm0
  00595	0f 28 85 a0 fc
	ff ff		 movaps	 xmm0, XMMWORD PTR $T30[ebp]
  0059c	0f 29 85 b0 fc
	ff ff		 movaps	 XMMWORD PTR _xSrc3$31[ebp], xmm0

; 658  : 
; 659  :         __m128i x02_0 = _mm_packus_epi16(_mm_and_si128(xMask, xSrc0), _mm_and_si128(xMask, xSrc1));

  005a3	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _xMask$[ebp]
  005a7	66 0f db 85 f0
	fc ff ff	 pand	 xmm0, XMMWORD PTR _xSrc1$35[ebp]
  005af	0f 29 85 70 fc
	ff ff		 movaps	 XMMWORD PTR $T27[ebp], xmm0
  005b6	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _xMask$[ebp]
  005ba	66 0f db 85 10
	fd ff ff	 pand	 xmm0, XMMWORD PTR _xSrc0$37[ebp]
  005c2	0f 29 85 80 fc
	ff ff		 movaps	 XMMWORD PTR $T28[ebp], xmm0
  005c9	0f 28 85 80 fc
	ff ff		 movaps	 xmm0, XMMWORD PTR $T28[ebp]
  005d0	66 0f 67 85 70
	fc ff ff	 packuswb xmm0, XMMWORD PTR $T27[ebp]
  005d8	0f 29 85 60 fc
	ff ff		 movaps	 XMMWORD PTR $T26[ebp], xmm0
  005df	0f 28 85 60 fc
	ff ff		 movaps	 xmm0, XMMWORD PTR $T26[ebp]
  005e6	0f 29 85 90 fc
	ff ff		 movaps	 XMMWORD PTR _x02_0$29[ebp], xmm0

; 660  :         __m128i x02_1 = _mm_packus_epi16(_mm_and_si128(xMask, xSrc2), _mm_and_si128(xMask, xSrc3));

  005ed	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _xMask$[ebp]
  005f1	66 0f db 85 b0
	fc ff ff	 pand	 xmm0, XMMWORD PTR _xSrc3$31[ebp]
  005f9	0f 29 85 30 fc
	ff ff		 movaps	 XMMWORD PTR $T23[ebp], xmm0
  00600	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _xMask$[ebp]
  00604	66 0f db 85 d0
	fc ff ff	 pand	 xmm0, XMMWORD PTR _xSrc2$33[ebp]
  0060c	0f 29 85 40 fc
	ff ff		 movaps	 XMMWORD PTR $T24[ebp], xmm0
  00613	0f 28 85 40 fc
	ff ff		 movaps	 xmm0, XMMWORD PTR $T24[ebp]
  0061a	66 0f 67 85 30
	fc ff ff	 packuswb xmm0, XMMWORD PTR $T23[ebp]
  00622	0f 29 85 20 fc
	ff ff		 movaps	 XMMWORD PTR $T22[ebp], xmm0
  00629	0f 28 85 20 fc
	ff ff		 movaps	 xmm0, XMMWORD PTR $T22[ebp]
  00630	0f 29 85 50 fc
	ff ff		 movaps	 XMMWORD PTR _x02_1$25[ebp], xmm0

; 661  :         __m128i x13_0 = _mm_packus_epi16(_mm_srli_epi16(xSrc0, 8), _mm_srli_epi16(xSrc1, 8));

  00637	0f 28 85 f0 fc
	ff ff		 movaps	 xmm0, XMMWORD PTR _xSrc1$35[ebp]
  0063e	66 0f 71 d0 08	 psrlw	 xmm0, 8
  00643	0f 29 85 f0 fb
	ff ff		 movaps	 XMMWORD PTR $T19[ebp], xmm0
  0064a	0f 28 85 10 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR _xSrc0$37[ebp]
  00651	66 0f 71 d0 08	 psrlw	 xmm0, 8
  00656	0f 29 85 00 fc
	ff ff		 movaps	 XMMWORD PTR $T20[ebp], xmm0
  0065d	0f 28 85 00 fc
	ff ff		 movaps	 xmm0, XMMWORD PTR $T20[ebp]
  00664	66 0f 67 85 f0
	fb ff ff	 packuswb xmm0, XMMWORD PTR $T19[ebp]
  0066c	0f 29 85 e0 fb
	ff ff		 movaps	 XMMWORD PTR $T18[ebp], xmm0
  00673	0f 28 85 e0 fb
	ff ff		 movaps	 xmm0, XMMWORD PTR $T18[ebp]
  0067a	0f 29 85 10 fc
	ff ff		 movaps	 XMMWORD PTR _x13_0$21[ebp], xmm0

; 662  :         __m128i x13_1 = _mm_packus_epi16(_mm_srli_epi16(xSrc2, 8), _mm_srli_epi16(xSrc3, 8));

  00681	0f 28 85 b0 fc
	ff ff		 movaps	 xmm0, XMMWORD PTR _xSrc3$31[ebp]
  00688	66 0f 71 d0 08	 psrlw	 xmm0, 8
  0068d	0f 29 85 b0 fb
	ff ff		 movaps	 XMMWORD PTR $T15[ebp], xmm0
  00694	0f 28 85 d0 fc
	ff ff		 movaps	 xmm0, XMMWORD PTR _xSrc2$33[ebp]
  0069b	66 0f 71 d0 08	 psrlw	 xmm0, 8
  006a0	0f 29 85 c0 fb
	ff ff		 movaps	 XMMWORD PTR $T16[ebp], xmm0
  006a7	0f 28 85 c0 fb
	ff ff		 movaps	 xmm0, XMMWORD PTR $T16[ebp]
  006ae	66 0f 67 85 b0
	fb ff ff	 packuswb xmm0, XMMWORD PTR $T15[ebp]
  006b6	0f 29 85 a0 fb
	ff ff		 movaps	 XMMWORD PTR $T14[ebp], xmm0
  006bd	0f 28 85 a0 fb
	ff ff		 movaps	 xmm0, XMMWORD PTR $T14[ebp]
  006c4	0f 29 85 d0 fb
	ff ff		 movaps	 XMMWORD PTR _x13_1$17[ebp], xmm0

; 663  : 
; 664  :         __m128i x0 = _mm_packus_epi16(_mm_and_si128(xMask, x02_0), _mm_and_si128(xMask, x02_1));

  006cb	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _xMask$[ebp]
  006cf	66 0f db 85 50
	fc ff ff	 pand	 xmm0, XMMWORD PTR _x02_1$25[ebp]
  006d7	0f 29 85 70 fb
	ff ff		 movaps	 XMMWORD PTR $T11[ebp], xmm0
  006de	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _xMask$[ebp]
  006e2	66 0f db 85 90
	fc ff ff	 pand	 xmm0, XMMWORD PTR _x02_0$29[ebp]
  006ea	0f 29 85 80 fb
	ff ff		 movaps	 XMMWORD PTR $T12[ebp], xmm0
  006f1	0f 28 85 80 fb
	ff ff		 movaps	 xmm0, XMMWORD PTR $T12[ebp]
  006f8	66 0f 67 85 70
	fb ff ff	 packuswb xmm0, XMMWORD PTR $T11[ebp]
  00700	0f 29 85 60 fb
	ff ff		 movaps	 XMMWORD PTR $T10[ebp], xmm0
  00707	0f 28 85 60 fb
	ff ff		 movaps	 xmm0, XMMWORD PTR $T10[ebp]
  0070e	0f 29 85 90 fb
	ff ff		 movaps	 XMMWORD PTR _x0$13[ebp], xmm0

; 665  :         __m128i x1 = _mm_packus_epi16(_mm_and_si128(xMask, x13_0), _mm_and_si128(xMask, x13_1));

  00715	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _xMask$[ebp]
  00719	66 0f db 85 d0
	fb ff ff	 pand	 xmm0, XMMWORD PTR _x13_1$17[ebp]
  00721	0f 29 85 30 fb
	ff ff		 movaps	 XMMWORD PTR $T7[ebp], xmm0
  00728	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _xMask$[ebp]
  0072c	66 0f db 85 10
	fc ff ff	 pand	 xmm0, XMMWORD PTR _x13_0$21[ebp]
  00734	0f 29 85 40 fb
	ff ff		 movaps	 XMMWORD PTR $T8[ebp], xmm0
  0073b	0f 28 85 40 fb
	ff ff		 movaps	 xmm0, XMMWORD PTR $T8[ebp]
  00742	66 0f 67 85 30
	fb ff ff	 packuswb xmm0, XMMWORD PTR $T7[ebp]
  0074a	0f 29 85 20 fb
	ff ff		 movaps	 XMMWORD PTR $T6[ebp], xmm0
  00751	0f 28 85 20 fb
	ff ff		 movaps	 xmm0, XMMWORD PTR $T6[ebp]
  00758	0f 29 85 50 fb
	ff ff		 movaps	 XMMWORD PTR _x1$9[ebp], xmm0

; 666  :         __m128i x2 = _mm_packus_epi16(_mm_srli_epi16(x02_0, 8), _mm_srli_epi16(x02_1, 8));

  0075f	0f 28 85 50 fc
	ff ff		 movaps	 xmm0, XMMWORD PTR _x02_1$25[ebp]
  00766	66 0f 71 d0 08	 psrlw	 xmm0, 8
  0076b	0f 29 85 f0 fa
	ff ff		 movaps	 XMMWORD PTR $T3[ebp], xmm0
  00772	0f 28 85 90 fc
	ff ff		 movaps	 xmm0, XMMWORD PTR _x02_0$29[ebp]
  00779	66 0f 71 d0 08	 psrlw	 xmm0, 8
  0077e	0f 29 85 00 fb
	ff ff		 movaps	 XMMWORD PTR $T4[ebp], xmm0
  00785	0f 28 85 00 fb
	ff ff		 movaps	 xmm0, XMMWORD PTR $T4[ebp]
  0078c	66 0f 67 85 f0
	fa ff ff	 packuswb xmm0, XMMWORD PTR $T3[ebp]
  00794	0f 29 85 e0 fa
	ff ff		 movaps	 XMMWORD PTR $T2[ebp], xmm0
  0079b	0f 28 85 e0 fa
	ff ff		 movaps	 xmm0, XMMWORD PTR $T2[ebp]
  007a2	0f 29 85 10 fb
	ff ff		 movaps	 XMMWORD PTR _x2$5[ebp], xmm0

; 667  :         //__m128i x3 = _mm_packus_epi16(_mm_srli_epi16(x13_0), 8), _mm_srli_epi16(x13_1), 8));
; 668  : 
; 669  :         _mm_storeu_si128((__m128i *)ptr_dst0, x0);

  007a9	0f 10 85 90 fb
	ff ff		 movups	 xmm0, XMMWORD PTR _x0$13[ebp]
  007b0	8b 55 84	 mov	 edx, DWORD PTR _ptr_dst0$79[ebp]
  007b3	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 670  :         _mm_storeu_si128((__m128i *)ptr_dst1, x1);

  007b6	0f 10 85 50 fb
	ff ff		 movups	 xmm0, XMMWORD PTR _x1$9[ebp]
  007bd	8b 45 80	 mov	 eax, DWORD PTR _ptr_dst1$78[ebp]
  007c0	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 671  :         _mm_storeu_si128((__m128i *)ptr_dst2, x2);

  007c3	0f 10 85 10 fb
	ff ff		 movups	 xmm0, XMMWORD PTR _x2$5[ebp]
  007ca	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _ptr_dst2$77[ebp]
  007d0	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 672  :     }

  007d3	e9 9b f9 ff ff	 jmp	 $LN2@convert_rg
$LN1@convert_rg:

; 673  : }

  007d8	52		 push	 edx
  007d9	8b cd		 mov	 ecx, ebp
  007db	50		 push	 eax
  007dc	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN15@convert_rg
  007e2	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  007e7	58		 pop	 eax
  007e8	5a		 pop	 edx
  007e9	5f		 pop	 edi
  007ea	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  007ed	33 cd		 xor	 ecx, ebp
  007ef	e8 00 00 00 00	 call	 @__security_check_cookie@4
  007f4	8b e5		 mov	 esp, ebp
  007f6	5d		 pop	 ebp
  007f7	8b e3		 mov	 esp, ebx
  007f9	5b		 pop	 ebx
  007fa	c3		 ret	 0
  007fb	90		 npad	 1
$LN15@convert_rg:
  007fc	01 00 00 00	 DD	 1
  00800	00 00 00 00	 DD	 $LN14@convert_rg
$LN14@convert_rg:
  00804	dc ff ff ff	 DD	 -36			; ffffffdcH
  00808	0c 00 00 00	 DD	 12			; 0000000cH
  0080c	00 00 00 00	 DD	 $LN13@convert_rg
$LN13@convert_rg:
  00810	79		 DB	 121			; 00000079H
  00811	5f		 DB	 95			; 0000005fH
  00812	72		 DB	 114			; 00000072H
  00813	61		 DB	 97			; 00000061H
  00814	6e		 DB	 110			; 0000006eH
  00815	67		 DB	 103			; 00000067H
  00816	65		 DB	 101			; 00000065H
  00817	00		 DB	 0
??$convert_rgb32_to_rgb_simd@$0PPAAABAC@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_rgb32_to_rgb_simd<4278190338,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_sse2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_rgb32_to_rgb_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_rgb32_to_rgb_sse2

; 65   : void convert_rgb32_to_rgb_sse2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 66   :     convert_rgb32_to_rgb_simd<RGB_PLANE(2, 1, 0, -1), false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_rgb32_to_rgb_simd@$0PPAAABAC@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_rgb32_to_rgb_simd<4278190338,0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 67   : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_rgb32_to_rgb_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_rgb32_to_rgb_sse2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -896						; size = 12
$T2 = -880						; size = 16
_x3$3 = -864						; size = 16
$T4 = -848						; size = 16
_x2$5 = -832						; size = 16
$T6 = -816						; size = 16
_x1$7 = -800						; size = 16
$T8 = -784						; size = 16
_x0$9 = -768						; size = 16
$T10 = -752						; size = 16
$T11 = -736						; size = 16
_xB1$12 = -720						; size = 16
$T13 = -704						; size = 16
$T14 = -688						; size = 16
_xB0$15 = -672						; size = 16
$T16 = -656						; size = 16
_xRG1$17 = -640						; size = 16
$T18 = -624						; size = 16
_xRG0$19 = -608						; size = 16
$T20 = -592						; size = 16
_xB$21 = -576						; size = 16
$T22 = -560						; size = 16
_xG$23 = -544						; size = 16
$T24 = -528						; size = 16
_xR$25 = -512						; size = 16
_x_offset$26 = -484					; size = 4
$T27 = -480						; size = 16
_x3$28 = -464						; size = 16
$T29 = -448						; size = 16
_x2$30 = -432						; size = 16
$T31 = -416						; size = 16
_x1$32 = -400						; size = 16
$T33 = -384						; size = 16
_x0$34 = -368						; size = 16
$T35 = -352						; size = 16
$T36 = -336						; size = 16
_xB1$37 = -320						; size = 16
$T38 = -304						; size = 16
$T39 = -288						; size = 16
_xB0$40 = -272						; size = 16
$T41 = -256						; size = 16
_xRG1$42 = -240						; size = 16
$T43 = -224						; size = 16
_xRG0$44 = -208						; size = 16
$T45 = -192						; size = 16
_xB$46 = -176						; size = 16
$T47 = -160						; size = 16
_xG$48 = -144						; size = 16
$T49 = -128						; size = 16
_xR$50 = -112						; size = 16
_x_fin$51 = -96						; size = 4
_x$52 = -92						; size = 4
_ptr_dst$53 = -88					; size = 4
_ptr_srcB$54 = -84					; size = 4
_ptr_srcG$55 = -80					; size = 4
_ptr_srcR$56 = -76					; size = 4
_y$57 = -72						; size = 4
_dstLine$ = -68						; size = 4
_srcBLine$ = -64					; size = 4
_srcGLine$ = -60					; size = 4
_srcRLine$ = -56					; size = 4
$T58 = -52						; size = 12
_y_range$ = -36						; size = 12
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_rgb_to_rgb32_simd@$0PPACAAAB@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_rgb_to_rgb32_simd<4278321153>

; 676  : static void __forceinline convert_rgb_to_rgb32_simd(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 80 03 00
	00		 sub	 esp, 896		; 00000380H
  0001c	57		 push	 edi
  0001d	8d bd 80 fc ff
	ff		 lea	 edi, DWORD PTR [ebp-896]
  00023	b9 e0 00 00 00	 mov	 ecx, 224		; 000000e0H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 677  :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 678  :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 679  :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 680  :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 681  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  0007c	8b 53 2c	 mov	 edx, DWORD PTR _thread_n$[ebx]
  0007f	52		 push	 edx
  00080	8b 43 28	 mov	 eax, DWORD PTR _thread_id$[ebx]
  00083	50		 push	 eax
  00084	8b 4b 20	 mov	 ecx, DWORD PTR _height$[ebx]
  00087	2b 4d ec	 sub	 ecx, DWORD PTR _crop_bottom$[ebp]
  0008a	51		 push	 ecx
  0008b	8b 55 f4	 mov	 edx, DWORD PTR _crop_up$[ebp]
  0008e	52		 push	 edx
  0008f	8d 85 80 fc ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  00095	50		 push	 eax
  00096	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  0009b	83 c4 14	 add	 esp, 20			; 00000014H
  0009e	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a0	89 4d cc	 mov	 DWORD PTR $T58[ebp], ecx
  000a3	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a6	89 55 d0	 mov	 DWORD PTR $T58[ebp+4], edx
  000a9	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000ac	89 45 d4	 mov	 DWORD PTR $T58[ebp+8], eax
  000af	8b 4d cc	 mov	 ecx, DWORD PTR $T58[ebp]
  000b2	89 4d dc	 mov	 DWORD PTR _y_range$[ebp], ecx
  000b5	8b 55 d0	 mov	 edx, DWORD PTR $T58[ebp+4]
  000b8	89 55 e0	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000bb	8b 45 d4	 mov	 eax, DWORD PTR $T58[ebp+8]
  000be	89 45 e4	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 682  :     uint8_t *srcRLine = (uint8_t *)src[(plane_from >>  0) & 0xff] + src_y_pitch_byte * y_range.start_src + crop_left;

  000c1	b9 04 00 00 00	 mov	 ecx, 4
  000c6	c1 e1 00	 shl	 ecx, 0
  000c9	8b 53 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  000cc	0f af 55 dc	 imul	 edx, DWORD PTR _y_range$[ebp]
  000d0	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  000d3	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  000d6	03 ca		 add	 ecx, edx
  000d8	03 4d f8	 add	 ecx, DWORD PTR _crop_left$[ebp]
  000db	89 4d c8	 mov	 DWORD PTR _srcRLine$[ebp], ecx

; 683  :     uint8_t *srcGLine = (uint8_t *)src[(plane_from >>  8) & 0xff] + src_y_pitch_byte * y_range.start_src + crop_left;

  000de	ba 04 00 00 00	 mov	 edx, 4
  000e3	6b c2 00	 imul	 eax, edx, 0
  000e6	8b 4b 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebx]
  000e9	0f af 4d dc	 imul	 ecx, DWORD PTR _y_range$[ebp]
  000ed	8b 53 0c	 mov	 edx, DWORD PTR _src$[ebx]
  000f0	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  000f3	03 c1		 add	 eax, ecx
  000f5	03 45 f8	 add	 eax, DWORD PTR _crop_left$[ebp]
  000f8	89 45 c4	 mov	 DWORD PTR _srcGLine$[ebp], eax

; 684  :     uint8_t *srcBLine = (uint8_t *)src[(plane_from >> 16) & 0xff] + src_y_pitch_byte * y_range.start_src + crop_left;

  000fb	b9 04 00 00 00	 mov	 ecx, 4
  00100	d1 e1		 shl	 ecx, 1
  00102	8b 53 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  00105	0f af 55 dc	 imul	 edx, DWORD PTR _y_range$[ebp]
  00109	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  0010c	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  0010f	03 ca		 add	 ecx, edx
  00111	03 4d f8	 add	 ecx, DWORD PTR _crop_left$[ebp]
  00114	89 4d c0	 mov	 DWORD PTR _srcBLine$[ebp], ecx

; 685  :     uint8_t *dstLine = (uint8_t *)dst[0] + dst_y_pitch_byte * y_range.start_dst;

  00117	ba 04 00 00 00	 mov	 edx, 4
  0011c	6b c2 00	 imul	 eax, edx, 0
  0011f	8b 4b 1c	 mov	 ecx, DWORD PTR _dst_y_pitch_byte$[ebx]
  00122	0f af 4d e0	 imul	 ecx, DWORD PTR _y_range$[ebp+4]
  00126	8b 53 08	 mov	 edx, DWORD PTR _dst$[ebx]
  00129	03 0c 02	 add	 ecx, DWORD PTR [edx+eax]
  0012c	89 4d bc	 mov	 DWORD PTR _dstLine$[ebp], ecx

; 686  :     for (int y = 0; y < y_range.len; y++, dstLine += dst_y_pitch_byte, srcRLine += src_y_pitch_byte, srcGLine += src_y_pitch_byte, srcBLine += src_y_pitch_byte) {

  0012f	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _y$57[ebp], 0
  00136	eb 2d		 jmp	 SHORT $LN4@convert_rg
$LN2@convert_rg:
  00138	8b 45 b8	 mov	 eax, DWORD PTR _y$57[ebp]
  0013b	83 c0 01	 add	 eax, 1
  0013e	89 45 b8	 mov	 DWORD PTR _y$57[ebp], eax
  00141	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$[ebp]
  00144	03 4b 1c	 add	 ecx, DWORD PTR _dst_y_pitch_byte$[ebx]
  00147	89 4d bc	 mov	 DWORD PTR _dstLine$[ebp], ecx
  0014a	8b 55 c8	 mov	 edx, DWORD PTR _srcRLine$[ebp]
  0014d	03 53 14	 add	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  00150	89 55 c8	 mov	 DWORD PTR _srcRLine$[ebp], edx
  00153	8b 45 c4	 mov	 eax, DWORD PTR _srcGLine$[ebp]
  00156	03 43 14	 add	 eax, DWORD PTR _src_y_pitch_byte$[ebx]
  00159	89 45 c4	 mov	 DWORD PTR _srcGLine$[ebp], eax
  0015c	8b 4d c0	 mov	 ecx, DWORD PTR _srcBLine$[ebp]
  0015f	03 4b 14	 add	 ecx, DWORD PTR _src_y_pitch_byte$[ebx]
  00162	89 4d c0	 mov	 DWORD PTR _srcBLine$[ebp], ecx
$LN4@convert_rg:
  00165	8b 55 b8	 mov	 edx, DWORD PTR _y$57[ebp]
  00168	3b 55 e4	 cmp	 edx, DWORD PTR _y_range$[ebp+8]
  0016b	0f 8d 36 04 00
	00		 jge	 $LN1@convert_rg

; 687  :         uint8_t *ptr_srcR = srcRLine;

  00171	8b 45 c8	 mov	 eax, DWORD PTR _srcRLine$[ebp]
  00174	89 45 b4	 mov	 DWORD PTR _ptr_srcR$56[ebp], eax

; 688  :         uint8_t *ptr_srcG = srcGLine;

  00177	8b 4d c4	 mov	 ecx, DWORD PTR _srcGLine$[ebp]
  0017a	89 4d b0	 mov	 DWORD PTR _ptr_srcG$55[ebp], ecx

; 689  :         uint8_t *ptr_srcB = srcBLine;

  0017d	8b 55 c0	 mov	 edx, DWORD PTR _srcBLine$[ebp]
  00180	89 55 ac	 mov	 DWORD PTR _ptr_srcB$54[ebp], edx

; 690  :         uint8_t *ptr_dst = dstLine;

  00183	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$[ebp]
  00186	89 45 a8	 mov	 DWORD PTR _ptr_dst$53[ebp], eax

; 691  :         int x = 0, x_fin = width - crop_left - crop_right - 16;

  00189	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _x$52[ebp], 0
  00190	8b 4b 10	 mov	 ecx, DWORD PTR _width$[ebx]
  00193	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  00196	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  00199	83 e9 10	 sub	 ecx, 16			; 00000010H
  0019c	89 4d a0	 mov	 DWORD PTR _x_fin$51[ebp], ecx

; 692  :         for (; x < x_fin; x += 16, ptr_dst += 64, ptr_srcR += 16, ptr_srcG += 16, ptr_srcB += 16) {

  0019f	eb 2d		 jmp	 SHORT $LN7@convert_rg
$LN5@convert_rg:
  001a1	8b 55 a4	 mov	 edx, DWORD PTR _x$52[ebp]
  001a4	83 c2 10	 add	 edx, 16			; 00000010H
  001a7	89 55 a4	 mov	 DWORD PTR _x$52[ebp], edx
  001aa	8b 45 a8	 mov	 eax, DWORD PTR _ptr_dst$53[ebp]
  001ad	83 c0 40	 add	 eax, 64			; 00000040H
  001b0	89 45 a8	 mov	 DWORD PTR _ptr_dst$53[ebp], eax
  001b3	8b 4d b4	 mov	 ecx, DWORD PTR _ptr_srcR$56[ebp]
  001b6	83 c1 10	 add	 ecx, 16			; 00000010H
  001b9	89 4d b4	 mov	 DWORD PTR _ptr_srcR$56[ebp], ecx
  001bc	8b 55 b0	 mov	 edx, DWORD PTR _ptr_srcG$55[ebp]
  001bf	83 c2 10	 add	 edx, 16			; 00000010H
  001c2	89 55 b0	 mov	 DWORD PTR _ptr_srcG$55[ebp], edx
  001c5	8b 45 ac	 mov	 eax, DWORD PTR _ptr_srcB$54[ebp]
  001c8	83 c0 10	 add	 eax, 16			; 00000010H
  001cb	89 45 ac	 mov	 DWORD PTR _ptr_srcB$54[ebp], eax
$LN7@convert_rg:
  001ce	8b 4d a4	 mov	 ecx, DWORD PTR _x$52[ebp]
  001d1	3b 4d a0	 cmp	 ecx, DWORD PTR _x_fin$51[ebp]
  001d4	0f 8d b8 01 00
	00		 jge	 $LN6@convert_rg

; 693  :             __m128i xR = _mm_loadu_si128((__m128i *)ptr_srcR);

  001da	8b 55 b4	 mov	 edx, DWORD PTR _ptr_srcR$56[ebp]
  001dd	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  001e0	0f 29 45 80	 movaps	 XMMWORD PTR $T49[ebp], xmm0
  001e4	0f 28 45 80	 movaps	 xmm0, XMMWORD PTR $T49[ebp]
  001e8	0f 29 45 90	 movaps	 XMMWORD PTR _xR$50[ebp], xmm0

; 694  :             __m128i xG = _mm_loadu_si128((__m128i *)ptr_srcG);

  001ec	8b 45 b0	 mov	 eax, DWORD PTR _ptr_srcG$55[ebp]
  001ef	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  001f2	0f 29 85 60 ff
	ff ff		 movaps	 XMMWORD PTR $T47[ebp], xmm0
  001f9	0f 28 85 60 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T47[ebp]
  00200	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR _xG$48[ebp], xmm0

; 695  :             __m128i xB = _mm_loadu_si128((__m128i *)ptr_srcB);

  00207	8b 4d ac	 mov	 ecx, DWORD PTR _ptr_srcB$54[ebp]
  0020a	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  0020d	0f 29 85 40 ff
	ff ff		 movaps	 XMMWORD PTR $T45[ebp], xmm0
  00214	0f 28 85 40 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T45[ebp]
  0021b	0f 29 85 50 ff
	ff ff		 movaps	 XMMWORD PTR _xB$46[ebp], xmm0

; 696  : 
; 697  :             __m128i xRG0 = _mm_unpacklo_epi8(xR, xG);

  00222	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR _xR$50[ebp]
  00226	66 0f 60 85 70
	ff ff ff	 punpcklbw xmm0, XMMWORD PTR _xG$48[ebp]
  0022e	0f 29 85 20 ff
	ff ff		 movaps	 XMMWORD PTR $T43[ebp], xmm0
  00235	0f 28 85 20 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T43[ebp]
  0023c	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR _xRG0$44[ebp], xmm0

; 698  :             __m128i xRG1 = _mm_unpackhi_epi8(xR, xG);

  00243	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR _xR$50[ebp]
  00247	66 0f 68 85 70
	ff ff ff	 punpckhbw xmm0, XMMWORD PTR _xG$48[ebp]
  0024f	0f 29 85 00 ff
	ff ff		 movaps	 XMMWORD PTR $T41[ebp], xmm0
  00256	0f 28 85 00 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T41[ebp]
  0025d	0f 29 85 10 ff
	ff ff		 movaps	 XMMWORD PTR _xRG1$42[ebp], xmm0

; 699  :             __m128i xB0 = _mm_unpacklo_epi8(xB, _mm_setzero_si128());

  00264	0f 57 c0	 xorps	 xmm0, xmm0
  00267	0f 29 85 e0 fe
	ff ff		 movaps	 XMMWORD PTR $T39[ebp], xmm0
  0026e	0f 28 85 50 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _xB$46[ebp]
  00275	66 0f 60 85 e0
	fe ff ff	 punpcklbw xmm0, XMMWORD PTR $T39[ebp]
  0027d	0f 29 85 d0 fe
	ff ff		 movaps	 XMMWORD PTR $T38[ebp], xmm0
  00284	0f 28 85 d0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T38[ebp]
  0028b	0f 29 85 f0 fe
	ff ff		 movaps	 XMMWORD PTR _xB0$40[ebp], xmm0

; 700  :             __m128i xB1 = _mm_unpackhi_epi8(xB, _mm_setzero_si128());

  00292	0f 57 c0	 xorps	 xmm0, xmm0
  00295	0f 29 85 b0 fe
	ff ff		 movaps	 XMMWORD PTR $T36[ebp], xmm0
  0029c	0f 28 85 50 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _xB$46[ebp]
  002a3	66 0f 68 85 b0
	fe ff ff	 punpckhbw xmm0, XMMWORD PTR $T36[ebp]
  002ab	0f 29 85 a0 fe
	ff ff		 movaps	 XMMWORD PTR $T35[ebp], xmm0
  002b2	0f 28 85 a0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T35[ebp]
  002b9	0f 29 85 c0 fe
	ff ff		 movaps	 XMMWORD PTR _xB1$37[ebp], xmm0

; 701  : 
; 702  :             __m128i x0 = _mm_unpacklo_epi16(xRG0, xB0);

  002c0	0f 28 85 30 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _xRG0$44[ebp]
  002c7	66 0f 61 85 f0
	fe ff ff	 punpcklwd xmm0, XMMWORD PTR _xB0$40[ebp]
  002cf	0f 29 85 80 fe
	ff ff		 movaps	 XMMWORD PTR $T33[ebp], xmm0
  002d6	0f 28 85 80 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T33[ebp]
  002dd	0f 29 85 90 fe
	ff ff		 movaps	 XMMWORD PTR _x0$34[ebp], xmm0

; 703  :             __m128i x1 = _mm_unpackhi_epi16(xRG0, xB0);

  002e4	0f 28 85 30 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _xRG0$44[ebp]
  002eb	66 0f 69 85 f0
	fe ff ff	 punpckhwd xmm0, XMMWORD PTR _xB0$40[ebp]
  002f3	0f 29 85 60 fe
	ff ff		 movaps	 XMMWORD PTR $T31[ebp], xmm0
  002fa	0f 28 85 60 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T31[ebp]
  00301	0f 29 85 70 fe
	ff ff		 movaps	 XMMWORD PTR _x1$32[ebp], xmm0

; 704  :             __m128i x2 = _mm_unpacklo_epi16(xRG1, xB1);

  00308	0f 28 85 10 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _xRG1$42[ebp]
  0030f	66 0f 61 85 c0
	fe ff ff	 punpcklwd xmm0, XMMWORD PTR _xB1$37[ebp]
  00317	0f 29 85 40 fe
	ff ff		 movaps	 XMMWORD PTR $T29[ebp], xmm0
  0031e	0f 28 85 40 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T29[ebp]
  00325	0f 29 85 50 fe
	ff ff		 movaps	 XMMWORD PTR _x2$30[ebp], xmm0

; 705  :             __m128i x3 = _mm_unpackhi_epi16(xRG1, xB1);

  0032c	0f 28 85 10 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _xRG1$42[ebp]
  00333	66 0f 69 85 c0
	fe ff ff	 punpckhwd xmm0, XMMWORD PTR _xB1$37[ebp]
  0033b	0f 29 85 20 fe
	ff ff		 movaps	 XMMWORD PTR $T27[ebp], xmm0
  00342	0f 28 85 20 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T27[ebp]
  00349	0f 29 85 30 fe
	ff ff		 movaps	 XMMWORD PTR _x3$28[ebp], xmm0

; 706  : 
; 707  :             _mm_storeu_si128((__m128i *)(ptr_dst +  0), x0);

  00350	0f 10 85 90 fe
	ff ff		 movups	 xmm0, XMMWORD PTR _x0$34[ebp]
  00357	8b 55 a8	 mov	 edx, DWORD PTR _ptr_dst$53[ebp]
  0035a	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 708  :             _mm_storeu_si128((__m128i *)(ptr_dst + 16), x1);

  0035d	0f 10 85 70 fe
	ff ff		 movups	 xmm0, XMMWORD PTR _x1$32[ebp]
  00364	8b 45 a8	 mov	 eax, DWORD PTR _ptr_dst$53[ebp]
  00367	83 c0 10	 add	 eax, 16			; 00000010H
  0036a	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 709  :             _mm_storeu_si128((__m128i *)(ptr_dst + 32), x2);

  0036d	0f 10 85 50 fe
	ff ff		 movups	 xmm0, XMMWORD PTR _x2$30[ebp]
  00374	8b 4d a8	 mov	 ecx, DWORD PTR _ptr_dst$53[ebp]
  00377	83 c1 20	 add	 ecx, 32			; 00000020H
  0037a	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 710  :             _mm_storeu_si128((__m128i *)(ptr_dst + 48), x3);

  0037d	0f 10 85 30 fe
	ff ff		 movups	 xmm0, XMMWORD PTR _x3$28[ebp]
  00384	8b 55 a8	 mov	 edx, DWORD PTR _ptr_dst$53[ebp]
  00387	83 c2 30	 add	 edx, 48			; 00000030H
  0038a	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 711  :         }

  0038d	e9 0f fe ff ff	 jmp	 $LN5@convert_rg
$LN6@convert_rg:

; 712  :         if (width & 15) {

  00392	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  00395	83 e0 0f	 and	 eax, 15			; 0000000fH
  00398	74 46		 je	 SHORT $LN8@convert_rg

; 713  :             int x_offset = (16 - (width & 15));

  0039a	8b 4b 10	 mov	 ecx, DWORD PTR _width$[ebx]
  0039d	83 e1 0f	 and	 ecx, 15			; 0000000fH
  003a0	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  003a5	2b d1		 sub	 edx, ecx
  003a7	89 95 1c fe ff
	ff		 mov	 DWORD PTR _x_offset$26[ebp], edx

; 714  :             ptr_dst -= x_offset * 3;

  003ad	6b 85 1c fe ff
	ff 03		 imul	 eax, DWORD PTR _x_offset$26[ebp], 3
  003b4	8b 4d a8	 mov	 ecx, DWORD PTR _ptr_dst$53[ebp]
  003b7	2b c8		 sub	 ecx, eax
  003b9	89 4d a8	 mov	 DWORD PTR _ptr_dst$53[ebp], ecx

; 715  :             ptr_srcR -= x_offset;

  003bc	8b 55 b4	 mov	 edx, DWORD PTR _ptr_srcR$56[ebp]
  003bf	2b 95 1c fe ff
	ff		 sub	 edx, DWORD PTR _x_offset$26[ebp]
  003c5	89 55 b4	 mov	 DWORD PTR _ptr_srcR$56[ebp], edx

; 716  :             ptr_srcG -= x_offset;

  003c8	8b 45 b0	 mov	 eax, DWORD PTR _ptr_srcG$55[ebp]
  003cb	2b 85 1c fe ff
	ff		 sub	 eax, DWORD PTR _x_offset$26[ebp]
  003d1	89 45 b0	 mov	 DWORD PTR _ptr_srcG$55[ebp], eax

; 717  :             ptr_srcB -= x_offset;

  003d4	8b 4d ac	 mov	 ecx, DWORD PTR _ptr_srcB$54[ebp]
  003d7	2b 8d 1c fe ff
	ff		 sub	 ecx, DWORD PTR _x_offset$26[ebp]
  003dd	89 4d ac	 mov	 DWORD PTR _ptr_srcB$54[ebp], ecx
$LN8@convert_rg:

; 718  :         }
; 719  :         __m128i xR = _mm_loadu_si128((__m128i *)ptr_srcR);

  003e0	8b 55 b4	 mov	 edx, DWORD PTR _ptr_srcR$56[ebp]
  003e3	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  003e6	0f 29 85 f0 fd
	ff ff		 movaps	 XMMWORD PTR $T24[ebp], xmm0
  003ed	0f 28 85 f0 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T24[ebp]
  003f4	0f 29 85 00 fe
	ff ff		 movaps	 XMMWORD PTR _xR$25[ebp], xmm0

; 720  :         __m128i xG = _mm_loadu_si128((__m128i *)ptr_srcG);

  003fb	8b 45 b0	 mov	 eax, DWORD PTR _ptr_srcG$55[ebp]
  003fe	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00401	0f 29 85 d0 fd
	ff ff		 movaps	 XMMWORD PTR $T22[ebp], xmm0
  00408	0f 28 85 d0 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T22[ebp]
  0040f	0f 29 85 e0 fd
	ff ff		 movaps	 XMMWORD PTR _xG$23[ebp], xmm0

; 721  :         __m128i xB = _mm_loadu_si128((__m128i *)ptr_srcB);

  00416	8b 4d ac	 mov	 ecx, DWORD PTR _ptr_srcB$54[ebp]
  00419	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  0041c	0f 29 85 b0 fd
	ff ff		 movaps	 XMMWORD PTR $T20[ebp], xmm0
  00423	0f 28 85 b0 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T20[ebp]
  0042a	0f 29 85 c0 fd
	ff ff		 movaps	 XMMWORD PTR _xB$21[ebp], xmm0

; 722  : 
; 723  :         __m128i xRG0 = _mm_unpacklo_epi8(xR, xG);

  00431	0f 28 85 00 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _xR$25[ebp]
  00438	66 0f 60 85 e0
	fd ff ff	 punpcklbw xmm0, XMMWORD PTR _xG$23[ebp]
  00440	0f 29 85 90 fd
	ff ff		 movaps	 XMMWORD PTR $T18[ebp], xmm0
  00447	0f 28 85 90 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T18[ebp]
  0044e	0f 29 85 a0 fd
	ff ff		 movaps	 XMMWORD PTR _xRG0$19[ebp], xmm0

; 724  :         __m128i xRG1 = _mm_unpackhi_epi8(xR, xG);

  00455	0f 28 85 00 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _xR$25[ebp]
  0045c	66 0f 68 85 e0
	fd ff ff	 punpckhbw xmm0, XMMWORD PTR _xG$23[ebp]
  00464	0f 29 85 70 fd
	ff ff		 movaps	 XMMWORD PTR $T16[ebp], xmm0
  0046b	0f 28 85 70 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T16[ebp]
  00472	0f 29 85 80 fd
	ff ff		 movaps	 XMMWORD PTR _xRG1$17[ebp], xmm0

; 725  :         __m128i xB0 = _mm_unpacklo_epi8(xB, _mm_setzero_si128());

  00479	0f 57 c0	 xorps	 xmm0, xmm0
  0047c	0f 29 85 50 fd
	ff ff		 movaps	 XMMWORD PTR $T14[ebp], xmm0
  00483	0f 28 85 c0 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR _xB$21[ebp]
  0048a	66 0f 60 85 50
	fd ff ff	 punpcklbw xmm0, XMMWORD PTR $T14[ebp]
  00492	0f 29 85 40 fd
	ff ff		 movaps	 XMMWORD PTR $T13[ebp], xmm0
  00499	0f 28 85 40 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T13[ebp]
  004a0	0f 29 85 60 fd
	ff ff		 movaps	 XMMWORD PTR _xB0$15[ebp], xmm0

; 726  :         __m128i xB1 = _mm_unpackhi_epi8(xB, _mm_setzero_si128());

  004a7	0f 57 c0	 xorps	 xmm0, xmm0
  004aa	0f 29 85 20 fd
	ff ff		 movaps	 XMMWORD PTR $T11[ebp], xmm0
  004b1	0f 28 85 c0 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR _xB$21[ebp]
  004b8	66 0f 68 85 20
	fd ff ff	 punpckhbw xmm0, XMMWORD PTR $T11[ebp]
  004c0	0f 29 85 10 fd
	ff ff		 movaps	 XMMWORD PTR $T10[ebp], xmm0
  004c7	0f 28 85 10 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T10[ebp]
  004ce	0f 29 85 30 fd
	ff ff		 movaps	 XMMWORD PTR _xB1$12[ebp], xmm0

; 727  : 
; 728  :         __m128i x0 = _mm_unpacklo_epi16(xRG0, xB0);

  004d5	0f 28 85 a0 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR _xRG0$19[ebp]
  004dc	66 0f 61 85 60
	fd ff ff	 punpcklwd xmm0, XMMWORD PTR _xB0$15[ebp]
  004e4	0f 29 85 f0 fc
	ff ff		 movaps	 XMMWORD PTR $T8[ebp], xmm0
  004eb	0f 28 85 f0 fc
	ff ff		 movaps	 xmm0, XMMWORD PTR $T8[ebp]
  004f2	0f 29 85 00 fd
	ff ff		 movaps	 XMMWORD PTR _x0$9[ebp], xmm0

; 729  :         __m128i x1 = _mm_unpackhi_epi16(xRG0, xB0);

  004f9	0f 28 85 a0 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR _xRG0$19[ebp]
  00500	66 0f 69 85 60
	fd ff ff	 punpckhwd xmm0, XMMWORD PTR _xB0$15[ebp]
  00508	0f 29 85 d0 fc
	ff ff		 movaps	 XMMWORD PTR $T6[ebp], xmm0
  0050f	0f 28 85 d0 fc
	ff ff		 movaps	 xmm0, XMMWORD PTR $T6[ebp]
  00516	0f 29 85 e0 fc
	ff ff		 movaps	 XMMWORD PTR _x1$7[ebp], xmm0

; 730  :         __m128i x2 = _mm_unpacklo_epi16(xRG1, xB1);

  0051d	0f 28 85 80 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR _xRG1$17[ebp]
  00524	66 0f 61 85 30
	fd ff ff	 punpcklwd xmm0, XMMWORD PTR _xB1$12[ebp]
  0052c	0f 29 85 b0 fc
	ff ff		 movaps	 XMMWORD PTR $T4[ebp], xmm0
  00533	0f 28 85 b0 fc
	ff ff		 movaps	 xmm0, XMMWORD PTR $T4[ebp]
  0053a	0f 29 85 c0 fc
	ff ff		 movaps	 XMMWORD PTR _x2$5[ebp], xmm0

; 731  :         __m128i x3 = _mm_unpackhi_epi16(xRG1, xB1);

  00541	0f 28 85 80 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR _xRG1$17[ebp]
  00548	66 0f 69 85 30
	fd ff ff	 punpckhwd xmm0, XMMWORD PTR _xB1$12[ebp]
  00550	0f 29 85 90 fc
	ff ff		 movaps	 XMMWORD PTR $T2[ebp], xmm0
  00557	0f 28 85 90 fc
	ff ff		 movaps	 xmm0, XMMWORD PTR $T2[ebp]
  0055e	0f 29 85 a0 fc
	ff ff		 movaps	 XMMWORD PTR _x3$3[ebp], xmm0

; 732  : 
; 733  :         _mm_storeu_si128((__m128i *)(ptr_dst +  0), x0);

  00565	0f 10 85 00 fd
	ff ff		 movups	 xmm0, XMMWORD PTR _x0$9[ebp]
  0056c	8b 55 a8	 mov	 edx, DWORD PTR _ptr_dst$53[ebp]
  0056f	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 734  :         _mm_storeu_si128((__m128i *)(ptr_dst + 16), x1);

  00572	0f 10 85 e0 fc
	ff ff		 movups	 xmm0, XMMWORD PTR _x1$7[ebp]
  00579	8b 45 a8	 mov	 eax, DWORD PTR _ptr_dst$53[ebp]
  0057c	83 c0 10	 add	 eax, 16			; 00000010H
  0057f	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 735  :         _mm_storeu_si128((__m128i *)(ptr_dst + 32), x2);

  00582	0f 10 85 c0 fc
	ff ff		 movups	 xmm0, XMMWORD PTR _x2$5[ebp]
  00589	8b 4d a8	 mov	 ecx, DWORD PTR _ptr_dst$53[ebp]
  0058c	83 c1 20	 add	 ecx, 32			; 00000020H
  0058f	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 736  :         _mm_storeu_si128((__m128i *)(ptr_dst + 48), x3);

  00592	0f 10 85 a0 fc
	ff ff		 movups	 xmm0, XMMWORD PTR _x3$3[ebp]
  00599	8b 55 a8	 mov	 edx, DWORD PTR _ptr_dst$53[ebp]
  0059c	83 c2 30	 add	 edx, 48			; 00000030H
  0059f	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 737  :     }

  005a2	e9 91 fb ff ff	 jmp	 $LN2@convert_rg
$LN1@convert_rg:

; 738  : }

  005a7	52		 push	 edx
  005a8	8b cd		 mov	 ecx, ebp
  005aa	50		 push	 eax
  005ab	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN12@convert_rg
  005b1	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  005b6	58		 pop	 eax
  005b7	5a		 pop	 edx
  005b8	5f		 pop	 edi
  005b9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005bc	33 cd		 xor	 ecx, ebp
  005be	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005c3	8b e5		 mov	 esp, ebp
  005c5	5d		 pop	 ebp
  005c6	8b e3		 mov	 esp, ebx
  005c8	5b		 pop	 ebx
  005c9	c3		 ret	 0
  005ca	66 90		 npad	 2
$LN12@convert_rg:
  005cc	01 00 00 00	 DD	 1
  005d0	00 00 00 00	 DD	 $LN11@convert_rg
$LN11@convert_rg:
  005d4	dc ff ff ff	 DD	 -36			; ffffffdcH
  005d8	0c 00 00 00	 DD	 12			; 0000000cH
  005dc	00 00 00 00	 DD	 $LN10@convert_rg
$LN10@convert_rg:
  005e0	79		 DB	 121			; 00000079H
  005e1	5f		 DB	 95			; 0000005fH
  005e2	72		 DB	 114			; 00000072H
  005e3	61		 DB	 97			; 00000061H
  005e4	6e		 DB	 110			; 0000006eH
  005e5	67		 DB	 103			; 00000067H
  005e6	65		 DB	 101			; 00000065H
  005e7	00		 DB	 0
??$convert_rgb_to_rgb32_simd@$0PPACAAAB@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_rgb_to_rgb32_simd<4278321153>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_sse2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_gbr_to_rgb32_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_gbr_to_rgb32_sse2

; 61   : void convert_gbr_to_rgb32_sse2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 62   :     convert_rgb_to_rgb32_simd<RGB_PLANE(1, 0, 2, -1)>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_rgb_to_rgb32_simd@$0PPACAAAB@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_rgb_to_rgb32_simd<4278321153>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 63   : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_gbr_to_rgb32_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_gbr_to_rgb32_sse2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -304						; size = 12
$T2 = -288						; size = 12
$T3 = -272						; size = 16
$T4 = -256						; size = 16
$T5 = -240						; size = 16
$T6 = -224						; size = 16
_x$7 = -196						; size = 4
_x2$8 = -192						; size = 16
_x1$9 = -176						; size = 16
_x0$10 = -160						; size = 16
_dst_ptr$11 = -132					; size = 4
_src_v_ptr$12 = -128					; size = 4
_src_u_ptr$13 = -124					; size = 4
_x_fin$14 = -120					; size = 4
_y$15 = -116						; size = 4
_dstLine$ = -112					; size = 4
_srcVLine$ = -108					; size = 4
_srcULine$ = -104					; size = 4
$T16 = -100						; size = 12
_uv_range$ = -84					; size = 12
_y$17 = -68						; size = 4
_y_width$18 = -64					; size = 4
_dstLine$19 = -60					; size = 4
_srcYLine$20 = -56					; size = 4
$T21 = -52						; size = 12
_y_range$22 = -36					; size = 12
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yv12_to_nv12_simd@$00@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_to_nv12_simd<1>

; 284  : static void __forceinline convert_yv12_to_nv12_simd(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 30 01 00
	00		 sub	 esp, 304		; 00000130H
  0001c	57		 push	 edi
  0001d	8d bd d0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-304]
  00023	b9 4c 00 00 00	 mov	 ecx, 76			; 0000004cH
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 285  :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 286  :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 287  :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 288  :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 289  :     //Y成分のコピー
; 290  :     if (!uv_only) {

  0007c	33 d2		 xor	 edx, edx
  0007e	0f 84 c8 00 00
	00		 je	 $LN11@convert_yv

; 291  :         const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00084	8b 43 2c	 mov	 eax, DWORD PTR _thread_n$[ebx]
  00087	50		 push	 eax
  00088	8b 4b 28	 mov	 ecx, DWORD PTR _thread_id$[ebx]
  0008b	51		 push	 ecx
  0008c	8b 53 20	 mov	 edx, DWORD PTR _height$[ebx]
  0008f	2b 55 ec	 sub	 edx, DWORD PTR _crop_bottom$[ebp]
  00092	52		 push	 edx
  00093	8b 45 f4	 mov	 eax, DWORD PTR _crop_up$[ebp]
  00096	50		 push	 eax
  00097	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  0009d	51		 push	 ecx
  0009e	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  000a3	83 c4 14	 add	 esp, 20			; 00000014H
  000a6	8b 10		 mov	 edx, DWORD PTR [eax]
  000a8	89 55 cc	 mov	 DWORD PTR $T21[ebp], edx
  000ab	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ae	89 4d d0	 mov	 DWORD PTR $T21[ebp+4], ecx
  000b1	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000b4	89 55 d4	 mov	 DWORD PTR $T21[ebp+8], edx
  000b7	8b 45 cc	 mov	 eax, DWORD PTR $T21[ebp]
  000ba	89 45 dc	 mov	 DWORD PTR _y_range$22[ebp], eax
  000bd	8b 4d d0	 mov	 ecx, DWORD PTR $T21[ebp+4]
  000c0	89 4d e0	 mov	 DWORD PTR _y_range$22[ebp+4], ecx
  000c3	8b 55 d4	 mov	 edx, DWORD PTR $T21[ebp+8]
  000c6	89 55 e4	 mov	 DWORD PTR _y_range$22[ebp+8], edx

; 292  :         uint8_t *srcYLine = (uint8_t *)src[0] + src_y_pitch_byte * y_range.start_src + crop_left;

  000c9	b8 04 00 00 00	 mov	 eax, 4
  000ce	6b c8 00	 imul	 ecx, eax, 0
  000d1	8b 53 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  000d4	0f af 55 dc	 imul	 edx, DWORD PTR _y_range$22[ebp]
  000d8	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  000db	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  000de	03 ca		 add	 ecx, edx
  000e0	03 4d f8	 add	 ecx, DWORD PTR _crop_left$[ebp]
  000e3	89 4d c8	 mov	 DWORD PTR _srcYLine$20[ebp], ecx

; 293  :         uint8_t *dstLine = (uint8_t *)dst[0] + dst_y_pitch_byte * y_range.start_dst;

  000e6	ba 04 00 00 00	 mov	 edx, 4
  000eb	6b c2 00	 imul	 eax, edx, 0
  000ee	8b 4b 1c	 mov	 ecx, DWORD PTR _dst_y_pitch_byte$[ebx]
  000f1	0f af 4d e0	 imul	 ecx, DWORD PTR _y_range$22[ebp+4]
  000f5	8b 53 08	 mov	 edx, DWORD PTR _dst$[ebx]
  000f8	03 0c 02	 add	 ecx, DWORD PTR [edx+eax]
  000fb	89 4d c4	 mov	 DWORD PTR _dstLine$19[ebp], ecx

; 294  :         const int y_width = width - crop_right - crop_left;

  000fe	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  00101	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  00104	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  00107	89 45 c0	 mov	 DWORD PTR _y_width$18[ebp], eax

; 295  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch_byte, dstLine += dst_y_pitch_byte) {

  0010a	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _y$17[ebp], 0
  00111	eb 1b		 jmp	 SHORT $LN4@convert_yv
$LN2@convert_yv:
  00113	8b 4d bc	 mov	 ecx, DWORD PTR _y$17[ebp]
  00116	83 c1 01	 add	 ecx, 1
  00119	89 4d bc	 mov	 DWORD PTR _y$17[ebp], ecx
  0011c	8b 55 c8	 mov	 edx, DWORD PTR _srcYLine$20[ebp]
  0011f	03 53 14	 add	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  00122	89 55 c8	 mov	 DWORD PTR _srcYLine$20[ebp], edx
  00125	8b 45 c4	 mov	 eax, DWORD PTR _dstLine$19[ebp]
  00128	03 43 1c	 add	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  0012b	89 45 c4	 mov	 DWORD PTR _dstLine$19[ebp], eax
$LN4@convert_yv:
  0012e	8b 4d bc	 mov	 ecx, DWORD PTR _y$17[ebp]
  00131	3b 4d e4	 cmp	 ecx, DWORD PTR _y_range$22[ebp+8]
  00134	7d 16		 jge	 SHORT $LN11@convert_yv

; 296  :             memcpy_sse(dstLine, srcYLine, y_width);

  00136	8b 55 c0	 mov	 edx, DWORD PTR _y_width$18[ebp]
  00139	52		 push	 edx
  0013a	8b 45 c8	 mov	 eax, DWORD PTR _srcYLine$20[ebp]
  0013d	50		 push	 eax
  0013e	8b 4d c4	 mov	 ecx, DWORD PTR _dstLine$19[ebp]
  00141	51		 push	 ecx
  00142	e8 00 00 00 00	 call	 ?memcpy_sse@@YAXPAEPBEH@Z ; memcpy_sse
  00147	83 c4 0c	 add	 esp, 12			; 0000000cH

; 297  :         }

  0014a	eb c7		 jmp	 SHORT $LN2@convert_yv
$LN11@convert_yv:

; 298  :     }
; 299  :     //UV成分のコピー
; 300  :     const auto uv_range = thread_y_range(crop_up >> 1, (height - crop_bottom) >> 1, thread_id, thread_n);

  0014c	8b 53 2c	 mov	 edx, DWORD PTR _thread_n$[ebx]
  0014f	52		 push	 edx
  00150	8b 43 28	 mov	 eax, DWORD PTR _thread_id$[ebx]
  00153	50		 push	 eax
  00154	8b 4b 20	 mov	 ecx, DWORD PTR _height$[ebx]
  00157	2b 4d ec	 sub	 ecx, DWORD PTR _crop_bottom$[ebp]
  0015a	d1 f9		 sar	 ecx, 1
  0015c	51		 push	 ecx
  0015d	8b 55 f4	 mov	 edx, DWORD PTR _crop_up$[ebp]
  00160	d1 fa		 sar	 edx, 1
  00162	52		 push	 edx
  00163	8d 85 d0 fe ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  00169	50		 push	 eax
  0016a	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  0016f	83 c4 14	 add	 esp, 20			; 00000014H
  00172	8b 08		 mov	 ecx, DWORD PTR [eax]
  00174	89 4d 9c	 mov	 DWORD PTR $T16[ebp], ecx
  00177	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0017a	89 55 a0	 mov	 DWORD PTR $T16[ebp+4], edx
  0017d	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00180	89 45 a4	 mov	 DWORD PTR $T16[ebp+8], eax
  00183	8b 4d 9c	 mov	 ecx, DWORD PTR $T16[ebp]
  00186	89 4d ac	 mov	 DWORD PTR _uv_range$[ebp], ecx
  00189	8b 55 a0	 mov	 edx, DWORD PTR $T16[ebp+4]
  0018c	89 55 b0	 mov	 DWORD PTR _uv_range$[ebp+4], edx
  0018f	8b 45 a4	 mov	 eax, DWORD PTR $T16[ebp+8]
  00192	89 45 b4	 mov	 DWORD PTR _uv_range$[ebp+8], eax

; 301  :     uint8_t *srcULine = (uint8_t *)src[1] + ((src_uv_pitch_byte * uv_range.start_src) + (crop_left >> 1));

  00195	b9 04 00 00 00	 mov	 ecx, 4
  0019a	c1 e1 00	 shl	 ecx, 0
  0019d	8b 53 18	 mov	 edx, DWORD PTR _src_uv_pitch_byte$[ebx]
  001a0	0f af 55 ac	 imul	 edx, DWORD PTR _uv_range$[ebp]
  001a4	8b 45 f8	 mov	 eax, DWORD PTR _crop_left$[ebp]
  001a7	d1 f8		 sar	 eax, 1
  001a9	03 d0		 add	 edx, eax
  001ab	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  001ae	03 14 08	 add	 edx, DWORD PTR [eax+ecx]
  001b1	89 55 98	 mov	 DWORD PTR _srcULine$[ebp], edx

; 302  :     uint8_t *srcVLine = (uint8_t *)src[2] + ((src_uv_pitch_byte * uv_range.start_src) + (crop_left >> 1));

  001b4	b9 04 00 00 00	 mov	 ecx, 4
  001b9	d1 e1		 shl	 ecx, 1
  001bb	8b 53 18	 mov	 edx, DWORD PTR _src_uv_pitch_byte$[ebx]
  001be	0f af 55 ac	 imul	 edx, DWORD PTR _uv_range$[ebp]
  001c2	8b 45 f8	 mov	 eax, DWORD PTR _crop_left$[ebp]
  001c5	d1 f8		 sar	 eax, 1
  001c7	03 d0		 add	 edx, eax
  001c9	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  001cc	03 14 08	 add	 edx, DWORD PTR [eax+ecx]
  001cf	89 55 94	 mov	 DWORD PTR _srcVLine$[ebp], edx

; 303  :     uint8_t *dstLine = (uint8_t *)dst[1] + dst_y_pitch_byte * uv_range.start_dst;

  001d2	b9 04 00 00 00	 mov	 ecx, 4
  001d7	c1 e1 00	 shl	 ecx, 0
  001da	8b 53 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebx]
  001dd	0f af 55 b0	 imul	 edx, DWORD PTR _uv_range$[ebp+4]
  001e1	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  001e4	03 14 08	 add	 edx, DWORD PTR [eax+ecx]
  001e7	89 55 90	 mov	 DWORD PTR _dstLine$[ebp], edx

; 304  :     for (int y = 0; y < uv_range.len; y++, srcULine += src_uv_pitch_byte, srcVLine += src_uv_pitch_byte, dstLine += dst_y_pitch_byte) {

  001ea	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR _y$15[ebp], 0
  001f1	eb 24		 jmp	 SHORT $LN7@convert_yv
$LN5@convert_yv:
  001f3	8b 4d 8c	 mov	 ecx, DWORD PTR _y$15[ebp]
  001f6	83 c1 01	 add	 ecx, 1
  001f9	89 4d 8c	 mov	 DWORD PTR _y$15[ebp], ecx
  001fc	8b 55 98	 mov	 edx, DWORD PTR _srcULine$[ebp]
  001ff	03 53 18	 add	 edx, DWORD PTR _src_uv_pitch_byte$[ebx]
  00202	89 55 98	 mov	 DWORD PTR _srcULine$[ebp], edx
  00205	8b 45 94	 mov	 eax, DWORD PTR _srcVLine$[ebp]
  00208	03 43 18	 add	 eax, DWORD PTR _src_uv_pitch_byte$[ebx]
  0020b	89 45 94	 mov	 DWORD PTR _srcVLine$[ebp], eax
  0020e	8b 4d 90	 mov	 ecx, DWORD PTR _dstLine$[ebp]
  00211	03 4b 1c	 add	 ecx, DWORD PTR _dst_y_pitch_byte$[ebx]
  00214	89 4d 90	 mov	 DWORD PTR _dstLine$[ebp], ecx
$LN7@convert_yv:
  00217	8b 55 8c	 mov	 edx, DWORD PTR _y$15[ebp]
  0021a	3b 55 b4	 cmp	 edx, DWORD PTR _uv_range$[ebp+8]
  0021d	0f 8d 13 01 00
	00		 jge	 $LN1@convert_yv

; 305  :         const int x_fin = width - crop_right;

  00223	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  00226	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  00229	89 45 88	 mov	 DWORD PTR _x_fin$14[ebp], eax

; 306  :         uint8_t *src_u_ptr = srcULine;

  0022c	8b 4d 98	 mov	 ecx, DWORD PTR _srcULine$[ebp]
  0022f	89 4d 84	 mov	 DWORD PTR _src_u_ptr$13[ebp], ecx

; 307  :         uint8_t *src_v_ptr = srcVLine;

  00232	8b 55 94	 mov	 edx, DWORD PTR _srcVLine$[ebp]
  00235	89 55 80	 mov	 DWORD PTR _src_v_ptr$12[ebp], edx

; 308  :         uint8_t *dst_ptr = dstLine;

  00238	8b 45 90	 mov	 eax, DWORD PTR _dstLine$[ebp]
  0023b	89 85 7c ff ff
	ff		 mov	 DWORD PTR _dst_ptr$11[ebp], eax

; 309  :         __m128i x0, x1, x2;
; 310  :         for (int x = crop_left; x < x_fin; x += 32, src_u_ptr += 16, src_v_ptr += 16, dst_ptr += 32) {

  00241	8b 4d f8	 mov	 ecx, DWORD PTR _crop_left$[ebp]
  00244	89 8d 3c ff ff
	ff		 mov	 DWORD PTR _x$7[ebp], ecx
  0024a	eb 30		 jmp	 SHORT $LN10@convert_yv
$LN8@convert_yv:
  0024c	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR _x$7[ebp]
  00252	83 c2 20	 add	 edx, 32			; 00000020H
  00255	89 95 3c ff ff
	ff		 mov	 DWORD PTR _x$7[ebp], edx
  0025b	8b 45 84	 mov	 eax, DWORD PTR _src_u_ptr$13[ebp]
  0025e	83 c0 10	 add	 eax, 16			; 00000010H
  00261	89 45 84	 mov	 DWORD PTR _src_u_ptr$13[ebp], eax
  00264	8b 4d 80	 mov	 ecx, DWORD PTR _src_v_ptr$12[ebp]
  00267	83 c1 10	 add	 ecx, 16			; 00000010H
  0026a	89 4d 80	 mov	 DWORD PTR _src_v_ptr$12[ebp], ecx
  0026d	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR _dst_ptr$11[ebp]
  00273	83 c2 20	 add	 edx, 32			; 00000020H
  00276	89 95 7c ff ff
	ff		 mov	 DWORD PTR _dst_ptr$11[ebp], edx
$LN10@convert_yv:
  0027c	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _x$7[ebp]
  00282	3b 45 88	 cmp	 eax, DWORD PTR _x_fin$14[ebp]
  00285	0f 8d a6 00 00
	00		 jge	 $LN9@convert_yv

; 311  :             x0 = _mm_loadu_si128((const __m128i *)src_u_ptr);

  0028b	8b 4d 84	 mov	 ecx, DWORD PTR _src_u_ptr$13[ebp]
  0028e	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00291	0f 29 85 20 ff
	ff ff		 movaps	 XMMWORD PTR $T6[ebp], xmm0
  00298	0f 28 85 20 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T6[ebp]
  0029f	0f 29 85 60 ff
	ff ff		 movaps	 XMMWORD PTR _x0$10[ebp], xmm0

; 312  :             x1 = _mm_loadu_si128((const __m128i *)src_v_ptr);

  002a6	8b 55 80	 mov	 edx, DWORD PTR _src_v_ptr$12[ebp]
  002a9	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  002ac	0f 29 85 10 ff
	ff ff		 movaps	 XMMWORD PTR $T5[ebp], xmm0
  002b3	0f 28 85 10 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T5[ebp]
  002ba	0f 29 85 50 ff
	ff ff		 movaps	 XMMWORD PTR _x1$9[ebp], xmm0

; 313  : 
; 314  :             x2 = _mm_unpackhi_epi8(x0, x1);

  002c1	0f 28 85 60 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x0$10[ebp]
  002c8	66 0f 68 85 50
	ff ff ff	 punpckhbw xmm0, XMMWORD PTR _x1$9[ebp]
  002d0	0f 29 85 00 ff
	ff ff		 movaps	 XMMWORD PTR $T4[ebp], xmm0
  002d7	0f 28 85 00 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T4[ebp]
  002de	0f 29 85 40 ff
	ff ff		 movaps	 XMMWORD PTR _x2$8[ebp], xmm0

; 315  :             x0 = _mm_unpacklo_epi8(x0, x1);

  002e5	0f 28 85 60 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x0$10[ebp]
  002ec	66 0f 60 85 50
	ff ff ff	 punpcklbw xmm0, XMMWORD PTR _x1$9[ebp]
  002f4	0f 29 85 f0 fe
	ff ff		 movaps	 XMMWORD PTR $T3[ebp], xmm0
  002fb	0f 28 85 f0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T3[ebp]
  00302	0f 29 85 60 ff
	ff ff		 movaps	 XMMWORD PTR _x0$10[ebp], xmm0

; 316  : 
; 317  :             _mm_storeu_si128((__m128i *)(dst_ptr +  0), x0);

  00309	0f 10 85 60 ff
	ff ff		 movups	 xmm0, XMMWORD PTR _x0$10[ebp]
  00310	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _dst_ptr$11[ebp]
  00316	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 318  :             _mm_storeu_si128((__m128i *)(dst_ptr + 16), x2);

  00319	0f 10 85 40 ff
	ff ff		 movups	 xmm0, XMMWORD PTR _x2$8[ebp]
  00320	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _dst_ptr$11[ebp]
  00326	83 c1 10	 add	 ecx, 16			; 00000010H
  00329	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 319  :         }

  0032c	e9 1b ff ff ff	 jmp	 $LN8@convert_yv
$LN9@convert_yv:

; 320  :     }

  00331	e9 bd fe ff ff	 jmp	 $LN5@convert_yv
$LN1@convert_yv:

; 321  : }

  00336	52		 push	 edx
  00337	8b cd		 mov	 ecx, ebp
  00339	50		 push	 eax
  0033a	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN16@convert_yv
  00340	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00345	58		 pop	 eax
  00346	5a		 pop	 edx
  00347	5f		 pop	 edi
  00348	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0034b	33 cd		 xor	 ecx, ebp
  0034d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00352	8b e5		 mov	 esp, ebp
  00354	5d		 pop	 ebp
  00355	8b e3		 mov	 esp, ebx
  00357	5b		 pop	 ebx
  00358	c3		 ret	 0
  00359	0f 1f 00	 npad	 3
$LN16@convert_yv:
  0035c	02 00 00 00	 DD	 2
  00360	00 00 00 00	 DD	 $LN15@convert_yv
$LN15@convert_yv:
  00364	dc ff ff ff	 DD	 -36			; ffffffdcH
  00368	0c 00 00 00	 DD	 12			; 0000000cH
  0036c	00 00 00 00	 DD	 $LN13@convert_yv
  00370	ac ff ff ff	 DD	 -84			; ffffffacH
  00374	0c 00 00 00	 DD	 12			; 0000000cH
  00378	00 00 00 00	 DD	 $LN14@convert_yv
$LN14@convert_yv:
  0037c	75		 DB	 117			; 00000075H
  0037d	76		 DB	 118			; 00000076H
  0037e	5f		 DB	 95			; 0000005fH
  0037f	72		 DB	 114			; 00000072H
  00380	61		 DB	 97			; 00000061H
  00381	6e		 DB	 110			; 0000006eH
  00382	67		 DB	 103			; 00000067H
  00383	65		 DB	 101			; 00000065H
  00384	00		 DB	 0
$LN13@convert_yv:
  00385	79		 DB	 121			; 00000079H
  00386	5f		 DB	 95			; 0000005fH
  00387	72		 DB	 114			; 00000072H
  00388	61		 DB	 97			; 00000061H
  00389	6e		 DB	 110			; 0000006eH
  0038a	67		 DB	 103			; 00000067H
  0038b	65		 DB	 101			; 00000065H
  0038c	00		 DB	 0
??$convert_yv12_to_nv12_simd@$00@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_to_nv12_simd<1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_sse2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_uv_yv12_to_nv12_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_uv_yv12_to_nv12_sse2

; 57   : void convert_uv_yv12_to_nv12_sse2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 58   :     convert_yv12_to_nv12_simd<true>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yv12_to_nv12_simd@$00@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_to_nv12_simd<1>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 59   : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_uv_yv12_to_nv12_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_uv_yv12_to_nv12_sse2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -304						; size = 12
$T2 = -288						; size = 12
$T3 = -272						; size = 16
$T4 = -256						; size = 16
$T5 = -240						; size = 16
$T6 = -224						; size = 16
_x$7 = -196						; size = 4
_x2$8 = -192						; size = 16
_x1$9 = -176						; size = 16
_x0$10 = -160						; size = 16
_dst_ptr$11 = -132					; size = 4
_src_v_ptr$12 = -128					; size = 4
_src_u_ptr$13 = -124					; size = 4
_x_fin$14 = -120					; size = 4
_y$15 = -116						; size = 4
_dstLine$ = -112					; size = 4
_srcVLine$ = -108					; size = 4
_srcULine$ = -104					; size = 4
$T16 = -100						; size = 12
_uv_range$ = -84					; size = 12
_y$17 = -68						; size = 4
_y_width$18 = -64					; size = 4
_dstLine$19 = -60					; size = 4
_srcYLine$20 = -56					; size = 4
$T21 = -52						; size = 12
_y_range$22 = -36					; size = 12
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yv12_to_nv12_simd@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_to_nv12_simd<0>

; 284  : static void __forceinline convert_yv12_to_nv12_simd(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 30 01 00
	00		 sub	 esp, 304		; 00000130H
  0001c	57		 push	 edi
  0001d	8d bd d0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-304]
  00023	b9 4c 00 00 00	 mov	 ecx, 76			; 0000004cH
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 285  :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 286  :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 287  :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 288  :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 289  :     //Y成分のコピー
; 290  :     if (!uv_only) {

  0007c	ba 01 00 00 00	 mov	 edx, 1
  00081	85 d2		 test	 edx, edx
  00083	0f 84 c8 00 00
	00		 je	 $LN11@convert_yv

; 291  :         const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00089	8b 43 2c	 mov	 eax, DWORD PTR _thread_n$[ebx]
  0008c	50		 push	 eax
  0008d	8b 4b 28	 mov	 ecx, DWORD PTR _thread_id$[ebx]
  00090	51		 push	 ecx
  00091	8b 53 20	 mov	 edx, DWORD PTR _height$[ebx]
  00094	2b 55 ec	 sub	 edx, DWORD PTR _crop_bottom$[ebp]
  00097	52		 push	 edx
  00098	8b 45 f4	 mov	 eax, DWORD PTR _crop_up$[ebp]
  0009b	50		 push	 eax
  0009c	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  000a2	51		 push	 ecx
  000a3	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  000a8	83 c4 14	 add	 esp, 20			; 00000014H
  000ab	8b 10		 mov	 edx, DWORD PTR [eax]
  000ad	89 55 cc	 mov	 DWORD PTR $T21[ebp], edx
  000b0	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000b3	89 4d d0	 mov	 DWORD PTR $T21[ebp+4], ecx
  000b6	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000b9	89 55 d4	 mov	 DWORD PTR $T21[ebp+8], edx
  000bc	8b 45 cc	 mov	 eax, DWORD PTR $T21[ebp]
  000bf	89 45 dc	 mov	 DWORD PTR _y_range$22[ebp], eax
  000c2	8b 4d d0	 mov	 ecx, DWORD PTR $T21[ebp+4]
  000c5	89 4d e0	 mov	 DWORD PTR _y_range$22[ebp+4], ecx
  000c8	8b 55 d4	 mov	 edx, DWORD PTR $T21[ebp+8]
  000cb	89 55 e4	 mov	 DWORD PTR _y_range$22[ebp+8], edx

; 292  :         uint8_t *srcYLine = (uint8_t *)src[0] + src_y_pitch_byte * y_range.start_src + crop_left;

  000ce	b8 04 00 00 00	 mov	 eax, 4
  000d3	6b c8 00	 imul	 ecx, eax, 0
  000d6	8b 53 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  000d9	0f af 55 dc	 imul	 edx, DWORD PTR _y_range$22[ebp]
  000dd	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  000e0	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  000e3	03 ca		 add	 ecx, edx
  000e5	03 4d f8	 add	 ecx, DWORD PTR _crop_left$[ebp]
  000e8	89 4d c8	 mov	 DWORD PTR _srcYLine$20[ebp], ecx

; 293  :         uint8_t *dstLine = (uint8_t *)dst[0] + dst_y_pitch_byte * y_range.start_dst;

  000eb	ba 04 00 00 00	 mov	 edx, 4
  000f0	6b c2 00	 imul	 eax, edx, 0
  000f3	8b 4b 1c	 mov	 ecx, DWORD PTR _dst_y_pitch_byte$[ebx]
  000f6	0f af 4d e0	 imul	 ecx, DWORD PTR _y_range$22[ebp+4]
  000fa	8b 53 08	 mov	 edx, DWORD PTR _dst$[ebx]
  000fd	03 0c 02	 add	 ecx, DWORD PTR [edx+eax]
  00100	89 4d c4	 mov	 DWORD PTR _dstLine$19[ebp], ecx

; 294  :         const int y_width = width - crop_right - crop_left;

  00103	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  00106	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  00109	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  0010c	89 45 c0	 mov	 DWORD PTR _y_width$18[ebp], eax

; 295  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch_byte, dstLine += dst_y_pitch_byte) {

  0010f	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _y$17[ebp], 0
  00116	eb 1b		 jmp	 SHORT $LN4@convert_yv
$LN2@convert_yv:
  00118	8b 4d bc	 mov	 ecx, DWORD PTR _y$17[ebp]
  0011b	83 c1 01	 add	 ecx, 1
  0011e	89 4d bc	 mov	 DWORD PTR _y$17[ebp], ecx
  00121	8b 55 c8	 mov	 edx, DWORD PTR _srcYLine$20[ebp]
  00124	03 53 14	 add	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  00127	89 55 c8	 mov	 DWORD PTR _srcYLine$20[ebp], edx
  0012a	8b 45 c4	 mov	 eax, DWORD PTR _dstLine$19[ebp]
  0012d	03 43 1c	 add	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  00130	89 45 c4	 mov	 DWORD PTR _dstLine$19[ebp], eax
$LN4@convert_yv:
  00133	8b 4d bc	 mov	 ecx, DWORD PTR _y$17[ebp]
  00136	3b 4d e4	 cmp	 ecx, DWORD PTR _y_range$22[ebp+8]
  00139	7d 16		 jge	 SHORT $LN11@convert_yv

; 296  :             memcpy_sse(dstLine, srcYLine, y_width);

  0013b	8b 55 c0	 mov	 edx, DWORD PTR _y_width$18[ebp]
  0013e	52		 push	 edx
  0013f	8b 45 c8	 mov	 eax, DWORD PTR _srcYLine$20[ebp]
  00142	50		 push	 eax
  00143	8b 4d c4	 mov	 ecx, DWORD PTR _dstLine$19[ebp]
  00146	51		 push	 ecx
  00147	e8 00 00 00 00	 call	 ?memcpy_sse@@YAXPAEPBEH@Z ; memcpy_sse
  0014c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 297  :         }

  0014f	eb c7		 jmp	 SHORT $LN2@convert_yv
$LN11@convert_yv:

; 298  :     }
; 299  :     //UV成分のコピー
; 300  :     const auto uv_range = thread_y_range(crop_up >> 1, (height - crop_bottom) >> 1, thread_id, thread_n);

  00151	8b 53 2c	 mov	 edx, DWORD PTR _thread_n$[ebx]
  00154	52		 push	 edx
  00155	8b 43 28	 mov	 eax, DWORD PTR _thread_id$[ebx]
  00158	50		 push	 eax
  00159	8b 4b 20	 mov	 ecx, DWORD PTR _height$[ebx]
  0015c	2b 4d ec	 sub	 ecx, DWORD PTR _crop_bottom$[ebp]
  0015f	d1 f9		 sar	 ecx, 1
  00161	51		 push	 ecx
  00162	8b 55 f4	 mov	 edx, DWORD PTR _crop_up$[ebp]
  00165	d1 fa		 sar	 edx, 1
  00167	52		 push	 edx
  00168	8d 85 d0 fe ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  0016e	50		 push	 eax
  0016f	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00174	83 c4 14	 add	 esp, 20			; 00000014H
  00177	8b 08		 mov	 ecx, DWORD PTR [eax]
  00179	89 4d 9c	 mov	 DWORD PTR $T16[ebp], ecx
  0017c	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0017f	89 55 a0	 mov	 DWORD PTR $T16[ebp+4], edx
  00182	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00185	89 45 a4	 mov	 DWORD PTR $T16[ebp+8], eax
  00188	8b 4d 9c	 mov	 ecx, DWORD PTR $T16[ebp]
  0018b	89 4d ac	 mov	 DWORD PTR _uv_range$[ebp], ecx
  0018e	8b 55 a0	 mov	 edx, DWORD PTR $T16[ebp+4]
  00191	89 55 b0	 mov	 DWORD PTR _uv_range$[ebp+4], edx
  00194	8b 45 a4	 mov	 eax, DWORD PTR $T16[ebp+8]
  00197	89 45 b4	 mov	 DWORD PTR _uv_range$[ebp+8], eax

; 301  :     uint8_t *srcULine = (uint8_t *)src[1] + ((src_uv_pitch_byte * uv_range.start_src) + (crop_left >> 1));

  0019a	b9 04 00 00 00	 mov	 ecx, 4
  0019f	c1 e1 00	 shl	 ecx, 0
  001a2	8b 53 18	 mov	 edx, DWORD PTR _src_uv_pitch_byte$[ebx]
  001a5	0f af 55 ac	 imul	 edx, DWORD PTR _uv_range$[ebp]
  001a9	8b 45 f8	 mov	 eax, DWORD PTR _crop_left$[ebp]
  001ac	d1 f8		 sar	 eax, 1
  001ae	03 d0		 add	 edx, eax
  001b0	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  001b3	03 14 08	 add	 edx, DWORD PTR [eax+ecx]
  001b6	89 55 98	 mov	 DWORD PTR _srcULine$[ebp], edx

; 302  :     uint8_t *srcVLine = (uint8_t *)src[2] + ((src_uv_pitch_byte * uv_range.start_src) + (crop_left >> 1));

  001b9	b9 04 00 00 00	 mov	 ecx, 4
  001be	d1 e1		 shl	 ecx, 1
  001c0	8b 53 18	 mov	 edx, DWORD PTR _src_uv_pitch_byte$[ebx]
  001c3	0f af 55 ac	 imul	 edx, DWORD PTR _uv_range$[ebp]
  001c7	8b 45 f8	 mov	 eax, DWORD PTR _crop_left$[ebp]
  001ca	d1 f8		 sar	 eax, 1
  001cc	03 d0		 add	 edx, eax
  001ce	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  001d1	03 14 08	 add	 edx, DWORD PTR [eax+ecx]
  001d4	89 55 94	 mov	 DWORD PTR _srcVLine$[ebp], edx

; 303  :     uint8_t *dstLine = (uint8_t *)dst[1] + dst_y_pitch_byte * uv_range.start_dst;

  001d7	b9 04 00 00 00	 mov	 ecx, 4
  001dc	c1 e1 00	 shl	 ecx, 0
  001df	8b 53 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebx]
  001e2	0f af 55 b0	 imul	 edx, DWORD PTR _uv_range$[ebp+4]
  001e6	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  001e9	03 14 08	 add	 edx, DWORD PTR [eax+ecx]
  001ec	89 55 90	 mov	 DWORD PTR _dstLine$[ebp], edx

; 304  :     for (int y = 0; y < uv_range.len; y++, srcULine += src_uv_pitch_byte, srcVLine += src_uv_pitch_byte, dstLine += dst_y_pitch_byte) {

  001ef	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR _y$15[ebp], 0
  001f6	eb 24		 jmp	 SHORT $LN7@convert_yv
$LN5@convert_yv:
  001f8	8b 4d 8c	 mov	 ecx, DWORD PTR _y$15[ebp]
  001fb	83 c1 01	 add	 ecx, 1
  001fe	89 4d 8c	 mov	 DWORD PTR _y$15[ebp], ecx
  00201	8b 55 98	 mov	 edx, DWORD PTR _srcULine$[ebp]
  00204	03 53 18	 add	 edx, DWORD PTR _src_uv_pitch_byte$[ebx]
  00207	89 55 98	 mov	 DWORD PTR _srcULine$[ebp], edx
  0020a	8b 45 94	 mov	 eax, DWORD PTR _srcVLine$[ebp]
  0020d	03 43 18	 add	 eax, DWORD PTR _src_uv_pitch_byte$[ebx]
  00210	89 45 94	 mov	 DWORD PTR _srcVLine$[ebp], eax
  00213	8b 4d 90	 mov	 ecx, DWORD PTR _dstLine$[ebp]
  00216	03 4b 1c	 add	 ecx, DWORD PTR _dst_y_pitch_byte$[ebx]
  00219	89 4d 90	 mov	 DWORD PTR _dstLine$[ebp], ecx
$LN7@convert_yv:
  0021c	8b 55 8c	 mov	 edx, DWORD PTR _y$15[ebp]
  0021f	3b 55 b4	 cmp	 edx, DWORD PTR _uv_range$[ebp+8]
  00222	0f 8d 13 01 00
	00		 jge	 $LN1@convert_yv

; 305  :         const int x_fin = width - crop_right;

  00228	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  0022b	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  0022e	89 45 88	 mov	 DWORD PTR _x_fin$14[ebp], eax

; 306  :         uint8_t *src_u_ptr = srcULine;

  00231	8b 4d 98	 mov	 ecx, DWORD PTR _srcULine$[ebp]
  00234	89 4d 84	 mov	 DWORD PTR _src_u_ptr$13[ebp], ecx

; 307  :         uint8_t *src_v_ptr = srcVLine;

  00237	8b 55 94	 mov	 edx, DWORD PTR _srcVLine$[ebp]
  0023a	89 55 80	 mov	 DWORD PTR _src_v_ptr$12[ebp], edx

; 308  :         uint8_t *dst_ptr = dstLine;

  0023d	8b 45 90	 mov	 eax, DWORD PTR _dstLine$[ebp]
  00240	89 85 7c ff ff
	ff		 mov	 DWORD PTR _dst_ptr$11[ebp], eax

; 309  :         __m128i x0, x1, x2;
; 310  :         for (int x = crop_left; x < x_fin; x += 32, src_u_ptr += 16, src_v_ptr += 16, dst_ptr += 32) {

  00246	8b 4d f8	 mov	 ecx, DWORD PTR _crop_left$[ebp]
  00249	89 8d 3c ff ff
	ff		 mov	 DWORD PTR _x$7[ebp], ecx
  0024f	eb 30		 jmp	 SHORT $LN10@convert_yv
$LN8@convert_yv:
  00251	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR _x$7[ebp]
  00257	83 c2 20	 add	 edx, 32			; 00000020H
  0025a	89 95 3c ff ff
	ff		 mov	 DWORD PTR _x$7[ebp], edx
  00260	8b 45 84	 mov	 eax, DWORD PTR _src_u_ptr$13[ebp]
  00263	83 c0 10	 add	 eax, 16			; 00000010H
  00266	89 45 84	 mov	 DWORD PTR _src_u_ptr$13[ebp], eax
  00269	8b 4d 80	 mov	 ecx, DWORD PTR _src_v_ptr$12[ebp]
  0026c	83 c1 10	 add	 ecx, 16			; 00000010H
  0026f	89 4d 80	 mov	 DWORD PTR _src_v_ptr$12[ebp], ecx
  00272	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR _dst_ptr$11[ebp]
  00278	83 c2 20	 add	 edx, 32			; 00000020H
  0027b	89 95 7c ff ff
	ff		 mov	 DWORD PTR _dst_ptr$11[ebp], edx
$LN10@convert_yv:
  00281	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _x$7[ebp]
  00287	3b 45 88	 cmp	 eax, DWORD PTR _x_fin$14[ebp]
  0028a	0f 8d a6 00 00
	00		 jge	 $LN9@convert_yv

; 311  :             x0 = _mm_loadu_si128((const __m128i *)src_u_ptr);

  00290	8b 4d 84	 mov	 ecx, DWORD PTR _src_u_ptr$13[ebp]
  00293	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00296	0f 29 85 20 ff
	ff ff		 movaps	 XMMWORD PTR $T6[ebp], xmm0
  0029d	0f 28 85 20 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T6[ebp]
  002a4	0f 29 85 60 ff
	ff ff		 movaps	 XMMWORD PTR _x0$10[ebp], xmm0

; 312  :             x1 = _mm_loadu_si128((const __m128i *)src_v_ptr);

  002ab	8b 55 80	 mov	 edx, DWORD PTR _src_v_ptr$12[ebp]
  002ae	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  002b1	0f 29 85 10 ff
	ff ff		 movaps	 XMMWORD PTR $T5[ebp], xmm0
  002b8	0f 28 85 10 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T5[ebp]
  002bf	0f 29 85 50 ff
	ff ff		 movaps	 XMMWORD PTR _x1$9[ebp], xmm0

; 313  : 
; 314  :             x2 = _mm_unpackhi_epi8(x0, x1);

  002c6	0f 28 85 60 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x0$10[ebp]
  002cd	66 0f 68 85 50
	ff ff ff	 punpckhbw xmm0, XMMWORD PTR _x1$9[ebp]
  002d5	0f 29 85 00 ff
	ff ff		 movaps	 XMMWORD PTR $T4[ebp], xmm0
  002dc	0f 28 85 00 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T4[ebp]
  002e3	0f 29 85 40 ff
	ff ff		 movaps	 XMMWORD PTR _x2$8[ebp], xmm0

; 315  :             x0 = _mm_unpacklo_epi8(x0, x1);

  002ea	0f 28 85 60 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x0$10[ebp]
  002f1	66 0f 60 85 50
	ff ff ff	 punpcklbw xmm0, XMMWORD PTR _x1$9[ebp]
  002f9	0f 29 85 f0 fe
	ff ff		 movaps	 XMMWORD PTR $T3[ebp], xmm0
  00300	0f 28 85 f0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T3[ebp]
  00307	0f 29 85 60 ff
	ff ff		 movaps	 XMMWORD PTR _x0$10[ebp], xmm0

; 316  : 
; 317  :             _mm_storeu_si128((__m128i *)(dst_ptr +  0), x0);

  0030e	0f 10 85 60 ff
	ff ff		 movups	 xmm0, XMMWORD PTR _x0$10[ebp]
  00315	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _dst_ptr$11[ebp]
  0031b	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 318  :             _mm_storeu_si128((__m128i *)(dst_ptr + 16), x2);

  0031e	0f 10 85 40 ff
	ff ff		 movups	 xmm0, XMMWORD PTR _x2$8[ebp]
  00325	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _dst_ptr$11[ebp]
  0032b	83 c1 10	 add	 ecx, 16			; 00000010H
  0032e	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 319  :         }

  00331	e9 1b ff ff ff	 jmp	 $LN8@convert_yv
$LN9@convert_yv:

; 320  :     }

  00336	e9 bd fe ff ff	 jmp	 $LN5@convert_yv
$LN1@convert_yv:

; 321  : }

  0033b	52		 push	 edx
  0033c	8b cd		 mov	 ecx, ebp
  0033e	50		 push	 eax
  0033f	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN16@convert_yv
  00345	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0034a	58		 pop	 eax
  0034b	5a		 pop	 edx
  0034c	5f		 pop	 edi
  0034d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00350	33 cd		 xor	 ecx, ebp
  00352	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00357	8b e5		 mov	 esp, ebp
  00359	5d		 pop	 ebp
  0035a	8b e3		 mov	 esp, ebx
  0035c	5b		 pop	 ebx
  0035d	c3		 ret	 0
  0035e	66 90		 npad	 2
$LN16@convert_yv:
  00360	02 00 00 00	 DD	 2
  00364	00 00 00 00	 DD	 $LN15@convert_yv
$LN15@convert_yv:
  00368	dc ff ff ff	 DD	 -36			; ffffffdcH
  0036c	0c 00 00 00	 DD	 12			; 0000000cH
  00370	00 00 00 00	 DD	 $LN13@convert_yv
  00374	ac ff ff ff	 DD	 -84			; ffffffacH
  00378	0c 00 00 00	 DD	 12			; 0000000cH
  0037c	00 00 00 00	 DD	 $LN14@convert_yv
$LN14@convert_yv:
  00380	75		 DB	 117			; 00000075H
  00381	76		 DB	 118			; 00000076H
  00382	5f		 DB	 95			; 0000005fH
  00383	72		 DB	 114			; 00000072H
  00384	61		 DB	 97			; 00000061H
  00385	6e		 DB	 110			; 0000006eH
  00386	67		 DB	 103			; 00000067H
  00387	65		 DB	 101			; 00000065H
  00388	00		 DB	 0
$LN13@convert_yv:
  00389	79		 DB	 121			; 00000079H
  0038a	5f		 DB	 95			; 0000005fH
  0038b	72		 DB	 114			; 00000072H
  0038c	61		 DB	 97			; 00000061H
  0038d	6e		 DB	 110			; 0000006eH
  0038e	67		 DB	 103			; 00000067H
  0038f	65		 DB	 101			; 00000065H
  00390	00		 DB	 0
??$convert_yv12_to_nv12_simd@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_to_nv12_simd<0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_sse2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yv12_to_nv12_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_to_nv12_sse2

; 53   : void convert_yv12_to_nv12_sse2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 54   :     convert_yv12_to_nv12_simd<false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yv12_to_nv12_simd@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_to_nv12_simd<0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 55   : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yv12_to_nv12_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_to_nv12_sse2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_sse2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuy2_to_nv12_i_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuy2_to_nv12_i_sse2

; 49   : void convert_yuy2_to_nv12_i_sse2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 50   :     return convert_yuy2_to_nv12_i_simd(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ?convert_yuy2_to_nv12_i_simd@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuy2_to_nv12_i_simd
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 51   : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yuy2_to_nv12_i_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuy2_to_nv12_i_sse2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_sse2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuy2_to_nv12_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuy2_to_nv12_sse2

; 45   : void convert_yuy2_to_nv12_sse2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 46   :     return convert_yuy2_to_nv12_simd(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ?convert_yuy2_to_nv12_simd@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuy2_to_nv12_simd
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 47   : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yuy2_to_nv12_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuy2_to_nv12_sse2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -88						; size = 12
_y$2 = -76						; size = 4
_y_width$3 = -72					; size = 4
_dstLine$4 = -68					; size = 4
_srcYLine$5 = -64					; size = 4
$T6 = -60						; size = 12
_y_range$7 = -44					; size = 12
_i$8 = -28						; size = 4
_pixel_size$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$copy_nv12_to_nv12@$00@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; copy_nv12_to_nv12<1>

; 120  : static void __forceinline copy_nv12_to_nv12(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	57		 push	 edi
  00007	8d 7d a8	 lea	 edi, DWORD PTR [ebp-88]
  0000a	b9 16 00 00 00	 mov	 ecx, 22			; 00000016H
  0000f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00014	f3 ab		 rep stosd
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 121  :     const int crop_left   = crop[0];

  00020	b8 04 00 00 00	 mov	 eax, 4
  00025	6b c8 00	 imul	 ecx, eax, 0
  00028	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  0002b	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0002e	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 122  :     const int crop_up     = crop[1];

  00031	b9 04 00 00 00	 mov	 ecx, 4
  00036	c1 e1 00	 shl	 ecx, 0
  00039	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  0003c	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0003f	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 123  :     const int crop_right  = crop[2];

  00042	b9 04 00 00 00	 mov	 ecx, 4
  00047	d1 e1		 shl	 ecx, 1
  00049	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  0004c	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0004f	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 124  :     const int crop_bottom = crop[3];

  00052	b9 04 00 00 00	 mov	 ecx, 4
  00057	6b d1 03	 imul	 edx, ecx, 3
  0005a	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  0005d	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00060	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 125  :     const int pixel_size = highbit_depth ? 2 : 1;

  00063	c7 45 e8 02 00
	00 00		 mov	 DWORD PTR _pixel_size$[ebp], 2

; 126  :     for (int i = 0; i < 2; i++) {

  0006a	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _i$8[ebp], 0
  00071	eb 09		 jmp	 SHORT $LN4@copy_nv12_
$LN2@copy_nv12_:
  00073	8b 55 e4	 mov	 edx, DWORD PTR _i$8[ebp]
  00076	83 c2 01	 add	 edx, 1
  00079	89 55 e4	 mov	 DWORD PTR _i$8[ebp], edx
$LN4@copy_nv12_:
  0007c	83 7d e4 02	 cmp	 DWORD PTR _i$8[ebp], 2
  00080	0f 8d cc 00 00
	00		 jge	 $LN1@copy_nv12_

; 127  :         const auto y_range = thread_y_range(crop_up >> i, (height - crop_bottom) >> i, thread_id, thread_n);

  00086	8b 45 2c	 mov	 eax, DWORD PTR _thread_n$[ebp]
  00089	50		 push	 eax
  0008a	8b 4d 28	 mov	 ecx, DWORD PTR _thread_id$[ebp]
  0008d	51		 push	 ecx
  0008e	8b 55 20	 mov	 edx, DWORD PTR _height$[ebp]
  00091	2b 55 ec	 sub	 edx, DWORD PTR _crop_bottom$[ebp]
  00094	8b 4d e4	 mov	 ecx, DWORD PTR _i$8[ebp]
  00097	d3 fa		 sar	 edx, cl
  00099	52		 push	 edx
  0009a	8b 45 f4	 mov	 eax, DWORD PTR _crop_up$[ebp]
  0009d	8b 4d e4	 mov	 ecx, DWORD PTR _i$8[ebp]
  000a0	d3 f8		 sar	 eax, cl
  000a2	50		 push	 eax
  000a3	8d 4d a8	 lea	 ecx, DWORD PTR $T1[ebp]
  000a6	51		 push	 ecx
  000a7	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  000ac	83 c4 14	 add	 esp, 20			; 00000014H
  000af	8b 10		 mov	 edx, DWORD PTR [eax]
  000b1	89 55 c4	 mov	 DWORD PTR $T6[ebp], edx
  000b4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000b7	89 4d c8	 mov	 DWORD PTR $T6[ebp+4], ecx
  000ba	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000bd	89 55 cc	 mov	 DWORD PTR $T6[ebp+8], edx
  000c0	8b 45 c4	 mov	 eax, DWORD PTR $T6[ebp]
  000c3	89 45 d4	 mov	 DWORD PTR _y_range$7[ebp], eax
  000c6	8b 4d c8	 mov	 ecx, DWORD PTR $T6[ebp+4]
  000c9	89 4d d8	 mov	 DWORD PTR _y_range$7[ebp+4], ecx
  000cc	8b 55 cc	 mov	 edx, DWORD PTR $T6[ebp+8]
  000cf	89 55 dc	 mov	 DWORD PTR _y_range$7[ebp+8], edx

; 128  :         uint8_t *srcYLine = (uint8_t *)src[i] + src_y_pitch_byte * y_range.start_src + crop_left;

  000d2	8b 45 14	 mov	 eax, DWORD PTR _src_y_pitch_byte$[ebp]
  000d5	0f af 45 d4	 imul	 eax, DWORD PTR _y_range$7[ebp]
  000d9	8b 4d e4	 mov	 ecx, DWORD PTR _i$8[ebp]
  000dc	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  000df	8b 0c 8a	 mov	 ecx, DWORD PTR [edx+ecx*4]
  000e2	03 c8		 add	 ecx, eax
  000e4	03 4d f8	 add	 ecx, DWORD PTR _crop_left$[ebp]
  000e7	89 4d c0	 mov	 DWORD PTR _srcYLine$5[ebp], ecx

; 129  :         uint8_t *dstLine = (uint8_t *)dst[i] + dst_y_pitch_byte * y_range.start_dst;

  000ea	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  000ed	0f af 55 d8	 imul	 edx, DWORD PTR _y_range$7[ebp+4]
  000f1	8b 45 e4	 mov	 eax, DWORD PTR _i$8[ebp]
  000f4	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  000f7	03 14 81	 add	 edx, DWORD PTR [ecx+eax*4]
  000fa	89 55 bc	 mov	 DWORD PTR _dstLine$4[ebp], edx

; 130  :         const int y_width = width - crop_right - crop_left;

  000fd	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00100	2b 55 f0	 sub	 edx, DWORD PTR _crop_right$[ebp]
  00103	2b 55 f8	 sub	 edx, DWORD PTR _crop_left$[ebp]
  00106	89 55 b8	 mov	 DWORD PTR _y_width$3[ebp], edx

; 131  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch_byte, dstLine += dst_y_pitch_byte) {

  00109	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _y$2[ebp], 0
  00110	eb 1b		 jmp	 SHORT $LN7@copy_nv12_
$LN5@copy_nv12_:
  00112	8b 45 b4	 mov	 eax, DWORD PTR _y$2[ebp]
  00115	83 c0 01	 add	 eax, 1
  00118	89 45 b4	 mov	 DWORD PTR _y$2[ebp], eax
  0011b	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$5[ebp]
  0011e	03 4d 14	 add	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00121	89 4d c0	 mov	 DWORD PTR _srcYLine$5[ebp], ecx
  00124	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$4[ebp]
  00127	03 55 1c	 add	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0012a	89 55 bc	 mov	 DWORD PTR _dstLine$4[ebp], edx
$LN7@copy_nv12_:
  0012d	8b 45 b4	 mov	 eax, DWORD PTR _y$2[ebp]
  00130	3b 45 dc	 cmp	 eax, DWORD PTR _y_range$7[ebp+8]
  00133	7d 18		 jge	 SHORT $LN6@copy_nv12_

; 132  :             memcpy_sse(dstLine, srcYLine, y_width * pixel_size);

  00135	8b 4d b8	 mov	 ecx, DWORD PTR _y_width$3[ebp]
  00138	d1 e1		 shl	 ecx, 1
  0013a	51		 push	 ecx
  0013b	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$5[ebp]
  0013e	52		 push	 edx
  0013f	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$4[ebp]
  00142	50		 push	 eax
  00143	e8 00 00 00 00	 call	 ?memcpy_sse@@YAXPAEPBEH@Z ; memcpy_sse
  00148	83 c4 0c	 add	 esp, 12			; 0000000cH

; 133  :         }

  0014b	eb c5		 jmp	 SHORT $LN5@copy_nv12_
$LN6@copy_nv12_:

; 134  :     }

  0014d	e9 21 ff ff ff	 jmp	 $LN2@copy_nv12_
$LN1@copy_nv12_:

; 135  : }

  00152	52		 push	 edx
  00153	8b cd		 mov	 ecx, ebp
  00155	50		 push	 eax
  00156	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN11@copy_nv12_
  0015c	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00161	58		 pop	 eax
  00162	5a		 pop	 edx
  00163	5f		 pop	 edi
  00164	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00167	33 cd		 xor	 ecx, ebp
  00169	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0016e	83 c4 58	 add	 esp, 88			; 00000058H
  00171	3b ec		 cmp	 ebp, esp
  00173	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00178	8b e5		 mov	 esp, ebp
  0017a	5d		 pop	 ebp
  0017b	c3		 ret	 0
$LN11@copy_nv12_:
  0017c	01 00 00 00	 DD	 1
  00180	00 00 00 00	 DD	 $LN10@copy_nv12_
$LN10@copy_nv12_:
  00184	d4 ff ff ff	 DD	 -44			; ffffffd4H
  00188	0c 00 00 00	 DD	 12			; 0000000cH
  0018c	00 00 00 00	 DD	 $LN9@copy_nv12_
$LN9@copy_nv12_:
  00190	79		 DB	 121			; 00000079H
  00191	5f		 DB	 95			; 0000005fH
  00192	72		 DB	 114			; 00000072H
  00193	61		 DB	 97			; 00000061H
  00194	6e		 DB	 110			; 0000006eH
  00195	67		 DB	 103			; 00000067H
  00196	65		 DB	 101			; 00000065H
  00197	00		 DB	 0
??$copy_nv12_to_nv12@$00@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; copy_nv12_to_nv12<1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_sse2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?copy_p010_to_p010_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; copy_p010_to_p010_sse2

; 41   : void copy_p010_to_p010_sse2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 42   :     return copy_nv12_to_nv12<true>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$copy_nv12_to_nv12@$00@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; copy_nv12_to_nv12<1>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 43   : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?copy_p010_to_p010_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; copy_p010_to_p010_sse2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -88						; size = 12
_y$2 = -76						; size = 4
_y_width$3 = -72					; size = 4
_dstLine$4 = -68					; size = 4
_srcYLine$5 = -64					; size = 4
$T6 = -60						; size = 12
_y_range$7 = -44					; size = 12
_i$8 = -28						; size = 4
_pixel_size$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$copy_nv12_to_nv12@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; copy_nv12_to_nv12<0>

; 120  : static void __forceinline copy_nv12_to_nv12(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	57		 push	 edi
  00007	8d 7d a8	 lea	 edi, DWORD PTR [ebp-88]
  0000a	b9 16 00 00 00	 mov	 ecx, 22			; 00000016H
  0000f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00014	f3 ab		 rep stosd
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 121  :     const int crop_left   = crop[0];

  00020	b8 04 00 00 00	 mov	 eax, 4
  00025	6b c8 00	 imul	 ecx, eax, 0
  00028	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  0002b	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0002e	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 122  :     const int crop_up     = crop[1];

  00031	b9 04 00 00 00	 mov	 ecx, 4
  00036	c1 e1 00	 shl	 ecx, 0
  00039	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  0003c	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0003f	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 123  :     const int crop_right  = crop[2];

  00042	b9 04 00 00 00	 mov	 ecx, 4
  00047	d1 e1		 shl	 ecx, 1
  00049	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  0004c	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0004f	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 124  :     const int crop_bottom = crop[3];

  00052	b9 04 00 00 00	 mov	 ecx, 4
  00057	6b d1 03	 imul	 edx, ecx, 3
  0005a	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  0005d	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00060	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 125  :     const int pixel_size = highbit_depth ? 2 : 1;

  00063	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _pixel_size$[ebp], 1

; 126  :     for (int i = 0; i < 2; i++) {

  0006a	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _i$8[ebp], 0
  00071	eb 09		 jmp	 SHORT $LN4@copy_nv12_
$LN2@copy_nv12_:
  00073	8b 55 e4	 mov	 edx, DWORD PTR _i$8[ebp]
  00076	83 c2 01	 add	 edx, 1
  00079	89 55 e4	 mov	 DWORD PTR _i$8[ebp], edx
$LN4@copy_nv12_:
  0007c	83 7d e4 02	 cmp	 DWORD PTR _i$8[ebp], 2
  00080	0f 8d ca 00 00
	00		 jge	 $LN1@copy_nv12_

; 127  :         const auto y_range = thread_y_range(crop_up >> i, (height - crop_bottom) >> i, thread_id, thread_n);

  00086	8b 45 2c	 mov	 eax, DWORD PTR _thread_n$[ebp]
  00089	50		 push	 eax
  0008a	8b 4d 28	 mov	 ecx, DWORD PTR _thread_id$[ebp]
  0008d	51		 push	 ecx
  0008e	8b 55 20	 mov	 edx, DWORD PTR _height$[ebp]
  00091	2b 55 ec	 sub	 edx, DWORD PTR _crop_bottom$[ebp]
  00094	8b 4d e4	 mov	 ecx, DWORD PTR _i$8[ebp]
  00097	d3 fa		 sar	 edx, cl
  00099	52		 push	 edx
  0009a	8b 45 f4	 mov	 eax, DWORD PTR _crop_up$[ebp]
  0009d	8b 4d e4	 mov	 ecx, DWORD PTR _i$8[ebp]
  000a0	d3 f8		 sar	 eax, cl
  000a2	50		 push	 eax
  000a3	8d 4d a8	 lea	 ecx, DWORD PTR $T1[ebp]
  000a6	51		 push	 ecx
  000a7	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  000ac	83 c4 14	 add	 esp, 20			; 00000014H
  000af	8b 10		 mov	 edx, DWORD PTR [eax]
  000b1	89 55 c4	 mov	 DWORD PTR $T6[ebp], edx
  000b4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000b7	89 4d c8	 mov	 DWORD PTR $T6[ebp+4], ecx
  000ba	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000bd	89 55 cc	 mov	 DWORD PTR $T6[ebp+8], edx
  000c0	8b 45 c4	 mov	 eax, DWORD PTR $T6[ebp]
  000c3	89 45 d4	 mov	 DWORD PTR _y_range$7[ebp], eax
  000c6	8b 4d c8	 mov	 ecx, DWORD PTR $T6[ebp+4]
  000c9	89 4d d8	 mov	 DWORD PTR _y_range$7[ebp+4], ecx
  000cc	8b 55 cc	 mov	 edx, DWORD PTR $T6[ebp+8]
  000cf	89 55 dc	 mov	 DWORD PTR _y_range$7[ebp+8], edx

; 128  :         uint8_t *srcYLine = (uint8_t *)src[i] + src_y_pitch_byte * y_range.start_src + crop_left;

  000d2	8b 45 14	 mov	 eax, DWORD PTR _src_y_pitch_byte$[ebp]
  000d5	0f af 45 d4	 imul	 eax, DWORD PTR _y_range$7[ebp]
  000d9	8b 4d e4	 mov	 ecx, DWORD PTR _i$8[ebp]
  000dc	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  000df	8b 0c 8a	 mov	 ecx, DWORD PTR [edx+ecx*4]
  000e2	03 c8		 add	 ecx, eax
  000e4	03 4d f8	 add	 ecx, DWORD PTR _crop_left$[ebp]
  000e7	89 4d c0	 mov	 DWORD PTR _srcYLine$5[ebp], ecx

; 129  :         uint8_t *dstLine = (uint8_t *)dst[i] + dst_y_pitch_byte * y_range.start_dst;

  000ea	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  000ed	0f af 55 d8	 imul	 edx, DWORD PTR _y_range$7[ebp+4]
  000f1	8b 45 e4	 mov	 eax, DWORD PTR _i$8[ebp]
  000f4	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  000f7	03 14 81	 add	 edx, DWORD PTR [ecx+eax*4]
  000fa	89 55 bc	 mov	 DWORD PTR _dstLine$4[ebp], edx

; 130  :         const int y_width = width - crop_right - crop_left;

  000fd	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00100	2b 55 f0	 sub	 edx, DWORD PTR _crop_right$[ebp]
  00103	2b 55 f8	 sub	 edx, DWORD PTR _crop_left$[ebp]
  00106	89 55 b8	 mov	 DWORD PTR _y_width$3[ebp], edx

; 131  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch_byte, dstLine += dst_y_pitch_byte) {

  00109	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _y$2[ebp], 0
  00110	eb 1b		 jmp	 SHORT $LN7@copy_nv12_
$LN5@copy_nv12_:
  00112	8b 45 b4	 mov	 eax, DWORD PTR _y$2[ebp]
  00115	83 c0 01	 add	 eax, 1
  00118	89 45 b4	 mov	 DWORD PTR _y$2[ebp], eax
  0011b	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$5[ebp]
  0011e	03 4d 14	 add	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00121	89 4d c0	 mov	 DWORD PTR _srcYLine$5[ebp], ecx
  00124	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$4[ebp]
  00127	03 55 1c	 add	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0012a	89 55 bc	 mov	 DWORD PTR _dstLine$4[ebp], edx
$LN7@copy_nv12_:
  0012d	8b 45 b4	 mov	 eax, DWORD PTR _y$2[ebp]
  00130	3b 45 dc	 cmp	 eax, DWORD PTR _y_range$7[ebp+8]
  00133	7d 16		 jge	 SHORT $LN6@copy_nv12_

; 132  :             memcpy_sse(dstLine, srcYLine, y_width * pixel_size);

  00135	8b 4d b8	 mov	 ecx, DWORD PTR _y_width$3[ebp]
  00138	51		 push	 ecx
  00139	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$5[ebp]
  0013c	52		 push	 edx
  0013d	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$4[ebp]
  00140	50		 push	 eax
  00141	e8 00 00 00 00	 call	 ?memcpy_sse@@YAXPAEPBEH@Z ; memcpy_sse
  00146	83 c4 0c	 add	 esp, 12			; 0000000cH

; 133  :         }

  00149	eb c7		 jmp	 SHORT $LN5@copy_nv12_
$LN6@copy_nv12_:

; 134  :     }

  0014b	e9 23 ff ff ff	 jmp	 $LN2@copy_nv12_
$LN1@copy_nv12_:

; 135  : }

  00150	52		 push	 edx
  00151	8b cd		 mov	 ecx, ebp
  00153	50		 push	 eax
  00154	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN11@copy_nv12_
  0015a	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0015f	58		 pop	 eax
  00160	5a		 pop	 edx
  00161	5f		 pop	 edi
  00162	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00165	33 cd		 xor	 ecx, ebp
  00167	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0016c	83 c4 58	 add	 esp, 88			; 00000058H
  0016f	3b ec		 cmp	 ebp, esp
  00171	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00176	8b e5		 mov	 esp, ebp
  00178	5d		 pop	 ebp
  00179	c3		 ret	 0
  0017a	66 90		 npad	 2
$LN11@copy_nv12_:
  0017c	01 00 00 00	 DD	 1
  00180	00 00 00 00	 DD	 $LN10@copy_nv12_
$LN10@copy_nv12_:
  00184	d4 ff ff ff	 DD	 -44			; ffffffd4H
  00188	0c 00 00 00	 DD	 12			; 0000000cH
  0018c	00 00 00 00	 DD	 $LN9@copy_nv12_
$LN9@copy_nv12_:
  00190	79		 DB	 121			; 00000079H
  00191	5f		 DB	 95			; 0000005fH
  00192	72		 DB	 114			; 00000072H
  00193	61		 DB	 97			; 00000061H
  00194	6e		 DB	 110			; 0000006eH
  00195	67		 DB	 103			; 00000067H
  00196	65		 DB	 101			; 00000065H
  00197	00		 DB	 0
??$copy_nv12_to_nv12@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; copy_nv12_to_nv12<0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_sse2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?copy_nv12_to_nv12_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; copy_nv12_to_nv12_sse2

; 37   : void copy_nv12_to_nv12_sse2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 38   :     return copy_nv12_to_nv12<false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$copy_nv12_to_nv12@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; copy_nv12_to_nv12<0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 39   : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?copy_nv12_to_nv12_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; copy_nv12_to_nv12_sse2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -464						; size = 16
$T2 = -448						; size = 16
$T3 = -432						; size = 16
$T4 = -416						; size = 16
$T5 = -400						; size = 16
$T6 = -384						; size = 16
$T7 = -368						; size = 16
$T8 = -352						; size = 16
$T9 = -336						; size = 16
$T10 = -320						; size = 16
$T11 = -304						; size = 16
$T12 = -288						; size = 16
$T13 = -272						; size = 16
$T14 = -256						; size = 16
$T15 = -240						; size = 16
$T16 = -224						; size = 16
$T17 = -208						; size = 16
$T18 = -192						; size = 16
$T19 = -176						; size = 16
$T20 = -160						; size = 16
$T21 = -144						; size = 16
$T22 = -128						; size = 16
$T23 = -112						; size = 16
$T24 = -96						; size = 16
$T25 = -80						; size = 16
$T26 = -64						; size = 16
$T27 = -48						; size = 16
_x4$ = -32						; size = 16
_x3$ = -16						; size = 16
_x0$ = 8						; size = 4
_x1$ = 12						; size = 4
_x2$ = 16						; size = 4
?gather_y_u_v_to_yc48@@YAXAAT__m128i@@00@Z PROC		; gather_y_u_v_to_yc48

; 1528 : static __forceinline void gather_y_u_v_to_yc48(__m128i& x0, __m128i& x1, __m128i& x2) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec d0 01 00
	00		 sub	 esp, 464		; 000001d0H
  0001c	57		 push	 edi
  0001d	8d bd 30 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-464]
  00023	b9 74 00 00 00	 mov	 ecx, 116		; 00000074H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd

; 1529 :     __m128i x3, x4;
; 1530 : #if USE_SSE41
; 1531 :     alignas(16) static const uint8_t shuffle_yc48[16] = {
; 1532 :         0x00, 0x01, 0x06, 0x07, 0x0C, 0x0D, 0x02, 0x03, 0x08, 0x09, 0x0E, 0x0F, 0x04, 0x05, 0x0A, 0x0B
; 1533 :     };
; 1534 :     x4 = _mm_load_si128((__m128i *)shuffle_yc48);
; 1535 :     x0 = _mm_shuffle_epi8(x0, x4);                          //5,2,7,4,1,6,3,0
; 1536 :     x1 = _mm_shuffle_epi8(x1, _mm_alignr_epi8(x4, x4, 14)); //2,7,4,1,6,3,0,5
; 1537 :     x2 = _mm_shuffle_epi8(x2, _mm_alignr_epi8(x4, x4, 12)); //7,4,1,6,3,0,5,2
; 1538 : 
; 1539 :     x3 = _mm_blend_epi16(x0, x1, 0x80 + 0x10 + 0x02);
; 1540 :     x3 = _mm_blend_epi16(x3, x2, 0x20 + 0x04);
; 1541 : 
; 1542 :     x4 = _mm_blend_epi16(x2, x1, 0x20 + 0x04);
; 1543 :     x4 = _mm_blend_epi16(x4, x0, 0x80 + 0x10 + 0x02);
; 1544 : 
; 1545 :     x2 = _mm_blend_epi16(x2, x0, 0x20 + 0x04);
; 1546 :     x2 = _mm_blend_epi16(x2, x1, 0x40 + 0x08 + 0x01);
; 1547 : 
; 1548 :     x0 = x3;
; 1549 :     x1 = x4;
; 1550 : #else
; 1551 :     x0 = _mm_shufflelo_epi16(x0, _MM_SHUFFLE(3,1,2,0)); // 7,6,5,4,3,1,2,0

  0002f	8b 43 08	 mov	 eax, DWORD PTR _x0$[ebx]
  00032	f2 0f 70 00 d8	 pshuflw xmm0, XMMWORD PTR [eax], 216 ; 000000d8H
  00037	0f 29 45 d0	 movaps	 XMMWORD PTR $T27[ebp], xmm0
  0003b	8b 4b 08	 mov	 ecx, DWORD PTR _x0$[ebx]
  0003e	0f 10 45 d0	 movups	 xmm0, XMMWORD PTR $T27[ebp]
  00042	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 1552 :     x0 = _mm_shufflehi_epi16(x0, _MM_SHUFFLE(3,1,2,0)); // 7,5,6,4,3,1,2,0

  00045	8b 53 08	 mov	 edx, DWORD PTR _x0$[ebx]
  00048	f3 0f 70 02 d8	 pshufhw xmm0, XMMWORD PTR [edx], 216 ; 000000d8H
  0004d	0f 29 45 c0	 movaps	 XMMWORD PTR $T26[ebp], xmm0
  00051	8b 43 08	 mov	 eax, DWORD PTR _x0$[ebx]
  00054	0f 10 45 c0	 movups	 xmm0, XMMWORD PTR $T26[ebp]
  00058	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 1553 :     x0 = _mm_shuffle_epi32(  x0, _MM_SHUFFLE(3,1,2,0)); // 7,5,3,1,6,4,2,0

  0005b	8b 4b 08	 mov	 ecx, DWORD PTR _x0$[ebx]
  0005e	66 0f 70 01 d8	 pshufd	 xmm0, XMMWORD PTR [ecx], 216 ; 000000d8H
  00063	0f 29 45 b0	 movaps	 XMMWORD PTR $T25[ebp], xmm0
  00067	8b 53 08	 mov	 edx, DWORD PTR _x0$[ebx]
  0006a	0f 10 45 b0	 movups	 xmm0, XMMWORD PTR $T25[ebp]
  0006e	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 1554 :     x0 = _mm_shufflelo_epi16(x0, _MM_SHUFFLE(3,1,2,0)); // 7,5,3,1,6,2,4,0

  00071	8b 43 08	 mov	 eax, DWORD PTR _x0$[ebx]
  00074	f2 0f 70 00 d8	 pshuflw xmm0, XMMWORD PTR [eax], 216 ; 000000d8H
  00079	0f 29 45 a0	 movaps	 XMMWORD PTR $T24[ebp], xmm0
  0007d	8b 4b 08	 mov	 ecx, DWORD PTR _x0$[ebx]
  00080	0f 10 45 a0	 movups	 xmm0, XMMWORD PTR $T24[ebp]
  00084	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 1555 :     x0 = _mm_shufflehi_epi16(x0, _MM_SHUFFLE(3,1,2,0)); // 7,3,5,1,6,2,4,0

  00087	8b 53 08	 mov	 edx, DWORD PTR _x0$[ebx]
  0008a	f3 0f 70 02 d8	 pshufhw xmm0, XMMWORD PTR [edx], 216 ; 000000d8H
  0008f	0f 29 45 90	 movaps	 XMMWORD PTR $T23[ebp], xmm0
  00093	8b 43 08	 mov	 eax, DWORD PTR _x0$[ebx]
  00096	0f 10 45 90	 movups	 xmm0, XMMWORD PTR $T23[ebp]
  0009a	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 1556 : 
; 1557 :     x1 = _mm_shufflelo_epi16(x1, _MM_SHUFFLE(3,1,2,0));

  0009d	8b 4b 0c	 mov	 ecx, DWORD PTR _x1$[ebx]
  000a0	f2 0f 70 01 d8	 pshuflw xmm0, XMMWORD PTR [ecx], 216 ; 000000d8H
  000a5	0f 29 45 80	 movaps	 XMMWORD PTR $T22[ebp], xmm0
  000a9	8b 53 0c	 mov	 edx, DWORD PTR _x1$[ebx]
  000ac	0f 10 45 80	 movups	 xmm0, XMMWORD PTR $T22[ebp]
  000b0	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 1558 :     x1 = _mm_shufflehi_epi16(x1, _MM_SHUFFLE(3,1,2,0));

  000b3	8b 43 0c	 mov	 eax, DWORD PTR _x1$[ebx]
  000b6	f3 0f 70 00 d8	 pshufhw xmm0, XMMWORD PTR [eax], 216 ; 000000d8H
  000bb	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR $T21[ebp], xmm0
  000c2	8b 4b 0c	 mov	 ecx, DWORD PTR _x1$[ebx]
  000c5	0f 10 85 70 ff
	ff ff		 movups	 xmm0, XMMWORD PTR $T21[ebp]
  000cc	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 1559 :     x1 = _mm_shuffle_epi32(  x1, _MM_SHUFFLE(3,1,2,0));

  000cf	8b 53 0c	 mov	 edx, DWORD PTR _x1$[ebx]
  000d2	66 0f 70 02 d8	 pshufd	 xmm0, XMMWORD PTR [edx], 216 ; 000000d8H
  000d7	0f 29 85 60 ff
	ff ff		 movaps	 XMMWORD PTR $T20[ebp], xmm0
  000de	8b 43 0c	 mov	 eax, DWORD PTR _x1$[ebx]
  000e1	0f 10 85 60 ff
	ff ff		 movups	 xmm0, XMMWORD PTR $T20[ebp]
  000e8	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 1560 :     x1 = _mm_shufflelo_epi16(x1, _MM_SHUFFLE(3,1,2,0));

  000eb	8b 4b 0c	 mov	 ecx, DWORD PTR _x1$[ebx]
  000ee	f2 0f 70 01 d8	 pshuflw xmm0, XMMWORD PTR [ecx], 216 ; 000000d8H
  000f3	0f 29 85 50 ff
	ff ff		 movaps	 XMMWORD PTR $T19[ebp], xmm0
  000fa	8b 53 0c	 mov	 edx, DWORD PTR _x1$[ebx]
  000fd	0f 10 85 50 ff
	ff ff		 movups	 xmm0, XMMWORD PTR $T19[ebp]
  00104	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 1561 :     x1 = _mm_shufflehi_epi16(x1, _MM_SHUFFLE(3,1,2,0));

  00107	8b 43 0c	 mov	 eax, DWORD PTR _x1$[ebx]
  0010a	f3 0f 70 00 d8	 pshufhw xmm0, XMMWORD PTR [eax], 216 ; 000000d8H
  0010f	0f 29 85 40 ff
	ff ff		 movaps	 XMMWORD PTR $T18[ebp], xmm0
  00116	8b 4b 0c	 mov	 ecx, DWORD PTR _x1$[ebx]
  00119	0f 10 85 40 ff
	ff ff		 movups	 xmm0, XMMWORD PTR $T18[ebp]
  00120	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 1562 : 
; 1563 :     x2 = _mm_shufflelo_epi16(x2, _MM_SHUFFLE(3,1,2,0));

  00123	8b 53 10	 mov	 edx, DWORD PTR _x2$[ebx]
  00126	f2 0f 70 02 d8	 pshuflw xmm0, XMMWORD PTR [edx], 216 ; 000000d8H
  0012b	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR $T17[ebp], xmm0
  00132	8b 43 10	 mov	 eax, DWORD PTR _x2$[ebx]
  00135	0f 10 85 30 ff
	ff ff		 movups	 xmm0, XMMWORD PTR $T17[ebp]
  0013c	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 1564 :     x2 = _mm_shufflehi_epi16(x2, _MM_SHUFFLE(3,1,2,0));

  0013f	8b 4b 10	 mov	 ecx, DWORD PTR _x2$[ebx]
  00142	f3 0f 70 01 d8	 pshufhw xmm0, XMMWORD PTR [ecx], 216 ; 000000d8H
  00147	0f 29 85 20 ff
	ff ff		 movaps	 XMMWORD PTR $T16[ebp], xmm0
  0014e	8b 53 10	 mov	 edx, DWORD PTR _x2$[ebx]
  00151	0f 10 85 20 ff
	ff ff		 movups	 xmm0, XMMWORD PTR $T16[ebp]
  00158	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 1565 :     x2 = _mm_shuffle_epi32(  x2, _MM_SHUFFLE(3,1,2,0));

  0015b	8b 43 10	 mov	 eax, DWORD PTR _x2$[ebx]
  0015e	66 0f 70 00 d8	 pshufd	 xmm0, XMMWORD PTR [eax], 216 ; 000000d8H
  00163	0f 29 85 10 ff
	ff ff		 movaps	 XMMWORD PTR $T15[ebp], xmm0
  0016a	8b 4b 10	 mov	 ecx, DWORD PTR _x2$[ebx]
  0016d	0f 10 85 10 ff
	ff ff		 movups	 xmm0, XMMWORD PTR $T15[ebp]
  00174	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 1566 :     x2 = _mm_shufflelo_epi16(x2, _MM_SHUFFLE(3,1,2,0));

  00177	8b 53 10	 mov	 edx, DWORD PTR _x2$[ebx]
  0017a	f2 0f 70 02 d8	 pshuflw xmm0, XMMWORD PTR [edx], 216 ; 000000d8H
  0017f	0f 29 85 00 ff
	ff ff		 movaps	 XMMWORD PTR $T14[ebp], xmm0
  00186	8b 43 10	 mov	 eax, DWORD PTR _x2$[ebx]
  00189	0f 10 85 00 ff
	ff ff		 movups	 xmm0, XMMWORD PTR $T14[ebp]
  00190	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 1567 :     x2 = _mm_shufflehi_epi16(x2, _MM_SHUFFLE(3,1,2,0));

  00193	8b 4b 10	 mov	 ecx, DWORD PTR _x2$[ebx]
  00196	f3 0f 70 01 d8	 pshufhw xmm0, XMMWORD PTR [ecx], 216 ; 000000d8H
  0019b	0f 29 85 f0 fe
	ff ff		 movaps	 XMMWORD PTR $T13[ebp], xmm0
  001a2	8b 53 10	 mov	 edx, DWORD PTR _x2$[ebx]
  001a5	0f 10 85 f0 fe
	ff ff		 movups	 xmm0, XMMWORD PTR $T13[ebp]
  001ac	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 1568 : 
; 1569 :     x3 = _mm_shuffle_epi32(x0, _MM_SHUFFLE(3,2,3,2));

  001af	8b 43 08	 mov	 eax, DWORD PTR _x0$[ebx]
  001b2	66 0f 70 00 ee	 pshufd	 xmm0, XMMWORD PTR [eax], 238 ; 000000eeH
  001b7	0f 29 85 e0 fe
	ff ff		 movaps	 XMMWORD PTR $T12[ebp], xmm0
  001be	0f 28 85 e0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T12[ebp]
  001c5	0f 29 45 f0	 movaps	 XMMWORD PTR _x3$[ebp], xmm0

; 1570 :     x0 = _mm_unpacklo_epi16(x0, x1);

  001c9	8b 4b 0c	 mov	 ecx, DWORD PTR _x1$[ebx]
  001cc	8b 53 08	 mov	 edx, DWORD PTR _x0$[ebx]
  001cf	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  001d2	66 0f 61 01	 punpcklwd xmm0, XMMWORD PTR [ecx]
  001d6	0f 29 85 d0 fe
	ff ff		 movaps	 XMMWORD PTR $T11[ebp], xmm0
  001dd	8b 43 08	 mov	 eax, DWORD PTR _x0$[ebx]
  001e0	0f 10 85 d0 fe
	ff ff		 movups	 xmm0, XMMWORD PTR $T11[ebp]
  001e7	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 1571 :     x1 = _mm_unpackhi_epi16(x1, x2);

  001ea	8b 4b 10	 mov	 ecx, DWORD PTR _x2$[ebx]
  001ed	8b 53 0c	 mov	 edx, DWORD PTR _x1$[ebx]
  001f0	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  001f3	66 0f 69 01	 punpckhwd xmm0, XMMWORD PTR [ecx]
  001f7	0f 29 85 c0 fe
	ff ff		 movaps	 XMMWORD PTR $T10[ebp], xmm0
  001fe	8b 43 0c	 mov	 eax, DWORD PTR _x1$[ebx]
  00201	0f 10 85 c0 fe
	ff ff		 movups	 xmm0, XMMWORD PTR $T10[ebp]
  00208	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 1572 :     x2 = _mm_unpacklo_epi16(x2, x3);

  0020b	8b 4b 10	 mov	 ecx, DWORD PTR _x2$[ebx]
  0020e	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00211	66 0f 61 45 f0	 punpcklwd xmm0, XMMWORD PTR _x3$[ebp]
  00216	0f 29 85 b0 fe
	ff ff		 movaps	 XMMWORD PTR $T9[ebp], xmm0
  0021d	8b 53 10	 mov	 edx, DWORD PTR _x2$[ebx]
  00220	0f 10 85 b0 fe
	ff ff		 movups	 xmm0, XMMWORD PTR $T9[ebp]
  00227	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 1573 : 
; 1574 :     x3 = _mm_shuffle_epi32(x0, _MM_SHUFFLE(3,2,3,2));

  0022a	8b 43 08	 mov	 eax, DWORD PTR _x0$[ebx]
  0022d	66 0f 70 00 ee	 pshufd	 xmm0, XMMWORD PTR [eax], 238 ; 000000eeH
  00232	0f 29 85 a0 fe
	ff ff		 movaps	 XMMWORD PTR $T8[ebp], xmm0
  00239	0f 28 85 a0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T8[ebp]
  00240	0f 29 45 f0	 movaps	 XMMWORD PTR _x3$[ebp], xmm0

; 1575 :     x0 = _mm_unpacklo_epi32(x0, x2);

  00244	8b 4b 10	 mov	 ecx, DWORD PTR _x2$[ebx]
  00247	8b 53 08	 mov	 edx, DWORD PTR _x0$[ebx]
  0024a	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  0024d	66 0f 62 01	 punpckldq xmm0, XMMWORD PTR [ecx]
  00251	0f 29 85 90 fe
	ff ff		 movaps	 XMMWORD PTR $T7[ebp], xmm0
  00258	8b 43 08	 mov	 eax, DWORD PTR _x0$[ebx]
  0025b	0f 10 85 90 fe
	ff ff		 movups	 xmm0, XMMWORD PTR $T7[ebp]
  00262	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 1576 :     x2 = _mm_unpackhi_epi32(x2, x1);

  00265	8b 4b 0c	 mov	 ecx, DWORD PTR _x1$[ebx]
  00268	8b 53 10	 mov	 edx, DWORD PTR _x2$[ebx]
  0026b	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  0026e	66 0f 6a 01	 punpckhdq xmm0, XMMWORD PTR [ecx]
  00272	0f 29 85 80 fe
	ff ff		 movaps	 XMMWORD PTR $T6[ebp], xmm0
  00279	8b 43 10	 mov	 eax, DWORD PTR _x2$[ebx]
  0027c	0f 10 85 80 fe
	ff ff		 movups	 xmm0, XMMWORD PTR $T6[ebp]
  00283	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 1577 :     x1 = _mm_unpacklo_epi32(x1, x3);

  00286	8b 4b 0c	 mov	 ecx, DWORD PTR _x1$[ebx]
  00289	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  0028c	66 0f 62 45 f0	 punpckldq xmm0, XMMWORD PTR _x3$[ebp]
  00291	0f 29 85 70 fe
	ff ff		 movaps	 XMMWORD PTR $T5[ebp], xmm0
  00298	8b 53 0c	 mov	 edx, DWORD PTR _x1$[ebx]
  0029b	0f 10 85 70 fe
	ff ff		 movups	 xmm0, XMMWORD PTR $T5[ebp]
  002a2	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 1578 : 
; 1579 :     x3 = _mm_shuffle_epi32(x0, _MM_SHUFFLE(3,2,3,2));

  002a5	8b 43 08	 mov	 eax, DWORD PTR _x0$[ebx]
  002a8	66 0f 70 00 ee	 pshufd	 xmm0, XMMWORD PTR [eax], 238 ; 000000eeH
  002ad	0f 29 85 60 fe
	ff ff		 movaps	 XMMWORD PTR $T4[ebp], xmm0
  002b4	0f 28 85 60 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T4[ebp]
  002bb	0f 29 45 f0	 movaps	 XMMWORD PTR _x3$[ebp], xmm0

; 1580 :     x0 = _mm_unpacklo_epi64(x0, x1);

  002bf	8b 4b 0c	 mov	 ecx, DWORD PTR _x1$[ebx]
  002c2	8b 53 08	 mov	 edx, DWORD PTR _x0$[ebx]
  002c5	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  002c8	66 0f 6c 01	 punpcklqdq xmm0, XMMWORD PTR [ecx]
  002cc	0f 29 85 50 fe
	ff ff		 movaps	 XMMWORD PTR $T3[ebp], xmm0
  002d3	8b 43 08	 mov	 eax, DWORD PTR _x0$[ebx]
  002d6	0f 10 85 50 fe
	ff ff		 movups	 xmm0, XMMWORD PTR $T3[ebp]
  002dd	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 1581 :     x1 = _mm_unpackhi_epi64(x1, x2);

  002e0	8b 4b 10	 mov	 ecx, DWORD PTR _x2$[ebx]
  002e3	8b 53 0c	 mov	 edx, DWORD PTR _x1$[ebx]
  002e6	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  002e9	66 0f 6d 01	 punpckhqdq xmm0, XMMWORD PTR [ecx]
  002ed	0f 29 85 40 fe
	ff ff		 movaps	 XMMWORD PTR $T2[ebp], xmm0
  002f4	8b 43 0c	 mov	 eax, DWORD PTR _x1$[ebx]
  002f7	0f 10 85 40 fe
	ff ff		 movups	 xmm0, XMMWORD PTR $T2[ebp]
  002fe	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 1582 :     x2 = _mm_unpacklo_epi64(x2, x3);

  00301	8b 4b 10	 mov	 ecx, DWORD PTR _x2$[ebx]
  00304	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00307	66 0f 6c 45 f0	 punpcklqdq xmm0, XMMWORD PTR _x3$[ebp]
  0030c	0f 29 85 30 fe
	ff ff		 movaps	 XMMWORD PTR $T1[ebp], xmm0
  00313	8b 53 10	 mov	 edx, DWORD PTR _x2$[ebx]
  00316	0f 10 85 30 fe
	ff ff		 movups	 xmm0, XMMWORD PTR $T1[ebp]
  0031d	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 1583 : 
; 1584 :     x4 = x2;

  00320	8b 43 10	 mov	 eax, DWORD PTR _x2$[ebx]
  00323	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00326	0f 11 45 e0	 movups	 XMMWORD PTR _x4$[ebp], xmm0

; 1585 :     x2 = x1;

  0032a	8b 4b 10	 mov	 ecx, DWORD PTR _x2$[ebx]
  0032d	8b 53 0c	 mov	 edx, DWORD PTR _x1$[ebx]
  00330	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  00333	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 1586 :     x1 = x4;

  00336	8b 43 0c	 mov	 eax, DWORD PTR _x1$[ebx]
  00339	0f 10 45 e0	 movups	 xmm0, XMMWORD PTR _x4$[ebp]
  0033d	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 1587 : #endif
; 1588 : }

  00340	5f		 pop	 edi
  00341	8b e5		 mov	 esp, ebp
  00343	5d		 pop	 ebp
  00344	8b e3		 mov	 esp, ebx
  00346	5b		 pop	 ebx
  00347	c3		 ret	 0
?gather_y_u_v_to_yc48@@YAXAAT__m128i@@00@Z ENDP		; gather_y_u_v_to_yc48
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -592						; size = 16
$T2 = -576						; size = 16
$T3 = -560						; size = 16
$T4 = -544						; size = 16
$T5 = -528						; size = 16
$T6 = -512						; size = 16
$T7 = -496						; size = 16
$T8 = -480						; size = 16
$T9 = -464						; size = 16
$T10 = -448						; size = 16
$T11 = -432						; size = 16
$T12 = -416						; size = 16
$T13 = -400						; size = 16
$T14 = -384						; size = 16
$T15 = -368						; size = 16
$T16 = -352						; size = 16
$T17 = -336						; size = 16
$T18 = -320						; size = 16
$T19 = -304						; size = 16
$T20 = -288						; size = 16
$T21 = -272						; size = 16
$T22 = -256						; size = 16
$T23 = -240						; size = 16
$T24 = -224						; size = 16
$T25 = -208						; size = 16
$T26 = -192						; size = 16
$T27 = -176						; size = 16
$T28 = -160						; size = 16
$T29 = -144						; size = 16
$T30 = -128						; size = 16
$T31 = -112						; size = 16
$T32 = -96						; size = 16
$T33 = -80						; size = 16
_xMask$ = -64						; size = 16
_x7$ = -48						; size = 16
_x6$ = -32						; size = 16
_x5$ = -16						; size = 16
_x0$ = 8						; size = 4
_x1$ = 12						; size = 4
_x2$ = 16						; size = 4
?gather_y_u_v_from_yc48@@YAXAAT__m128i@@00@Z PROC	; gather_y_u_v_from_yc48

; 1464 : static __forceinline void gather_y_u_v_from_yc48(__m128i& x0, __m128i& x1, __m128i& x2) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 50 02 00
	00		 sub	 esp, 592		; 00000250H
  0001c	57		 push	 edi
  0001d	8d bd b0 fd ff
	ff		 lea	 edi, DWORD PTR [ebp-592]
  00023	b9 94 00 00 00	 mov	 ecx, 148		; 00000094H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd

; 1465 : #if USE_SSE41
; 1466 :     __m128i x3, x4, x5;
; 1467 :     const int MASK_INT = 0x40 + 0x08 + 0x01;
; 1468 :     x3 = _mm_blend_epi16(x2, x0, MASK_INT);
; 1469 :     x4 = _mm_blend_epi16(x1, x2, MASK_INT);
; 1470 :     x5 = _mm_blend_epi16(x0, x1, MASK_INT);
; 1471 : 
; 1472 :     x3 = _mm_blend_epi16(x3, x1, MASK_INT<<1);
; 1473 :     x4 = _mm_blend_epi16(x4, x0, MASK_INT<<1);
; 1474 :     x5 = _mm_blend_epi16(x5, x2, MASK_INT<<1);
; 1475 : 
; 1476 :     x0 = _mm_shuffle_epi8(x3, xC_SUFFLE_YCP_Y);
; 1477 :     x1 = _mm_shuffle_epi8(x4, _mm_alignr_epi8_simd(xC_SUFFLE_YCP_Y, xC_SUFFLE_YCP_Y, 6));
; 1478 :     x2 = _mm_shuffle_epi8(x5, _mm_alignr_epi8_simd(xC_SUFFLE_YCP_Y, xC_SUFFLE_YCP_Y, 12));
; 1479 : #else
; 1480 :     //code from afs v7.5a+10
; 1481 :     __m128i x5, x6, x7, xMask;
; 1482 :     //select y
; 1483 :     alignas(16) static const uint16_t maskY_select[8] = { 0xffff, 0x0000, 0x0000, 0xffff, 0x0000, 0x0000, 0xffff, 0x0000 };
; 1484 :     xMask = _mm_load_si128((__m128i*)maskY_select);

  0002f	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR ?maskY_select@?1??gather_y_u_v_from_yc48@@YAXAAT__m128i@@00@Z@4QBGB
  00036	0f 29 45 b0	 movaps	 XMMWORD PTR $T33[ebp], xmm0
  0003a	0f 28 45 b0	 movaps	 xmm0, XMMWORD PTR $T33[ebp]
  0003e	0f 29 45 c0	 movaps	 XMMWORD PTR _xMask$[ebp], xmm0

; 1485 : 
; 1486 :     x5 = select_by_mask(x2, x0, xMask);

  00042	0f 28 55 c0	 movaps	 xmm2, XMMWORD PTR _xMask$[ebp]
  00046	8b 43 08	 mov	 eax, DWORD PTR _x0$[ebx]
  00049	0f 10 08	 movups	 xmm1, XMMWORD PTR [eax]
  0004c	8b 4b 10	 mov	 ecx, DWORD PTR _x2$[ebx]
  0004f	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00052	e8 00 00 00 00	 call	 ?select_by_mask@@YA?AT__m128i@@T1@00@Z ; select_by_mask
  00057	0f 29 45 a0	 movaps	 XMMWORD PTR $T32[ebp], xmm0
  0005b	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR $T32[ebp]
  0005f	0f 29 45 f0	 movaps	 XMMWORD PTR _x5$[ebp], xmm0

; 1487 :     xMask = _mm_slli_si128(xMask, 2);

  00063	0f 28 45 c0	 movaps	 xmm0, XMMWORD PTR _xMask$[ebp]
  00067	66 0f 73 f8 02	 pslldq	 xmm0, 2
  0006c	0f 29 45 90	 movaps	 XMMWORD PTR $T31[ebp], xmm0
  00070	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR $T31[ebp]
  00074	0f 29 45 c0	 movaps	 XMMWORD PTR _xMask$[ebp], xmm0

; 1488 :     x5 = select_by_mask(x5, x1, xMask); //52741630

  00078	0f 28 55 c0	 movaps	 xmm2, XMMWORD PTR _xMask$[ebp]
  0007c	8b 53 0c	 mov	 edx, DWORD PTR _x1$[ebx]
  0007f	0f 10 0a	 movups	 xmm1, XMMWORD PTR [edx]
  00082	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x5$[ebp]
  00086	e8 00 00 00 00	 call	 ?select_by_mask@@YA?AT__m128i@@T1@00@Z ; select_by_mask
  0008b	0f 29 45 80	 movaps	 XMMWORD PTR $T30[ebp], xmm0
  0008f	0f 28 45 80	 movaps	 xmm0, XMMWORD PTR $T30[ebp]
  00093	0f 29 45 f0	 movaps	 XMMWORD PTR _x5$[ebp], xmm0

; 1489 : 
; 1490 :     x6 = _mm_unpacklo_epi16(x5, x5);    //11663300

  00097	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x5$[ebp]
  0009b	66 0f 61 45 f0	 punpcklwd xmm0, XMMWORD PTR _x5$[ebp]
  000a0	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR $T29[ebp], xmm0
  000a7	0f 28 85 70 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T29[ebp]
  000ae	0f 29 45 e0	 movaps	 XMMWORD PTR _x6$[ebp], xmm0

; 1491 :     x7 = _mm_unpackhi_epi16(x5, x5);    //55227744

  000b2	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x5$[ebp]
  000b6	66 0f 69 45 f0	 punpckhwd xmm0, XMMWORD PTR _x5$[ebp]
  000bb	0f 29 85 60 ff
	ff ff		 movaps	 XMMWORD PTR $T28[ebp], xmm0
  000c2	0f 28 85 60 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T28[ebp]
  000c9	0f 29 45 d0	 movaps	 XMMWORD PTR _x7$[ebp], xmm0

; 1492 : 
; 1493 :     alignas(16) static const uint16_t maskY_shuffle[8] = { 0xffff, 0x0000, 0xffff, 0x0000, 0x0000, 0xffff, 0xffff, 0x0000 };
; 1494 :     xMask = _mm_load_si128((__m128i*)maskY_shuffle);

  000cd	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR ?maskY_shuffle@?1??gather_y_u_v_from_yc48@@YAXAAT__m128i@@00@Z@4QBGB
  000d4	0f 29 85 50 ff
	ff ff		 movaps	 XMMWORD PTR $T27[ebp], xmm0
  000db	0f 28 85 50 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T27[ebp]
  000e2	0f 29 45 c0	 movaps	 XMMWORD PTR _xMask$[ebp], xmm0

; 1495 :     x5 = select_by_mask(x7, x6, xMask);                 //51627340

  000e6	0f 28 55 c0	 movaps	 xmm2, XMMWORD PTR _xMask$[ebp]
  000ea	0f 28 4d e0	 movaps	 xmm1, XMMWORD PTR _x6$[ebp]
  000ee	0f 28 45 d0	 movaps	 xmm0, XMMWORD PTR _x7$[ebp]
  000f2	e8 00 00 00 00	 call	 ?select_by_mask@@YA?AT__m128i@@T1@00@Z ; select_by_mask
  000f7	0f 29 85 40 ff
	ff ff		 movaps	 XMMWORD PTR $T26[ebp], xmm0
  000fe	0f 28 85 40 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T26[ebp]
  00105	0f 29 45 f0	 movaps	 XMMWORD PTR _x5$[ebp], xmm0

; 1496 :     x5 = _mm_shuffle_epi32(x5, _MM_SHUFFLE(1, 2, 3, 0));   //73625140

  00109	66 0f 70 45 f0
	6c		 pshufd	 xmm0, XMMWORD PTR _x5$[ebp], 108 ; 0000006cH
  0010f	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR $T25[ebp], xmm0
  00116	0f 28 85 30 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T25[ebp]
  0011d	0f 29 45 f0	 movaps	 XMMWORD PTR _x5$[ebp], xmm0

; 1497 : 
; 1498 :     x5 = _mm_unpacklo_epi16(x5, _mm_srli_si128(x5, 8)); //75316420

  00121	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x5$[ebp]
  00125	66 0f 73 d8 08	 psrldq	 xmm0, 8
  0012a	0f 29 85 20 ff
	ff ff		 movaps	 XMMWORD PTR $T24[ebp], xmm0
  00131	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x5$[ebp]
  00135	66 0f 61 85 20
	ff ff ff	 punpcklwd xmm0, XMMWORD PTR $T24[ebp]
  0013d	0f 29 85 10 ff
	ff ff		 movaps	 XMMWORD PTR $T23[ebp], xmm0
  00144	0f 28 85 10 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T23[ebp]
  0014b	0f 29 45 f0	 movaps	 XMMWORD PTR _x5$[ebp], xmm0

; 1499 :     x5 = _mm_unpacklo_epi16(x5, _mm_srli_si128(x5, 8)); //76543210

  0014f	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x5$[ebp]
  00153	66 0f 73 d8 08	 psrldq	 xmm0, 8
  00158	0f 29 85 00 ff
	ff ff		 movaps	 XMMWORD PTR $T22[ebp], xmm0
  0015f	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x5$[ebp]
  00163	66 0f 61 85 00
	ff ff ff	 punpcklwd xmm0, XMMWORD PTR $T22[ebp]
  0016b	0f 29 85 f0 fe
	ff ff		 movaps	 XMMWORD PTR $T21[ebp], xmm0
  00172	0f 28 85 f0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T21[ebp]
  00179	0f 29 45 f0	 movaps	 XMMWORD PTR _x5$[ebp], xmm0

; 1500 : 
; 1501 :                                                         //select uv
; 1502 :     xMask = _mm_srli_si128(_mm_cmpeq_epi8(xMask, xMask), 8); //0x00000000, 0x00000000, 0xffffffff, 0xffffffff

  0017d	0f 28 45 c0	 movaps	 xmm0, XMMWORD PTR _xMask$[ebp]
  00181	66 0f 74 45 c0	 pcmpeqb xmm0, XMMWORD PTR _xMask$[ebp]
  00186	0f 29 85 e0 fe
	ff ff		 movaps	 XMMWORD PTR $T20[ebp], xmm0
  0018d	0f 28 85 e0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T20[ebp]
  00194	66 0f 73 d8 08	 psrldq	 xmm0, 8
  00199	0f 29 85 d0 fe
	ff ff		 movaps	 XMMWORD PTR $T19[ebp], xmm0
  001a0	0f 28 85 d0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T19[ebp]
  001a7	0f 29 45 c0	 movaps	 XMMWORD PTR _xMask$[ebp], xmm0

; 1503 :     x6 = select_by_mask(_mm_srli_si128(x1, 2), _mm_srli_si128(x2, 2), xMask); //x  x v4 u4 v6 u6 x  x

  001ab	8b 43 10	 mov	 eax, DWORD PTR _x2$[ebx]
  001ae	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  001b1	66 0f 73 d8 02	 psrldq	 xmm0, 2
  001b6	0f 29 85 b0 fe
	ff ff		 movaps	 XMMWORD PTR $T17[ebp], xmm0
  001bd	8b 4b 0c	 mov	 ecx, DWORD PTR _x1$[ebx]
  001c0	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  001c3	66 0f 73 d8 02	 psrldq	 xmm0, 2
  001c8	0f 29 85 c0 fe
	ff ff		 movaps	 XMMWORD PTR $T18[ebp], xmm0
  001cf	0f 28 55 c0	 movaps	 xmm2, XMMWORD PTR _xMask$[ebp]
  001d3	0f 28 8d b0 fe
	ff ff		 movaps	 xmm1, XMMWORD PTR $T17[ebp]
  001da	0f 28 85 c0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T18[ebp]
  001e1	e8 00 00 00 00	 call	 ?select_by_mask@@YA?AT__m128i@@T1@00@Z ; select_by_mask
  001e6	0f 29 85 a0 fe
	ff ff		 movaps	 XMMWORD PTR $T16[ebp], xmm0
  001ed	0f 28 85 a0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T16[ebp]
  001f4	0f 29 45 e0	 movaps	 XMMWORD PTR _x6$[ebp], xmm0

; 1504 :     x7 = select_by_mask(x0, x1, xMask);               //x  x  v1 u1 v3 u3 x  x

  001f8	0f 28 55 c0	 movaps	 xmm2, XMMWORD PTR _xMask$[ebp]
  001fc	8b 53 0c	 mov	 edx, DWORD PTR _x1$[ebx]
  001ff	0f 10 0a	 movups	 xmm1, XMMWORD PTR [edx]
  00202	8b 43 08	 mov	 eax, DWORD PTR _x0$[ebx]
  00205	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00208	e8 00 00 00 00	 call	 ?select_by_mask@@YA?AT__m128i@@T1@00@Z ; select_by_mask
  0020d	0f 29 85 90 fe
	ff ff		 movaps	 XMMWORD PTR $T15[ebp], xmm0
  00214	0f 28 85 90 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T15[ebp]
  0021b	0f 29 45 d0	 movaps	 XMMWORD PTR _x7$[ebp], xmm0

; 1505 :     xMask = _mm_slli_si128(xMask, 4);                 //0x00000000, 0xffffffff, 0xffffffff, 0x00000000

  0021f	0f 28 45 c0	 movaps	 xmm0, XMMWORD PTR _xMask$[ebp]
  00223	66 0f 73 f8 04	 pslldq	 xmm0, 4
  00228	0f 29 85 80 fe
	ff ff		 movaps	 XMMWORD PTR $T14[ebp], xmm0
  0022f	0f 28 85 80 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T14[ebp]
  00236	0f 29 45 c0	 movaps	 XMMWORD PTR _xMask$[ebp], xmm0

; 1506 :     x0 = _mm_alignr_epi8_simd(x1, x0, 2);             //v2 u2  x  x  x  x v0 u0

  0023a	8b 4b 08	 mov	 ecx, DWORD PTR _x0$[ebx]
  0023d	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00240	66 0f 73 d8 02	 psrldq	 xmm0, 2
  00245	0f 29 85 60 fe
	ff ff		 movaps	 XMMWORD PTR $T12[ebp], xmm0
  0024c	8b 53 0c	 mov	 edx, DWORD PTR _x1$[ebx]
  0024f	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  00252	66 0f 73 f8 0e	 pslldq	 xmm0, 14		; 0000000eH
  00257	0f 29 85 70 fe
	ff ff		 movaps	 XMMWORD PTR $T13[ebp], xmm0
  0025e	0f 28 85 70 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T13[ebp]
  00265	66 0f eb 85 60
	fe ff ff	 por	 xmm0, XMMWORD PTR $T12[ebp]
  0026d	0f 29 85 50 fe
	ff ff		 movaps	 XMMWORD PTR $T11[ebp], xmm0
  00274	8b 43 08	 mov	 eax, DWORD PTR _x0$[ebx]
  00277	0f 10 85 50 fe
	ff ff		 movups	 xmm0, XMMWORD PTR $T11[ebp]
  0027e	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 1507 :     x6 = select_by_mask(x0, x6, xMask);               //v2 u2 v4 u4 v6 u6 v0 u0

  00281	0f 28 55 c0	 movaps	 xmm2, XMMWORD PTR _xMask$[ebp]
  00285	0f 28 4d e0	 movaps	 xmm1, XMMWORD PTR _x6$[ebp]
  00289	8b 4b 08	 mov	 ecx, DWORD PTR _x0$[ebx]
  0028c	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  0028f	e8 00 00 00 00	 call	 ?select_by_mask@@YA?AT__m128i@@T1@00@Z ; select_by_mask
  00294	0f 29 85 40 fe
	ff ff		 movaps	 XMMWORD PTR $T10[ebp], xmm0
  0029b	0f 28 85 40 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T10[ebp]
  002a2	0f 29 45 e0	 movaps	 XMMWORD PTR _x6$[ebp], xmm0

; 1508 :     x7 = select_by_mask(x2, x7, xMask);               //v7 u7 v1 u1 v3 u3 v5 u5

  002a6	0f 28 55 c0	 movaps	 xmm2, XMMWORD PTR _xMask$[ebp]
  002aa	0f 28 4d d0	 movaps	 xmm1, XMMWORD PTR _x7$[ebp]
  002ae	8b 53 10	 mov	 edx, DWORD PTR _x2$[ebx]
  002b1	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  002b4	e8 00 00 00 00	 call	 ?select_by_mask@@YA?AT__m128i@@T1@00@Z ; select_by_mask
  002b9	0f 29 85 30 fe
	ff ff		 movaps	 XMMWORD PTR $T9[ebp], xmm0
  002c0	0f 28 85 30 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T9[ebp]
  002c7	0f 29 45 d0	 movaps	 XMMWORD PTR _x7$[ebp], xmm0

; 1509 :     x0 = _mm_shuffle_epi32(x6, _MM_SHUFFLE(1, 2, 3, 0)); //v6 u6 v4 u4 v2 u2 v0 u0

  002cb	66 0f 70 45 e0
	6c		 pshufd	 xmm0, XMMWORD PTR _x6$[ebp], 108 ; 0000006cH
  002d1	0f 29 85 20 fe
	ff ff		 movaps	 XMMWORD PTR $T8[ebp], xmm0
  002d8	8b 43 08	 mov	 eax, DWORD PTR _x0$[ebx]
  002db	0f 10 85 20 fe
	ff ff		 movups	 xmm0, XMMWORD PTR $T8[ebp]
  002e2	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 1510 :     x1 = _mm_shuffle_epi32(x7, _MM_SHUFFLE(3, 0, 1, 2)); //v7 u7 v5 u5 v3 u3 v1 u1

  002e5	66 0f 70 45 d0
	c6		 pshufd	 xmm0, XMMWORD PTR _x7$[ebp], 198 ; 000000c6H
  002eb	0f 29 85 10 fe
	ff ff		 movaps	 XMMWORD PTR $T7[ebp], xmm0
  002f2	8b 4b 0c	 mov	 ecx, DWORD PTR _x1$[ebx]
  002f5	0f 10 85 10 fe
	ff ff		 movups	 xmm0, XMMWORD PTR $T7[ebp]
  002fc	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 1511 : 
; 1512 :     x6 = _mm_unpacklo_epi16(x0, x1); //v3 v2 u3 u2 v1 v0 u1 u0

  002ff	8b 53 0c	 mov	 edx, DWORD PTR _x1$[ebx]
  00302	8b 43 08	 mov	 eax, DWORD PTR _x0$[ebx]
  00305	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00308	66 0f 61 02	 punpcklwd xmm0, XMMWORD PTR [edx]
  0030c	0f 29 85 00 fe
	ff ff		 movaps	 XMMWORD PTR $T6[ebp], xmm0
  00313	0f 28 85 00 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T6[ebp]
  0031a	0f 29 45 e0	 movaps	 XMMWORD PTR _x6$[ebp], xmm0

; 1513 :     x7 = _mm_unpackhi_epi16(x0, x1); //v7 v6 u7 u6 v5 v4 u5 u4

  0031e	8b 4b 0c	 mov	 ecx, DWORD PTR _x1$[ebx]
  00321	8b 53 08	 mov	 edx, DWORD PTR _x0$[ebx]
  00324	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  00327	66 0f 69 01	 punpckhwd xmm0, XMMWORD PTR [ecx]
  0032b	0f 29 85 f0 fd
	ff ff		 movaps	 XMMWORD PTR $T5[ebp], xmm0
  00332	0f 28 85 f0 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T5[ebp]
  00339	0f 29 45 d0	 movaps	 XMMWORD PTR _x7$[ebp], xmm0

; 1514 : 
; 1515 :     x0 = _mm_unpacklo_epi32(x6, x7); //v5 v4 v1 v0 u5 u4 u1 u0

  0033d	0f 28 45 e0	 movaps	 xmm0, XMMWORD PTR _x6$[ebp]
  00341	66 0f 62 45 d0	 punpckldq xmm0, XMMWORD PTR _x7$[ebp]
  00346	0f 29 85 e0 fd
	ff ff		 movaps	 XMMWORD PTR $T4[ebp], xmm0
  0034d	8b 43 08	 mov	 eax, DWORD PTR _x0$[ebx]
  00350	0f 10 85 e0 fd
	ff ff		 movups	 xmm0, XMMWORD PTR $T4[ebp]
  00357	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 1516 :     x1 = _mm_unpackhi_epi32(x6, x7); //v7 v6 v3 v2 u7 u6 u3 u2

  0035a	0f 28 45 e0	 movaps	 xmm0, XMMWORD PTR _x6$[ebp]
  0035e	66 0f 6a 45 d0	 punpckhdq xmm0, XMMWORD PTR _x7$[ebp]
  00363	0f 29 85 d0 fd
	ff ff		 movaps	 XMMWORD PTR $T3[ebp], xmm0
  0036a	8b 4b 0c	 mov	 ecx, DWORD PTR _x1$[ebx]
  0036d	0f 10 85 d0 fd
	ff ff		 movups	 xmm0, XMMWORD PTR $T3[ebp]
  00374	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 1517 : 
; 1518 :     x6 = _mm_unpacklo_epi32(x0, x1); //u7 u6 u5 u4 u3 u2 u1 u0

  00377	8b 53 0c	 mov	 edx, DWORD PTR _x1$[ebx]
  0037a	8b 43 08	 mov	 eax, DWORD PTR _x0$[ebx]
  0037d	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00380	66 0f 62 02	 punpckldq xmm0, XMMWORD PTR [edx]
  00384	0f 29 85 c0 fd
	ff ff		 movaps	 XMMWORD PTR $T2[ebp], xmm0
  0038b	0f 28 85 c0 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T2[ebp]
  00392	0f 29 45 e0	 movaps	 XMMWORD PTR _x6$[ebp], xmm0

; 1519 :     x7 = _mm_unpackhi_epi32(x0, x1); //v7 v6 v5 v4 v3 v2 v1 v0

  00396	8b 4b 0c	 mov	 ecx, DWORD PTR _x1$[ebx]
  00399	8b 53 08	 mov	 edx, DWORD PTR _x0$[ebx]
  0039c	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  0039f	66 0f 6a 01	 punpckhdq xmm0, XMMWORD PTR [ecx]
  003a3	0f 29 85 b0 fd
	ff ff		 movaps	 XMMWORD PTR $T1[ebp], xmm0
  003aa	0f 28 85 b0 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T1[ebp]
  003b1	0f 29 45 d0	 movaps	 XMMWORD PTR _x7$[ebp], xmm0

; 1520 : 
; 1521 :     x0 = x5;

  003b5	8b 43 08	 mov	 eax, DWORD PTR _x0$[ebx]
  003b8	0f 10 45 f0	 movups	 xmm0, XMMWORD PTR _x5$[ebp]
  003bc	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 1522 :     x1 = x6;

  003bf	8b 4b 0c	 mov	 ecx, DWORD PTR _x1$[ebx]
  003c2	0f 10 45 e0	 movups	 xmm0, XMMWORD PTR _x6$[ebp]
  003c6	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 1523 :     x2 = x7;

  003c9	8b 53 10	 mov	 edx, DWORD PTR _x2$[ebx]
  003cc	0f 10 45 d0	 movups	 xmm0, XMMWORD PTR _x7$[ebp]
  003d0	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 1524 : #endif //USE_SSE41
; 1525 : }

  003d3	5f		 pop	 edi
  003d4	8b e5		 mov	 esp, ebp
  003d6	5d		 pop	 ebp
  003d7	8b e3		 mov	 esp, ebx
  003d9	5b		 pop	 ebx
  003da	c3		 ret	 0
?gather_y_u_v_from_yc48@@YAXAAT__m128i@@00@Z ENDP	; gather_y_u_v_from_yc48
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -272						; size = 16
$T2 = -256						; size = 16
$T3 = -240						; size = 16
$T4 = -224						; size = 16
$T5 = -208						; size = 16
$T6 = -192						; size = 16
$T7 = -176						; size = 16
$T8 = -160						; size = 16
_x1$ = -144						; size = 16
$T9 = -128						; size = 16
$T10 = -112						; size = 16
_xC_0x8000$ = -96					; size = 16
$T11 = -80						; size = 16
$T12 = -64						; size = 16
$T13 = -48						; size = 16
_xC_coeff$ = -32					; size = 16
_x0$ = -16						; size = 16
?convert_uv_range_to_yc48@@YA?AT__m128i@@T1@@Z PROC	; convert_uv_range_to_yc48
; _x0$ = xmm0

; 1447 : static __forceinline __m128i convert_uv_range_to_yc48(__m128i x0) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 10 01 00
	00		 sub	 esp, 272		; 00000110H
  0001c	57		 push	 edi
  0001d	8d bd f0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-272]
  00023	b9 44 00 00 00	 mov	 ecx, 68			; 00000044H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	0f 29 45 f0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1448 :     //coeff = 4682
; 1449 :     //UV = (( uv - 32768 ) * coef + (1<<15) ) >> 16
; 1450 :     const __m128i xC_coeff = _mm_unpacklo_epi16(_mm_set1_epi16(4682), _mm_set1_epi16(-1));

  00033	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@ffffffffffffffffffffffffffffffff
  0003a	0f 29 45 c0	 movaps	 XMMWORD PTR $T12[ebp], xmm0
  0003e	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@124a124a124a124a124a124a124a124a
  00045	0f 29 45 d0	 movaps	 XMMWORD PTR $T13[ebp], xmm0
  00049	0f 28 45 d0	 movaps	 xmm0, XMMWORD PTR $T13[ebp]
  0004d	66 0f 61 45 c0	 punpcklwd xmm0, XMMWORD PTR $T12[ebp]
  00052	0f 29 45 b0	 movaps	 XMMWORD PTR $T11[ebp], xmm0
  00056	0f 28 45 b0	 movaps	 xmm0, XMMWORD PTR $T11[ebp]
  0005a	0f 29 45 e0	 movaps	 XMMWORD PTR _xC_coeff$[ebp], xmm0

; 1451 :     const __m128i xC_0x8000 = _mm_slli_epi16(_mm_cmpeq_epi32(x0, x0), 15);

  0005e	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  00062	66 0f 76 45 f0	 pcmpeqd xmm0, XMMWORD PTR _x0$[ebp]
  00067	0f 29 45 90	 movaps	 XMMWORD PTR $T10[ebp], xmm0
  0006b	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR $T10[ebp]
  0006f	66 0f 71 f0 0f	 psllw	 xmm0, 15		; 0000000fH
  00074	0f 29 45 80	 movaps	 XMMWORD PTR $T9[ebp], xmm0
  00078	0f 28 45 80	 movaps	 xmm0, XMMWORD PTR $T9[ebp]
  0007c	0f 29 45 a0	 movaps	 XMMWORD PTR _xC_0x8000$[ebp], xmm0

; 1452 :     __m128i x1;
; 1453 :     x0 = _mm_add_epi16(x0, xC_0x8000); // -32768

  00080	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  00084	66 0f fd 45 a0	 paddw	 xmm0, XMMWORD PTR _xC_0x8000$[ebp]
  00089	0f 29 85 60 ff
	ff ff		 movaps	 XMMWORD PTR $T8[ebp], xmm0
  00090	0f 28 85 60 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T8[ebp]
  00097	0f 29 45 f0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1454 :     x1 = _mm_unpackhi_epi16(x0, xC_0x8000);

  0009b	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  0009f	66 0f 69 45 a0	 punpckhwd xmm0, XMMWORD PTR _xC_0x8000$[ebp]
  000a4	0f 29 85 50 ff
	ff ff		 movaps	 XMMWORD PTR $T7[ebp], xmm0
  000ab	0f 28 85 50 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T7[ebp]
  000b2	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR _x1$[ebp], xmm0

; 1455 :     x0 = _mm_unpacklo_epi16(x0, xC_0x8000);

  000b9	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  000bd	66 0f 61 45 a0	 punpcklwd xmm0, XMMWORD PTR _xC_0x8000$[ebp]
  000c2	0f 29 85 40 ff
	ff ff		 movaps	 XMMWORD PTR $T6[ebp], xmm0
  000c9	0f 28 85 40 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T6[ebp]
  000d0	0f 29 45 f0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1456 :     x0 = _mm_madd_epi16(x0, xC_coeff);

  000d4	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  000d8	66 0f f5 45 e0	 pmaddwd xmm0, XMMWORD PTR _xC_coeff$[ebp]
  000dd	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR $T5[ebp], xmm0
  000e4	0f 28 85 30 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T5[ebp]
  000eb	0f 29 45 f0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1457 :     x1 = _mm_madd_epi16(x1, xC_coeff);

  000ef	0f 28 85 70 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$[ebp]
  000f6	66 0f f5 45 e0	 pmaddwd xmm0, XMMWORD PTR _xC_coeff$[ebp]
  000fb	0f 29 85 20 ff
	ff ff		 movaps	 XMMWORD PTR $T4[ebp], xmm0
  00102	0f 28 85 20 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T4[ebp]
  00109	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR _x1$[ebp], xmm0

; 1458 :     x0 = _mm_srai_epi32(x0, 16);

  00110	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  00114	66 0f 72 e0 10	 psrad	 xmm0, 16		; 00000010H
  00119	0f 29 85 10 ff
	ff ff		 movaps	 XMMWORD PTR $T3[ebp], xmm0
  00120	0f 28 85 10 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T3[ebp]
  00127	0f 29 45 f0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1459 :     x1 = _mm_srai_epi32(x1, 16);

  0012b	0f 28 85 70 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$[ebp]
  00132	66 0f 72 e0 10	 psrad	 xmm0, 16		; 00000010H
  00137	0f 29 85 00 ff
	ff ff		 movaps	 XMMWORD PTR $T2[ebp], xmm0
  0013e	0f 28 85 00 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T2[ebp]
  00145	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR _x1$[ebp], xmm0

; 1460 :     x0 = _mm_packs_epi32(x0, x1);

  0014c	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  00150	66 0f 6b 85 70
	ff ff ff	 packssdw xmm0, XMMWORD PTR _x1$[ebp]
  00158	0f 29 85 f0 fe
	ff ff		 movaps	 XMMWORD PTR $T1[ebp], xmm0
  0015f	0f 28 85 f0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T1[ebp]
  00166	0f 29 45 f0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1461 :     return x0;

  0016a	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]

; 1462 : }

  0016e	5f		 pop	 edi
  0016f	8b e5		 mov	 esp, ebp
  00171	5d		 pop	 ebp
  00172	8b e3		 mov	 esp, ebx
  00174	5b		 pop	 ebx
  00175	c3		 ret	 0
?convert_uv_range_to_yc48@@YA?AT__m128i@@T1@@Z ENDP	; convert_uv_range_to_yc48
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -144						; size = 16
$T2 = -128						; size = 16
$T3 = -112						; size = 16
$T4 = -96						; size = 16
$T5 = -80						; size = 16
$T6 = -64						; size = 16
$T7 = -48						; size = 16
_xC_0x8000$ = -32					; size = 16
_x0$ = -16						; size = 16
?convert_y_range_to_yc48@@YA?AT__m128i@@T1@@Z PROC	; convert_y_range_to_yc48
; _x0$ = xmm0

; 1437 : static __forceinline __m128i convert_y_range_to_yc48(__m128i x0) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 90 00 00
	00		 sub	 esp, 144		; 00000090H
  0001c	57		 push	 edi
  0001d	8d bd 70 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-144]
  00023	b9 24 00 00 00	 mov	 ecx, 36			; 00000024H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	0f 29 45 f0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1438 :     //coef = 4788
; 1439 :     //((( y - 32768 ) * coef) >> 16 ) + (coef/2 - 299)
; 1440 :     const __m128i xC_0x8000 = _mm_slli_epi16(_mm_cmpeq_epi32(x0, x0), 15);

  00033	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  00037	66 0f 76 45 f0	 pcmpeqd xmm0, XMMWORD PTR _x0$[ebp]
  0003c	0f 29 45 d0	 movaps	 XMMWORD PTR $T7[ebp], xmm0
  00040	0f 28 45 d0	 movaps	 xmm0, XMMWORD PTR $T7[ebp]
  00044	66 0f 71 f0 0f	 psllw	 xmm0, 15		; 0000000fH
  00049	0f 29 45 c0	 movaps	 XMMWORD PTR $T6[ebp], xmm0
  0004d	0f 28 45 c0	 movaps	 xmm0, XMMWORD PTR $T6[ebp]
  00051	0f 29 45 e0	 movaps	 XMMWORD PTR _xC_0x8000$[ebp], xmm0

; 1441 :     x0 = _mm_add_epi16(x0, xC_0x8000); // -32768

  00055	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  00059	66 0f fd 45 e0	 paddw	 xmm0, XMMWORD PTR _xC_0x8000$[ebp]
  0005e	0f 29 45 b0	 movaps	 XMMWORD PTR $T5[ebp], xmm0
  00062	0f 28 45 b0	 movaps	 xmm0, XMMWORD PTR $T5[ebp]
  00066	0f 29 45 f0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1442 :     x0 = _mm_mulhi_epi16(x0, _mm_set1_epi16(4788));

  0006a	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@12b412b412b412b412b412b412b412b4
  00071	0f 29 45 a0	 movaps	 XMMWORD PTR $T4[ebp], xmm0
  00075	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  00079	66 0f e5 45 a0	 pmulhw	 xmm0, XMMWORD PTR $T4[ebp]
  0007e	0f 29 45 90	 movaps	 XMMWORD PTR $T3[ebp], xmm0
  00082	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR $T3[ebp]
  00086	0f 29 45 f0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1443 :     x0 = _mm_adds_epi16(x0, _mm_set1_epi16(4788/2 - 299));

  0008a	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@082f082f082f082f082f082f082f082f
  00091	0f 29 45 80	 movaps	 XMMWORD PTR $T2[ebp], xmm0
  00095	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  00099	66 0f ed 45 80	 paddsw	 xmm0, XMMWORD PTR $T2[ebp]
  0009e	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR $T1[ebp], xmm0
  000a5	0f 28 85 70 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T1[ebp]
  000ac	0f 29 45 f0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1444 :     return x0;

  000b0	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]

; 1445 : }

  000b4	5f		 pop	 edi
  000b5	8b e5		 mov	 esp, ebp
  000b7	5d		 pop	 ebp
  000b8	8b e3		 mov	 esp, ebx
  000ba	5b		 pop	 ebx
  000bb	c3		 ret	 0
?convert_y_range_to_yc48@@YA?AT__m128i@@T1@@Z ENDP	; convert_y_range_to_yc48
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -368						; size = 16
$T2 = -352						; size = 16
$T3 = -336						; size = 16
$T4 = -320						; size = 16
$T5 = -304						; size = 16
$T6 = -288						; size = 16
$T7 = -272						; size = 16
$T8 = -256						; size = 16
$T9 = -240						; size = 16
$T10 = -224						; size = 16
$T11 = -208						; size = 16
$T12 = -192						; size = 16
$T13 = -176						; size = 16
$T14 = -160						; size = 16
$T15 = -144						; size = 16
$T16 = -128						; size = 16
$T17 = -112						; size = 16
_x7$ = -96						; size = 16
_x6$ = -80						; size = 16
_x3$ = -64						; size = 16
_x2$ = -48						; size = 16
_x1$ = -32						; size = 16
_x0$ = -16						; size = 16
_xC_UV_OFFSET_x1$ = 8					; size = 4
_xC_UV_MA_16_0$ = 12					; size = 4
_xC_UV_MA_16_1$ = 16					; size = 4
_UV_RSH_16$ = 20					; size = 4
_xC_YCC$ = 24						; size = 4
_xC_pw_one$ = 28					; size = 4
?convert_uv_range_from_yc48_420i@@YA?AT__m128i@@T1@0ABT1@11H11@Z PROC ; convert_uv_range_from_yc48_420i
; _x0$ = xmm0
; _x1$ = xmm1

; 1411 : static __forceinline __m128i convert_uv_range_from_yc48_420i(__m128i x0, __m128i x1, const __m128i& xC_UV_OFFSET_x1, const __m128i& xC_UV_MA_16_0, const __m128i& xC_UV_MA_16_1, int UV_RSH_16, const __m128i& xC_YCC, const __m128i& xC_pw_one) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 70 01 00
	00		 sub	 esp, 368		; 00000170H
  0001c	57		 push	 edi
  0001d	8d bd 90 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-368]
  00023	b9 5c 00 00 00	 mov	 ecx, 92			; 0000005cH
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	0f 29 4d e0	 movaps	 XMMWORD PTR _x1$[ebp], xmm1
  00033	0f 29 45 f0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1412 :     __m128i x2, x3, x6, x7;
; 1413 :     x0 = _mm_add_epi16(x0, xC_UV_OFFSET_x1);

  00037	8b 43 08	 mov	 eax, DWORD PTR _xC_UV_OFFSET_x1$[ebx]
  0003a	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  0003e	66 0f fd 00	 paddw	 xmm0, XMMWORD PTR [eax]
  00042	0f 29 45 90	 movaps	 XMMWORD PTR $T17[ebp], xmm0
  00046	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR $T17[ebp]
  0004a	0f 29 45 f0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1414 :     x1 = _mm_add_epi16(x1, xC_UV_OFFSET_x1);

  0004e	8b 4b 08	 mov	 ecx, DWORD PTR _xC_UV_OFFSET_x1$[ebx]
  00051	0f 28 45 e0	 movaps	 xmm0, XMMWORD PTR _x1$[ebp]
  00055	66 0f fd 01	 paddw	 xmm0, XMMWORD PTR [ecx]
  00059	0f 29 45 80	 movaps	 XMMWORD PTR $T16[ebp], xmm0
  0005d	0f 28 45 80	 movaps	 xmm0, XMMWORD PTR $T16[ebp]
  00061	0f 29 45 e0	 movaps	 XMMWORD PTR _x1$[ebp], xmm0

; 1415 : 
; 1416 :     x7 = _mm_unpackhi_epi16(x0, xC_pw_one);

  00065	8b 53 1c	 mov	 edx, DWORD PTR _xC_pw_one$[ebx]
  00068	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  0006c	66 0f 69 02	 punpckhwd xmm0, XMMWORD PTR [edx]
  00070	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR $T15[ebp], xmm0
  00077	0f 28 85 70 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T15[ebp]
  0007e	0f 29 45 a0	 movaps	 XMMWORD PTR _x7$[ebp], xmm0

; 1417 :     x6 = _mm_unpacklo_epi16(x0, xC_pw_one);

  00082	8b 43 1c	 mov	 eax, DWORD PTR _xC_pw_one$[ebx]
  00085	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  00089	66 0f 61 00	 punpcklwd xmm0, XMMWORD PTR [eax]
  0008d	0f 29 85 60 ff
	ff ff		 movaps	 XMMWORD PTR $T14[ebp], xmm0
  00094	0f 28 85 60 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T14[ebp]
  0009b	0f 29 45 b0	 movaps	 XMMWORD PTR _x6$[ebp], xmm0

; 1418 :     x3 = _mm_unpackhi_epi16(x1, xC_pw_one);

  0009f	8b 4b 1c	 mov	 ecx, DWORD PTR _xC_pw_one$[ebx]
  000a2	0f 28 45 e0	 movaps	 xmm0, XMMWORD PTR _x1$[ebp]
  000a6	66 0f 69 01	 punpckhwd xmm0, XMMWORD PTR [ecx]
  000aa	0f 29 85 50 ff
	ff ff		 movaps	 XMMWORD PTR $T13[ebp], xmm0
  000b1	0f 28 85 50 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T13[ebp]
  000b8	0f 29 45 c0	 movaps	 XMMWORD PTR _x3$[ebp], xmm0

; 1419 :     x2 = _mm_unpacklo_epi16(x1, xC_pw_one);

  000bc	8b 53 1c	 mov	 edx, DWORD PTR _xC_pw_one$[ebx]
  000bf	0f 28 45 e0	 movaps	 xmm0, XMMWORD PTR _x1$[ebp]
  000c3	66 0f 61 02	 punpcklwd xmm0, XMMWORD PTR [edx]
  000c7	0f 29 85 40 ff
	ff ff		 movaps	 XMMWORD PTR $T12[ebp], xmm0
  000ce	0f 28 85 40 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T12[ebp]
  000d5	0f 29 45 d0	 movaps	 XMMWORD PTR _x2$[ebp], xmm0

; 1420 : 
; 1421 :     x6 = _mm_madd_epi16(x6, xC_UV_MA_16_0);

  000d9	8b 43 0c	 mov	 eax, DWORD PTR _xC_UV_MA_16_0$[ebx]
  000dc	0f 28 45 b0	 movaps	 xmm0, XMMWORD PTR _x6$[ebp]
  000e0	66 0f f5 00	 pmaddwd xmm0, XMMWORD PTR [eax]
  000e4	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR $T11[ebp], xmm0
  000eb	0f 28 85 30 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T11[ebp]
  000f2	0f 29 45 b0	 movaps	 XMMWORD PTR _x6$[ebp], xmm0

; 1422 :     x7 = _mm_madd_epi16(x7, xC_UV_MA_16_0);

  000f6	8b 4b 0c	 mov	 ecx, DWORD PTR _xC_UV_MA_16_0$[ebx]
  000f9	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _x7$[ebp]
  000fd	66 0f f5 01	 pmaddwd xmm0, XMMWORD PTR [ecx]
  00101	0f 29 85 20 ff
	ff ff		 movaps	 XMMWORD PTR $T10[ebp], xmm0
  00108	0f 28 85 20 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T10[ebp]
  0010f	0f 29 45 a0	 movaps	 XMMWORD PTR _x7$[ebp], xmm0

; 1423 :     x2 = _mm_madd_epi16(x2, xC_UV_MA_16_1);

  00113	8b 53 10	 mov	 edx, DWORD PTR _xC_UV_MA_16_1$[ebx]
  00116	0f 28 45 d0	 movaps	 xmm0, XMMWORD PTR _x2$[ebp]
  0011a	66 0f f5 02	 pmaddwd xmm0, XMMWORD PTR [edx]
  0011e	0f 29 85 10 ff
	ff ff		 movaps	 XMMWORD PTR $T9[ebp], xmm0
  00125	0f 28 85 10 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T9[ebp]
  0012c	0f 29 45 d0	 movaps	 XMMWORD PTR _x2$[ebp], xmm0

; 1424 :     x3 = _mm_madd_epi16(x3, xC_UV_MA_16_1);

  00130	8b 43 10	 mov	 eax, DWORD PTR _xC_UV_MA_16_1$[ebx]
  00133	0f 28 45 c0	 movaps	 xmm0, XMMWORD PTR _x3$[ebp]
  00137	66 0f f5 00	 pmaddwd xmm0, XMMWORD PTR [eax]
  0013b	0f 29 85 00 ff
	ff ff		 movaps	 XMMWORD PTR $T8[ebp], xmm0
  00142	0f 28 85 00 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T8[ebp]
  00149	0f 29 45 c0	 movaps	 XMMWORD PTR _x3$[ebp], xmm0

; 1425 :     x0 = _mm_add_epi32(x6, x2);

  0014d	0f 28 45 b0	 movaps	 xmm0, XMMWORD PTR _x6$[ebp]
  00151	66 0f fe 45 d0	 paddd	 xmm0, XMMWORD PTR _x2$[ebp]
  00156	0f 29 85 f0 fe
	ff ff		 movaps	 XMMWORD PTR $T7[ebp], xmm0
  0015d	0f 28 85 f0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T7[ebp]
  00164	0f 29 45 f0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1426 :     x7 = _mm_add_epi32(x7, x3);

  00168	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _x7$[ebp]
  0016c	66 0f fe 45 c0	 paddd	 xmm0, XMMWORD PTR _x3$[ebp]
  00171	0f 29 85 e0 fe
	ff ff		 movaps	 XMMWORD PTR $T6[ebp], xmm0
  00178	0f 28 85 e0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T6[ebp]
  0017f	0f 29 45 a0	 movaps	 XMMWORD PTR _x7$[ebp], xmm0

; 1427 :     x0 = _mm_srai_epi32(x0, UV_RSH_16);

  00183	8b 4b 14	 mov	 ecx, DWORD PTR _UV_RSH_16$[ebx]
  00186	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  0018a	66 0f 6e c9	 movd	 xmm1, ecx
  0018e	66 0f e2 c1	 psrad	 xmm0, xmm1
  00192	0f 29 85 d0 fe
	ff ff		 movaps	 XMMWORD PTR $T5[ebp], xmm0
  00199	0f 28 85 d0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T5[ebp]
  001a0	0f 29 45 f0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1428 :     x7 = _mm_srai_epi32(x7, UV_RSH_16);

  001a4	8b 53 14	 mov	 edx, DWORD PTR _UV_RSH_16$[ebx]
  001a7	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _x7$[ebp]
  001ab	66 0f 6e ca	 movd	 xmm1, edx
  001af	66 0f e2 c1	 psrad	 xmm0, xmm1
  001b3	0f 29 85 c0 fe
	ff ff		 movaps	 XMMWORD PTR $T4[ebp], xmm0
  001ba	0f 28 85 c0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T4[ebp]
  001c1	0f 29 45 a0	 movaps	 XMMWORD PTR _x7$[ebp], xmm0

; 1429 :     x0 = _mm_add_epi32(x0, xC_YCC);

  001c5	8b 43 18	 mov	 eax, DWORD PTR _xC_YCC$[ebx]
  001c8	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  001cc	66 0f fe 00	 paddd	 xmm0, XMMWORD PTR [eax]
  001d0	0f 29 85 b0 fe
	ff ff		 movaps	 XMMWORD PTR $T3[ebp], xmm0
  001d7	0f 28 85 b0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T3[ebp]
  001de	0f 29 45 f0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1430 :     x7 = _mm_add_epi32(x7, xC_YCC);

  001e2	8b 4b 18	 mov	 ecx, DWORD PTR _xC_YCC$[ebx]
  001e5	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _x7$[ebp]
  001e9	66 0f fe 01	 paddd	 xmm0, XMMWORD PTR [ecx]
  001ed	0f 29 85 a0 fe
	ff ff		 movaps	 XMMWORD PTR $T2[ebp], xmm0
  001f4	0f 28 85 a0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T2[ebp]
  001fb	0f 29 45 a0	 movaps	 XMMWORD PTR _x7$[ebp], xmm0

; 1431 : 
; 1432 :     x0 = _mm_packus_epi32_simd(x0, x7);

  001ff	0f 28 4d a0	 movaps	 xmm1, XMMWORD PTR _x7$[ebp]
  00203	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  00207	e8 00 00 00 00	 call	 ?_mm_packus_epi32_simd@@YA?AT__m128i@@T1@0@Z ; _mm_packus_epi32_simd
  0020c	0f 29 85 90 fe
	ff ff		 movaps	 XMMWORD PTR $T1[ebp], xmm0
  00213	0f 28 85 90 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T1[ebp]
  0021a	0f 29 45 f0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1433 : 
; 1434 :     return x0;

  0021e	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]

; 1435 : }

  00222	5f		 pop	 edi
  00223	8b e5		 mov	 esp, ebp
  00225	5d		 pop	 ebp
  00226	8b e3		 mov	 esp, ebx
  00228	5b		 pop	 ebx
  00229	c3		 ret	 0
?convert_uv_range_from_yc48_420i@@YA?AT__m128i@@T1@0ABT1@11H11@Z ENDP ; convert_uv_range_from_yc48_420i
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -80						; size = 16
$T2 = -64						; size = 16
$T3 = -48						; size = 16
_x1$ = -32						; size = 16
_x0$ = -16						; size = 16
_xC_UV_OFFSET_x2$ = 8					; size = 4
_xC_UV_MA_16$ = 12					; size = 4
_UV_RSH_16$ = 16					; size = 4
_xC_YCC$ = 20						; size = 4
_xC_pw_one$ = 24					; size = 4
?convert_uv_range_from_yc48_yuv420p@@YA?AT__m128i@@T1@0ABT1@1H11@Z PROC ; convert_uv_range_from_yc48_yuv420p
; _x0$ = xmm0
; _x1$ = xmm1

; 1405 : static __forceinline __m128i convert_uv_range_from_yc48_yuv420p(__m128i x0, __m128i x1, const __m128i& xC_UV_OFFSET_x2, const __m128i& xC_UV_MA_16, int UV_RSH_16, const __m128i& xC_YCC, const __m128i& xC_pw_one) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	83 ec 50	 sub	 esp, 80			; 00000050H
  00019	57		 push	 edi
  0001a	8d 7d b0	 lea	 edi, DWORD PTR [ebp-80]
  0001d	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  00022	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00027	f3 ab		 rep stosd
  00029	0f 29 4d e0	 movaps	 XMMWORD PTR _x1$[ebp], xmm1
  0002d	0f 29 45 f0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1406 :     x0 = _mm_add_epi16(x0, x1);

  00031	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  00035	66 0f fd 45 e0	 paddw	 xmm0, XMMWORD PTR _x1$[ebp]
  0003a	0f 29 45 d0	 movaps	 XMMWORD PTR $T3[ebp], xmm0
  0003e	0f 28 45 d0	 movaps	 xmm0, XMMWORD PTR $T3[ebp]
  00042	0f 29 45 f0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1407 :     x0 = _mm_add_epi16(x0, xC_UV_OFFSET_x2);

  00046	8b 43 08	 mov	 eax, DWORD PTR _xC_UV_OFFSET_x2$[ebx]
  00049	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  0004d	66 0f fd 00	 paddw	 xmm0, XMMWORD PTR [eax]
  00051	0f 29 45 c0	 movaps	 XMMWORD PTR $T2[ebp], xmm0
  00055	0f 28 45 c0	 movaps	 xmm0, XMMWORD PTR $T2[ebp]
  00059	0f 29 45 f0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1408 : 
; 1409 :     return convert_uv_range_after_adding_offset(x0, xC_UV_MA_16, UV_RSH_16, xC_YCC, xC_pw_one);

  0005d	8b 4b 18	 mov	 ecx, DWORD PTR _xC_pw_one$[ebx]
  00060	51		 push	 ecx
  00061	8b 53 14	 mov	 edx, DWORD PTR _xC_YCC$[ebx]
  00064	52		 push	 edx
  00065	8b 43 10	 mov	 eax, DWORD PTR _UV_RSH_16$[ebx]
  00068	50		 push	 eax
  00069	8b 4b 0c	 mov	 ecx, DWORD PTR _xC_UV_MA_16$[ebx]
  0006c	51		 push	 ecx
  0006d	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  00071	e8 00 00 00 00	 call	 ?convert_uv_range_after_adding_offset@@YA?AT__m128i@@T1@ABT1@H11@Z ; convert_uv_range_after_adding_offset
  00076	83 c4 10	 add	 esp, 16			; 00000010H
  00079	0f 29 45 b0	 movaps	 XMMWORD PTR $T1[ebp], xmm0
  0007d	0f 28 45 b0	 movaps	 xmm0, XMMWORD PTR $T1[ebp]

; 1410 : }

  00081	5f		 pop	 edi
  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	8b e3		 mov	 esp, ebx
  00087	5b		 pop	 ebx
  00088	c3		 ret	 0
?convert_uv_range_from_yc48_yuv420p@@YA?AT__m128i@@T1@0ABT1@1H11@Z ENDP ; convert_uv_range_from_yc48_yuv420p
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -96						; size = 16
$T2 = -80						; size = 16
_xC_YCC$ = -48						; size = 16
_x0$ = -16						; size = 16
_xC_UV_OFFSET_x1$ = 8					; size = 4
_xC_UV_MA_16$ = 12					; size = 4
_UV_RSH_16$ = 16					; size = 4
_xC_pw_one$ = 20					; size = 4
?convert_uv_range_from_yc48@@YA?AT__m128i@@T1@ABT1@1H01@Z PROC ; convert_uv_range_from_yc48
; _x0$ = xmm0
; _xC_YCC$ = xmm1

; 1400 : static __forceinline __m128i convert_uv_range_from_yc48(__m128i x0, const __m128i& xC_UV_OFFSET_x1, const __m128i& xC_UV_MA_16, int UV_RSH_16, __m128i xC_YCC, const __m128i& xC_pw_one) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	83 ec 60	 sub	 esp, 96			; 00000060H
  00019	57		 push	 edi
  0001a	8d 7d a0	 lea	 edi, DWORD PTR [ebp-96]
  0001d	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  00022	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00027	f3 ab		 rep stosd
  00029	0f 29 4d d0	 movaps	 XMMWORD PTR _xC_YCC$[ebp], xmm1
  0002d	0f 29 45 f0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1401 :     x0 = _mm_add_epi16(x0, xC_UV_OFFSET_x1);

  00031	8b 43 08	 mov	 eax, DWORD PTR _xC_UV_OFFSET_x1$[ebx]
  00034	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  00038	66 0f fd 00	 paddw	 xmm0, XMMWORD PTR [eax]
  0003c	0f 29 45 b0	 movaps	 XMMWORD PTR $T2[ebp], xmm0
  00040	0f 28 45 b0	 movaps	 xmm0, XMMWORD PTR $T2[ebp]
  00044	0f 29 45 f0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1402 : 
; 1403 :     return convert_uv_range_after_adding_offset(x0, xC_UV_MA_16, UV_RSH_16, xC_YCC, xC_pw_one);

  00048	8b 4b 14	 mov	 ecx, DWORD PTR _xC_pw_one$[ebx]
  0004b	51		 push	 ecx
  0004c	8d 55 d0	 lea	 edx, DWORD PTR _xC_YCC$[ebp]
  0004f	52		 push	 edx
  00050	8b 43 10	 mov	 eax, DWORD PTR _UV_RSH_16$[ebx]
  00053	50		 push	 eax
  00054	8b 4b 0c	 mov	 ecx, DWORD PTR _xC_UV_MA_16$[ebx]
  00057	51		 push	 ecx
  00058	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  0005c	e8 00 00 00 00	 call	 ?convert_uv_range_after_adding_offset@@YA?AT__m128i@@T1@ABT1@H11@Z ; convert_uv_range_after_adding_offset
  00061	83 c4 10	 add	 esp, 16			; 00000010H
  00064	0f 29 45 a0	 movaps	 XMMWORD PTR $T1[ebp], xmm0
  00068	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR $T1[ebp]

; 1404 : }

  0006c	52		 push	 edx
  0006d	8b cd		 mov	 ecx, ebp
  0006f	50		 push	 eax
  00070	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@convert_uv
  00076	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0007b	58		 pop	 eax
  0007c	5a		 pop	 edx
  0007d	5f		 pop	 edi
  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	8b e3		 mov	 esp, ebx
  00083	5b		 pop	 ebx
  00084	c3		 ret	 0
  00085	0f 1f 00	 npad	 3
$LN5@convert_uv:
  00088	01 00 00 00	 DD	 1
  0008c	00 00 00 00	 DD	 $LN4@convert_uv
$LN4@convert_uv:
  00090	d0 ff ff ff	 DD	 -48			; ffffffd0H
  00094	10 00 00 00	 DD	 16			; 00000010H
  00098	00 00 00 00	 DD	 $LN3@convert_uv
$LN3@convert_uv:
  0009c	78		 DB	 120			; 00000078H
  0009d	43		 DB	 67			; 00000043H
  0009e	5f		 DB	 95			; 0000005fH
  0009f	59		 DB	 89			; 00000059H
  000a0	43		 DB	 67			; 00000043H
  000a1	43		 DB	 67			; 00000043H
  000a2	00		 DB	 0
?convert_uv_range_from_yc48@@YA?AT__m128i@@T1@ABT1@1H01@Z ENDP ; convert_uv_range_from_yc48
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -176						; size = 16
$T2 = -160						; size = 16
$T3 = -144						; size = 16
$T4 = -128						; size = 16
$T5 = -112						; size = 16
$T6 = -96						; size = 16
$T7 = -80						; size = 16
$T8 = -64						; size = 16
$T9 = -48						; size = 16
_x1$ = -32						; size = 16
_x0$ = -16						; size = 16
_xC_UV_MA_16$ = 8					; size = 4
_UV_RSH_16$ = 12					; size = 4
_xC_YCC$ = 16						; size = 4
_xC_pw_one$ = 20					; size = 4
?convert_uv_range_after_adding_offset@@YA?AT__m128i@@T1@ABT1@H11@Z PROC ; convert_uv_range_after_adding_offset
; _x0$ = xmm0

; 1383 : static __forceinline __m128i convert_uv_range_after_adding_offset(__m128i x0, const __m128i& xC_UV_MA_16, int UV_RSH_16, const __m128i& xC_YCC, const __m128i& xC_pw_one) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec b0 00 00
	00		 sub	 esp, 176		; 000000b0H
  0001c	57		 push	 edi
  0001d	8d bd 50 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-176]
  00023	b9 2c 00 00 00	 mov	 ecx, 44			; 0000002cH
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	0f 29 45 f0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1384 :     __m128i x1;
; 1385 :     x1 = _mm_unpackhi_epi16(x0, xC_pw_one);

  00033	8b 43 14	 mov	 eax, DWORD PTR _xC_pw_one$[ebx]
  00036	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  0003a	66 0f 69 00	 punpckhwd xmm0, XMMWORD PTR [eax]
  0003e	0f 29 45 d0	 movaps	 XMMWORD PTR $T9[ebp], xmm0
  00042	0f 28 45 d0	 movaps	 xmm0, XMMWORD PTR $T9[ebp]
  00046	0f 29 45 e0	 movaps	 XMMWORD PTR _x1$[ebp], xmm0

; 1386 :     x0 = _mm_unpacklo_epi16(x0, xC_pw_one);

  0004a	8b 4b 14	 mov	 ecx, DWORD PTR _xC_pw_one$[ebx]
  0004d	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  00051	66 0f 61 01	 punpcklwd xmm0, XMMWORD PTR [ecx]
  00055	0f 29 45 c0	 movaps	 XMMWORD PTR $T8[ebp], xmm0
  00059	0f 28 45 c0	 movaps	 xmm0, XMMWORD PTR $T8[ebp]
  0005d	0f 29 45 f0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1387 : 
; 1388 :     x0 = _mm_madd_epi16(x0, xC_UV_MA_16);

  00061	8b 53 08	 mov	 edx, DWORD PTR _xC_UV_MA_16$[ebx]
  00064	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  00068	66 0f f5 02	 pmaddwd xmm0, XMMWORD PTR [edx]
  0006c	0f 29 45 b0	 movaps	 XMMWORD PTR $T7[ebp], xmm0
  00070	0f 28 45 b0	 movaps	 xmm0, XMMWORD PTR $T7[ebp]
  00074	0f 29 45 f0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1389 :     x1 = _mm_madd_epi16(x1, xC_UV_MA_16);

  00078	8b 43 08	 mov	 eax, DWORD PTR _xC_UV_MA_16$[ebx]
  0007b	0f 28 45 e0	 movaps	 xmm0, XMMWORD PTR _x1$[ebp]
  0007f	66 0f f5 00	 pmaddwd xmm0, XMMWORD PTR [eax]
  00083	0f 29 45 a0	 movaps	 XMMWORD PTR $T6[ebp], xmm0
  00087	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR $T6[ebp]
  0008b	0f 29 45 e0	 movaps	 XMMWORD PTR _x1$[ebp], xmm0

; 1390 :     x0 = _mm_srai_epi32(x0, UV_RSH_16);

  0008f	8b 4b 0c	 mov	 ecx, DWORD PTR _UV_RSH_16$[ebx]
  00092	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  00096	66 0f 6e c9	 movd	 xmm1, ecx
  0009a	66 0f e2 c1	 psrad	 xmm0, xmm1
  0009e	0f 29 45 90	 movaps	 XMMWORD PTR $T5[ebp], xmm0
  000a2	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR $T5[ebp]
  000a6	0f 29 45 f0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1391 :     x1 = _mm_srai_epi32(x1, UV_RSH_16);

  000aa	8b 53 0c	 mov	 edx, DWORD PTR _UV_RSH_16$[ebx]
  000ad	0f 28 45 e0	 movaps	 xmm0, XMMWORD PTR _x1$[ebp]
  000b1	66 0f 6e ca	 movd	 xmm1, edx
  000b5	66 0f e2 c1	 psrad	 xmm0, xmm1
  000b9	0f 29 45 80	 movaps	 XMMWORD PTR $T4[ebp], xmm0
  000bd	0f 28 45 80	 movaps	 xmm0, XMMWORD PTR $T4[ebp]
  000c1	0f 29 45 e0	 movaps	 XMMWORD PTR _x1$[ebp], xmm0

; 1392 :     x0 = _mm_add_epi32(x0, xC_YCC);

  000c5	8b 43 10	 mov	 eax, DWORD PTR _xC_YCC$[ebx]
  000c8	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  000cc	66 0f fe 00	 paddd	 xmm0, XMMWORD PTR [eax]
  000d0	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR $T3[ebp], xmm0
  000d7	0f 28 85 70 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T3[ebp]
  000de	0f 29 45 f0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1393 :     x1 = _mm_add_epi32(x1, xC_YCC);

  000e2	8b 4b 10	 mov	 ecx, DWORD PTR _xC_YCC$[ebx]
  000e5	0f 28 45 e0	 movaps	 xmm0, XMMWORD PTR _x1$[ebp]
  000e9	66 0f fe 01	 paddd	 xmm0, XMMWORD PTR [ecx]
  000ed	0f 29 85 60 ff
	ff ff		 movaps	 XMMWORD PTR $T2[ebp], xmm0
  000f4	0f 28 85 60 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T2[ebp]
  000fb	0f 29 45 e0	 movaps	 XMMWORD PTR _x1$[ebp], xmm0

; 1394 : 
; 1395 :     x0 = _mm_packus_epi32_simd(x0, x1);

  000ff	0f 28 4d e0	 movaps	 xmm1, XMMWORD PTR _x1$[ebp]
  00103	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  00107	e8 00 00 00 00	 call	 ?_mm_packus_epi32_simd@@YA?AT__m128i@@T1@0@Z ; _mm_packus_epi32_simd
  0010c	0f 29 85 50 ff
	ff ff		 movaps	 XMMWORD PTR $T1[ebp], xmm0
  00113	0f 28 85 50 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T1[ebp]
  0011a	0f 29 45 f0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1396 : 
; 1397 :     return x0;

  0011e	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]

; 1398 : }

  00122	5f		 pop	 edi
  00123	8b e5		 mov	 esp, ebp
  00125	5d		 pop	 ebp
  00126	8b e3		 mov	 esp, ebx
  00128	5b		 pop	 ebx
  00129	c3		 ret	 0
?convert_uv_range_after_adding_offset@@YA?AT__m128i@@T1@ABT1@H11@Z ENDP ; convert_uv_range_after_adding_offset
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -176						; size = 16
$T2 = -160						; size = 16
$T3 = -144						; size = 16
$T4 = -128						; size = 16
$T5 = -112						; size = 16
$T6 = -96						; size = 16
$T7 = -80						; size = 16
$T8 = -64						; size = 16
$T9 = -48						; size = 16
_x7$ = -32						; size = 16
_x0$ = -16						; size = 16
_xC_Y_MA_16$ = 8					; size = 4
_Y_RSH_16$ = 12						; size = 4
_xC_YCC$ = 16						; size = 4
_xC_pw_one$ = 20					; size = 4
?convert_y_range_from_yc48@@YA?AT__m128i@@T1@ABT1@H11@Z PROC ; convert_y_range_from_yc48
; _x0$ = xmm0

; 1366 : static __forceinline __m128i convert_y_range_from_yc48(__m128i x0, const __m128i& xC_Y_MA_16, int Y_RSH_16, const __m128i& xC_YCC, const __m128i& xC_pw_one) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec b0 00 00
	00		 sub	 esp, 176		; 000000b0H
  0001c	57		 push	 edi
  0001d	8d bd 50 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-176]
  00023	b9 2c 00 00 00	 mov	 ecx, 44			; 0000002cH
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	0f 29 45 f0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1367 :     __m128i x7;
; 1368 :     x7 = _mm_unpackhi_epi16(x0, xC_pw_one);

  00033	8b 43 14	 mov	 eax, DWORD PTR _xC_pw_one$[ebx]
  00036	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  0003a	66 0f 69 00	 punpckhwd xmm0, XMMWORD PTR [eax]
  0003e	0f 29 45 d0	 movaps	 XMMWORD PTR $T9[ebp], xmm0
  00042	0f 28 45 d0	 movaps	 xmm0, XMMWORD PTR $T9[ebp]
  00046	0f 29 45 e0	 movaps	 XMMWORD PTR _x7$[ebp], xmm0

; 1369 :     x0 = _mm_unpacklo_epi16(x0, xC_pw_one);

  0004a	8b 4b 14	 mov	 ecx, DWORD PTR _xC_pw_one$[ebx]
  0004d	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  00051	66 0f 61 01	 punpcklwd xmm0, XMMWORD PTR [ecx]
  00055	0f 29 45 c0	 movaps	 XMMWORD PTR $T8[ebp], xmm0
  00059	0f 28 45 c0	 movaps	 xmm0, XMMWORD PTR $T8[ebp]
  0005d	0f 29 45 f0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1370 : 
; 1371 :     x0 = _mm_madd_epi16(x0, xC_Y_MA_16);

  00061	8b 53 08	 mov	 edx, DWORD PTR _xC_Y_MA_16$[ebx]
  00064	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  00068	66 0f f5 02	 pmaddwd xmm0, XMMWORD PTR [edx]
  0006c	0f 29 45 b0	 movaps	 XMMWORD PTR $T7[ebp], xmm0
  00070	0f 28 45 b0	 movaps	 xmm0, XMMWORD PTR $T7[ebp]
  00074	0f 29 45 f0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1372 :     x7 = _mm_madd_epi16(x7, xC_Y_MA_16);

  00078	8b 43 08	 mov	 eax, DWORD PTR _xC_Y_MA_16$[ebx]
  0007b	0f 28 45 e0	 movaps	 xmm0, XMMWORD PTR _x7$[ebp]
  0007f	66 0f f5 00	 pmaddwd xmm0, XMMWORD PTR [eax]
  00083	0f 29 45 a0	 movaps	 XMMWORD PTR $T6[ebp], xmm0
  00087	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR $T6[ebp]
  0008b	0f 29 45 e0	 movaps	 XMMWORD PTR _x7$[ebp], xmm0

; 1373 :     x0 = _mm_srai_epi32(x0, Y_RSH_16);

  0008f	8b 4b 0c	 mov	 ecx, DWORD PTR _Y_RSH_16$[ebx]
  00092	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  00096	66 0f 6e c9	 movd	 xmm1, ecx
  0009a	66 0f e2 c1	 psrad	 xmm0, xmm1
  0009e	0f 29 45 90	 movaps	 XMMWORD PTR $T5[ebp], xmm0
  000a2	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR $T5[ebp]
  000a6	0f 29 45 f0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1374 :     x7 = _mm_srai_epi32(x7, Y_RSH_16);

  000aa	8b 53 0c	 mov	 edx, DWORD PTR _Y_RSH_16$[ebx]
  000ad	0f 28 45 e0	 movaps	 xmm0, XMMWORD PTR _x7$[ebp]
  000b1	66 0f 6e ca	 movd	 xmm1, edx
  000b5	66 0f e2 c1	 psrad	 xmm0, xmm1
  000b9	0f 29 45 80	 movaps	 XMMWORD PTR $T4[ebp], xmm0
  000bd	0f 28 45 80	 movaps	 xmm0, XMMWORD PTR $T4[ebp]
  000c1	0f 29 45 e0	 movaps	 XMMWORD PTR _x7$[ebp], xmm0

; 1375 :     x0 = _mm_add_epi32(x0, xC_YCC);

  000c5	8b 43 10	 mov	 eax, DWORD PTR _xC_YCC$[ebx]
  000c8	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  000cc	66 0f fe 00	 paddd	 xmm0, XMMWORD PTR [eax]
  000d0	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR $T3[ebp], xmm0
  000d7	0f 28 85 70 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T3[ebp]
  000de	0f 29 45 f0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1376 :     x7 = _mm_add_epi32(x7, xC_YCC);

  000e2	8b 4b 10	 mov	 ecx, DWORD PTR _xC_YCC$[ebx]
  000e5	0f 28 45 e0	 movaps	 xmm0, XMMWORD PTR _x7$[ebp]
  000e9	66 0f fe 01	 paddd	 xmm0, XMMWORD PTR [ecx]
  000ed	0f 29 85 60 ff
	ff ff		 movaps	 XMMWORD PTR $T2[ebp], xmm0
  000f4	0f 28 85 60 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T2[ebp]
  000fb	0f 29 45 e0	 movaps	 XMMWORD PTR _x7$[ebp], xmm0

; 1377 : 
; 1378 :     x0 = _mm_packus_epi32_simd(x0, x7);

  000ff	0f 28 4d e0	 movaps	 xmm1, XMMWORD PTR _x7$[ebp]
  00103	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  00107	e8 00 00 00 00	 call	 ?_mm_packus_epi32_simd@@YA?AT__m128i@@T1@0@Z ; _mm_packus_epi32_simd
  0010c	0f 29 85 50 ff
	ff ff		 movaps	 XMMWORD PTR $T1[ebp], xmm0
  00113	0f 28 85 50 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T1[ebp]
  0011a	0f 29 45 f0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1379 : 
; 1380 :     return x0;

  0011e	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]

; 1381 : }

  00122	5f		 pop	 edi
  00123	8b e5		 mov	 esp, ebp
  00125	5d		 pop	 ebp
  00126	8b e3		 mov	 esp, ebx
  00128	5b		 pop	 ebx
  00129	c3		 ret	 0
?convert_y_range_from_yc48@@YA?AT__m128i@@T1@ABT1@H11@Z ENDP ; convert_y_range_from_yc48
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -304						; size = 16
$T2 = -288						; size = 16
$T3 = -272						; size = 16
$T4 = -256						; size = 16
$T5 = -240						; size = 16
$T6 = -224						; size = 16
$T7 = -208						; size = 16
$T8 = -192						; size = 16
$T9 = -176						; size = 16
$T10 = -160						; size = 16
$T11 = -144						; size = 16
$T12 = -128						; size = 16
$T13 = -112						; size = 16
$T14 = -96						; size = 16
$T15 = -80						; size = 16
$T16 = -64						; size = 16
$T17 = -48						; size = 16
_x3$ = -32						; size = 16
_x2$ = -16						; size = 16
_x0$ = 8						; size = 4
_x1$ = 12						; size = 4
?gather_y_uv_from_yc48@@YAXAAT__m128i@@0T1@@Z PROC	; gather_y_uv_from_yc48
; _x2$ = xmm0

; 1331 : static __forceinline void gather_y_uv_from_yc48(__m128i& x0, __m128i& x1, __m128i x2) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 30 01 00
	00		 sub	 esp, 304		; 00000130H
  0001c	57		 push	 edi
  0001d	8d bd d0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-304]
  00023	b9 4c 00 00 00	 mov	 ecx, 76			; 0000004cH
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	0f 29 45 f0	 movaps	 XMMWORD PTR _x2$[ebp], xmm0

; 1332 : #if USE_SSE41
; 1333 :     __m128i x3;
; 1334 :     const int MASK_INT_Y  = 0x80 + 0x10 + 0x02;
; 1335 :     const int MASK_INT_UV = 0x40 + 0x20 + 0x01;
; 1336 :     x3 = _mm_blend_epi16(x0, x1, MASK_INT_Y);
; 1337 :     x3 = _mm_blend_epi16(x3, x2, MASK_INT_Y>>2);
; 1338 : 
; 1339 :     x1 = _mm_blend_epi16(x0, x1, MASK_INT_UV);
; 1340 :     x1 = _mm_blend_epi16(x1, x2, MASK_INT_UV>>2);
; 1341 :     x1 = _mm_alignr_epi8_simd(x1, x1, 2);
; 1342 :     x1 = _mm_shuffle_epi32(x1, _MM_SHUFFLE(1,2,3,0));//UV1行目
; 1343 : 
; 1344 :     x0 = _mm_shuffle_epi8(x3, xC_SUFFLE_YCP_Y);
; 1345 : #else
; 1346 :     __m128i x3;
; 1347 :     x3 = select_by_mask(x0, x1, xC_MASK_YCP2Y(0));

  00033	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  00038	6b c8 00	 imul	 ecx, eax, 0
  0003b	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?Array_MASK_YCP2Y@@3QAY0BA@$$CBFA
  00041	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00044	0f 29 45 d0	 movaps	 XMMWORD PTR $T17[ebp], xmm0
  00048	0f 28 55 d0	 movaps	 xmm2, XMMWORD PTR $T17[ebp]
  0004c	8b 53 0c	 mov	 edx, DWORD PTR _x1$[ebx]
  0004f	0f 10 0a	 movups	 xmm1, XMMWORD PTR [edx]
  00052	8b 43 08	 mov	 eax, DWORD PTR _x0$[ebx]
  00055	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00058	e8 00 00 00 00	 call	 ?select_by_mask@@YA?AT__m128i@@T1@00@Z ; select_by_mask
  0005d	0f 29 45 c0	 movaps	 XMMWORD PTR $T16[ebp], xmm0
  00061	0f 28 45 c0	 movaps	 xmm0, XMMWORD PTR $T16[ebp]
  00065	0f 29 45 e0	 movaps	 XMMWORD PTR _x3$[ebp], xmm0

; 1348 :     x3 = select_by_mask(x3, x2, xC_MASK_YCP2Y(1));

  00069	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0006e	c1 e1 00	 shl	 ecx, 0
  00071	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?Array_MASK_YCP2Y@@3QAY0BA@$$CBFA
  00077	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  0007a	0f 29 45 b0	 movaps	 XMMWORD PTR $T15[ebp], xmm0
  0007e	0f 28 55 b0	 movaps	 xmm2, XMMWORD PTR $T15[ebp]
  00082	0f 28 4d f0	 movaps	 xmm1, XMMWORD PTR _x2$[ebp]
  00086	0f 28 45 e0	 movaps	 xmm0, XMMWORD PTR _x3$[ebp]
  0008a	e8 00 00 00 00	 call	 ?select_by_mask@@YA?AT__m128i@@T1@00@Z ; select_by_mask
  0008f	0f 29 45 a0	 movaps	 XMMWORD PTR $T14[ebp], xmm0
  00093	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR $T14[ebp]
  00097	0f 29 45 e0	 movaps	 XMMWORD PTR _x3$[ebp], xmm0

; 1349 : 
; 1350 :     x1 = select_by_mask(x0, x1, xC_MASK_YCP2UV(0));

  0009b	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  000a0	6b c2 00	 imul	 eax, edx, 0
  000a3	05 00 00 00 00	 add	 eax, OFFSET ?Array_MASK_YCP2UV@@3QAY0BA@$$CBFA
  000a8	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  000ab	0f 29 45 90	 movaps	 XMMWORD PTR $T13[ebp], xmm0
  000af	0f 28 55 90	 movaps	 xmm2, XMMWORD PTR $T13[ebp]
  000b3	8b 4b 0c	 mov	 ecx, DWORD PTR _x1$[ebx]
  000b6	0f 10 09	 movups	 xmm1, XMMWORD PTR [ecx]
  000b9	8b 53 08	 mov	 edx, DWORD PTR _x0$[ebx]
  000bc	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  000bf	e8 00 00 00 00	 call	 ?select_by_mask@@YA?AT__m128i@@T1@00@Z ; select_by_mask
  000c4	0f 29 45 80	 movaps	 XMMWORD PTR $T12[ebp], xmm0
  000c8	8b 43 0c	 mov	 eax, DWORD PTR _x1$[ebx]
  000cb	0f 10 45 80	 movups	 xmm0, XMMWORD PTR $T12[ebp]
  000cf	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 1351 :     x1 = select_by_mask(x1, x2, xC_MASK_YCP2UV(1));

  000d2	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  000d7	c1 e1 00	 shl	 ecx, 0
  000da	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?Array_MASK_YCP2UV@@3QAY0BA@$$CBFA
  000e0	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  000e3	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR $T11[ebp], xmm0
  000ea	0f 28 95 70 ff
	ff ff		 movaps	 xmm2, XMMWORD PTR $T11[ebp]
  000f1	0f 28 4d f0	 movaps	 xmm1, XMMWORD PTR _x2$[ebp]
  000f5	8b 53 0c	 mov	 edx, DWORD PTR _x1$[ebx]
  000f8	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  000fb	e8 00 00 00 00	 call	 ?select_by_mask@@YA?AT__m128i@@T1@00@Z ; select_by_mask
  00100	0f 29 85 60 ff
	ff ff		 movaps	 XMMWORD PTR $T10[ebp], xmm0
  00107	8b 43 0c	 mov	 eax, DWORD PTR _x1$[ebx]
  0010a	0f 10 85 60 ff
	ff ff		 movups	 xmm0, XMMWORD PTR $T10[ebp]
  00111	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 1352 :     x1 = _mm_alignr_epi8_simd(x1, x1, 2);

  00114	8b 4b 0c	 mov	 ecx, DWORD PTR _x1$[ebx]
  00117	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  0011a	66 0f 73 d8 02	 psrldq	 xmm0, 2
  0011f	0f 29 85 40 ff
	ff ff		 movaps	 XMMWORD PTR $T8[ebp], xmm0
  00126	8b 53 0c	 mov	 edx, DWORD PTR _x1$[ebx]
  00129	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  0012c	66 0f 73 f8 0e	 pslldq	 xmm0, 14		; 0000000eH
  00131	0f 29 85 50 ff
	ff ff		 movaps	 XMMWORD PTR $T9[ebp], xmm0
  00138	0f 28 85 50 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T9[ebp]
  0013f	66 0f eb 85 40
	ff ff ff	 por	 xmm0, XMMWORD PTR $T8[ebp]
  00147	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR $T7[ebp], xmm0
  0014e	8b 43 0c	 mov	 eax, DWORD PTR _x1$[ebx]
  00151	0f 10 85 30 ff
	ff ff		 movups	 xmm0, XMMWORD PTR $T7[ebp]
  00158	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 1353 :     x1 = _mm_shuffle_epi32(x1, _MM_SHUFFLE(1,2,3,0));

  0015b	8b 4b 0c	 mov	 ecx, DWORD PTR _x1$[ebx]
  0015e	66 0f 70 01 6c	 pshufd	 xmm0, XMMWORD PTR [ecx], 108 ; 0000006cH
  00163	0f 29 85 20 ff
	ff ff		 movaps	 XMMWORD PTR $T6[ebp], xmm0
  0016a	8b 53 0c	 mov	 edx, DWORD PTR _x1$[ebx]
  0016d	0f 10 85 20 ff
	ff ff		 movups	 xmm0, XMMWORD PTR $T6[ebp]
  00174	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 1354 : #if USE_SSSE3
; 1355 :     x0 = _mm_shuffle_epi8(x3, xC_SUFFLE_YCP_Y);
; 1356 : #else
; 1357 :     x0 = _mm_shuffle_epi32(  x3, _MM_SHUFFLE(3,1,2,0));

  00177	66 0f 70 45 e0
	d8		 pshufd	 xmm0, XMMWORD PTR _x3$[ebp], 216 ; 000000d8H
  0017d	0f 29 85 10 ff
	ff ff		 movaps	 XMMWORD PTR $T5[ebp], xmm0
  00184	8b 43 08	 mov	 eax, DWORD PTR _x0$[ebx]
  00187	0f 10 85 10 ff
	ff ff		 movups	 xmm0, XMMWORD PTR $T5[ebp]
  0018e	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 1358 :     x0 = _mm_shufflehi_epi16(x0, _MM_SHUFFLE(1,2,3,0));

  00191	8b 4b 08	 mov	 ecx, DWORD PTR _x0$[ebx]
  00194	f3 0f 70 01 6c	 pshufhw xmm0, XMMWORD PTR [ecx], 108 ; 0000006cH
  00199	0f 29 85 00 ff
	ff ff		 movaps	 XMMWORD PTR $T4[ebp], xmm0
  001a0	8b 53 08	 mov	 edx, DWORD PTR _x0$[ebx]
  001a3	0f 10 85 00 ff
	ff ff		 movups	 xmm0, XMMWORD PTR $T4[ebp]
  001aa	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 1359 :     x0 = _mm_shuffle_epi32(  x0, _MM_SHUFFLE(1,2,3,0));

  001ad	8b 43 08	 mov	 eax, DWORD PTR _x0$[ebx]
  001b0	66 0f 70 00 6c	 pshufd	 xmm0, XMMWORD PTR [eax], 108 ; 0000006cH
  001b5	0f 29 85 f0 fe
	ff ff		 movaps	 XMMWORD PTR $T3[ebp], xmm0
  001bc	8b 4b 08	 mov	 ecx, DWORD PTR _x0$[ebx]
  001bf	0f 10 85 f0 fe
	ff ff		 movups	 xmm0, XMMWORD PTR $T3[ebp]
  001c6	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 1360 :     x0 = _mm_shufflelo_epi16(x0, _MM_SHUFFLE(1,2,3,0));

  001c9	8b 53 08	 mov	 edx, DWORD PTR _x0$[ebx]
  001cc	f2 0f 70 02 6c	 pshuflw xmm0, XMMWORD PTR [edx], 108 ; 0000006cH
  001d1	0f 29 85 e0 fe
	ff ff		 movaps	 XMMWORD PTR $T2[ebp], xmm0
  001d8	8b 43 08	 mov	 eax, DWORD PTR _x0$[ebx]
  001db	0f 10 85 e0 fe
	ff ff		 movups	 xmm0, XMMWORD PTR $T2[ebp]
  001e2	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 1361 :     x0 = _mm_shufflehi_epi16(x0, _MM_SHUFFLE(3,0,1,2));

  001e5	8b 4b 08	 mov	 ecx, DWORD PTR _x0$[ebx]
  001e8	f3 0f 70 01 c6	 pshufhw xmm0, XMMWORD PTR [ecx], 198 ; 000000c6H
  001ed	0f 29 85 d0 fe
	ff ff		 movaps	 XMMWORD PTR $T1[ebp], xmm0
  001f4	8b 53 08	 mov	 edx, DWORD PTR _x0$[ebx]
  001f7	0f 10 85 d0 fe
	ff ff		 movups	 xmm0, XMMWORD PTR $T1[ebp]
  001fe	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 1362 : #endif //USE_SSSE3
; 1363 : #endif //USE_SSE41
; 1364 : }

  00201	5f		 pop	 edi
  00202	8b e5		 mov	 esp, ebp
  00204	5d		 pop	 ebp
  00205	8b e3		 mov	 esp, ebx
  00207	5b		 pop	 ebx
  00208	c3		 ret	 0
?gather_y_uv_from_yc48@@YAXAAT__m128i@@0T1@@Z ENDP	; gather_y_uv_from_yc48
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -224						; size = 12
$T2 = -208						; size = 16
$T3 = -192						; size = 16
$T4 = -176						; size = 16
$T5 = -160						; size = 16
$T6 = -144						; size = 16
_x1$7 = -128						; size = 16
_x0$8 = -112						; size = 16
_x$9 = -88						; size = 4
_dst_ptr$10 = -84					; size = 4
_src_ptr$11 = -80					; size = 4
_y$12 = -76						; size = 4
_y_width$13 = -72					; size = 4
_dstLine$14 = -68					; size = 4
_srcYLine$15 = -64					; size = 4
_i$16 = -60						; size = 4
$T17 = -56						; size = 12
_y_range$ = -40						; size = 12
_dst_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuv444_to_yuv444_16_simd@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_to_yuv444_16_simd

; 1224 : static void __forceinline convert_yuv444_to_yuv444_16_simd(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec e0 00 00
	00		 sub	 esp, 224		; 000000e0H
  0001c	57		 push	 edi
  0001d	8d bd 20 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-224]
  00023	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1225 :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 1226 :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 1227 :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 1228 :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 1229 :     const int dst_y_pitch = dst_y_pitch_byte >> 1;

  0007c	8b 53 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebx]
  0007f	d1 fa		 sar	 edx, 1
  00081	89 55 e8	 mov	 DWORD PTR _dst_y_pitch$[ebp], edx

; 1230 :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00084	8b 43 2c	 mov	 eax, DWORD PTR _thread_n$[ebx]
  00087	50		 push	 eax
  00088	8b 4b 28	 mov	 ecx, DWORD PTR _thread_id$[ebx]
  0008b	51		 push	 ecx
  0008c	8b 53 20	 mov	 edx, DWORD PTR _height$[ebx]
  0008f	2b 55 ec	 sub	 edx, DWORD PTR _crop_bottom$[ebp]
  00092	52		 push	 edx
  00093	8b 45 f4	 mov	 eax, DWORD PTR _crop_up$[ebp]
  00096	50		 push	 eax
  00097	8d 8d 20 ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  0009d	51		 push	 ecx
  0009e	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  000a3	83 c4 14	 add	 esp, 20			; 00000014H
  000a6	8b 10		 mov	 edx, DWORD PTR [eax]
  000a8	89 55 c8	 mov	 DWORD PTR $T17[ebp], edx
  000ab	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ae	89 4d cc	 mov	 DWORD PTR $T17[ebp+4], ecx
  000b1	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000b4	89 55 d0	 mov	 DWORD PTR $T17[ebp+8], edx
  000b7	8b 45 c8	 mov	 eax, DWORD PTR $T17[ebp]
  000ba	89 45 d8	 mov	 DWORD PTR _y_range$[ebp], eax
  000bd	8b 4d cc	 mov	 ecx, DWORD PTR $T17[ebp+4]
  000c0	89 4d dc	 mov	 DWORD PTR _y_range$[ebp+4], ecx
  000c3	8b 55 d0	 mov	 edx, DWORD PTR $T17[ebp+8]
  000c6	89 55 e0	 mov	 DWORD PTR _y_range$[ebp+8], edx

; 1231 :     for (int i = 0; i < 3; i++) {

  000c9	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _i$16[ebp], 0
  000d0	eb 09		 jmp	 SHORT $LN4@convert_yu
$LN2@convert_yu:
  000d2	8b 45 c4	 mov	 eax, DWORD PTR _i$16[ebp]
  000d5	83 c0 01	 add	 eax, 1
  000d8	89 45 c4	 mov	 DWORD PTR _i$16[ebp], eax
$LN4@convert_yu:
  000db	83 7d c4 03	 cmp	 DWORD PTR _i$16[ebp], 3
  000df	0f 8d 37 01 00
	00		 jge	 $LN1@convert_yu

; 1232 :         uint8_t *srcYLine = (uint8_t *)src[i] + src_y_pitch_byte * y_range.start_src + crop_left;

  000e5	8b 4b 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebx]
  000e8	0f af 4d d8	 imul	 ecx, DWORD PTR _y_range$[ebp]
  000ec	8b 55 c4	 mov	 edx, DWORD PTR _i$16[ebp]
  000ef	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  000f2	8b 14 90	 mov	 edx, DWORD PTR [eax+edx*4]
  000f5	03 d1		 add	 edx, ecx
  000f7	03 55 f8	 add	 edx, DWORD PTR _crop_left$[ebp]
  000fa	89 55 c0	 mov	 DWORD PTR _srcYLine$15[ebp], edx

; 1233 :         uint16_t *dstLine = (uint16_t *)dst[i] + dst_y_pitch * y_range.start_dst;

  000fd	8b 45 e8	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  00100	0f af 45 dc	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  00104	8b 4d c4	 mov	 ecx, DWORD PTR _i$16[ebp]
  00107	8b 53 08	 mov	 edx, DWORD PTR _dst$[ebx]
  0010a	8b 0c 8a	 mov	 ecx, DWORD PTR [edx+ecx*4]
  0010d	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00110	89 55 bc	 mov	 DWORD PTR _dstLine$14[ebp], edx

; 1234 :         const int y_width = width - crop_right - crop_left;

  00113	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  00116	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  00119	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  0011c	89 45 b8	 mov	 DWORD PTR _y_width$13[ebp], eax

; 1235 :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch_byte, dstLine += dst_y_pitch) {

  0011f	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _y$12[ebp], 0
  00126	eb 1e		 jmp	 SHORT $LN7@convert_yu
$LN5@convert_yu:
  00128	8b 4d b4	 mov	 ecx, DWORD PTR _y$12[ebp]
  0012b	83 c1 01	 add	 ecx, 1
  0012e	89 4d b4	 mov	 DWORD PTR _y$12[ebp], ecx
  00131	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$15[ebp]
  00134	03 53 14	 add	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  00137	89 55 c0	 mov	 DWORD PTR _srcYLine$15[ebp], edx
  0013a	8b 45 e8	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  0013d	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$14[ebp]
  00140	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00143	89 55 bc	 mov	 DWORD PTR _dstLine$14[ebp], edx
$LN7@convert_yu:
  00146	8b 45 b4	 mov	 eax, DWORD PTR _y$12[ebp]
  00149	3b 45 e0	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  0014c	0f 8d c5 00 00
	00		 jge	 $LN6@convert_yu

; 1236 :             uint8_t *src_ptr = srcYLine;

  00152	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$15[ebp]
  00155	89 4d b0	 mov	 DWORD PTR _src_ptr$11[ebp], ecx

; 1237 :             uint16_t *dst_ptr = dstLine;

  00158	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$14[ebp]
  0015b	89 55 ac	 mov	 DWORD PTR _dst_ptr$10[ebp], edx

; 1238 :             for (int x = 0; x < y_width; x += 16, dst_ptr += 16, src_ptr += 16) {

  0015e	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR _x$9[ebp], 0
  00165	eb 1b		 jmp	 SHORT $LN10@convert_yu
$LN8@convert_yu:
  00167	8b 45 a8	 mov	 eax, DWORD PTR _x$9[ebp]
  0016a	83 c0 10	 add	 eax, 16			; 00000010H
  0016d	89 45 a8	 mov	 DWORD PTR _x$9[ebp], eax
  00170	8b 4d ac	 mov	 ecx, DWORD PTR _dst_ptr$10[ebp]
  00173	83 c1 20	 add	 ecx, 32			; 00000020H
  00176	89 4d ac	 mov	 DWORD PTR _dst_ptr$10[ebp], ecx
  00179	8b 55 b0	 mov	 edx, DWORD PTR _src_ptr$11[ebp]
  0017c	83 c2 10	 add	 edx, 16			; 00000010H
  0017f	89 55 b0	 mov	 DWORD PTR _src_ptr$11[ebp], edx
$LN10@convert_yu:
  00182	8b 45 a8	 mov	 eax, DWORD PTR _x$9[ebp]
  00185	3b 45 b8	 cmp	 eax, DWORD PTR _y_width$13[ebp]
  00188	0f 8d 84 00 00
	00		 jge	 $LN9@convert_yu

; 1239 :                 __m128i x0, x1;
; 1240 :                 x0 = _mm_loadu_si128((const __m128i *)src_ptr);

  0018e	8b 4d b0	 mov	 ecx, DWORD PTR _src_ptr$11[ebp]
  00191	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00194	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR $T6[ebp], xmm0
  0019b	0f 28 85 70 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T6[ebp]
  001a2	0f 29 45 90	 movaps	 XMMWORD PTR _x0$8[ebp], xmm0

; 1241 :                 x1 = _mm_unpackhi_epi8(_mm_setzero_si128(), x0);

  001a6	0f 57 c0	 xorps	 xmm0, xmm0
  001a9	0f 29 85 60 ff
	ff ff		 movaps	 XMMWORD PTR $T5[ebp], xmm0
  001b0	0f 28 85 60 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T5[ebp]
  001b7	66 0f 68 45 90	 punpckhbw xmm0, XMMWORD PTR _x0$8[ebp]
  001bc	0f 29 85 50 ff
	ff ff		 movaps	 XMMWORD PTR $T4[ebp], xmm0
  001c3	0f 28 85 50 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T4[ebp]
  001ca	0f 29 45 80	 movaps	 XMMWORD PTR _x1$7[ebp], xmm0

; 1242 :                 x0 = _mm_unpacklo_epi8(_mm_setzero_si128(), x0);

  001ce	0f 57 c0	 xorps	 xmm0, xmm0
  001d1	0f 29 85 40 ff
	ff ff		 movaps	 XMMWORD PTR $T3[ebp], xmm0
  001d8	0f 28 85 40 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T3[ebp]
  001df	66 0f 60 45 90	 punpcklbw xmm0, XMMWORD PTR _x0$8[ebp]
  001e4	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR $T2[ebp], xmm0
  001eb	0f 28 85 30 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T2[ebp]
  001f2	0f 29 45 90	 movaps	 XMMWORD PTR _x0$8[ebp], xmm0

; 1243 :                 _mm_storeu_si128((__m128i *)(dst_ptr + 0), x0);

  001f6	0f 10 45 90	 movups	 xmm0, XMMWORD PTR _x0$8[ebp]
  001fa	8b 55 ac	 mov	 edx, DWORD PTR _dst_ptr$10[ebp]
  001fd	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 1244 :                 _mm_storeu_si128((__m128i *)(dst_ptr + 8), x1);

  00200	0f 10 45 80	 movups	 xmm0, XMMWORD PTR _x1$7[ebp]
  00204	8b 45 ac	 mov	 eax, DWORD PTR _dst_ptr$10[ebp]
  00207	83 c0 10	 add	 eax, 16			; 00000010H
  0020a	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 1245 :             }

  0020d	e9 55 ff ff ff	 jmp	 $LN8@convert_yu
$LN9@convert_yu:

; 1246 :         }

  00212	e9 11 ff ff ff	 jmp	 $LN5@convert_yu
$LN6@convert_yu:

; 1247 :     }

  00217	e9 b6 fe ff ff	 jmp	 $LN2@convert_yu
$LN1@convert_yu:

; 1248 : }

  0021c	52		 push	 edx
  0021d	8b cd		 mov	 ecx, ebp
  0021f	50		 push	 eax
  00220	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN14@convert_yu
  00226	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0022b	58		 pop	 eax
  0022c	5a		 pop	 edx
  0022d	5f		 pop	 edi
  0022e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00231	33 cd		 xor	 ecx, ebp
  00233	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00238	8b e5		 mov	 esp, ebp
  0023a	5d		 pop	 ebp
  0023b	8b e3		 mov	 esp, ebx
  0023d	5b		 pop	 ebx
  0023e	c3		 ret	 0
  0023f	90		 npad	 1
$LN14@convert_yu:
  00240	01 00 00 00	 DD	 1
  00244	00 00 00 00	 DD	 $LN13@convert_yu
$LN13@convert_yu:
  00248	d8 ff ff ff	 DD	 -40			; ffffffd8H
  0024c	0c 00 00 00	 DD	 12			; 0000000cH
  00250	00 00 00 00	 DD	 $LN12@convert_yu
$LN12@convert_yu:
  00254	79		 DB	 121			; 00000079H
  00255	5f		 DB	 95			; 0000005fH
  00256	72		 DB	 114			; 00000072H
  00257	61		 DB	 97			; 00000061H
  00258	6e		 DB	 110			; 0000006eH
  00259	67		 DB	 103			; 00000067H
  0025a	65		 DB	 101			; 00000065H
  0025b	00		 DB	 0
?convert_yuv444_to_yuv444_16_simd@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_to_yuv444_16_simd
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -84						; size = 12
_y$2 = -72						; size = 4
_y_width$3 = -68					; size = 4
_dstLine$4 = -64					; size = 4
_srcYLine$5 = -60					; size = 4
_i$6 = -56						; size = 4
$T7 = -52						; size = 12
_y_range$ = -36						; size = 12
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?copy_yuv444_to_yuv444@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC	; copy_yuv444_to_yuv444

; 1208 : static void __forceinline copy_yuv444_to_yuv444(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	57		 push	 edi
  00007	8d 7d ac	 lea	 edi, DWORD PTR [ebp-84]
  0000a	b9 15 00 00 00	 mov	 ecx, 21			; 00000015H
  0000f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00014	f3 ab		 rep stosd
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1209 :     const int crop_left   = crop[0];

  00020	b8 04 00 00 00	 mov	 eax, 4
  00025	6b c8 00	 imul	 ecx, eax, 0
  00028	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  0002b	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0002e	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 1210 :     const int crop_up     = crop[1];

  00031	b9 04 00 00 00	 mov	 ecx, 4
  00036	c1 e1 00	 shl	 ecx, 0
  00039	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  0003c	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0003f	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 1211 :     const int crop_right  = crop[2];

  00042	b9 04 00 00 00	 mov	 ecx, 4
  00047	d1 e1		 shl	 ecx, 1
  00049	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  0004c	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0004f	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 1212 :     const int crop_bottom = crop[3];

  00052	b9 04 00 00 00	 mov	 ecx, 4
  00057	6b d1 03	 imul	 edx, ecx, 3
  0005a	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  0005d	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00060	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 1213 :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00063	8b 55 2c	 mov	 edx, DWORD PTR _thread_n$[ebp]
  00066	52		 push	 edx
  00067	8b 45 28	 mov	 eax, DWORD PTR _thread_id$[ebp]
  0006a	50		 push	 eax
  0006b	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  0006e	2b 4d ec	 sub	 ecx, DWORD PTR _crop_bottom$[ebp]
  00071	51		 push	 ecx
  00072	8b 55 f4	 mov	 edx, DWORD PTR _crop_up$[ebp]
  00075	52		 push	 edx
  00076	8d 45 ac	 lea	 eax, DWORD PTR $T1[ebp]
  00079	50		 push	 eax
  0007a	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  0007f	83 c4 14	 add	 esp, 20			; 00000014H
  00082	8b 08		 mov	 ecx, DWORD PTR [eax]
  00084	89 4d cc	 mov	 DWORD PTR $T7[ebp], ecx
  00087	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0008a	89 55 d0	 mov	 DWORD PTR $T7[ebp+4], edx
  0008d	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00090	89 45 d4	 mov	 DWORD PTR $T7[ebp+8], eax
  00093	8b 4d cc	 mov	 ecx, DWORD PTR $T7[ebp]
  00096	89 4d dc	 mov	 DWORD PTR _y_range$[ebp], ecx
  00099	8b 55 d0	 mov	 edx, DWORD PTR $T7[ebp+4]
  0009c	89 55 e0	 mov	 DWORD PTR _y_range$[ebp+4], edx
  0009f	8b 45 d4	 mov	 eax, DWORD PTR $T7[ebp+8]
  000a2	89 45 e4	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 1214 :     for (int i = 0; i < 3; i++) {

  000a5	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _i$6[ebp], 0
  000ac	eb 09		 jmp	 SHORT $LN4@copy_yuv44
$LN2@copy_yuv44:
  000ae	8b 4d c8	 mov	 ecx, DWORD PTR _i$6[ebp]
  000b1	83 c1 01	 add	 ecx, 1
  000b4	89 4d c8	 mov	 DWORD PTR _i$6[ebp], ecx
$LN4@copy_yuv44:
  000b7	83 7d c8 03	 cmp	 DWORD PTR _i$6[ebp], 3
  000bb	7d 7e		 jge	 SHORT $LN1@copy_yuv44

; 1215 :         uint8_t *srcYLine = (uint8_t *)src[i] + src_y_pitch_byte * y_range.start_src + crop_left;

  000bd	8b 55 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebp]
  000c0	0f af 55 dc	 imul	 edx, DWORD PTR _y_range$[ebp]
  000c4	8b 45 c8	 mov	 eax, DWORD PTR _i$6[ebp]
  000c7	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  000ca	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  000cd	03 c2		 add	 eax, edx
  000cf	03 45 f8	 add	 eax, DWORD PTR _crop_left$[ebp]
  000d2	89 45 c4	 mov	 DWORD PTR _srcYLine$5[ebp], eax

; 1216 :         uint8_t *dstLine = (uint8_t *)dst[i] + dst_y_pitch_byte * y_range.start_dst;

  000d5	8b 4d 1c	 mov	 ecx, DWORD PTR _dst_y_pitch_byte$[ebp]
  000d8	0f af 4d e0	 imul	 ecx, DWORD PTR _y_range$[ebp+4]
  000dc	8b 55 c8	 mov	 edx, DWORD PTR _i$6[ebp]
  000df	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
  000e2	03 0c 90	 add	 ecx, DWORD PTR [eax+edx*4]
  000e5	89 4d c0	 mov	 DWORD PTR _dstLine$4[ebp], ecx

; 1217 :         const int y_width = width - crop_right - crop_left;

  000e8	8b 4d 10	 mov	 ecx, DWORD PTR _width$[ebp]
  000eb	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  000ee	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  000f1	89 4d bc	 mov	 DWORD PTR _y_width$3[ebp], ecx

; 1218 :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch_byte, dstLine += dst_y_pitch_byte) {

  000f4	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _y$2[ebp], 0
  000fb	eb 1b		 jmp	 SHORT $LN7@copy_yuv44
$LN5@copy_yuv44:
  000fd	8b 55 b8	 mov	 edx, DWORD PTR _y$2[ebp]
  00100	83 c2 01	 add	 edx, 1
  00103	89 55 b8	 mov	 DWORD PTR _y$2[ebp], edx
  00106	8b 45 c4	 mov	 eax, DWORD PTR _srcYLine$5[ebp]
  00109	03 45 14	 add	 eax, DWORD PTR _src_y_pitch_byte$[ebp]
  0010c	89 45 c4	 mov	 DWORD PTR _srcYLine$5[ebp], eax
  0010f	8b 4d c0	 mov	 ecx, DWORD PTR _dstLine$4[ebp]
  00112	03 4d 1c	 add	 ecx, DWORD PTR _dst_y_pitch_byte$[ebp]
  00115	89 4d c0	 mov	 DWORD PTR _dstLine$4[ebp], ecx
$LN7@copy_yuv44:
  00118	8b 55 b8	 mov	 edx, DWORD PTR _y$2[ebp]
  0011b	3b 55 e4	 cmp	 edx, DWORD PTR _y_range$[ebp+8]
  0011e	7d 16		 jge	 SHORT $LN6@copy_yuv44

; 1219 :             memcpy_sse(dstLine, srcYLine, y_width);

  00120	8b 45 bc	 mov	 eax, DWORD PTR _y_width$3[ebp]
  00123	50		 push	 eax
  00124	8b 4d c4	 mov	 ecx, DWORD PTR _srcYLine$5[ebp]
  00127	51		 push	 ecx
  00128	8b 55 c0	 mov	 edx, DWORD PTR _dstLine$4[ebp]
  0012b	52		 push	 edx
  0012c	e8 00 00 00 00	 call	 ?memcpy_sse@@YAXPAEPBEH@Z ; memcpy_sse
  00131	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1220 :         }

  00134	eb c7		 jmp	 SHORT $LN5@copy_yuv44
$LN6@copy_yuv44:

; 1221 :     }

  00136	e9 73 ff ff ff	 jmp	 $LN2@copy_yuv44
$LN1@copy_yuv44:

; 1222 : }

  0013b	52		 push	 edx
  0013c	8b cd		 mov	 ecx, ebp
  0013e	50		 push	 eax
  0013f	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN11@copy_yuv44
  00145	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0014a	58		 pop	 eax
  0014b	5a		 pop	 edx
  0014c	5f		 pop	 edi
  0014d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00150	33 cd		 xor	 ecx, ebp
  00152	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00157	83 c4 54	 add	 esp, 84			; 00000054H
  0015a	3b ec		 cmp	 ebp, esp
  0015c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00161	8b e5		 mov	 esp, ebp
  00163	5d		 pop	 ebp
  00164	c3		 ret	 0
  00165	0f 1f 00	 npad	 3
$LN11@copy_yuv44:
  00168	01 00 00 00	 DD	 1
  0016c	00 00 00 00	 DD	 $LN10@copy_yuv44
$LN10@copy_yuv44:
  00170	dc ff ff ff	 DD	 -36			; ffffffdcH
  00174	0c 00 00 00	 DD	 12			; 0000000cH
  00178	00 00 00 00	 DD	 $LN9@copy_yuv44
$LN9@copy_yuv44:
  0017c	79		 DB	 121			; 00000079H
  0017d	5f		 DB	 95			; 0000005fH
  0017e	72		 DB	 114			; 00000072H
  0017f	61		 DB	 97			; 00000061H
  00180	6e		 DB	 110			; 0000006eH
  00181	67		 DB	 103			; 00000067H
  00182	65		 DB	 101			; 00000065H
  00183	00		 DB	 0
?copy_yuv444_to_yuv444@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP	; copy_yuv444_to_yuv444
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -576						; size = 12
$T2 = -560						; size = 16
$T3 = -544						; size = 16
$T4 = -528						; size = 16
$T5 = -512						; size = 16
$T6 = -496						; size = 16
$T7 = -480						; size = 16
$T8 = -464						; size = 16
$T9 = -448						; size = 16
$T10 = -432						; size = 16
$T11 = -416						; size = 16
$T12 = -400						; size = 16
$T13 = -384						; size = 16
$T14 = -368						; size = 16
$T15 = -352						; size = 16
_x$16 = -324						; size = 4
_x4$17 = -320						; size = 16
_x3$18 = -304						; size = 16
_x2$19 = -288						; size = 16
_x1$20 = -272						; size = 16
_x0$21 = -256						; size = 16
_dst_ptr$22 = -240					; size = 4
_src_v_ptr$23 = -236					; size = 4
_src_u_ptr$24 = -232					; size = 4
_x_fin$25 = -228					; size = 4
_y$26 = -224						; size = 4
_srcVLine$ = -220					; size = 4
_srcULine$ = -216					; size = 4
_src_uv_pitch$ = -212					; size = 4
$T27 = -208						; size = 16
$T28 = -192						; size = 16
$T29 = -176						; size = 16
$T30 = -160						; size = 16
$T31 = -144						; size = 16
_x1$32 = -128						; size = 16
_x0$33 = -112						; size = 16
_x$34 = -88						; size = 4
_dst_ptr$35 = -84					; size = 4
_src_ptr$36 = -80					; size = 4
_y$37 = -76						; size = 4
_y_width$ = -72						; size = 4
_dstLine$ = -68						; size = 4
_srcYLine$ = -64					; size = 4
$T38 = -60						; size = 12
_y_range$ = -44						; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuv422_to_p210_simd@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv422_to_p210_simd

; 1094 : static void __forceinline convert_yuv422_to_p210_simd(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 40 02 00
	00		 sub	 esp, 576		; 00000240H
  0001c	57		 push	 edi
  0001d	8d bd c0 fd ff
	ff		 lea	 edi, DWORD PTR [ebp-576]
  00023	b9 90 00 00 00	 mov	 ecx, 144		; 00000090H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1095 :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 1096 :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 1097 :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 1098 :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 1099 :     const int src_y_pitch = src_y_pitch_byte;

  0007c	8b 53 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  0007f	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 1100 :     const int dst_y_pitch = dst_y_pitch_byte >> 1;

  00082	8b 43 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  00085	d1 f8		 sar	 eax, 1
  00087	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 1101 :     //Y成分のコピー
; 1102 :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  0008a	8b 4b 2c	 mov	 ecx, DWORD PTR _thread_n$[ebx]
  0008d	51		 push	 ecx
  0008e	8b 53 28	 mov	 edx, DWORD PTR _thread_id$[ebx]
  00091	52		 push	 edx
  00092	8b 43 20	 mov	 eax, DWORD PTR _height$[ebx]
  00095	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  00098	50		 push	 eax
  00099	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  0009c	51		 push	 ecx
  0009d	8d 95 c0 fd ff
	ff		 lea	 edx, DWORD PTR $T1[ebp]
  000a3	52		 push	 edx
  000a4	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  000a9	83 c4 14	 add	 esp, 20			; 00000014H
  000ac	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ae	89 4d c4	 mov	 DWORD PTR $T38[ebp], ecx
  000b1	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000b4	89 55 c8	 mov	 DWORD PTR $T38[ebp+4], edx
  000b7	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000ba	89 45 cc	 mov	 DWORD PTR $T38[ebp+8], eax
  000bd	8b 4d c4	 mov	 ecx, DWORD PTR $T38[ebp]
  000c0	89 4d d4	 mov	 DWORD PTR _y_range$[ebp], ecx
  000c3	8b 55 c8	 mov	 edx, DWORD PTR $T38[ebp+4]
  000c6	89 55 d8	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000c9	8b 45 cc	 mov	 eax, DWORD PTR $T38[ebp+8]
  000cc	89 45 dc	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 1103 :     uint8_t *srcYLine = (uint8_t *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000cf	b9 04 00 00 00	 mov	 ecx, 4
  000d4	6b d1 00	 imul	 edx, ecx, 0
  000d7	8b 45 e8	 mov	 eax, DWORD PTR _src_y_pitch$[ebp]
  000da	0f af 45 d4	 imul	 eax, DWORD PTR _y_range$[ebp]
  000de	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  000e1	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  000e4	03 d0		 add	 edx, eax
  000e6	03 55 f8	 add	 edx, DWORD PTR _crop_left$[ebp]
  000e9	89 55 c0	 mov	 DWORD PTR _srcYLine$[ebp], edx

; 1104 :     uint16_t *dstLine = (uint16_t *)dst[0] + dst_y_pitch * y_range.start_dst;

  000ec	b8 04 00 00 00	 mov	 eax, 4
  000f1	6b c8 00	 imul	 ecx, eax, 0
  000f4	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  000f7	0f af 55 d8	 imul	 edx, DWORD PTR _y_range$[ebp+4]
  000fb	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  000fe	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  00101	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  00104	89 55 bc	 mov	 DWORD PTR _dstLine$[ebp], edx

; 1105 :     const int y_width = width - crop_right - crop_left;

  00107	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  0010a	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  0010d	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  00110	89 45 b8	 mov	 DWORD PTR _y_width$[ebp], eax

; 1106 :     for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  00113	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _y$37[ebp], 0
  0011a	eb 1e		 jmp	 SHORT $LN4@convert_yu
$LN2@convert_yu:
  0011c	8b 4d b4	 mov	 ecx, DWORD PTR _y$37[ebp]
  0011f	83 c1 01	 add	 ecx, 1
  00122	89 4d b4	 mov	 DWORD PTR _y$37[ebp], ecx
  00125	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$[ebp]
  00128	03 55 e8	 add	 edx, DWORD PTR _src_y_pitch$[ebp]
  0012b	89 55 c0	 mov	 DWORD PTR _srcYLine$[ebp], edx
  0012e	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  00131	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$[ebp]
  00134	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00137	89 55 bc	 mov	 DWORD PTR _dstLine$[ebp], edx
$LN4@convert_yu:
  0013a	8b 45 b4	 mov	 eax, DWORD PTR _y$37[ebp]
  0013d	3b 45 dc	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  00140	0f 8d c5 00 00
	00		 jge	 $LN3@convert_yu

; 1107 :         uint8_t *src_ptr = srcYLine;

  00146	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$[ebp]
  00149	89 4d b0	 mov	 DWORD PTR _src_ptr$36[ebp], ecx

; 1108 :         uint16_t *dst_ptr = dstLine;

  0014c	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$[ebp]
  0014f	89 55 ac	 mov	 DWORD PTR _dst_ptr$35[ebp], edx

; 1109 :         for (int x = 0; x < y_width; x += 16, dst_ptr += 16, src_ptr += 16) {

  00152	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR _x$34[ebp], 0
  00159	eb 1b		 jmp	 SHORT $LN7@convert_yu
$LN5@convert_yu:
  0015b	8b 45 a8	 mov	 eax, DWORD PTR _x$34[ebp]
  0015e	83 c0 10	 add	 eax, 16			; 00000010H
  00161	89 45 a8	 mov	 DWORD PTR _x$34[ebp], eax
  00164	8b 4d ac	 mov	 ecx, DWORD PTR _dst_ptr$35[ebp]
  00167	83 c1 20	 add	 ecx, 32			; 00000020H
  0016a	89 4d ac	 mov	 DWORD PTR _dst_ptr$35[ebp], ecx
  0016d	8b 55 b0	 mov	 edx, DWORD PTR _src_ptr$36[ebp]
  00170	83 c2 10	 add	 edx, 16			; 00000010H
  00173	89 55 b0	 mov	 DWORD PTR _src_ptr$36[ebp], edx
$LN7@convert_yu:
  00176	8b 45 a8	 mov	 eax, DWORD PTR _x$34[ebp]
  00179	3b 45 b8	 cmp	 eax, DWORD PTR _y_width$[ebp]
  0017c	0f 8d 84 00 00
	00		 jge	 $LN6@convert_yu

; 1110 :             __m128i x0, x1;
; 1111 :             x0 = _mm_loadu_si128((const __m128i *)src_ptr);

  00182	8b 4d b0	 mov	 ecx, DWORD PTR _src_ptr$36[ebp]
  00185	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00188	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR $T31[ebp], xmm0
  0018f	0f 28 85 70 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T31[ebp]
  00196	0f 29 45 90	 movaps	 XMMWORD PTR _x0$33[ebp], xmm0

; 1112 :             x1 = _mm_unpackhi_epi8(_mm_setzero_si128(), x0);

  0019a	0f 57 c0	 xorps	 xmm0, xmm0
  0019d	0f 29 85 60 ff
	ff ff		 movaps	 XMMWORD PTR $T30[ebp], xmm0
  001a4	0f 28 85 60 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T30[ebp]
  001ab	66 0f 68 45 90	 punpckhbw xmm0, XMMWORD PTR _x0$33[ebp]
  001b0	0f 29 85 50 ff
	ff ff		 movaps	 XMMWORD PTR $T29[ebp], xmm0
  001b7	0f 28 85 50 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T29[ebp]
  001be	0f 29 45 80	 movaps	 XMMWORD PTR _x1$32[ebp], xmm0

; 1113 :             x0 = _mm_unpacklo_epi8(_mm_setzero_si128(), x0);

  001c2	0f 57 c0	 xorps	 xmm0, xmm0
  001c5	0f 29 85 40 ff
	ff ff		 movaps	 XMMWORD PTR $T28[ebp], xmm0
  001cc	0f 28 85 40 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T28[ebp]
  001d3	66 0f 60 45 90	 punpcklbw xmm0, XMMWORD PTR _x0$33[ebp]
  001d8	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR $T27[ebp], xmm0
  001df	0f 28 85 30 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T27[ebp]
  001e6	0f 29 45 90	 movaps	 XMMWORD PTR _x0$33[ebp], xmm0

; 1114 :             _mm_storeu_si128((__m128i *)(dst_ptr + 0), x0);

  001ea	0f 10 45 90	 movups	 xmm0, XMMWORD PTR _x0$33[ebp]
  001ee	8b 55 ac	 mov	 edx, DWORD PTR _dst_ptr$35[ebp]
  001f1	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 1115 :             _mm_storeu_si128((__m128i *)(dst_ptr + 8), x1);

  001f4	0f 10 45 80	 movups	 xmm0, XMMWORD PTR _x1$32[ebp]
  001f8	8b 45 ac	 mov	 eax, DWORD PTR _dst_ptr$35[ebp]
  001fb	83 c0 10	 add	 eax, 16			; 00000010H
  001fe	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 1116 :         }

  00201	e9 55 ff ff ff	 jmp	 $LN5@convert_yu
$LN6@convert_yu:

; 1117 :     }

  00206	e9 11 ff ff ff	 jmp	 $LN2@convert_yu
$LN3@convert_yu:

; 1118 :     //UV成分のコピー
; 1119 :     const int src_uv_pitch = src_uv_pitch_byte;

  0020b	8b 4b 18	 mov	 ecx, DWORD PTR _src_uv_pitch_byte$[ebx]
  0020e	89 8d 2c ff ff
	ff		 mov	 DWORD PTR _src_uv_pitch$[ebp], ecx

; 1120 :     uint8_t *srcULine = (uint8_t *)src[1] + ((src_uv_pitch * y_range.start_src) + (crop_left >> 1));

  00214	ba 04 00 00 00	 mov	 edx, 4
  00219	c1 e2 00	 shl	 edx, 0
  0021c	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  00222	0f af 45 d4	 imul	 eax, DWORD PTR _y_range$[ebp]
  00226	8b 4d f8	 mov	 ecx, DWORD PTR _crop_left$[ebp]
  00229	d1 f9		 sar	 ecx, 1
  0022b	03 c1		 add	 eax, ecx
  0022d	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  00230	03 04 11	 add	 eax, DWORD PTR [ecx+edx]
  00233	89 85 28 ff ff
	ff		 mov	 DWORD PTR _srcULine$[ebp], eax

; 1121 :     uint8_t *srcVLine = (uint8_t *)src[2] + ((src_uv_pitch * y_range.start_src) + (crop_left >> 1));

  00239	ba 04 00 00 00	 mov	 edx, 4
  0023e	d1 e2		 shl	 edx, 1
  00240	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  00246	0f af 45 d4	 imul	 eax, DWORD PTR _y_range$[ebp]
  0024a	8b 4d f8	 mov	 ecx, DWORD PTR _crop_left$[ebp]
  0024d	d1 f9		 sar	 ecx, 1
  0024f	03 c1		 add	 eax, ecx
  00251	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  00254	03 04 11	 add	 eax, DWORD PTR [ecx+edx]
  00257	89 85 24 ff ff
	ff		 mov	 DWORD PTR _srcVLine$[ebp], eax

; 1122 :     dstLine = (uint16_t *)dst[1] + dst_y_pitch * y_range.start_dst;

  0025d	ba 04 00 00 00	 mov	 edx, 4
  00262	c1 e2 00	 shl	 edx, 0
  00265	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  00268	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  0026c	8b 4b 08	 mov	 ecx, DWORD PTR _dst$[ebx]
  0026f	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  00272	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  00275	89 45 bc	 mov	 DWORD PTR _dstLine$[ebp], eax

; 1123 :     for (int y = 0; y < y_range.len; y++, srcULine += src_uv_pitch, srcVLine += src_uv_pitch, dstLine += dst_y_pitch) {

  00278	c7 85 20 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _y$26[ebp], 0
  00282	eb 3f		 jmp	 SHORT $LN10@convert_yu
$LN8@convert_yu:
  00284	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR _y$26[ebp]
  0028a	83 c1 01	 add	 ecx, 1
  0028d	89 8d 20 ff ff
	ff		 mov	 DWORD PTR _y$26[ebp], ecx
  00293	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR _srcULine$[ebp]
  00299	03 95 2c ff ff
	ff		 add	 edx, DWORD PTR _src_uv_pitch$[ebp]
  0029f	89 95 28 ff ff
	ff		 mov	 DWORD PTR _srcULine$[ebp], edx
  002a5	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _srcVLine$[ebp]
  002ab	03 85 2c ff ff
	ff		 add	 eax, DWORD PTR _src_uv_pitch$[ebp]
  002b1	89 85 24 ff ff
	ff		 mov	 DWORD PTR _srcVLine$[ebp], eax
  002b7	8b 4d e4	 mov	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  002ba	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$[ebp]
  002bd	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  002c0	89 45 bc	 mov	 DWORD PTR _dstLine$[ebp], eax
$LN10@convert_yu:
  002c3	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR _y$26[ebp]
  002c9	3b 4d dc	 cmp	 ecx, DWORD PTR _y_range$[ebp+8]
  002cc	0f 8d 5d 02 00
	00		 jge	 $LN1@convert_yu

; 1124 :         const int x_fin = width - crop_right;

  002d2	8b 53 10	 mov	 edx, DWORD PTR _width$[ebx]
  002d5	2b 55 f0	 sub	 edx, DWORD PTR _crop_right$[ebp]
  002d8	89 95 1c ff ff
	ff		 mov	 DWORD PTR _x_fin$25[ebp], edx

; 1125 :         uint8_t *src_u_ptr = srcULine;

  002de	8b 85 28 ff ff
	ff		 mov	 eax, DWORD PTR _srcULine$[ebp]
  002e4	89 85 18 ff ff
	ff		 mov	 DWORD PTR _src_u_ptr$24[ebp], eax

; 1126 :         uint8_t *src_v_ptr = srcVLine;

  002ea	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR _srcVLine$[ebp]
  002f0	89 8d 14 ff ff
	ff		 mov	 DWORD PTR _src_v_ptr$23[ebp], ecx

; 1127 :         uint16_t *dst_ptr = dstLine;

  002f6	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$[ebp]
  002f9	89 95 10 ff ff
	ff		 mov	 DWORD PTR _dst_ptr$22[ebp], edx

; 1128 :         __m128i x0, x1, x2, x3, x4;
; 1129 :         for (int x = crop_left; x < x_fin; x += 16, src_u_ptr += 16, src_v_ptr += 16, dst_ptr += 32) {

  002ff	8b 45 f8	 mov	 eax, DWORD PTR _crop_left$[ebp]
  00302	89 85 bc fe ff
	ff		 mov	 DWORD PTR _x$16[ebp], eax
  00308	eb 3c		 jmp	 SHORT $LN13@convert_yu
$LN11@convert_yu:
  0030a	8b 8d bc fe ff
	ff		 mov	 ecx, DWORD PTR _x$16[ebp]
  00310	83 c1 10	 add	 ecx, 16			; 00000010H
  00313	89 8d bc fe ff
	ff		 mov	 DWORD PTR _x$16[ebp], ecx
  00319	8b 95 18 ff ff
	ff		 mov	 edx, DWORD PTR _src_u_ptr$24[ebp]
  0031f	83 c2 10	 add	 edx, 16			; 00000010H
  00322	89 95 18 ff ff
	ff		 mov	 DWORD PTR _src_u_ptr$24[ebp], edx
  00328	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _src_v_ptr$23[ebp]
  0032e	83 c0 10	 add	 eax, 16			; 00000010H
  00331	89 85 14 ff ff
	ff		 mov	 DWORD PTR _src_v_ptr$23[ebp], eax
  00337	8b 8d 10 ff ff
	ff		 mov	 ecx, DWORD PTR _dst_ptr$22[ebp]
  0033d	83 c1 40	 add	 ecx, 64			; 00000040H
  00340	89 8d 10 ff ff
	ff		 mov	 DWORD PTR _dst_ptr$22[ebp], ecx
$LN13@convert_yu:
  00346	8b 95 bc fe ff
	ff		 mov	 edx, DWORD PTR _x$16[ebp]
  0034c	3b 95 1c ff ff
	ff		 cmp	 edx, DWORD PTR _x_fin$25[ebp]
  00352	0f 8d d2 01 00
	00		 jge	 $LN12@convert_yu

; 1130 :             x0 = _mm_loadu_si128((const __m128i *)src_u_ptr);

  00358	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _src_u_ptr$24[ebp]
  0035e	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00361	0f 29 85 a0 fe
	ff ff		 movaps	 XMMWORD PTR $T15[ebp], xmm0
  00368	0f 28 85 a0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T15[ebp]
  0036f	0f 29 85 00 ff
	ff ff		 movaps	 XMMWORD PTR _x0$21[ebp], xmm0

; 1131 :             x1 = _mm_loadu_si128((const __m128i *)src_v_ptr);

  00376	8b 8d 14 ff ff
	ff		 mov	 ecx, DWORD PTR _src_v_ptr$23[ebp]
  0037c	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  0037f	0f 29 85 90 fe
	ff ff		 movaps	 XMMWORD PTR $T14[ebp], xmm0
  00386	0f 28 85 90 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T14[ebp]
  0038d	0f 29 85 f0 fe
	ff ff		 movaps	 XMMWORD PTR _x1$20[ebp], xmm0

; 1132 :             x2 = _mm_unpackhi_epi8(_mm_setzero_si128(), x0);

  00394	0f 57 c0	 xorps	 xmm0, xmm0
  00397	0f 29 85 80 fe
	ff ff		 movaps	 XMMWORD PTR $T13[ebp], xmm0
  0039e	0f 28 85 80 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T13[ebp]
  003a5	66 0f 68 85 00
	ff ff ff	 punpckhbw xmm0, XMMWORD PTR _x0$21[ebp]
  003ad	0f 29 85 70 fe
	ff ff		 movaps	 XMMWORD PTR $T12[ebp], xmm0
  003b4	0f 28 85 70 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T12[ebp]
  003bb	0f 29 85 e0 fe
	ff ff		 movaps	 XMMWORD PTR _x2$19[ebp], xmm0

; 1133 :             x0 = _mm_unpacklo_epi8(_mm_setzero_si128(), x0);

  003c2	0f 57 c0	 xorps	 xmm0, xmm0
  003c5	0f 29 85 60 fe
	ff ff		 movaps	 XMMWORD PTR $T11[ebp], xmm0
  003cc	0f 28 85 60 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T11[ebp]
  003d3	66 0f 60 85 00
	ff ff ff	 punpcklbw xmm0, XMMWORD PTR _x0$21[ebp]
  003db	0f 29 85 50 fe
	ff ff		 movaps	 XMMWORD PTR $T10[ebp], xmm0
  003e2	0f 28 85 50 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T10[ebp]
  003e9	0f 29 85 00 ff
	ff ff		 movaps	 XMMWORD PTR _x0$21[ebp], xmm0

; 1134 :             x3 = _mm_unpackhi_epi8(_mm_setzero_si128(), x1);

  003f0	0f 57 c0	 xorps	 xmm0, xmm0
  003f3	0f 29 85 40 fe
	ff ff		 movaps	 XMMWORD PTR $T9[ebp], xmm0
  003fa	0f 28 85 40 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T9[ebp]
  00401	66 0f 68 85 f0
	fe ff ff	 punpckhbw xmm0, XMMWORD PTR _x1$20[ebp]
  00409	0f 29 85 30 fe
	ff ff		 movaps	 XMMWORD PTR $T8[ebp], xmm0
  00410	0f 28 85 30 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T8[ebp]
  00417	0f 29 85 d0 fe
	ff ff		 movaps	 XMMWORD PTR _x3$18[ebp], xmm0

; 1135 :             x1 = _mm_unpacklo_epi8(_mm_setzero_si128(), x1);

  0041e	0f 57 c0	 xorps	 xmm0, xmm0
  00421	0f 29 85 20 fe
	ff ff		 movaps	 XMMWORD PTR $T7[ebp], xmm0
  00428	0f 28 85 20 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T7[ebp]
  0042f	66 0f 60 85 f0
	fe ff ff	 punpcklbw xmm0, XMMWORD PTR _x1$20[ebp]
  00437	0f 29 85 10 fe
	ff ff		 movaps	 XMMWORD PTR $T6[ebp], xmm0
  0043e	0f 28 85 10 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T6[ebp]
  00445	0f 29 85 f0 fe
	ff ff		 movaps	 XMMWORD PTR _x1$20[ebp], xmm0

; 1136 : 
; 1137 :             x4 = _mm_unpackhi_epi16(x0, x1);

  0044c	0f 28 85 00 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x0$21[ebp]
  00453	66 0f 69 85 f0
	fe ff ff	 punpckhwd xmm0, XMMWORD PTR _x1$20[ebp]
  0045b	0f 29 85 00 fe
	ff ff		 movaps	 XMMWORD PTR $T5[ebp], xmm0
  00462	0f 28 85 00 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T5[ebp]
  00469	0f 29 85 c0 fe
	ff ff		 movaps	 XMMWORD PTR _x4$17[ebp], xmm0

; 1138 :             x0 = _mm_unpacklo_epi16(x0, x1);

  00470	0f 28 85 00 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x0$21[ebp]
  00477	66 0f 61 85 f0
	fe ff ff	 punpcklwd xmm0, XMMWORD PTR _x1$20[ebp]
  0047f	0f 29 85 f0 fd
	ff ff		 movaps	 XMMWORD PTR $T4[ebp], xmm0
  00486	0f 28 85 f0 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T4[ebp]
  0048d	0f 29 85 00 ff
	ff ff		 movaps	 XMMWORD PTR _x0$21[ebp], xmm0

; 1139 : 
; 1140 :             _mm_storeu_si128((__m128i *)(dst_ptr +  0), x0);

  00494	0f 10 85 00 ff
	ff ff		 movups	 xmm0, XMMWORD PTR _x0$21[ebp]
  0049b	8b 95 10 ff ff
	ff		 mov	 edx, DWORD PTR _dst_ptr$22[ebp]
  004a1	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 1141 :             _mm_storeu_si128((__m128i *)(dst_ptr +  8), x4);

  004a4	0f 10 85 c0 fe
	ff ff		 movups	 xmm0, XMMWORD PTR _x4$17[ebp]
  004ab	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _dst_ptr$22[ebp]
  004b1	83 c0 10	 add	 eax, 16			; 00000010H
  004b4	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 1142 : 
; 1143 :             x4 = _mm_unpackhi_epi16(x2, x3);

  004b7	0f 28 85 e0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _x2$19[ebp]
  004be	66 0f 69 85 d0
	fe ff ff	 punpckhwd xmm0, XMMWORD PTR _x3$18[ebp]
  004c6	0f 29 85 e0 fd
	ff ff		 movaps	 XMMWORD PTR $T3[ebp], xmm0
  004cd	0f 28 85 e0 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T3[ebp]
  004d4	0f 29 85 c0 fe
	ff ff		 movaps	 XMMWORD PTR _x4$17[ebp], xmm0

; 1144 :             x0 = _mm_unpacklo_epi16(x2, x3);

  004db	0f 28 85 e0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _x2$19[ebp]
  004e2	66 0f 61 85 d0
	fe ff ff	 punpcklwd xmm0, XMMWORD PTR _x3$18[ebp]
  004ea	0f 29 85 d0 fd
	ff ff		 movaps	 XMMWORD PTR $T2[ebp], xmm0
  004f1	0f 28 85 d0 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T2[ebp]
  004f8	0f 29 85 00 ff
	ff ff		 movaps	 XMMWORD PTR _x0$21[ebp], xmm0

; 1145 : 
; 1146 :             _mm_storeu_si128((__m128i *)(dst_ptr + 16), x0);

  004ff	0f 10 85 00 ff
	ff ff		 movups	 xmm0, XMMWORD PTR _x0$21[ebp]
  00506	8b 8d 10 ff ff
	ff		 mov	 ecx, DWORD PTR _dst_ptr$22[ebp]
  0050c	83 c1 20	 add	 ecx, 32			; 00000020H
  0050f	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 1147 :             _mm_storeu_si128((__m128i *)(dst_ptr + 24), x4);

  00512	0f 10 85 c0 fe
	ff ff		 movups	 xmm0, XMMWORD PTR _x4$17[ebp]
  00519	8b 95 10 ff ff
	ff		 mov	 edx, DWORD PTR _dst_ptr$22[ebp]
  0051f	83 c2 30	 add	 edx, 48			; 00000030H
  00522	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 1148 :         }

  00525	e9 e0 fd ff ff	 jmp	 $LN11@convert_yu
$LN12@convert_yu:

; 1149 :     }

  0052a	e9 55 fd ff ff	 jmp	 $LN8@convert_yu
$LN1@convert_yu:

; 1150 : }

  0052f	52		 push	 edx
  00530	8b cd		 mov	 ecx, ebp
  00532	50		 push	 eax
  00533	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN17@convert_yu
  00539	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0053e	58		 pop	 eax
  0053f	5a		 pop	 edx
  00540	5f		 pop	 edi
  00541	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00544	33 cd		 xor	 ecx, ebp
  00546	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0054b	8b e5		 mov	 esp, ebp
  0054d	5d		 pop	 ebp
  0054e	8b e3		 mov	 esp, ebx
  00550	5b		 pop	 ebx
  00551	c3		 ret	 0
  00552	66 90		 npad	 2
$LN17@convert_yu:
  00554	01 00 00 00	 DD	 1
  00558	00 00 00 00	 DD	 $LN16@convert_yu
$LN16@convert_yu:
  0055c	d4 ff ff ff	 DD	 -44			; ffffffd4H
  00560	0c 00 00 00	 DD	 12			; 0000000cH
  00564	00 00 00 00	 DD	 $LN15@convert_yu
$LN15@convert_yu:
  00568	79		 DB	 121			; 00000079H
  00569	5f		 DB	 95			; 0000005fH
  0056a	72		 DB	 114			; 00000072H
  0056b	61		 DB	 97			; 00000061H
  0056c	6e		 DB	 110			; 0000006eH
  0056d	67		 DB	 103			; 00000067H
  0056e	65		 DB	 101			; 00000065H
  0056f	00		 DB	 0
?convert_yuv422_to_p210_simd@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv422_to_p210_simd
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -80						; size = 12
_y$2 = -68						; size = 4
_y_width$ = -64						; size = 4
_dstLine$ = -60						; size = 4
_srcLine$ = -56						; size = 4
$T3 = -52						; size = 12
_y_range$ = -36						; size = 12
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_rgb32r_to_rgb32_simd@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_rgb32r_to_rgb32_simd

; 876  : static void __forceinline convert_rgb32r_to_rgb32_simd(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	57		 push	 edi
  00007	8d 7d b0	 lea	 edi, DWORD PTR [ebp-80]
  0000a	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  0000f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00014	f3 ab		 rep stosd
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 877  :     const int crop_left   = crop[0];

  00020	b8 04 00 00 00	 mov	 eax, 4
  00025	6b c8 00	 imul	 ecx, eax, 0
  00028	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  0002b	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0002e	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 878  :     const int crop_up     = crop[1];

  00031	b9 04 00 00 00	 mov	 ecx, 4
  00036	c1 e1 00	 shl	 ecx, 0
  00039	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  0003c	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0003f	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 879  :     const int crop_right  = crop[2];

  00042	b9 04 00 00 00	 mov	 ecx, 4
  00047	d1 e1		 shl	 ecx, 1
  00049	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  0004c	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0004f	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 880  :     const int crop_bottom = crop[3];

  00052	b9 04 00 00 00	 mov	 ecx, 4
  00057	6b d1 03	 imul	 edx, ecx, 3
  0005a	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  0005d	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00060	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 881  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00063	8b 55 2c	 mov	 edx, DWORD PTR _thread_n$[ebp]
  00066	52		 push	 edx
  00067	8b 45 28	 mov	 eax, DWORD PTR _thread_id$[ebp]
  0006a	50		 push	 eax
  0006b	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  0006e	2b 4d ec	 sub	 ecx, DWORD PTR _crop_bottom$[ebp]
  00071	51		 push	 ecx
  00072	8b 55 f4	 mov	 edx, DWORD PTR _crop_up$[ebp]
  00075	52		 push	 edx
  00076	8d 45 b0	 lea	 eax, DWORD PTR $T1[ebp]
  00079	50		 push	 eax
  0007a	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  0007f	83 c4 14	 add	 esp, 20			; 00000014H
  00082	8b 08		 mov	 ecx, DWORD PTR [eax]
  00084	89 4d cc	 mov	 DWORD PTR $T3[ebp], ecx
  00087	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0008a	89 55 d0	 mov	 DWORD PTR $T3[ebp+4], edx
  0008d	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00090	89 45 d4	 mov	 DWORD PTR $T3[ebp+8], eax
  00093	8b 4d cc	 mov	 ecx, DWORD PTR $T3[ebp]
  00096	89 4d dc	 mov	 DWORD PTR _y_range$[ebp], ecx
  00099	8b 55 d0	 mov	 edx, DWORD PTR $T3[ebp+4]
  0009c	89 55 e0	 mov	 DWORD PTR _y_range$[ebp+4], edx
  0009f	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp+8]
  000a2	89 45 e4	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 882  :     uint8_t *srcLine = (uint8_t *)src[0] + src_y_pitch_byte * (y_range.start_src + y_range.len - 1) + crop_left * 4;

  000a5	b9 04 00 00 00	 mov	 ecx, 4
  000aa	6b d1 00	 imul	 edx, ecx, 0
  000ad	8b 45 e4	 mov	 eax, DWORD PTR _y_range$[ebp+8]
  000b0	8b 4d dc	 mov	 ecx, DWORD PTR _y_range$[ebp]
  000b3	8d 44 01 ff	 lea	 eax, DWORD PTR [ecx+eax-1]
  000b7	0f af 45 14	 imul	 eax, DWORD PTR _src_y_pitch_byte$[ebp]
  000bb	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  000be	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  000c1	03 d0		 add	 edx, eax
  000c3	8b 45 f8	 mov	 eax, DWORD PTR _crop_left$[ebp]
  000c6	8d 0c 82	 lea	 ecx, DWORD PTR [edx+eax*4]
  000c9	89 4d c8	 mov	 DWORD PTR _srcLine$[ebp], ecx

; 883  :     uint8_t *dstLine = (uint8_t *)dst[0] + dst_y_pitch_byte * (height - (y_range.start_dst + y_range.len));

  000cc	ba 04 00 00 00	 mov	 edx, 4
  000d1	6b c2 00	 imul	 eax, edx, 0
  000d4	8b 4d e0	 mov	 ecx, DWORD PTR _y_range$[ebp+4]
  000d7	03 4d e4	 add	 ecx, DWORD PTR _y_range$[ebp+8]
  000da	8b 55 20	 mov	 edx, DWORD PTR _height$[ebp]
  000dd	2b d1		 sub	 edx, ecx
  000df	0f af 55 1c	 imul	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  000e3	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  000e6	03 14 01	 add	 edx, DWORD PTR [ecx+eax]
  000e9	89 55 c4	 mov	 DWORD PTR _dstLine$[ebp], edx

; 884  :     const int y_width = width - crop_right - crop_left;

  000ec	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  000ef	2b 55 f0	 sub	 edx, DWORD PTR _crop_right$[ebp]
  000f2	2b 55 f8	 sub	 edx, DWORD PTR _crop_left$[ebp]
  000f5	89 55 c0	 mov	 DWORD PTR _y_width$[ebp], edx

; 885  :     for (int y = 0; y < y_range.len; y++, dstLine += dst_y_pitch_byte, srcLine -= src_y_pitch_byte) {

  000f8	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _y$2[ebp], 0
  000ff	eb 1b		 jmp	 SHORT $LN4@convert_rg
$LN2@convert_rg:
  00101	8b 45 bc	 mov	 eax, DWORD PTR _y$2[ebp]
  00104	83 c0 01	 add	 eax, 1
  00107	89 45 bc	 mov	 DWORD PTR _y$2[ebp], eax
  0010a	8b 4d c4	 mov	 ecx, DWORD PTR _dstLine$[ebp]
  0010d	03 4d 1c	 add	 ecx, DWORD PTR _dst_y_pitch_byte$[ebp]
  00110	89 4d c4	 mov	 DWORD PTR _dstLine$[ebp], ecx
  00113	8b 55 c8	 mov	 edx, DWORD PTR _srcLine$[ebp]
  00116	2b 55 14	 sub	 edx, DWORD PTR _src_y_pitch_byte$[ebp]
  00119	89 55 c8	 mov	 DWORD PTR _srcLine$[ebp], edx
$LN4@convert_rg:
  0011c	8b 45 bc	 mov	 eax, DWORD PTR _y$2[ebp]
  0011f	3b 45 e4	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  00122	7d 19		 jge	 SHORT $LN1@convert_rg

; 886  :         memcpy_sse(dstLine, srcLine, y_width * 4);

  00124	8b 4d c0	 mov	 ecx, DWORD PTR _y_width$[ebp]
  00127	c1 e1 02	 shl	 ecx, 2
  0012a	51		 push	 ecx
  0012b	8b 55 c8	 mov	 edx, DWORD PTR _srcLine$[ebp]
  0012e	52		 push	 edx
  0012f	8b 45 c4	 mov	 eax, DWORD PTR _dstLine$[ebp]
  00132	50		 push	 eax
  00133	e8 00 00 00 00	 call	 ?memcpy_sse@@YAXPAEPBEH@Z ; memcpy_sse
  00138	83 c4 0c	 add	 esp, 12			; 0000000cH

; 887  :     }

  0013b	eb c4		 jmp	 SHORT $LN2@convert_rg
$LN1@convert_rg:

; 888  : }

  0013d	52		 push	 edx
  0013e	8b cd		 mov	 ecx, ebp
  00140	50		 push	 eax
  00141	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN8@convert_rg
  00147	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0014c	58		 pop	 eax
  0014d	5a		 pop	 edx
  0014e	5f		 pop	 edi
  0014f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00152	33 cd		 xor	 ecx, ebp
  00154	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00159	83 c4 50	 add	 esp, 80			; 00000050H
  0015c	3b ec		 cmp	 ebp, esp
  0015e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00163	8b e5		 mov	 esp, ebp
  00165	5d		 pop	 ebp
  00166	c3		 ret	 0
  00167	90		 npad	 1
$LN8@convert_rg:
  00168	01 00 00 00	 DD	 1
  0016c	00 00 00 00	 DD	 $LN7@convert_rg
$LN7@convert_rg:
  00170	dc ff ff ff	 DD	 -36			; ffffffdcH
  00174	0c 00 00 00	 DD	 12			; 0000000cH
  00178	00 00 00 00	 DD	 $LN6@convert_rg
$LN6@convert_rg:
  0017c	79		 DB	 121			; 00000079H
  0017d	5f		 DB	 95			; 0000005fH
  0017e	72		 DB	 114			; 00000072H
  0017f	61		 DB	 97			; 00000061H
  00180	6e		 DB	 110			; 0000006eH
  00181	67		 DB	 103			; 00000067H
  00182	65		 DB	 101			; 00000065H
  00183	00		 DB	 0
?convert_rgb32r_to_rgb32_simd@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_rgb32r_to_rgb32_simd
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -80						; size = 12
_y$2 = -68						; size = 4
_y_width$ = -64						; size = 4
_dstLine$ = -60						; size = 4
_srcLine$ = -56						; size = 4
$T3 = -52						; size = 12
_y_range$ = -36						; size = 12
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_rgb24r_to_rgb24_simd@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_rgb24r_to_rgb24_simd

; 814  : static void __forceinline convert_rgb24r_to_rgb24_simd(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	57		 push	 edi
  00007	8d 7d b0	 lea	 edi, DWORD PTR [ebp-80]
  0000a	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  0000f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00014	f3 ab		 rep stosd
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 815  :     const int crop_left   = crop[0];

  00020	b8 04 00 00 00	 mov	 eax, 4
  00025	6b c8 00	 imul	 ecx, eax, 0
  00028	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  0002b	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0002e	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 816  :     const int crop_up     = crop[1];

  00031	b9 04 00 00 00	 mov	 ecx, 4
  00036	c1 e1 00	 shl	 ecx, 0
  00039	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  0003c	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0003f	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 817  :     const int crop_right  = crop[2];

  00042	b9 04 00 00 00	 mov	 ecx, 4
  00047	d1 e1		 shl	 ecx, 1
  00049	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  0004c	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0004f	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 818  :     const int crop_bottom = crop[3];

  00052	b9 04 00 00 00	 mov	 ecx, 4
  00057	6b d1 03	 imul	 edx, ecx, 3
  0005a	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  0005d	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00060	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 819  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00063	8b 55 2c	 mov	 edx, DWORD PTR _thread_n$[ebp]
  00066	52		 push	 edx
  00067	8b 45 28	 mov	 eax, DWORD PTR _thread_id$[ebp]
  0006a	50		 push	 eax
  0006b	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  0006e	2b 4d ec	 sub	 ecx, DWORD PTR _crop_bottom$[ebp]
  00071	51		 push	 ecx
  00072	8b 55 f4	 mov	 edx, DWORD PTR _crop_up$[ebp]
  00075	52		 push	 edx
  00076	8d 45 b0	 lea	 eax, DWORD PTR $T1[ebp]
  00079	50		 push	 eax
  0007a	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  0007f	83 c4 14	 add	 esp, 20			; 00000014H
  00082	8b 08		 mov	 ecx, DWORD PTR [eax]
  00084	89 4d cc	 mov	 DWORD PTR $T3[ebp], ecx
  00087	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0008a	89 55 d0	 mov	 DWORD PTR $T3[ebp+4], edx
  0008d	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00090	89 45 d4	 mov	 DWORD PTR $T3[ebp+8], eax
  00093	8b 4d cc	 mov	 ecx, DWORD PTR $T3[ebp]
  00096	89 4d dc	 mov	 DWORD PTR _y_range$[ebp], ecx
  00099	8b 55 d0	 mov	 edx, DWORD PTR $T3[ebp+4]
  0009c	89 55 e0	 mov	 DWORD PTR _y_range$[ebp+4], edx
  0009f	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp+8]
  000a2	89 45 e4	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 820  :     uint8_t *srcLine = (uint8_t *)src[0] + src_y_pitch_byte * (y_range.start_src + y_range.len - 1) + crop_left * 3;

  000a5	b9 04 00 00 00	 mov	 ecx, 4
  000aa	6b d1 00	 imul	 edx, ecx, 0
  000ad	8b 45 e4	 mov	 eax, DWORD PTR _y_range$[ebp+8]
  000b0	8b 4d dc	 mov	 ecx, DWORD PTR _y_range$[ebp]
  000b3	8d 44 01 ff	 lea	 eax, DWORD PTR [ecx+eax-1]
  000b7	0f af 45 14	 imul	 eax, DWORD PTR _src_y_pitch_byte$[ebp]
  000bb	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  000be	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  000c1	03 d0		 add	 edx, eax
  000c3	6b 45 f8 03	 imul	 eax, DWORD PTR _crop_left$[ebp], 3
  000c7	03 d0		 add	 edx, eax
  000c9	89 55 c8	 mov	 DWORD PTR _srcLine$[ebp], edx

; 821  :     uint8_t *dstLine = (uint8_t *)dst[0] + dst_y_pitch_byte * (height - (y_range.start_dst + y_range.len));

  000cc	b9 04 00 00 00	 mov	 ecx, 4
  000d1	6b d1 00	 imul	 edx, ecx, 0
  000d4	8b 45 e0	 mov	 eax, DWORD PTR _y_range$[ebp+4]
  000d7	03 45 e4	 add	 eax, DWORD PTR _y_range$[ebp+8]
  000da	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  000dd	2b c8		 sub	 ecx, eax
  000df	0f af 4d 1c	 imul	 ecx, DWORD PTR _dst_y_pitch_byte$[ebp]
  000e3	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
  000e6	03 0c 10	 add	 ecx, DWORD PTR [eax+edx]
  000e9	89 4d c4	 mov	 DWORD PTR _dstLine$[ebp], ecx

; 822  :     const int y_width = width - crop_right - crop_left;

  000ec	8b 4d 10	 mov	 ecx, DWORD PTR _width$[ebp]
  000ef	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  000f2	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  000f5	89 4d c0	 mov	 DWORD PTR _y_width$[ebp], ecx

; 823  :     for (int y = 0; y < y_range.len; y++, dstLine += dst_y_pitch_byte, srcLine -= src_y_pitch_byte) {

  000f8	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _y$2[ebp], 0
  000ff	eb 1b		 jmp	 SHORT $LN4@convert_rg
$LN2@convert_rg:
  00101	8b 55 bc	 mov	 edx, DWORD PTR _y$2[ebp]
  00104	83 c2 01	 add	 edx, 1
  00107	89 55 bc	 mov	 DWORD PTR _y$2[ebp], edx
  0010a	8b 45 c4	 mov	 eax, DWORD PTR _dstLine$[ebp]
  0010d	03 45 1c	 add	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  00110	89 45 c4	 mov	 DWORD PTR _dstLine$[ebp], eax
  00113	8b 4d c8	 mov	 ecx, DWORD PTR _srcLine$[ebp]
  00116	2b 4d 14	 sub	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00119	89 4d c8	 mov	 DWORD PTR _srcLine$[ebp], ecx
$LN4@convert_rg:
  0011c	8b 55 bc	 mov	 edx, DWORD PTR _y$2[ebp]
  0011f	3b 55 e4	 cmp	 edx, DWORD PTR _y_range$[ebp+8]
  00122	7d 17		 jge	 SHORT $LN1@convert_rg

; 824  :         memcpy_sse(dstLine, srcLine, y_width * 3);

  00124	6b 45 c0 03	 imul	 eax, DWORD PTR _y_width$[ebp], 3
  00128	50		 push	 eax
  00129	8b 4d c8	 mov	 ecx, DWORD PTR _srcLine$[ebp]
  0012c	51		 push	 ecx
  0012d	8b 55 c4	 mov	 edx, DWORD PTR _dstLine$[ebp]
  00130	52		 push	 edx
  00131	e8 00 00 00 00	 call	 ?memcpy_sse@@YAXPAEPBEH@Z ; memcpy_sse
  00136	83 c4 0c	 add	 esp, 12			; 0000000cH

; 825  :     }

  00139	eb c6		 jmp	 SHORT $LN2@convert_rg
$LN1@convert_rg:

; 826  : }

  0013b	52		 push	 edx
  0013c	8b cd		 mov	 ecx, ebp
  0013e	50		 push	 eax
  0013f	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN8@convert_rg
  00145	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0014a	58		 pop	 eax
  0014b	5a		 pop	 edx
  0014c	5f		 pop	 edi
  0014d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00150	33 cd		 xor	 ecx, ebp
  00152	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00157	83 c4 50	 add	 esp, 80			; 00000050H
  0015a	3b ec		 cmp	 ebp, esp
  0015c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00161	8b e5		 mov	 esp, ebp
  00163	5d		 pop	 ebp
  00164	c3		 ret	 0
  00165	0f 1f 00	 npad	 3
$LN8@convert_rg:
  00168	01 00 00 00	 DD	 1
  0016c	00 00 00 00	 DD	 $LN7@convert_rg
$LN7@convert_rg:
  00170	dc ff ff ff	 DD	 -36			; ffffffdcH
  00174	0c 00 00 00	 DD	 12			; 0000000cH
  00178	00 00 00 00	 DD	 $LN6@convert_rg
$LN6@convert_rg:
  0017c	79		 DB	 121			; 00000079H
  0017d	5f		 DB	 95			; 0000005fH
  0017e	72		 DB	 114			; 00000072H
  0017f	61		 DB	 97			; 00000061H
  00180	6e		 DB	 110			; 0000006eH
  00181	67		 DB	 103			; 00000067H
  00182	65		 DB	 101			; 00000065H
  00183	00		 DB	 0
?convert_rgb24r_to_rgb24_simd@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_rgb24r_to_rgb24_simd
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -256						; size = 12
$T2 = -240						; size = 16
$T3 = -224						; size = 16
$T4 = -208						; size = 16
$T5 = -192						; size = 16
_x$6 = -164						; size = 4
_x2$7 = -160						; size = 16
_x1$8 = -144						; size = 16
_x0$9 = -128						; size = 16
_dst_ptr$10 = -100					; size = 4
_src_v_ptr$11 = -96					; size = 4
_src_u_ptr$12 = -92					; size = 4
_x_fin$13 = -88						; size = 4
_y$14 = -84						; size = 4
_uv_fin$ = -80						; size = 4
_srcVLine$ = -76					; size = 4
_srcULine$ = -72					; size = 4
_y$15 = -68						; size = 4
_y_width$ = -64						; size = 4
_dstLine$ = -60						; size = 4
_srcYLine$ = -56					; size = 4
$T16 = -52						; size = 12
_y_range$ = -36						; size = 12
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuv422_to_nv16_simd@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv422_to_nv16_simd

; 352  : static void __forceinline convert_yuv422_to_nv16_simd(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 00 01 00
	00		 sub	 esp, 256		; 00000100H
  0001c	57		 push	 edi
  0001d	8d bd 00 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-256]
  00023	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 353  :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 354  :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 355  :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 356  :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 357  :     //Y成分のコピー
; 358  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  0007c	8b 53 2c	 mov	 edx, DWORD PTR _thread_n$[ebx]
  0007f	52		 push	 edx
  00080	8b 43 28	 mov	 eax, DWORD PTR _thread_id$[ebx]
  00083	50		 push	 eax
  00084	8b 4b 20	 mov	 ecx, DWORD PTR _height$[ebx]
  00087	2b 4d ec	 sub	 ecx, DWORD PTR _crop_bottom$[ebp]
  0008a	51		 push	 ecx
  0008b	8b 55 f4	 mov	 edx, DWORD PTR _crop_up$[ebp]
  0008e	52		 push	 edx
  0008f	8d 85 00 ff ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  00095	50		 push	 eax
  00096	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  0009b	83 c4 14	 add	 esp, 20			; 00000014H
  0009e	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a0	89 4d cc	 mov	 DWORD PTR $T16[ebp], ecx
  000a3	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a6	89 55 d0	 mov	 DWORD PTR $T16[ebp+4], edx
  000a9	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000ac	89 45 d4	 mov	 DWORD PTR $T16[ebp+8], eax
  000af	8b 4d cc	 mov	 ecx, DWORD PTR $T16[ebp]
  000b2	89 4d dc	 mov	 DWORD PTR _y_range$[ebp], ecx
  000b5	8b 55 d0	 mov	 edx, DWORD PTR $T16[ebp+4]
  000b8	89 55 e0	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000bb	8b 45 d4	 mov	 eax, DWORD PTR $T16[ebp+8]
  000be	89 45 e4	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 359  :     uint8_t *srcYLine = (uint8_t *)src[0] + src_y_pitch_byte * y_range.start_src + crop_left;

  000c1	b9 04 00 00 00	 mov	 ecx, 4
  000c6	6b d1 00	 imul	 edx, ecx, 0
  000c9	8b 43 14	 mov	 eax, DWORD PTR _src_y_pitch_byte$[ebx]
  000cc	0f af 45 dc	 imul	 eax, DWORD PTR _y_range$[ebp]
  000d0	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  000d3	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  000d6	03 d0		 add	 edx, eax
  000d8	03 55 f8	 add	 edx, DWORD PTR _crop_left$[ebp]
  000db	89 55 c8	 mov	 DWORD PTR _srcYLine$[ebp], edx

; 360  :     uint8_t *dstLine = (uint8_t *)dst[0] + dst_y_pitch_byte * y_range.start_dst;

  000de	b8 04 00 00 00	 mov	 eax, 4
  000e3	6b c8 00	 imul	 ecx, eax, 0
  000e6	8b 53 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebx]
  000e9	0f af 55 e0	 imul	 edx, DWORD PTR _y_range$[ebp+4]
  000ed	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  000f0	03 14 08	 add	 edx, DWORD PTR [eax+ecx]
  000f3	89 55 c4	 mov	 DWORD PTR _dstLine$[ebp], edx

; 361  :     const int y_width = width - crop_right - crop_left;

  000f6	8b 4b 10	 mov	 ecx, DWORD PTR _width$[ebx]
  000f9	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  000fc	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  000ff	89 4d c0	 mov	 DWORD PTR _y_width$[ebp], ecx

; 362  :     for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch_byte, dstLine += dst_y_pitch_byte) {

  00102	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _y$15[ebp], 0
  00109	eb 1b		 jmp	 SHORT $LN4@convert_yu
$LN2@convert_yu:
  0010b	8b 55 bc	 mov	 edx, DWORD PTR _y$15[ebp]
  0010e	83 c2 01	 add	 edx, 1
  00111	89 55 bc	 mov	 DWORD PTR _y$15[ebp], edx
  00114	8b 45 c8	 mov	 eax, DWORD PTR _srcYLine$[ebp]
  00117	03 43 14	 add	 eax, DWORD PTR _src_y_pitch_byte$[ebx]
  0011a	89 45 c8	 mov	 DWORD PTR _srcYLine$[ebp], eax
  0011d	8b 4d c4	 mov	 ecx, DWORD PTR _dstLine$[ebp]
  00120	03 4b 1c	 add	 ecx, DWORD PTR _dst_y_pitch_byte$[ebx]
  00123	89 4d c4	 mov	 DWORD PTR _dstLine$[ebp], ecx
$LN4@convert_yu:
  00126	8b 55 bc	 mov	 edx, DWORD PTR _y$15[ebp]
  00129	3b 55 e4	 cmp	 edx, DWORD PTR _y_range$[ebp+8]
  0012c	7d 16		 jge	 SHORT $LN3@convert_yu

; 363  :         memcpy_sse(dstLine, srcYLine, y_width);

  0012e	8b 45 c0	 mov	 eax, DWORD PTR _y_width$[ebp]
  00131	50		 push	 eax
  00132	8b 4d c8	 mov	 ecx, DWORD PTR _srcYLine$[ebp]
  00135	51		 push	 ecx
  00136	8b 55 c4	 mov	 edx, DWORD PTR _dstLine$[ebp]
  00139	52		 push	 edx
  0013a	e8 00 00 00 00	 call	 ?memcpy_sse@@YAXPAEPBEH@Z ; memcpy_sse
  0013f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 364  :     }

  00142	eb c7		 jmp	 SHORT $LN2@convert_yu
$LN3@convert_yu:

; 365  :     //UV成分のコピー
; 366  :     uint8_t *srcULine = (uint8_t *)src[1] + ((src_uv_pitch_byte * y_range.start_src) + (crop_left >> 1));

  00144	b8 04 00 00 00	 mov	 eax, 4
  00149	c1 e0 00	 shl	 eax, 0
  0014c	8b 4b 18	 mov	 ecx, DWORD PTR _src_uv_pitch_byte$[ebx]
  0014f	0f af 4d dc	 imul	 ecx, DWORD PTR _y_range$[ebp]
  00153	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  00156	d1 fa		 sar	 edx, 1
  00158	03 ca		 add	 ecx, edx
  0015a	8b 53 0c	 mov	 edx, DWORD PTR _src$[ebx]
  0015d	03 0c 02	 add	 ecx, DWORD PTR [edx+eax]
  00160	89 4d b8	 mov	 DWORD PTR _srcULine$[ebp], ecx

; 367  :     uint8_t *srcVLine = (uint8_t *)src[2] + ((src_uv_pitch_byte * y_range.start_src) + (crop_left >> 1));

  00163	b8 04 00 00 00	 mov	 eax, 4
  00168	d1 e0		 shl	 eax, 1
  0016a	8b 4b 18	 mov	 ecx, DWORD PTR _src_uv_pitch_byte$[ebx]
  0016d	0f af 4d dc	 imul	 ecx, DWORD PTR _y_range$[ebp]
  00171	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  00174	d1 fa		 sar	 edx, 1
  00176	03 ca		 add	 ecx, edx
  00178	8b 53 0c	 mov	 edx, DWORD PTR _src$[ebx]
  0017b	03 0c 02	 add	 ecx, DWORD PTR [edx+eax]
  0017e	89 4d b4	 mov	 DWORD PTR _srcVLine$[ebp], ecx

; 368  :     dstLine = (uint8_t *)dst[1] + dst_y_pitch_byte * y_range.start_dst;

  00181	b8 04 00 00 00	 mov	 eax, 4
  00186	c1 e0 00	 shl	 eax, 0
  00189	8b 4b 1c	 mov	 ecx, DWORD PTR _dst_y_pitch_byte$[ebx]
  0018c	0f af 4d e0	 imul	 ecx, DWORD PTR _y_range$[ebp+4]
  00190	8b 53 08	 mov	 edx, DWORD PTR _dst$[ebx]
  00193	03 0c 02	 add	 ecx, DWORD PTR [edx+eax]
  00196	89 4d c4	 mov	 DWORD PTR _dstLine$[ebp], ecx

; 369  :     const int uv_fin = height - crop_bottom;

  00199	8b 43 20	 mov	 eax, DWORD PTR _height$[ebx]
  0019c	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  0019f	89 45 b0	 mov	 DWORD PTR _uv_fin$[ebp], eax

; 370  :     for (int y = 0; y < y_range.len; y++, srcULine += src_uv_pitch_byte, srcVLine += src_uv_pitch_byte, dstLine += dst_y_pitch_byte) {

  001a2	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR _y$14[ebp], 0
  001a9	eb 24		 jmp	 SHORT $LN7@convert_yu
$LN5@convert_yu:
  001ab	8b 4d ac	 mov	 ecx, DWORD PTR _y$14[ebp]
  001ae	83 c1 01	 add	 ecx, 1
  001b1	89 4d ac	 mov	 DWORD PTR _y$14[ebp], ecx
  001b4	8b 55 b8	 mov	 edx, DWORD PTR _srcULine$[ebp]
  001b7	03 53 18	 add	 edx, DWORD PTR _src_uv_pitch_byte$[ebx]
  001ba	89 55 b8	 mov	 DWORD PTR _srcULine$[ebp], edx
  001bd	8b 45 b4	 mov	 eax, DWORD PTR _srcVLine$[ebp]
  001c0	03 43 18	 add	 eax, DWORD PTR _src_uv_pitch_byte$[ebx]
  001c3	89 45 b4	 mov	 DWORD PTR _srcVLine$[ebp], eax
  001c6	8b 4d c4	 mov	 ecx, DWORD PTR _dstLine$[ebp]
  001c9	03 4b 1c	 add	 ecx, DWORD PTR _dst_y_pitch_byte$[ebx]
  001cc	89 4d c4	 mov	 DWORD PTR _dstLine$[ebp], ecx
$LN7@convert_yu:
  001cf	8b 55 ac	 mov	 edx, DWORD PTR _y$14[ebp]
  001d2	3b 55 e4	 cmp	 edx, DWORD PTR _y_range$[ebp+8]
  001d5	0f 8d f5 00 00
	00		 jge	 $LN1@convert_yu

; 371  :         const int x_fin = width - crop_right;

  001db	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  001de	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  001e1	89 45 a8	 mov	 DWORD PTR _x_fin$13[ebp], eax

; 372  :         uint8_t *src_u_ptr = srcULine;

  001e4	8b 4d b8	 mov	 ecx, DWORD PTR _srcULine$[ebp]
  001e7	89 4d a4	 mov	 DWORD PTR _src_u_ptr$12[ebp], ecx

; 373  :         uint8_t *src_v_ptr = srcVLine;

  001ea	8b 55 b4	 mov	 edx, DWORD PTR _srcVLine$[ebp]
  001ed	89 55 a0	 mov	 DWORD PTR _src_v_ptr$11[ebp], edx

; 374  :         uint8_t *dst_ptr = dstLine;

  001f0	8b 45 c4	 mov	 eax, DWORD PTR _dstLine$[ebp]
  001f3	89 45 9c	 mov	 DWORD PTR _dst_ptr$10[ebp], eax

; 375  :         __m128i x0, x1, x2;
; 376  :         for (int x = crop_left; x < x_fin; x += 32, src_u_ptr += 16, src_v_ptr += 16, dst_ptr += 32) {

  001f6	8b 4d f8	 mov	 ecx, DWORD PTR _crop_left$[ebp]
  001f9	89 8d 5c ff ff
	ff		 mov	 DWORD PTR _x$6[ebp], ecx
  001ff	eb 2a		 jmp	 SHORT $LN10@convert_yu
$LN8@convert_yu:
  00201	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR _x$6[ebp]
  00207	83 c2 20	 add	 edx, 32			; 00000020H
  0020a	89 95 5c ff ff
	ff		 mov	 DWORD PTR _x$6[ebp], edx
  00210	8b 45 a4	 mov	 eax, DWORD PTR _src_u_ptr$12[ebp]
  00213	83 c0 10	 add	 eax, 16			; 00000010H
  00216	89 45 a4	 mov	 DWORD PTR _src_u_ptr$12[ebp], eax
  00219	8b 4d a0	 mov	 ecx, DWORD PTR _src_v_ptr$11[ebp]
  0021c	83 c1 10	 add	 ecx, 16			; 00000010H
  0021f	89 4d a0	 mov	 DWORD PTR _src_v_ptr$11[ebp], ecx
  00222	8b 55 9c	 mov	 edx, DWORD PTR _dst_ptr$10[ebp]
  00225	83 c2 20	 add	 edx, 32			; 00000020H
  00228	89 55 9c	 mov	 DWORD PTR _dst_ptr$10[ebp], edx
$LN10@convert_yu:
  0022b	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _x$6[ebp]
  00231	3b 45 a8	 cmp	 eax, DWORD PTR _x_fin$13[ebp]
  00234	0f 8d 91 00 00
	00		 jge	 $LN9@convert_yu

; 377  :             x0 = _mm_loadu_si128((const __m128i *)src_u_ptr);

  0023a	8b 4d a4	 mov	 ecx, DWORD PTR _src_u_ptr$12[ebp]
  0023d	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00240	0f 29 85 40 ff
	ff ff		 movaps	 XMMWORD PTR $T5[ebp], xmm0
  00247	0f 28 85 40 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T5[ebp]
  0024e	0f 29 45 80	 movaps	 XMMWORD PTR _x0$9[ebp], xmm0

; 378  :             x1 = _mm_loadu_si128((const __m128i *)src_v_ptr);

  00252	8b 55 a0	 mov	 edx, DWORD PTR _src_v_ptr$11[ebp]
  00255	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  00258	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR $T4[ebp], xmm0
  0025f	0f 28 85 30 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T4[ebp]
  00266	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR _x1$8[ebp], xmm0

; 379  : 
; 380  :             x2 = _mm_unpackhi_epi8(x0, x1);

  0026d	0f 28 45 80	 movaps	 xmm0, XMMWORD PTR _x0$9[ebp]
  00271	66 0f 68 85 70
	ff ff ff	 punpckhbw xmm0, XMMWORD PTR _x1$8[ebp]
  00279	0f 29 85 20 ff
	ff ff		 movaps	 XMMWORD PTR $T3[ebp], xmm0
  00280	0f 28 85 20 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T3[ebp]
  00287	0f 29 85 60 ff
	ff ff		 movaps	 XMMWORD PTR _x2$7[ebp], xmm0

; 381  :             x0 = _mm_unpacklo_epi8(x0, x1);

  0028e	0f 28 45 80	 movaps	 xmm0, XMMWORD PTR _x0$9[ebp]
  00292	66 0f 60 85 70
	ff ff ff	 punpcklbw xmm0, XMMWORD PTR _x1$8[ebp]
  0029a	0f 29 85 10 ff
	ff ff		 movaps	 XMMWORD PTR $T2[ebp], xmm0
  002a1	0f 28 85 10 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T2[ebp]
  002a8	0f 29 45 80	 movaps	 XMMWORD PTR _x0$9[ebp], xmm0

; 382  : 
; 383  :             _mm_storeu_si128((__m128i *)(dst_ptr +  0), x0);

  002ac	0f 10 45 80	 movups	 xmm0, XMMWORD PTR _x0$9[ebp]
  002b0	8b 45 9c	 mov	 eax, DWORD PTR _dst_ptr$10[ebp]
  002b3	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 384  :             _mm_storeu_si128((__m128i *)(dst_ptr + 16), x2);

  002b6	0f 10 85 60 ff
	ff ff		 movups	 xmm0, XMMWORD PTR _x2$7[ebp]
  002bd	8b 4d 9c	 mov	 ecx, DWORD PTR _dst_ptr$10[ebp]
  002c0	83 c1 10	 add	 ecx, 16			; 00000010H
  002c3	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 385  :         }

  002c6	e9 36 ff ff ff	 jmp	 $LN8@convert_yu
$LN9@convert_yu:

; 386  :     }

  002cb	e9 db fe ff ff	 jmp	 $LN5@convert_yu
$LN1@convert_yu:

; 387  : }

  002d0	52		 push	 edx
  002d1	8b cd		 mov	 ecx, ebp
  002d3	50		 push	 eax
  002d4	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN14@convert_yu
  002da	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  002df	58		 pop	 eax
  002e0	5a		 pop	 edx
  002e1	5f		 pop	 edi
  002e2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002e5	33 cd		 xor	 ecx, ebp
  002e7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002ec	8b e5		 mov	 esp, ebp
  002ee	5d		 pop	 ebp
  002ef	8b e3		 mov	 esp, ebx
  002f1	5b		 pop	 ebx
  002f2	c3		 ret	 0
  002f3	90		 npad	 1
$LN14@convert_yu:
  002f4	01 00 00 00	 DD	 1
  002f8	00 00 00 00	 DD	 $LN13@convert_yu
$LN13@convert_yu:
  002fc	dc ff ff ff	 DD	 -36			; ffffffdcH
  00300	0c 00 00 00	 DD	 12			; 0000000cH
  00304	00 00 00 00	 DD	 $LN12@convert_yu
$LN12@convert_yu:
  00308	79		 DB	 121			; 00000079H
  00309	5f		 DB	 95			; 0000005fH
  0030a	72		 DB	 114			; 00000072H
  0030b	61		 DB	 97			; 00000061H
  0030c	6e		 DB	 110			; 0000006eH
  0030d	67		 DB	 103			; 00000067H
  0030e	65		 DB	 101			; 00000065H
  0030f	00		 DB	 0
?convert_yuv422_to_nv16_simd@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv422_to_nv16_simd
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -288						; size = 12
$T2 = -272						; size = 16
$T3 = -256						; size = 16
$T4 = -240						; size = 16
$T5 = -224						; size = 16
$T6 = -208						; size = 16
_x$7 = -184						; size = 4
_x_fin$8 = -180						; size = 4
_x3$9 = -176						; size = 16
_x1$10 = -144						; size = 16
_x0$11 = -112						; size = 16
_pw$12 = -80						; size = 4
_p$13 = -76						; size = 4
_i$14 = -72						; size = 4
_y$15 = -68						; size = 4
_dstCLine$ = -64					; size = 4
_dstYLine$ = -60					; size = 4
_srcLine$ = -56						; size = 4
$T16 = -52						; size = 12
_y_range$ = -36						; size = 12
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuy2_to_nv12_i_simd@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuy2_to_nv12_i_simd

; 233  : static void __forceinline convert_yuy2_to_nv12_i_simd(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 20 01 00
	00		 sub	 esp, 288		; 00000120H
  0001c	57		 push	 edi
  0001d	8d bd e0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-288]
  00023	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 234  :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 235  :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 236  :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 237  :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 238  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  0007c	8b 53 2c	 mov	 edx, DWORD PTR _thread_n$[ebx]
  0007f	52		 push	 edx
  00080	8b 43 28	 mov	 eax, DWORD PTR _thread_id$[ebx]
  00083	50		 push	 eax
  00084	8b 4b 20	 mov	 ecx, DWORD PTR _height$[ebx]
  00087	2b 4d ec	 sub	 ecx, DWORD PTR _crop_bottom$[ebp]
  0008a	51		 push	 ecx
  0008b	8b 55 f4	 mov	 edx, DWORD PTR _crop_up$[ebp]
  0008e	52		 push	 edx
  0008f	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  00095	50		 push	 eax
  00096	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  0009b	83 c4 14	 add	 esp, 20			; 00000014H
  0009e	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a0	89 4d cc	 mov	 DWORD PTR $T16[ebp], ecx
  000a3	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a6	89 55 d0	 mov	 DWORD PTR $T16[ebp+4], edx
  000a9	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000ac	89 45 d4	 mov	 DWORD PTR $T16[ebp+8], eax
  000af	8b 4d cc	 mov	 ecx, DWORD PTR $T16[ebp]
  000b2	89 4d dc	 mov	 DWORD PTR _y_range$[ebp], ecx
  000b5	8b 55 d0	 mov	 edx, DWORD PTR $T16[ebp+4]
  000b8	89 55 e0	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000bb	8b 45 d4	 mov	 eax, DWORD PTR $T16[ebp+8]
  000be	89 45 e4	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 239  :     uint8_t *srcLine = (uint8_t *)src[0] + src_y_pitch_byte * y_range.start_src + crop_left;

  000c1	b9 04 00 00 00	 mov	 ecx, 4
  000c6	6b d1 00	 imul	 edx, ecx, 0
  000c9	8b 43 14	 mov	 eax, DWORD PTR _src_y_pitch_byte$[ebx]
  000cc	0f af 45 dc	 imul	 eax, DWORD PTR _y_range$[ebp]
  000d0	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  000d3	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  000d6	03 d0		 add	 edx, eax
  000d8	03 55 f8	 add	 edx, DWORD PTR _crop_left$[ebp]
  000db	89 55 c8	 mov	 DWORD PTR _srcLine$[ebp], edx

; 240  :     uint8_t *dstYLine = (uint8_t *)dst[0] + dst_y_pitch_byte * y_range.start_dst;

  000de	b8 04 00 00 00	 mov	 eax, 4
  000e3	6b c8 00	 imul	 ecx, eax, 0
  000e6	8b 53 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebx]
  000e9	0f af 55 e0	 imul	 edx, DWORD PTR _y_range$[ebp+4]
  000ed	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  000f0	03 14 08	 add	 edx, DWORD PTR [eax+ecx]
  000f3	89 55 c4	 mov	 DWORD PTR _dstYLine$[ebp], edx

; 241  :     uint8_t *dstCLine = (uint8_t *)dst[1] + dst_y_pitch_byte * (y_range.start_dst >> 1);

  000f6	b9 04 00 00 00	 mov	 ecx, 4
  000fb	c1 e1 00	 shl	 ecx, 0
  000fe	8b 55 e0	 mov	 edx, DWORD PTR _y_range$[ebp+4]
  00101	d1 fa		 sar	 edx, 1
  00103	0f af 53 1c	 imul	 edx, DWORD PTR _dst_y_pitch_byte$[ebx]
  00107	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  0010a	03 14 08	 add	 edx, DWORD PTR [eax+ecx]
  0010d	89 55 c0	 mov	 DWORD PTR _dstCLine$[ebp], edx

; 242  :     for (int y = 0; y < y_range.len; y += 4) {

  00110	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _y$15[ebp], 0
  00117	eb 09		 jmp	 SHORT $LN4@convert_yu
$LN2@convert_yu:
  00119	8b 4d bc	 mov	 ecx, DWORD PTR _y$15[ebp]
  0011c	83 c1 04	 add	 ecx, 4
  0011f	89 4d bc	 mov	 DWORD PTR _y$15[ebp], ecx
$LN4@convert_yu:
  00122	8b 55 bc	 mov	 edx, DWORD PTR _y$15[ebp]
  00125	3b 55 e4	 cmp	 edx, DWORD PTR _y_range$[ebp+8]
  00128	0f 8d c0 01 00
	00		 jge	 $LN1@convert_yu

; 243  :         for (int i = 0; i < 2; i++) {

  0012e	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _i$14[ebp], 0
  00135	eb 09		 jmp	 SHORT $LN7@convert_yu
$LN5@convert_yu:
  00137	8b 45 b8	 mov	 eax, DWORD PTR _i$14[ebp]
  0013a	83 c0 01	 add	 eax, 1
  0013d	89 45 b8	 mov	 DWORD PTR _i$14[ebp], eax
$LN7@convert_yu:
  00140	83 7d b8 02	 cmp	 DWORD PTR _i$14[ebp], 2
  00144	0f 8d 87 01 00
	00		 jge	 $LN6@convert_yu

; 244  :             uint8_t *p = srcLine;

  0014a	8b 4d c8	 mov	 ecx, DWORD PTR _srcLine$[ebp]
  0014d	89 4d b4	 mov	 DWORD PTR _p$13[ebp], ecx

; 245  :             uint8_t *pw = p + (src_y_pitch_byte<<1);

  00150	8b 53 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  00153	8b 45 b4	 mov	 eax, DWORD PTR _p$13[ebp]
  00156	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00159	89 4d b0	 mov	 DWORD PTR _pw$12[ebp], ecx

; 246  :             __m128i x0, x1, x3;
; 247  :             const int x_fin = width - crop_right - crop_left;

  0015c	8b 53 10	 mov	 edx, DWORD PTR _width$[ebx]
  0015f	2b 55 f0	 sub	 edx, DWORD PTR _crop_right$[ebp]
  00162	2b 55 f8	 sub	 edx, DWORD PTR _crop_left$[ebp]
  00165	89 95 4c ff ff
	ff		 mov	 DWORD PTR _x_fin$8[ebp], edx

; 248  :             for (int x = 0; x < x_fin; x += 16, p += 32, pw += 32) {

  0016b	c7 85 48 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _x$7[ebp], 0
  00175	eb 21		 jmp	 SHORT $LN10@convert_yu
$LN8@convert_yu:
  00177	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _x$7[ebp]
  0017d	83 c0 10	 add	 eax, 16			; 00000010H
  00180	89 85 48 ff ff
	ff		 mov	 DWORD PTR _x$7[ebp], eax
  00186	8b 4d b4	 mov	 ecx, DWORD PTR _p$13[ebp]
  00189	83 c1 20	 add	 ecx, 32			; 00000020H
  0018c	89 4d b4	 mov	 DWORD PTR _p$13[ebp], ecx
  0018f	8b 55 b0	 mov	 edx, DWORD PTR _pw$12[ebp]
  00192	83 c2 20	 add	 edx, 32			; 00000020H
  00195	89 55 b0	 mov	 DWORD PTR _pw$12[ebp], edx
$LN10@convert_yu:
  00198	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _x$7[ebp]
  0019e	3b 85 4c ff ff
	ff		 cmp	 eax, DWORD PTR _x_fin$8[ebp]
  001a4	0f 8d 07 01 00
	00		 jge	 $LN9@convert_yu

; 249  :                 //-----------    1+i行目   ---------------
; 250  :                 x0 = _mm_loadu_si128((const __m128i *)(p+ 0));

  001aa	8b 4d b4	 mov	 ecx, DWORD PTR _p$13[ebp]
  001ad	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  001b0	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR $T6[ebp], xmm0
  001b7	0f 28 85 30 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T6[ebp]
  001be	0f 29 45 90	 movaps	 XMMWORD PTR _x0$11[ebp], xmm0

; 251  :                 x1 = _mm_loadu_si128((const __m128i *)(p+16));

  001c2	8b 55 b4	 mov	 edx, DWORD PTR _p$13[ebp]
  001c5	83 c2 10	 add	 edx, 16			; 00000010H
  001c8	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  001cb	0f 29 85 20 ff
	ff ff		 movaps	 XMMWORD PTR $T5[ebp], xmm0
  001d2	0f 28 85 20 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T5[ebp]
  001d9	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR _x1$10[ebp], xmm0

; 252  : 
; 253  :                 separate_low_up(x0, x1);

  001e0	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR _x1$10[ebp]
  001e6	50		 push	 eax
  001e7	8d 4d 90	 lea	 ecx, DWORD PTR _x0$11[ebp]
  001ea	51		 push	 ecx
  001eb	e8 00 00 00 00	 call	 ?separate_low_up@@YAXAAT__m128i@@0@Z ; separate_low_up
  001f0	83 c4 08	 add	 esp, 8

; 254  :                 x3 = x1;

  001f3	0f 28 85 70 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$10[ebp]
  001fa	0f 29 85 50 ff
	ff ff		 movaps	 XMMWORD PTR _x3$9[ebp], xmm0

; 255  : 
; 256  :                 _mm_store_si128((__m128i *)(dstYLine + x), x0);

  00201	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR _x0$11[ebp]
  00205	8b 55 c4	 mov	 edx, DWORD PTR _dstYLine$[ebp]
  00208	03 95 48 ff ff
	ff		 add	 edx, DWORD PTR _x$7[ebp]
  0020e	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 257  :                 //-----------1+i行目終了---------------
; 258  : 
; 259  :                 //-----------3+i行目---------------
; 260  :                 x0 = _mm_loadu_si128((const __m128i *)(pw+ 0));

  00211	8b 45 b0	 mov	 eax, DWORD PTR _pw$12[ebp]
  00214	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00217	0f 29 85 10 ff
	ff ff		 movaps	 XMMWORD PTR $T4[ebp], xmm0
  0021e	0f 28 85 10 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T4[ebp]
  00225	0f 29 45 90	 movaps	 XMMWORD PTR _x0$11[ebp], xmm0

; 261  :                 x1 = _mm_loadu_si128((const __m128i *)(pw+16));

  00229	8b 4d b0	 mov	 ecx, DWORD PTR _pw$12[ebp]
  0022c	83 c1 10	 add	 ecx, 16			; 00000010H
  0022f	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00232	0f 29 85 00 ff
	ff ff		 movaps	 XMMWORD PTR $T3[ebp], xmm0
  00239	0f 28 85 00 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T3[ebp]
  00240	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR _x1$10[ebp], xmm0

; 262  : 
; 263  :                 separate_low_up(x0, x1);

  00247	8d 95 70 ff ff
	ff		 lea	 edx, DWORD PTR _x1$10[ebp]
  0024d	52		 push	 edx
  0024e	8d 45 90	 lea	 eax, DWORD PTR _x0$11[ebp]
  00251	50		 push	 eax
  00252	e8 00 00 00 00	 call	 ?separate_low_up@@YAXAAT__m128i@@0@Z ; separate_low_up
  00257	83 c4 08	 add	 esp, 8

; 264  : 
; 265  :                 _mm_store_si128((__m128i *)(dstYLine + (dst_y_pitch_byte<<1) + x), x0);

  0025a	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR _x0$11[ebp]
  0025e	8b 4b 1c	 mov	 ecx, DWORD PTR _dst_y_pitch_byte$[ebx]
  00261	8b 55 c4	 mov	 edx, DWORD PTR _dstYLine$[ebp]
  00264	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  00267	03 85 48 ff ff
	ff		 add	 eax, DWORD PTR _x$7[ebp]
  0026d	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 266  :                 //-----------3+i行目終了---------------
; 267  :                 x0 = yuv422_to_420_i_interpolate(x3, x1, i);

  00270	8b 4d b8	 mov	 ecx, DWORD PTR _i$14[ebp]
  00273	51		 push	 ecx
  00274	0f 28 8d 70 ff
	ff ff		 movaps	 xmm1, XMMWORD PTR _x1$10[ebp]
  0027b	0f 28 85 50 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x3$9[ebp]
  00282	e8 00 00 00 00	 call	 ?yuv422_to_420_i_interpolate@@YA?AT__m128i@@T1@0H@Z ; yuv422_to_420_i_interpolate
  00287	83 c4 04	 add	 esp, 4
  0028a	0f 29 85 f0 fe
	ff ff		 movaps	 XMMWORD PTR $T2[ebp], xmm0
  00291	0f 28 85 f0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T2[ebp]
  00298	0f 29 45 90	 movaps	 XMMWORD PTR _x0$11[ebp], xmm0

; 268  : 
; 269  :                 _mm_store_si128((__m128i *)(dstCLine + x), x0);

  0029c	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR _x0$11[ebp]
  002a0	8b 55 c0	 mov	 edx, DWORD PTR _dstCLine$[ebp]
  002a3	03 95 48 ff ff
	ff		 add	 edx, DWORD PTR _x$7[ebp]
  002a9	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 270  :             }

  002ac	e9 c6 fe ff ff	 jmp	 $LN8@convert_yu
$LN9@convert_yu:

; 271  :             srcLine  += src_y_pitch_byte;

  002b1	8b 45 c8	 mov	 eax, DWORD PTR _srcLine$[ebp]
  002b4	03 43 14	 add	 eax, DWORD PTR _src_y_pitch_byte$[ebx]
  002b7	89 45 c8	 mov	 DWORD PTR _srcLine$[ebp], eax

; 272  :             dstYLine += dst_y_pitch_byte;

  002ba	8b 4d c4	 mov	 ecx, DWORD PTR _dstYLine$[ebp]
  002bd	03 4b 1c	 add	 ecx, DWORD PTR _dst_y_pitch_byte$[ebx]
  002c0	89 4d c4	 mov	 DWORD PTR _dstYLine$[ebp], ecx

; 273  :             dstCLine += dst_y_pitch_byte;

  002c3	8b 55 c0	 mov	 edx, DWORD PTR _dstCLine$[ebp]
  002c6	03 53 1c	 add	 edx, DWORD PTR _dst_y_pitch_byte$[ebx]
  002c9	89 55 c0	 mov	 DWORD PTR _dstCLine$[ebp], edx

; 274  :         }

  002cc	e9 66 fe ff ff	 jmp	 $LN5@convert_yu
$LN6@convert_yu:

; 275  :         srcLine  += src_y_pitch_byte << 1;

  002d1	8b 43 14	 mov	 eax, DWORD PTR _src_y_pitch_byte$[ebx]
  002d4	8b 4d c8	 mov	 ecx, DWORD PTR _srcLine$[ebp]
  002d7	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  002da	89 55 c8	 mov	 DWORD PTR _srcLine$[ebp], edx

; 276  :         dstYLine += dst_y_pitch_byte << 1;

  002dd	8b 43 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  002e0	8b 4d c4	 mov	 ecx, DWORD PTR _dstYLine$[ebp]
  002e3	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  002e6	89 55 c4	 mov	 DWORD PTR _dstYLine$[ebp], edx

; 277  :     }

  002e9	e9 2b fe ff ff	 jmp	 $LN2@convert_yu
$LN1@convert_yu:

; 278  : }

  002ee	52		 push	 edx
  002ef	8b cd		 mov	 ecx, ebp
  002f1	50		 push	 eax
  002f2	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN16@convert_yu
  002f8	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  002fd	58		 pop	 eax
  002fe	5a		 pop	 edx
  002ff	5f		 pop	 edi
  00300	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00303	33 cd		 xor	 ecx, ebp
  00305	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0030a	8b e5		 mov	 esp, ebp
  0030c	5d		 pop	 ebp
  0030d	8b e3		 mov	 esp, ebx
  0030f	5b		 pop	 ebx
  00310	c3		 ret	 0
  00311	0f 1f 00	 npad	 3
$LN16@convert_yu:
  00314	03 00 00 00	 DD	 3
  00318	00 00 00 00	 DD	 $LN15@convert_yu
$LN15@convert_yu:
  0031c	dc ff ff ff	 DD	 -36			; ffffffdcH
  00320	0c 00 00 00	 DD	 12			; 0000000cH
  00324	00 00 00 00	 DD	 $LN12@convert_yu
  00328	90 ff ff ff	 DD	 -112			; ffffff90H
  0032c	10 00 00 00	 DD	 16			; 00000010H
  00330	00 00 00 00	 DD	 $LN13@convert_yu
  00334	70 ff ff ff	 DD	 -144			; ffffff70H
  00338	10 00 00 00	 DD	 16			; 00000010H
  0033c	00 00 00 00	 DD	 $LN14@convert_yu
$LN14@convert_yu:
  00340	78		 DB	 120			; 00000078H
  00341	31		 DB	 49			; 00000031H
  00342	00		 DB	 0
$LN13@convert_yu:
  00343	78		 DB	 120			; 00000078H
  00344	30		 DB	 48			; 00000030H
  00345	00		 DB	 0
$LN12@convert_yu:
  00346	79		 DB	 121			; 00000079H
  00347	5f		 DB	 95			; 0000005fH
  00348	72		 DB	 114			; 00000072H
  00349	61		 DB	 97			; 00000061H
  0034a	6e		 DB	 110			; 0000006eH
  0034b	67		 DB	 103			; 00000067H
  0034c	65		 DB	 101			; 00000065H
  0034d	00		 DB	 0
?convert_yuy2_to_nv12_i_simd@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuy2_to_nv12_i_simd
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -512						; size = 16
$T2 = -496						; size = 16
$T3 = -480						; size = 16
$T4 = -464						; size = 16
$T5 = -448						; size = 16
$T6 = -432						; size = 16
$T7 = -416						; size = 16
$T8 = -400						; size = 16
$T9 = -384						; size = 16
$T10 = -368						; size = 16
$T11 = -352						; size = 16
$T12 = -336						; size = 16
$T13 = -320						; size = 16
$T14 = -304						; size = 16
$T15 = -288						; size = 16
$T16 = -272						; size = 16
$T17 = -256						; size = 16
$T18 = -240						; size = 16
$T19 = -224						; size = 16
$T20 = -208						; size = 16
$T21 = -192						; size = 16
_xC$ = -160						; size = 32
_x3$ = -112						; size = 16
_x2$ = -96						; size = 16
_x1$ = -80						; size = 16
_x0$ = -64						; size = 16
_y_down$ = -48						; size = 16
_y_up$ = -32						; size = 16
__$ArrayPad$ = -4					; size = 4
_i$ = 8							; size = 4
?yuv422_to_420_i_interpolate@@YA?AT__m128i@@T1@0H@Z PROC ; yuv422_to_420_i_interpolate
; _y_up$ = xmm0
; _y_down$ = xmm1

; 205  : static __forceinline __m128i yuv422_to_420_i_interpolate(__m128i y_up, __m128i y_down, int i) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 00 02 00
	00		 sub	 esp, 512		; 00000200H
  0001c	57		 push	 edi
  0001d	8d bd 00 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-512]
  00023	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00039	0f 29 4d d0	 movaps	 XMMWORD PTR _y_down$[ebp], xmm1
  0003d	0f 29 45 e0	 movaps	 XMMWORD PTR _y_up$[ebp], xmm0

; 206  :     __m128i x0, x1;
; 207  : #if USE_SSSE3
; 208  :     x0 = _mm_unpacklo_epi8(y_down, y_up);
; 209  :     x1 = _mm_unpackhi_epi8(y_down, y_up);
; 210  :     x0 = _mm_maddubs_epi16(x0, xC_INTERLACE_WEIGHT(i));
; 211  :     x1 = _mm_maddubs_epi16(x1, xC_INTERLACE_WEIGHT(i));
; 212  : #else
; 213  :     __m128i x2, x3, xC[2];
; 214  :     xC[0] = y_up;

  00041	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00046	6b c8 00	 imul	 ecx, eax, 0
  00049	0f 10 45 e0	 movups	 xmm0, XMMWORD PTR _y_up$[ebp]
  0004d	0f 11 84 0d 60
	ff ff ff	 movups	 XMMWORD PTR _xC$[ebp+ecx], xmm0

; 215  :     xC[1] = y_down;

  00055	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  0005a	c1 e2 00	 shl	 edx, 0
  0005d	0f 10 45 d0	 movups	 xmm0, XMMWORD PTR _y_down$[ebp]
  00061	0f 11 84 15 60
	ff ff ff	 movups	 XMMWORD PTR _xC$[ebp+edx], xmm0

; 216  :     x0 = _mm_unpacklo_epi8(xC[i], _mm_setzero_si128());

  00069	0f 57 c0	 xorps	 xmm0, xmm0
  0006c	0f 29 85 40 ff
	ff ff		 movaps	 XMMWORD PTR $T21[ebp], xmm0
  00073	8b 43 08	 mov	 eax, DWORD PTR _i$[ebx]
  00076	c1 e0 04	 shl	 eax, 4
  00079	0f 10 84 05 60
	ff ff ff	 movups	 xmm0, XMMWORD PTR _xC$[ebp+eax]
  00081	66 0f 60 85 40
	ff ff ff	 punpcklbw xmm0, XMMWORD PTR $T21[ebp]
  00089	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR $T20[ebp], xmm0
  00090	0f 28 85 30 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T20[ebp]
  00097	0f 29 45 c0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 217  :     x1 = _mm_unpackhi_epi8(xC[i], _mm_setzero_si128());

  0009b	0f 57 c0	 xorps	 xmm0, xmm0
  0009e	0f 29 85 20 ff
	ff ff		 movaps	 XMMWORD PTR $T19[ebp], xmm0
  000a5	8b 4b 08	 mov	 ecx, DWORD PTR _i$[ebx]
  000a8	c1 e1 04	 shl	 ecx, 4
  000ab	0f 10 84 0d 60
	ff ff ff	 movups	 xmm0, XMMWORD PTR _xC$[ebp+ecx]
  000b3	66 0f 68 85 20
	ff ff ff	 punpckhbw xmm0, XMMWORD PTR $T19[ebp]
  000bb	0f 29 85 10 ff
	ff ff		 movaps	 XMMWORD PTR $T18[ebp], xmm0
  000c2	0f 28 85 10 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T18[ebp]
  000c9	0f 29 45 b0	 movaps	 XMMWORD PTR _x1$[ebp], xmm0

; 218  :     x0 = _mm_mullo_epi16(x0, _mm_set1_epi16(3));

  000cd	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@00030003000300030003000300030003
  000d4	0f 29 85 00 ff
	ff ff		 movaps	 XMMWORD PTR $T17[ebp], xmm0
  000db	0f 28 45 c0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  000df	66 0f d5 85 00
	ff ff ff	 pmullw	 xmm0, XMMWORD PTR $T17[ebp]
  000e7	0f 29 85 f0 fe
	ff ff		 movaps	 XMMWORD PTR $T16[ebp], xmm0
  000ee	0f 28 85 f0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T16[ebp]
  000f5	0f 29 45 c0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 219  :     x1 = _mm_mullo_epi16(x1, _mm_set1_epi16(3));

  000f9	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@00030003000300030003000300030003
  00100	0f 29 85 e0 fe
	ff ff		 movaps	 XMMWORD PTR $T15[ebp], xmm0
  00107	0f 28 45 b0	 movaps	 xmm0, XMMWORD PTR _x1$[ebp]
  0010b	66 0f d5 85 e0
	fe ff ff	 pmullw	 xmm0, XMMWORD PTR $T15[ebp]
  00113	0f 29 85 d0 fe
	ff ff		 movaps	 XMMWORD PTR $T14[ebp], xmm0
  0011a	0f 28 85 d0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T14[ebp]
  00121	0f 29 45 b0	 movaps	 XMMWORD PTR _x1$[ebp], xmm0

; 220  :     x2 = _mm_unpacklo_epi8(xC[(i+1)&0x01], _mm_setzero_si128());

  00125	0f 57 c0	 xorps	 xmm0, xmm0
  00128	0f 29 85 c0 fe
	ff ff		 movaps	 XMMWORD PTR $T13[ebp], xmm0
  0012f	8b 53 08	 mov	 edx, DWORD PTR _i$[ebx]
  00132	83 c2 01	 add	 edx, 1
  00135	83 e2 01	 and	 edx, 1
  00138	c1 e2 04	 shl	 edx, 4
  0013b	0f 10 84 15 60
	ff ff ff	 movups	 xmm0, XMMWORD PTR _xC$[ebp+edx]
  00143	66 0f 60 85 c0
	fe ff ff	 punpcklbw xmm0, XMMWORD PTR $T13[ebp]
  0014b	0f 29 85 b0 fe
	ff ff		 movaps	 XMMWORD PTR $T12[ebp], xmm0
  00152	0f 28 85 b0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T12[ebp]
  00159	0f 29 45 a0	 movaps	 XMMWORD PTR _x2$[ebp], xmm0

; 221  :     x3 = _mm_unpackhi_epi8(xC[(i+1)&0x01], _mm_setzero_si128());

  0015d	0f 57 c0	 xorps	 xmm0, xmm0
  00160	0f 29 85 a0 fe
	ff ff		 movaps	 XMMWORD PTR $T11[ebp], xmm0
  00167	8b 43 08	 mov	 eax, DWORD PTR _i$[ebx]
  0016a	83 c0 01	 add	 eax, 1
  0016d	83 e0 01	 and	 eax, 1
  00170	c1 e0 04	 shl	 eax, 4
  00173	0f 10 84 05 60
	ff ff ff	 movups	 xmm0, XMMWORD PTR _xC$[ebp+eax]
  0017b	66 0f 68 85 a0
	fe ff ff	 punpckhbw xmm0, XMMWORD PTR $T11[ebp]
  00183	0f 29 85 90 fe
	ff ff		 movaps	 XMMWORD PTR $T10[ebp], xmm0
  0018a	0f 28 85 90 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T10[ebp]
  00191	0f 29 45 90	 movaps	 XMMWORD PTR _x3$[ebp], xmm0

; 222  :     x0 = _mm_add_epi16(x0, x2);

  00195	0f 28 45 c0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  00199	66 0f fd 45 a0	 paddw	 xmm0, XMMWORD PTR _x2$[ebp]
  0019e	0f 29 85 80 fe
	ff ff		 movaps	 XMMWORD PTR $T9[ebp], xmm0
  001a5	0f 28 85 80 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T9[ebp]
  001ac	0f 29 45 c0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 223  :     x1 = _mm_add_epi16(x1, x3);

  001b0	0f 28 45 b0	 movaps	 xmm0, XMMWORD PTR _x1$[ebp]
  001b4	66 0f fd 45 90	 paddw	 xmm0, XMMWORD PTR _x3$[ebp]
  001b9	0f 29 85 70 fe
	ff ff		 movaps	 XMMWORD PTR $T8[ebp], xmm0
  001c0	0f 28 85 70 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T8[ebp]
  001c7	0f 29 45 b0	 movaps	 XMMWORD PTR _x1$[ebp], xmm0

; 224  : #endif
; 225  :     x0 = _mm_add_epi16(x0, _mm_set1_epi16(2));

  001cb	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@00020002000200020002000200020002
  001d2	0f 29 85 60 fe
	ff ff		 movaps	 XMMWORD PTR $T7[ebp], xmm0
  001d9	0f 28 45 c0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  001dd	66 0f fd 85 60
	fe ff ff	 paddw	 xmm0, XMMWORD PTR $T7[ebp]
  001e5	0f 29 85 50 fe
	ff ff		 movaps	 XMMWORD PTR $T6[ebp], xmm0
  001ec	0f 28 85 50 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T6[ebp]
  001f3	0f 29 45 c0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 226  :     x1 = _mm_add_epi16(x1, _mm_set1_epi16(2));

  001f7	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@00020002000200020002000200020002
  001fe	0f 29 85 40 fe
	ff ff		 movaps	 XMMWORD PTR $T5[ebp], xmm0
  00205	0f 28 45 b0	 movaps	 xmm0, XMMWORD PTR _x1$[ebp]
  00209	66 0f fd 85 40
	fe ff ff	 paddw	 xmm0, XMMWORD PTR $T5[ebp]
  00211	0f 29 85 30 fe
	ff ff		 movaps	 XMMWORD PTR $T4[ebp], xmm0
  00218	0f 28 85 30 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T4[ebp]
  0021f	0f 29 45 b0	 movaps	 XMMWORD PTR _x1$[ebp], xmm0

; 227  :     x0 = _mm_srai_epi16(x0, 2);

  00223	0f 28 45 c0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  00227	66 0f 71 e0 02	 psraw	 xmm0, 2
  0022c	0f 29 85 20 fe
	ff ff		 movaps	 XMMWORD PTR $T3[ebp], xmm0
  00233	0f 28 85 20 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T3[ebp]
  0023a	0f 29 45 c0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 228  :     x1 = _mm_srai_epi16(x1, 2);

  0023e	0f 28 45 b0	 movaps	 xmm0, XMMWORD PTR _x1$[ebp]
  00242	66 0f 71 e0 02	 psraw	 xmm0, 2
  00247	0f 29 85 10 fe
	ff ff		 movaps	 XMMWORD PTR $T2[ebp], xmm0
  0024e	0f 28 85 10 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T2[ebp]
  00255	0f 29 45 b0	 movaps	 XMMWORD PTR _x1$[ebp], xmm0

; 229  :     x0 = _mm_packus_epi16(x0, x1);

  00259	0f 28 45 c0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  0025d	66 0f 67 45 b0	 packuswb xmm0, XMMWORD PTR _x1$[ebp]
  00262	0f 29 85 00 fe
	ff ff		 movaps	 XMMWORD PTR $T1[ebp], xmm0
  00269	0f 28 85 00 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T1[ebp]
  00270	0f 29 45 c0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 230  :     return x0;

  00274	0f 28 45 c0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]

; 231  : }

  00278	52		 push	 edx
  00279	8b cd		 mov	 ecx, ebp
  0027b	50		 push	 eax
  0027c	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@yuv422_to_
  00282	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00287	58		 pop	 eax
  00288	5a		 pop	 edx
  00289	5f		 pop	 edi
  0028a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0028d	33 cd		 xor	 ecx, ebp
  0028f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00294	8b e5		 mov	 esp, ebp
  00296	5d		 pop	 ebp
  00297	8b e3		 mov	 esp, ebx
  00299	5b		 pop	 ebx
  0029a	c3		 ret	 0
  0029b	90		 npad	 1
$LN5@yuv422_to_:
  0029c	01 00 00 00	 DD	 1
  002a0	00 00 00 00	 DD	 $LN4@yuv422_to_
$LN4@yuv422_to_:
  002a4	60 ff ff ff	 DD	 -160			; ffffff60H
  002a8	20 00 00 00	 DD	 32			; 00000020H
  002ac	00 00 00 00	 DD	 $LN3@yuv422_to_
$LN3@yuv422_to_:
  002b0	78		 DB	 120			; 00000078H
  002b1	43		 DB	 67			; 00000043H
  002b2	00		 DB	 0
?yuv422_to_420_i_interpolate@@YA?AT__m128i@@T1@0H@Z ENDP ; yuv422_to_420_i_interpolate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -288						; size = 12
$T2 = -272						; size = 16
$T3 = -256						; size = 16
$T4 = -240						; size = 16
$T5 = -224						; size = 16
$T6 = -208						; size = 16
_x$7 = -180						; size = 4
_x3$8 = -176						; size = 16
_x1$9 = -144						; size = 16
_x0$10 = -112						; size = 16
_x_fin$11 = -80						; size = 4
_pw$12 = -76						; size = 4
_p$13 = -72						; size = 4
_y$14 = -68						; size = 4
_dstCLine$ = -64					; size = 4
_dstYLine$ = -60					; size = 4
_srcLine$ = -56						; size = 4
$T15 = -52						; size = 12
_y_range$ = -36						; size = 12
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuy2_to_nv12_simd@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuy2_to_nv12_simd

; 162  : static void __forceinline convert_yuy2_to_nv12_simd(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 20 01 00
	00		 sub	 esp, 288		; 00000120H
  0001c	57		 push	 edi
  0001d	8d bd e0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-288]
  00023	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 163  :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 164  :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 165  :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 166  :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 167  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  0007c	8b 53 2c	 mov	 edx, DWORD PTR _thread_n$[ebx]
  0007f	52		 push	 edx
  00080	8b 43 28	 mov	 eax, DWORD PTR _thread_id$[ebx]
  00083	50		 push	 eax
  00084	8b 4b 20	 mov	 ecx, DWORD PTR _height$[ebx]
  00087	2b 4d ec	 sub	 ecx, DWORD PTR _crop_bottom$[ebp]
  0008a	51		 push	 ecx
  0008b	8b 55 f4	 mov	 edx, DWORD PTR _crop_up$[ebp]
  0008e	52		 push	 edx
  0008f	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  00095	50		 push	 eax
  00096	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  0009b	83 c4 14	 add	 esp, 20			; 00000014H
  0009e	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a0	89 4d cc	 mov	 DWORD PTR $T15[ebp], ecx
  000a3	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a6	89 55 d0	 mov	 DWORD PTR $T15[ebp+4], edx
  000a9	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000ac	89 45 d4	 mov	 DWORD PTR $T15[ebp+8], eax
  000af	8b 4d cc	 mov	 ecx, DWORD PTR $T15[ebp]
  000b2	89 4d dc	 mov	 DWORD PTR _y_range$[ebp], ecx
  000b5	8b 55 d0	 mov	 edx, DWORD PTR $T15[ebp+4]
  000b8	89 55 e0	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000bb	8b 45 d4	 mov	 eax, DWORD PTR $T15[ebp+8]
  000be	89 45 e4	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 168  :     uint8_t *srcLine = (uint8_t *)src[0] + src_y_pitch_byte * y_range.start_src + crop_left;

  000c1	b9 04 00 00 00	 mov	 ecx, 4
  000c6	6b d1 00	 imul	 edx, ecx, 0
  000c9	8b 43 14	 mov	 eax, DWORD PTR _src_y_pitch_byte$[ebx]
  000cc	0f af 45 dc	 imul	 eax, DWORD PTR _y_range$[ebp]
  000d0	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  000d3	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  000d6	03 d0		 add	 edx, eax
  000d8	03 55 f8	 add	 edx, DWORD PTR _crop_left$[ebp]
  000db	89 55 c8	 mov	 DWORD PTR _srcLine$[ebp], edx

; 169  :     uint8_t *dstYLine = (uint8_t *)dst[0] + dst_y_pitch_byte * y_range.start_dst;

  000de	b8 04 00 00 00	 mov	 eax, 4
  000e3	6b c8 00	 imul	 ecx, eax, 0
  000e6	8b 53 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebx]
  000e9	0f af 55 e0	 imul	 edx, DWORD PTR _y_range$[ebp+4]
  000ed	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  000f0	03 14 08	 add	 edx, DWORD PTR [eax+ecx]
  000f3	89 55 c4	 mov	 DWORD PTR _dstYLine$[ebp], edx

; 170  :     uint8_t *dstCLine = (uint8_t *)dst[1] + dst_y_pitch_byte * (y_range.start_dst >> 1);

  000f6	b9 04 00 00 00	 mov	 ecx, 4
  000fb	c1 e1 00	 shl	 ecx, 0
  000fe	8b 55 e0	 mov	 edx, DWORD PTR _y_range$[ebp+4]
  00101	d1 fa		 sar	 edx, 1
  00103	0f af 53 1c	 imul	 edx, DWORD PTR _dst_y_pitch_byte$[ebx]
  00107	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  0010a	03 14 08	 add	 edx, DWORD PTR [eax+ecx]
  0010d	89 55 c0	 mov	 DWORD PTR _dstCLine$[ebp], edx

; 171  :     for (int y = 0; y < y_range.len; y += 2) {

  00110	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _y$14[ebp], 0
  00117	eb 09		 jmp	 SHORT $LN4@convert_yu
$LN2@convert_yu:
  00119	8b 4d bc	 mov	 ecx, DWORD PTR _y$14[ebp]
  0011c	83 c1 02	 add	 ecx, 2
  0011f	89 4d bc	 mov	 DWORD PTR _y$14[ebp], ecx
$LN4@convert_yu:
  00122	8b 55 bc	 mov	 edx, DWORD PTR _y$14[ebp]
  00125	3b 55 e4	 cmp	 edx, DWORD PTR _y_range$[ebp+8]
  00128	0f 8d 7c 01 00
	00		 jge	 $LN1@convert_yu

; 172  :         uint8_t *p = srcLine;

  0012e	8b 45 c8	 mov	 eax, DWORD PTR _srcLine$[ebp]
  00131	89 45 b8	 mov	 DWORD PTR _p$13[ebp], eax

; 173  :         uint8_t *pw = p + src_y_pitch_byte;

  00134	8b 4d b8	 mov	 ecx, DWORD PTR _p$13[ebp]
  00137	03 4b 14	 add	 ecx, DWORD PTR _src_y_pitch_byte$[ebx]
  0013a	89 4d b4	 mov	 DWORD PTR _pw$12[ebp], ecx

; 174  :         const int x_fin = width - crop_right - crop_left;

  0013d	8b 53 10	 mov	 edx, DWORD PTR _width$[ebx]
  00140	2b 55 f0	 sub	 edx, DWORD PTR _crop_right$[ebp]
  00143	2b 55 f8	 sub	 edx, DWORD PTR _crop_left$[ebp]
  00146	89 55 b0	 mov	 DWORD PTR _x_fin$11[ebp], edx

; 175  :         __m128i x0, x1, x3;
; 176  :         for (int x = 0; x < x_fin; x += 16, p += 32, pw += 32) {

  00149	c7 85 4c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _x$7[ebp], 0
  00153	eb 21		 jmp	 SHORT $LN7@convert_yu
$LN5@convert_yu:
  00155	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _x$7[ebp]
  0015b	83 c0 10	 add	 eax, 16			; 00000010H
  0015e	89 85 4c ff ff
	ff		 mov	 DWORD PTR _x$7[ebp], eax
  00164	8b 4d b8	 mov	 ecx, DWORD PTR _p$13[ebp]
  00167	83 c1 20	 add	 ecx, 32			; 00000020H
  0016a	89 4d b8	 mov	 DWORD PTR _p$13[ebp], ecx
  0016d	8b 55 b4	 mov	 edx, DWORD PTR _pw$12[ebp]
  00170	83 c2 20	 add	 edx, 32			; 00000020H
  00173	89 55 b4	 mov	 DWORD PTR _pw$12[ebp], edx
$LN7@convert_yu:
  00176	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _x$7[ebp]
  0017c	3b 45 b0	 cmp	 eax, DWORD PTR _x_fin$11[ebp]
  0017f	0f 8d ff 00 00
	00		 jge	 $LN6@convert_yu

; 177  :             //-----------1行目---------------
; 178  :             x0 = _mm_loadu_si128((const __m128i *)(p+ 0));

  00185	8b 4d b8	 mov	 ecx, DWORD PTR _p$13[ebp]
  00188	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  0018b	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR $T6[ebp], xmm0
  00192	0f 28 85 30 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T6[ebp]
  00199	0f 29 45 90	 movaps	 XMMWORD PTR _x0$10[ebp], xmm0

; 179  :             x1 = _mm_loadu_si128((const __m128i *)(p+16));

  0019d	8b 55 b8	 mov	 edx, DWORD PTR _p$13[ebp]
  001a0	83 c2 10	 add	 edx, 16			; 00000010H
  001a3	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  001a6	0f 29 85 20 ff
	ff ff		 movaps	 XMMWORD PTR $T5[ebp], xmm0
  001ad	0f 28 85 20 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T5[ebp]
  001b4	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR _x1$9[ebp], xmm0

; 180  : 
; 181  :             separate_low_up(x0, x1);

  001bb	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR _x1$9[ebp]
  001c1	50		 push	 eax
  001c2	8d 4d 90	 lea	 ecx, DWORD PTR _x0$10[ebp]
  001c5	51		 push	 ecx
  001c6	e8 00 00 00 00	 call	 ?separate_low_up@@YAXAAT__m128i@@0@Z ; separate_low_up
  001cb	83 c4 08	 add	 esp, 8

; 182  :             x3 = x1;

  001ce	0f 28 85 70 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$9[ebp]
  001d5	0f 29 85 50 ff
	ff ff		 movaps	 XMMWORD PTR _x3$8[ebp], xmm0

; 183  : 
; 184  :             _mm_store_si128((__m128i *)(dstYLine + x), x0);

  001dc	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR _x0$10[ebp]
  001e0	8b 55 c4	 mov	 edx, DWORD PTR _dstYLine$[ebp]
  001e3	03 95 4c ff ff
	ff		 add	 edx, DWORD PTR _x$7[ebp]
  001e9	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 185  :             //-----------1行目終了---------------
; 186  : 
; 187  :             //-----------2行目---------------
; 188  :             x0 = _mm_loadu_si128((const __m128i *)(pw+ 0));

  001ec	8b 45 b4	 mov	 eax, DWORD PTR _pw$12[ebp]
  001ef	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  001f2	0f 29 85 10 ff
	ff ff		 movaps	 XMMWORD PTR $T4[ebp], xmm0
  001f9	0f 28 85 10 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T4[ebp]
  00200	0f 29 45 90	 movaps	 XMMWORD PTR _x0$10[ebp], xmm0

; 189  :             x1 = _mm_loadu_si128((const __m128i *)(pw+16));

  00204	8b 4d b4	 mov	 ecx, DWORD PTR _pw$12[ebp]
  00207	83 c1 10	 add	 ecx, 16			; 00000010H
  0020a	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  0020d	0f 29 85 00 ff
	ff ff		 movaps	 XMMWORD PTR $T3[ebp], xmm0
  00214	0f 28 85 00 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T3[ebp]
  0021b	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR _x1$9[ebp], xmm0

; 190  : 
; 191  :             separate_low_up(x0, x1);

  00222	8d 95 70 ff ff
	ff		 lea	 edx, DWORD PTR _x1$9[ebp]
  00228	52		 push	 edx
  00229	8d 45 90	 lea	 eax, DWORD PTR _x0$10[ebp]
  0022c	50		 push	 eax
  0022d	e8 00 00 00 00	 call	 ?separate_low_up@@YAXAAT__m128i@@0@Z ; separate_low_up
  00232	83 c4 08	 add	 esp, 8

; 192  : 
; 193  :             _mm_store_si128((__m128i *)(dstYLine + dst_y_pitch_byte + x), x0);

  00235	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR _x0$10[ebp]
  00239	8b 4d c4	 mov	 ecx, DWORD PTR _dstYLine$[ebp]
  0023c	03 4b 1c	 add	 ecx, DWORD PTR _dst_y_pitch_byte$[ebx]
  0023f	03 8d 4c ff ff
	ff		 add	 ecx, DWORD PTR _x$7[ebp]
  00245	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 194  :             //-----------2行目終了---------------
; 195  : 
; 196  :             x1 = _mm_avg_epu8(x1, x3);

  00248	0f 28 85 70 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$9[ebp]
  0024f	66 0f e0 85 50
	ff ff ff	 pavgb	 xmm0, XMMWORD PTR _x3$8[ebp]
  00257	0f 29 85 f0 fe
	ff ff		 movaps	 XMMWORD PTR $T2[ebp], xmm0
  0025e	0f 28 85 f0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T2[ebp]
  00265	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR _x1$9[ebp], xmm0

; 197  :             _mm_store_si128((__m128i *)(dstCLine + x), x1);

  0026c	0f 28 85 70 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$9[ebp]
  00273	8b 55 c0	 mov	 edx, DWORD PTR _dstCLine$[ebp]
  00276	03 95 4c ff ff
	ff		 add	 edx, DWORD PTR _x$7[ebp]
  0027c	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 198  :         }

  0027f	e9 d1 fe ff ff	 jmp	 $LN5@convert_yu
$LN6@convert_yu:

; 199  :         srcLine  += src_y_pitch_byte << 1;

  00284	8b 43 14	 mov	 eax, DWORD PTR _src_y_pitch_byte$[ebx]
  00287	8b 4d c8	 mov	 ecx, DWORD PTR _srcLine$[ebp]
  0028a	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  0028d	89 55 c8	 mov	 DWORD PTR _srcLine$[ebp], edx

; 200  :         dstYLine += dst_y_pitch_byte << 1;

  00290	8b 43 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  00293	8b 4d c4	 mov	 ecx, DWORD PTR _dstYLine$[ebp]
  00296	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00299	89 55 c4	 mov	 DWORD PTR _dstYLine$[ebp], edx

; 201  :         dstCLine += dst_y_pitch_byte;

  0029c	8b 45 c0	 mov	 eax, DWORD PTR _dstCLine$[ebp]
  0029f	03 43 1c	 add	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  002a2	89 45 c0	 mov	 DWORD PTR _dstCLine$[ebp], eax

; 202  :     }

  002a5	e9 6f fe ff ff	 jmp	 $LN2@convert_yu
$LN1@convert_yu:

; 203  : }

  002aa	52		 push	 edx
  002ab	8b cd		 mov	 ecx, ebp
  002ad	50		 push	 eax
  002ae	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN13@convert_yu
  002b4	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  002b9	58		 pop	 eax
  002ba	5a		 pop	 edx
  002bb	5f		 pop	 edi
  002bc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002bf	33 cd		 xor	 ecx, ebp
  002c1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002c6	8b e5		 mov	 esp, ebp
  002c8	5d		 pop	 ebp
  002c9	8b e3		 mov	 esp, ebx
  002cb	5b		 pop	 ebx
  002cc	c3		 ret	 0
  002cd	0f 1f 00	 npad	 3
$LN13@convert_yu:
  002d0	03 00 00 00	 DD	 3
  002d4	00 00 00 00	 DD	 $LN12@convert_yu
$LN12@convert_yu:
  002d8	dc ff ff ff	 DD	 -36			; ffffffdcH
  002dc	0c 00 00 00	 DD	 12			; 0000000cH
  002e0	00 00 00 00	 DD	 $LN9@convert_yu
  002e4	90 ff ff ff	 DD	 -112			; ffffff90H
  002e8	10 00 00 00	 DD	 16			; 00000010H
  002ec	00 00 00 00	 DD	 $LN10@convert_yu
  002f0	70 ff ff ff	 DD	 -144			; ffffff70H
  002f4	10 00 00 00	 DD	 16			; 00000010H
  002f8	00 00 00 00	 DD	 $LN11@convert_yu
$LN11@convert_yu:
  002fc	78		 DB	 120			; 00000078H
  002fd	31		 DB	 49			; 00000031H
  002fe	00		 DB	 0
$LN10@convert_yu:
  002ff	78		 DB	 120			; 00000078H
  00300	30		 DB	 48			; 00000030H
  00301	00		 DB	 0
$LN9@convert_yu:
  00302	79		 DB	 121			; 00000079H
  00303	5f		 DB	 95			; 0000005fH
  00304	72		 DB	 114			; 00000072H
  00305	61		 DB	 97			; 00000061H
  00306	6e		 DB	 110			; 0000006eH
  00307	67		 DB	 103			; 00000067H
  00308	65		 DB	 101			; 00000065H
  00309	00		 DB	 0
?convert_yuy2_to_nv12_simd@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuy2_to_nv12_simd
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -208						; size = 16
$T2 = -192						; size = 16
$T3 = -176						; size = 16
$T4 = -160						; size = 16
$T5 = -144						; size = 16
$T6 = -128						; size = 16
$T7 = -112						; size = 16
$T8 = -96						; size = 16
$T9 = -80						; size = 16
$T10 = -64						; size = 16
_xMaskLowByte$ = -48					; size = 16
_x5$ = -32						; size = 16
_x4$ = -16						; size = 16
_x0_return_lower$ = 8					; size = 4
_x1_return_upper$ = 12					; size = 4
?separate_low_up@@YAXAAT__m128i@@0@Z PROC		; separate_low_up

; 146  : static __forceinline void separate_low_up(__m128i& x0_return_lower, __m128i& x1_return_upper) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  0001c	57		 push	 edi
  0001d	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00023	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd

; 147  :     __m128i x4, x5;
; 148  :     const __m128i xMaskLowByte = _mm_srli_epi16(_mm_cmpeq_epi8(_mm_setzero_si128(), _mm_setzero_si128()), 8);

  0002f	0f 57 c0	 xorps	 xmm0, xmm0
  00032	0f 29 45 b0	 movaps	 XMMWORD PTR $T9[ebp], xmm0
  00036	0f 57 c0	 xorps	 xmm0, xmm0
  00039	0f 29 45 c0	 movaps	 XMMWORD PTR $T10[ebp], xmm0
  0003d	0f 28 45 c0	 movaps	 xmm0, XMMWORD PTR $T10[ebp]
  00041	66 0f 74 45 b0	 pcmpeqb xmm0, XMMWORD PTR $T9[ebp]
  00046	0f 29 45 a0	 movaps	 XMMWORD PTR $T8[ebp], xmm0
  0004a	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR $T8[ebp]
  0004e	66 0f 71 d0 08	 psrlw	 xmm0, 8
  00053	0f 29 45 90	 movaps	 XMMWORD PTR $T7[ebp], xmm0
  00057	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR $T7[ebp]
  0005b	0f 29 45 d0	 movaps	 XMMWORD PTR _xMaskLowByte$[ebp], xmm0

; 149  :     x4 = _mm_srli_epi16(x0_return_lower, 8);

  0005f	8b 43 08	 mov	 eax, DWORD PTR _x0_return_lower$[ebx]
  00062	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00065	66 0f 71 d0 08	 psrlw	 xmm0, 8
  0006a	0f 29 45 80	 movaps	 XMMWORD PTR $T6[ebp], xmm0
  0006e	0f 28 45 80	 movaps	 xmm0, XMMWORD PTR $T6[ebp]
  00072	0f 29 45 f0	 movaps	 XMMWORD PTR _x4$[ebp], xmm0

; 150  :     x5 = _mm_srli_epi16(x1_return_upper, 8);

  00076	8b 4b 0c	 mov	 ecx, DWORD PTR _x1_return_upper$[ebx]
  00079	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  0007c	66 0f 71 d0 08	 psrlw	 xmm0, 8
  00081	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR $T5[ebp], xmm0
  00088	0f 28 85 70 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T5[ebp]
  0008f	0f 29 45 e0	 movaps	 XMMWORD PTR _x5$[ebp], xmm0

; 151  : 
; 152  :     x0_return_lower = _mm_and_si128(x0_return_lower, xMaskLowByte);

  00093	8b 53 08	 mov	 edx, DWORD PTR _x0_return_lower$[ebx]
  00096	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  00099	66 0f db 45 d0	 pand	 xmm0, XMMWORD PTR _xMaskLowByte$[ebp]
  0009e	0f 29 85 60 ff
	ff ff		 movaps	 XMMWORD PTR $T4[ebp], xmm0
  000a5	8b 43 08	 mov	 eax, DWORD PTR _x0_return_lower$[ebx]
  000a8	0f 10 85 60 ff
	ff ff		 movups	 xmm0, XMMWORD PTR $T4[ebp]
  000af	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 153  :     x1_return_upper = _mm_and_si128(x1_return_upper, xMaskLowByte);

  000b2	8b 4b 0c	 mov	 ecx, DWORD PTR _x1_return_upper$[ebx]
  000b5	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  000b8	66 0f db 45 d0	 pand	 xmm0, XMMWORD PTR _xMaskLowByte$[ebp]
  000bd	0f 29 85 50 ff
	ff ff		 movaps	 XMMWORD PTR $T3[ebp], xmm0
  000c4	8b 53 0c	 mov	 edx, DWORD PTR _x1_return_upper$[ebx]
  000c7	0f 10 85 50 ff
	ff ff		 movups	 xmm0, XMMWORD PTR $T3[ebp]
  000ce	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 154  : 
; 155  :     x0_return_lower = _mm_packus_epi16(x0_return_lower, x1_return_upper);

  000d1	8b 43 0c	 mov	 eax, DWORD PTR _x1_return_upper$[ebx]
  000d4	8b 4b 08	 mov	 ecx, DWORD PTR _x0_return_lower$[ebx]
  000d7	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  000da	66 0f 67 00	 packuswb xmm0, XMMWORD PTR [eax]
  000de	0f 29 85 40 ff
	ff ff		 movaps	 XMMWORD PTR $T2[ebp], xmm0
  000e5	8b 53 08	 mov	 edx, DWORD PTR _x0_return_lower$[ebx]
  000e8	0f 10 85 40 ff
	ff ff		 movups	 xmm0, XMMWORD PTR $T2[ebp]
  000ef	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 156  :     x1_return_upper = _mm_packus_epi16(x4, x5);

  000f2	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x4$[ebp]
  000f6	66 0f 67 45 e0	 packuswb xmm0, XMMWORD PTR _x5$[ebp]
  000fb	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR $T1[ebp], xmm0
  00102	8b 43 0c	 mov	 eax, DWORD PTR _x1_return_upper$[ebx]
  00105	0f 10 85 30 ff
	ff ff		 movups	 xmm0, XMMWORD PTR $T1[ebp]
  0010c	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 157  : }

  0010f	5f		 pop	 edi
  00110	8b e5		 mov	 esp, ebp
  00112	5d		 pop	 ebp
  00113	8b e3		 mov	 esp, ebx
  00115	5b		 pop	 ebx
  00116	c3		 ret	 0
?separate_low_up@@YAXAAT__m128i@@0@Z ENDP		; separate_low_up
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -144						; size = 16
$T2 = -128						; size = 16
$T3 = -112						; size = 16
$T4 = -96						; size = 16
$T5 = -80						; size = 16
$T6 = -64						; size = 16
$T7 = -48						; size = 16
_b$ = -32						; size = 16
_a$ = -16						; size = 16
?_mm_packus_epi32_simd@@YA?AT__m128i@@T1@0@Z PROC	; _mm_packus_epi32_simd
; _a$ = xmm0
; _b$ = xmm1

; 98   : static __forceinline __m128i _mm_packus_epi32_simd(__m128i a, __m128i b) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 90 00 00
	00		 sub	 esp, 144		; 00000090H
  0001c	57		 push	 edi
  0001d	8d bd 70 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-144]
  00023	b9 24 00 00 00	 mov	 ecx, 36			; 00000024H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	0f 29 4d e0	 movaps	 XMMWORD PTR _b$[ebp], xmm1
  00033	0f 29 45 f0	 movaps	 XMMWORD PTR _a$[ebp], xmm0

; 99   : #if USE_SSE41
; 100  :     return _mm_packus_epi32(a, b);
; 101  : #else
; 102  :     alignas(64) static const uint32_t VAL[2][4] = {
; 103  :         { 0x00008000, 0x00008000, 0x00008000, 0x00008000 },
; 104  :         { 0x80008000, 0x80008000, 0x80008000, 0x80008000 }
; 105  :     };
; 106  : #define LOAD_32BIT_0x8000 _mm_load_si128((__m128i *)VAL[0])
; 107  : #define LOAD_16BIT_0x8000 _mm_load_si128((__m128i *)VAL[1])
; 108  :     a = _mm_sub_epi32(a, LOAD_32BIT_0x8000);

  00037	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0003c	6b c8 00	 imul	 ecx, eax, 0
  0003f	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?VAL@?1??_mm_packus_epi32_simd@@YA?AT__m128i@@T2@0@Z@4QAY03$$CBIA
  00045	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00048	0f 29 45 d0	 movaps	 XMMWORD PTR $T7[ebp], xmm0
  0004c	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _a$[ebp]
  00050	66 0f fa 45 d0	 psubd	 xmm0, XMMWORD PTR $T7[ebp]
  00055	0f 29 45 c0	 movaps	 XMMWORD PTR $T6[ebp], xmm0
  00059	0f 28 45 c0	 movaps	 xmm0, XMMWORD PTR $T6[ebp]
  0005d	0f 29 45 f0	 movaps	 XMMWORD PTR _a$[ebp], xmm0

; 109  :     b = _mm_sub_epi32(b, LOAD_32BIT_0x8000);

  00061	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00066	6b c2 00	 imul	 eax, edx, 0
  00069	05 00 00 00 00	 add	 eax, OFFSET ?VAL@?1??_mm_packus_epi32_simd@@YA?AT__m128i@@T2@0@Z@4QAY03$$CBIA
  0006e	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00071	0f 29 45 b0	 movaps	 XMMWORD PTR $T5[ebp], xmm0
  00075	0f 28 45 e0	 movaps	 xmm0, XMMWORD PTR _b$[ebp]
  00079	66 0f fa 45 b0	 psubd	 xmm0, XMMWORD PTR $T5[ebp]
  0007e	0f 29 45 a0	 movaps	 XMMWORD PTR $T4[ebp], xmm0
  00082	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR $T4[ebp]
  00086	0f 29 45 e0	 movaps	 XMMWORD PTR _b$[ebp], xmm0

; 110  :     a = _mm_packs_epi32(a, b);

  0008a	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _a$[ebp]
  0008e	66 0f 6b 45 e0	 packssdw xmm0, XMMWORD PTR _b$[ebp]
  00093	0f 29 45 90	 movaps	 XMMWORD PTR $T3[ebp], xmm0
  00097	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR $T3[ebp]
  0009b	0f 29 45 f0	 movaps	 XMMWORD PTR _a$[ebp], xmm0

; 111  :     return _mm_add_epi16(a, LOAD_16BIT_0x8000);

  0009f	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  000a4	c1 e1 00	 shl	 ecx, 0
  000a7	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?VAL@?1??_mm_packus_epi32_simd@@YA?AT__m128i@@T2@0@Z@4QAY03$$CBIA
  000ad	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  000b0	0f 29 45 80	 movaps	 XMMWORD PTR $T2[ebp], xmm0
  000b4	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _a$[ebp]
  000b8	66 0f fd 45 80	 paddw	 xmm0, XMMWORD PTR $T2[ebp]
  000bd	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR $T1[ebp], xmm0
  000c4	0f 28 85 70 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T1[ebp]

; 112  : #undef LOAD_32BIT_0x8000
; 113  : #undef LOAD_16BIT_0x8000
; 114  : #endif
; 115  : }

  000cb	5f		 pop	 edi
  000cc	8b e5		 mov	 esp, ebp
  000ce	5d		 pop	 ebp
  000cf	8b e3		 mov	 esp, ebx
  000d1	5b		 pop	 ebx
  000d2	c3		 ret	 0
?_mm_packus_epi32_simd@@YA?AT__m128i@@T1@0@Z ENDP	; _mm_packus_epi32_simd
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -96						; size = 16
$T2 = -80						; size = 16
$T3 = -64						; size = 16
_mask$ = -48						; size = 16
_b$ = -32						; size = 16
_a$ = -16						; size = 16
?select_by_mask@@YA?AT__m128i@@T1@00@Z PROC		; select_by_mask
; _a$ = xmm0
; _b$ = xmm1
; _mask$ = xmm2

; 90   : static __forceinline __m128i select_by_mask(__m128i a, __m128i b, __m128i mask) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	83 ec 60	 sub	 esp, 96			; 00000060H
  00019	57		 push	 edi
  0001a	8d 7d a0	 lea	 edi, DWORD PTR [ebp-96]
  0001d	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  00022	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00027	f3 ab		 rep stosd
  00029	0f 29 55 d0	 movaps	 XMMWORD PTR _mask$[ebp], xmm2
  0002d	0f 29 4d e0	 movaps	 XMMWORD PTR _b$[ebp], xmm1
  00031	0f 29 45 f0	 movaps	 XMMWORD PTR _a$[ebp], xmm0

; 91   : #if USE_SSE41
; 92   :     return _mm_blendv_epi8(a, b, mask);
; 93   : #else
; 94   :     return _mm_or_si128( _mm_andnot_si128(mask,a), _mm_and_si128(b,mask) );

  00035	0f 28 45 e0	 movaps	 xmm0, XMMWORD PTR _b$[ebp]
  00039	66 0f db 45 d0	 pand	 xmm0, XMMWORD PTR _mask$[ebp]
  0003e	0f 29 45 b0	 movaps	 XMMWORD PTR $T2[ebp], xmm0
  00042	0f 28 45 d0	 movaps	 xmm0, XMMWORD PTR _mask$[ebp]
  00046	66 0f df 45 f0	 pandn	 xmm0, XMMWORD PTR _a$[ebp]
  0004b	0f 29 45 c0	 movaps	 XMMWORD PTR $T3[ebp], xmm0
  0004f	0f 28 45 c0	 movaps	 xmm0, XMMWORD PTR $T3[ebp]
  00053	66 0f eb 45 b0	 por	 xmm0, XMMWORD PTR $T2[ebp]
  00058	0f 29 45 a0	 movaps	 XMMWORD PTR $T1[ebp], xmm0
  0005c	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR $T1[ebp]

; 95   : #endif
; 96   : }

  00060	5f		 pop	 edi
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	8b e3		 mov	 esp, ebx
  00066	5b		 pop	 ebx
  00067	c3		 ret	 0
?select_by_mask@@YA?AT__m128i@@T1@00@Z ENDP		; select_by_mask
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -256						; size = 16
$T2 = -240						; size = 16
$T3 = -224						; size = 16
$T4 = -208						; size = 16
_dst_tmp$ = -180					; size = 4
$T5 = -176						; size = 16
$T6 = -160						; size = 16
$T7 = -144						; size = 16
$T8 = -128						; size = 16
$T9 = -112						; size = 16
_start_align_diff$ = -84				; size = 4
_x3$ = -80						; size = 16
_x2$ = -64						; size = 16
_x1$ = -48						; size = 16
_x0$ = -32						; size = 16
_dst_aligned_fin$ = -12					; size = 4
_dst_fin$ = -8						; size = 4
_i$10 = -4						; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_size$ = 16						; size = 4
?memcpy_sse@@YAXPAEPBEH@Z PROC				; memcpy_sse

; 44   : static void __forceinline memcpy_sse(uint8_t *dst, const uint8_t *src, int size) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 00 01 00
	00		 sub	 esp, 256		; 00000100H
  0001c	57		 push	 edi
  0001d	8d bd 00 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-256]
  00023	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd

; 45   :     if (size < 64) {

  0002f	83 7b 10 40	 cmp	 DWORD PTR _size$[ebx], 64 ; 00000040H
  00033	7d 31		 jge	 SHORT $LN8@memcpy_sse

; 46   :         for (int i = 0; i < size; i++)

  00035	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$10[ebp], 0
  0003c	eb 09		 jmp	 SHORT $LN4@memcpy_sse
$LN2@memcpy_sse:
  0003e	8b 45 fc	 mov	 eax, DWORD PTR _i$10[ebp]
  00041	83 c0 01	 add	 eax, 1
  00044	89 45 fc	 mov	 DWORD PTR _i$10[ebp], eax
$LN4@memcpy_sse:
  00047	8b 4d fc	 mov	 ecx, DWORD PTR _i$10[ebp]
  0004a	3b 4b 10	 cmp	 ecx, DWORD PTR _size$[ebx]
  0004d	7d 12		 jge	 SHORT $LN3@memcpy_sse

; 47   :             dst[i] = src[i];

  0004f	8b 53 08	 mov	 edx, DWORD PTR _dst$[ebx]
  00052	03 55 fc	 add	 edx, DWORD PTR _i$10[ebp]
  00055	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  00058	03 45 fc	 add	 eax, DWORD PTR _i$10[ebp]
  0005b	8a 08		 mov	 cl, BYTE PTR [eax]
  0005d	88 0a		 mov	 BYTE PTR [edx], cl
  0005f	eb dd		 jmp	 SHORT $LN2@memcpy_sse
$LN3@memcpy_sse:

; 48   :         return;

  00061	e9 d7 01 00 00	 jmp	 $LN1@memcpy_sse
$LN8@memcpy_sse:

; 49   :     }
; 50   :     uint8_t *dst_fin = dst + size;

  00066	8b 53 08	 mov	 edx, DWORD PTR _dst$[ebx]
  00069	03 53 10	 add	 edx, DWORD PTR _size$[ebx]
  0006c	89 55 f8	 mov	 DWORD PTR _dst_fin$[ebp], edx

; 51   :     uint8_t *dst_aligned_fin = (uint8_t *)(((size_t)(dst_fin + 15) & ~15) - 64);

  0006f	8b 45 f8	 mov	 eax, DWORD PTR _dst_fin$[ebp]
  00072	83 c0 0f	 add	 eax, 15			; 0000000fH
  00075	83 e0 f0	 and	 eax, -16		; fffffff0H
  00078	83 e8 40	 sub	 eax, 64			; 00000040H
  0007b	89 45 f4	 mov	 DWORD PTR _dst_aligned_fin$[ebp], eax

; 52   :     __m128 x0, x1, x2, x3;
; 53   :     const int start_align_diff = (int)((size_t)dst & 15);

  0007e	8b 4b 08	 mov	 ecx, DWORD PTR _dst$[ebx]
  00081	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00084	89 4d ac	 mov	 DWORD PTR _start_align_diff$[ebp], ecx

; 54   :     if (start_align_diff) {

  00087	74 38		 je	 SHORT $LN9@memcpy_sse

; 55   :         x0 = _mm_loadu_ps((float*)src);

  00089	8b 53 0c	 mov	 edx, DWORD PTR _src$[ebx]
  0008c	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  0008f	0f 29 45 90	 movaps	 XMMWORD PTR $T9[ebp], xmm0
  00093	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR $T9[ebp]
  00097	0f 29 45 e0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 56   :         _mm_storeu_ps((float*)dst, x0);

  0009b	0f 10 45 e0	 movups	 xmm0, XMMWORD PTR _x0$[ebp]
  0009f	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  000a2	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 57   :         dst += 16 - start_align_diff;

  000a5	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  000aa	2b 4d ac	 sub	 ecx, DWORD PTR _start_align_diff$[ebp]
  000ad	03 4b 08	 add	 ecx, DWORD PTR _dst$[ebx]
  000b0	89 4b 08	 mov	 DWORD PTR _dst$[ebx], ecx

; 58   :         src += 16 - start_align_diff;

  000b3	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  000b8	2b 55 ac	 sub	 edx, DWORD PTR _start_align_diff$[ebp]
  000bb	03 53 0c	 add	 edx, DWORD PTR _src$[ebx]
  000be	89 53 0c	 mov	 DWORD PTR _src$[ebx], edx
$LN9@memcpy_sse:

; 59   :     }
; 60   :     for ( ; dst < dst_aligned_fin; dst += 64, src += 64) {

  000c1	eb 12		 jmp	 SHORT $LN7@memcpy_sse
$LN5@memcpy_sse:
  000c3	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  000c6	83 c0 40	 add	 eax, 64			; 00000040H
  000c9	89 43 08	 mov	 DWORD PTR _dst$[ebx], eax
  000cc	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  000cf	83 c1 40	 add	 ecx, 64			; 00000040H
  000d2	89 4b 0c	 mov	 DWORD PTR _src$[ebx], ecx
$LN7@memcpy_sse:
  000d5	8b 53 08	 mov	 edx, DWORD PTR _dst$[ebx]
  000d8	3b 55 f4	 cmp	 edx, DWORD PTR _dst_aligned_fin$[ebp]
  000db	0f 83 99 00 00
	00		 jae	 $LN6@memcpy_sse

; 61   :         x0 = _mm_loadu_ps((float*)(src +  0));

  000e1	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  000e4	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  000e7	0f 29 45 80	 movaps	 XMMWORD PTR $T8[ebp], xmm0
  000eb	0f 28 45 80	 movaps	 xmm0, XMMWORD PTR $T8[ebp]
  000ef	0f 29 45 e0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 62   :         x1 = _mm_loadu_ps((float*)(src + 16));

  000f3	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  000f6	83 c1 10	 add	 ecx, 16			; 00000010H
  000f9	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  000fc	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR $T7[ebp], xmm0
  00103	0f 28 85 70 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T7[ebp]
  0010a	0f 29 45 d0	 movaps	 XMMWORD PTR _x1$[ebp], xmm0

; 63   :         x2 = _mm_loadu_ps((float*)(src + 32));

  0010e	8b 53 0c	 mov	 edx, DWORD PTR _src$[ebx]
  00111	83 c2 20	 add	 edx, 32			; 00000020H
  00114	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  00117	0f 29 85 60 ff
	ff ff		 movaps	 XMMWORD PTR $T6[ebp], xmm0
  0011e	0f 28 85 60 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T6[ebp]
  00125	0f 29 45 c0	 movaps	 XMMWORD PTR _x2$[ebp], xmm0

; 64   :         x3 = _mm_loadu_ps((float*)(src + 48));

  00129	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  0012c	83 c0 30	 add	 eax, 48			; 00000030H
  0012f	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00132	0f 29 85 50 ff
	ff ff		 movaps	 XMMWORD PTR $T5[ebp], xmm0
  00139	0f 28 85 50 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T5[ebp]
  00140	0f 29 45 b0	 movaps	 XMMWORD PTR _x3$[ebp], xmm0

; 65   :         _mm_store_ps((float*)(dst +  0), x0);

  00144	0f 28 45 e0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  00148	8b 4b 08	 mov	 ecx, DWORD PTR _dst$[ebx]
  0014b	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 66   :         _mm_store_ps((float*)(dst + 16), x1);

  0014e	0f 28 45 d0	 movaps	 xmm0, XMMWORD PTR _x1$[ebp]
  00152	8b 53 08	 mov	 edx, DWORD PTR _dst$[ebx]
  00155	83 c2 10	 add	 edx, 16			; 00000010H
  00158	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 67   :         _mm_store_ps((float*)(dst + 32), x2);

  0015b	0f 28 45 c0	 movaps	 xmm0, XMMWORD PTR _x2$[ebp]
  0015f	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  00162	83 c0 20	 add	 eax, 32			; 00000020H
  00165	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 68   :         _mm_store_ps((float*)(dst + 48), x3);

  00168	0f 28 45 b0	 movaps	 xmm0, XMMWORD PTR _x3$[ebp]
  0016c	8b 4b 08	 mov	 ecx, DWORD PTR _dst$[ebx]
  0016f	83 c1 30	 add	 ecx, 48			; 00000030H
  00172	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 69   :     }

  00175	e9 49 ff ff ff	 jmp	 $LN5@memcpy_sse
$LN6@memcpy_sse:

; 70   :     uint8_t *dst_tmp = dst_fin - 64;

  0017a	8b 55 f8	 mov	 edx, DWORD PTR _dst_fin$[ebp]
  0017d	83 ea 40	 sub	 edx, 64			; 00000040H
  00180	89 95 4c ff ff
	ff		 mov	 DWORD PTR _dst_tmp$[ebp], edx

; 71   :     src -= (dst - dst_tmp);

  00186	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  00189	2b 85 4c ff ff
	ff		 sub	 eax, DWORD PTR _dst_tmp$[ebp]
  0018f	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  00192	2b c8		 sub	 ecx, eax
  00194	89 4b 0c	 mov	 DWORD PTR _src$[ebx], ecx

; 72   :     x0 = _mm_loadu_ps((float*)(src +  0));

  00197	8b 53 0c	 mov	 edx, DWORD PTR _src$[ebx]
  0019a	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  0019d	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR $T4[ebp], xmm0
  001a4	0f 28 85 30 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T4[ebp]
  001ab	0f 29 45 e0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 73   :     x1 = _mm_loadu_ps((float*)(src + 16));

  001af	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  001b2	83 c0 10	 add	 eax, 16			; 00000010H
  001b5	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  001b8	0f 29 85 20 ff
	ff ff		 movaps	 XMMWORD PTR $T3[ebp], xmm0
  001bf	0f 28 85 20 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T3[ebp]
  001c6	0f 29 45 d0	 movaps	 XMMWORD PTR _x1$[ebp], xmm0

; 74   :     x2 = _mm_loadu_ps((float*)(src + 32));

  001ca	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  001cd	83 c1 20	 add	 ecx, 32			; 00000020H
  001d0	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  001d3	0f 29 85 10 ff
	ff ff		 movaps	 XMMWORD PTR $T2[ebp], xmm0
  001da	0f 28 85 10 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T2[ebp]
  001e1	0f 29 45 c0	 movaps	 XMMWORD PTR _x2$[ebp], xmm0

; 75   :     x3 = _mm_loadu_ps((float*)(src + 48));

  001e5	8b 53 0c	 mov	 edx, DWORD PTR _src$[ebx]
  001e8	83 c2 30	 add	 edx, 48			; 00000030H
  001eb	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  001ee	0f 29 85 00 ff
	ff ff		 movaps	 XMMWORD PTR $T1[ebp], xmm0
  001f5	0f 28 85 00 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T1[ebp]
  001fc	0f 29 45 b0	 movaps	 XMMWORD PTR _x3$[ebp], xmm0

; 76   :     _mm_storeu_ps((float*)(dst_tmp +  0), x0);

  00200	0f 10 45 e0	 movups	 xmm0, XMMWORD PTR _x0$[ebp]
  00204	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _dst_tmp$[ebp]
  0020a	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 77   :     _mm_storeu_ps((float*)(dst_tmp + 16), x1);

  0020d	0f 10 45 d0	 movups	 xmm0, XMMWORD PTR _x1$[ebp]
  00211	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _dst_tmp$[ebp]
  00217	83 c1 10	 add	 ecx, 16			; 00000010H
  0021a	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 78   :     _mm_storeu_ps((float*)(dst_tmp + 32), x2);

  0021d	0f 10 45 c0	 movups	 xmm0, XMMWORD PTR _x2$[ebp]
  00221	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR _dst_tmp$[ebp]
  00227	83 c2 20	 add	 edx, 32			; 00000020H
  0022a	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 79   :     _mm_storeu_ps((float*)(dst_tmp + 48), x3);

  0022d	0f 10 45 b0	 movups	 xmm0, XMMWORD PTR _x3$[ebp]
  00231	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _dst_tmp$[ebp]
  00237	83 c0 30	 add	 eax, 48			; 00000030H
  0023a	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0
$LN1@memcpy_sse:

; 80   : }

  0023d	5f		 pop	 edi
  0023e	8b e5		 mov	 esp, ebp
  00240	5d		 pop	 ebp
  00241	8b e3		 mov	 esp, ebx
  00243	5b		 pop	 ebx
  00244	c3		 ret	 0
?memcpy_sse@@YAXPAEPBEH@Z ENDP				; memcpy_sse
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.h
_TEXT	SEGMENT
_y1$ = -36						; size = 4
_y0$ = -32						; size = 4
_y_range$ = -24						; size = 12
_h$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
$T1 = 8							; size = 4
_y_start$ = 12						; size = 4
_y_end$ = 16						; size = 4
_thread_id$ = 20					; size = 4
_thread_n$ = 24						; size = 4
?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z PROC	; thread_y_range

; 375  : static inline THREAD_Y_RANGE thread_y_range(int y_start, int y_end, int thread_id, int thread_n) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 dc	 mov	 DWORD PTR [ebp-36], eax
  0000e	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  00011	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  00014	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00017	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0001a	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0001d	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00020	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00023	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002b	33 c5		 xor	 eax, ebp
  0002d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 376  :     const int h = y_end - y_start;

  00030	8b 45 10	 mov	 eax, DWORD PTR _y_end$[ebp]
  00033	2b 45 0c	 sub	 eax, DWORD PTR _y_start$[ebp]
  00036	89 45 f8	 mov	 DWORD PTR _h$[ebp], eax

; 377  :     THREAD_Y_RANGE y_range;
; 378  :     int y0 = ((((h *  thread_id)    / thread_n) + 3) & ~3);

  00039	8b 45 f8	 mov	 eax, DWORD PTR _h$[ebp]
  0003c	0f af 45 14	 imul	 eax, DWORD PTR _thread_id$[ebp]
  00040	99		 cdq
  00041	f7 7d 18	 idiv	 DWORD PTR _thread_n$[ebp]
  00044	83 c0 03	 add	 eax, 3
  00047	83 e0 fc	 and	 eax, -4			; fffffffcH
  0004a	89 45 e0	 mov	 DWORD PTR _y0$[ebp], eax

; 379  :     int y1 = ((((h * (thread_id+1)) / thread_n) + 3) & ~3);

  0004d	8b 4d 14	 mov	 ecx, DWORD PTR _thread_id$[ebp]
  00050	83 c1 01	 add	 ecx, 1
  00053	8b c1		 mov	 eax, ecx
  00055	0f af 45 f8	 imul	 eax, DWORD PTR _h$[ebp]
  00059	99		 cdq
  0005a	f7 7d 18	 idiv	 DWORD PTR _thread_n$[ebp]
  0005d	83 c0 03	 add	 eax, 3
  00060	83 e0 fc	 and	 eax, -4			; fffffffcH
  00063	89 45 dc	 mov	 DWORD PTR _y1$[ebp], eax

; 380  :     if (y1 > h) {

  00066	8b 55 dc	 mov	 edx, DWORD PTR _y1$[ebp]
  00069	3b 55 f8	 cmp	 edx, DWORD PTR _h$[ebp]
  0006c	7e 06		 jle	 SHORT $LN2@thread_y_r

; 381  :         y1 = h;

  0006e	8b 45 f8	 mov	 eax, DWORD PTR _h$[ebp]
  00071	89 45 dc	 mov	 DWORD PTR _y1$[ebp], eax
$LN2@thread_y_r:

; 382  :     }
; 383  :     y_range.start_src = y_start + y0;

  00074	8b 4d 0c	 mov	 ecx, DWORD PTR _y_start$[ebp]
  00077	03 4d e0	 add	 ecx, DWORD PTR _y0$[ebp]
  0007a	89 4d e8	 mov	 DWORD PTR _y_range$[ebp], ecx

; 384  :     y_range.start_dst = y0;

  0007d	8b 55 e0	 mov	 edx, DWORD PTR _y0$[ebp]
  00080	89 55 ec	 mov	 DWORD PTR _y_range$[ebp+4], edx

; 385  :     y_range.len = y1 - y0;

  00083	8b 45 dc	 mov	 eax, DWORD PTR _y1$[ebp]
  00086	2b 45 e0	 sub	 eax, DWORD PTR _y0$[ebp]
  00089	89 45 f0	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 386  :     return y_range;

  0008c	8b 4d 08	 mov	 ecx, DWORD PTR $T1[ebp]
  0008f	8b 55 e8	 mov	 edx, DWORD PTR _y_range$[ebp]
  00092	89 11		 mov	 DWORD PTR [ecx], edx
  00094	8b 45 ec	 mov	 eax, DWORD PTR _y_range$[ebp+4]
  00097	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0009a	8b 55 f0	 mov	 edx, DWORD PTR _y_range$[ebp+8]
  0009d	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  000a0	8b 45 08	 mov	 eax, DWORD PTR $T1[ebp]

; 387  : }

  000a3	52		 push	 edx
  000a4	8b cd		 mov	 ecx, ebp
  000a6	50		 push	 eax
  000a7	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN6@thread_y_r
  000ad	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000b2	58		 pop	 eax
  000b3	5a		 pop	 edx
  000b4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b7	33 cd		 xor	 ecx, ebp
  000b9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000be	8b e5		 mov	 esp, ebp
  000c0	5d		 pop	 ebp
  000c1	c3		 ret	 0
  000c2	66 90		 npad	 2
$LN6@thread_y_r:
  000c4	01 00 00 00	 DD	 1
  000c8	00 00 00 00	 DD	 $LN5@thread_y_r
$LN5@thread_y_r:
  000cc	e8 ff ff ff	 DD	 -24			; ffffffe8H
  000d0	0c 00 00 00	 DD	 12			; 0000000cH
  000d4	00 00 00 00	 DD	 $LN4@thread_y_r
$LN4@thread_y_r:
  000d8	79		 DB	 121			; 00000079H
  000d9	5f		 DB	 95			; 0000005fH
  000da	72		 DB	 114			; 00000072H
  000db	61		 DB	 97			; 00000061H
  000dc	6e		 DB	 110			; 0000006eH
  000dd	67		 DB	 103			; 00000067H
  000de	65		 DB	 101			; 00000065H
  000df	00		 DB	 0
?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ENDP	; thread_y_range
_TEXT	ENDS
END
