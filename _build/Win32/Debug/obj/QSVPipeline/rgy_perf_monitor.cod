; Listing generated by Microsoft (R) Optimizing Compiler Version 19.23.28106.4 

	TITLE	D:\work\intel\intel_codec\QSVPipeline\rgy_perf_monitor.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG114761 DB	'trace', 00H
	ORG $+2
$SG114762 DB	'debug', 00H
	ORG $+2
$SG114763 DB	'more', 00H
	ORG $+3
$SG114764 DB	'info', 00H
	ORG $+3
$SG114765 DB	'warn', 00H
	ORG $+3
$SG114766 DB	'error', 00H
	ORG $+2
$SG114768 DB	'cfr', 00H
$SG114769 DB	'vfr', 00H
$SG114770 DB	'forcecfr', 00H
	ORG $+3
$SG114772 DB	'swr', 00H
$SG114773 DB	'soxr', 00H
	ORG $+3
?list_pref_monitor@@3QBUCX_DESC@@B DD FLAT:$SG115466	; list_pref_monitor
	DD	0ffffffffH
	DD	FLAT:$SG115467
	DD	0cc03H
	DD	FLAT:$SG115468
	DD	01H
	DD	FLAT:$SG115469
	DD	02H
	DD	FLAT:$SG115470
	DD	0400H
	DD	FLAT:$SG115471
	DD	0800H
	DD	FLAT:$SG115472
	DD	08000H
	DD	FLAT:$SG115473
	DD	03000H
	DD	FLAT:$SG115474
	DD	01000H
	DD	FLAT:$SG115475
	DD	02000H
	DD	FLAT:$SG115476
	DD	04000H
	DD	FLAT:$SG115477
	DD	0cH
	DD	FLAT:$SG115478
	DD	04H
	DD	FLAT:$SG115479
	DD	08H
	DD	FLAT:$SG115480
	DD	0300H
	DD	FLAT:$SG115481
	DD	0100H
	DD	FLAT:$SG115482
	DD	0200H
	DD	FLAT:$SG115483
	DD	010H
	DD	FLAT:$SG115484
	DD	020H
	DD	FLAT:$SG115485
	DD	040H
	DD	FLAT:$SG115486
	DD	080H
	DD	FLAT:$SG115487
	DD	020000H
	DD	FLAT:$SG115488
	DD	01e0c0000H
	DD	FLAT:$SG115489
	DD	040000H
	DD	FLAT:$SG115490
	DD	080000H
	DD	FLAT:$SG115491
	DD	04000000H
	DD	FLAT:$SG115492
	DD	04000000H
	DD	FLAT:$SG115493
	DD	010000000H
	DD	FLAT:$SG115494
	DD	02000000H
	DD	FLAT:$SG115495
	DD	0f00000H
	DD	00H
	DD	00H
$SG115466 DB	'all', 00H
$SG115467 DB	'cpu', 00H
$SG115468 DB	'cpu_total', 00H
	ORG $+2
$SG115469 DB	'cpu_kernel', 00H
	ORG $+1
$SG115470 DB	'cpu_main', 00H
	ORG $+3
$SG115471 DB	'cpu_enc', 00H
$SG115472 DB	'cpu_in', 00H
	ORG $+1
$SG115473 DB	'cpu_aud', 00H
$SG115474 DB	'cpu_aud_proc', 00H
	ORG $+3
$SG115475 DB	'cpu_aud_enc', 00H
$SG115476 DB	'cpu_out', 00H
$SG115477 DB	'mem', 00H
$SG115478 DB	'mem_private', 00H
$SG115479 DB	'mem_virtual', 00H
$SG115480 DB	'io', 00H
	ORG $+1
$SG115481 DB	'io_read', 00H
$SG115482 DB	'io_write', 00H
	ORG $+3
$SG115483 DB	'fps', 00H
$SG115484 DB	'fps_avg', 00H
$SG115485 DB	'bitrate', 00H
$SG115486 DB	'bitrate_avg', 00H
$SG115487 DB	'frame_out', 00H
	ORG $+2
$SG115488 DB	'gpu', 00H
$SG115489 DB	'gpu_load', 00H
	ORG $+3
$SG115490 DB	'gpu_clock', 00H
	ORG $+2
$SG115491 DB	'vee_load', 00H
	ORG $+3
$SG115492 DB	'ved_load', 00H
	ORG $+3
$SG115493 DB	'pcie_load', 00H
	ORG $+2
$SG115494 DB	've_clock', 00H
	ORG $+3
$SG115495 DB	'queue', 00H
	ORG $+2
$SG131906 DB	'invalid argument', 00H
	ORG $+3
$SG131907 DB	'%s', 00H
	ORG $+1
$SG118039 DB	',', 00H
	ORG $+2
$SG131908 DB	'C:\Program Files (x86)\Microsoft Visual Studio\2019\Comm'
	DB	'unity\VC\Tools\MSVC\14.23.28105\include\xmemory', 00H
$SG131909 DB	'C', 00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H
	DB	'g', 00H, 'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'F', 00H, 'i'
	DB	00H, 'l', 00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H
	DB	'8', 00H, '6', 00H, ')', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c'
	DB	00H, 'r', 00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H
	DB	' ', 00H, 'V', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l'
	DB	00H, ' ', 00H, 'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H
	DB	'o', 00H, '\', 00H, '2', 00H, '0', 00H, '1', 00H, '9', 00H, '\'
	DB	00H, 'C', 00H, 'o', 00H, 'm', 00H, 'm', 00H, 'u', 00H, 'n', 00H
	DB	'i', 00H, 't', 00H, 'y', 00H, '\', 00H, 'V', 00H, 'C', 00H, '\'
	DB	00H, 'T', 00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '\', 00H
	DB	'M', 00H, 'S', 00H, 'V', 00H, 'C', 00H, '\', 00H, '1', 00H, '4'
	DB	00H, '.', 00H, '2', 00H, '3', 00H, '.', 00H, '2', 00H, '8', 00H
	DB	'1', 00H, '0', 00H, '5', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c'
	DB	00H, 'l', 00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H
	DB	'm', 00H, 'e', 00H, 'm', 00H, 'o', 00H, 'r', 00H, 'y', 00H, 00H
	DB	00H
$SG131910 DB	's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H
	DB	'A', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a', 00H, 't'
	DB	00H, 'e', 00H, '_', 00H, 'm', 00H, 'a', 00H, 'n', 00H, 'u', 00H
	DB	'a', 00H, 'l', 00H, 'l', 00H, 'y', 00H, '_', 00H, 'v', 00H, 'e'
	DB	00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'a', 00H
	DB	'l', 00H, 'i', 00H, 'g', 00H, 'n', 00H, 'e', 00H, 'd', 00H, 00H
	DB	00H
	ORG $+2
$SG131911 DB	'"', 00H, 'i', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H
	DB	'i', 00H, 'd', 00H, ' ', 00H, 'a', 00H, 'r', 00H, 'g', 00H, 'u'
	DB	00H, 'm', 00H, 'e', 00H, 'n', 00H, 't', 00H, '"', 00H, 00H, 00H
	ORG $+2
$SG132058 DB	'C:\Program Files (x86)\Microsoft Visual Studio\2019\Comm'
	DB	'unity\VC\Tools\MSVC\14.23.28105\include\xlocale', 00H
$SG118036 DB	'none', 00H
	ORG $+3
$SG118157 DB	0aH, 0aH, 00H
	ORG $+1
$SG118171 DB	'QSVEnc.auo', 00H
	ORG $+1
$SG118175 DB	'PERF_MONITOR_SRC', 00H
	ORG $+3
$SG118176 DB	'PERF_MONITOR_PYW', 00H
	ORG $+3
$SG118180 DB	'wb', 00H
	ORG $+1
$SG118192 DB	',cpu (%)', 00H
	ORG $+3
$SG118194 DB	',cpu kernel (%)', 00H
$SG118196 DB	',cpu main thread (%)', 00H
	ORG $+3
$SG118198 DB	',cpu enc thread (%)', 00H
$SG118200 DB	',cpu aud proc thread (%)', 00H
	ORG $+3
$SG118202 DB	',cpu aud enc thread (%)', 00H
$SG118204 DB	',cpu in thread (%)', 00H
	ORG $+1
$SG118206 DB	',cpu out thread (%)', 00H
$SG118208 DB	',gpu load (%)', 00H
	ORG $+2
$SG118210 DB	',gpu clock (MHz)', 00H
	ORG $+3
$SG118212 DB	',mfx load (%)', 00H
	ORG $+2
$SG118214 DB	',video encoder load (%)', 00H
$SG118216 DB	',video decoder load (%)', 00H
$SG118218 DB	',video engine clock (MHz)', 00H
	ORG $+2
$SG118220 DB	',pcie link,pcie tx, pci rx', 00H
	ORG $+1
$SG118222 DB	',queue vid in', 00H
	ORG $+2
$SG118224 DB	',queue aud in', 00H
	ORG $+2
$SG118226 DB	',queue vid out', 00H
	ORG $+1
$SG118228 DB	',queue aud out', 00H
	ORG $+1
$SG118230 DB	',mem private (MB)', 00H
	ORG $+2
$SG118232 DB	',mem virtual (MB)', 00H
	ORG $+2
$SG118234 DB	',frame in', 00H
	ORG $+2
$SG118236 DB	',frame out', 00H
	ORG $+1
$SG118238 DB	',enc speed (fps)', 00H
	ORG $+3
$SG118240 DB	',enc speed avg (fps)', 00H
	ORG $+3
$SG118242 DB	',bitrate (kbps)', 00H
$SG118244 DB	',bitrate avg (kbps)', 00H
$SG118246 DB	',read (MB/s)', 00H
	ORG $+3
$SG118248 DB	',write (MB/s)', 00H
	ORG $+2
$SG118249 DB	0aH, 00H
	ORG $+2
$SG118976 DB	'a', 00H
	ORG $+2
$SG118978 DB	'Failed to open performance monitor log file: %s', 0aH, 00H
	ORG $+3
$SG118979 DB	'performance monitoring disabled.', 0aH, 00H
	ORG $+2
$SG118983 DB	'qsvencc_perf_monitor_%d.pyw', 00H
$SG118984 DB	'python', 00H
	ORG $+1
$SG118985 DB	'"', 00H
	ORG $+2
$SG118986 DB	'"', 00H
	ORG $+2
$SG118987 DB	'"', 00H
	ORG $+2
$SG118988 DB	'"', 00H
	ORG $+2
$SG118991 DB	'Failed to create file qsvencc_perf_monitor.pyw for perfo'
	DB	'rmance monitor plot.', 0aH, 00H
	ORG $+2
$SG118992 DB	'performance monitor plot disabled.', 0aH, 00H
$SG118993 DB	'%d', 00H
	ORG $+1
$SG118994 DB	'-i', 00H
	ORG $+1
$SG118997 DB	'Failed to run performance monitor plot.', 0aH, 00H
	ORG $+3
$SG118998 DB	'performance monitor plot disabled.', 0aH, 00H
$SG118999 DB	'Performace Monitor: %s', 0aH, 00H
$SG119000 DB	'Performace Plot   : %s', 0aH, 00H
$SG119208 DB	'%lf', 00H
$SG119210 DB	',%lf', 00H
	ORG $+3
$SG119212 DB	',%lf', 00H
	ORG $+3
$SG119214 DB	',%lf', 00H
	ORG $+3
$SG119216 DB	',%lf', 00H
	ORG $+3
$SG119218 DB	',%lf', 00H
	ORG $+3
$SG119220 DB	',%lf', 00H
	ORG $+3
$SG119222 DB	',%lf', 00H
	ORG $+3
$SG119224 DB	',%lf', 00H
	ORG $+3
$SG119226 DB	',%lf', 00H
	ORG $+3
$SG119228 DB	',%lf', 00H
	ORG $+3
$SG119230 DB	',%lf', 00H
	ORG $+3
$SG119232 DB	',%lf', 00H
	ORG $+3
$SG119234 DB	',%lf', 00H
	ORG $+3
$SG119236 DB	',%lf', 00H
	ORG $+3
$SG119238 DB	',PCIe %dx%d', 00H
$SG119239 DB	',%lf', 00H
	ORG $+3
$SG119240 DB	',%lf', 00H
	ORG $+3
$SG119242 DB	',%d', 00H
$SG119244 DB	',%d', 00H
$SG119246 DB	',%d', 00H
$SG119248 DB	',%d', 00H
$SG119250 DB	',%.2lf', 00H
	ORG $+1
$SG119252 DB	',%.2lf', 00H
	ORG $+1
$SG119254 DB	',%d', 00H
$SG119256 DB	',%d', 00H
$SG119258 DB	',%lf', 00H
	ORG $+3
$SG119260 DB	',%lf', 00H
	ORG $+3
$SG119262 DB	',%lf', 00H
	ORG $+3
$SG119264 DB	',%lf', 00H
	ORG $+3
$SG119266 DB	',%lf', 00H
	ORG $+3
$SG119268 DB	',%lf', 00H
	ORG $+3
$SG119269 DB	0aH, 00H
	ORG $+2
$SG119290 DB	'Error occured running python for perf-monitor-plot.', 0aH
	DB	00H
	ORG $+3
$SG111756 DB	'Invalid', 00H
$SG111757 DB	'nv12', 00H
	ORG $+3
$SG111758 DB	'yv12', 00H
	ORG $+3
$SG111759 DB	'yuy2', 00H
	ORG $+3
$SG111760 DB	'yuv422', 00H
	ORG $+1
$SG111761 DB	'nv16', 00H
	ORG $+3
$SG111762 DB	'yuv444', 00H
	ORG $+1
$SG111763 DB	'yv12(9bit)', 00H
	ORG $+1
$SG111764 DB	'yv12(10bit)', 00H
$SG111765 DB	'yv12(12bit)', 00H
$SG111766 DB	'yv12(14bit)', 00H
$SG111767 DB	'yv12(16bit)', 00H
$SG111768 DB	'p010', 00H
	ORG $+3
$SG111769 DB	'yuv422(9bit)', 00H
	ORG $+3
$SG111770 DB	'yuv422(10bit)', 00H
	ORG $+2
$SG111771 DB	'yuv422(12bit)', 00H
	ORG $+2
$SG111772 DB	'yuv422(14bit)', 00H
	ORG $+2
$SG111773 DB	'yuv422(16bit)', 00H
	ORG $+2
$SG111774 DB	'p210', 00H
	ORG $+3
$SG111775 DB	'yuv444(9bit)', 00H
	ORG $+3
$SG111776 DB	'yuv444(10bit)', 00H
	ORG $+2
$SG111777 DB	'yuv444(12bit)', 00H
	ORG $+2
$SG111778 DB	'yuv444(14bit)', 00H
	ORG $+2
$SG111779 DB	'yuv444(16bit)', 00H
	ORG $+2
$SG111780 DB	'yuva444', 00H
$SG111781 DB	'yuva444(16bit)', 00H
	ORG $+1
$SG111782 DB	'rgb24r', 00H
	ORG $+1
$SG111783 DB	'rgb32r', 00H
	ORG $+1
$SG111784 DB	'rgb24', 00H
	ORG $+2
$SG111785 DB	'rgb32', 00H
	ORG $+2
$SG111786 DB	'bgr24', 00H
	ORG $+2
$SG111787 DB	'bgr32', 00H
	ORG $+2
$SG111788 DB	'rgb', 00H
$SG111789 DB	'rgba', 00H
	ORG $+3
$SG111790 DB	'gbr', 00H
$SG111791 DB	'gbra', 00H
	ORG $+3
$SG111792 DB	'yc48', 00H
	ORG $+3
$SG111793 DB	'y8', 00H
	ORG $+1
$SG111794 DB	'yc16', 00H
	ORG $+3
$SG112726 DB	'H.264/AVC', 00H
	ORG $+2
$SG112728 DB	'H.265/HEVC', 00H
	ORG $+1
$SG112730 DB	'MPEG2', 00H
	ORG $+2
$SG112732 DB	'MPEG1', 00H
	ORG $+2
$SG112734 DB	'VC-1', 00H
	ORG $+3
$SG112736 DB	'MPEG4', 00H
	ORG $+2
$SG112738 DB	'VP8', 00H
$SG112740 DB	'VP9', 00H
$SG112742 DB	'unknown', 00H
$SG112849 DB	'unknown', 00H
?list_colormatrix@@3QBUCX_DESC@@B DD FLAT:$SG113344	; list_colormatrix
	DD	02H
	DD	FLAT:$SG113345
	DD	07fffffffH
	DD	FLAT:$SG113346
	DD	01H
	DD	FLAT:$SG113347
	DD	06H
	DD	FLAT:$SG113348
	DD	05H
	DD	FLAT:$SG113349
	DD	07H
	DD	FLAT:$SG113350
	DD	08H
	DD	FLAT:$SG113351
	DD	04H
	DD	FLAT:$SG113352
	DD	00H
	DD	FLAT:$SG113353
	DD	09H
	DD	FLAT:$SG113354
	DD	0aH
	DD	FLAT:$SG113355
	DD	0cH
	DD	FLAT:$SG113356
	DD	0dH
	DD	FLAT:$SG113357
	DD	0eH
	DD	FLAT:$SG113358
	DD	0fH
	DD	00H
	DD	00H
$SG113344 DB	'undef', 00H
	ORG $+2
$SG113345 DB	'auto', 00H
	ORG $+3
$SG113346 DB	'bt709', 00H
	ORG $+2
$SG113347 DB	'smpte170m', 00H
	ORG $+2
$SG113348 DB	'bt470bg', 00H
$SG113349 DB	'smpte240m', 00H
	ORG $+2
$SG113350 DB	'YCgCo', 00H
	ORG $+2
$SG113351 DB	'fcc', 00H
$SG113352 DB	'GBR', 00H
$SG113353 DB	'bt2020nc', 00H
	ORG $+3
$SG113354 DB	'bt2020c', 00H
$SG113355 DB	'derived-ncl', 00H
$SG113356 DB	'derived-cl', 00H
	ORG $+1
$SG113357 DB	'ictco', 00H
	ORG $+2
$SG113358 DB	'2100-lms', 00H
	ORG $+3
?list_transfer@@3QBUCX_DESC@@B DD FLAT:$SG113499	; list_transfer
	DD	02H
	DD	FLAT:$SG113500
	DD	07fffffffH
	DD	FLAT:$SG113501
	DD	01H
	DD	FLAT:$SG113502
	DD	06H
	DD	FLAT:$SG113503
	DD	04H
	DD	FLAT:$SG113504
	DD	05H
	DD	FLAT:$SG113505
	DD	07H
	DD	FLAT:$SG113506
	DD	08H
	DD	FLAT:$SG113507
	DD	09H
	DD	FLAT:$SG113508
	DD	0aH
	DD	FLAT:$SG113509
	DD	0bH
	DD	FLAT:$SG113510
	DD	0cH
	DD	FLAT:$SG113511
	DD	0dH
	DD	FLAT:$SG113512
	DD	0eH
	DD	FLAT:$SG113513
	DD	0fH
	DD	FLAT:$SG113514
	DD	010H
	DD	FLAT:$SG113515
	DD	011H
	DD	FLAT:$SG113516
	DD	012H
	DD	00H
	DD	00H
$SG113499 DB	'undef', 00H
	ORG $+2
$SG113500 DB	'auto', 00H
	ORG $+3
$SG113501 DB	'bt709', 00H
	ORG $+2
$SG113502 DB	'smpte170m', 00H
	ORG $+2
$SG113503 DB	'bt470m', 00H
	ORG $+1
$SG113504 DB	'bt470bg', 00H
$SG113505 DB	'smpte240m', 00H
	ORG $+2
$SG113506 DB	'linear', 00H
	ORG $+1
$SG113507 DB	'log100', 00H
	ORG $+1
$SG113508 DB	'log316', 00H
	ORG $+1
$SG113509 DB	'iec61966-2-4', 00H
	ORG $+3
$SG113510 DB	'bt1361e', 00H
$SG113511 DB	'iec61966-2-1', 00H
	ORG $+3
$SG113512 DB	'bt2020-10', 00H
	ORG $+2
$SG113513 DB	'bt2020-12', 00H
	ORG $+2
$SG113514 DB	'smpte2084', 00H
	ORG $+2
$SG113515 DB	'smpte428', 00H
	ORG $+3
$SG113516 DB	'arib-srd-b67', 00H
	ORG $+3
?list_colorprim@@3QBUCX_DESC@@B DD FLAT:$SG113648	; list_colorprim
	DD	02H
	DD	FLAT:$SG113649
	DD	07fffffffH
	DD	FLAT:$SG113650
	DD	01H
	DD	FLAT:$SG113651
	DD	06H
	DD	FLAT:$SG113652
	DD	04H
	DD	FLAT:$SG113653
	DD	05H
	DD	FLAT:$SG113654
	DD	07H
	DD	FLAT:$SG113655
	DD	08H
	DD	FLAT:$SG113656
	DD	09H
	DD	FLAT:$SG113657
	DD	0aH
	DD	FLAT:$SG113658
	DD	0bH
	DD	FLAT:$SG113659
	DD	0cH
	DD	FLAT:$SG113660
	DD	0dH
	DD	00H
	DD	00H
$SG113648 DB	'undef', 00H
	ORG $+2
$SG113649 DB	'auto', 00H
	ORG $+3
$SG113650 DB	'bt709', 00H
	ORG $+2
$SG113651 DB	'smpte170m', 00H
	ORG $+2
$SG113652 DB	'bt470m', 00H
	ORG $+1
$SG113653 DB	'bt470bg', 00H
$SG113654 DB	'smpte240m', 00H
	ORG $+2
$SG113655 DB	'film', 00H
	ORG $+3
$SG113656 DB	'bt2020', 00H
	ORG $+1
$SG113657 DB	'st428', 00H
	ORG $+2
$SG113658 DB	'st431-2', 00H
$SG113659 DB	'st432-1', 00H
$SG113660 DB	'ebu3213-e', 00H
	ORG $+2
?list_videoformat@@3QBUCX_DESC@@B DD FLAT:$SG113662	; list_videoformat
	DD	05H
	DD	FLAT:$SG113663
	DD	02H
	DD	FLAT:$SG113664
	DD	00H
	DD	FLAT:$SG113665
	DD	01H
	DD	FLAT:$SG113666
	DD	03H
	DD	FLAT:$SG113667
	DD	04H
	DD	00H
	DD	00H
$SG113662 DB	'undef', 00H
	ORG $+2
$SG113663 DB	'ntsc', 00H
	ORG $+3
$SG113664 DB	'component', 00H
	ORG $+2
$SG113665 DB	'pal', 00H
$SG113666 DB	'secam', 00H
	ORG $+2
$SG113667 DB	'mac', 00H
$SG113669 DB	'0', 00H
	ORG $+2
$SG113670 DB	'1', 00H
	ORG $+2
$SG113671 DB	'2', 00H
	ORG $+2
$SG113672 DB	'3', 00H
	ORG $+2
$SG113673 DB	'4', 00H
	ORG $+2
$SG113674 DB	'5', 00H
	ORG $+2
$SG113676 DB	'limited', 00H
$SG113677 DB	'full', 00H
	ORG $+3
$SG113678 DB	'tv', 00H
	ORG $+1
$SG113679 DB	'pc', 00H
CONST	ENDS
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	___local_stdio_printf_options
PUBLIC	__vfprintf_l
PUBLIC	_fprintf
PUBLIC	?max@?$numeric_limits@H@std@@SAHXZ		; std::numeric_limits<int>::max
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	?now@system_clock@chrono@std@@SA?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ ; std::chrono::system_clock::now
PUBLIC	?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count
PUBLIC	??0?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@@Z ; std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >
PUBLIC	?time_since_epoch@?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QBE?AV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@XZ ; std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >::time_since_epoch
PUBLIC	??$?0_JX@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,10000000> >::duration<__int64,std::ratio<1,10000000> ><__int64,void>
PUBLIC	?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ ; std::chrono::steady_clock::now
PUBLIC	?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
PUBLIC	??Y?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAEAAV012@ABV012@@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::operator+=
PUBLIC	??Z?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAEAAV012@ABV012@@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::operator-=
PUBLIC	??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
PUBLIC	?time_since_epoch@?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QBE?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@XZ ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_since_epoch
PUBLIC	??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,void>
PUBLIC	?count@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1> >::count
PUBLIC	?count@?$duration@NU?$ratio@$00$00@std@@@chrono@std@@QBENXZ ; std::chrono::duration<double,std::ratio<1,1> >::count
PUBLIC	?count@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000> >::count
PUBLIC	?count@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBENXZ ; std::chrono::duration<double,std::ratio<1,1000000000> >::count
PUBLIC	??0exception@std@@QAE@QBDH@Z			; std::exception::exception
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@AAE@QBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	??$_Convert_size@I@std@@YAII@Z			; std::_Convert_size<unsigned int>
PUBLIC	??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z ; std::_Container_proxy::_Container_proxy
PUBLIC	??0_Container_base12@std@@QAE@XZ		; std::_Container_base12::_Container_base12
PUBLIC	?_Orphan_all@_Container_base12@std@@QAEXXZ	; std::_Container_base12::_Orphan_all
PUBLIC	?_Swap_proxy_and_iterators@_Container_base12@std@@QAEXAAU12@@Z ; std::_Container_base12::_Swap_proxy_and_iterators
PUBLIC	?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ ; std::_Basic_container_proxy_ptr12::_Release
PUBLIC	?_Incref@_Ref_count_base@std@@QAEXXZ		; std::_Ref_count_base::_Incref
PUBLIC	?_Decref@_Ref_count_base@std@@QAEXXZ		; std::_Ref_count_base::_Decref
PUBLIC	?_Decwref@_Ref_count_base@std@@QAEXXZ		; std::_Ref_count_base::_Decwref
PUBLIC	??0thread@std@@QAE@XZ				; std::thread::thread
PUBLIC	??1thread@std@@QAE@XZ				; std::thread::~thread
PUBLIC	??4thread@std@@QAEAAV01@$$QAV01@@Z		; std::thread::operator=
PUBLIC	?joinable@thread@std@@QBE_NXZ			; std::thread::joinable
PUBLIC	?join@thread@std@@QAEXXZ			; std::thread::join
PUBLIC	??$exchange@U_Thrd_imp_t@@U1@@std@@YA?AU_Thrd_imp_t@@AAU1@$$QAU1@@Z ; std::exchange<_Thrd_imp_t,_Thrd_imp_t>
PUBLIC	?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z	; std::_Narrow_char_traits<char,int>::length
PUBLIC	?copy@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Narrow_char_traits<char,int>::copy
PUBLIC	?move@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Narrow_char_traits<char,int>::move
PUBLIC	?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXQADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
PUBLIC	?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEXI@Z ; std::_String_val<std::_Simple_types<char> >::_Check_offset
PUBLIC	?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
PUBLIC	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Move_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@U_Equal_allocators@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Move_assign
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Memcpy_val_from
PUBLIC	?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@U?$integral_constant@_N$00@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Copy_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy_assign
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
PUBLIC	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::capacity
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	??Rfp_deleter@@QBEXPAU_iobuf@@@Z		; fp_deleter::operator()
PUBLIC	??Rhandle_deleter@@QBEXPAX@Z			; handle_deleter::operator()
PUBLIC	??$make_array@W4CspMatrix@@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@@@YA?AV?$array@W4CspMatrix@@$0O@@std@@$$QAW4CspMatrix@@0000000000000@Z ; make_array<enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix>
PUBLIC	??$make_array@W4CspTransfer@@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@@@YA?AV?$array@W4CspTransfer@@$0P@@std@@$$QAW4CspTransfer@@00000000000000@Z ; make_array<enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer>
PUBLIC	??$make_array@W4CspColorprim@@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@@@YA?AV?$array@W4CspColorprim@@$0M@@std@@$$QAW4CspColorprim@@00000000000@Z ; make_array<enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim>
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@ABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0CPerfMonitor@@QAE@XZ				; CPerfMonitor::CPerfMonitor
PUBLIC	?init@CPerfMonitor@@QAEHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDHHHV?$unique_ptr@XUhandle_deleter@@@3@V?$shared_ptr@VRGYLog@@@3@PAUCPerfMonitorPrm@@@Z ; CPerfMonitor::init
PUBLIC	??1CPerfMonitor@@QAE@XZ				; CPerfMonitor::~CPerfMonitor
PUBLIC	?SetEncStatus@CPerfMonitor@@QAEXV?$shared_ptr@VEncodeStatus@@@std@@@Z ; CPerfMonitor::SetEncStatus
PUBLIC	?SetThreadHandles@CPerfMonitor@@QAEXPAX0000@Z	; CPerfMonitor::SetThreadHandles
PUBLIC	?clear@CPerfMonitor@@QAEXXZ			; CPerfMonitor::clear
PUBLIC	?createPerfMpnitorPyw@CPerfMonitor@@IAEHPBD@Z	; CPerfMonitor::createPerfMpnitorPyw
PUBLIC	?check@CPerfMonitor@@IAEXXZ			; CPerfMonitor::check
PUBLIC	?run@CPerfMonitor@@IAEXXZ			; CPerfMonitor::run
PUBLIC	?write_header@CPerfMonitor@@IAEXPAU_iobuf@@H@Z	; CPerfMonitor::write_header
PUBLIC	?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z		; CPerfMonitor::write
PUBLIC	?loader@CPerfMonitor@@KAXPAX@Z			; CPerfMonitor::loader
PUBLIC	?SelectedCounters@CPerfMonitor@@IAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; CPerfMonitor::SelectedCounters
PUBLIC	??4?$unique_ptr@XUhandle_deleter@@@std@@QAEAAV01@$$QAV01@@Z ; std::unique_ptr<void,handle_deleter>::operator=
PUBLIC	??1?$unique_ptr@XUhandle_deleter@@@std@@QAE@XZ	; std::unique_ptr<void,handle_deleter>::~unique_ptr<void,handle_deleter>
PUBLIC	?get@?$unique_ptr@XUhandle_deleter@@@std@@QBEPAXXZ ; std::unique_ptr<void,handle_deleter>::get
PUBLIC	??B?$unique_ptr@XUhandle_deleter@@@std@@QBE_NXZ	; std::unique_ptr<void,handle_deleter>::operator bool
PUBLIC	?release@?$unique_ptr@XUhandle_deleter@@@std@@QAEPAXXZ ; std::unique_ptr<void,handle_deleter>::release
PUBLIC	?reset@?$unique_ptr@XUhandle_deleter@@@std@@QAEXPAX@Z ; std::unique_ptr<void,handle_deleter>::reset
PUBLIC	?_Get_first@?$_Compressed_pair@Uhandle_deleter@@PAX$00@std@@QAEAAUhandle_deleter@@XZ ; std::_Compressed_pair<handle_deleter,void *,1>::_Get_first
PUBLIC	??R?$default_delete@VRGYPipeProcess@@@std@@QBEXPAVRGYPipeProcess@@@Z ; std::default_delete<RGYPipeProcess>::operator()
PUBLIC	??4?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@QAEAAV01@$$QAV01@@Z ; std::unique_ptr<RGYPipeProcess,std::default_delete<RGYPipeProcess> >::operator=
PUBLIC	??1?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@QAE@XZ ; std::unique_ptr<RGYPipeProcess,std::default_delete<RGYPipeProcess> >::~unique_ptr<RGYPipeProcess,std::default_delete<RGYPipeProcess> >
PUBLIC	??C?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@QBEPAVRGYPipeProcess@@XZ ; std::unique_ptr<RGYPipeProcess,std::default_delete<RGYPipeProcess> >::operator->
PUBLIC	?get@?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@QBEPAVRGYPipeProcess@@XZ ; std::unique_ptr<RGYPipeProcess,std::default_delete<RGYPipeProcess> >::get
PUBLIC	??B?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@QBE_NXZ ; std::unique_ptr<RGYPipeProcess,std::default_delete<RGYPipeProcess> >::operator bool
PUBLIC	?release@?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@QAEPAVRGYPipeProcess@@XZ ; std::unique_ptr<RGYPipeProcess,std::default_delete<RGYPipeProcess> >::release
PUBLIC	?reset@?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@QAEXPAVRGYPipeProcess@@@Z ; std::unique_ptr<RGYPipeProcess,std::default_delete<RGYPipeProcess> >::reset
PUBLIC	?_Get_first@?$_Compressed_pair@U?$default_delete@VRGYPipeProcess@@@std@@PAVRGYPipeProcess@@$00@std@@QAEAAU?$default_delete@VRGYPipeProcess@@@2@XZ ; std::_Compressed_pair<std::default_delete<RGYPipeProcess>,RGYPipeProcess *,1>::_Get_first
PUBLIC	?get@?$_Ptr_base@VEncodeStatus@@@std@@IBEPAVEncodeStatus@@XZ ; std::_Ptr_base<EncodeStatus>::get
PUBLIC	??0?$_Ptr_base@VEncodeStatus@@@std@@IAE@XZ	; std::_Ptr_base<EncodeStatus>::_Ptr_base<EncodeStatus>
PUBLIC	?_Decref@?$_Ptr_base@VEncodeStatus@@@std@@IAEXXZ ; std::_Ptr_base<EncodeStatus>::_Decref
PUBLIC	?_Swap@?$_Ptr_base@VEncodeStatus@@@std@@IAEXAAV12@@Z ; std::_Ptr_base<EncodeStatus>::_Swap
PUBLIC	??0?$shared_ptr@VEncodeStatus@@@std@@QAE@XZ	; std::shared_ptr<EncodeStatus>::shared_ptr<EncodeStatus>
PUBLIC	??0?$shared_ptr@VEncodeStatus@@@std@@QAE@ABV01@@Z ; std::shared_ptr<EncodeStatus>::shared_ptr<EncodeStatus>
PUBLIC	??1?$shared_ptr@VEncodeStatus@@@std@@QAE@XZ	; std::shared_ptr<EncodeStatus>::~shared_ptr<EncodeStatus>
PUBLIC	??4?$shared_ptr@VEncodeStatus@@@std@@QAEAAV01@ABV01@@Z ; std::shared_ptr<EncodeStatus>::operator=
PUBLIC	?swap@?$shared_ptr@VEncodeStatus@@@std@@QAEXAAV12@@Z ; std::shared_ptr<EncodeStatus>::swap
PUBLIC	??B?$shared_ptr@VEncodeStatus@@@std@@QBE_NXZ	; std::shared_ptr<EncodeStatus>::operator bool
PUBLIC	??4?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@QAEAAV01@$$QAV01@@Z ; std::unique_ptr<_iobuf,fp_deleter>::operator=
PUBLIC	??1?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@QAE@XZ ; std::unique_ptr<_iobuf,fp_deleter>::~unique_ptr<_iobuf,fp_deleter>
PUBLIC	?get@?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@QBEPAU_iobuf@@XZ ; std::unique_ptr<_iobuf,fp_deleter>::get
PUBLIC	??B?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@QBE_NXZ ; std::unique_ptr<_iobuf,fp_deleter>::operator bool
PUBLIC	?release@?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@QAEPAU_iobuf@@XZ ; std::unique_ptr<_iobuf,fp_deleter>::release
PUBLIC	?reset@?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@QAEXPAU_iobuf@@@Z ; std::unique_ptr<_iobuf,fp_deleter>::reset
PUBLIC	?_Get_first@?$_Compressed_pair@Ufp_deleter@@PAU_iobuf@@$00@std@@QAEAAUfp_deleter@@XZ ; std::_Compressed_pair<fp_deleter,_iobuf *,1>::_Get_first
PUBLIC	?get@?$_Ptr_base@VRGYLog@@@std@@IBEPAVRGYLog@@XZ ; std::_Ptr_base<RGYLog>::get
PUBLIC	??0?$_Ptr_base@VRGYLog@@@std@@IAE@XZ		; std::_Ptr_base<RGYLog>::_Ptr_base<RGYLog>
PUBLIC	?_Decref@?$_Ptr_base@VRGYLog@@@std@@IAEXXZ	; std::_Ptr_base<RGYLog>::_Decref
PUBLIC	?_Swap@?$_Ptr_base@VRGYLog@@@std@@IAEXAAV12@@Z	; std::_Ptr_base<RGYLog>::_Swap
PUBLIC	??0?$shared_ptr@VRGYLog@@@std@@QAE@XZ		; std::shared_ptr<RGYLog>::shared_ptr<RGYLog>
PUBLIC	??0?$shared_ptr@VRGYLog@@@std@@QAE@ABV01@@Z	; std::shared_ptr<RGYLog>::shared_ptr<RGYLog>
PUBLIC	??1?$shared_ptr@VRGYLog@@@std@@QAE@XZ		; std::shared_ptr<RGYLog>::~shared_ptr<RGYLog>
PUBLIC	??4?$shared_ptr@VRGYLog@@@std@@QAEAAV01@ABV01@@Z ; std::shared_ptr<RGYLog>::operator=
PUBLIC	?swap@?$shared_ptr@VRGYLog@@@std@@QAEXAAV12@@Z	; std::shared_ptr<RGYLog>::swap
PUBLIC	?reset@?$shared_ptr@VRGYLog@@@std@@QAEXXZ	; std::shared_ptr<RGYLog>::reset
PUBLIC	?getStartTimeMicroSec@EncodeStatus@@QAE_JXZ	; EncodeStatus::getStartTimeMicroSec
PUBLIC	?getEncStarted@EncodeStatus@@QAE_NXZ		; EncodeStatus::getEncStarted
PUBLIC	?GetEncodeData@EncodeStatus@@QAE?AUEncodeStatusData@@XZ ; EncodeStatus::GetEncodeData
PUBLIC	??$?CVRGYLog@@$0A@@?$shared_ptr@VRGYLog@@@std@@QBEPAVRGYLog@@XZ ; std::shared_ptr<RGYLog>::operator-><RGYLog,0>
PUBLIC	??$?GUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z ; std::chrono::operator-<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
PUBLIC	??$?0HX@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QAE@ABH@Z ; std::chrono::duration<__int64,std::ratio<1,1000> >::duration<__int64,std::ratio<1,1000> ><int,void>
PUBLIC	??$?0Uhandle_deleter@@$0A@@?$unique_ptr@XUhandle_deleter@@@std@@QAE@XZ ; std::unique_ptr<void,handle_deleter>::unique_ptr<void,handle_deleter><handle_deleter,0>
PUBLIC	??$?0U?$default_delete@VRGYPipeProcess@@@std@@$0A@@?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@QAE@XZ ; std::unique_ptr<RGYPipeProcess,std::default_delete<RGYPipeProcess> >::unique_ptr<RGYPipeProcess,std::default_delete<RGYPipeProcess> ><std::default_delete<RGYPipeProcess>,0>
PUBLIC	??$?0Ufp_deleter@@$0A@@?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@QAE@XZ ; std::unique_ptr<_iobuf,fp_deleter>::unique_ptr<_iobuf,fp_deleter><fp_deleter,0>
PUBLIC	??$move@AAV?$unique_ptr@XUhandle_deleter@@@std@@@std@@YA$$QAV?$unique_ptr@XUhandle_deleter@@@0@AAV10@@Z ; std::move<std::unique_ptr<void,handle_deleter> &>
PUBLIC	??$?0Ufp_deleter@@$0A@@?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@QAE@PAU_iobuf@@@Z ; std::unique_ptr<_iobuf,fp_deleter>::unique_ptr<_iobuf,fp_deleter><fp_deleter,0>
PUBLIC	??$?0U?$default_delete@VRGYPipeProcess@@@std@@$0A@@?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@QAE@PAVRGYPipeProcess@@@Z ; std::unique_ptr<RGYPipeProcess,std::default_delete<RGYPipeProcess> >::unique_ptr<RGYPipeProcess,std::default_delete<RGYPipeProcess> ><std::default_delete<RGYPipeProcess>,0>
PUBLIC	??0?$allocator@PBD@std@@QAE@XZ			; std::allocator<char const *>::allocator<char const *>
PUBLIC	?deallocate@?$allocator@PBD@std@@QAEXQAPBDI@Z	; std::allocator<char const *>::deallocate
PUBLIC	?allocate@?$allocator@PBD@std@@QAEPAPBDI@Z	; std::allocator<char const *>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@PBD@std@@@std@@SAIABV?$allocator@PBD@2@@Z ; std::_Default_allocator_traits<std::allocator<char const *> >::max_size
PUBLIC	??0?$vector@PBDV?$allocator@PBD@std@@@std@@QAE@XZ ; std::vector<char const *,std::allocator<char const *> >::vector<char const *,std::allocator<char const *> >
PUBLIC	??1?$vector@PBDV?$allocator@PBD@std@@@std@@QAE@XZ ; std::vector<char const *,std::allocator<char const *> >::~vector<char const *,std::allocator<char const *> >
PUBLIC	?push_back@?$vector@PBDV?$allocator@PBD@std@@@std@@QAEXABQBD@Z ; std::vector<char const *,std::allocator<char const *> >::push_back
PUBLIC	?push_back@?$vector@PBDV?$allocator@PBD@std@@@std@@QAEX$$QAPBD@Z ; std::vector<char const *,std::allocator<char const *> >::push_back
PUBLIC	?max_size@?$vector@PBDV?$allocator@PBD@std@@@std@@QBEIXZ ; std::vector<char const *,std::allocator<char const *> >::max_size
PUBLIC	?capacity@?$vector@PBDV?$allocator@PBD@std@@@std@@QBEIXZ ; std::vector<char const *,std::allocator<char const *> >::capacity
PUBLIC	?_Umove@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEPAPBDPAPBD00@Z ; std::vector<char const *,std::allocator<char const *> >::_Umove
PUBLIC	?_Umove_if_noexcept1@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEXPAPBD00U?$integral_constant@_N$00@2@@Z ; std::vector<char const *,std::allocator<char const *> >::_Umove_if_noexcept1
PUBLIC	?_Umove_if_noexcept@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEXPAPBD00@Z ; std::vector<char const *,std::allocator<char const *> >::_Umove_if_noexcept
PUBLIC	?_Destroy@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEXPAPBD0@Z ; std::vector<char const *,std::allocator<char const *> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@PBDV?$allocator@PBD@std@@@std@@ABEII@Z ; std::vector<char const *,std::allocator<char const *> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEXQAPBDII@Z ; std::vector<char const *,std::allocator<char const *> >::_Change_array
PUBLIC	?_Tidy@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEXXZ ; std::vector<char const *,std::allocator<char const *> >::_Tidy
PUBLIC	?_Xlength@?$vector@PBDV?$allocator@PBD@std@@@std@@CAXXZ ; std::vector<char const *,std::allocator<char const *> >::_Xlength
PUBLIC	?_Orphan_range@?$vector@PBDV?$allocator@PBD@std@@@std@@ABEXPAPBD0@Z ; std::vector<char const *,std::allocator<char const *> >::_Orphan_range
PUBLIC	?_Getal@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEAAV?$allocator@PBD@2@XZ ; std::vector<char const *,std::allocator<char const *> >::_Getal
PUBLIC	?_Getal@?$vector@PBDV?$allocator@PBD@std@@@std@@ABEABV?$allocator@PBD@2@XZ ; std::vector<char const *,std::allocator<char const *> >::_Getal
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PBD@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<char const *> >::_Vector_val<std::_Simple_types<char const *> >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@PBD@std@@V?$_Vector_val@U?$_Simple_types@PBD@std@@@2@$00@std@@QAEAAV?$allocator@PBD@2@XZ ; std::_Compressed_pair<std::allocator<char const *>,std::_Vector_val<std::_Simple_types<char const *> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@PBD@std@@V?$_Vector_val@U?$_Simple_types@PBD@std@@@2@$00@std@@QBEABV?$allocator@PBD@2@XZ ; std::_Compressed_pair<std::allocator<char const *>,std::_Vector_val<std::_Simple_types<char const *> >,1>::_Get_first
PUBLIC	??$?0A6AXPAX@ZPAVCPerfMonitor@@X@thread@std@@QAE@A6AXPAX@Z$$QAPAVCPerfMonitor@@@Z ; std::thread::thread<void (__cdecl&)(void *),CPerfMonitor *,void>
PUBLIC	??$?CVEncodeStatus@@$0A@@?$shared_ptr@VEncodeStatus@@@std@@QBEPAVEncodeStatus@@XZ ; std::shared_ptr<EncodeStatus>::operator-><EncodeStatus,0>
PUBLIC	??$sleep_for@_JU?$ratio@$00$0DOI@@std@@@this_thread@std@@YAXABV?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@1@@Z ; std::this_thread::sleep_for<__int64,std::ratio<1,1000> >
PUBLIC	??$move@AAPBD@std@@YA$$QAPBDAAPBD@Z		; std::move<char const * &>
PUBLIC	??$emplace_back@PBD@?$vector@PBDV?$allocator@PBD@std@@@std@@QAEX$$QAPBD@Z ; std::vector<char const *,std::allocator<char const *> >::emplace_back<char const *>
PUBLIC	??$forward@PBD@std@@YA$$QAPBDAAPBD@Z		; std::forward<char const *>
PUBLIC	??$_Emplace_back_with_unused_capacity@PBD@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEX$$QAPBD@Z ; std::vector<char const *,std::allocator<char const *> >::_Emplace_back_with_unused_capacity<char const *>
PUBLIC	??$_Unfancy@PBD@std@@YAPAPBDPAPBD@Z		; std::_Unfancy<char const *>
PUBLIC	??$construct@PBDPBD@?$_Default_allocator_traits@V?$allocator@PBD@std@@@std@@SAXAAV?$allocator@PBD@1@QAPBD$$QAPBD@Z ; std::_Default_allocator_traits<std::allocator<char const *> >::construct<char const *,char const *>
PUBLIC	??$_Emplace_reallocate@PBD@?$vector@PBDV?$allocator@PBD@std@@@std@@QAEPAPBDQAPBD$$QAPBD@Z ; std::vector<char const *,std::allocator<char const *> >::_Emplace_reallocate<char const *>
PUBLIC	??$emplace_back@ABQBD@?$vector@PBDV?$allocator@PBD@std@@@std@@QAEXABQBD@Z ; std::vector<char const *,std::allocator<char const *> >::emplace_back<char const * const &>
PUBLIC	??$forward@ABQBD@std@@YAABQBDABQBD@Z		; std::forward<char const * const &>
PUBLIC	??$_Emplace_back_with_unused_capacity@ABQBD@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEXABQBD@Z ; std::vector<char const *,std::allocator<char const *> >::_Emplace_back_with_unused_capacity<char const * const &>
PUBLIC	??$construct@PBDABQBD@?$_Default_allocator_traits@V?$allocator@PBD@std@@@std@@SAXAAV?$allocator@PBD@1@QAPBDABQBD@Z ; std::_Default_allocator_traits<std::allocator<char const *> >::construct<char const *,char const * const &>
PUBLIC	??$_Emplace_reallocate@ABQBD@?$vector@PBDV?$allocator@PBD@std@@@std@@QAEPAPBDQAPBDABQBD@Z ; std::vector<char const *,std::allocator<char const *> >::_Emplace_reallocate<char const * const &>
PUBLIC	?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
PUBLIC	??$?0PBD@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@PBD@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char const *>
PUBLIC	??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z ; std::exchange<std::_Container_proxy *,std::nullptr_t>
PUBLIC	??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@PBD@std@@V?$_Vector_val@U?$_Simple_types@PBD@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char const *>,std::_Vector_val<std::_Simple_types<char const *> >,1>::_Compressed_pair<std::allocator<char const *>,std::_Vector_val<std::_Simple_types<char const *> >,1><>
PUBLIC	??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >
PUBLIC	??$exchange@PAU_iobuf@@AAPAU1@@std@@YAPAU_iobuf@@AAPAU1@0@Z ; std::exchange<_iobuf *,_iobuf * &>
PUBLIC	??$addressof@V?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@@std@@YAPAV?$unique_ptr@U_iobuf@@Ufp_deleter@@@0@AAV10@@Z ; std::addressof<std::unique_ptr<_iobuf,fp_deleter> >
PUBLIC	??$forward@Ufp_deleter@@@std@@YA$$QAUfp_deleter@@AAU1@@Z ; std::forward<fp_deleter>
PUBLIC	??$exchange@PAVRGYPipeProcess@@AAPAV1@@std@@YAPAVRGYPipeProcess@@AAPAV1@0@Z ; std::exchange<RGYPipeProcess *,RGYPipeProcess * &>
PUBLIC	??$addressof@V?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@@std@@YAPAV?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@0@AAV10@@Z ; std::addressof<std::unique_ptr<RGYPipeProcess,std::default_delete<RGYPipeProcess> > >
PUBLIC	??$forward@U?$default_delete@VRGYPipeProcess@@@std@@@std@@YA$$QAU?$default_delete@VRGYPipeProcess@@@0@AAU10@@Z ; std::forward<std::default_delete<RGYPipeProcess> >
PUBLIC	??$exchange@PAXAAPAX@std@@YAPAXAAPAX0@Z		; std::exchange<void *,void * &>
PUBLIC	??$addressof@V?$unique_ptr@XUhandle_deleter@@@std@@@std@@YAPAV?$unique_ptr@XUhandle_deleter@@@0@AAV10@@Z ; std::addressof<std::unique_ptr<void,handle_deleter> >
PUBLIC	??$forward@Uhandle_deleter@@@std@@YA$$QAUhandle_deleter@@AAU1@@Z ; std::forward<handle_deleter>
PUBLIC	??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
PUBLIC	??$_Min_value@I@std@@YAABIABI0@Z		; std::_Min_value<unsigned int>
PUBLIC	??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
PUBLIC	??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
PUBLIC	??$_Unfancy@D@std@@YAPADPAD@Z			; std::_Unfancy<char>
PUBLIC	??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
PUBLIC	??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
PUBLIC	??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
PUBLIC	??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ; std::move<std::allocator<char> &>
PUBLIC	??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
PUBLIC	??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ; std::_Unfancy<std::_Container_proxy>
PUBLIC	??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z ; std::addressof<std::_Container_base12>
PUBLIC	??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
PUBLIC	??$_Copy_construct_from@VRGYLog@@@?$_Ptr_base@VRGYLog@@@std@@IAEXABV?$shared_ptr@VRGYLog@@@1@@Z ; std::_Ptr_base<RGYLog>::_Copy_construct_from<RGYLog>
PUBLIC	??$exchange@PAU_iobuf@@PAU1@@std@@YAPAU_iobuf@@AAPAU1@$$QAPAU1@@Z ; std::exchange<_iobuf *,_iobuf *>
PUBLIC	??$_Copy_construct_from@VEncodeStatus@@@?$_Ptr_base@VEncodeStatus@@@std@@IAEXABV?$shared_ptr@VEncodeStatus@@@1@@Z ; std::_Ptr_base<EncodeStatus>::_Copy_construct_from<EncodeStatus>
PUBLIC	??$exchange@PAVRGYPipeProcess@@PAV1@@std@@YAPAVRGYPipeProcess@@AAPAV1@$$QAPAV1@@Z ; std::exchange<RGYPipeProcess *,RGYPipeProcess *>
PUBLIC	??$exchange@PAXPAX@std@@YAPAXAAPAX$$QAPAX@Z	; std::exchange<void *,void *>
PUBLIC	??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z	; std::_Destroy_in_place<char *>
PUBLIC	??$_Max_value@I@std@@YAABIABI0@Z		; std::_Max_value<unsigned int>
PUBLIC	??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPBV?$_String_val@U?$_Simple_types@D@std@@@0@ABV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > const >
PUBLIC	??R<lambda_9366063389c5f42a00a5088cf24e69de>@@QBEXQADIQBD@Z ; <lambda_9366063389c5f42a00a5088cf24e69de>::operator()
PUBLIC	??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
PUBLIC	??R<lambda_ab246b20b9526e2ef7792587e4298a77>@@QBEXQADQBDI1I@Z ; <lambda_ab246b20b9526e2ef7792587e4298a77>::operator()
PUBLIC	??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
PUBLIC	??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@@Z ; std::_Pocca<std::allocator<char> >
PUBLIC	??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
PUBLIC	??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0@Z ; std::_Pocma<std::allocator<char> >
PUBLIC	??$_Get_size_of_n@$00@std@@YAII@Z		; std::_Get_size_of_n<1>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$_Get_size_of_n@$07@std@@YAII@Z		; std::_Get_size_of_n<8>
PUBLIC	??$_Destroy_range@V?$allocator@PBD@std@@@std@@YAXPAPBDQAPBDAAV?$allocator@PBD@0@@Z ; std::_Destroy_range<std::allocator<char const *> >
PUBLIC	??$swap@PAV_Ref_count_base@std@@X@std@@YAXAAPAV_Ref_count_base@0@0@Z ; std::swap<std::_Ref_count_base *,void>
PUBLIC	??$swap@PAVRGYLog@@X@std@@YAXAAPAVRGYLog@@0@Z	; std::swap<RGYLog *,void>
PUBLIC	??$swap@PAVEncodeStatus@@X@std@@YAXAAPAVEncodeStatus@@0@Z ; std::swap<EncodeStatus *,void>
PUBLIC	??$?G_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV201@0@Z ; std::chrono::operator-<__int64,std::ratio<1,1000000000>,__int64,std::ratio<1,1000000000> >
PUBLIC	??$sleep_until@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@this_thread@std@@YAXABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@1@@Z ; std::this_thread::sleep_until<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
PUBLIC	??$?0$$V@?$_Compressed_pair@Uhandle_deleter@@PAX$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<handle_deleter,void *,1>::_Compressed_pair<handle_deleter,void *,1><>
PUBLIC	??$?0$$V@?$_Compressed_pair@U?$default_delete@VRGYPipeProcess@@@std@@PAVRGYPipeProcess@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::default_delete<RGYPipeProcess>,RGYPipeProcess *,1>::_Compressed_pair<std::default_delete<RGYPipeProcess>,RGYPipeProcess *,1><>
PUBLIC	??$?0$$V@?$_Compressed_pair@Ufp_deleter@@PAU_iobuf@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<fp_deleter,_iobuf *,1>::_Compressed_pair<fp_deleter,_iobuf *,1><>
PUBLIC	??$?0AAPAU_iobuf@@@?$_Compressed_pair@Ufp_deleter@@PAU_iobuf@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAU_iobuf@@@Z ; std::_Compressed_pair<fp_deleter,_iobuf *,1>::_Compressed_pair<fp_deleter,_iobuf *,1><_iobuf * &>
PUBLIC	??$?0AAPAVRGYPipeProcess@@@?$_Compressed_pair@U?$default_delete@VRGYPipeProcess@@@std@@PAVRGYPipeProcess@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAVRGYPipeProcess@@@Z ; std::_Compressed_pair<std::default_delete<RGYPipeProcess>,RGYPipeProcess *,1>::_Compressed_pair<std::default_delete<RGYPipeProcess>,RGYPipeProcess *,1><RGYPipeProcess * &>
PUBLIC	??$forward@A6AXPAX@Z@std@@YAA6AXPAX@ZA6AX0@Z@Z	; std::forward<void (__cdecl&)(void *)>
PUBLIC	??$forward@PAVCPerfMonitor@@@std@@YA$$QAPAVCPerfMonitor@@AAPAV1@@Z ; std::forward<CPerfMonitor *>
PUBLIC	??$make_unique@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@A6AXPAX@ZPAVCPerfMonitor@@$0A@@std@@YA?AV?$unique_ptr@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@2@@0@A6AXPAX@Z$$QAPAVCPerfMonitor@@@Z ; std::make_unique<std::tuple<void (__cdecl*)(void *),CPerfMonitor *>,void (__cdecl&)(void *),CPerfMonitor *,0>
PUBLIC	??R?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@std@@QBEXPAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@1@@Z ; std::default_delete<std::tuple<void (__cdecl*)(void *),CPerfMonitor *> >::operator()
PUBLIC	??1?$unique_ptr@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::tuple<void (__cdecl*)(void *),CPerfMonitor *>,std::default_delete<std::tuple<void (__cdecl*)(void *),CPerfMonitor *> > >::~unique_ptr<std::tuple<void (__cdecl*)(void *),CPerfMonitor *>,std::default_delete<std::tuple<void (__cdecl*)(void *),CPerfMonitor *> > >
PUBLIC	??D?$unique_ptr@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@2@@std@@QBEAAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@1@XZ ; std::unique_ptr<std::tuple<void (__cdecl*)(void *),CPerfMonitor *>,std::default_delete<std::tuple<void (__cdecl*)(void *),CPerfMonitor *> > >::operator*
PUBLIC	?get@?$unique_ptr@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@2@@std@@QBEPAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@2@XZ ; std::unique_ptr<std::tuple<void (__cdecl*)(void *),CPerfMonitor *>,std::default_delete<std::tuple<void (__cdecl*)(void *),CPerfMonitor *> > >::get
PUBLIC	?release@?$unique_ptr@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@2@@std@@QAEPAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@2@XZ ; std::unique_ptr<std::tuple<void (__cdecl*)(void *),CPerfMonitor *>,std::default_delete<std::tuple<void (__cdecl*)(void *),CPerfMonitor *> > >::release
PUBLIC	?_Get_first@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@std@@PAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@2@$00@std@@QAEAAU?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@2@XZ ; std::_Compressed_pair<std::default_delete<std::tuple<void (__cdecl*)(void *),CPerfMonitor *> >,std::tuple<void (__cdecl*)(void *),CPerfMonitor *> *,1>::_Get_first
PUBLIC	??$_Invoke@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@$0A@$00@thread@std@@CGIPAX@Z ; std::thread::_Invoke<std::tuple<void (__cdecl*)(void *),CPerfMonitor *>,0,1>
PUBLIC	??$?HUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@_JU?$ratio@$00$0DOI@@2@@chrono@std@@YA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@ABV201@ABV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@@Z ; std::chrono::operator+<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000> >
PUBLIC	??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
PUBLIC	??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ; std::forward<std::allocator<char> >
PUBLIC	??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z ; std::addressof<std::_Container_proxy>
PUBLIC	??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z ; std::forward<std::_Container_base12 *>
PUBLIC	??$addressof@PAD@std@@YAPAPADAAPAD@Z		; std::addressof<char *>
PUBLIC	??$forward@ABQAD@std@@YAABQADABQAD@Z		; std::forward<char * const &>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??$move@AAPAVCPerfMonitor@@@std@@YA$$QAPAVCPerfMonitor@@AAPAV1@@Z ; std::move<CPerfMonitor * &>
PUBLIC	??$move@AAPAV_Ref_count_base@std@@@std@@YA$$QAPAV_Ref_count_base@0@AAPAV10@@Z ; std::move<std::_Ref_count_base * &>
PUBLIC	??$move@AAPAVRGYLog@@@std@@YA$$QAPAVRGYLog@@AAPAV1@@Z ; std::move<RGYLog * &>
PUBLIC	??$move@AAPAVEncodeStatus@@@std@@YA$$QAPAVEncodeStatus@@AAPAV1@@Z ; std::move<EncodeStatus * &>
PUBLIC	??$exchange@PAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@PAV12@@std@@YAPAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@0@AAPAV10@$$QAPAV10@@Z ; std::exchange<std::tuple<void (__cdecl*)(void *),CPerfMonitor *> *,std::tuple<void (__cdecl*)(void *),CPerfMonitor *> *>
PUBLIC	??$_Uninitialized_move@PAPBDV?$allocator@PBD@std@@@std@@YAPAPBDQAPBD0PAPBDAAV?$allocator@PBD@0@@Z ; std::_Uninitialized_move<char const * *,std::allocator<char const *> >
PUBLIC	??$_Get_size_of_n@$03@std@@YAII@Z		; std::_Get_size_of_n<4>
PUBLIC	??R<lambda_4d79bb85f269e6e8002a4599002d832c>@@QBEXQADQBDII1I@Z ; <lambda_4d79bb85f269e6e8002a4599002d832c>::operator()
PUBLIC	??$_Reallocate_grow_by@V<lambda_4d79bb85f269e6e8002a4599002d832c>@@IPBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_4d79bb85f269e6e8002a4599002d832c>@@IPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_4d79bb85f269e6e8002a4599002d832c>,unsigned int,char const *,unsigned int>
PUBLIC	??$?0_JU?$ratio@$00$0DOI@@std@@X@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0DOI@@std@@@12@@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,std::ratio<1,1000>,void>
PUBLIC	??$?NUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA_NABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z ; std::chrono::operator<=<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
PUBLIC	??$_To_xtime_10_day_clamped@_JU?$ratio@$00$0DLJKMKAA@@std@@@std@@YA_NAAUxtime@@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@0@@Z ; std::_To_xtime_10_day_clamped<__int64,std::ratio<1,1000000000> >
PUBLIC	??$forward@AAPAU_iobuf@@@std@@YAAAPAU_iobuf@@AAPAU1@@Z ; std::forward<_iobuf * &>
PUBLIC	??$forward@AAPAVRGYPipeProcess@@@std@@YAAAPAVRGYPipeProcess@@AAPAV1@@Z ; std::forward<RGYPipeProcess * &>
PUBLIC	??$?0A6AXPAX@ZPAVCPerfMonitor@@$0A@@?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@QAE@A6AXPAX@Z$$QAPAVCPerfMonitor@@@Z ; std::tuple<void (__cdecl*)(void *),CPerfMonitor *>::tuple<void (__cdecl*)(void *),CPerfMonitor *><void (__cdecl&)(void *),CPerfMonitor *,0>
PUBLIC	??$?0U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@std@@$0A@@?$unique_ptr@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@2@@std@@QAE@PAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@1@@Z ; std::unique_ptr<std::tuple<void (__cdecl*)(void *),CPerfMonitor *>,std::default_delete<std::tuple<void (__cdecl*)(void *),CPerfMonitor *> > >::unique_ptr<std::tuple<void (__cdecl*)(void *),CPerfMonitor *>,std::default_delete<std::tuple<void (__cdecl*)(void *),CPerfMonitor *> > ><std::default_delete<std::tuple<void (__cdecl*)(void *),CPerfMonitor *> >,0>
PUBLIC	??$get@$0A@P6AXPAX@ZPAVCPerfMonitor@@@std@@YAAAP6AXPAX@ZAAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@0@@Z ; std::get<0,void (__cdecl*)(void *),CPerfMonitor *>
PUBLIC	??$move@AAP6AXPAX@Z@std@@YA$$QAP6AXPAX@ZAAP6AX0@Z@Z ; std::move<void (__cdecl*&)(void *)>
PUBLIC	??$get@$00P6AXPAX@ZPAVCPerfMonitor@@@std@@YAAAPAVCPerfMonitor@@AAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@0@@Z ; std::get<1,void (__cdecl*)(void *),CPerfMonitor *>
PUBLIC	??$forward@P6AXPAX@Z@std@@YA$$QAP6AXPAX@ZAAP6AX0@Z@Z ; std::forward<void (__cdecl*)(void *)>
PUBLIC	??$_Call@P6AXPAX@ZPAVCPerfMonitor@@@_Invoker_functor@std@@SAX$$QAP6AXPAX@Z$$QAPAVCPerfMonitor@@@Z ; std::_Invoker_functor::_Call<void (__cdecl*)(void *),CPerfMonitor *>
PUBLIC	??$invoke@P6AXPAX@ZPAVCPerfMonitor@@@std@@YAX$$QAP6AXPAX@Z$$QAPAVCPerfMonitor@@@Z ; std::invoke<void (__cdecl*)(void *),CPerfMonitor *>
PUBLIC	??$?H_JU?$ratio@$00$0DLJKMKAA@@std@@_JU?$ratio@$00$0DOI@@1@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV201@ABV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@@Z ; std::chrono::operator+<__int64,std::ratio<1,1000000000>,__int64,std::ratio<1,1000> >
PUBLIC	?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
PUBLIC	??$_Get_unwrapped@PBD@std@@YAPAPBDQAPBD@Z	; std::_Get_unwrapped<char const *>
PUBLIC	??$_Copy_memmove@PAPBDPAPBD@std@@YAPAPBDPAPBD00@Z ; std::_Copy_memmove<char const * *,char const * *>
PUBLIC	??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DOI@@3@X@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@@Z ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000>,void>
PUBLIC	??$?MUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA_NABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z ; std::chrono::operator<<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
PUBLIC	??$?0_JU?$ratio@$00$0JIJGIA@@std@@X@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,std::ratio<1,10000000>,void>
PUBLIC	??$?MNU?$ratio@$00$00@std@@_JU?$ratio@$00$0DLJKMKAA@@1@@chrono@std@@YA_NABV?$duration@NU?$ratio@$00$00@std@@@01@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z ; std::chrono::operator<<double,std::ratio<1,1>,__int64,std::ratio<1,1000000000> >
PUBLIC	??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@X@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV201@@Z ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000000000>,void>
PUBLIC	??$duration_cast@V?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@X@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$00@std@@@01@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1> >,__int64,std::ratio<1,1000000000>,void>
PUBLIC	??$?0_JU?$ratio@$00$00@std@@X@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$00@std@@@12@@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,std::ratio<1,1>,void>
PUBLIC	??$?0U_Exact_args_t@std@@A6AXPAX@ZPAVCPerfMonitor@@$0A@@?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@QAE@U_Exact_args_t@1@A6AXPAX@Z$$QAPAVCPerfMonitor@@@Z ; std::tuple<void (__cdecl*)(void *),CPerfMonitor *>::tuple<void (__cdecl*)(void *),CPerfMonitor *><std::_Exact_args_t,void (__cdecl&)(void *),CPerfMonitor *,0>
PUBLIC	??$?0AAPAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@std@@PAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@1@@Z ; std::_Compressed_pair<std::default_delete<std::tuple<void (__cdecl*)(void *),CPerfMonitor *> >,std::tuple<void (__cdecl*)(void *),CPerfMonitor *> *,1>::_Compressed_pair<std::default_delete<std::tuple<void (__cdecl*)(void *),CPerfMonitor *> >,std::tuple<void (__cdecl*)(void *),CPerfMonitor *> *,1><std::tuple<void (__cdecl*)(void *),CPerfMonitor *> * &>
PUBLIC	??$?M_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YA_NABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@0@Z ; std::chrono::operator<<__int64,std::ratio<1,1000000000>,__int64,std::ratio<1,1000000000> >
PUBLIC	??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0JIJGIA@@3@X@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@@Z ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,10000000>,void>
PUBLIC	??$?0NU?$ratio@$00$00@std@@X@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABV?$duration@NU?$ratio@$00$00@std@@@12@@Z ; std::chrono::duration<double,std::ratio<1,1000000000> >::duration<double,std::ratio<1,1000000000> ><double,std::ratio<1,1>,void>
PUBLIC	??$?0_JU?$ratio@$00$0DLJKMKAA@@std@@X@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z ; std::chrono::duration<double,std::ratio<1,1000000000> >::duration<double,std::ratio<1,1000000000> ><__int64,std::ratio<1,1000000000>,void>
PUBLIC	??$?0_JX@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1> >::duration<__int64,std::ratio<1,1> ><__int64,void>
PUBLIC	??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$00@3@X@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@_JU?$ratio@$00$00@std@@@01@@Z ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1>,void>
PUBLIC	??$?0U_Exact_args_t@std@@PAVCPerfMonitor@@$$V$0A@@?$tuple@PAVCPerfMonitor@@@std@@QAE@U_Exact_args_t@1@$$QAPAVCPerfMonitor@@@Z ; std::tuple<CPerfMonitor *>::tuple<CPerfMonitor *><std::_Exact_args_t,CPerfMonitor *,0>
PUBLIC	??$?0A6AXPAX@Z@?$_Tuple_val@P6AXPAX@Z@std@@QAE@A6AXPAX@Z@Z ; std::_Tuple_val<void (__cdecl*)(void *)>::_Tuple_val<void (__cdecl*)(void *)><void (__cdecl&)(void *)>
PUBLIC	??$forward@AAPAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@std@@YAAAPAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@0@AAPAV10@@Z ; std::forward<std::tuple<void (__cdecl*)(void *),CPerfMonitor *> * &>
PUBLIC	??$duration_cast@V?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@NU?$ratio@$00$00@3@X@chrono@std@@YA?AV?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@NU?$ratio@$00$00@std@@@01@@Z ; std::chrono::duration_cast<std::chrono::duration<double,std::ratio<1,1000000000> >,double,std::ratio<1,1>,void>
PUBLIC	??$duration_cast@V?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@X@chrono@std@@YA?AV?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z ; std::chrono::duration_cast<std::chrono::duration<double,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000000000>,void>
PUBLIC	??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QAE@U_Exact_args_t@1@@Z ; std::tuple<>::tuple<><std::_Exact_args_t,0>
PUBLIC	??$?0PAVCPerfMonitor@@@?$_Tuple_val@PAVCPerfMonitor@@@std@@QAE@$$QAPAVCPerfMonitor@@@Z ; std::_Tuple_val<CPerfMonitor *>::_Tuple_val<CPerfMonitor *><CPerfMonitor *>
PUBLIC	??$?0NX@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABN@Z ; std::chrono::duration<double,std::ratio<1,1000000000> >::duration<double,std::ratio<1,1000000000> ><double,void>
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_0BB@FCMFBGOM@invalid?5argument@		; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_0GI@FJIKDGOA@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ ; `string'
PUBLIC	??_C@_1NA@CDBIFGMM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@ ; `string'
PUBLIC	??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@ ; `string'
PUBLIC	??_R0?AVRGYPipeProcess@@@8			; RGYPipeProcess `RTTI Type Descriptor'
PUBLIC	??_R0?AVRGYPipeProcessWin@@@8			; RGYPipeProcessWin `RTTI Type Descriptor'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position@	; `string'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long@	; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@3eb0c6f7a0b5ed8d
PUBLIC	__real@3f50624dd2f1a9fc
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@4020000000000000
PUBLIC	__real@4059000000000000
PUBLIC	__real@40c3880000000000
PUBLIC	__real@412a5e0000000000
PUBLIC	__real@412e848000000000
PUBLIC	__real@4130000000000000
PUBLIC	__real@41cdcd6500000000
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	__imp___invalid_parameter:PROC
EXTRN	__imp__fopen_s:PROC
EXTRN	__imp__fclose:PROC
EXTRN	__imp__fflush:PROC
EXTRN	__imp__fopen:PROC
EXTRN	__imp__fwrite:PROC
EXTRN	__imp____stdio_common_vfprintf:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	__imp___CrtDbgReport:PROC
EXTRN	__imp_??0_Lockit@std@@QAE@H@Z:PROC
EXTRN	__imp_??1_Lockit@std@@QAE@XZ:PROC
EXTRN	__imp__clock:PROC
EXTRN	__Xtime_get_ticks:PROC
EXTRN	__Query_perf_counter:PROC
EXTRN	__Query_perf_frequency:PROC
EXTRN	__imp__terminate:PROC
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	_strlen:PROC
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	__imp___beginthreadex:PROC
EXTRN	__Thrd_join:PROC
EXTRN	__Thrd_sleep:PROC
EXTRN	__Thrd_id:PROC
EXTRN	__Cnd_do_broadcast_at_thread_exit:PROC
EXTRN	?_Throw_Cpp_error@std@@YAXH@Z:PROC		; std::_Throw_Cpp_error
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__GetProcessTimes@20:PROC
EXTRN	__imp__GetCurrentProcess@0:PROC
EXTRN	__imp__GetExitCodeThread@8:PROC
EXTRN	__imp__GetProcessId@4:PROC
EXTRN	__imp__GetThreadTimes@20:PROC
EXTRN	__imp__GetSystemTime@4:PROC
EXTRN	__imp__GetModuleFileNameA@12:PROC
EXTRN	__imp__GetModuleHandleA@4:PROC
EXTRN	__imp__LoadResource@8:PROC
EXTRN	__imp__LockResource@4:PROC
EXTRN	__imp__SizeofResource@8:PROC
EXTRN	__imp__GetProcessIoCounters@8:PROC
EXTRN	__imp__FindResourceA@12:PROC
EXTRN	__imp__SystemTimeToFileTime@8:PROC
EXTRN	__imp__WaitForInputIdle@8:PROC
EXTRN	__imp__PathCombineA@12:PROC
EXTRN	__imp__PathRemoveFileSpecA@4:PROC
EXTRN	?get_cpu_info@@YA_NPAUcpu_info_t@@@Z:PROC	; get_cpu_info
EXTRN	?strsprintf@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ:PROC ; strsprintf
EXTRN	??0RGYPipeProcessWin@@QAE@XZ:PROC		; RGYPipeProcessWin::RGYPipeProcessWin
EXTRN	?getProcessInfo@RGYPipeProcessWin@@QAEABU_PROCESS_INFORMATION@@XZ:PROC ; RGYPipeProcessWin::getProcessInfo
EXTRN	?get_gpuz_info@@YAHPAUGPUZ_SH_MEM@@@Z:PROC	; get_gpuz_info
EXTRN	?gpu_core_clock@@YANPAUGPUZ_SH_MEM@@@Z:PROC	; gpu_core_clock
EXTRN	?gpu_load@@YANPAUGPUZ_SH_MEM@@@Z:PROC		; gpu_load
EXTRN	?video_engine_load@@YANPAUGPUZ_SH_MEM@@PA_N@Z:PROC ; video_engine_load
EXTRN	_K32GetProcessMemoryInfo@12:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	___RTDynamicCast:PROC
EXTRN	__alldiv:PROC
EXTRN	__allmul:PROC
EXTRN	__allrem:PROC
EXTRN	__aulldiv:PROC
EXTRN	__dtol3:PROC
EXTRN	__ltod3:PROC
EXTRN	__ultod3:PROC
EXTRN	_memset:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
_BSS	SEGMENT
?CspMatrixList@@3V?$array@W4CspMatrix@@$0O@@std@@B DB 038H DUP (?) ; CspMatrixList
?CspTransferList@@3V?$array@W4CspTransfer@@$0P@@std@@B DB 03cH DUP (?) ; CspTransferList
?CspColorprimList@@3V?$array@W4CspColorprim@@$0M@@std@@B DB 030H DUP (?) ; CspColorprimList
_BSS	ENDS
CRT$XCU	SEGMENT
?CspMatrixList$initializer$@@3P6AXXZA DD FLAT:??__ECspMatrixList@@YAXXZ ; CspMatrixList$initializer$
CRT$XCU	ENDS
;	COMDAT __real@41cdcd6500000000
CONST	SEGMENT
__real@41cdcd6500000000 DQ 041cdcd6500000000r	; 1e+09
CONST	ENDS
;	COMDAT __real@4130000000000000
CONST	SEGMENT
__real@4130000000000000 DQ 04130000000000000r	; 1.04858e+06
CONST	ENDS
;	COMDAT __real@412e848000000000
CONST	SEGMENT
__real@412e848000000000 DQ 0412e848000000000r	; 1e+06
CONST	ENDS
;	COMDAT __real@412a5e0000000000
CONST	SEGMENT
__real@412a5e0000000000 DQ 0412a5e0000000000r	; 864000
CONST	ENDS
;	COMDAT __real@40c3880000000000
CONST	SEGMENT
__real@40c3880000000000 DQ 040c3880000000000r	; 10000
CONST	ENDS
;	COMDAT __real@4059000000000000
CONST	SEGMENT
__real@4059000000000000 DQ 04059000000000000r	; 100
CONST	ENDS
;	COMDAT __real@4020000000000000
CONST	SEGMENT
__real@4020000000000000 DQ 04020000000000000r	; 8
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@3f50624dd2f1a9fc
CONST	SEGMENT
__real@3f50624dd2f1a9fc DQ 03f50624dd2f1a9fcr	; 0.001
CONST	ENDS
;	COMDAT __real@3eb0c6f7a0b5ed8d
CONST	SEGMENT
__real@3eb0c6f7a0b5ed8d DQ 03eb0c6f7a0b5ed8dr	; 1e-06
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long@ DB 'vector<T> too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position@ DB 'invalid string position'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_R0?AVRGYPipeProcessWin@@@8
data$r	SEGMENT
??_R0?AVRGYPipeProcessWin@@@8 DD FLAT:??_7type_info@@6B@ ; RGYPipeProcessWin `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVRGYPipeProcessWin@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AVRGYPipeProcess@@@8
data$r	SEGMENT
??_R0?AVRGYPipeProcess@@@8 DD FLAT:??_7type_info@@6B@	; RGYPipeProcess `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVRGYPipeProcess@@', 00H
data$r	ENDS
;	COMDAT ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
CONST	SEGMENT
??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@ DB '"'
	DB	00H, 'i', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H
	DB	'd', 00H, ' ', 00H, 'a', 00H, 'r', 00H, 'g', 00H, 'u', 00H, 'm'
	DB	00H, 'e', 00H, 'n', 00H, 't', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@
CONST	SEGMENT
??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'A', 00H
	DB	'd', 00H, 'j', 00H, 'u', 00H, 's', 00H, 't', 00H, '_', 00H, 'm'
	DB	00H, 'a', 00H, 'n', 00H, 'u', 00H, 'a', 00H, 'l', 00H, 'l', 00H
	DB	'y', 00H, '_', 00H, 'v', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o'
	DB	00H, 'r', 00H, '_', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'g', 00H
	DB	'n', 00H, 'e', 00H, 'd', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1NA@CDBIFGMM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
CONST	SEGMENT
??_C@_1NA@CDBIFGMM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ DB 'C'
	DB	00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'F', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'V', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	'\', 00H, '2', 00H, '0', 00H, '1', 00H, '9', 00H, '\', 00H, 'C'
	DB	00H, 'o', 00H, 'm', 00H, 'm', 00H, 'u', 00H, 'n', 00H, 'i', 00H
	DB	't', 00H, 'y', 00H, '\', 00H, 'V', 00H, 'C', 00H, '\', 00H, 'T'
	DB	00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '\', 00H, 'M', 00H
	DB	'S', 00H, 'V', 00H, 'C', 00H, '\', 00H, '1', 00H, '4', 00H, '.'
	DB	00H, '2', 00H, '3', 00H, '.', 00H, '2', 00H, '8', 00H, '1', 00H
	DB	'0', 00H, '5', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l'
	DB	00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H, 'm', 00H
	DB	'e', 00H, 'm', 00H, 'o', 00H, 'r', 00H, 'y', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GI@FJIKDGOA@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
CONST	SEGMENT
??_C@_0GI@FJIKDGOA@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ DB 'C:\Pro'
	DB	'gram Files (x86)\Microsoft Visual Studio\2019\Community\VC\To'
	DB	'ols\MSVC\14.23.28105\include\xmemory', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FCMFBGOM@invalid?5argument@
CONST	SEGMENT
??_C@_0BB@FCMFBGOM@invalid?5argument@ DB 'invalid argument', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?0U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@std@@$0A@@?$unique_ptr@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@2@@std@@QAE@PAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@1@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?0A6AXPAX@ZPAVCPerfMonitor@@$0A@@?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@QAE@A6AXPAX@Z$$QAPAVCPerfMonitor@@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Invoke@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@$0A@$00@thread@std@@CGIPAX@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Invoke@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@$0A@$00@thread@std@@CGIPAX@Z$0
__ehfuncinfo$??$_Invoke@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@$0A@$00@thread@std@@CGIPAX@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Invoke@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@$0A@$00@thread@std@@CGIPAX@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?release@?$unique_ptr@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@2@@std@@QAEPAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@2@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$make_unique@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@A6AXPAX@ZPAVCPerfMonitor@@$0A@@std@@YA?AV?$unique_ptr@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@2@@0@A6AXPAX@Z$$QAPAVCPerfMonitor@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$make_unique@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@A6AXPAX@ZPAVCPerfMonitor@@$0A@@std@@YA?AV?$unique_ptr@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@2@@0@A6AXPAX@Z$$QAPAVCPerfMonitor@@@Z$0
__ehfuncinfo$??$make_unique@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@A6AXPAX@ZPAVCPerfMonitor@@$0A@@std@@YA?AV?$unique_ptr@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@2@@0@A6AXPAX@Z$$QAPAVCPerfMonitor@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$make_unique@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@A6AXPAX@ZPAVCPerfMonitor@@$0A@@std@@YA?AV?$unique_ptr@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@2@@0@A6AXPAX@Z$$QAPAVCPerfMonitor@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z$0
__ehfuncinfo$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z$0
__ehfuncinfo$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Emplace_reallocate@ABQBD@?$vector@PBDV?$allocator@PBD@std@@@std@@QAEPAPBDQAPBDABQBD@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABQBD@?$vector@PBDV?$allocator@PBD@std@@@std@@QAEPAPBDQAPBDABQBD@Z$0
__unwindtable$??$_Emplace_reallocate@ABQBD@?$vector@PBDV?$allocator@PBD@std@@@std@@QAEPAPBDQAPBDABQBD@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABQBD@?$vector@PBDV?$allocator@PBD@std@@@std@@QAEPAPBDQAPBDABQBD@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABQBD@?$vector@PBDV?$allocator@PBD@std@@@std@@QAEPAPBDQAPBDABQBD@Z$2
__ehfuncinfo$??$_Emplace_reallocate@ABQBD@?$vector@PBDV?$allocator@PBD@std@@@std@@QAEPAPBDQAPBDABQBD@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABQBD@?$vector@PBDV?$allocator@PBD@std@@@std@@QAEPAPBDQAPBDABQBD@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABQBD@?$vector@PBDV?$allocator@PBD@std@@@std@@QAEPAPBDQAPBDABQBD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Emplace_reallocate@PBD@?$vector@PBDV?$allocator@PBD@std@@@std@@QAEPAPBDQAPBD$$QAPBD@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@PBD@?$vector@PBDV?$allocator@PBD@std@@@std@@QAEPAPBDQAPBD$$QAPBD@Z$0
__unwindtable$??$_Emplace_reallocate@PBD@?$vector@PBDV?$allocator@PBD@std@@@std@@QAEPAPBDQAPBD$$QAPBD@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@PBD@?$vector@PBDV?$allocator@PBD@std@@@std@@QAEPAPBDQAPBD$$QAPBD@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@PBD@?$vector@PBDV?$allocator@PBD@std@@@std@@QAEPAPBDQAPBD$$QAPBD@Z$2
__ehfuncinfo$??$_Emplace_reallocate@PBD@?$vector@PBDV?$allocator@PBD@std@@@std@@QAEPAPBDQAPBD$$QAPBD@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@PBD@?$vector@PBDV?$allocator@PBD@std@@@std@@QAEPAPBDQAPBD$$QAPBD@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@PBD@?$vector@PBDV?$allocator@PBD@std@@@std@@QAEPAPBDQAPBD$$QAPBD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?0A6AXPAX@ZPAVCPerfMonitor@@X@thread@std@@QAE@A6AXPAX@Z$$QAPAVCPerfMonitor@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0A6AXPAX@ZPAVCPerfMonitor@@X@thread@std@@QAE@A6AXPAX@Z$$QAPAVCPerfMonitor@@@Z$0
__ehfuncinfo$??$?0A6AXPAX@ZPAVCPerfMonitor@@X@thread@std@@QAE@A6AXPAX@Z$$QAPAVCPerfMonitor@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?0A6AXPAX@ZPAVCPerfMonitor@@X@thread@std@@QAE@A6AXPAX@Z$$QAPAVCPerfMonitor@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Orphan_range@?$vector@PBDV?$allocator@PBD@std@@@std@@ABEXPAPBD0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Orphan_range@?$vector@PBDV?$allocator@PBD@std@@@std@@ABEXPAPBD0@Z$0
__ehfuncinfo$?_Orphan_range@?$vector@PBDV?$allocator@PBD@std@@@std@@ABEXPAPBD0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Orphan_range@?$vector@PBDV?$allocator@PBD@std@@@std@@ABEXPAPBD0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Tidy@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$vector@PBDV?$allocator@PBD@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$vector@PBDV?$allocator@PBD@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?0U?$default_delete@VRGYPipeProcess@@@std@@$0A@@?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@QAE@PAVRGYPipeProcess@@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?0Ufp_deleter@@$0A@@?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@QAE@PAU_iobuf@@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?0Ufp_deleter@@$0A@@?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?0U?$default_delete@VRGYPipeProcess@@@std@@$0A@@?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?0Uhandle_deleter@@$0A@@?$unique_ptr@XUhandle_deleter@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?reset@?$shared_ptr@VRGYLog@@@std@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?reset@?$shared_ptr@VRGYLog@@@std@@QAEXXZ$0
__ehfuncinfo$?reset@?$shared_ptr@VRGYLog@@@std@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?reset@?$shared_ptr@VRGYLog@@@std@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??4?$shared_ptr@VRGYLog@@@std@@QAEAAV01@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??4?$shared_ptr@VRGYLog@@@std@@QAEAAV01@ABV01@@Z$0
__ehfuncinfo$??4?$shared_ptr@VRGYLog@@@std@@QAEAAV01@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??4?$shared_ptr@VRGYLog@@@std@@QAEAAV01@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?reset@?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@QAEXPAU_iobuf@@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?release@?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@QAEPAU_iobuf@@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??4?$shared_ptr@VEncodeStatus@@@std@@QAEAAV01@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??4?$shared_ptr@VEncodeStatus@@@std@@QAEAAV01@ABV01@@Z$0
__ehfuncinfo$??4?$shared_ptr@VEncodeStatus@@@std@@QAEAAV01@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??4?$shared_ptr@VEncodeStatus@@@std@@QAEAAV01@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?reset@?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@QAEXPAVRGYPipeProcess@@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?release@?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@QAEPAVRGYPipeProcess@@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?reset@?$unique_ptr@XUhandle_deleter@@@std@@QAEXPAX@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?release@?$unique_ptr@XUhandle_deleter@@@std@@QAEPAXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$unique_ptr@XUhandle_deleter@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
xdata$x	SEGMENT
__unwindtable$?write_header@CPerfMonitor@@IAEXPAU_iobuf@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?write_header@CPerfMonitor@@IAEXPAU_iobuf@@H@Z$0
__unwindtable$?SetEncStatus@CPerfMonitor@@QAEXV?$shared_ptr@VEncodeStatus@@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetEncStatus@CPerfMonitor@@QAEXV?$shared_ptr@VEncodeStatus@@@std@@@Z$0
__unwindtable$?SelectedCounters@CPerfMonitor@@IAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SelectedCounters@CPerfMonitor@@IAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?SelectedCounters@CPerfMonitor@@IAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z$1
__ehfuncinfo$?SelectedCounters@CPerfMonitor@@IAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?SelectedCounters@CPerfMonitor@@IAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__ehfuncinfo$?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z DD 019930522H
	DD	020H
	DD	FLAT:__unwindtable$?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__ehfuncinfo$?write_header@CPerfMonitor@@IAEXPAU_iobuf@@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?write_header@CPerfMonitor@@IAEXPAU_iobuf@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__ehfuncinfo$?SetEncStatus@CPerfMonitor@@QAEXV?$shared_ptr@VEncodeStatus@@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SetEncStatus@CPerfMonitor@@QAEXV?$shared_ptr@VEncodeStatus@@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__ehfuncinfo$??1CPerfMonitor@@QAE@XZ DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$??1CPerfMonitor@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
__ehfuncinfo$?init@CPerfMonitor@@QAEHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDHHHV?$unique_ptr@XUhandle_deleter@@@3@V?$shared_ptr@VRGYLog@@@3@PAUCPerfMonitorPrm@@@Z DD 019930522H
	DD	015H
	DD	FLAT:__unwindtable$?init@CPerfMonitor@@QAEHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDHHHV?$unique_ptr@XUhandle_deleter@@@3@V?$shared_ptr@VRGYLog@@@3@PAUCPerfMonitorPrm@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__ehfuncinfo$??0CPerfMonitor@@QAE@XZ DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$??0CPerfMonitor@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??1CPerfMonitor@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CPerfMonitor@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CPerfMonitor@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CPerfMonitor@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CPerfMonitor@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1CPerfMonitor@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??1CPerfMonitor@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??1CPerfMonitor@@QAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??1CPerfMonitor@@QAE@XZ$7
__unwindtable$??0CPerfMonitor@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CPerfMonitor@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CPerfMonitor@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CPerfMonitor@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0CPerfMonitor@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0CPerfMonitor@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0CPerfMonitor@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??0CPerfMonitor@@QAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??0CPerfMonitor@@QAE@XZ$7
__unwindtable$?init@CPerfMonitor@@QAEHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDHHHV?$unique_ptr@XUhandle_deleter@@@3@V?$shared_ptr@VRGYLog@@@3@PAUCPerfMonitorPrm@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?init@CPerfMonitor@@QAEHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDHHHV?$unique_ptr@XUhandle_deleter@@@3@V?$shared_ptr@VRGYLog@@@3@PAUCPerfMonitorPrm@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?init@CPerfMonitor@@QAEHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDHHHV?$unique_ptr@XUhandle_deleter@@@3@V?$shared_ptr@VRGYLog@@@3@PAUCPerfMonitorPrm@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?init@CPerfMonitor@@QAEHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDHHHV?$unique_ptr@XUhandle_deleter@@@3@V?$shared_ptr@VRGYLog@@@3@PAUCPerfMonitorPrm@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?init@CPerfMonitor@@QAEHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDHHHV?$unique_ptr@XUhandle_deleter@@@3@V?$shared_ptr@VRGYLog@@@3@PAUCPerfMonitorPrm@@@Z$3
	DD	02H
	DD	FLAT:__unwindfunclet$?init@CPerfMonitor@@QAEHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDHHHV?$unique_ptr@XUhandle_deleter@@@3@V?$shared_ptr@VRGYLog@@@3@PAUCPerfMonitorPrm@@@Z$4
	DD	02H
	DD	FLAT:__unwindfunclet$?init@CPerfMonitor@@QAEHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDHHHV?$unique_ptr@XUhandle_deleter@@@3@V?$shared_ptr@VRGYLog@@@3@PAUCPerfMonitorPrm@@@Z$5
	DD	02H
	DD	FLAT:__unwindfunclet$?init@CPerfMonitor@@QAEHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDHHHV?$unique_ptr@XUhandle_deleter@@@3@V?$shared_ptr@VRGYLog@@@3@PAUCPerfMonitorPrm@@@Z$6
	DD	02H
	DD	FLAT:__unwindfunclet$?init@CPerfMonitor@@QAEHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDHHHV?$unique_ptr@XUhandle_deleter@@@3@V?$shared_ptr@VRGYLog@@@3@PAUCPerfMonitorPrm@@@Z$7
	DD	07H
	DD	FLAT:__unwindfunclet$?init@CPerfMonitor@@QAEHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDHHHV?$unique_ptr@XUhandle_deleter@@@3@V?$shared_ptr@VRGYLog@@@3@PAUCPerfMonitorPrm@@@Z$8
	DD	08H
	DD	FLAT:__unwindfunclet$?init@CPerfMonitor@@QAEHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDHHHV?$unique_ptr@XUhandle_deleter@@@3@V?$shared_ptr@VRGYLog@@@3@PAUCPerfMonitorPrm@@@Z$9
	DD	09H
	DD	FLAT:__unwindfunclet$?init@CPerfMonitor@@QAEHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDHHHV?$unique_ptr@XUhandle_deleter@@@3@V?$shared_ptr@VRGYLog@@@3@PAUCPerfMonitorPrm@@@Z$10
	DD	0aH
	DD	FLAT:__unwindfunclet$?init@CPerfMonitor@@QAEHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDHHHV?$unique_ptr@XUhandle_deleter@@@3@V?$shared_ptr@VRGYLog@@@3@PAUCPerfMonitorPrm@@@Z$11
	DD	07H
	DD	FLAT:__unwindfunclet$?init@CPerfMonitor@@QAEHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDHHHV?$unique_ptr@XUhandle_deleter@@@3@V?$shared_ptr@VRGYLog@@@3@PAUCPerfMonitorPrm@@@Z$12
	DD	0cH
	DD	FLAT:__unwindfunclet$?init@CPerfMonitor@@QAEHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDHHHV?$unique_ptr@XUhandle_deleter@@@3@V?$shared_ptr@VRGYLog@@@3@PAUCPerfMonitorPrm@@@Z$13
	DD	0dH
	DD	FLAT:__unwindfunclet$?init@CPerfMonitor@@QAEHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDHHHV?$unique_ptr@XUhandle_deleter@@@3@V?$shared_ptr@VRGYLog@@@3@PAUCPerfMonitorPrm@@@Z$14
	DD	0eH
	DD	FLAT:__unwindfunclet$?init@CPerfMonitor@@QAEHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDHHHV?$unique_ptr@XUhandle_deleter@@@3@V?$shared_ptr@VRGYLog@@@3@PAUCPerfMonitorPrm@@@Z$15
	DD	07H
	DD	FLAT:__unwindfunclet$?init@CPerfMonitor@@QAEHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDHHHV?$unique_ptr@XUhandle_deleter@@@3@V?$shared_ptr@VRGYLog@@@3@PAUCPerfMonitorPrm@@@Z$16
	DD	010H
	DD	FLAT:__unwindfunclet$?init@CPerfMonitor@@QAEHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDHHHV?$unique_ptr@XUhandle_deleter@@@3@V?$shared_ptr@VRGYLog@@@3@PAUCPerfMonitorPrm@@@Z$17
	DD	02H
	DD	FLAT:__unwindfunclet$?init@CPerfMonitor@@QAEHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDHHHV?$unique_ptr@XUhandle_deleter@@@3@V?$shared_ptr@VRGYLog@@@3@PAUCPerfMonitorPrm@@@Z$18
	DD	02H
	DD	FLAT:__unwindfunclet$?init@CPerfMonitor@@QAEHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDHHHV?$unique_ptr@XUhandle_deleter@@@3@V?$shared_ptr@VRGYLog@@@3@PAUCPerfMonitorPrm@@@Z$19
	DD	02H
	DD	FLAT:__unwindfunclet$?init@CPerfMonitor@@QAEHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDHHHV?$unique_ptr@XUhandle_deleter@@@3@V?$shared_ptr@VRGYLog@@@3@PAUCPerfMonitorPrm@@@Z$20
__unwindtable$?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z$3
	DD	00H
	DD	FLAT:__unwindfunclet$?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z$4
	DD	00H
	DD	FLAT:__unwindfunclet$?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z$5
	DD	00H
	DD	FLAT:__unwindfunclet$?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z$6
	DD	00H
	DD	FLAT:__unwindfunclet$?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z$7
	DD	00H
	DD	FLAT:__unwindfunclet$?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z$8
	DD	00H
	DD	FLAT:__unwindfunclet$?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z$9
	DD	00H
	DD	FLAT:__unwindfunclet$?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z$10
	DD	00H
	DD	FLAT:__unwindfunclet$?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z$11
	DD	00H
	DD	FLAT:__unwindfunclet$?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z$12
	DD	00H
	DD	FLAT:__unwindfunclet$?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z$13
	DD	00H
	DD	FLAT:__unwindfunclet$?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z$14
	DD	00H
	DD	FLAT:__unwindfunclet$?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z$15
	DD	00H
	DD	FLAT:__unwindfunclet$?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z$16
	DD	00H
	DD	FLAT:__unwindfunclet$?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z$17
	DD	00H
	DD	FLAT:__unwindfunclet$?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z$18
	DD	00H
	DD	FLAT:__unwindfunclet$?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z$19
	DD	00H
	DD	FLAT:__unwindfunclet$?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z$20
	DD	00H
	DD	FLAT:__unwindfunclet$?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z$21
	DD	00H
	DD	FLAT:__unwindfunclet$?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z$22
	DD	00H
	DD	FLAT:__unwindfunclet$?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z$23
	DD	00H
	DD	FLAT:__unwindfunclet$?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z$24
	DD	00H
	DD	FLAT:__unwindfunclet$?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z$25
	DD	00H
	DD	FLAT:__unwindfunclet$?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z$26
	DD	00H
	DD	FLAT:__unwindfunclet$?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z$27
	DD	00H
	DD	FLAT:__unwindfunclet$?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z$28
	DD	00H
	DD	FLAT:__unwindfunclet$?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z$29
	DD	00H
	DD	FLAT:__unwindfunclet$?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z$30
	DD	00H
	DD	FLAT:__unwindfunclet$?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z$31
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z$0
__ehfuncinfo$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@ABV10@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@ABV10@@Z$0
__ehfuncinfo$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@ABV10@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@ABV10@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0
__ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@U?$integral_constant@_N$00@2@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z$1
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?move@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?copy@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??4thread@std@@QAEAAV01@$$QAV01@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Swap_proxy_and_iterators@_Container_base12@std@@QAEXAAU12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Swap_proxy_and_iterators@_Container_base12@std@@QAEXAAU12@@Z$0
__ehfuncinfo$?_Swap_proxy_and_iterators@_Container_base12@std@@QAEXAAU12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Swap_proxy_and_iterators@_Container_base12@std@@QAEXAAU12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0
__ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0bad_array_new_length@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0bad_array_new_length@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0bad_array_new_length@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0bad_array_new_length@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1bad_array_new_length@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1bad_array_new_length@std@@UAE@XZ$0
__ehfuncinfo$??1bad_array_new_length@std@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1bad_array_new_length@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0bad_array_new_length@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0bad_array_new_length@std@@QAE@XZ$0
__ehfuncinfo$??0bad_array_new_length@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0bad_array_new_length@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0bad_alloc@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0bad_alloc@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0bad_alloc@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0bad_alloc@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1bad_alloc@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1bad_alloc@std@@UAE@XZ$0
__ehfuncinfo$??1bad_alloc@std@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1bad_alloc@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0bad_alloc@std@@AAE@QBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0bad_alloc@std@@AAE@QBD@Z$0
__ehfuncinfo$??0bad_alloc@std@@AAE@QBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0bad_alloc@std@@AAE@QBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1exception@std@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0exception@std@@QAE@ABV01@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?now@system_clock@chrono@std@@SA?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
CRT$XCU	SEGMENT
?CspTransferList$initializer$@@3P6AXXZA DD FLAT:??__ECspTransferList@@YAXXZ ; CspTransferList$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?CspColorprimList$initializer$@@3P6AXXZA DD FLAT:??__ECspColorprimList@@YAXXZ ; CspColorprimList$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\chrono
;	COMDAT ??$?0NX@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABN@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??$?0NX@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABN@Z PROC ; std::chrono::duration<double,std::ratio<1,1000000000> >::duration<double,std::ratio<1,1000000000> ><double,void>, COMDAT
; _this$ = ecx

; 78   :             : _MyRep(static_cast<_Rep>(_Val)) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 4d 08	 mov	 ecx, DWORD PTR __Val$[ebp]
  00014	f2 0f 10 01	 movsd	 xmm0, QWORD PTR [ecx]
  00018	f2 0f 11 00	 movsd	 QWORD PTR [eax], xmm0
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
??$?0NX@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABN@Z ENDP ; std::chrono::duration<double,std::ratio<1,1000000000> >::duration<double,std::ratio<1,1000000000> ><double,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\tuple
;	COMDAT ??$?0PAVCPerfMonitor@@@?$_Tuple_val@PAVCPerfMonitor@@@std@@QAE@$$QAPAVCPerfMonitor@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Arg$ = 8						; size = 4
??$?0PAVCPerfMonitor@@@?$_Tuple_val@PAVCPerfMonitor@@@std@@QAE@$$QAPAVCPerfMonitor@@@Z PROC ; std::_Tuple_val<CPerfMonitor *>::_Tuple_val<CPerfMonitor *><CPerfMonitor *>, COMDAT
; _this$ = ecx

; 155  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) { // construct with argument

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$forward@PAVCPerfMonitor@@@std@@YA$$QAPAVCPerfMonitor@@AAPAV1@@Z ; std::forward<CPerfMonitor *>
  00017	83 c4 04	 add	 esp, 4
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	8b 10		 mov	 edx, DWORD PTR [eax]
  0001f	89 11		 mov	 DWORD PTR [ecx], edx

; 156  :     }

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	83 c4 04	 add	 esp, 4
  00027	3b ec		 cmp	 ebp, esp
  00029	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
??$?0PAVCPerfMonitor@@@?$_Tuple_val@PAVCPerfMonitor@@@std@@QAE@$$QAPAVCPerfMonitor@@@Z ENDP ; std::_Tuple_val<CPerfMonitor *>::_Tuple_val<CPerfMonitor *><CPerfMonitor *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\tuple
;	COMDAT ??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QAE@U_Exact_args_t@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QAE@U_Exact_args_t@1@@Z PROC ; std::tuple<>::tuple<><std::_Exact_args_t,0>, COMDAT
; _this$ = ecx

; 214  :     constexpr tuple(_Tag) noexcept { // strengthened, construct from one arg per element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 215  :     }

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QAE@U_Exact_args_t@1@@Z ENDP ; std::tuple<>::tuple<><std::_Exact_args_t,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\chrono
;	COMDAT ??$duration_cast@V?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@X@chrono@std@@YA?AV?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z
_TEXT	SEGMENT
$T1 = -36						; size = 8
$T2 = -28						; size = 8
$T3 = -20						; size = 8
$T4 = -12						; size = 8
__Den_is_one$ = -2					; size = 1
__Num_is_one$ = -1					; size = 1
___$ReturnUdt$ = 8					; size = 4
__Dur$ = 12						; size = 4
??$duration_cast@V?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@X@chrono@std@@YA?AV?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z PROC ; std::chrono::duration_cast<std::chrono::duration<double,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000000000>,void>, COMDAT

; 397  :         _NOEXCEPT_COND(is_arithmetic_v<_Rep>&& is_arithmetic_v<typename _To::rep>) { // strengthened

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 dc	 mov	 DWORD PTR [ebp-36], eax
  0000e	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  00011	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  00014	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00017	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0001a	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0001d	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00020	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00023	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 398  :         // convert duration to another duration; truncate
; 399  :         using _CF = ratio_divide<_Period, typename _To::period>;
; 400  : 
; 401  :         using _ToRep = typename _To::rep;
; 402  :         using _CR    = common_type_t<_ToRep, _Rep, intmax_t>;
; 403  : 
; 404  :         constexpr bool _Num_is_one = _CF::num == 1;

  00026	c6 45 ff 01	 mov	 BYTE PTR __Num_is_one$[ebp], 1

; 405  :         constexpr bool _Den_is_one = _CF::den == 1;

  0002a	c6 45 fe 01	 mov	 BYTE PTR __Den_is_one$[ebp], 1

; 406  : 
; 407  :         if (_Den_is_one) {

  0002e	b8 01 00 00 00	 mov	 eax, 1
  00033	85 c0		 test	 eax, eax
  00035	74 62		 je	 SHORT $LN2@duration_c

; 408  :             if (_Num_is_one) {

  00037	b9 01 00 00 00	 mov	 ecx, 1
  0003c	85 c9		 test	 ecx, ecx
  0003e	74 2a		 je	 SHORT $LN4@duration_c

; 409  :                 return static_cast<_To>(static_cast<_ToRep>(_Dur.count()));

  00040	8b 4d 0c	 mov	 ecx, DWORD PTR __Dur$[ebp]
  00043	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
  00048	8b c8		 mov	 ecx, eax
  0004a	e8 00 00 00 00	 call	 __ltod3
  0004f	f2 0f 11 45 f4	 movsd	 QWORD PTR $T4[ebp], xmm0
  00054	8d 55 f4	 lea	 edx, DWORD PTR $T4[ebp]
  00057	52		 push	 edx
  00058	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0005b	e8 00 00 00 00	 call	 ??$?0NX@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABN@Z ; std::chrono::duration<double,std::ratio<1,1000000000> >::duration<double,std::ratio<1,1000000000> ><double,void>
  00060	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00063	e9 9c 00 00 00	 jmp	 $LN7@duration_c

; 410  :             } else {

  00068	eb 2d		 jmp	 SHORT $LN5@duration_c
$LN4@duration_c:

; 411  :                 return static_cast<_To>(

  0006a	8b 4d 0c	 mov	 ecx, DWORD PTR __Dur$[ebp]
  0006d	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
  00072	8b c8		 mov	 ecx, eax
  00074	e8 00 00 00 00	 call	 __ltod3
  00079	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3ff0000000000000
  00081	f2 0f 11 45 ec	 movsd	 QWORD PTR $T3[ebp], xmm0
  00086	8d 45 ec	 lea	 eax, DWORD PTR $T3[ebp]
  00089	50		 push	 eax
  0008a	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0008d	e8 00 00 00 00	 call	 ??$?0NX@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABN@Z ; std::chrono::duration<double,std::ratio<1,1000000000> >::duration<double,std::ratio<1,1000000000> ><double,void>
  00092	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00095	eb 6d		 jmp	 SHORT $LN7@duration_c
$LN5@duration_c:

; 412  :                     static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num)));
; 413  :             }
; 414  :         } else {

  00097	eb 6b		 jmp	 SHORT $LN7@duration_c
$LN2@duration_c:

; 415  :             if (_Num_is_one) {

  00099	b9 01 00 00 00	 mov	 ecx, 1
  0009e	85 c9		 test	 ecx, ecx
  000a0	74 2f		 je	 SHORT $LN6@duration_c

; 416  :                 return static_cast<_To>(

  000a2	8b 4d 0c	 mov	 ecx, DWORD PTR __Dur$[ebp]
  000a5	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
  000aa	8b c8		 mov	 ecx, eax
  000ac	e8 00 00 00 00	 call	 __ltod3
  000b1	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@3ff0000000000000
  000b9	f2 0f 11 45 e4	 movsd	 QWORD PTR $T2[ebp], xmm0
  000be	8d 55 e4	 lea	 edx, DWORD PTR $T2[ebp]
  000c1	52		 push	 edx
  000c2	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  000c5	e8 00 00 00 00	 call	 ??$?0NX@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABN@Z ; std::chrono::duration<double,std::ratio<1,1000000000> >::duration<double,std::ratio<1,1000000000> ><double,void>
  000ca	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000cd	eb 35		 jmp	 SHORT $LN7@duration_c

; 417  :                     static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) / static_cast<_CR>(_CF::den)));
; 418  :             } else {

  000cf	eb 33		 jmp	 SHORT $LN7@duration_c
$LN6@duration_c:

; 419  :                 return static_cast<_To>(static_cast<_ToRep>(

  000d1	8b 4d 0c	 mov	 ecx, DWORD PTR __Dur$[ebp]
  000d4	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
  000d9	8b c8		 mov	 ecx, eax
  000db	e8 00 00 00 00	 call	 __ltod3
  000e0	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3ff0000000000000
  000e8	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@3ff0000000000000
  000f0	f2 0f 11 45 dc	 movsd	 QWORD PTR $T1[ebp], xmm0
  000f5	8d 45 dc	 lea	 eax, DWORD PTR $T1[ebp]
  000f8	50		 push	 eax
  000f9	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  000fc	e8 00 00 00 00	 call	 ??$?0NX@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABN@Z ; std::chrono::duration<double,std::ratio<1,1000000000> >::duration<double,std::ratio<1,1000000000> ><double,void>
  00101	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN7@duration_c:

; 420  :                     static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num) / static_cast<_CR>(_CF::den)));
; 421  :             }
; 422  :         }
; 423  :     }

  00104	83 c4 24	 add	 esp, 36			; 00000024H
  00107	3b ec		 cmp	 ebp, esp
  00109	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0010e	8b e5		 mov	 esp, ebp
  00110	5d		 pop	 ebp
  00111	c3		 ret	 0
??$duration_cast@V?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@X@chrono@std@@YA?AV?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z ENDP ; std::chrono::duration_cast<std::chrono::duration<double,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000000000>,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\chrono
;	COMDAT ??$duration_cast@V?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@NU?$ratio@$00$00@3@X@chrono@std@@YA?AV?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@NU?$ratio@$00$00@std@@@01@@Z
_TEXT	SEGMENT
tv143 = -60						; size = 8
tv137 = -52						; size = 8
tv130 = -44						; size = 8
$T1 = -36						; size = 8
$T2 = -28						; size = 8
$T3 = -20						; size = 8
$T4 = -12						; size = 8
__Den_is_one$ = -2					; size = 1
__Num_is_one$ = -1					; size = 1
___$ReturnUdt$ = 8					; size = 4
__Dur$ = 12						; size = 4
??$duration_cast@V?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@NU?$ratio@$00$00@3@X@chrono@std@@YA?AV?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@NU?$ratio@$00$00@std@@@01@@Z PROC ; std::chrono::duration_cast<std::chrono::duration<double,std::ratio<1,1000000000> >,double,std::ratio<1,1>,void>, COMDAT

; 397  :         _NOEXCEPT_COND(is_arithmetic_v<_Rep>&& is_arithmetic_v<typename _To::rep>) { // strengthened

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	57		 push	 edi
  00007	8d 7d c4	 lea	 edi, DWORD PTR [ebp-60]
  0000a	b9 0f 00 00 00	 mov	 ecx, 15			; 0000000fH
  0000f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00014	f3 ab		 rep stosd

; 398  :         // convert duration to another duration; truncate
; 399  :         using _CF = ratio_divide<_Period, typename _To::period>;
; 400  : 
; 401  :         using _ToRep = typename _To::rep;
; 402  :         using _CR    = common_type_t<_ToRep, _Rep, intmax_t>;
; 403  : 
; 404  :         constexpr bool _Num_is_one = _CF::num == 1;

  00016	c6 45 ff 00	 mov	 BYTE PTR __Num_is_one$[ebp], 0

; 405  :         constexpr bool _Den_is_one = _CF::den == 1;

  0001a	c6 45 fe 01	 mov	 BYTE PTR __Den_is_one$[ebp], 1

; 406  : 
; 407  :         if (_Den_is_one) {

  0001e	b8 01 00 00 00	 mov	 eax, 1
  00023	85 c0		 test	 eax, eax
  00025	74 55		 je	 SHORT $LN2@duration_c

; 408  :             if (_Num_is_one) {

  00027	33 c9		 xor	 ecx, ecx
  00029	74 21		 je	 SHORT $LN4@duration_c

; 409  :                 return static_cast<_To>(static_cast<_ToRep>(_Dur.count()));

  0002b	8b 4d 0c	 mov	 ecx, DWORD PTR __Dur$[ebp]
  0002e	e8 00 00 00 00	 call	 ?count@?$duration@NU?$ratio@$00$00@std@@@chrono@std@@QBENXZ ; std::chrono::duration<double,std::ratio<1,1> >::count
  00033	dd 5d f4	 fstp	 QWORD PTR $T4[ebp]
  00036	8d 55 f4	 lea	 edx, DWORD PTR $T4[ebp]
  00039	52		 push	 edx
  0003a	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0003d	e8 00 00 00 00	 call	 ??$?0NX@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABN@Z ; std::chrono::duration<double,std::ratio<1,1000000000> >::duration<double,std::ratio<1,1000000000> ><double,void>
  00042	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00045	e9 9a 00 00 00	 jmp	 $LN7@duration_c

; 410  :             } else {

  0004a	eb 2e		 jmp	 SHORT $LN5@duration_c
$LN4@duration_c:

; 411  :                 return static_cast<_To>(

  0004c	8b 4d 0c	 mov	 ecx, DWORD PTR __Dur$[ebp]
  0004f	e8 00 00 00 00	 call	 ?count@?$duration@NU?$ratio@$00$00@std@@@chrono@std@@QBENXZ ; std::chrono::duration<double,std::ratio<1,1> >::count
  00054	dd 5d d4	 fstp	 QWORD PTR tv130[ebp]
  00057	f2 0f 10 45 d4	 movsd	 xmm0, QWORD PTR tv130[ebp]
  0005c	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@41cdcd6500000000
  00064	f2 0f 11 45 ec	 movsd	 QWORD PTR $T3[ebp], xmm0
  00069	8d 45 ec	 lea	 eax, DWORD PTR $T3[ebp]
  0006c	50		 push	 eax
  0006d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00070	e8 00 00 00 00	 call	 ??$?0NX@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABN@Z ; std::chrono::duration<double,std::ratio<1,1000000000> >::duration<double,std::ratio<1,1000000000> ><double,void>
  00075	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00078	eb 6a		 jmp	 SHORT $LN7@duration_c
$LN5@duration_c:

; 412  :                     static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num)));
; 413  :             }
; 414  :         } else {

  0007a	eb 68		 jmp	 SHORT $LN7@duration_c
$LN2@duration_c:

; 415  :             if (_Num_is_one) {

  0007c	33 c9		 xor	 ecx, ecx
  0007e	74 30		 je	 SHORT $LN6@duration_c

; 416  :                 return static_cast<_To>(

  00080	8b 4d 0c	 mov	 ecx, DWORD PTR __Dur$[ebp]
  00083	e8 00 00 00 00	 call	 ?count@?$duration@NU?$ratio@$00$00@std@@@chrono@std@@QBENXZ ; std::chrono::duration<double,std::ratio<1,1> >::count
  00088	dd 5d cc	 fstp	 QWORD PTR tv137[ebp]
  0008b	f2 0f 10 45 cc	 movsd	 xmm0, QWORD PTR tv137[ebp]
  00090	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@3ff0000000000000
  00098	f2 0f 11 45 e4	 movsd	 QWORD PTR $T2[ebp], xmm0
  0009d	8d 55 e4	 lea	 edx, DWORD PTR $T2[ebp]
  000a0	52		 push	 edx
  000a1	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  000a4	e8 00 00 00 00	 call	 ??$?0NX@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABN@Z ; std::chrono::duration<double,std::ratio<1,1000000000> >::duration<double,std::ratio<1,1000000000> ><double,void>
  000a9	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000ac	eb 36		 jmp	 SHORT $LN7@duration_c

; 417  :                     static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) / static_cast<_CR>(_CF::den)));
; 418  :             } else {

  000ae	eb 34		 jmp	 SHORT $LN7@duration_c
$LN6@duration_c:

; 419  :                 return static_cast<_To>(static_cast<_ToRep>(

  000b0	8b 4d 0c	 mov	 ecx, DWORD PTR __Dur$[ebp]
  000b3	e8 00 00 00 00	 call	 ?count@?$duration@NU?$ratio@$00$00@std@@@chrono@std@@QBENXZ ; std::chrono::duration<double,std::ratio<1,1> >::count
  000b8	dd 5d c4	 fstp	 QWORD PTR tv143[ebp]
  000bb	f2 0f 10 45 c4	 movsd	 xmm0, QWORD PTR tv143[ebp]
  000c0	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@41cdcd6500000000
  000c8	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@3ff0000000000000
  000d0	f2 0f 11 45 dc	 movsd	 QWORD PTR $T1[ebp], xmm0
  000d5	8d 45 dc	 lea	 eax, DWORD PTR $T1[ebp]
  000d8	50		 push	 eax
  000d9	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  000dc	e8 00 00 00 00	 call	 ??$?0NX@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABN@Z ; std::chrono::duration<double,std::ratio<1,1000000000> >::duration<double,std::ratio<1,1000000000> ><double,void>
  000e1	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN7@duration_c:

; 420  :                     static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num) / static_cast<_CR>(_CF::den)));
; 421  :             }
; 422  :         }
; 423  :     }

  000e4	5f		 pop	 edi
  000e5	83 c4 3c	 add	 esp, 60			; 0000003cH
  000e8	3b ec		 cmp	 ebp, esp
  000ea	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ef	8b e5		 mov	 esp, ebp
  000f1	5d		 pop	 ebp
  000f2	c3		 ret	 0
??$duration_cast@V?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@NU?$ratio@$00$00@3@X@chrono@std@@YA?AV?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@NU?$ratio@$00$00@std@@@01@@Z ENDP ; std::chrono::duration_cast<std::chrono::duration<double,std::ratio<1,1000000000> >,double,std::ratio<1,1>,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\type_traits
;	COMDAT ??$forward@AAPAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@std@@YAAAPAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@0@AAPAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@std@@YAAAPAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@0@AAPAV10@@Z PROC ; std::forward<std::tuple<void (__cdecl*)(void *),CPerfMonitor *> * &>, COMDAT

; 1420 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1421 :     return static_cast<_Ty&&>(_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1422 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAPAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@std@@YAAAPAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@0@AAPAV10@@Z ENDP ; std::forward<std::tuple<void (__cdecl*)(void *),CPerfMonitor *> * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\tuple
;	COMDAT ??$?0A6AXPAX@Z@?$_Tuple_val@P6AXPAX@Z@std@@QAE@A6AXPAX@Z@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Arg$ = 8						; size = 4
??$?0A6AXPAX@Z@?$_Tuple_val@P6AXPAX@Z@std@@QAE@A6AXPAX@Z@Z PROC ; std::_Tuple_val<void (__cdecl*)(void *)>::_Tuple_val<void (__cdecl*)(void *)><void (__cdecl&)(void *)>, COMDAT
; _this$ = ecx

; 155  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) { // construct with argument

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$forward@A6AXPAX@Z@std@@YAA6AXPAX@ZA6AX0@Z@Z ; std::forward<void (__cdecl&)(void *)>
  00017	83 c4 04	 add	 esp, 4
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	89 01		 mov	 DWORD PTR [ecx], eax

; 156  :     }

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	83 c4 04	 add	 esp, 4
  00025	3b ec		 cmp	 ebp, esp
  00027	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c2 04 00	 ret	 4
??$?0A6AXPAX@Z@?$_Tuple_val@P6AXPAX@Z@std@@QAE@A6AXPAX@Z@Z ENDP ; std::_Tuple_val<void (__cdecl*)(void *)>::_Tuple_val<void (__cdecl*)(void *)><void (__cdecl&)(void *)>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\tuple
;	COMDAT ??$?0U_Exact_args_t@std@@PAVCPerfMonitor@@$$V$0A@@?$tuple@PAVCPerfMonitor@@@std@@QAE@U_Exact_args_t@1@$$QAPAVCPerfMonitor@@@Z
_TEXT	SEGMENT
$T1 = -5						; size = 1
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
__This_arg$ = 12					; size = 4
??$?0U_Exact_args_t@std@@PAVCPerfMonitor@@$$V$0A@@?$tuple@PAVCPerfMonitor@@@std@@QAE@U_Exact_args_t@1@$$QAPAVCPerfMonitor@@@Z PROC ; std::tuple<CPerfMonitor *>::tuple<CPerfMonitor *><std::_Exact_args_t,CPerfMonitor *,0>, COMDAT
; _this$ = ecx

; 242  :           _Myfirst(_STD forward<_This2>(_This_arg)) { // construct from one arg per element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 241  :         : _Mybase(_Exact_args_t{}, _STD forward<_Rest2>(_Rest_arg)...),

  00017	33 c0		 xor	 eax, eax
  00019	88 45 fb	 mov	 BYTE PTR $T1[ebp], al
  0001c	0f b6 4d fb	 movzx	 ecx, BYTE PTR $T1[ebp]
  00020	51		 push	 ecx
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QAE@U_Exact_args_t@1@@Z ; std::tuple<>::tuple<><std::_Exact_args_t,0>

; 242  :           _Myfirst(_STD forward<_This2>(_This_arg)) { // construct from one arg per element

  00029	8b 55 0c	 mov	 edx, DWORD PTR __This_arg$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$forward@PAVCPerfMonitor@@@std@@YA$$QAPAVCPerfMonitor@@AAPAV1@@Z ; std::forward<CPerfMonitor *>
  00032	83 c4 04	 add	 esp, 4
  00035	50		 push	 eax
  00036	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	e8 00 00 00 00	 call	 ??$?0PAVCPerfMonitor@@@?$_Tuple_val@PAVCPerfMonitor@@@std@@QAE@$$QAPAVCPerfMonitor@@@Z ; std::_Tuple_val<CPerfMonitor *>::_Tuple_val<CPerfMonitor *><CPerfMonitor *>

; 243  :     }

  0003e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00041	83 c4 08	 add	 esp, 8
  00044	3b ec		 cmp	 ebp, esp
  00046	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c2 08 00	 ret	 8
??$?0U_Exact_args_t@std@@PAVCPerfMonitor@@$$V$0A@@?$tuple@PAVCPerfMonitor@@@std@@QAE@U_Exact_args_t@1@$$QAPAVCPerfMonitor@@@Z ENDP ; std::tuple<CPerfMonitor *>::tuple<CPerfMonitor *><std::_Exact_args_t,CPerfMonitor *,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\chrono
;	COMDAT ??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$00@3@X@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@_JU?$ratio@$00$00@std@@@01@@Z
_TEXT	SEGMENT
$T1 = -36						; size = 8
$T2 = -28						; size = 8
$T3 = -20						; size = 8
$T4 = -12						; size = 8
__Den_is_one$ = -2					; size = 1
__Num_is_one$ = -1					; size = 1
___$ReturnUdt$ = 8					; size = 4
__Dur$ = 12						; size = 4
??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$00@3@X@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@_JU?$ratio@$00$00@std@@@01@@Z PROC ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1>,void>, COMDAT

; 397  :         _NOEXCEPT_COND(is_arithmetic_v<_Rep>&& is_arithmetic_v<typename _To::rep>) { // strengthened

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 dc	 mov	 DWORD PTR [ebp-36], eax
  0000e	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  00011	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  00014	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00017	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0001a	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0001d	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00020	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00023	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 398  :         // convert duration to another duration; truncate
; 399  :         using _CF = ratio_divide<_Period, typename _To::period>;
; 400  : 
; 401  :         using _ToRep = typename _To::rep;
; 402  :         using _CR    = common_type_t<_ToRep, _Rep, intmax_t>;
; 403  : 
; 404  :         constexpr bool _Num_is_one = _CF::num == 1;

  00026	c6 45 ff 00	 mov	 BYTE PTR __Num_is_one$[ebp], 0

; 405  :         constexpr bool _Den_is_one = _CF::den == 1;

  0002a	c6 45 fe 01	 mov	 BYTE PTR __Den_is_one$[ebp], 1

; 406  : 
; 407  :         if (_Den_is_one) {

  0002e	b8 01 00 00 00	 mov	 eax, 1
  00033	85 c0		 test	 eax, eax
  00035	74 57		 je	 SHORT $LN2@duration_c

; 408  :             if (_Num_is_one) {

  00037	33 c9		 xor	 ecx, ecx
  00039	74 24		 je	 SHORT $LN4@duration_c

; 409  :                 return static_cast<_To>(static_cast<_ToRep>(_Dur.count()));

  0003b	8b 4d 0c	 mov	 ecx, DWORD PTR __Dur$[ebp]
  0003e	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1> >::count
  00043	89 45 f4	 mov	 DWORD PTR $T4[ebp], eax
  00046	89 55 f8	 mov	 DWORD PTR $T4[ebp+4], edx
  00049	8d 55 f4	 lea	 edx, DWORD PTR $T4[ebp]
  0004c	52		 push	 edx
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00050	e8 00 00 00 00	 call	 ??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,void>
  00055	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00058	e9 81 00 00 00	 jmp	 $LN1@duration_c

; 410  :             } else {

  0005d	eb 2d		 jmp	 SHORT $LN5@duration_c
$LN4@duration_c:

; 411  :                 return static_cast<_To>(

  0005f	8b 4d 0c	 mov	 ecx, DWORD PTR __Dur$[ebp]
  00062	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1> >::count
  00067	6a 00		 push	 0
  00069	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  0006e	52		 push	 edx
  0006f	50		 push	 eax
  00070	e8 00 00 00 00	 call	 __allmul
  00075	89 45 ec	 mov	 DWORD PTR $T3[ebp], eax
  00078	89 55 f0	 mov	 DWORD PTR $T3[ebp+4], edx
  0007b	8d 45 ec	 lea	 eax, DWORD PTR $T3[ebp]
  0007e	50		 push	 eax
  0007f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00082	e8 00 00 00 00	 call	 ??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,void>
  00087	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0008a	eb 52		 jmp	 SHORT $LN1@duration_c
$LN5@duration_c:

; 412  :                     static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num)));
; 413  :             }
; 414  :         } else {

  0008c	eb 50		 jmp	 SHORT $LN1@duration_c
$LN2@duration_c:

; 415  :             if (_Num_is_one) {

  0008e	33 c9		 xor	 ecx, ecx
  00090	74 21		 je	 SHORT $LN6@duration_c

; 416  :                 return static_cast<_To>(

  00092	8b 4d 0c	 mov	 ecx, DWORD PTR __Dur$[ebp]
  00095	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1> >::count
  0009a	89 45 e4	 mov	 DWORD PTR $T2[ebp], eax
  0009d	89 55 e8	 mov	 DWORD PTR $T2[ebp+4], edx
  000a0	8d 55 e4	 lea	 edx, DWORD PTR $T2[ebp]
  000a3	52		 push	 edx
  000a4	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  000a7	e8 00 00 00 00	 call	 ??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,void>
  000ac	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000af	eb 2d		 jmp	 SHORT $LN1@duration_c

; 417  :                     static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) / static_cast<_CR>(_CF::den)));
; 418  :             } else {

  000b1	eb 2b		 jmp	 SHORT $LN1@duration_c
$LN6@duration_c:

; 419  :                 return static_cast<_To>(static_cast<_ToRep>(

  000b3	8b 4d 0c	 mov	 ecx, DWORD PTR __Dur$[ebp]
  000b6	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1> >::count
  000bb	6a 00		 push	 0
  000bd	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  000c2	52		 push	 edx
  000c3	50		 push	 eax
  000c4	e8 00 00 00 00	 call	 __allmul
  000c9	89 45 dc	 mov	 DWORD PTR $T1[ebp], eax
  000cc	89 55 e0	 mov	 DWORD PTR $T1[ebp+4], edx
  000cf	8d 45 dc	 lea	 eax, DWORD PTR $T1[ebp]
  000d2	50		 push	 eax
  000d3	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  000d6	e8 00 00 00 00	 call	 ??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,void>
  000db	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN1@duration_c:

; 420  :                     static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num) / static_cast<_CR>(_CF::den)));
; 421  :             }
; 422  :         }
; 423  :     }

  000de	83 c4 24	 add	 esp, 36			; 00000024H
  000e1	3b ec		 cmp	 ebp, esp
  000e3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e8	8b e5		 mov	 esp, ebp
  000ea	5d		 pop	 ebp
  000eb	c3		 ret	 0
??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$00@3@X@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@_JU?$ratio@$00$00@std@@@01@@Z ENDP ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1>,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\chrono
;	COMDAT ??$?0_JX@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QAE@AB_J@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??$?0_JX@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QAE@AB_J@Z PROC ; std::chrono::duration<__int64,std::ratio<1,1> >::duration<__int64,std::ratio<1,1> ><__int64,void>, COMDAT
; _this$ = ecx

; 78   :             : _MyRep(static_cast<_Rep>(_Val)) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 4d 08	 mov	 ecx, DWORD PTR __Val$[ebp]
  00014	8b 11		 mov	 edx, DWORD PTR [ecx]
  00016	89 10		 mov	 DWORD PTR [eax], edx
  00018	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0001b	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
??$?0_JX@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QAE@AB_J@Z ENDP ; std::chrono::duration<__int64,std::ratio<1,1> >::duration<__int64,std::ratio<1,1> ><__int64,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\chrono
;	COMDAT ??$?0_JU?$ratio@$00$0DLJKMKAA@@std@@X@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 8
_this$ = -4						; size = 4
__Dur$ = 8						; size = 4
??$?0_JU?$ratio@$00$0DLJKMKAA@@std@@X@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z PROC ; std::chrono::duration<double,std::ratio<1,1000000000> >::duration<double,std::ratio<1,1000000000> ><__int64,std::ratio<1,1000000000>,void>, COMDAT
; _this$ = ecx

; 86   :             : _MyRep(chrono::duration_cast<duration>(_Dur).count()) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0001e	8b 45 08	 mov	 eax, DWORD PTR __Dur$[ebp]
  00021	50		 push	 eax
  00022	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00025	51		 push	 ecx
  00026	e8 00 00 00 00	 call	 ??$duration_cast@V?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@X@chrono@std@@YA?AV?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z ; std::chrono::duration_cast<std::chrono::duration<double,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000000000>,void>
  0002b	83 c4 08	 add	 esp, 8
  0002e	8b c8		 mov	 ecx, eax
  00030	e8 00 00 00 00	 call	 ?count@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBENXZ ; std::chrono::duration<double,std::ratio<1,1000000000> >::count
  00035	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00038	dd 1a		 fstp	 QWORD PTR [edx]
  0003a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
??$?0_JU?$ratio@$00$0DLJKMKAA@@std@@X@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z ENDP ; std::chrono::duration<double,std::ratio<1,1000000000> >::duration<double,std::ratio<1,1000000000> ><__int64,std::ratio<1,1000000000>,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\chrono
;	COMDAT ??$?0NU?$ratio@$00$00@std@@X@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABV?$duration@NU?$ratio@$00$00@std@@@12@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 8
_this$ = -4						; size = 4
__Dur$ = 8						; size = 4
??$?0NU?$ratio@$00$00@std@@X@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABV?$duration@NU?$ratio@$00$00@std@@@12@@Z PROC ; std::chrono::duration<double,std::ratio<1,1000000000> >::duration<double,std::ratio<1,1000000000> ><double,std::ratio<1,1>,void>, COMDAT
; _this$ = ecx

; 86   :             : _MyRep(chrono::duration_cast<duration>(_Dur).count()) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0001e	8b 45 08	 mov	 eax, DWORD PTR __Dur$[ebp]
  00021	50		 push	 eax
  00022	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00025	51		 push	 ecx
  00026	e8 00 00 00 00	 call	 ??$duration_cast@V?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@NU?$ratio@$00$00@3@X@chrono@std@@YA?AV?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@NU?$ratio@$00$00@std@@@01@@Z ; std::chrono::duration_cast<std::chrono::duration<double,std::ratio<1,1000000000> >,double,std::ratio<1,1>,void>
  0002b	83 c4 08	 add	 esp, 8
  0002e	8b c8		 mov	 ecx, eax
  00030	e8 00 00 00 00	 call	 ?count@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBENXZ ; std::chrono::duration<double,std::ratio<1,1000000000> >::count
  00035	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00038	dd 1a		 fstp	 QWORD PTR [edx]
  0003a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
??$?0NU?$ratio@$00$00@std@@X@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABV?$duration@NU?$ratio@$00$00@std@@@12@@Z ENDP ; std::chrono::duration<double,std::ratio<1,1000000000> >::duration<double,std::ratio<1,1000000000> ><double,std::ratio<1,1>,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\chrono
;	COMDAT ??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0JIJGIA@@3@X@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@@Z
_TEXT	SEGMENT
$T1 = -36						; size = 8
$T2 = -28						; size = 8
$T3 = -20						; size = 8
$T4 = -12						; size = 8
__Den_is_one$ = -2					; size = 1
__Num_is_one$ = -1					; size = 1
___$ReturnUdt$ = 8					; size = 4
__Dur$ = 12						; size = 4
??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0JIJGIA@@3@X@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@@Z PROC ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,10000000>,void>, COMDAT

; 397  :         _NOEXCEPT_COND(is_arithmetic_v<_Rep>&& is_arithmetic_v<typename _To::rep>) { // strengthened

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 dc	 mov	 DWORD PTR [ebp-36], eax
  0000e	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  00011	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  00014	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00017	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0001a	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0001d	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00020	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00023	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 398  :         // convert duration to another duration; truncate
; 399  :         using _CF = ratio_divide<_Period, typename _To::period>;
; 400  : 
; 401  :         using _ToRep = typename _To::rep;
; 402  :         using _CR    = common_type_t<_ToRep, _Rep, intmax_t>;
; 403  : 
; 404  :         constexpr bool _Num_is_one = _CF::num == 1;

  00026	c6 45 ff 00	 mov	 BYTE PTR __Num_is_one$[ebp], 0

; 405  :         constexpr bool _Den_is_one = _CF::den == 1;

  0002a	c6 45 fe 01	 mov	 BYTE PTR __Den_is_one$[ebp], 1

; 406  : 
; 407  :         if (_Den_is_one) {

  0002e	b8 01 00 00 00	 mov	 eax, 1
  00033	85 c0		 test	 eax, eax
  00035	74 51		 je	 SHORT $LN2@duration_c

; 408  :             if (_Num_is_one) {

  00037	33 c9		 xor	 ecx, ecx
  00039	74 21		 je	 SHORT $LN4@duration_c

; 409  :                 return static_cast<_To>(static_cast<_ToRep>(_Dur.count()));

  0003b	8b 4d 0c	 mov	 ecx, DWORD PTR __Dur$[ebp]
  0003e	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count
  00043	89 45 f4	 mov	 DWORD PTR $T4[ebp], eax
  00046	89 55 f8	 mov	 DWORD PTR $T4[ebp+4], edx
  00049	8d 55 f4	 lea	 edx, DWORD PTR $T4[ebp]
  0004c	52		 push	 edx
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00050	e8 00 00 00 00	 call	 ??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,void>
  00055	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00058	eb 7b		 jmp	 SHORT $LN1@duration_c

; 410  :             } else {

  0005a	eb 2a		 jmp	 SHORT $LN5@duration_c
$LN4@duration_c:

; 411  :                 return static_cast<_To>(

  0005c	8b 4d 0c	 mov	 ecx, DWORD PTR __Dur$[ebp]
  0005f	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count
  00064	6a 00		 push	 0
  00066	6a 64		 push	 100			; 00000064H
  00068	52		 push	 edx
  00069	50		 push	 eax
  0006a	e8 00 00 00 00	 call	 __allmul
  0006f	89 45 ec	 mov	 DWORD PTR $T3[ebp], eax
  00072	89 55 f0	 mov	 DWORD PTR $T3[ebp+4], edx
  00075	8d 45 ec	 lea	 eax, DWORD PTR $T3[ebp]
  00078	50		 push	 eax
  00079	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0007c	e8 00 00 00 00	 call	 ??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,void>
  00081	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00084	eb 4f		 jmp	 SHORT $LN1@duration_c
$LN5@duration_c:

; 412  :                     static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num)));
; 413  :             }
; 414  :         } else {

  00086	eb 4d		 jmp	 SHORT $LN1@duration_c
$LN2@duration_c:

; 415  :             if (_Num_is_one) {

  00088	33 c9		 xor	 ecx, ecx
  0008a	74 21		 je	 SHORT $LN6@duration_c

; 416  :                 return static_cast<_To>(

  0008c	8b 4d 0c	 mov	 ecx, DWORD PTR __Dur$[ebp]
  0008f	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count
  00094	89 45 e4	 mov	 DWORD PTR $T2[ebp], eax
  00097	89 55 e8	 mov	 DWORD PTR $T2[ebp+4], edx
  0009a	8d 55 e4	 lea	 edx, DWORD PTR $T2[ebp]
  0009d	52		 push	 edx
  0009e	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  000a1	e8 00 00 00 00	 call	 ??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,void>
  000a6	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000a9	eb 2a		 jmp	 SHORT $LN1@duration_c

; 417  :                     static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) / static_cast<_CR>(_CF::den)));
; 418  :             } else {

  000ab	eb 28		 jmp	 SHORT $LN1@duration_c
$LN6@duration_c:

; 419  :                 return static_cast<_To>(static_cast<_ToRep>(

  000ad	8b 4d 0c	 mov	 ecx, DWORD PTR __Dur$[ebp]
  000b0	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count
  000b5	6a 00		 push	 0
  000b7	6a 64		 push	 100			; 00000064H
  000b9	52		 push	 edx
  000ba	50		 push	 eax
  000bb	e8 00 00 00 00	 call	 __allmul
  000c0	89 45 dc	 mov	 DWORD PTR $T1[ebp], eax
  000c3	89 55 e0	 mov	 DWORD PTR $T1[ebp+4], edx
  000c6	8d 45 dc	 lea	 eax, DWORD PTR $T1[ebp]
  000c9	50		 push	 eax
  000ca	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  000cd	e8 00 00 00 00	 call	 ??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,void>
  000d2	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN1@duration_c:

; 420  :                     static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num) / static_cast<_CR>(_CF::den)));
; 421  :             }
; 422  :         }
; 423  :     }

  000d5	83 c4 24	 add	 esp, 36			; 00000024H
  000d8	3b ec		 cmp	 ebp, esp
  000da	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000df	8b e5		 mov	 esp, ebp
  000e1	5d		 pop	 ebp
  000e2	c3		 ret	 0
??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0JIJGIA@@3@X@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@@Z ENDP ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,10000000>,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\chrono
;	COMDAT ??$?M_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YA_NABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@0@Z
_TEXT	SEGMENT
tv71 = -36						; size = 4
tv94 = -32						; size = 8
tv91 = -24						; size = 8
$T1 = -16						; size = 8
$T2 = -8						; size = 8
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?M_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YA_NABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@0@Z PROC ; std::chrono::operator<<__int64,std::ratio<1,1000000000>,__int64,std::ratio<1,1000000000> >, COMDAT

; 365  :         _NOEXCEPT_COND(is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>) { // strengthened

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000d	89 45 dc	 mov	 DWORD PTR [ebp-36], eax
  00010	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  00013	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  00016	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00019	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0001c	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0001f	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00022	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00025	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 366  :         // test if duration < duration
; 367  :         using _CT = common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>;
; 368  :         return _CT(_Left).count() < _CT(_Right).count();

  00028	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  0002b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002d	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00030	89 4d f8	 mov	 DWORD PTR $T2[ebp], ecx
  00033	89 55 fc	 mov	 DWORD PTR $T2[ebp+4], edx
  00036	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00039	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003b	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0003e	89 4d f0	 mov	 DWORD PTR $T1[ebp], ecx
  00041	89 55 f4	 mov	 DWORD PTR $T1[ebp+4], edx
  00044	8d 4d f8	 lea	 ecx, DWORD PTR $T2[ebp]
  00047	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
  0004c	8b f0		 mov	 esi, eax
  0004e	8b fa		 mov	 edi, edx
  00050	8d 4d f0	 lea	 ecx, DWORD PTR $T1[ebp]
  00053	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
  00058	89 75 e8	 mov	 DWORD PTR tv91[ebp], esi
  0005b	89 7d ec	 mov	 DWORD PTR tv91[ebp+4], edi
  0005e	89 45 e0	 mov	 DWORD PTR tv94[ebp], eax
  00061	89 55 e4	 mov	 DWORD PTR tv94[ebp+4], edx
  00064	8b 45 ec	 mov	 eax, DWORD PTR tv91[ebp+4]
  00067	3b 45 e4	 cmp	 eax, DWORD PTR tv94[ebp+4]
  0006a	7f 13		 jg	 SHORT $LN3@operator
  0006c	7c 08		 jl	 SHORT $LN5@operator
  0006e	8b 4d e8	 mov	 ecx, DWORD PTR tv91[ebp]
  00071	3b 4d e0	 cmp	 ecx, DWORD PTR tv94[ebp]
  00074	73 09		 jae	 SHORT $LN3@operator
$LN5@operator:
  00076	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR tv71[ebp], 1
  0007d	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  0007f	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
$LN4@operator:
  00086	8a 45 dc	 mov	 al, BYTE PTR tv71[ebp]

; 369  :     }

  00089	5f		 pop	 edi
  0008a	5e		 pop	 esi
  0008b	83 c4 24	 add	 esp, 36			; 00000024H
  0008e	3b ec		 cmp	 ebp, esp
  00090	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00095	8b e5		 mov	 esp, ebp
  00097	5d		 pop	 ebp
  00098	c3		 ret	 0
??$?M_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YA_NABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@0@Z ENDP ; std::chrono::operator<<__int64,std::ratio<1,1000000000>,__int64,std::ratio<1,1000000000> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ??$?0AAPAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@std@@PAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
_<_Val2_0>$ = 12					; size = 4
??$?0AAPAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@std@@PAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@1@@Z PROC ; std::_Compressed_pair<std::default_delete<std::tuple<void (__cdecl*)(void *),CPerfMonitor *> >,std::tuple<void (__cdecl*)(void *),CPerfMonitor *> *,1>::_Compressed_pair<std::default_delete<std::tuple<void (__cdecl*)(void *),CPerfMonitor *> >,std::tuple<void (__cdecl*)(void *),CPerfMonitor *> *,1><std::tuple<void (__cdecl*)(void *),CPerfMonitor *> * &>, COMDAT
; _this$ = ecx

; 1414 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 0c	 mov	 eax, DWORD PTR _<_Val2_0>$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$forward@AAPAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@std@@YAAAPAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@0@AAPAV10@@Z ; std::forward<std::tuple<void (__cdecl*)(void *),CPerfMonitor *> * &>
  00017	83 c4 04	 add	 esp, 4
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	8b 10		 mov	 edx, DWORD PTR [eax]
  0001f	89 11		 mov	 DWORD PTR [ecx], edx
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	83 c4 04	 add	 esp, 4
  00027	3b ec		 cmp	 ebp, esp
  00029	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 08 00	 ret	 8
??$?0AAPAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@std@@PAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@1@@Z ENDP ; std::_Compressed_pair<std::default_delete<std::tuple<void (__cdecl*)(void *),CPerfMonitor *> >,std::tuple<void (__cdecl*)(void *),CPerfMonitor *> *,1>::_Compressed_pair<std::default_delete<std::tuple<void (__cdecl*)(void *),CPerfMonitor *> >,std::tuple<void (__cdecl*)(void *),CPerfMonitor *> *,1><std::tuple<void (__cdecl*)(void *),CPerfMonitor *> * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\tuple
;	COMDAT ??$?0U_Exact_args_t@std@@A6AXPAX@ZPAVCPerfMonitor@@$0A@@?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@QAE@U_Exact_args_t@1@A6AXPAX@Z$$QAPAVCPerfMonitor@@@Z
_TEXT	SEGMENT
$T1 = -5						; size = 1
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
__This_arg$ = 12					; size = 4
_<_Rest_arg_0>$ = 16					; size = 4
??$?0U_Exact_args_t@std@@A6AXPAX@ZPAVCPerfMonitor@@$0A@@?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@QAE@U_Exact_args_t@1@A6AXPAX@Z$$QAPAVCPerfMonitor@@@Z PROC ; std::tuple<void (__cdecl*)(void *),CPerfMonitor *>::tuple<void (__cdecl*)(void *),CPerfMonitor *><std::_Exact_args_t,void (__cdecl&)(void *),CPerfMonitor *,0>, COMDAT
; _this$ = ecx

; 242  :           _Myfirst(_STD forward<_This2>(_This_arg)) { // construct from one arg per element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 241  :         : _Mybase(_Exact_args_t{}, _STD forward<_Rest2>(_Rest_arg)...),

  00017	33 c0		 xor	 eax, eax
  00019	88 45 fb	 mov	 BYTE PTR $T1[ebp], al
  0001c	8b 4d 10	 mov	 ecx, DWORD PTR _<_Rest_arg_0>$[ebp]
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ??$forward@PAVCPerfMonitor@@@std@@YA$$QAPAVCPerfMonitor@@AAPAV1@@Z ; std::forward<CPerfMonitor *>
  00025	83 c4 04	 add	 esp, 4
  00028	50		 push	 eax
  00029	0f b6 55 fb	 movzx	 edx, BYTE PTR $T1[ebp]
  0002d	52		 push	 edx
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ??$?0U_Exact_args_t@std@@PAVCPerfMonitor@@$$V$0A@@?$tuple@PAVCPerfMonitor@@@std@@QAE@U_Exact_args_t@1@$$QAPAVCPerfMonitor@@@Z ; std::tuple<CPerfMonitor *>::tuple<CPerfMonitor *><std::_Exact_args_t,CPerfMonitor *,0>

; 242  :           _Myfirst(_STD forward<_This2>(_This_arg)) { // construct from one arg per element

  00036	8b 45 0c	 mov	 eax, DWORD PTR __This_arg$[ebp]
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 ??$forward@A6AXPAX@Z@std@@YAA6AXPAX@ZA6AX0@Z@Z ; std::forward<void (__cdecl&)(void *)>
  0003f	83 c4 04	 add	 esp, 4
  00042	50		 push	 eax
  00043	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	83 c1 04	 add	 ecx, 4
  00049	e8 00 00 00 00	 call	 ??$?0A6AXPAX@Z@?$_Tuple_val@P6AXPAX@Z@std@@QAE@A6AXPAX@Z@Z ; std::_Tuple_val<void (__cdecl*)(void *)>::_Tuple_val<void (__cdecl*)(void *)><void (__cdecl&)(void *)>

; 243  :     }

  0004e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00051	83 c4 08	 add	 esp, 8
  00054	3b ec		 cmp	 ebp, esp
  00056	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c2 0c 00	 ret	 12			; 0000000cH
??$?0U_Exact_args_t@std@@A6AXPAX@ZPAVCPerfMonitor@@$0A@@?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@QAE@U_Exact_args_t@1@A6AXPAX@Z$$QAPAVCPerfMonitor@@@Z ENDP ; std::tuple<void (__cdecl*)(void *),CPerfMonitor *>::tuple<void (__cdecl*)(void *),CPerfMonitor *><std::_Exact_args_t,void (__cdecl&)(void *),CPerfMonitor *,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\chrono
;	COMDAT ??$?0_JU?$ratio@$00$00@std@@X@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$00@std@@@12@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 8
_this$ = -4						; size = 4
__Dur$ = 8						; size = 4
??$?0_JU?$ratio@$00$00@std@@X@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$00@std@@@12@@Z PROC ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,std::ratio<1,1>,void>, COMDAT
; _this$ = ecx

; 86   :             : _MyRep(chrono::duration_cast<duration>(_Dur).count()) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0001e	8b 45 08	 mov	 eax, DWORD PTR __Dur$[ebp]
  00021	50		 push	 eax
  00022	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00025	51		 push	 ecx
  00026	e8 00 00 00 00	 call	 ??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$00@3@X@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@_JU?$ratio@$00$00@std@@@01@@Z ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1>,void>
  0002b	83 c4 08	 add	 esp, 8
  0002e	8b c8		 mov	 ecx, eax
  00030	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
  00035	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	89 01		 mov	 DWORD PTR [ecx], eax
  0003a	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0003d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00040	83 c4 0c	 add	 esp, 12			; 0000000cH
  00043	3b ec		 cmp	 ebp, esp
  00045	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 04 00	 ret	 4
??$?0_JU?$ratio@$00$00@std@@X@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$00@std@@@12@@Z ENDP ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,std::ratio<1,1>,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\chrono
;	COMDAT ??$duration_cast@V?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@X@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$00@std@@@01@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z
_TEXT	SEGMENT
$T1 = -36						; size = 8
$T2 = -28						; size = 8
$T3 = -20						; size = 8
$T4 = -12						; size = 8
__Den_is_one$ = -2					; size = 1
__Num_is_one$ = -1					; size = 1
___$ReturnUdt$ = 8					; size = 4
__Dur$ = 12						; size = 4
??$duration_cast@V?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@X@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$00@std@@@01@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z PROC ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1> >,__int64,std::ratio<1,1000000000>,void>, COMDAT

; 397  :         _NOEXCEPT_COND(is_arithmetic_v<_Rep>&& is_arithmetic_v<typename _To::rep>) { // strengthened

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 dc	 mov	 DWORD PTR [ebp-36], eax
  0000e	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  00011	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  00014	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00017	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0001a	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0001d	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00020	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00023	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 398  :         // convert duration to another duration; truncate
; 399  :         using _CF = ratio_divide<_Period, typename _To::period>;
; 400  : 
; 401  :         using _ToRep = typename _To::rep;
; 402  :         using _CR    = common_type_t<_ToRep, _Rep, intmax_t>;
; 403  : 
; 404  :         constexpr bool _Num_is_one = _CF::num == 1;

  00026	c6 45 ff 01	 mov	 BYTE PTR __Num_is_one$[ebp], 1

; 405  :         constexpr bool _Den_is_one = _CF::den == 1;

  0002a	c6 45 fe 00	 mov	 BYTE PTR __Den_is_one$[ebp], 0

; 406  : 
; 407  :         if (_Den_is_one) {

  0002e	33 c0		 xor	 eax, eax
  00030	74 4e		 je	 SHORT $LN2@duration_c

; 408  :             if (_Num_is_one) {

  00032	b9 01 00 00 00	 mov	 ecx, 1
  00037	85 c9		 test	 ecx, ecx
  00039	74 24		 je	 SHORT $LN4@duration_c

; 409  :                 return static_cast<_To>(static_cast<_ToRep>(_Dur.count()));

  0003b	8b 4d 0c	 mov	 ecx, DWORD PTR __Dur$[ebp]
  0003e	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
  00043	89 45 f4	 mov	 DWORD PTR $T4[ebp], eax
  00046	89 55 f8	 mov	 DWORD PTR $T4[ebp+4], edx
  00049	8d 55 f4	 lea	 edx, DWORD PTR $T4[ebp]
  0004c	52		 push	 edx
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00050	e8 00 00 00 00	 call	 ??$?0_JX@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1> >::duration<__int64,std::ratio<1,1> ><__int64,void>
  00055	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00058	e9 86 00 00 00	 jmp	 $LN1@duration_c

; 410  :             } else {

  0005d	eb 1f		 jmp	 SHORT $LN5@duration_c
$LN4@duration_c:

; 411  :                 return static_cast<_To>(

  0005f	8b 4d 0c	 mov	 ecx, DWORD PTR __Dur$[ebp]
  00062	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
  00067	89 45 ec	 mov	 DWORD PTR $T3[ebp], eax
  0006a	89 55 f0	 mov	 DWORD PTR $T3[ebp+4], edx
  0006d	8d 45 ec	 lea	 eax, DWORD PTR $T3[ebp]
  00070	50		 push	 eax
  00071	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00074	e8 00 00 00 00	 call	 ??$?0_JX@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1> >::duration<__int64,std::ratio<1,1> ><__int64,void>
  00079	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0007c	eb 65		 jmp	 SHORT $LN1@duration_c
$LN5@duration_c:

; 412  :                     static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num)));
; 413  :             }
; 414  :         } else {

  0007e	eb 63		 jmp	 SHORT $LN1@duration_c
$LN2@duration_c:

; 415  :             if (_Num_is_one) {

  00080	b9 01 00 00 00	 mov	 ecx, 1
  00085	85 c9		 test	 ecx, ecx
  00087	74 2f		 je	 SHORT $LN6@duration_c

; 416  :                 return static_cast<_To>(

  00089	8b 4d 0c	 mov	 ecx, DWORD PTR __Dur$[ebp]
  0008c	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
  00091	6a 00		 push	 0
  00093	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00098	52		 push	 edx
  00099	50		 push	 eax
  0009a	e8 00 00 00 00	 call	 __alldiv
  0009f	89 45 e4	 mov	 DWORD PTR $T2[ebp], eax
  000a2	89 55 e8	 mov	 DWORD PTR $T2[ebp+4], edx
  000a5	8d 55 e4	 lea	 edx, DWORD PTR $T2[ebp]
  000a8	52		 push	 edx
  000a9	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  000ac	e8 00 00 00 00	 call	 ??$?0_JX@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1> >::duration<__int64,std::ratio<1,1> ><__int64,void>
  000b1	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000b4	eb 2d		 jmp	 SHORT $LN1@duration_c

; 417  :                     static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) / static_cast<_CR>(_CF::den)));
; 418  :             } else {

  000b6	eb 2b		 jmp	 SHORT $LN1@duration_c
$LN6@duration_c:

; 419  :                 return static_cast<_To>(static_cast<_ToRep>(

  000b8	8b 4d 0c	 mov	 ecx, DWORD PTR __Dur$[ebp]
  000bb	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
  000c0	6a 00		 push	 0
  000c2	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  000c7	52		 push	 edx
  000c8	50		 push	 eax
  000c9	e8 00 00 00 00	 call	 __alldiv
  000ce	89 45 dc	 mov	 DWORD PTR $T1[ebp], eax
  000d1	89 55 e0	 mov	 DWORD PTR $T1[ebp+4], edx
  000d4	8d 45 dc	 lea	 eax, DWORD PTR $T1[ebp]
  000d7	50		 push	 eax
  000d8	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  000db	e8 00 00 00 00	 call	 ??$?0_JX@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1> >::duration<__int64,std::ratio<1,1> ><__int64,void>
  000e0	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN1@duration_c:

; 420  :                     static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num) / static_cast<_CR>(_CF::den)));
; 421  :             }
; 422  :         }
; 423  :     }

  000e3	83 c4 24	 add	 esp, 36			; 00000024H
  000e6	3b ec		 cmp	 ebp, esp
  000e8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ed	8b e5		 mov	 esp, ebp
  000ef	5d		 pop	 ebp
  000f0	c3		 ret	 0
??$duration_cast@V?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@X@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$00@std@@@01@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z ENDP ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1> >,__int64,std::ratio<1,1000000000>,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\chrono
;	COMDAT ??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@X@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV201@@Z
_TEXT	SEGMENT
$T1 = -36						; size = 8
$T2 = -28						; size = 8
$T3 = -20						; size = 8
$T4 = -12						; size = 8
__Den_is_one$ = -2					; size = 1
__Num_is_one$ = -1					; size = 1
___$ReturnUdt$ = 8					; size = 4
__Dur$ = 12						; size = 4
??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@X@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV201@@Z PROC ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000000000>,void>, COMDAT

; 397  :         _NOEXCEPT_COND(is_arithmetic_v<_Rep>&& is_arithmetic_v<typename _To::rep>) { // strengthened

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 dc	 mov	 DWORD PTR [ebp-36], eax
  0000e	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  00011	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  00014	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00017	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0001a	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0001d	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00020	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00023	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 398  :         // convert duration to another duration; truncate
; 399  :         using _CF = ratio_divide<_Period, typename _To::period>;
; 400  : 
; 401  :         using _ToRep = typename _To::rep;
; 402  :         using _CR    = common_type_t<_ToRep, _Rep, intmax_t>;
; 403  : 
; 404  :         constexpr bool _Num_is_one = _CF::num == 1;

  00026	c6 45 ff 01	 mov	 BYTE PTR __Num_is_one$[ebp], 1

; 405  :         constexpr bool _Den_is_one = _CF::den == 1;

  0002a	c6 45 fe 01	 mov	 BYTE PTR __Den_is_one$[ebp], 1

; 406  : 
; 407  :         if (_Den_is_one) {

  0002e	b8 01 00 00 00	 mov	 eax, 1
  00033	85 c0		 test	 eax, eax
  00035	74 4b		 je	 SHORT $LN2@duration_c

; 408  :             if (_Num_is_one) {

  00037	b9 01 00 00 00	 mov	 ecx, 1
  0003c	85 c9		 test	 ecx, ecx
  0003e	74 21		 je	 SHORT $LN4@duration_c

; 409  :                 return static_cast<_To>(static_cast<_ToRep>(_Dur.count()));

  00040	8b 4d 0c	 mov	 ecx, DWORD PTR __Dur$[ebp]
  00043	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
  00048	89 45 f4	 mov	 DWORD PTR $T4[ebp], eax
  0004b	89 55 f8	 mov	 DWORD PTR $T4[ebp+4], edx
  0004e	8d 55 f4	 lea	 edx, DWORD PTR $T4[ebp]
  00051	52		 push	 edx
  00052	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00055	e8 00 00 00 00	 call	 ??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,void>
  0005a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0005d	eb 6a		 jmp	 SHORT $LN1@duration_c

; 410  :             } else {

  0005f	eb 1f		 jmp	 SHORT $LN5@duration_c
$LN4@duration_c:

; 411  :                 return static_cast<_To>(

  00061	8b 4d 0c	 mov	 ecx, DWORD PTR __Dur$[ebp]
  00064	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
  00069	89 45 ec	 mov	 DWORD PTR $T3[ebp], eax
  0006c	89 55 f0	 mov	 DWORD PTR $T3[ebp+4], edx
  0006f	8d 45 ec	 lea	 eax, DWORD PTR $T3[ebp]
  00072	50		 push	 eax
  00073	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00076	e8 00 00 00 00	 call	 ??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,void>
  0007b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0007e	eb 49		 jmp	 SHORT $LN1@duration_c
$LN5@duration_c:

; 412  :                     static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num)));
; 413  :             }
; 414  :         } else {

  00080	eb 47		 jmp	 SHORT $LN1@duration_c
$LN2@duration_c:

; 415  :             if (_Num_is_one) {

  00082	b9 01 00 00 00	 mov	 ecx, 1
  00087	85 c9		 test	 ecx, ecx
  00089	74 21		 je	 SHORT $LN6@duration_c

; 416  :                 return static_cast<_To>(

  0008b	8b 4d 0c	 mov	 ecx, DWORD PTR __Dur$[ebp]
  0008e	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
  00093	89 45 e4	 mov	 DWORD PTR $T2[ebp], eax
  00096	89 55 e8	 mov	 DWORD PTR $T2[ebp+4], edx
  00099	8d 55 e4	 lea	 edx, DWORD PTR $T2[ebp]
  0009c	52		 push	 edx
  0009d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  000a0	e8 00 00 00 00	 call	 ??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,void>
  000a5	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000a8	eb 1f		 jmp	 SHORT $LN1@duration_c

; 417  :                     static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) / static_cast<_CR>(_CF::den)));
; 418  :             } else {

  000aa	eb 1d		 jmp	 SHORT $LN1@duration_c
$LN6@duration_c:

; 419  :                 return static_cast<_To>(static_cast<_ToRep>(

  000ac	8b 4d 0c	 mov	 ecx, DWORD PTR __Dur$[ebp]
  000af	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
  000b4	89 45 dc	 mov	 DWORD PTR $T1[ebp], eax
  000b7	89 55 e0	 mov	 DWORD PTR $T1[ebp+4], edx
  000ba	8d 45 dc	 lea	 eax, DWORD PTR $T1[ebp]
  000bd	50		 push	 eax
  000be	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  000c1	e8 00 00 00 00	 call	 ??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,void>
  000c6	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN1@duration_c:

; 420  :                     static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num) / static_cast<_CR>(_CF::den)));
; 421  :             }
; 422  :         }
; 423  :     }

  000c9	83 c4 24	 add	 esp, 36			; 00000024H
  000cc	3b ec		 cmp	 ebp, esp
  000ce	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d3	8b e5		 mov	 esp, ebp
  000d5	5d		 pop	 ebp
  000d6	c3		 ret	 0
??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@X@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV201@@Z ENDP ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000000000>,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\chrono
;	COMDAT ??$?MNU?$ratio@$00$00@std@@_JU?$ratio@$00$0DLJKMKAA@@1@@chrono@std@@YA_NABV?$duration@NU?$ratio@$00$00@std@@@01@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z
_TEXT	SEGMENT
tv75 = -44						; size = 4
tv89 = -40						; size = 8
tv92 = -32						; size = 8
tv83 = -24						; size = 8
$T1 = -16						; size = 8
$T2 = -8						; size = 8
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?MNU?$ratio@$00$00@std@@_JU?$ratio@$00$0DLJKMKAA@@1@@chrono@std@@YA_NABV?$duration@NU?$ratio@$00$00@std@@@01@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z PROC ; std::chrono::operator<<double,std::ratio<1,1>,__int64,std::ratio<1,1000000000> >, COMDAT

; 365  :         _NOEXCEPT_COND(is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>) { // strengthened

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	57		 push	 edi
  00007	8d 7d d4	 lea	 edi, DWORD PTR [ebp-44]
  0000a	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  0000f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00014	f3 ab		 rep stosd

; 366  :         // test if duration < duration
; 367  :         using _CT = common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>;
; 368  :         return _CT(_Left).count() < _CT(_Right).count();

  00016	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00019	50		 push	 eax
  0001a	8d 4d f8	 lea	 ecx, DWORD PTR $T2[ebp]
  0001d	e8 00 00 00 00	 call	 ??$?0NU?$ratio@$00$00@std@@X@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABV?$duration@NU?$ratio@$00$00@std@@@12@@Z ; std::chrono::duration<double,std::ratio<1,1000000000> >::duration<double,std::ratio<1,1000000000> ><double,std::ratio<1,1>,void>
  00022	8b c8		 mov	 ecx, eax
  00024	e8 00 00 00 00	 call	 ?count@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBENXZ ; std::chrono::duration<double,std::ratio<1,1000000000> >::count
  00029	dd 5d e8	 fstp	 QWORD PTR tv83[ebp]
  0002c	f2 0f 10 45 e8	 movsd	 xmm0, QWORD PTR tv83[ebp]
  00031	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00034	51		 push	 ecx
  00035	8d 4d f0	 lea	 ecx, DWORD PTR $T1[ebp]
  00038	f2 0f 11 45 e0	 movsd	 QWORD PTR tv92[ebp], xmm0
  0003d	e8 00 00 00 00	 call	 ??$?0_JU?$ratio@$00$0DLJKMKAA@@std@@X@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z ; std::chrono::duration<double,std::ratio<1,1000000000> >::duration<double,std::ratio<1,1000000000> ><__int64,std::ratio<1,1000000000>,void>
  00042	8b c8		 mov	 ecx, eax
  00044	e8 00 00 00 00	 call	 ?count@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBENXZ ; std::chrono::duration<double,std::ratio<1,1000000000> >::count
  00049	dd 5d d8	 fstp	 QWORD PTR tv89[ebp]
  0004c	f2 0f 10 45 d8	 movsd	 xmm0, QWORD PTR tv89[ebp]
  00051	f2 0f 10 4d e0	 movsd	 xmm1, QWORD PTR tv92[ebp]
  00056	66 0f 2f c1	 comisd	 xmm0, xmm1
  0005a	76 09		 jbe	 SHORT $LN3@operator
  0005c	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR tv75[ebp], 1
  00063	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00065	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR tv75[ebp], 0
$LN4@operator:
  0006c	8a 45 d4	 mov	 al, BYTE PTR tv75[ebp]

; 369  :     }

  0006f	5f		 pop	 edi
  00070	83 c4 2c	 add	 esp, 44			; 0000002cH
  00073	3b ec		 cmp	 ebp, esp
  00075	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
??$?MNU?$ratio@$00$00@std@@_JU?$ratio@$00$0DLJKMKAA@@1@@chrono@std@@YA_NABV?$duration@NU?$ratio@$00$00@std@@@01@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z ENDP ; std::chrono::operator<<double,std::ratio<1,1>,__int64,std::ratio<1,1000000000> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\chrono
;	COMDAT ??$?0_JU?$ratio@$00$0JIJGIA@@std@@X@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 8
_this$ = -4						; size = 4
__Dur$ = 8						; size = 4
??$?0_JU?$ratio@$00$0JIJGIA@@std@@X@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@@Z PROC ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,std::ratio<1,10000000>,void>, COMDAT
; _this$ = ecx

; 86   :             : _MyRep(chrono::duration_cast<duration>(_Dur).count()) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0001e	8b 45 08	 mov	 eax, DWORD PTR __Dur$[ebp]
  00021	50		 push	 eax
  00022	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00025	51		 push	 ecx
  00026	e8 00 00 00 00	 call	 ??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0JIJGIA@@3@X@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@@Z ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,10000000>,void>
  0002b	83 c4 08	 add	 esp, 8
  0002e	8b c8		 mov	 ecx, eax
  00030	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
  00035	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	89 01		 mov	 DWORD PTR [ecx], eax
  0003a	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0003d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00040	83 c4 0c	 add	 esp, 12			; 0000000cH
  00043	3b ec		 cmp	 ebp, esp
  00045	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 04 00	 ret	 4
??$?0_JU?$ratio@$00$0JIJGIA@@std@@X@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@@Z ENDP ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,std::ratio<1,10000000>,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\chrono
;	COMDAT ??$?MUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA_NABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z
_TEXT	SEGMENT
$T1 = -16						; size = 8
$T2 = -8						; size = 8
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?MUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA_NABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z PROC ; std::chrono::operator<<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,std::chrono::duration<__int64,std::ratio<1,1000000000> > >, COMDAT

; 552  :             is_arithmetic_v<typename _Duration1::rep>&& is_arithmetic_v<typename _Duration2::rep>) { // strengthened

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000e	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00011	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00014	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 553  :         // test for time_point < time_point
; 554  :         return _Left.time_since_epoch() < _Right.time_since_epoch();

  00017	8d 45 f8	 lea	 eax, DWORD PTR $T2[ebp]
  0001a	50		 push	 eax
  0001b	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  0001e	e8 00 00 00 00	 call	 ?time_since_epoch@?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QBE?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@XZ ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_since_epoch
  00023	50		 push	 eax
  00024	8d 4d f0	 lea	 ecx, DWORD PTR $T1[ebp]
  00027	51		 push	 ecx
  00028	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0002b	e8 00 00 00 00	 call	 ?time_since_epoch@?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QBE?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@XZ ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_since_epoch
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ??$?M_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YA_NABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@0@Z ; std::chrono::operator<<__int64,std::ratio<1,1000000000>,__int64,std::ratio<1,1000000000> >
  00036	83 c4 08	 add	 esp, 8

; 555  :     }

  00039	83 c4 10	 add	 esp, 16			; 00000010H
  0003c	3b ec		 cmp	 ebp, esp
  0003e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
??$?MUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA_NABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z ENDP ; std::chrono::operator<<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\chrono
;	COMDAT ??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DOI@@3@X@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@@Z
_TEXT	SEGMENT
$T1 = -36						; size = 8
$T2 = -28						; size = 8
$T3 = -20						; size = 8
$T4 = -12						; size = 8
__Den_is_one$ = -2					; size = 1
__Num_is_one$ = -1					; size = 1
___$ReturnUdt$ = 8					; size = 4
__Dur$ = 12						; size = 4
??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DOI@@3@X@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@@Z PROC ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000>,void>, COMDAT

; 397  :         _NOEXCEPT_COND(is_arithmetic_v<_Rep>&& is_arithmetic_v<typename _To::rep>) { // strengthened

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 dc	 mov	 DWORD PTR [ebp-36], eax
  0000e	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  00011	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  00014	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00017	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0001a	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0001d	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00020	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00023	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 398  :         // convert duration to another duration; truncate
; 399  :         using _CF = ratio_divide<_Period, typename _To::period>;
; 400  : 
; 401  :         using _ToRep = typename _To::rep;
; 402  :         using _CR    = common_type_t<_ToRep, _Rep, intmax_t>;
; 403  : 
; 404  :         constexpr bool _Num_is_one = _CF::num == 1;

  00026	c6 45 ff 00	 mov	 BYTE PTR __Num_is_one$[ebp], 0

; 405  :         constexpr bool _Den_is_one = _CF::den == 1;

  0002a	c6 45 fe 01	 mov	 BYTE PTR __Den_is_one$[ebp], 1

; 406  : 
; 407  :         if (_Den_is_one) {

  0002e	b8 01 00 00 00	 mov	 eax, 1
  00033	85 c0		 test	 eax, eax
  00035	74 57		 je	 SHORT $LN2@duration_c

; 408  :             if (_Num_is_one) {

  00037	33 c9		 xor	 ecx, ecx
  00039	74 24		 je	 SHORT $LN4@duration_c

; 409  :                 return static_cast<_To>(static_cast<_ToRep>(_Dur.count()));

  0003b	8b 4d 0c	 mov	 ecx, DWORD PTR __Dur$[ebp]
  0003e	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000> >::count
  00043	89 45 f4	 mov	 DWORD PTR $T4[ebp], eax
  00046	89 55 f8	 mov	 DWORD PTR $T4[ebp+4], edx
  00049	8d 55 f4	 lea	 edx, DWORD PTR $T4[ebp]
  0004c	52		 push	 edx
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00050	e8 00 00 00 00	 call	 ??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,void>
  00055	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00058	e9 81 00 00 00	 jmp	 $LN1@duration_c

; 410  :             } else {

  0005d	eb 2d		 jmp	 SHORT $LN5@duration_c
$LN4@duration_c:

; 411  :                 return static_cast<_To>(

  0005f	8b 4d 0c	 mov	 ecx, DWORD PTR __Dur$[ebp]
  00062	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000> >::count
  00067	6a 00		 push	 0
  00069	68 40 42 0f 00	 push	 1000000			; 000f4240H
  0006e	52		 push	 edx
  0006f	50		 push	 eax
  00070	e8 00 00 00 00	 call	 __allmul
  00075	89 45 ec	 mov	 DWORD PTR $T3[ebp], eax
  00078	89 55 f0	 mov	 DWORD PTR $T3[ebp+4], edx
  0007b	8d 45 ec	 lea	 eax, DWORD PTR $T3[ebp]
  0007e	50		 push	 eax
  0007f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00082	e8 00 00 00 00	 call	 ??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,void>
  00087	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0008a	eb 52		 jmp	 SHORT $LN1@duration_c
$LN5@duration_c:

; 412  :                     static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num)));
; 413  :             }
; 414  :         } else {

  0008c	eb 50		 jmp	 SHORT $LN1@duration_c
$LN2@duration_c:

; 415  :             if (_Num_is_one) {

  0008e	33 c9		 xor	 ecx, ecx
  00090	74 21		 je	 SHORT $LN6@duration_c

; 416  :                 return static_cast<_To>(

  00092	8b 4d 0c	 mov	 ecx, DWORD PTR __Dur$[ebp]
  00095	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000> >::count
  0009a	89 45 e4	 mov	 DWORD PTR $T2[ebp], eax
  0009d	89 55 e8	 mov	 DWORD PTR $T2[ebp+4], edx
  000a0	8d 55 e4	 lea	 edx, DWORD PTR $T2[ebp]
  000a3	52		 push	 edx
  000a4	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  000a7	e8 00 00 00 00	 call	 ??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,void>
  000ac	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000af	eb 2d		 jmp	 SHORT $LN1@duration_c

; 417  :                     static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) / static_cast<_CR>(_CF::den)));
; 418  :             } else {

  000b1	eb 2b		 jmp	 SHORT $LN1@duration_c
$LN6@duration_c:

; 419  :                 return static_cast<_To>(static_cast<_ToRep>(

  000b3	8b 4d 0c	 mov	 ecx, DWORD PTR __Dur$[ebp]
  000b6	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000> >::count
  000bb	6a 00		 push	 0
  000bd	68 40 42 0f 00	 push	 1000000			; 000f4240H
  000c2	52		 push	 edx
  000c3	50		 push	 eax
  000c4	e8 00 00 00 00	 call	 __allmul
  000c9	89 45 dc	 mov	 DWORD PTR $T1[ebp], eax
  000cc	89 55 e0	 mov	 DWORD PTR $T1[ebp+4], edx
  000cf	8d 45 dc	 lea	 eax, DWORD PTR $T1[ebp]
  000d2	50		 push	 eax
  000d3	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  000d6	e8 00 00 00 00	 call	 ??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,void>
  000db	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN1@duration_c:

; 420  :                     static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num) / static_cast<_CR>(_CF::den)));
; 421  :             }
; 422  :         }
; 423  :     }

  000de	83 c4 24	 add	 esp, 36			; 00000024H
  000e1	3b ec		 cmp	 ebp, esp
  000e3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e8	8b e5		 mov	 esp, ebp
  000ea	5d		 pop	 ebp
  000eb	c3		 ret	 0
??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DOI@@3@X@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@@Z ENDP ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000>,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xutility
;	COMDAT ??$_Copy_memmove@PAPBDPAPBD@std@@YAPAPBDPAPBD00@Z
_TEXT	SEGMENT
__Count$ = -16						; size = 4
__Dest_ch$ = -12					; size = 4
__Last_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPBDPAPBD@std@@YAPAPBDPAPBD00@Z PROC	; std::_Copy_memmove<char const * *,char const * *>, COMDAT

; 1739 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) { // implement copy-like function as memmove

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000e	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00011	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00014	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 1740 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));

  00017	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001a	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 1741 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));

  0001d	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00020	89 4d f8	 mov	 DWORD PTR __Last_ch$[ebp], ecx

; 1742 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));

  00023	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00026	89 55 f4	 mov	 DWORD PTR __Dest_ch$[ebp], edx

; 1743 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00029	8b 45 f8	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  0002c	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  0002f	89 45 f0	 mov	 DWORD PTR __Count$[ebp], eax

; 1744 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00032	8b 4d f0	 mov	 ecx, DWORD PTR __Count$[ebp]
  00035	51		 push	 ecx
  00036	8b 55 fc	 mov	 edx, DWORD PTR __First_ch$[ebp]
  00039	52		 push	 edx
  0003a	8b 45 f4	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 _memmove
  00043	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1745 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  00046	8b 45 f4	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  00049	03 45 f0	 add	 eax, DWORD PTR __Count$[ebp]

; 1746 : }

  0004c	83 c4 10	 add	 esp, 16			; 00000010H
  0004f	3b ec		 cmp	 ebp, esp
  00051	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
??$_Copy_memmove@PAPBDPAPBD@std@@YAPAPBDPAPBD00@Z ENDP	; std::_Copy_memmove<char const * *,char const * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xutility
;	COMDAT ??$_Get_unwrapped@PBD@std@@YAPAPBDQAPBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Get_unwrapped@PBD@std@@YAPAPBDQAPBD@Z PROC		; std::_Get_unwrapped<char const *>, COMDAT

; 275  : _NODISCARD constexpr _Ty* _Get_unwrapped(_Ty* const _Ptr) { // special case already-unwrapped pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 276  :     return _Ptr;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 277  : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Get_unwrapped@PBD@std@@YAPAPBDQAPBD@Z ENDP		; std::_Get_unwrapped<char const *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__Count$ = 16						; size = 4
?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate, COMDAT

; 751  :     static void deallocate(_Alloc&, const pointer _Ptr, const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 752  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 753  :         _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00003	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	c1 e0 03	 shl	 eax, 3
  00009	50		 push	 eax
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000d	51		 push	 ecx
  0000e	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00013	83 c4 08	 add	 esp, 8

; 754  :     }

  00016	3b ec		 cmp	 ebp, esp
  00018	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\chrono
;	COMDAT ??$?H_JU?$ratio@$00$0DLJKMKAA@@std@@_JU?$ratio@$00$0DOI@@1@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV201@ABV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@@Z
_TEXT	SEGMENT
$T1 = -24						; size = 8
$T2 = -16						; size = 8
$T3 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?H_JU?$ratio@$00$0DLJKMKAA@@std@@_JU?$ratio@$00$0DOI@@1@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV201@ABV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@@Z PROC ; std::chrono::operator+<__int64,std::ratio<1,1000000000>,__int64,std::ratio<1,1000> >, COMDAT

; 253  :         _NOEXCEPT_COND(is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>) { // strengthened

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000d	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00010	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00013	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00016	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00019	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  0001c	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 254  :         // add two durations
; 255  :         using _CD = common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>;
; 256  :         return _CD(_CD(_Left).count() + _CD(_Right).count());

  0001f	8b 45 0c	 mov	 eax, DWORD PTR __Left$[ebp]
  00022	8b 08		 mov	 ecx, DWORD PTR [eax]
  00024	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00027	89 4d f0	 mov	 DWORD PTR $T2[ebp], ecx
  0002a	89 55 f4	 mov	 DWORD PTR $T2[ebp+4], edx
  0002d	8d 4d f0	 lea	 ecx, DWORD PTR $T2[ebp]
  00030	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
  00035	8b f0		 mov	 esi, eax
  00037	8b fa		 mov	 edi, edx
  00039	8b 45 10	 mov	 eax, DWORD PTR __Right$[ebp]
  0003c	50		 push	 eax
  0003d	8d 4d e8	 lea	 ecx, DWORD PTR $T1[ebp]
  00040	e8 00 00 00 00	 call	 ??$?0_JU?$ratio@$00$0DOI@@std@@X@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0DOI@@std@@@12@@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,std::ratio<1,1000>,void>
  00045	8b c8		 mov	 ecx, eax
  00047	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
  0004c	03 f0		 add	 esi, eax
  0004e	13 fa		 adc	 edi, edx
  00050	89 75 f8	 mov	 DWORD PTR $T3[ebp], esi
  00053	89 7d fc	 mov	 DWORD PTR $T3[ebp+4], edi
  00056	8d 4d f8	 lea	 ecx, DWORD PTR $T3[ebp]
  00059	51		 push	 ecx
  0005a	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0005d	e8 00 00 00 00	 call	 ??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,void>
  00062	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 257  :     }

  00065	5f		 pop	 edi
  00066	5e		 pop	 esi
  00067	83 c4 18	 add	 esp, 24			; 00000018H
  0006a	3b ec		 cmp	 ebp, esp
  0006c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
??$?H_JU?$ratio@$00$0DLJKMKAA@@std@@_JU?$ratio@$00$0DOI@@1@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV201@ABV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@@Z ENDP ; std::chrono::operator+<__int64,std::ratio<1,1000000000>,__int64,std::ratio<1,1000> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\type_traits
;	COMDAT ??$invoke@P6AXPAX@ZPAVCPerfMonitor@@@std@@YAX$$QAP6AXPAX@Z$$QAPAVCPerfMonitor@@@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$invoke@P6AXPAX@ZPAVCPerfMonitor@@@std@@YAX$$QAP6AXPAX@Z$$QAPAVCPerfMonitor@@@Z PROC ; std::invoke<void (__cdecl*)(void *),CPerfMonitor *>, COMDAT

; 1571 : _IMPLEMENT_INVOKE(_EMPTY_ARGUMENT, inline)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??$forward@PAVCPerfMonitor@@@std@@YA$$QAPAVCPerfMonitor@@AAPAV1@@Z ; std::forward<CPerfMonitor *>
  0000c	83 c4 04	 add	 esp, 4
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Obj$[ebp]
  00013	51		 push	 ecx
  00014	e8 00 00 00 00	 call	 ??$forward@P6AXPAX@Z@std@@YA$$QAP6AXPAX@ZAAP6AX0@Z@Z ; std::forward<void (__cdecl*)(void *)>
  00019	83 c4 04	 add	 esp, 4
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 ??$_Call@P6AXPAX@ZPAVCPerfMonitor@@@_Invoker_functor@std@@SAX$$QAP6AXPAX@Z$$QAPAVCPerfMonitor@@@Z ; std::_Invoker_functor::_Call<void (__cdecl*)(void *),CPerfMonitor *>
  00022	83 c4 08	 add	 esp, 8
  00025	3b ec		 cmp	 ebp, esp
  00027	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
??$invoke@P6AXPAX@ZPAVCPerfMonitor@@@std@@YAX$$QAP6AXPAX@Z$$QAPAVCPerfMonitor@@@Z ENDP ; std::invoke<void (__cdecl*)(void *),CPerfMonitor *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\type_traits
;	COMDAT ??$_Call@P6AXPAX@ZPAVCPerfMonitor@@@_Invoker_functor@std@@SAX$$QAP6AXPAX@Z$$QAPAVCPerfMonitor@@@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Call@P6AXPAX@ZPAVCPerfMonitor@@@_Invoker_functor@std@@SAX$$QAP6AXPAX@Z$$QAPAVCPerfMonitor@@@Z PROC ; std::_Invoker_functor::_Call<void (__cdecl*)(void *),CPerfMonitor *>, COMDAT

; 1571 : _IMPLEMENT_INVOKE(_EMPTY_ARGUMENT, inline)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??$forward@PAVCPerfMonitor@@@std@@YA$$QAPAVCPerfMonitor@@AAPAV1@@Z ; std::forward<CPerfMonitor *>
  0000d	83 c4 04	 add	 esp, 4
  00010	8b f4		 mov	 esi, esp
  00012	8b 08		 mov	 ecx, DWORD PTR [eax]
  00014	51		 push	 ecx
  00015	8b 55 08	 mov	 edx, DWORD PTR __Obj$[ebp]
  00018	52		 push	 edx
  00019	e8 00 00 00 00	 call	 ??$forward@P6AXPAX@Z@std@@YA$$QAP6AXPAX@ZAAP6AX0@Z@Z ; std::forward<void (__cdecl*)(void *)>
  0001e	83 c4 04	 add	 esp, 4
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	ff d0		 call	 eax
  00025	83 c4 04	 add	 esp, 4
  00028	3b f4		 cmp	 esi, esp
  0002a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002f	5e		 pop	 esi
  00030	3b ec		 cmp	 ebp, esp
  00032	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
??$_Call@P6AXPAX@ZPAVCPerfMonitor@@@_Invoker_functor@std@@SAX$$QAP6AXPAX@Z$$QAPAVCPerfMonitor@@@Z ENDP ; std::_Invoker_functor::_Call<void (__cdecl*)(void *),CPerfMonitor *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\type_traits
;	COMDAT ??$forward@P6AXPAX@Z@std@@YA$$QAP6AXPAX@ZAAP6AX0@Z@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@P6AXPAX@Z@std@@YA$$QAP6AXPAX@ZAAP6AX0@Z@Z PROC ; std::forward<void (__cdecl*)(void *)>, COMDAT

; 1420 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1421 :     return static_cast<_Ty&&>(_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1422 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@P6AXPAX@Z@std@@YA$$QAP6AXPAX@ZAAP6AX0@Z@Z ENDP ; std::forward<void (__cdecl*)(void *)>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\tuple
;	COMDAT ??$get@$00P6AXPAX@ZPAVCPerfMonitor@@@std@@YAAAPAVCPerfMonitor@@AAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@0@@Z
_TEXT	SEGMENT
__Tuple$ = 8						; size = 4
??$get@$00P6AXPAX@ZPAVCPerfMonitor@@@std@@YAAAPAVCPerfMonitor@@AAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@0@@Z PROC ; std::get<1,void (__cdecl*)(void *),CPerfMonitor *>, COMDAT

; 649  : _NODISCARD constexpr tuple_element_t<_Index, tuple<_Types...>>& get(tuple<_Types...>& _Tuple) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 650  :     using _Ttype = typename tuple_element<_Index, tuple<_Types...>>::_Ttype;
; 651  :     return static_cast<_Ttype&>(_Tuple)._Myfirst._Val;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Tuple$[ebp]

; 652  : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$get@$00P6AXPAX@ZPAVCPerfMonitor@@@std@@YAAAPAVCPerfMonitor@@AAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@0@@Z ENDP ; std::get<1,void (__cdecl*)(void *),CPerfMonitor *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\type_traits
;	COMDAT ??$move@AAP6AXPAX@Z@std@@YA$$QAP6AXPAX@ZAAP6AX0@Z@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAP6AXPAX@Z@std@@YA$$QAP6AXPAX@ZAAP6AX0@Z@Z PROC ; std::move<void (__cdecl*&)(void *)>, COMDAT

; 1432 : _NODISCARD constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept { // forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1433 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1434 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAP6AXPAX@Z@std@@YA$$QAP6AXPAX@ZAAP6AX0@Z@Z ENDP ; std::move<void (__cdecl*&)(void *)>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\tuple
;	COMDAT ??$get@$0A@P6AXPAX@ZPAVCPerfMonitor@@@std@@YAAAP6AXPAX@ZAAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@0@@Z
_TEXT	SEGMENT
__Tuple$ = 8						; size = 4
??$get@$0A@P6AXPAX@ZPAVCPerfMonitor@@@std@@YAAAP6AXPAX@ZAAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@0@@Z PROC ; std::get<0,void (__cdecl*)(void *),CPerfMonitor *>, COMDAT

; 649  : _NODISCARD constexpr tuple_element_t<_Index, tuple<_Types...>>& get(tuple<_Types...>& _Tuple) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 650  :     using _Ttype = typename tuple_element<_Index, tuple<_Types...>>::_Ttype;
; 651  :     return static_cast<_Ttype&>(_Tuple)._Myfirst._Val;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Tuple$[ebp]
  00006	83 c0 04	 add	 eax, 4

; 652  : }

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$get@$0A@P6AXPAX@ZPAVCPerfMonitor@@@std@@YAAAP6AXPAX@ZAAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@0@@Z ENDP ; std::get<0,void (__cdecl*)(void *),CPerfMonitor *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\memory
;	COMDAT ??$?0U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@std@@$0A@@?$unique_ptr@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@2@@std@@QAE@PAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@1@@Z
_TEXT	SEGMENT
$T2 = -17						; size = 1
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
??$?0U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@std@@$0A@@?$unique_ptr@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@2@@std@@QAE@PAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@1@@Z PROC ; std::unique_ptr<std::tuple<void (__cdecl*)(void *),CPerfMonitor *>,std::default_delete<std::tuple<void (__cdecl*)(void *),CPerfMonitor *> > >::unique_ptr<std::tuple<void (__cdecl*)(void *),CPerfMonitor *>,std::default_delete<std::tuple<void (__cdecl*)(void *),CPerfMonitor *> > ><std::default_delete<std::tuple<void (__cdecl*)(void *),CPerfMonitor *> >,0>, COMDAT
; _this$ = ecx

; 1820 :     explicit unique_ptr(pointer _Ptr) noexcept : _Mypair(_Zero_then_variadic_args_t(), _Ptr) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?0U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@std@@$0A@@?$unique_ptr@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@2@@std@@QAE@PAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	c7 45 ec cc cc
	cc cc		 mov	 DWORD PTR [ebp-20], -858993460 ; ccccccccH
  0001b	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00027	33 c5		 xor	 eax, ebp
  00029	50		 push	 eax
  0002a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0002d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00033	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00036	8d 45 08	 lea	 eax, DWORD PTR __Ptr$[ebp]
  00039	50		 push	 eax
  0003a	0f b6 4d ef	 movzx	 ecx, BYTE PTR $T2[ebp]
  0003e	51		 push	 ecx
  0003f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e8 00 00 00 00	 call	 ??$?0AAPAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@std@@PAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@1@@Z ; std::_Compressed_pair<std::default_delete<std::tuple<void (__cdecl*)(void *),CPerfMonitor *> >,std::tuple<void (__cdecl*)(void *),CPerfMonitor *> *,1>::_Compressed_pair<std::default_delete<std::tuple<void (__cdecl*)(void *),CPerfMonitor *> >,std::tuple<void (__cdecl*)(void *),CPerfMonitor *> *,1><std::tuple<void (__cdecl*)(void *),CPerfMonitor *> * &>
  00047	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00054	59		 pop	 ecx
  00055	83 c4 14	 add	 esp, 20			; 00000014H
  00058	3b ec		 cmp	 ebp, esp
  0005a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$?0U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@std@@$0A@@?$unique_ptr@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@2@@std@@QAE@PAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@1@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?0U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@std@@$0A@@?$unique_ptr@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@2@@std@@QAE@PAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@1@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?0U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@std@@$0A@@?$unique_ptr@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@2@@std@@QAE@PAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@1@@Z ENDP ; std::unique_ptr<std::tuple<void (__cdecl*)(void *),CPerfMonitor *>,std::default_delete<std::tuple<void (__cdecl*)(void *),CPerfMonitor *> > >::unique_ptr<std::tuple<void (__cdecl*)(void *),CPerfMonitor *>,std::default_delete<std::tuple<void (__cdecl*)(void *),CPerfMonitor *> > ><std::default_delete<std::tuple<void (__cdecl*)(void *),CPerfMonitor *> >,0>
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\tuple
;	COMDAT ??$?0A6AXPAX@ZPAVCPerfMonitor@@$0A@@?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@QAE@A6AXPAX@Z$$QAPAVCPerfMonitor@@@Z
_TEXT	SEGMENT
$T2 = -17						; size = 1
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__This_arg$ = 8						; size = 4
_<_Rest_arg_0>$ = 12					; size = 4
??$?0A6AXPAX@ZPAVCPerfMonitor@@$0A@@?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@QAE@A6AXPAX@Z$$QAPAVCPerfMonitor@@@Z PROC ; std::tuple<void (__cdecl*)(void *),CPerfMonitor *>::tuple<void (__cdecl*)(void *),CPerfMonitor *><void (__cdecl&)(void *),CPerfMonitor *,0>, COMDAT
; _this$ = ecx

; 310  :         : tuple(_Exact_args_t{}, _STD forward<_This2>(_This_arg), _STD forward<_Rest2>(_Rest_arg)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?0A6AXPAX@ZPAVCPerfMonitor@@$0A@@?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@QAE@A6AXPAX@Z$$QAPAVCPerfMonitor@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	c7 45 ec cc cc
	cc cc		 mov	 DWORD PTR [ebp-20], -858993460 ; ccccccccH
  0001b	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00027	33 c5		 xor	 eax, ebp
  00029	50		 push	 eax
  0002a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0002d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00033	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00036	33 c0		 xor	 eax, eax
  00038	88 45 ef	 mov	 BYTE PTR $T2[ebp], al
  0003b	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Rest_arg_0>$[ebp]
  0003e	51		 push	 ecx
  0003f	e8 00 00 00 00	 call	 ??$forward@PAVCPerfMonitor@@@std@@YA$$QAPAVCPerfMonitor@@AAPAV1@@Z ; std::forward<CPerfMonitor *>
  00044	83 c4 04	 add	 esp, 4
  00047	50		 push	 eax
  00048	8b 55 08	 mov	 edx, DWORD PTR __This_arg$[ebp]
  0004b	52		 push	 edx
  0004c	e8 00 00 00 00	 call	 ??$forward@A6AXPAX@Z@std@@YAA6AXPAX@ZA6AX0@Z@Z ; std::forward<void (__cdecl&)(void *)>
  00051	83 c4 04	 add	 esp, 4
  00054	50		 push	 eax
  00055	0f b6 45 ef	 movzx	 eax, BYTE PTR $T2[ebp]
  00059	50		 push	 eax
  0005a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	e8 00 00 00 00	 call	 ??$?0U_Exact_args_t@std@@A6AXPAX@ZPAVCPerfMonitor@@$0A@@?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@QAE@U_Exact_args_t@1@A6AXPAX@Z$$QAPAVCPerfMonitor@@@Z ; std::tuple<void (__cdecl*)(void *),CPerfMonitor *>::tuple<void (__cdecl*)(void *),CPerfMonitor *><std::_Exact_args_t,void (__cdecl&)(void *),CPerfMonitor *,0>
  00062	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00065	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00068	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006f	59		 pop	 ecx
  00070	83 c4 14	 add	 esp, 20			; 00000014H
  00073	3b ec		 cmp	 ebp, esp
  00075	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$?0A6AXPAX@ZPAVCPerfMonitor@@$0A@@?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@QAE@A6AXPAX@Z$$QAPAVCPerfMonitor@@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?0A6AXPAX@ZPAVCPerfMonitor@@$0A@@?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@QAE@A6AXPAX@Z$$QAPAVCPerfMonitor@@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?0A6AXPAX@ZPAVCPerfMonitor@@$0A@@?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@QAE@A6AXPAX@Z$$QAPAVCPerfMonitor@@@Z ENDP ; std::tuple<void (__cdecl*)(void *),CPerfMonitor *>::tuple<void (__cdecl*)(void *),CPerfMonitor *><void (__cdecl&)(void *),CPerfMonitor *,0>
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\type_traits
;	COMDAT ??$forward@AAPAVRGYPipeProcess@@@std@@YAAAPAVRGYPipeProcess@@AAPAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAVRGYPipeProcess@@@std@@YAAAPAVRGYPipeProcess@@AAPAV1@@Z PROC ; std::forward<RGYPipeProcess * &>, COMDAT

; 1420 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1421 :     return static_cast<_Ty&&>(_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1422 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAPAVRGYPipeProcess@@@std@@YAAAPAVRGYPipeProcess@@AAPAV1@@Z ENDP ; std::forward<RGYPipeProcess * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\type_traits
;	COMDAT ??$forward@AAPAU_iobuf@@@std@@YAAAPAU_iobuf@@AAPAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAU_iobuf@@@std@@YAAAPAU_iobuf@@AAPAU1@@Z PROC ; std::forward<_iobuf * &>, COMDAT

; 1420 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1421 :     return static_cast<_Ty&&>(_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1422 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAPAU_iobuf@@@std@@YAAAPAU_iobuf@@AAPAU1@@Z ENDP ; std::forward<_iobuf * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\chrono
;	COMDAT ??$_To_xtime_10_day_clamped@_JU?$ratio@$00$0DLJKMKAA@@std@@@std@@YA_NAAUxtime@@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@0@@Z
_TEXT	SEGMENT
$T1 = -100						; size = 8
$T2 = -92						; size = 8
$T3 = -84						; size = 8
$T4 = -76						; size = 8
__Whole_seconds$ = -64					; size = 8
__Clamped$ = -49					; size = 1
__T0$ = -44						; size = 8
__Ten_days_d$ = -28					; size = 8
__Ten_days$ = -12					; size = 8
__Xt$ = 8						; size = 4
__Rel_time$ = 12					; size = 4
??$_To_xtime_10_day_clamped@_JU?$ratio@$00$0DLJKMKAA@@std@@@std@@YA_NAAUxtime@@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@0@@Z PROC ; std::_To_xtime_10_day_clamped<__int64,std::ratio<1,1000000000> >, COMDAT

; 663  :     _NOEXCEPT_COND(is_arithmetic_v<_Rep>) { // strengthened

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	57		 push	 edi
  00007	8d 7d 9c	 lea	 edi, DWORD PTR [ebp-100]
  0000a	b9 19 00 00 00	 mov	 ecx, 25			; 00000019H
  0000f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00014	f3 ab		 rep stosd

; 664  :     // Convert duration to xtime, maximum 10 days from now, returns whether clamping occurred.
; 665  :     // If clamped, timeouts will be transformed into spurious non-timeout wakes, due to ABI restrictions where
; 666  :     // the other side of the DLL boundary overflows int32_t milliseconds.
; 667  :     // Every function calling this one is TRANSITION, ABI
; 668  :     constexpr chrono::nanoseconds _Ten_days{chrono::hours{24} * 10};

  00016	c7 45 f4 00 00
	16 ad		 mov	 DWORD PTR __Ten_days$[ebp], -1391067136 ; ad160000H
  0001d	c7 45 f8 cd 11
	03 00		 mov	 DWORD PTR __Ten_days$[ebp+4], 201165 ; 000311cdH

; 669  :     constexpr chrono::duration<double> _Ten_days_d{_Ten_days};

  00024	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@412a5e0000000000
  0002c	f2 0f 11 45 e4	 movsd	 QWORD PTR __Ten_days_d$[ebp], xmm0

; 670  :     chrono::nanoseconds _T0 = chrono::system_clock::now().time_since_epoch();

  00031	8d 45 ac	 lea	 eax, DWORD PTR $T3[ebp]
  00034	50		 push	 eax
  00035	8d 4d b4	 lea	 ecx, DWORD PTR $T4[ebp]
  00038	51		 push	 ecx
  00039	e8 00 00 00 00	 call	 ?now@system_clock@chrono@std@@SA?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ ; std::chrono::system_clock::now
  0003e	83 c4 04	 add	 esp, 4
  00041	8b c8		 mov	 ecx, eax
  00043	e8 00 00 00 00	 call	 ?time_since_epoch@?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QBE?AV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@XZ ; std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >::time_since_epoch
  00048	50		 push	 eax
  00049	8d 4d d4	 lea	 ecx, DWORD PTR __T0$[ebp]
  0004c	e8 00 00 00 00	 call	 ??$?0_JU?$ratio@$00$0JIJGIA@@std@@X@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,std::ratio<1,10000000>,void>

; 671  :     const bool _Clamped     = _Ten_days_d < _Rel_time;

  00051	8b 55 0c	 mov	 edx, DWORD PTR __Rel_time$[ebp]
  00054	52		 push	 edx
  00055	8d 45 e4	 lea	 eax, DWORD PTR __Ten_days_d$[ebp]
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 ??$?MNU?$ratio@$00$00@std@@_JU?$ratio@$00$0DLJKMKAA@@1@@chrono@std@@YA_NABV?$duration@NU?$ratio@$00$00@std@@@01@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z ; std::chrono::operator<<double,std::ratio<1,1>,__int64,std::ratio<1,1000000000> >
  0005e	83 c4 08	 add	 esp, 8
  00061	88 45 cf	 mov	 BYTE PTR __Clamped$[ebp], al

; 672  :     if (_Clamped) {

  00064	0f b6 4d cf	 movzx	 ecx, BYTE PTR __Clamped$[ebp]
  00068	85 c9		 test	 ecx, ecx
  0006a	74 0e		 je	 SHORT $LN2@To_xtime_1

; 673  :         _T0 += _Ten_days;

  0006c	8d 55 f4	 lea	 edx, DWORD PTR __Ten_days$[ebp]
  0006f	52		 push	 edx
  00070	8d 4d d4	 lea	 ecx, DWORD PTR __T0$[ebp]
  00073	e8 00 00 00 00	 call	 ??Y?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAEAAV012@ABV012@@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::operator+=

; 674  :     } else {

  00078	eb 19		 jmp	 SHORT $LN3@To_xtime_1
$LN2@To_xtime_1:

; 675  :         _T0 += chrono::duration_cast<chrono::nanoseconds>(_Rel_time);

  0007a	8b 45 0c	 mov	 eax, DWORD PTR __Rel_time$[ebp]
  0007d	50		 push	 eax
  0007e	8d 4d a4	 lea	 ecx, DWORD PTR $T2[ebp]
  00081	51		 push	 ecx
  00082	e8 00 00 00 00	 call	 ??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@X@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV201@@Z ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000000000>,void>
  00087	83 c4 08	 add	 esp, 8
  0008a	50		 push	 eax
  0008b	8d 4d d4	 lea	 ecx, DWORD PTR __T0$[ebp]
  0008e	e8 00 00 00 00	 call	 ??Y?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAEAAV012@ABV012@@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::operator+=
$LN3@To_xtime_1:

; 676  :     }
; 677  : 
; 678  :     const auto _Whole_seconds = chrono::duration_cast<chrono::seconds>(_T0);

  00093	8d 55 d4	 lea	 edx, DWORD PTR __T0$[ebp]
  00096	52		 push	 edx
  00097	8d 45 c0	 lea	 eax, DWORD PTR __Whole_seconds$[ebp]
  0009a	50		 push	 eax
  0009b	e8 00 00 00 00	 call	 ??$duration_cast@V?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@X@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$00@std@@@01@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1> >,__int64,std::ratio<1,1000000000>,void>
  000a0	83 c4 08	 add	 esp, 8

; 679  :     _Xt.sec                   = _Whole_seconds.count();

  000a3	8d 4d c0	 lea	 ecx, DWORD PTR __Whole_seconds$[ebp]
  000a6	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1> >::count
  000ab	8b 4d 08	 mov	 ecx, DWORD PTR __Xt$[ebp]
  000ae	89 01		 mov	 DWORD PTR [ecx], eax
  000b0	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 680  :     _T0 -= _Whole_seconds;

  000b3	8d 55 c0	 lea	 edx, DWORD PTR __Whole_seconds$[ebp]
  000b6	52		 push	 edx
  000b7	8d 4d 9c	 lea	 ecx, DWORD PTR $T1[ebp]
  000ba	e8 00 00 00 00	 call	 ??$?0_JU?$ratio@$00$00@std@@X@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$00@std@@@12@@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,std::ratio<1,1>,void>
  000bf	8d 45 9c	 lea	 eax, DWORD PTR $T1[ebp]
  000c2	50		 push	 eax
  000c3	8d 4d d4	 lea	 ecx, DWORD PTR __T0$[ebp]
  000c6	e8 00 00 00 00	 call	 ??Z?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAEAAV012@ABV012@@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::operator-=

; 681  :     _Xt.nsec = static_cast<long>(_T0.count());

  000cb	8d 4d d4	 lea	 ecx, DWORD PTR __T0$[ebp]
  000ce	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
  000d3	8b 4d 08	 mov	 ecx, DWORD PTR __Xt$[ebp]
  000d6	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 682  :     return _Clamped;

  000d9	8a 45 cf	 mov	 al, BYTE PTR __Clamped$[ebp]

; 683  : }

  000dc	52		 push	 edx
  000dd	8b cd		 mov	 ecx, ebp
  000df	50		 push	 eax
  000e0	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN10@To_xtime_1
  000e6	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000eb	58		 pop	 eax
  000ec	5a		 pop	 edx
  000ed	5f		 pop	 edi
  000ee	83 c4 64	 add	 esp, 100		; 00000064H
  000f1	3b ec		 cmp	 ebp, esp
  000f3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f8	8b e5		 mov	 esp, ebp
  000fa	5d		 pop	 ebp
  000fb	c3		 ret	 0
$LN10@To_xtime_1:
  000fc	04 00 00 00	 DD	 4
  00100	00 00 00 00	 DD	 $LN9@To_xtime_1
$LN9@To_xtime_1:
  00104	f4 ff ff ff	 DD	 -12			; fffffff4H
  00108	08 00 00 00	 DD	 8
  0010c	00 00 00 00	 DD	 $LN5@To_xtime_1
  00110	e4 ff ff ff	 DD	 -28			; ffffffe4H
  00114	08 00 00 00	 DD	 8
  00118	00 00 00 00	 DD	 $LN6@To_xtime_1
  0011c	d4 ff ff ff	 DD	 -44			; ffffffd4H
  00120	08 00 00 00	 DD	 8
  00124	00 00 00 00	 DD	 $LN7@To_xtime_1
  00128	c0 ff ff ff	 DD	 -64			; ffffffc0H
  0012c	08 00 00 00	 DD	 8
  00130	00 00 00 00	 DD	 $LN8@To_xtime_1
$LN8@To_xtime_1:
  00134	5f		 DB	 95			; 0000005fH
  00135	57		 DB	 87			; 00000057H
  00136	68		 DB	 104			; 00000068H
  00137	6f		 DB	 111			; 0000006fH
  00138	6c		 DB	 108			; 0000006cH
  00139	65		 DB	 101			; 00000065H
  0013a	5f		 DB	 95			; 0000005fH
  0013b	73		 DB	 115			; 00000073H
  0013c	65		 DB	 101			; 00000065H
  0013d	63		 DB	 99			; 00000063H
  0013e	6f		 DB	 111			; 0000006fH
  0013f	6e		 DB	 110			; 0000006eH
  00140	64		 DB	 100			; 00000064H
  00141	73		 DB	 115			; 00000073H
  00142	00		 DB	 0
$LN7@To_xtime_1:
  00143	5f		 DB	 95			; 0000005fH
  00144	54		 DB	 84			; 00000054H
  00145	30		 DB	 48			; 00000030H
  00146	00		 DB	 0
$LN6@To_xtime_1:
  00147	5f		 DB	 95			; 0000005fH
  00148	54		 DB	 84			; 00000054H
  00149	65		 DB	 101			; 00000065H
  0014a	6e		 DB	 110			; 0000006eH
  0014b	5f		 DB	 95			; 0000005fH
  0014c	64		 DB	 100			; 00000064H
  0014d	61		 DB	 97			; 00000061H
  0014e	79		 DB	 121			; 00000079H
  0014f	73		 DB	 115			; 00000073H
  00150	5f		 DB	 95			; 0000005fH
  00151	64		 DB	 100			; 00000064H
  00152	00		 DB	 0
$LN5@To_xtime_1:
  00153	5f		 DB	 95			; 0000005fH
  00154	54		 DB	 84			; 00000054H
  00155	65		 DB	 101			; 00000065H
  00156	6e		 DB	 110			; 0000006eH
  00157	5f		 DB	 95			; 0000005fH
  00158	64		 DB	 100			; 00000064H
  00159	61		 DB	 97			; 00000061H
  0015a	79		 DB	 121			; 00000079H
  0015b	73		 DB	 115			; 00000073H
  0015c	00		 DB	 0
??$_To_xtime_10_day_clamped@_JU?$ratio@$00$0DLJKMKAA@@std@@@std@@YA_NAAUxtime@@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@0@@Z ENDP ; std::_To_xtime_10_day_clamped<__int64,std::ratio<1,1000000000> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\chrono
;	COMDAT ??$?NUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA_NABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?NUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA_NABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z PROC ; std::chrono::operator<=<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,std::chrono::duration<__int64,std::ratio<1,1000000000> > >, COMDAT

; 561  :             is_arithmetic_v<typename _Duration1::rep>&& is_arithmetic_v<typename _Duration2::rep>) { // strengthened

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 562  :         // test for time_point <= time_point
; 563  :         return !(_Right < _Left);

  0000b	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  0000e	50		 push	 eax
  0000f	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 ??$?MUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA_NABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z ; std::chrono::operator<<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
  00018	83 c4 08	 add	 esp, 8
  0001b	0f b6 d0	 movzx	 edx, al
  0001e	85 d2		 test	 edx, edx
  00020	75 09		 jne	 SHORT $LN3@operator
  00022	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv69[ebp], 1
  00029	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$LN4@operator:
  00032	8a 45 fc	 mov	 al, BYTE PTR tv69[ebp]

; 564  :     }

  00035	83 c4 04	 add	 esp, 4
  00038	3b ec		 cmp	 ebp, esp
  0003a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
??$?NUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA_NABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z ENDP ; std::chrono::operator<=<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\chrono
;	COMDAT ??$?0_JU?$ratio@$00$0DOI@@std@@X@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0DOI@@std@@@12@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 8
_this$ = -4						; size = 4
__Dur$ = 8						; size = 4
??$?0_JU?$ratio@$00$0DOI@@std@@X@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0DOI@@std@@@12@@Z PROC ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,std::ratio<1,1000>,void>, COMDAT
; _this$ = ecx

; 86   :             : _MyRep(chrono::duration_cast<duration>(_Dur).count()) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0001e	8b 45 08	 mov	 eax, DWORD PTR __Dur$[ebp]
  00021	50		 push	 eax
  00022	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00025	51		 push	 ecx
  00026	e8 00 00 00 00	 call	 ??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DOI@@3@X@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@@Z ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000>,void>
  0002b	83 c4 08	 add	 esp, 8
  0002e	8b c8		 mov	 ecx, eax
  00030	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
  00035	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	89 01		 mov	 DWORD PTR [ecx], eax
  0003a	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0003d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00040	83 c4 0c	 add	 esp, 12			; 0000000cH
  00043	3b ec		 cmp	 ebp, esp
  00045	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 04 00	 ret	 4
??$?0_JU?$ratio@$00$0DOI@@std@@X@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0DOI@@std@@@12@@Z ENDP ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,std::ratio<1,1000>,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_4d79bb85f269e6e8002a4599002d832c>@@IPBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_4d79bb85f269e6e8002a4599002d832c>@@IPBDI@Z
_TEXT	SEGMENT
__Old_ptr$1 = -48					; size = 4
__Raw_new$ = -44					; size = 4
__New_ptr$ = -36					; size = 4
__Al$ = -28						; size = 4
__New_capacity$ = -24					; size = 4
__Old_capacity$ = -20					; size = 4
__New_size$ = -16					; size = 4
__Old_size$ = -12					; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
_<_Args_1>$ = 20					; size = 4
_<_Args_2>$ = 24					; size = 4
??$_Reallocate_grow_by@V<lambda_4d79bb85f269e6e8002a4599002d832c>@@IPBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_4d79bb85f269e6e8002a4599002d832c>@@IPBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_4d79bb85f269e6e8002a4599002d832c>,unsigned int,char const *,unsigned int>, COMDAT
; _this$ = ecx

; 4108 :     basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	57		 push	 edi
  00007	51		 push	 ecx
  00008	8d 7d d0	 lea	 edi, DWORD PTR [ebp-48]
  0000b	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	59		 pop	 ecx
  00018	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 4109 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 4110 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 4111 :         auto& _My_data            = _Mypair._Myval2;

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 4112 :         const size_type _Old_size = _My_data._Mysize;

  00021	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00024	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00027	89 55 f4	 mov	 DWORD PTR __Old_size$[ebp], edx

; 4113 :         if (max_size() - _Old_size < _Size_increase) {

  0002a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00032	2b 45 f4	 sub	 eax, DWORD PTR __Old_size$[ebp]
  00035	3b 45 08	 cmp	 eax, DWORD PTR __Size_increase$[ebp]
  00038	73 05		 jae	 SHORT $LN2@Reallocate

; 4114 :             _Xlen(); // result too long

  0003a	e8 00 00 00 00	 call	 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN2@Reallocate:

; 4115 :         }
; 4116 : 
; 4117 :         const size_type _New_size     = _Old_size + _Size_increase;

  0003f	8b 45 f4	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00042	03 45 08	 add	 eax, DWORD PTR __Size_increase$[ebp]
  00045	89 45 f0	 mov	 DWORD PTR __New_size$[ebp], eax

; 4118 :         const size_type _Old_capacity = _My_data._Myres;

  00048	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0004b	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0004e	89 55 ec	 mov	 DWORD PTR __Old_capacity$[ebp], edx

; 4119 :         const size_type _New_capacity = _Calculate_growth(_New_size);

  00051	8b 45 f0	 mov	 eax, DWORD PTR __New_size$[ebp]
  00054	50		 push	 eax
  00055	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  0005d	89 45 e8	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 4120 :         auto& _Al                     = _Getal();

  00060	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00063	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00068	89 45 e4	 mov	 DWORD PTR __Al$[ebp], eax

; 4121 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  0006b	8b 4d e8	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  0006e	83 c1 01	 add	 ecx, 1
  00071	51		 push	 ecx
  00072	8b 4d e4	 mov	 ecx, DWORD PTR __Al$[ebp]
  00075	e8 00 00 00 00	 call	 ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate
  0007a	89 45 dc	 mov	 DWORD PTR __New_ptr$[ebp], eax

; 4122 :         _My_data._Orphan_all();

  0007d	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00080	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 4123 :         _My_data._Mysize      = _New_size;

  00085	8b 55 f8	 mov	 edx, DWORD PTR __My_data$[ebp]
  00088	8b 45 f0	 mov	 eax, DWORD PTR __New_size$[ebp]
  0008b	89 42 14	 mov	 DWORD PTR [edx+20], eax

; 4124 :         _My_data._Myres       = _New_capacity;

  0008e	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00091	8b 55 e8	 mov	 edx, DWORD PTR __New_capacity$[ebp]
  00094	89 51 18	 mov	 DWORD PTR [ecx+24], edx

; 4125 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

  00097	8b 45 dc	 mov	 eax, DWORD PTR __New_ptr$[ebp]
  0009a	50		 push	 eax
  0009b	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPADPAD@Z ; std::_Unfancy<char>
  000a0	83 c4 04	 add	 esp, 4
  000a3	89 45 d4	 mov	 DWORD PTR __Raw_new$[ebp], eax

; 4126 :         if (_BUF_SIZE <= _Old_capacity) {

  000a6	83 7d ec 10	 cmp	 DWORD PTR __Old_capacity$[ebp], 16 ; 00000010H
  000aa	72 50		 jb	 SHORT $LN3@Reallocate

; 4127 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  000ac	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  000af	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000b2	89 55 d0	 mov	 DWORD PTR __Old_ptr$1[ebp], edx

; 4128 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);

  000b5	8b 45 18	 mov	 eax, DWORD PTR _<_Args_2>$[ebp]
  000b8	50		 push	 eax
  000b9	8b 4d 14	 mov	 ecx, DWORD PTR _<_Args_1>$[ebp]
  000bc	51		 push	 ecx
  000bd	8b 55 10	 mov	 edx, DWORD PTR _<_Args_0>$[ebp]
  000c0	52		 push	 edx
  000c1	8b 45 f4	 mov	 eax, DWORD PTR __Old_size$[ebp]
  000c4	50		 push	 eax
  000c5	8b 4d d0	 mov	 ecx, DWORD PTR __Old_ptr$1[ebp]
  000c8	51		 push	 ecx
  000c9	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPADPAD@Z ; std::_Unfancy<char>
  000ce	83 c4 04	 add	 esp, 4
  000d1	50		 push	 eax
  000d2	8b 55 d4	 mov	 edx, DWORD PTR __Raw_new$[ebp]
  000d5	52		 push	 edx
  000d6	8d 4d 0c	 lea	 ecx, DWORD PTR __Fn$[ebp]
  000d9	e8 00 00 00 00	 call	 ??R<lambda_4d79bb85f269e6e8002a4599002d832c>@@QBEXQADQBDII1I@Z ; <lambda_4d79bb85f269e6e8002a4599002d832c>::operator()

; 4129 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

  000de	8b 45 ec	 mov	 eax, DWORD PTR __Old_capacity$[ebp]
  000e1	83 c0 01	 add	 eax, 1
  000e4	50		 push	 eax
  000e5	8b 4d d0	 mov	 ecx, DWORD PTR __Old_ptr$1[ebp]
  000e8	51		 push	 ecx
  000e9	8b 4d e4	 mov	 ecx, DWORD PTR __Al$[ebp]
  000ec	e8 00 00 00 00	 call	 ?deallocate@?$allocator@D@std@@QAEXQADI@Z ; std::allocator<char>::deallocate

; 4130 :             _My_data._Bx._Ptr = _New_ptr;

  000f1	8b 55 f8	 mov	 edx, DWORD PTR __My_data$[ebp]
  000f4	8b 45 dc	 mov	 eax, DWORD PTR __New_ptr$[ebp]
  000f7	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 4131 :         } else {

  000fa	eb 36		 jmp	 SHORT $LN4@Reallocate
$LN3@Reallocate:

; 4132 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);

  000fc	8b 4d 18	 mov	 ecx, DWORD PTR _<_Args_2>$[ebp]
  000ff	51		 push	 ecx
  00100	8b 55 14	 mov	 edx, DWORD PTR _<_Args_1>$[ebp]
  00103	52		 push	 edx
  00104	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00107	50		 push	 eax
  00108	8b 4d f4	 mov	 ecx, DWORD PTR __Old_size$[ebp]
  0010b	51		 push	 ecx
  0010c	8b 55 f8	 mov	 edx, DWORD PTR __My_data$[ebp]
  0010f	83 c2 04	 add	 edx, 4
  00112	52		 push	 edx
  00113	8b 45 d4	 mov	 eax, DWORD PTR __Raw_new$[ebp]
  00116	50		 push	 eax
  00117	8d 4d 0c	 lea	 ecx, DWORD PTR __Fn$[ebp]
  0011a	e8 00 00 00 00	 call	 ??R<lambda_4d79bb85f269e6e8002a4599002d832c>@@QBEXQADQBDII1I@Z ; <lambda_4d79bb85f269e6e8002a4599002d832c>::operator()

; 4133 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  0011f	8d 4d dc	 lea	 ecx, DWORD PTR __New_ptr$[ebp]
  00122	51		 push	 ecx
  00123	8b 55 f8	 mov	 edx, DWORD PTR __My_data$[ebp]
  00126	83 c2 04	 add	 edx, 4
  00129	52		 push	 edx
  0012a	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  0012f	83 c4 08	 add	 esp, 8
$LN4@Reallocate:

; 4134 :         }
; 4135 : 
; 4136 :         return *this;

  00132	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
$LN5@Reallocate:

; 4137 :     }

  00135	52		 push	 edx
  00136	8b cd		 mov	 ecx, ebp
  00138	50		 push	 eax
  00139	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN8@Reallocate
  0013f	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00144	58		 pop	 eax
  00145	5a		 pop	 edx
  00146	5f		 pop	 edi
  00147	83 c4 30	 add	 esp, 48			; 00000030H
  0014a	3b ec		 cmp	 ebp, esp
  0014c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00151	8b e5		 mov	 esp, ebp
  00153	5d		 pop	 ebp
  00154	c2 14 00	 ret	 20			; 00000014H
  00157	90		 npad	 1
$LN8@Reallocate:
  00158	01 00 00 00	 DD	 1
  0015c	00 00 00 00	 DD	 $LN7@Reallocate
$LN7@Reallocate:
  00160	dc ff ff ff	 DD	 -36			; ffffffdcH
  00164	04 00 00 00	 DD	 4
  00168	00 00 00 00	 DD	 $LN6@Reallocate
$LN6@Reallocate:
  0016c	5f		 DB	 95			; 0000005fH
  0016d	4e		 DB	 78			; 0000004eH
  0016e	65		 DB	 101			; 00000065H
  0016f	77		 DB	 119			; 00000077H
  00170	5f		 DB	 95			; 0000005fH
  00171	70		 DB	 112			; 00000070H
  00172	74		 DB	 116			; 00000074H
  00173	72		 DB	 114			; 00000072H
  00174	00		 DB	 0
??$_Reallocate_grow_by@V<lambda_4d79bb85f269e6e8002a4599002d832c>@@IPBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_4d79bb85f269e6e8002a4599002d832c>@@IPBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_4d79bb85f269e6e8002a4599002d832c>,unsigned int,char const *,unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring
;	COMDAT ??R<lambda_4d79bb85f269e6e8002a4599002d832c>@@QBEXQADQBDII1I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__New_ptr$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Old_size$ = 16					; size = 4
__Off$ = 20						; size = 4
__Ptr$ = 24						; size = 4
__Count$ = 28						; size = 4
??R<lambda_4d79bb85f269e6e8002a4599002d832c>@@QBEXQADQBDII1I@Z PROC ; <lambda_4d79bb85f269e6e8002a4599002d832c>::operator(), COMDAT
; _this$ = ecx

; 2987 :                 const _Elem* const _Ptr, const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2988 :                 _Traits::copy(_New_ptr, _Old_ptr, _Off);

  0000e	8b 45 14	 mov	 eax, DWORD PTR __Off$[ebp]
  00011	50		 push	 eax
  00012	8b 4d 0c	 mov	 ecx, DWORD PTR __Old_ptr$[ebp]
  00015	51		 push	 ecx
  00016	8b 55 08	 mov	 edx, DWORD PTR __New_ptr$[ebp]
  00019	52		 push	 edx
  0001a	e8 00 00 00 00	 call	 ?copy@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Narrow_char_traits<char,int>::copy
  0001f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2989 :                 _Traits::copy(_New_ptr + _Off, _Ptr, _Count);

  00022	8b 45 1c	 mov	 eax, DWORD PTR __Count$[ebp]
  00025	50		 push	 eax
  00026	8b 4d 18	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00029	51		 push	 ecx
  0002a	8b 55 08	 mov	 edx, DWORD PTR __New_ptr$[ebp]
  0002d	03 55 14	 add	 edx, DWORD PTR __Off$[ebp]
  00030	52		 push	 edx
  00031	e8 00 00 00 00	 call	 ?copy@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Narrow_char_traits<char,int>::copy
  00036	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2990 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

  00039	8b 45 10	 mov	 eax, DWORD PTR __Old_size$[ebp]
  0003c	2b 45 14	 sub	 eax, DWORD PTR __Off$[ebp]
  0003f	83 c0 01	 add	 eax, 1
  00042	50		 push	 eax
  00043	8b 4d 0c	 mov	 ecx, DWORD PTR __Old_ptr$[ebp]
  00046	03 4d 14	 add	 ecx, DWORD PTR __Off$[ebp]
  00049	51		 push	 ecx
  0004a	8b 55 08	 mov	 edx, DWORD PTR __New_ptr$[ebp]
  0004d	03 55 14	 add	 edx, DWORD PTR __Off$[ebp]
  00050	03 55 1c	 add	 edx, DWORD PTR __Count$[ebp]
  00053	52		 push	 edx
  00054	e8 00 00 00 00	 call	 ?copy@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Narrow_char_traits<char,int>::copy
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2991 :             },

  0005c	83 c4 04	 add	 esp, 4
  0005f	3b ec		 cmp	 ebp, esp
  00061	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c2 18 00	 ret	 24			; 00000018H
??R<lambda_4d79bb85f269e6e8002a4599002d832c>@@QBEXQADQBDII1I@Z ENDP ; <lambda_4d79bb85f269e6e8002a4599002d832c>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ??$_Get_size_of_n@$03@std@@YAII@Z
_TEXT	SEGMENT
__Max_possible$1 = -8					; size = 4
__Overflow_is_possible$ = -1				; size = 1
__Count$ = 8						; size = 4
??$_Get_size_of_n@$03@std@@YAII@Z PROC			; std::_Get_size_of_n<4>, COMDAT

; 24   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 25   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00014	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$[ebp], 1

; 26   : 
; 27   :     if
; 28   :         _CONSTEXPR_IF(_Overflow_is_possible) {
; 29   :             constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  00018	c7 45 f8 ff ff
	ff 3f		 mov	 DWORD PTR __Max_possible$1[ebp], 1073741823 ; 3fffffffH

; 30   :             if (_Count > _Max_possible) {

  0001f	81 7d 08 ff ff
	ff 3f		 cmp	 DWORD PTR __Count$[ebp], 1073741823 ; 3fffffffH
  00026	76 05		 jbe	 SHORT $LN2@Get_size_o

; 31   :                 _Throw_bad_array_new_length(); // multiply overflow

  00028	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN2@Get_size_o:

; 32   :             }
; 33   :         }
; 34   : 
; 35   :     return _Count * _Ty_size;

  0002d	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00030	c1 e0 02	 shl	 eax, 2
$LN3@Get_size_o:

; 36   : }

  00033	83 c4 08	 add	 esp, 8
  00036	3b ec		 cmp	 ebp, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
??$_Get_size_of_n@$03@std@@YAII@Z ENDP			; std::_Get_size_of_n<4>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPBDV?$allocator@PBD@std@@@std@@YAPAPBDQAPBD0PAPBDAAV?$allocator@PBD@0@@Z
_TEXT	SEGMENT
__ULast$ = -8						; size = 4
__UFirst$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAPBDV?$allocator@PBD@std@@@std@@YAPAPBDQAPBD0PAPBDAAV?$allocator@PBD@0@@Z PROC ; std::_Uninitialized_move<char const * *,std::allocator<char const *> >, COMDAT

; 1729 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 1730 :     // move [_First, _Last) to raw _Dest, using _Al
; 1731 :     // note: only called internally from elsewhere in the STL
; 1732 :     using _Ptrval     = typename _Alloc::value_type*;
; 1733 :     auto _UFirst      = _Get_unwrapped(_First);

  00014	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 ??$_Get_unwrapped@PBD@std@@YAPAPBDQAPBD@Z ; std::_Get_unwrapped<char const *>
  0001d	83 c4 04	 add	 esp, 4
  00020	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1734 :     const auto _ULast = _Get_unwrapped(_Last);

  00023	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 ??$_Get_unwrapped@PBD@std@@YAPAPBDQAPBD@Z ; std::_Get_unwrapped<char const *>
  0002c	83 c4 04	 add	 esp, 4
  0002f	89 45 f8	 mov	 DWORD PTR __ULast$[ebp], eax

; 1735 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1736 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1737 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  00032	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00035	52		 push	 edx
  00036	e8 00 00 00 00	 call	 ??$_Unfancy@PBD@std@@YAPAPBDPAPBD@Z ; std::_Unfancy<char const *>
  0003b	83 c4 04	 add	 esp, 4
  0003e	50		 push	 eax
  0003f	8b 45 f8	 mov	 eax, DWORD PTR __ULast$[ebp]
  00042	50		 push	 eax
  00043	8b 4d fc	 mov	 ecx, DWORD PTR __UFirst$[ebp]
  00046	51		 push	 ecx
  00047	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPBDPAPBD@std@@YAPAPBDPAPBD00@Z ; std::_Copy_memmove<char const * *,char const * *>
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1738 :         return _Dest + (_ULast - _UFirst);

  0004f	8b 55 f8	 mov	 edx, DWORD PTR __ULast$[ebp]
  00052	2b 55 fc	 sub	 edx, DWORD PTR __UFirst$[ebp]
  00055	c1 fa 02	 sar	 edx, 2
  00058	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0005b	8d 04 90	 lea	 eax, DWORD PTR [eax+edx*4]

; 1739 :         (void) _Al;
; 1740 :     } else {
; 1741 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1742 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1743 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1744 :         }
; 1745 : 
; 1746 :         return _Backout._Release();
; 1747 :     }
; 1748 : }

  0005e	83 c4 08	 add	 esp, 8
  00061	3b ec		 cmp	 ebp, esp
  00063	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
??$_Uninitialized_move@PAPBDV?$allocator@PBD@std@@@std@@YAPAPBDQAPBD0PAPBDAAV?$allocator@PBD@0@@Z ENDP ; std::_Uninitialized_move<char const * *,std::allocator<char const *> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\utility
;	COMDAT ??$exchange@PAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@PAV12@@std@@YAPAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@0@AAPAV10@$$QAPAV10@@Z
_TEXT	SEGMENT
__Old_val$ = -4						; size = 4
__Val$ = 8						; size = 4
__New_val$ = 12						; size = 4
??$exchange@PAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@PAV12@@std@@YAPAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@0@AAPAV10@$$QAPAV10@@Z PROC ; std::exchange<std::tuple<void (__cdecl*)(void *),CPerfMonitor *> *,std::tuple<void (__cdecl*)(void *),CPerfMonitor *> *>, COMDAT

; 526  : _Ty exchange(_Ty& _Val, _Other&& _New_val) { // assign _New_val to _Val, return previous _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 527  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  0000b	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0000e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00010	89 4d fc	 mov	 DWORD PTR __Old_val$[ebp], ecx

; 528  :     _Val         = static_cast<_Other&&>(_New_val);

  00013	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  00016	8b 45 0c	 mov	 eax, DWORD PTR __New_val$[ebp]
  00019	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001b	89 0a		 mov	 DWORD PTR [edx], ecx

; 529  :     return _Old_val;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR __Old_val$[ebp]

; 530  : }

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??$exchange@PAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@PAV12@@std@@YAPAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@0@AAPAV10@$$QAPAV10@@Z ENDP ; std::exchange<std::tuple<void (__cdecl*)(void *),CPerfMonitor *> *,std::tuple<void (__cdecl*)(void *),CPerfMonitor *> *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\type_traits
;	COMDAT ??$move@AAPAVEncodeStatus@@@std@@YA$$QAPAVEncodeStatus@@AAPAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAPAVEncodeStatus@@@std@@YA$$QAPAVEncodeStatus@@AAPAV1@@Z PROC ; std::move<EncodeStatus * &>, COMDAT

; 1432 : _NODISCARD constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept { // forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1433 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1434 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAPAVEncodeStatus@@@std@@YA$$QAPAVEncodeStatus@@AAPAV1@@Z ENDP ; std::move<EncodeStatus * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\type_traits
;	COMDAT ??$move@AAPAVRGYLog@@@std@@YA$$QAPAVRGYLog@@AAPAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAPAVRGYLog@@@std@@YA$$QAPAVRGYLog@@AAPAV1@@Z PROC ; std::move<RGYLog * &>, COMDAT

; 1432 : _NODISCARD constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept { // forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1433 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1434 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAPAVRGYLog@@@std@@YA$$QAPAVRGYLog@@AAPAV1@@Z ENDP ; std::move<RGYLog * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\type_traits
;	COMDAT ??$move@AAPAV_Ref_count_base@std@@@std@@YA$$QAPAV_Ref_count_base@0@AAPAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAPAV_Ref_count_base@std@@@std@@YA$$QAPAV_Ref_count_base@0@AAPAV10@@Z PROC ; std::move<std::_Ref_count_base * &>, COMDAT

; 1432 : _NODISCARD constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept { // forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1433 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1434 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAPAV_Ref_count_base@std@@@std@@YA$$QAPAV_Ref_count_base@0@AAPAV10@@Z ENDP ; std::move<std::_Ref_count_base * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\type_traits
;	COMDAT ??$move@AAPAVCPerfMonitor@@@std@@YA$$QAPAVCPerfMonitor@@AAPAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAPAVCPerfMonitor@@@std@@YA$$QAPAVCPerfMonitor@@AAPAV1@@Z PROC ; std::move<CPerfMonitor * &>, COMDAT

; 1432 : _NODISCARD constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept { // forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1433 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1434 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAPAVCPerfMonitor@@@std@@YA$$QAPAVCPerfMonitor@@AAPAV1@@Z ENDP ; std::move<CPerfMonitor * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Ptr$ = -12						; size = 4
__Ptr_container$ = -8					; size = 4
__Block_size$ = -4					; size = 4
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 83   : _DECLSPEC_ALLOCATOR void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000e	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00015	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 84   :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 85   :     const size_t _Block_size = _Non_user_size + _Bytes;

  0001c	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  0001f	83 c0 27	 add	 eax, 39			; 00000027H
  00022	89 45 fc	 mov	 DWORD PTR __Block_size$[ebp], eax

; 86   :     if (_Block_size <= _Bytes) {

  00025	8b 4d fc	 mov	 ecx, DWORD PTR __Block_size$[ebp]
  00028	3b 4d 08	 cmp	 ecx, DWORD PTR __Bytes$[ebp]
  0002b	77 05		 ja	 SHORT $LN8@Allocate_m

; 87   :         _Throw_bad_array_new_length(); // add overflow

  0002d	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN8@Allocate_m:

; 88   :     }
; 89   : 
; 90   :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00032	8b 55 fc	 mov	 edx, DWORD PTR __Block_size$[ebp]
  00035	52		 push	 edx
  00036	e8 00 00 00 00	 call	 ?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
  0003b	83 c4 04	 add	 esp, 4
  0003e	89 45 f8	 mov	 DWORD PTR __Ptr_container$[ebp], eax
$LN4@Allocate_m:

; 91   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00041	83 7d f8 00	 cmp	 DWORD PTR __Ptr_container$[ebp], 0
  00045	74 02		 je	 SHORT $LN7@Allocate_m
  00047	eb 56		 jmp	 SHORT $LN2@Allocate_m
$LN7@Allocate_m:
  00049	8b f4		 mov	 esi, esp
  0004b	68 00 00 00 00	 push	 OFFSET $SG131906
  00050	68 00 00 00 00	 push	 OFFSET $SG131907
  00055	6a 00		 push	 0
  00057	6a 5b		 push	 91			; 0000005bH
  00059	68 00 00 00 00	 push	 OFFSET $SG131908
  0005e	6a 02		 push	 2
  00060	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  00066	83 c4 18	 add	 esp, 24			; 00000018H
  00069	3b f4		 cmp	 esi, esp
  0006b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00070	83 f8 01	 cmp	 eax, 1
  00073	75 01		 jne	 SHORT $LN12@Allocate_m
  00075	cc		 int	 3
$LN12@Allocate_m:
  00076	8b f4		 mov	 esi, esp
  00078	6a 00		 push	 0
  0007a	6a 5b		 push	 91			; 0000005bH
  0007c	68 00 00 00 00	 push	 OFFSET $SG131909
  00081	68 00 00 00 00	 push	 OFFSET $SG131910
  00086	68 00 00 00 00	 push	 OFFSET $SG131911
  0008b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  00091	83 c4 14	 add	 esp, 20			; 00000014H
  00094	3b f4		 cmp	 esi, esp
  00096	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009b	33 c9		 xor	 ecx, ecx
  0009d	75 aa		 jne	 SHORT $LN7@Allocate_m
$LN2@Allocate_m:
  0009f	33 d2		 xor	 edx, edx
  000a1	75 9e		 jne	 SHORT $LN4@Allocate_m

; 92   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  000a3	8b 45 f8	 mov	 eax, DWORD PTR __Ptr_container$[ebp]
  000a6	83 c0 27	 add	 eax, 39			; 00000027H
  000a9	83 e0 e0	 and	 eax, -32		; ffffffe0H
  000ac	89 45 f4	 mov	 DWORD PTR __Ptr$[ebp], eax

; 93   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  000af	b9 04 00 00 00	 mov	 ecx, 4
  000b4	6b d1 ff	 imul	 edx, ecx, -1
  000b7	8b 45 f4	 mov	 eax, DWORD PTR __Ptr$[ebp]
  000ba	8b 4d f8	 mov	 ecx, DWORD PTR __Ptr_container$[ebp]
  000bd	89 0c 10	 mov	 DWORD PTR [eax+edx], ecx

; 94   : 
; 95   : #ifdef _DEBUG
; 96   :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;

  000c0	ba 04 00 00 00	 mov	 edx, 4
  000c5	6b c2 fe	 imul	 eax, edx, -2
  000c8	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  000cb	c7 04 01 fa fa
	fa fa		 mov	 DWORD PTR [ecx+eax], -84215046 ; fafafafaH

; 97   : #endif // _DEBUG
; 98   :     return _Ptr;

  000d2	8b 45 f4	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN11@Allocate_m:

; 99   : }

  000d5	5e		 pop	 esi
  000d6	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d9	3b ec		 cmp	 ebp, esp
  000db	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e0	8b e5		 mov	 esp, ebp
  000e2	5d		 pop	 ebp
  000e3	c3		 ret	 0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\type_traits
;	COMDAT ??$forward@ABQAD@std@@YAABQADABQAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABQAD@std@@YAABQADABQAD@Z PROC		; std::forward<char * const &>, COMDAT

; 1420 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1421 :     return static_cast<_Ty&&>(_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1422 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABQAD@std@@YAABQADABQAD@Z ENDP		; std::forward<char * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstddef
;	COMDAT ??$addressof@PAD@std@@YAPAPADAAPAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAD@std@@YAPAPADAAPAD@Z PROC		; std::addressof<char *>, COMDAT

; 279  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept { // return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  :     return __builtin_addressof(_Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 281  : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@PAD@std@@YAPAPADAAPAD@Z ENDP		; std::addressof<char *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\type_traits
;	COMDAT ??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z PROC ; std::forward<std::_Container_base12 *>, COMDAT

; 1420 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1421 :     return static_cast<_Ty&&>(_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1422 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z ENDP ; std::forward<std::_Container_base12 *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstddef
;	COMDAT ??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z PROC ; std::addressof<std::_Container_proxy>, COMDAT

; 279  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept { // return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  :     return __builtin_addressof(_Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 281  : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z ENDP ; std::addressof<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\type_traits
;	COMDAT ??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z PROC ; std::forward<std::allocator<char> >, COMDAT

; 1420 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1421 :     return static_cast<_Ty&&>(_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1422 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ENDP ; std::forward<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z PROC ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >, COMDAT

; 1081 : void _Deallocate_plain(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 1082 :     // deallocate a plain pointer using an allocator
; 1083 :     using _Alloc_traits = allocator_traits<_Alloc>;
; 1084 :     if constexpr (is_same_v<_Alloc_ptr_t<_Alloc>, typename _Alloc::value_type*>) {
; 1085 :         _Alloc_traits::deallocate(_Al, _Ptr, 1);

  00022	6a 01		 push	 1
  00024	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00027	50		 push	 eax
  00028	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  0002b	51		 push	 ecx
  0002c	e8 00 00 00 00	 call	 ?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1086 :     } else {
; 1087 :         using _Ptr_traits = pointer_traits<_Alloc_ptr_t<_Alloc>>;
; 1088 :         _Alloc_traits::deallocate(_Al, _Ptr_traits::pointer_to(*_Ptr), 1);
; 1089 :     }
; 1090 : }

  00034	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00037	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0003e	59		 pop	 ecx
  0003f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00042	3b ec		 cmp	 ebp, esp
  00044	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ENDP ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\chrono
;	COMDAT ??$?HUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@_JU?$ratio@$00$0DOI@@2@@chrono@std@@YA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@ABV201@ABV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@@Z
_TEXT	SEGMENT
$T1 = -16						; size = 8
$T2 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@_JU?$ratio@$00$0DOI@@2@@chrono@std@@YA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@ABV201@ABV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@@Z PROC ; std::chrono::operator+<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000> >, COMDAT

; 497  :         _NOEXCEPT_COND(is_arithmetic_v<typename _Duration::rep>&& is_arithmetic_v<_Rep>) { // strengthened

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000e	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00011	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00014	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 498  :         // add duration to time_point
; 499  :         using _RT = time_point<_Clock, common_type_t<_Duration, duration<_Rep, _Period>>>;
; 500  :         return _RT(_Left.time_since_epoch() + _Right);

  00017	8b 45 10	 mov	 eax, DWORD PTR __Right$[ebp]
  0001a	50		 push	 eax
  0001b	8d 4d f8	 lea	 ecx, DWORD PTR $T2[ebp]
  0001e	51		 push	 ecx
  0001f	8b 4d 0c	 mov	 ecx, DWORD PTR __Left$[ebp]
  00022	e8 00 00 00 00	 call	 ?time_since_epoch@?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QBE?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@XZ ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_since_epoch
  00027	50		 push	 eax
  00028	8d 55 f0	 lea	 edx, DWORD PTR $T1[ebp]
  0002b	52		 push	 edx
  0002c	e8 00 00 00 00	 call	 ??$?H_JU?$ratio@$00$0DLJKMKAA@@std@@_JU?$ratio@$00$0DOI@@1@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV201@ABV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@@Z ; std::chrono::operator+<__int64,std::ratio<1,1000000000>,__int64,std::ratio<1,1000> >
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH
  00034	50		 push	 eax
  00035	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00038	e8 00 00 00 00	 call	 ??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
  0003d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 501  :     }

  00040	83 c4 10	 add	 esp, 16			; 00000010H
  00043	3b ec		 cmp	 ebp, esp
  00045	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
??$?HUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@_JU?$ratio@$00$0DOI@@2@@chrono@std@@YA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@ABV201@ABV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@@Z ENDP ; std::chrono::operator+<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\thread
;	COMDAT ??$_Invoke@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@$0A@$00@thread@std@@CGIPAX@Z
_TEXT	SEGMENT
$T2 = -32						; size = 4
__Tup$ = -28						; size = 4
__FnVals$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__RawVals$ = 8						; size = 4
??$_Invoke@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@$0A@$00@thread@std@@CGIPAX@Z PROC ; std::thread::_Invoke<std::tuple<void (__cdecl*)(void *),CPerfMonitor *>,0,1>, COMDAT

; 36   :     static unsigned int __stdcall _Invoke(void* _RawVals) noexcept { // enforces termination

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Invoke@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@$0A@$00@thread@std@@CGIPAX@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  0001c	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  0001f	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00022	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00025	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002d	33 c5		 xor	 eax, ebp
  0002f	50		 push	 eax
  00030	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00033	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 37   :         // adapt invoke of user's callable object to _beginthreadex's thread procedure
; 38   :         const unique_ptr<_Tuple> _FnVals(static_cast<_Tuple*>(_RawVals));

  00039	8b 45 08	 mov	 eax, DWORD PTR __RawVals$[ebp]
  0003c	50		 push	 eax
  0003d	8d 4d ec	 lea	 ecx, DWORD PTR __FnVals$[ebp]
  00040	e8 00 00 00 00	 call	 ??$?0U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@std@@$0A@@?$unique_ptr@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@2@@std@@QAE@PAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@1@@Z ; std::unique_ptr<std::tuple<void (__cdecl*)(void *),CPerfMonitor *>,std::default_delete<std::tuple<void (__cdecl*)(void *),CPerfMonitor *> > >::unique_ptr<std::tuple<void (__cdecl*)(void *),CPerfMonitor *>,std::default_delete<std::tuple<void (__cdecl*)(void *),CPerfMonitor *> > ><std::default_delete<std::tuple<void (__cdecl*)(void *),CPerfMonitor *> >,0>
  00045	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 39   :         _Tuple& _Tup = *_FnVals;

  0004c	8d 4d ec	 lea	 ecx, DWORD PTR __FnVals$[ebp]
  0004f	e8 00 00 00 00	 call	 ??D?$unique_ptr@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@2@@std@@QBEAAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@1@XZ ; std::unique_ptr<std::tuple<void (__cdecl*)(void *),CPerfMonitor *>,std::default_delete<std::tuple<void (__cdecl*)(void *),CPerfMonitor *> > >::operator*
  00054	89 45 e4	 mov	 DWORD PTR __Tup$[ebp], eax

; 40   :         _STD invoke(_STD move(_STD get<_Indices>(_Tup))...);

  00057	8b 4d e4	 mov	 ecx, DWORD PTR __Tup$[ebp]
  0005a	51		 push	 ecx
  0005b	e8 00 00 00 00	 call	 ??$get@$00P6AXPAX@ZPAVCPerfMonitor@@@std@@YAAAPAVCPerfMonitor@@AAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@0@@Z ; std::get<1,void (__cdecl*)(void *),CPerfMonitor *>
  00060	83 c4 04	 add	 esp, 4
  00063	50		 push	 eax
  00064	e8 00 00 00 00	 call	 ??$move@AAPAVCPerfMonitor@@@std@@YA$$QAPAVCPerfMonitor@@AAPAV1@@Z ; std::move<CPerfMonitor * &>
  00069	83 c4 04	 add	 esp, 4
  0006c	50		 push	 eax
  0006d	8b 55 e4	 mov	 edx, DWORD PTR __Tup$[ebp]
  00070	52		 push	 edx
  00071	e8 00 00 00 00	 call	 ??$get@$0A@P6AXPAX@ZPAVCPerfMonitor@@@std@@YAAAP6AXPAX@ZAAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@0@@Z ; std::get<0,void (__cdecl*)(void *),CPerfMonitor *>
  00076	83 c4 04	 add	 esp, 4
  00079	50		 push	 eax
  0007a	e8 00 00 00 00	 call	 ??$move@AAP6AXPAX@Z@std@@YA$$QAP6AXPAX@ZAAP6AX0@Z@Z ; std::move<void (__cdecl*&)(void *)>
  0007f	83 c4 04	 add	 esp, 4
  00082	50		 push	 eax
  00083	e8 00 00 00 00	 call	 ??$invoke@P6AXPAX@ZPAVCPerfMonitor@@@std@@YAX$$QAP6AXPAX@Z$$QAPAVCPerfMonitor@@@Z ; std::invoke<void (__cdecl*)(void *),CPerfMonitor *>
  00088	83 c4 08	 add	 esp, 8

; 41   :         _Cnd_do_broadcast_at_thread_exit(); // TRANSITION, ABI

  0008b	e8 00 00 00 00	 call	 __Cnd_do_broadcast_at_thread_exit

; 42   :         return 0;

  00090	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  00097	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0009e	8d 4d ec	 lea	 ecx, DWORD PTR __FnVals$[ebp]
  000a1	e8 00 00 00 00	 call	 ??1?$unique_ptr@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::tuple<void (__cdecl*)(void *),CPerfMonitor *>,std::default_delete<std::tuple<void (__cdecl*)(void *),CPerfMonitor *> > >::~unique_ptr<std::tuple<void (__cdecl*)(void *),CPerfMonitor *>,std::default_delete<std::tuple<void (__cdecl*)(void *),CPerfMonitor *> > >
  000a6	8b 45 e0	 mov	 eax, DWORD PTR $T2[ebp]

; 43   :     }

  000a9	52		 push	 edx
  000aa	8b cd		 mov	 ecx, ebp
  000ac	50		 push	 eax
  000ad	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN7@Invoke
  000b3	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000b8	58		 pop	 eax
  000b9	5a		 pop	 edx
  000ba	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000bd	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000c4	59		 pop	 ecx
  000c5	83 c4 20	 add	 esp, 32			; 00000020H
  000c8	3b ec		 cmp	 ebp, esp
  000ca	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000cf	8b e5		 mov	 esp, ebp
  000d1	5d		 pop	 ebp
  000d2	c2 04 00	 ret	 4
  000d5	0f 1f 00	 npad	 3
$LN7@Invoke:
  000d8	01 00 00 00	 DD	 1
  000dc	00 00 00 00	 DD	 $LN6@Invoke
$LN6@Invoke:
  000e0	ec ff ff ff	 DD	 -20			; ffffffecH
  000e4	04 00 00 00	 DD	 4
  000e8	00 00 00 00	 DD	 $LN4@Invoke
$LN4@Invoke:
  000ec	5f		 DB	 95			; 0000005fH
  000ed	46		 DB	 70			; 00000046H
  000ee	6e		 DB	 110			; 0000006eH
  000ef	56		 DB	 86			; 00000056H
  000f0	61		 DB	 97			; 00000061H
  000f1	6c		 DB	 108			; 0000006cH
  000f2	73		 DB	 115			; 00000073H
  000f3	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Invoke@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@$0A@$00@thread@std@@CGIPAX@Z$0:
  00000	8d 4d ec	 lea	 ecx, DWORD PTR __FnVals$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$unique_ptr@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::tuple<void (__cdecl*)(void *),CPerfMonitor *>,std::default_delete<std::tuple<void (__cdecl*)(void *),CPerfMonitor *> > >::~unique_ptr<std::tuple<void (__cdecl*)(void *),CPerfMonitor *>,std::default_delete<std::tuple<void (__cdecl*)(void *),CPerfMonitor *> > >
__ehhandler$??$_Invoke@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@$0A@$00@thread@std@@CGIPAX@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Invoke@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@$0A@$00@thread@std@@CGIPAX@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Invoke@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@$0A@$00@thread@std@@CGIPAX@Z ENDP ; std::thread::_Invoke<std::tuple<void (__cdecl*)(void *),CPerfMonitor *>,0,1>
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@std@@PAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@2@$00@std@@QAEAAU?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@std@@PAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@2@$00@std@@QAEAAU?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::default_delete<std::tuple<void (__cdecl*)(void *),CPerfMonitor *> >,std::tuple<void (__cdecl*)(void *),CPerfMonitor *> *,1>::_Get_first, COMDAT
; _this$ = ecx

; 1420 :     _Ty1& _Get_first() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1421 :         return *this;

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1422 :     }

  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@std@@PAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@2@$00@std@@QAEAAU?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::default_delete<std::tuple<void (__cdecl*)(void *),CPerfMonitor *> >,std::tuple<void (__cdecl*)(void *),CPerfMonitor *> *,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\memory
;	COMDAT ?release@?$unique_ptr@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@2@@std@@QAEPAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@2@XZ
_TEXT	SEGMENT
$T2 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?release@?$unique_ptr@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@2@@std@@QAEPAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@2@XZ PROC ; std::unique_ptr<std::tuple<void (__cdecl*)(void *),CPerfMonitor *>,std::default_delete<std::tuple<void (__cdecl*)(void *),CPerfMonitor *> > >::release, COMDAT
; _this$ = ecx

; 1903 :     pointer release() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?release@?$unique_ptr@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@2@@std@@QAEPAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@2@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	c7 45 ec cc cc
	cc cc		 mov	 DWORD PTR [ebp-20], -858993460 ; ccccccccH
  0001b	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00027	33 c5		 xor	 eax, ebp
  00029	50		 push	 eax
  0002a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0002d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00033	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1904 :         return _STD exchange(_Mypair._Myval2, pointer());

  00036	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  0003d	8d 45 ec	 lea	 eax, DWORD PTR $T2[ebp]
  00040	50		 push	 eax
  00041	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	51		 push	 ecx
  00045	e8 00 00 00 00	 call	 ??$exchange@PAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@PAV12@@std@@YAPAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@0@AAPAV10@$$QAPAV10@@Z ; std::exchange<std::tuple<void (__cdecl*)(void *),CPerfMonitor *> *,std::tuple<void (__cdecl*)(void *),CPerfMonitor *> *>
  0004a	83 c4 08	 add	 esp, 8

; 1905 :     }

  0004d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00050	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00057	59		 pop	 ecx
  00058	83 c4 14	 add	 esp, 20			; 00000014H
  0005b	3b ec		 cmp	 ebp, esp
  0005d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?release@?$unique_ptr@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@2@@std@@QAEPAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@2@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?release@?$unique_ptr@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@2@@std@@QAEPAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@2@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?release@?$unique_ptr@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@2@@std@@QAEPAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@2@XZ ENDP ; std::unique_ptr<std::tuple<void (__cdecl*)(void *),CPerfMonitor *>,std::default_delete<std::tuple<void (__cdecl*)(void *),CPerfMonitor *> > >::release
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\memory
;	COMDAT ?get@?$unique_ptr@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@2@@std@@QBEPAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$unique_ptr@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@2@@std@@QBEPAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@2@XZ PROC ; std::unique_ptr<std::tuple<void (__cdecl*)(void *),CPerfMonitor *>,std::default_delete<std::tuple<void (__cdecl*)(void *),CPerfMonitor *> > >::get, COMDAT
; _this$ = ecx

; 1895 :     _NODISCARD pointer get() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1896 :         return _Mypair._Myval2;

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 00		 mov	 eax, DWORD PTR [eax]

; 1897 :     }

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?get@?$unique_ptr@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@2@@std@@QBEPAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@2@XZ ENDP ; std::unique_ptr<std::tuple<void (__cdecl*)(void *),CPerfMonitor *>,std::default_delete<std::tuple<void (__cdecl*)(void *),CPerfMonitor *> > >::get
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\memory
;	COMDAT ??D?$unique_ptr@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@2@@std@@QBEAAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$unique_ptr@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@2@@std@@QBEAAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@1@XZ PROC ; std::unique_ptr<std::tuple<void (__cdecl*)(void *),CPerfMonitor *>,std::default_delete<std::tuple<void (__cdecl*)(void *),CPerfMonitor *> > >::operator*, COMDAT
; _this$ = ecx

; 1887 :     _NODISCARD add_lvalue_reference_t<_Ty> operator*() const noexcept { // strengthened

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1888 :         return *_Mypair._Myval2;

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 00		 mov	 eax, DWORD PTR [eax]

; 1889 :     }

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??D?$unique_ptr@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@2@@std@@QBEAAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@1@XZ ENDP ; std::unique_ptr<std::tuple<void (__cdecl*)(void *),CPerfMonitor *>,std::default_delete<std::tuple<void (__cdecl*)(void *),CPerfMonitor *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\memory
;	COMDAT ??1?$unique_ptr@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$unique_ptr@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@2@@std@@QAE@XZ PROC ; std::unique_ptr<std::tuple<void (__cdecl*)(void *),CPerfMonitor *>,std::default_delete<std::tuple<void (__cdecl*)(void *),CPerfMonitor *> > >::~unique_ptr<std::tuple<void (__cdecl*)(void *),CPerfMonitor *>,std::default_delete<std::tuple<void (__cdecl*)(void *),CPerfMonitor *> > >, COMDAT
; _this$ = ecx

; 1873 :     ~unique_ptr() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1874 :         if (_Mypair._Myval2) {

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	83 38 00	 cmp	 DWORD PTR [eax], 0
  00014	74 15		 je	 SHORT $LN1@unique_ptr

; 1875 :             _Mypair._Get_first()(_Mypair._Myval2);

  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001b	52		 push	 edx
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@std@@PAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@2@$00@std@@QAEAAU?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@2@XZ ; std::_Compressed_pair<std::default_delete<std::tuple<void (__cdecl*)(void *),CPerfMonitor *> >,std::tuple<void (__cdecl*)(void *),CPerfMonitor *> *,1>::_Get_first
  00024	8b c8		 mov	 ecx, eax
  00026	e8 00 00 00 00	 call	 ??R?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@std@@QBEXPAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@1@@Z ; std::default_delete<std::tuple<void (__cdecl*)(void *),CPerfMonitor *> >::operator()
$LN1@unique_ptr:

; 1876 :         }
; 1877 :     }

  0002b	83 c4 04	 add	 esp, 4
  0002e	3b ec		 cmp	 ebp, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
??1?$unique_ptr@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@2@@std@@QAE@XZ ENDP ; std::unique_ptr<std::tuple<void (__cdecl*)(void *),CPerfMonitor *>,std::default_delete<std::tuple<void (__cdecl*)(void *),CPerfMonitor *> > >::~unique_ptr<std::tuple<void (__cdecl*)(void *),CPerfMonitor *>,std::default_delete<std::tuple<void (__cdecl*)(void *),CPerfMonitor *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\memory
;	COMDAT ??R?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@std@@QBEXPAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@1@@Z
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??R?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@std@@QBEXPAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@1@@Z PROC ; std::default_delete<std::tuple<void (__cdecl*)(void *),CPerfMonitor *> >::operator(), COMDAT
; _this$ = ecx

; 1765 :     void operator()(_Ty* _Ptr) const noexcept { // delete a pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1766 :         static_assert(0 < sizeof(_Ty), "can't delete an incomplete type");
; 1767 :         delete _Ptr;

  00017	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0001a	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
  0001d	6a 08		 push	 8
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR $T1[ebp]
  00022	51		 push	 ecx
  00023	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00028	83 c4 08	 add	 esp, 8

; 1768 :     }

  0002b	83 c4 08	 add	 esp, 8
  0002e	3b ec		 cmp	 ebp, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
??R?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@std@@QBEXPAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@1@@Z ENDP ; std::default_delete<std::tuple<void (__cdecl*)(void *),CPerfMonitor *> >::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\memory
;	COMDAT ??$make_unique@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@A6AXPAX@ZPAVCPerfMonitor@@$0A@@std@@YA?AV?$unique_ptr@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@2@@0@A6AXPAX@Z$$QAPAVCPerfMonitor@@@Z
_TEXT	SEGMENT
tv80 = -24						; size = 4
$T2 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_<_Args_0>$ = 12					; size = 4
_<_Args_1>$ = 16					; size = 4
??$make_unique@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@A6AXPAX@ZPAVCPerfMonitor@@$0A@@std@@YA?AV?$unique_ptr@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@2@@0@A6AXPAX@Z$$QAPAVCPerfMonitor@@@Z PROC ; std::make_unique<std::tuple<void (__cdecl*)(void *),CPerfMonitor *>,void (__cdecl&)(void *),CPerfMonitor *,0>, COMDAT

; 2056 : _NODISCARD unique_ptr<_Ty> make_unique(_Types&&... _Args) { // make a unique_ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$make_unique@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@A6AXPAX@ZPAVCPerfMonitor@@$0A@@std@@YA?AV?$unique_ptr@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@2@@0@A6AXPAX@Z$$QAPAVCPerfMonitor@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	c7 45 e8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-24], -858993460 ; ccccccccH
  0001b	c7 45 ec cc cc
	cc cc		 mov	 DWORD PTR [ebp-20], -858993460 ; ccccccccH
  00022	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00029	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002e	33 c5		 xor	 eax, ebp
  00030	50		 push	 eax
  00031	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00034	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003a	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0

; 2057 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

  00041	6a 08		 push	 8
  00043	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00048	83 c4 04	 add	 esp, 4
  0004b	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax
  0004e	83 7d f0 00	 cmp	 DWORD PTR $T3[ebp], 0
  00052	74 27		 je	 SHORT $LN3@make_uniqu
  00054	8b 45 10	 mov	 eax, DWORD PTR _<_Args_1>$[ebp]
  00057	50		 push	 eax
  00058	e8 00 00 00 00	 call	 ??$forward@PAVCPerfMonitor@@@std@@YA$$QAPAVCPerfMonitor@@AAPAV1@@Z ; std::forward<CPerfMonitor *>
  0005d	83 c4 04	 add	 esp, 4
  00060	50		 push	 eax
  00061	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00064	51		 push	 ecx
  00065	e8 00 00 00 00	 call	 ??$forward@A6AXPAX@Z@std@@YAA6AXPAX@ZA6AX0@Z@Z ; std::forward<void (__cdecl&)(void *)>
  0006a	83 c4 04	 add	 esp, 4
  0006d	50		 push	 eax
  0006e	8b 4d f0	 mov	 ecx, DWORD PTR $T3[ebp]
  00071	e8 00 00 00 00	 call	 ??$?0A6AXPAX@ZPAVCPerfMonitor@@$0A@@?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@QAE@A6AXPAX@Z$$QAPAVCPerfMonitor@@@Z ; std::tuple<void (__cdecl*)(void *),CPerfMonitor *>::tuple<void (__cdecl*)(void *),CPerfMonitor *><void (__cdecl&)(void *),CPerfMonitor *,0>
  00076	89 45 e8	 mov	 DWORD PTR tv80[ebp], eax
  00079	eb 07		 jmp	 SHORT $LN4@make_uniqu
$LN3@make_uniqu:
  0007b	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv80[ebp], 0
$LN4@make_uniqu:
  00082	8b 55 e8	 mov	 edx, DWORD PTR tv80[ebp]
  00085	52		 push	 edx
  00086	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00089	e8 00 00 00 00	 call	 ??$?0U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@std@@$0A@@?$unique_ptr@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@2@@std@@QAE@PAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@1@@Z ; std::unique_ptr<std::tuple<void (__cdecl*)(void *),CPerfMonitor *>,std::default_delete<std::tuple<void (__cdecl*)(void *),CPerfMonitor *> > >::unique_ptr<std::tuple<void (__cdecl*)(void *),CPerfMonitor *>,std::default_delete<std::tuple<void (__cdecl*)(void *),CPerfMonitor *> > ><std::default_delete<std::tuple<void (__cdecl*)(void *),CPerfMonitor *> >,0>
  0008e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00095	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00098	83 c8 01	 or	 eax, 1
  0009b	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
  0009e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2058 : }

  000a1	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ab	59		 pop	 ecx
  000ac	83 c4 18	 add	 esp, 24			; 00000018H
  000af	3b ec		 cmp	 ebp, esp
  000b1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b6	8b e5		 mov	 esp, ebp
  000b8	5d		 pop	 ebp
  000b9	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$make_unique@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@A6AXPAX@ZPAVCPerfMonitor@@$0A@@std@@YA?AV?$unique_ptr@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@2@@0@A6AXPAX@Z$$QAPAVCPerfMonitor@@@Z$0:
  00000	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0c 00 00
	00		 je	 $LN6@make_uniqu
  0000c	83 65 ec fe	 and	 DWORD PTR $T2[ebp], -2	; fffffffeH
  00010	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$unique_ptr@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::tuple<void (__cdecl*)(void *),CPerfMonitor *>,std::default_delete<std::tuple<void (__cdecl*)(void *),CPerfMonitor *> > >::~unique_ptr<std::tuple<void (__cdecl*)(void *),CPerfMonitor *>,std::default_delete<std::tuple<void (__cdecl*)(void *),CPerfMonitor *> > >
$LN6@make_uniqu:
  00018	c3		 ret	 0
__ehhandler$??$make_unique@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@A6AXPAX@ZPAVCPerfMonitor@@$0A@@std@@YA?AV?$unique_ptr@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@2@@0@A6AXPAX@Z$$QAPAVCPerfMonitor@@@Z:
  00019	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00020	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$make_unique@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@A6AXPAX@ZPAVCPerfMonitor@@$0A@@std@@YA?AV?$unique_ptr@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@2@@0@A6AXPAX@Z$$QAPAVCPerfMonitor@@@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$make_unique@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@A6AXPAX@ZPAVCPerfMonitor@@$0A@@std@@YA?AV?$unique_ptr@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@2@@0@A6AXPAX@Z$$QAPAVCPerfMonitor@@@Z ENDP ; std::make_unique<std::tuple<void (__cdecl*)(void *),CPerfMonitor *>,void (__cdecl&)(void *),CPerfMonitor *,0>
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\type_traits
;	COMDAT ??$forward@PAVCPerfMonitor@@@std@@YA$$QAPAVCPerfMonitor@@AAPAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@PAVCPerfMonitor@@@std@@YA$$QAPAVCPerfMonitor@@AAPAV1@@Z PROC ; std::forward<CPerfMonitor *>, COMDAT

; 1420 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1421 :     return static_cast<_Ty&&>(_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1422 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@PAVCPerfMonitor@@@std@@YA$$QAPAVCPerfMonitor@@AAPAV1@@Z ENDP ; std::forward<CPerfMonitor *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\type_traits
;	COMDAT ??$forward@A6AXPAX@Z@std@@YAA6AXPAX@ZA6AX0@Z@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@A6AXPAX@Z@std@@YAA6AXPAX@ZA6AX0@Z@Z PROC	; std::forward<void (__cdecl&)(void *)>, COMDAT

; 1420 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1421 :     return static_cast<_Ty&&>(_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1422 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@A6AXPAX@Z@std@@YAA6AXPAX@ZA6AX0@Z@Z ENDP	; std::forward<void (__cdecl&)(void *)>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ??$?0AAPAVRGYPipeProcess@@@?$_Compressed_pair@U?$default_delete@VRGYPipeProcess@@@std@@PAVRGYPipeProcess@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAVRGYPipeProcess@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
_<_Val2_0>$ = 12					; size = 4
??$?0AAPAVRGYPipeProcess@@@?$_Compressed_pair@U?$default_delete@VRGYPipeProcess@@@std@@PAVRGYPipeProcess@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAVRGYPipeProcess@@@Z PROC ; std::_Compressed_pair<std::default_delete<RGYPipeProcess>,RGYPipeProcess *,1>::_Compressed_pair<std::default_delete<RGYPipeProcess>,RGYPipeProcess *,1><RGYPipeProcess * &>, COMDAT
; _this$ = ecx

; 1414 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 0c	 mov	 eax, DWORD PTR _<_Val2_0>$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$forward@AAPAVRGYPipeProcess@@@std@@YAAAPAVRGYPipeProcess@@AAPAV1@@Z ; std::forward<RGYPipeProcess * &>
  00017	83 c4 04	 add	 esp, 4
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	8b 10		 mov	 edx, DWORD PTR [eax]
  0001f	89 11		 mov	 DWORD PTR [ecx], edx
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	83 c4 04	 add	 esp, 4
  00027	3b ec		 cmp	 ebp, esp
  00029	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 08 00	 ret	 8
??$?0AAPAVRGYPipeProcess@@@?$_Compressed_pair@U?$default_delete@VRGYPipeProcess@@@std@@PAVRGYPipeProcess@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAVRGYPipeProcess@@@Z ENDP ; std::_Compressed_pair<std::default_delete<RGYPipeProcess>,RGYPipeProcess *,1>::_Compressed_pair<std::default_delete<RGYPipeProcess>,RGYPipeProcess *,1><RGYPipeProcess * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ??$?0AAPAU_iobuf@@@?$_Compressed_pair@Ufp_deleter@@PAU_iobuf@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAU_iobuf@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
_<_Val2_0>$ = 12					; size = 4
??$?0AAPAU_iobuf@@@?$_Compressed_pair@Ufp_deleter@@PAU_iobuf@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAU_iobuf@@@Z PROC ; std::_Compressed_pair<fp_deleter,_iobuf *,1>::_Compressed_pair<fp_deleter,_iobuf *,1><_iobuf * &>, COMDAT
; _this$ = ecx

; 1414 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 0c	 mov	 eax, DWORD PTR _<_Val2_0>$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$forward@AAPAU_iobuf@@@std@@YAAAPAU_iobuf@@AAPAU1@@Z ; std::forward<_iobuf * &>
  00017	83 c4 04	 add	 esp, 4
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	8b 10		 mov	 edx, DWORD PTR [eax]
  0001f	89 11		 mov	 DWORD PTR [ecx], edx
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	83 c4 04	 add	 esp, 4
  00027	3b ec		 cmp	 ebp, esp
  00029	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 08 00	 ret	 8
??$?0AAPAU_iobuf@@@?$_Compressed_pair@Ufp_deleter@@PAU_iobuf@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAU_iobuf@@@Z ENDP ; std::_Compressed_pair<fp_deleter,_iobuf *,1>::_Compressed_pair<fp_deleter,_iobuf *,1><_iobuf * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@Ufp_deleter@@PAU_iobuf@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@Ufp_deleter@@PAU_iobuf@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<fp_deleter,_iobuf *,1>::_Compressed_pair<fp_deleter,_iobuf *,1><>, COMDAT
; _this$ = ecx

; 1414 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@Ufp_deleter@@PAU_iobuf@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<fp_deleter,_iobuf *,1>::_Compressed_pair<fp_deleter,_iobuf *,1><>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$default_delete@VRGYPipeProcess@@@std@@PAVRGYPipeProcess@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$default_delete@VRGYPipeProcess@@@std@@PAVRGYPipeProcess@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::default_delete<RGYPipeProcess>,RGYPipeProcess *,1>::_Compressed_pair<std::default_delete<RGYPipeProcess>,RGYPipeProcess *,1><>, COMDAT
; _this$ = ecx

; 1414 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@U?$default_delete@VRGYPipeProcess@@@std@@PAVRGYPipeProcess@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::default_delete<RGYPipeProcess>,RGYPipeProcess *,1>::_Compressed_pair<std::default_delete<RGYPipeProcess>,RGYPipeProcess *,1><>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@Uhandle_deleter@@PAX$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@Uhandle_deleter@@PAX$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<handle_deleter,void *,1>::_Compressed_pair<handle_deleter,void *,1><>, COMDAT
; _this$ = ecx

; 1414 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@Uhandle_deleter@@PAX$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<handle_deleter,void *,1>::_Compressed_pair<handle_deleter,void *,1><>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\thread
;	COMDAT ??$sleep_until@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@this_thread@std@@YAXABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@1@@Z
_TEXT	SEGMENT
$T1 = -52						; size = 8
__Tgt$2 = -40						; size = 16
__Now$3 = -16						; size = 8
__$ArrayPad$ = -4					; size = 4
__Abs_time$ = 8						; size = 4
??$sleep_until@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@this_thread@std@@YAXABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@1@@Z PROC ; std::this_thread::sleep_until<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >, COMDAT

; 155  :     void sleep_until(const chrono::time_point<_Clock, _Duration>& _Abs_time) { // sleep until time point

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	57		 push	 edi
  00007	8d 7d cc	 lea	 edi, DWORD PTR [ebp-52]
  0000a	b9 0d 00 00 00	 mov	 ecx, 13			; 0000000dH
  0000f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00014	f3 ab		 rep stosd
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
$LN4@sleep_unti:

; 156  :         for (;;) {
; 157  :             const auto _Now = _Clock::now();

  00020	8d 45 f0	 lea	 eax, DWORD PTR __Now$3[ebp]
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 ?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ ; std::chrono::steady_clock::now
  00029	83 c4 04	 add	 esp, 4

; 158  :             if (_Abs_time <= _Now) {

  0002c	8d 4d f0	 lea	 ecx, DWORD PTR __Now$3[ebp]
  0002f	51		 push	 ecx
  00030	8b 55 08	 mov	 edx, DWORD PTR __Abs_time$[ebp]
  00033	52		 push	 edx
  00034	e8 00 00 00 00	 call	 ??$?NUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA_NABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z ; std::chrono::operator<=<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
  00039	83 c4 08	 add	 esp, 8
  0003c	0f b6 c0	 movzx	 eax, al
  0003f	85 c0		 test	 eax, eax
  00041	74 02		 je	 SHORT $LN5@sleep_unti

; 159  :                 return;

  00043	eb 2f		 jmp	 SHORT $LN1@sleep_unti
$LN5@sleep_unti:

; 160  :             }
; 161  : 
; 162  :             _CSTD xtime _Tgt;
; 163  :             (void) _To_xtime_10_day_clamped(_Tgt, _Abs_time - _Now);

  00045	8d 4d f0	 lea	 ecx, DWORD PTR __Now$3[ebp]
  00048	51		 push	 ecx
  00049	8b 55 08	 mov	 edx, DWORD PTR __Abs_time$[ebp]
  0004c	52		 push	 edx
  0004d	8d 45 cc	 lea	 eax, DWORD PTR $T1[ebp]
  00050	50		 push	 eax
  00051	e8 00 00 00 00	 call	 ??$?GUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z ; std::chrono::operator-<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
  00056	83 c4 0c	 add	 esp, 12			; 0000000cH
  00059	50		 push	 eax
  0005a	8d 4d d8	 lea	 ecx, DWORD PTR __Tgt$2[ebp]
  0005d	51		 push	 ecx
  0005e	e8 00 00 00 00	 call	 ??$_To_xtime_10_day_clamped@_JU?$ratio@$00$0DLJKMKAA@@std@@@std@@YA_NAAUxtime@@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@0@@Z ; std::_To_xtime_10_day_clamped<__int64,std::ratio<1,1000000000> >
  00063	83 c4 08	 add	 esp, 8

; 164  :             _Thrd_sleep(&_Tgt);

  00066	8d 55 d8	 lea	 edx, DWORD PTR __Tgt$2[ebp]
  00069	52		 push	 edx
  0006a	e8 00 00 00 00	 call	 __Thrd_sleep
  0006f	83 c4 04	 add	 esp, 4

; 165  :         }

  00072	eb ac		 jmp	 SHORT $LN4@sleep_unti
$LN1@sleep_unti:

; 166  :     }

  00074	52		 push	 edx
  00075	8b cd		 mov	 ecx, ebp
  00077	50		 push	 eax
  00078	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN10@sleep_unti
  0007e	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00083	58		 pop	 eax
  00084	5a		 pop	 edx
  00085	5f		 pop	 edi
  00086	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00089	33 cd		 xor	 ecx, ebp
  0008b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00090	83 c4 34	 add	 esp, 52			; 00000034H
  00093	3b ec		 cmp	 ebp, esp
  00095	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009a	8b e5		 mov	 esp, ebp
  0009c	5d		 pop	 ebp
  0009d	c3		 ret	 0
  0009e	66 90		 npad	 2
$LN10@sleep_unti:
  000a0	02 00 00 00	 DD	 2
  000a4	00 00 00 00	 DD	 $LN9@sleep_unti
$LN9@sleep_unti:
  000a8	f0 ff ff ff	 DD	 -16			; fffffff0H
  000ac	08 00 00 00	 DD	 8
  000b0	00 00 00 00	 DD	 $LN7@sleep_unti
  000b4	d8 ff ff ff	 DD	 -40			; ffffffd8H
  000b8	10 00 00 00	 DD	 16			; 00000010H
  000bc	00 00 00 00	 DD	 $LN8@sleep_unti
$LN8@sleep_unti:
  000c0	5f		 DB	 95			; 0000005fH
  000c1	54		 DB	 84			; 00000054H
  000c2	67		 DB	 103			; 00000067H
  000c3	74		 DB	 116			; 00000074H
  000c4	00		 DB	 0
$LN7@sleep_unti:
  000c5	5f		 DB	 95			; 0000005fH
  000c6	4e		 DB	 78			; 0000004eH
  000c7	6f		 DB	 111			; 0000006fH
  000c8	77		 DB	 119			; 00000077H
  000c9	00		 DB	 0
??$sleep_until@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@this_thread@std@@YAXABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@1@@Z ENDP ; std::this_thread::sleep_until<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\chrono
;	COMDAT ??$?G_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV201@0@Z
_TEXT	SEGMENT
$T1 = -24						; size = 8
$T2 = -16						; size = 8
$T3 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?G_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV201@0@Z PROC ; std::chrono::operator-<__int64,std::ratio<1,1000000000>,__int64,std::ratio<1,1000000000> >, COMDAT

; 262  :         _NOEXCEPT_COND(is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>) { // strengthened

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000d	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00010	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00013	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00016	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00019	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  0001c	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 263  :         // subtract two durations
; 264  :         using _CD = common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>;
; 265  :         return _CD(_CD(_Left).count() - _CD(_Right).count());

  0001f	8b 45 0c	 mov	 eax, DWORD PTR __Left$[ebp]
  00022	8b 08		 mov	 ecx, DWORD PTR [eax]
  00024	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00027	89 4d f0	 mov	 DWORD PTR $T2[ebp], ecx
  0002a	89 55 f4	 mov	 DWORD PTR $T2[ebp+4], edx
  0002d	8b 45 10	 mov	 eax, DWORD PTR __Right$[ebp]
  00030	8b 08		 mov	 ecx, DWORD PTR [eax]
  00032	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00035	89 4d e8	 mov	 DWORD PTR $T1[ebp], ecx
  00038	89 55 ec	 mov	 DWORD PTR $T1[ebp+4], edx
  0003b	8d 4d f0	 lea	 ecx, DWORD PTR $T2[ebp]
  0003e	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
  00043	8b f0		 mov	 esi, eax
  00045	8b fa		 mov	 edi, edx
  00047	8d 4d e8	 lea	 ecx, DWORD PTR $T1[ebp]
  0004a	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
  0004f	2b f0		 sub	 esi, eax
  00051	1b fa		 sbb	 edi, edx
  00053	89 75 f8	 mov	 DWORD PTR $T3[ebp], esi
  00056	89 7d fc	 mov	 DWORD PTR $T3[ebp+4], edi
  00059	8d 45 f8	 lea	 eax, DWORD PTR $T3[ebp]
  0005c	50		 push	 eax
  0005d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00060	e8 00 00 00 00	 call	 ??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,void>
  00065	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 266  :     }

  00068	5f		 pop	 edi
  00069	5e		 pop	 esi
  0006a	83 c4 18	 add	 esp, 24			; 00000018H
  0006d	3b ec		 cmp	 ebp, esp
  0006f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c3		 ret	 0
??$?G_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV201@0@Z ENDP ; std::chrono::operator-<__int64,std::ratio<1,1000000000>,__int64,std::ratio<1,1000000000> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\utility
;	COMDAT ??$swap@PAVEncodeStatus@@X@std@@YAXAAPAVEncodeStatus@@0@Z
_TEXT	SEGMENT
__Tmp$ = -8						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@PAVEncodeStatus@@X@std@@YAXAAPAVEncodeStatus@@0@Z PROC ; std::swap<EncodeStatus *,void>, COMDAT

; 58   :         is_nothrow_move_assignable_v<_Ty>) { // exchange values stored at _Left and _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 59   :     _Ty _Tmp = _STD move(_Left);

  0001b	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??$move@AAPAVEncodeStatus@@@std@@YA$$QAPAVEncodeStatus@@AAPAV1@@Z ; std::move<EncodeStatus * &>
  00024	83 c4 04	 add	 esp, 4
  00027	8b 08		 mov	 ecx, DWORD PTR [eax]
  00029	89 4d f8	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 60   :     _Left    = _STD move(_Right);

  0002c	8b 55 0c	 mov	 edx, DWORD PTR __Right$[ebp]
  0002f	52		 push	 edx
  00030	e8 00 00 00 00	 call	 ??$move@AAPAVEncodeStatus@@@std@@YA$$QAPAVEncodeStatus@@AAPAV1@@Z ; std::move<EncodeStatus * &>
  00035	83 c4 04	 add	 esp, 4
  00038	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0003b	8b 10		 mov	 edx, DWORD PTR [eax]
  0003d	89 11		 mov	 DWORD PTR [ecx], edx

; 61   :     _Right   = _STD move(_Tmp);

  0003f	8d 45 f8	 lea	 eax, DWORD PTR __Tmp$[ebp]
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 ??$move@AAPAVEncodeStatus@@@std@@YA$$QAPAVEncodeStatus@@AAPAV1@@Z ; std::move<EncodeStatus * &>
  00048	83 c4 04	 add	 esp, 4
  0004b	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  0004e	8b 10		 mov	 edx, DWORD PTR [eax]
  00050	89 11		 mov	 DWORD PTR [ecx], edx

; 62   : }

  00052	52		 push	 edx
  00053	8b cd		 mov	 ecx, ebp
  00055	50		 push	 eax
  00056	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@swap
  0005c	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00061	58		 pop	 eax
  00062	5a		 pop	 edx
  00063	83 c4 0c	 add	 esp, 12			; 0000000cH
  00066	3b ec		 cmp	 ebp, esp
  00068	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
  00071	0f 1f 00	 npad	 3
$LN5@swap:
  00074	01 00 00 00	 DD	 1
  00078	00 00 00 00	 DD	 $LN4@swap
$LN4@swap:
  0007c	f8 ff ff ff	 DD	 -8			; fffffff8H
  00080	04 00 00 00	 DD	 4
  00084	00 00 00 00	 DD	 $LN3@swap
$LN3@swap:
  00088	5f		 DB	 95			; 0000005fH
  00089	54		 DB	 84			; 00000054H
  0008a	6d		 DB	 109			; 0000006dH
  0008b	70		 DB	 112			; 00000070H
  0008c	00		 DB	 0
??$swap@PAVEncodeStatus@@X@std@@YAXAAPAVEncodeStatus@@0@Z ENDP ; std::swap<EncodeStatus *,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\utility
;	COMDAT ??$swap@PAVRGYLog@@X@std@@YAXAAPAVRGYLog@@0@Z
_TEXT	SEGMENT
__Tmp$ = -8						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@PAVRGYLog@@X@std@@YAXAAPAVRGYLog@@0@Z PROC	; std::swap<RGYLog *,void>, COMDAT

; 58   :         is_nothrow_move_assignable_v<_Ty>) { // exchange values stored at _Left and _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 59   :     _Ty _Tmp = _STD move(_Left);

  0001b	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??$move@AAPAVRGYLog@@@std@@YA$$QAPAVRGYLog@@AAPAV1@@Z ; std::move<RGYLog * &>
  00024	83 c4 04	 add	 esp, 4
  00027	8b 08		 mov	 ecx, DWORD PTR [eax]
  00029	89 4d f8	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 60   :     _Left    = _STD move(_Right);

  0002c	8b 55 0c	 mov	 edx, DWORD PTR __Right$[ebp]
  0002f	52		 push	 edx
  00030	e8 00 00 00 00	 call	 ??$move@AAPAVRGYLog@@@std@@YA$$QAPAVRGYLog@@AAPAV1@@Z ; std::move<RGYLog * &>
  00035	83 c4 04	 add	 esp, 4
  00038	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0003b	8b 10		 mov	 edx, DWORD PTR [eax]
  0003d	89 11		 mov	 DWORD PTR [ecx], edx

; 61   :     _Right   = _STD move(_Tmp);

  0003f	8d 45 f8	 lea	 eax, DWORD PTR __Tmp$[ebp]
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 ??$move@AAPAVRGYLog@@@std@@YA$$QAPAVRGYLog@@AAPAV1@@Z ; std::move<RGYLog * &>
  00048	83 c4 04	 add	 esp, 4
  0004b	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  0004e	8b 10		 mov	 edx, DWORD PTR [eax]
  00050	89 11		 mov	 DWORD PTR [ecx], edx

; 62   : }

  00052	52		 push	 edx
  00053	8b cd		 mov	 ecx, ebp
  00055	50		 push	 eax
  00056	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@swap
  0005c	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00061	58		 pop	 eax
  00062	5a		 pop	 edx
  00063	83 c4 0c	 add	 esp, 12			; 0000000cH
  00066	3b ec		 cmp	 ebp, esp
  00068	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
  00071	0f 1f 00	 npad	 3
$LN5@swap:
  00074	01 00 00 00	 DD	 1
  00078	00 00 00 00	 DD	 $LN4@swap
$LN4@swap:
  0007c	f8 ff ff ff	 DD	 -8			; fffffff8H
  00080	04 00 00 00	 DD	 4
  00084	00 00 00 00	 DD	 $LN3@swap
$LN3@swap:
  00088	5f		 DB	 95			; 0000005fH
  00089	54		 DB	 84			; 00000054H
  0008a	6d		 DB	 109			; 0000006dH
  0008b	70		 DB	 112			; 00000070H
  0008c	00		 DB	 0
??$swap@PAVRGYLog@@X@std@@YAXAAPAVRGYLog@@0@Z ENDP	; std::swap<RGYLog *,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\utility
;	COMDAT ??$swap@PAV_Ref_count_base@std@@X@std@@YAXAAPAV_Ref_count_base@0@0@Z
_TEXT	SEGMENT
__Tmp$ = -8						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@PAV_Ref_count_base@std@@X@std@@YAXAAPAV_Ref_count_base@0@0@Z PROC ; std::swap<std::_Ref_count_base *,void>, COMDAT

; 58   :         is_nothrow_move_assignable_v<_Ty>) { // exchange values stored at _Left and _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 59   :     _Ty _Tmp = _STD move(_Left);

  0001b	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??$move@AAPAV_Ref_count_base@std@@@std@@YA$$QAPAV_Ref_count_base@0@AAPAV10@@Z ; std::move<std::_Ref_count_base * &>
  00024	83 c4 04	 add	 esp, 4
  00027	8b 08		 mov	 ecx, DWORD PTR [eax]
  00029	89 4d f8	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 60   :     _Left    = _STD move(_Right);

  0002c	8b 55 0c	 mov	 edx, DWORD PTR __Right$[ebp]
  0002f	52		 push	 edx
  00030	e8 00 00 00 00	 call	 ??$move@AAPAV_Ref_count_base@std@@@std@@YA$$QAPAV_Ref_count_base@0@AAPAV10@@Z ; std::move<std::_Ref_count_base * &>
  00035	83 c4 04	 add	 esp, 4
  00038	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0003b	8b 10		 mov	 edx, DWORD PTR [eax]
  0003d	89 11		 mov	 DWORD PTR [ecx], edx

; 61   :     _Right   = _STD move(_Tmp);

  0003f	8d 45 f8	 lea	 eax, DWORD PTR __Tmp$[ebp]
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 ??$move@AAPAV_Ref_count_base@std@@@std@@YA$$QAPAV_Ref_count_base@0@AAPAV10@@Z ; std::move<std::_Ref_count_base * &>
  00048	83 c4 04	 add	 esp, 4
  0004b	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  0004e	8b 10		 mov	 edx, DWORD PTR [eax]
  00050	89 11		 mov	 DWORD PTR [ecx], edx

; 62   : }

  00052	52		 push	 edx
  00053	8b cd		 mov	 ecx, ebp
  00055	50		 push	 eax
  00056	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@swap
  0005c	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00061	58		 pop	 eax
  00062	5a		 pop	 edx
  00063	83 c4 0c	 add	 esp, 12			; 0000000cH
  00066	3b ec		 cmp	 ebp, esp
  00068	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
  00071	0f 1f 00	 npad	 3
$LN5@swap:
  00074	01 00 00 00	 DD	 1
  00078	00 00 00 00	 DD	 $LN4@swap
$LN4@swap:
  0007c	f8 ff ff ff	 DD	 -8			; fffffff8H
  00080	04 00 00 00	 DD	 4
  00084	00 00 00 00	 DD	 $LN3@swap
$LN3@swap:
  00088	5f		 DB	 95			; 0000005fH
  00089	54		 DB	 84			; 00000054H
  0008a	6d		 DB	 109			; 0000006dH
  0008b	70		 DB	 112			; 00000070H
  0008c	00		 DB	 0
??$swap@PAV_Ref_count_base@std@@X@std@@YAXAAPAV_Ref_count_base@0@0@Z ENDP ; std::swap<std::_Ref_count_base *,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PBD@std@@@std@@YAXPAPBDQAPBDAAV?$allocator@PBD@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PBD@std@@@std@@YAXPAPBDQAPBDAAV?$allocator@PBD@0@@Z PROC ; std::_Destroy_range<std::allocator<char const *> >, COMDAT

; 1027 : void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1028 :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 1029 :     using _Ty = typename _Alloc::value_type;
; 1030 :     if
; 1031 :         _CONSTEXPR_IF(conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 1032 :             (void) _First;
; 1033 :             (void) _Last;
; 1034 :             (void) _Al;
; 1035 :         }
; 1036 :     else {
; 1037 :         for (; _First != _Last; ++_First) {
; 1038 :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 1039 :         }
; 1040 :     }
; 1041 : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@PBD@std@@@std@@YAXPAPBDQAPBDAAV?$allocator@PBD@0@@Z ENDP ; std::_Destroy_range<std::allocator<char const *> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ??$_Get_size_of_n@$07@std@@YAII@Z
_TEXT	SEGMENT
__Max_possible$1 = -8					; size = 4
__Overflow_is_possible$ = -1				; size = 1
__Count$ = 8						; size = 4
??$_Get_size_of_n@$07@std@@YAII@Z PROC			; std::_Get_size_of_n<8>, COMDAT

; 24   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 25   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00014	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$[ebp], 1

; 26   : 
; 27   :     if
; 28   :         _CONSTEXPR_IF(_Overflow_is_possible) {
; 29   :             constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  00018	c7 45 f8 ff ff
	ff 1f		 mov	 DWORD PTR __Max_possible$1[ebp], 536870911 ; 1fffffffH

; 30   :             if (_Count > _Max_possible) {

  0001f	81 7d 08 ff ff
	ff 1f		 cmp	 DWORD PTR __Count$[ebp], 536870911 ; 1fffffffH
  00026	76 05		 jbe	 SHORT $LN2@Get_size_o

; 31   :                 _Throw_bad_array_new_length(); // multiply overflow

  00028	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN2@Get_size_o:

; 32   :             }
; 33   :         }
; 34   : 
; 35   :     return _Count * _Ty_size;

  0002d	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00030	c1 e0 03	 shl	 eax, 3
$LN3@Get_size_o:

; 36   : }

  00033	83 c4 08	 add	 esp, 8
  00036	3b ec		 cmp	 ebp, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
??$_Get_size_of_n@$07@std@@YAII@Z ENDP			; std::_Get_size_of_n<8>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 183  : void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 184  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 185  : #if defined(_M_IX86) || defined(_M_X64)
; 186  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00022	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  00029	72 10		 jb	 SHORT $LN2@Deallocate

; 187  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);

  0002b	8d 45 0c	 lea	 eax, DWORD PTR __Bytes$[ebp]
  0002e	50		 push	 eax
  0002f	8d 4d 08	 lea	 ecx, DWORD PTR __Ptr$[ebp]
  00032	51		 push	 ecx
  00033	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
  00038	83 c4 08	 add	 esp, 8
$LN2@Deallocate:

; 188  :     }
; 189  : #endif // defined(_M_IX86) || defined(_M_X64)
; 190  : 
; 191  :     ::operator delete(_Ptr, _Bytes);

  0003b	8b 55 0c	 mov	 edx, DWORD PTR __Bytes$[ebp]
  0003e	52		 push	 edx
  0003f	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00048	83 c4 08	 add	 esp, 8

; 192  : }

  0004b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00055	59		 pop	 ecx
  00056	83 c4 0c	 add	 esp, 12			; 0000000cH
  00059	3b ec		 cmp	 ebp, esp
  0005b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 167  : _DECLSPEC_ALLOCATOR void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 168  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 169  : #if defined(_M_IX86) || defined(_M_X64)
; 170  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00003	81 7d 08 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  0000a	72 0e		 jb	 SHORT $LN2@Allocate

; 171  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00015	83 c4 04	 add	 esp, 4
  00018	eb 16		 jmp	 SHORT $LN1@Allocate
$LN2@Allocate:

; 172  :     }
; 173  : #endif // defined(_M_IX86) || defined(_M_X64)
; 174  : 
; 175  :     if (_Bytes != 0) {

  0001a	83 7d 08 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  0001e	74 0e		 je	 SHORT $LN3@Allocate

; 176  :         return _Traits::_Allocate(_Bytes);

  00020	8b 4d 08	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
  00029	83 c4 04	 add	 esp, 4
  0002c	eb 02		 jmp	 SHORT $LN1@Allocate
$LN3@Allocate:

; 177  :     }
; 178  : 
; 179  :     return nullptr;

  0002e	33 c0		 xor	 eax, eax
$LN1@Allocate:

; 180  : }

  00030	3b ec		 cmp	 ebp, esp
  00032	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ??$_Get_size_of_n@$00@std@@YAII@Z
_TEXT	SEGMENT
__Overflow_is_possible$ = -1				; size = 1
__Count$ = 8						; size = 4
??$_Get_size_of_n@$00@std@@YAII@Z PROC			; std::_Get_size_of_n<1>, COMDAT

; 24   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 25   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  0000b	c6 45 ff 00	 mov	 BYTE PTR __Overflow_is_possible$[ebp], 0

; 26   : 
; 27   :     if
; 28   :         _CONSTEXPR_IF(_Overflow_is_possible) {
; 29   :             constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 30   :             if (_Count > _Max_possible) {
; 31   :                 _Throw_bad_array_new_length(); // multiply overflow
; 32   :             }
; 33   :         }
; 34   : 
; 35   :     return _Count * _Ty_size;

  0000f	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]

; 36   : }

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??$_Get_size_of_n@$00@std@@YAII@Z ENDP			; std::_Get_size_of_n<1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0@Z PROC ; std::_Pocma<std::allocator<char> >, COMDAT

; 968  : void _Pocma(_Alloc& _Left, _Alloc& _Right) noexcept { // (maybe) propagate on container move assignment

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 969  :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_move_assignment::value) {
; 970  :         _Left = _STD move(_Right);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ; std::move<std::allocator<char> &>
  0000c	83 c4 04	 add	 esp, 4

; 971  :     } else {
; 972  :         (void) _Left; // TRANSITION, VSO#486357
; 973  :         (void) _Right; // TRANSITION, VSO#486357
; 974  :     }
; 975  : }

  0000f	3b ec		 cmp	 ebp, esp
  00011	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0@Z ENDP ; std::_Pocma<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z PROC ; std::_Construct_in_place<char *,char * const &>, COMDAT

; 198  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) _NOEXCEPT_COND(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 199  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  0000b	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ??$addressof@PAD@std@@YAPAPADAAPAD@Z ; std::addressof<char *>
  00014	83 c4 04	 add	 esp, 4
  00017	50		 push	 eax
  00018	6a 04		 push	 4
  0001a	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  0001f	83 c4 08	 add	 esp, 8
  00022	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00028	51		 push	 ecx
  00029	e8 00 00 00 00	 call	 ??$forward@ABQAD@std@@YAABQADABQAD@Z ; std::forward<char * const &>
  0002e	83 c4 04	 add	 esp, 4
  00031	8b 55 fc	 mov	 edx, DWORD PTR $T1[ebp]
  00034	8b 00		 mov	 eax, DWORD PTR [eax]
  00036	89 02		 mov	 DWORD PTR [edx], eax

; 200  :         _Ty(_STD forward<_Types>(_Args)...);
; 201  : }

  00038	83 c4 04	 add	 esp, 4
  0003b	3b ec		 cmp	 ebp, esp
  0003d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ENDP ; std::_Construct_in_place<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@@Z PROC ; std::_Pocca<std::allocator<char> >, COMDAT

; 942  : void _Pocca(_Alloc& _Left, const _Alloc& _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 943  :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_copy_assignment::value) {
; 944  :         _Left = _Right;
; 945  :     } else {
; 946  :         (void) _Left; // TRANSITION, VSO#486357
; 947  :         (void) _Right; // TRANSITION, VSO#486357
; 948  :     }
; 949  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@@Z ENDP ; std::_Pocca<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z
_TEXT	SEGMENT
__Old_ptr$1 = -48					; size = 4
__Raw_new$ = -44					; size = 4
__New_ptr$ = -36					; size = 4
__Al$ = -28						; size = 4
__New_capacity$ = -24					; size = 4
__Old_capacity$ = -20					; size = 4
__New_size$ = -16					; size = 4
__Old_size$ = -12					; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
_<_Args_1>$ = 20					; size = 4
??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>, COMDAT
; _this$ = ecx

; 4108 :     basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	57		 push	 edi
  00007	51		 push	 ecx
  00008	8d 7d d0	 lea	 edi, DWORD PTR [ebp-48]
  0000b	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	59		 pop	 ecx
  00018	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 4109 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 4110 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 4111 :         auto& _My_data            = _Mypair._Myval2;

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 4112 :         const size_type _Old_size = _My_data._Mysize;

  00021	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00024	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00027	89 55 f4	 mov	 DWORD PTR __Old_size$[ebp], edx

; 4113 :         if (max_size() - _Old_size < _Size_increase) {

  0002a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00032	2b 45 f4	 sub	 eax, DWORD PTR __Old_size$[ebp]
  00035	3b 45 08	 cmp	 eax, DWORD PTR __Size_increase$[ebp]
  00038	73 05		 jae	 SHORT $LN2@Reallocate

; 4114 :             _Xlen(); // result too long

  0003a	e8 00 00 00 00	 call	 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN2@Reallocate:

; 4115 :         }
; 4116 : 
; 4117 :         const size_type _New_size     = _Old_size + _Size_increase;

  0003f	8b 45 f4	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00042	03 45 08	 add	 eax, DWORD PTR __Size_increase$[ebp]
  00045	89 45 f0	 mov	 DWORD PTR __New_size$[ebp], eax

; 4118 :         const size_type _Old_capacity = _My_data._Myres;

  00048	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0004b	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0004e	89 55 ec	 mov	 DWORD PTR __Old_capacity$[ebp], edx

; 4119 :         const size_type _New_capacity = _Calculate_growth(_New_size);

  00051	8b 45 f0	 mov	 eax, DWORD PTR __New_size$[ebp]
  00054	50		 push	 eax
  00055	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  0005d	89 45 e8	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 4120 :         auto& _Al                     = _Getal();

  00060	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00063	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00068	89 45 e4	 mov	 DWORD PTR __Al$[ebp], eax

; 4121 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  0006b	8b 4d e8	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  0006e	83 c1 01	 add	 ecx, 1
  00071	51		 push	 ecx
  00072	8b 4d e4	 mov	 ecx, DWORD PTR __Al$[ebp]
  00075	e8 00 00 00 00	 call	 ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate
  0007a	89 45 dc	 mov	 DWORD PTR __New_ptr$[ebp], eax

; 4122 :         _My_data._Orphan_all();

  0007d	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00080	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 4123 :         _My_data._Mysize      = _New_size;

  00085	8b 55 f8	 mov	 edx, DWORD PTR __My_data$[ebp]
  00088	8b 45 f0	 mov	 eax, DWORD PTR __New_size$[ebp]
  0008b	89 42 14	 mov	 DWORD PTR [edx+20], eax

; 4124 :         _My_data._Myres       = _New_capacity;

  0008e	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00091	8b 55 e8	 mov	 edx, DWORD PTR __New_capacity$[ebp]
  00094	89 51 18	 mov	 DWORD PTR [ecx+24], edx

; 4125 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

  00097	8b 45 dc	 mov	 eax, DWORD PTR __New_ptr$[ebp]
  0009a	50		 push	 eax
  0009b	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPADPAD@Z ; std::_Unfancy<char>
  000a0	83 c4 04	 add	 esp, 4
  000a3	89 45 d4	 mov	 DWORD PTR __Raw_new$[ebp], eax

; 4126 :         if (_BUF_SIZE <= _Old_capacity) {

  000a6	83 7d ec 10	 cmp	 DWORD PTR __Old_capacity$[ebp], 16 ; 00000010H
  000aa	72 4c		 jb	 SHORT $LN3@Reallocate

; 4127 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  000ac	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  000af	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000b2	89 55 d0	 mov	 DWORD PTR __Old_ptr$1[ebp], edx

; 4128 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);

  000b5	8b 45 14	 mov	 eax, DWORD PTR _<_Args_1>$[ebp]
  000b8	50		 push	 eax
  000b9	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  000bc	51		 push	 ecx
  000bd	8b 55 f4	 mov	 edx, DWORD PTR __Old_size$[ebp]
  000c0	52		 push	 edx
  000c1	8b 45 d0	 mov	 eax, DWORD PTR __Old_ptr$1[ebp]
  000c4	50		 push	 eax
  000c5	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPADPAD@Z ; std::_Unfancy<char>
  000ca	83 c4 04	 add	 esp, 4
  000cd	50		 push	 eax
  000ce	8b 4d d4	 mov	 ecx, DWORD PTR __Raw_new$[ebp]
  000d1	51		 push	 ecx
  000d2	8d 4d 0c	 lea	 ecx, DWORD PTR __Fn$[ebp]
  000d5	e8 00 00 00 00	 call	 ??R<lambda_ab246b20b9526e2ef7792587e4298a77>@@QBEXQADQBDI1I@Z ; <lambda_ab246b20b9526e2ef7792587e4298a77>::operator()

; 4129 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

  000da	8b 55 ec	 mov	 edx, DWORD PTR __Old_capacity$[ebp]
  000dd	83 c2 01	 add	 edx, 1
  000e0	52		 push	 edx
  000e1	8b 45 d0	 mov	 eax, DWORD PTR __Old_ptr$1[ebp]
  000e4	50		 push	 eax
  000e5	8b 4d e4	 mov	 ecx, DWORD PTR __Al$[ebp]
  000e8	e8 00 00 00 00	 call	 ?deallocate@?$allocator@D@std@@QAEXQADI@Z ; std::allocator<char>::deallocate

; 4130 :             _My_data._Bx._Ptr = _New_ptr;

  000ed	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  000f0	8b 55 dc	 mov	 edx, DWORD PTR __New_ptr$[ebp]
  000f3	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 4131 :         } else {

  000f6	eb 32		 jmp	 SHORT $LN4@Reallocate
$LN3@Reallocate:

; 4132 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);

  000f8	8b 45 14	 mov	 eax, DWORD PTR _<_Args_1>$[ebp]
  000fb	50		 push	 eax
  000fc	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  000ff	51		 push	 ecx
  00100	8b 55 f4	 mov	 edx, DWORD PTR __Old_size$[ebp]
  00103	52		 push	 edx
  00104	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00107	83 c0 04	 add	 eax, 4
  0010a	50		 push	 eax
  0010b	8b 4d d4	 mov	 ecx, DWORD PTR __Raw_new$[ebp]
  0010e	51		 push	 ecx
  0010f	8d 4d 0c	 lea	 ecx, DWORD PTR __Fn$[ebp]
  00112	e8 00 00 00 00	 call	 ??R<lambda_ab246b20b9526e2ef7792587e4298a77>@@QBEXQADQBDI1I@Z ; <lambda_ab246b20b9526e2ef7792587e4298a77>::operator()

; 4133 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  00117	8d 55 dc	 lea	 edx, DWORD PTR __New_ptr$[ebp]
  0011a	52		 push	 edx
  0011b	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  0011e	83 c0 04	 add	 eax, 4
  00121	50		 push	 eax
  00122	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  00127	83 c4 08	 add	 esp, 8
$LN4@Reallocate:

; 4134 :         }
; 4135 : 
; 4136 :         return *this;

  0012a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
$LN5@Reallocate:

; 4137 :     }

  0012d	52		 push	 edx
  0012e	8b cd		 mov	 ecx, ebp
  00130	50		 push	 eax
  00131	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN8@Reallocate
  00137	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0013c	58		 pop	 eax
  0013d	5a		 pop	 edx
  0013e	5f		 pop	 edi
  0013f	83 c4 30	 add	 esp, 48			; 00000030H
  00142	3b ec		 cmp	 ebp, esp
  00144	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00149	8b e5		 mov	 esp, ebp
  0014b	5d		 pop	 ebp
  0014c	c2 10 00	 ret	 16			; 00000010H
  0014f	90		 npad	 1
$LN8@Reallocate:
  00150	01 00 00 00	 DD	 1
  00154	00 00 00 00	 DD	 $LN7@Reallocate
$LN7@Reallocate:
  00158	dc ff ff ff	 DD	 -36			; ffffffdcH
  0015c	04 00 00 00	 DD	 4
  00160	00 00 00 00	 DD	 $LN6@Reallocate
$LN6@Reallocate:
  00164	5f		 DB	 95			; 0000005fH
  00165	4e		 DB	 78			; 0000004eH
  00166	65		 DB	 101			; 00000065H
  00167	77		 DB	 119			; 00000077H
  00168	5f		 DB	 95			; 0000005fH
  00169	70		 DB	 112			; 00000070H
  0016a	74		 DB	 116			; 00000074H
  0016b	72		 DB	 114			; 00000072H
  0016c	00		 DB	 0
??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring
;	COMDAT ??R<lambda_ab246b20b9526e2ef7792587e4298a77>@@QBEXQADQBDI1I@Z
_TEXT	SEGMENT
$T1 = -5						; size = 1
_this$ = -4						; size = 4
__New_ptr$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Old_size$ = 16					; size = 4
__Ptr$ = 20						; size = 4
__Count$ = 24						; size = 4
??R<lambda_ab246b20b9526e2ef7792587e4298a77>@@QBEXQADQBDI1I@Z PROC ; <lambda_ab246b20b9526e2ef7792587e4298a77>::operator(), COMDAT
; _this$ = ecx

; 2748 :                 const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2749 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);

  00017	8b 45 10	 mov	 eax, DWORD PTR __Old_size$[ebp]
  0001a	50		 push	 eax
  0001b	8b 4d 0c	 mov	 ecx, DWORD PTR __Old_ptr$[ebp]
  0001e	51		 push	 ecx
  0001f	8b 55 08	 mov	 edx, DWORD PTR __New_ptr$[ebp]
  00022	52		 push	 edx
  00023	e8 00 00 00 00	 call	 ?copy@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Narrow_char_traits<char,int>::copy
  00028	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2750 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);

  0002b	8b 45 18	 mov	 eax, DWORD PTR __Count$[ebp]
  0002e	50		 push	 eax
  0002f	8b 4d 14	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00032	51		 push	 ecx
  00033	8b 55 08	 mov	 edx, DWORD PTR __New_ptr$[ebp]
  00036	03 55 10	 add	 edx, DWORD PTR __Old_size$[ebp]
  00039	52		 push	 edx
  0003a	e8 00 00 00 00	 call	 ?copy@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Narrow_char_traits<char,int>::copy
  0003f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2751 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  00042	c6 45 fb 00	 mov	 BYTE PTR $T1[ebp], 0
  00046	8d 45 fb	 lea	 eax, DWORD PTR $T1[ebp]
  00049	50		 push	 eax
  0004a	8b 4d 10	 mov	 ecx, DWORD PTR __Old_size$[ebp]
  0004d	03 4d 18	 add	 ecx, DWORD PTR __Count$[ebp]
  00050	03 4d 08	 add	 ecx, DWORD PTR __New_ptr$[ebp]
  00053	51		 push	 ecx
  00054	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
  00059	83 c4 08	 add	 esp, 8

; 2752 :             },

  0005c	83 c4 08	 add	 esp, 8
  0005f	3b ec		 cmp	 ebp, esp
  00061	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c2 14 00	 ret	 20			; 00000014H
??R<lambda_ab246b20b9526e2ef7792587e4298a77>@@QBEXQADQBDI1I@Z ENDP ; <lambda_ab246b20b9526e2ef7792587e4298a77>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring
;	COMDAT ??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z
_TEXT	SEGMENT
__New_ptr$ = -24					; size = 4
__Al$ = -16						; size = 4
__New_capacity$ = -12					; size = 4
__Old_capacity$ = -8					; size = 4
_this$ = -4						; size = 4
__New_size$ = 8						; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>, COMDAT
; _this$ = ecx

; 4082 :     basic_string& _Reallocate_for(const size_type _New_size, _Fty _Fn, _ArgTys... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  0000e	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00011	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00014	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00017	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  0001a	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  0001d	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00020	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 4083 :         // reallocate to store exactly _New_size elements, new buffer prepared by
; 4084 :         // _Fn(_New_ptr, _New_size, _Args...)
; 4085 :         if (_New_size > max_size()) {

  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  0002b	39 45 08	 cmp	 DWORD PTR __New_size$[ebp], eax
  0002e	76 05		 jbe	 SHORT $LN2@Reallocate

; 4086 :             _Xlen(); // result too long

  00030	e8 00 00 00 00	 call	 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN2@Reallocate:

; 4087 :         }
; 4088 : 
; 4089 :         const size_type _Old_capacity = _Mypair._Myval2._Myres;

  00035	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00038	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0003b	89 4d f8	 mov	 DWORD PTR __Old_capacity$[ebp], ecx

; 4090 :         const size_type _New_capacity = _Calculate_growth(_New_size);

  0003e	8b 55 08	 mov	 edx, DWORD PTR __New_size$[ebp]
  00041	52		 push	 edx
  00042	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  0004a	89 45 f4	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 4091 :         auto& _Al                     = _Getal();

  0004d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00055	89 45 f0	 mov	 DWORD PTR __Al$[ebp], eax

; 4092 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  00058	8b 45 f4	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  0005b	83 c0 01	 add	 eax, 1
  0005e	50		 push	 eax
  0005f	8b 4d f0	 mov	 ecx, DWORD PTR __Al$[ebp]
  00062	e8 00 00 00 00	 call	 ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate
  00067	89 45 e8	 mov	 DWORD PTR __New_ptr$[ebp], eax

; 4093 :         _Mypair._Myval2._Orphan_all();

  0006a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006d	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 4094 :         _Mypair._Myval2._Mysize = _New_size;

  00072	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	8b 55 08	 mov	 edx, DWORD PTR __New_size$[ebp]
  00078	89 51 14	 mov	 DWORD PTR [ecx+20], edx

; 4095 :         _Mypair._Myval2._Myres  = _New_capacity;

  0007b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0007e	8b 4d f4	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  00081	89 48 18	 mov	 DWORD PTR [eax+24], ecx

; 4096 :         _Fn(_Unfancy(_New_ptr), _New_size, _Args...);

  00084	8b 55 10	 mov	 edx, DWORD PTR _<_Args_0>$[ebp]
  00087	52		 push	 edx
  00088	8b 45 08	 mov	 eax, DWORD PTR __New_size$[ebp]
  0008b	50		 push	 eax
  0008c	8b 4d e8	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  0008f	51		 push	 ecx
  00090	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPADPAD@Z ; std::_Unfancy<char>
  00095	83 c4 04	 add	 esp, 4
  00098	50		 push	 eax
  00099	8d 4d 0c	 lea	 ecx, DWORD PTR __Fn$[ebp]
  0009c	e8 00 00 00 00	 call	 ??R<lambda_9366063389c5f42a00a5088cf24e69de>@@QBEXQADIQBD@Z ; <lambda_9366063389c5f42a00a5088cf24e69de>::operator()

; 4097 :         if (_BUF_SIZE <= _Old_capacity) {

  000a1	83 7d f8 10	 cmp	 DWORD PTR __Old_capacity$[ebp], 16 ; 00000010H
  000a5	72 21		 jb	 SHORT $LN3@Reallocate

; 4098 :             _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);

  000a7	8b 55 f8	 mov	 edx, DWORD PTR __Old_capacity$[ebp]
  000aa	83 c2 01	 add	 edx, 1
  000ad	52		 push	 edx
  000ae	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000b1	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000b4	51		 push	 ecx
  000b5	8b 4d f0	 mov	 ecx, DWORD PTR __Al$[ebp]
  000b8	e8 00 00 00 00	 call	 ?deallocate@?$allocator@D@std@@QAEXQADI@Z ; std::allocator<char>::deallocate

; 4099 :             _Mypair._Myval2._Bx._Ptr = _New_ptr;

  000bd	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000c0	8b 45 e8	 mov	 eax, DWORD PTR __New_ptr$[ebp]
  000c3	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 4100 :         } else {

  000c6	eb 13		 jmp	 SHORT $LN4@Reallocate
$LN3@Reallocate:

; 4101 :             _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);

  000c8	8d 4d e8	 lea	 ecx, DWORD PTR __New_ptr$[ebp]
  000cb	51		 push	 ecx
  000cc	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000cf	83 c2 04	 add	 edx, 4
  000d2	52		 push	 edx
  000d3	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  000d8	83 c4 08	 add	 esp, 8
$LN4@Reallocate:

; 4102 :         }
; 4103 : 
; 4104 :         return *this;

  000db	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
$LN5@Reallocate:

; 4105 :     }

  000de	52		 push	 edx
  000df	8b cd		 mov	 ecx, ebp
  000e1	50		 push	 eax
  000e2	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN8@Reallocate
  000e8	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000ed	58		 pop	 eax
  000ee	5a		 pop	 edx
  000ef	83 c4 1c	 add	 esp, 28			; 0000001cH
  000f2	3b ec		 cmp	 ebp, esp
  000f4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f9	8b e5		 mov	 esp, ebp
  000fb	5d		 pop	 ebp
  000fc	c2 0c 00	 ret	 12			; 0000000cH
  000ff	90		 npad	 1
$LN8@Reallocate:
  00100	01 00 00 00	 DD	 1
  00104	00 00 00 00	 DD	 $LN7@Reallocate
$LN7@Reallocate:
  00108	e8 ff ff ff	 DD	 -24			; ffffffe8H
  0010c	04 00 00 00	 DD	 4
  00110	00 00 00 00	 DD	 $LN6@Reallocate
$LN6@Reallocate:
  00114	5f		 DB	 95			; 0000005fH
  00115	4e		 DB	 78			; 0000004eH
  00116	65		 DB	 101			; 00000065H
  00117	77		 DB	 119			; 00000077H
  00118	5f		 DB	 95			; 0000005fH
  00119	70		 DB	 112			; 00000070H
  0011a	74		 DB	 116			; 00000074H
  0011b	72		 DB	 114			; 00000072H
  0011c	00		 DB	 0
??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring
;	COMDAT ??R<lambda_9366063389c5f42a00a5088cf24e69de>@@QBEXQADIQBD@Z
_TEXT	SEGMENT
$T1 = -5						; size = 1
_this$ = -4						; size = 4
__New_ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??R<lambda_9366063389c5f42a00a5088cf24e69de>@@QBEXQADIQBD@Z PROC ; <lambda_9366063389c5f42a00a5088cf24e69de>::operator(), COMDAT
; _this$ = ecx

; 2853 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2854 :                 _Traits::copy(_New_ptr, _Ptr, _Count);

  00017	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0001a	50		 push	 eax
  0001b	8b 4d 10	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0001e	51		 push	 ecx
  0001f	8b 55 08	 mov	 edx, DWORD PTR __New_ptr$[ebp]
  00022	52		 push	 edx
  00023	e8 00 00 00 00	 call	 ?copy@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Narrow_char_traits<char,int>::copy
  00028	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2855 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  0002b	c6 45 fb 00	 mov	 BYTE PTR $T1[ebp], 0
  0002f	8d 45 fb	 lea	 eax, DWORD PTR $T1[ebp]
  00032	50		 push	 eax
  00033	8b 4d 08	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  00036	03 4d 0c	 add	 ecx, DWORD PTR __Count$[ebp]
  00039	51		 push	 ecx
  0003a	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
  0003f	83 c4 08	 add	 esp, 8

; 2856 :             },

  00042	83 c4 08	 add	 esp, 8
  00045	3b ec		 cmp	 ebp, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c2 0c 00	 ret	 12			; 0000000cH
??R<lambda_9366063389c5f42a00a5088cf24e69de>@@QBEXQADIQBD@Z ENDP ; <lambda_9366063389c5f42a00a5088cf24e69de>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstddef
;	COMDAT ??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPBV?$_String_val@U?$_Simple_types@D@std@@@0@ABV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPBV?$_String_val@U?$_Simple_types@D@std@@@0@ABV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<char> > const >, COMDAT

; 279  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept { // return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  :     return __builtin_addressof(_Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 281  : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPBV?$_String_val@U?$_Simple_types@D@std@@@0@ABV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<char> > const >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\utility
;	COMDAT ??$_Max_value@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
tv65 = -8						; size = 4
$T1 = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Max_value@I@std@@YAABIABI0@Z PROC			; std::_Max_value<unsigned int>, COMDAT

; 32   :     _NOEXCEPT_COND(noexcept(_Left < _Right)) { // return larger of _Left and _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 33   :     return _Left < _Right ? _Right : _Left;

  00014	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00017	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  0001a	8b 10		 mov	 edx, DWORD PTR [eax]
  0001c	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0001e	73 08		 jae	 SHORT $LN3@Max_value
  00020	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00023	89 45 f8	 mov	 DWORD PTR tv65[ebp], eax
  00026	eb 06		 jmp	 SHORT $LN4@Max_value
$LN3@Max_value:
  00028	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0002b	89 4d f8	 mov	 DWORD PTR tv65[ebp], ecx
$LN4@Max_value:
  0002e	8b 55 f8	 mov	 edx, DWORD PTR tv65[ebp]
  00031	89 55 fc	 mov	 DWORD PTR $T1[ebp], edx
  00034	8b 45 fc	 mov	 eax, DWORD PTR $T1[ebp]

; 34   : }

  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
??$_Max_value@I@std@@YAABIABI0@Z ENDP			; std::_Max_value<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z PROC		; std::_Destroy_in_place<char *>, COMDAT

; 321  : void _Destroy_in_place(_Ty& _Obj) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 322  :     _Obj.~_Ty();
; 323  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ENDP		; std::_Destroy_in_place<char *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\utility
;	COMDAT ??$exchange@PAXPAX@std@@YAPAXAAPAX$$QAPAX@Z
_TEXT	SEGMENT
__Old_val$ = -4						; size = 4
__Val$ = 8						; size = 4
__New_val$ = 12						; size = 4
??$exchange@PAXPAX@std@@YAPAXAAPAX$$QAPAX@Z PROC	; std::exchange<void *,void *>, COMDAT

; 526  : _Ty exchange(_Ty& _Val, _Other&& _New_val) { // assign _New_val to _Val, return previous _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 527  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  0000b	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0000e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00010	89 4d fc	 mov	 DWORD PTR __Old_val$[ebp], ecx

; 528  :     _Val         = static_cast<_Other&&>(_New_val);

  00013	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  00016	8b 45 0c	 mov	 eax, DWORD PTR __New_val$[ebp]
  00019	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001b	89 0a		 mov	 DWORD PTR [edx], ecx

; 529  :     return _Old_val;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR __Old_val$[ebp]

; 530  : }

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??$exchange@PAXPAX@std@@YAPAXAAPAX$$QAPAX@Z ENDP	; std::exchange<void *,void *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\utility
;	COMDAT ??$exchange@PAVRGYPipeProcess@@PAV1@@std@@YAPAVRGYPipeProcess@@AAPAV1@$$QAPAV1@@Z
_TEXT	SEGMENT
__Old_val$ = -4						; size = 4
__Val$ = 8						; size = 4
__New_val$ = 12						; size = 4
??$exchange@PAVRGYPipeProcess@@PAV1@@std@@YAPAVRGYPipeProcess@@AAPAV1@$$QAPAV1@@Z PROC ; std::exchange<RGYPipeProcess *,RGYPipeProcess *>, COMDAT

; 526  : _Ty exchange(_Ty& _Val, _Other&& _New_val) { // assign _New_val to _Val, return previous _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 527  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  0000b	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0000e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00010	89 4d fc	 mov	 DWORD PTR __Old_val$[ebp], ecx

; 528  :     _Val         = static_cast<_Other&&>(_New_val);

  00013	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  00016	8b 45 0c	 mov	 eax, DWORD PTR __New_val$[ebp]
  00019	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001b	89 0a		 mov	 DWORD PTR [edx], ecx

; 529  :     return _Old_val;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR __Old_val$[ebp]

; 530  : }

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??$exchange@PAVRGYPipeProcess@@PAV1@@std@@YAPAVRGYPipeProcess@@AAPAV1@$$QAPAV1@@Z ENDP ; std::exchange<RGYPipeProcess *,RGYPipeProcess *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\memory
;	COMDAT ??$_Copy_construct_from@VEncodeStatus@@@?$_Ptr_base@VEncodeStatus@@@std@@IAEXABV?$shared_ptr@VEncodeStatus@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
??$_Copy_construct_from@VEncodeStatus@@@?$_Ptr_base@VEncodeStatus@@@std@@IAEXABV?$shared_ptr@VEncodeStatus@@@1@@Z PROC ; std::_Ptr_base<EncodeStatus>::_Copy_construct_from<EncodeStatus>, COMDAT
; _this$ = ecx

; 835  :     void _Copy_construct_from(const shared_ptr<_Ty2>& _Other) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 836  :         // implement shared_ptr's (converting) copy ctor
; 837  :         if (_Other._Rep) {

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  00011	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00015	74 0b		 je	 SHORT $LN2@Copy_const

; 838  :             _Other._Rep->_Incref();

  00017	8b 4d 08	 mov	 ecx, DWORD PTR __Other$[ebp]
  0001a	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0001d	e8 00 00 00 00	 call	 ?_Incref@_Ref_count_base@std@@QAEXXZ ; std::_Ref_count_base::_Incref
$LN2@Copy_const:

; 839  :         }
; 840  : 
; 841  :         _Ptr = _Other._Ptr;

  00022	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00025	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  00028	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002a	89 0a		 mov	 DWORD PTR [edx], ecx

; 842  :         _Rep = _Other._Rep;

  0002c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002f	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  00032	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00035	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 843  :     }

  00038	83 c4 04	 add	 esp, 4
  0003b	3b ec		 cmp	 ebp, esp
  0003d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c2 04 00	 ret	 4
??$_Copy_construct_from@VEncodeStatus@@@?$_Ptr_base@VEncodeStatus@@@std@@IAEXABV?$shared_ptr@VEncodeStatus@@@1@@Z ENDP ; std::_Ptr_base<EncodeStatus>::_Copy_construct_from<EncodeStatus>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\utility
;	COMDAT ??$exchange@PAU_iobuf@@PAU1@@std@@YAPAU_iobuf@@AAPAU1@$$QAPAU1@@Z
_TEXT	SEGMENT
__Old_val$ = -4						; size = 4
__Val$ = 8						; size = 4
__New_val$ = 12						; size = 4
??$exchange@PAU_iobuf@@PAU1@@std@@YAPAU_iobuf@@AAPAU1@$$QAPAU1@@Z PROC ; std::exchange<_iobuf *,_iobuf *>, COMDAT

; 526  : _Ty exchange(_Ty& _Val, _Other&& _New_val) { // assign _New_val to _Val, return previous _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 527  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  0000b	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0000e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00010	89 4d fc	 mov	 DWORD PTR __Old_val$[ebp], ecx

; 528  :     _Val         = static_cast<_Other&&>(_New_val);

  00013	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  00016	8b 45 0c	 mov	 eax, DWORD PTR __New_val$[ebp]
  00019	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001b	89 0a		 mov	 DWORD PTR [edx], ecx

; 529  :     return _Old_val;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR __Old_val$[ebp]

; 530  : }

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??$exchange@PAU_iobuf@@PAU1@@std@@YAPAU_iobuf@@AAPAU1@$$QAPAU1@@Z ENDP ; std::exchange<_iobuf *,_iobuf *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\memory
;	COMDAT ??$_Copy_construct_from@VRGYLog@@@?$_Ptr_base@VRGYLog@@@std@@IAEXABV?$shared_ptr@VRGYLog@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
??$_Copy_construct_from@VRGYLog@@@?$_Ptr_base@VRGYLog@@@std@@IAEXABV?$shared_ptr@VRGYLog@@@1@@Z PROC ; std::_Ptr_base<RGYLog>::_Copy_construct_from<RGYLog>, COMDAT
; _this$ = ecx

; 835  :     void _Copy_construct_from(const shared_ptr<_Ty2>& _Other) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 836  :         // implement shared_ptr's (converting) copy ctor
; 837  :         if (_Other._Rep) {

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  00011	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00015	74 0b		 je	 SHORT $LN2@Copy_const

; 838  :             _Other._Rep->_Incref();

  00017	8b 4d 08	 mov	 ecx, DWORD PTR __Other$[ebp]
  0001a	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0001d	e8 00 00 00 00	 call	 ?_Incref@_Ref_count_base@std@@QAEXXZ ; std::_Ref_count_base::_Incref
$LN2@Copy_const:

; 839  :         }
; 840  : 
; 841  :         _Ptr = _Other._Ptr;

  00022	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00025	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  00028	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002a	89 0a		 mov	 DWORD PTR [edx], ecx

; 842  :         _Rep = _Other._Rep;

  0002c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002f	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  00032	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00035	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 843  :     }

  00038	83 c4 04	 add	 esp, 4
  0003b	3b ec		 cmp	 ebp, esp
  0003d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c2 04 00	 ret	 4
??$_Copy_construct_from@VRGYLog@@@?$_Ptr_base@VRGYLog@@@std@@IAEXABV?$shared_ptr@VRGYLog@@@1@@Z ENDP ; std::_Ptr_base<RGYLog>::_Copy_construct_from<RGYLog>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z PROC ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>, COMDAT

; 198  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) _NOEXCEPT_COND(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 199  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  0000b	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z ; std::addressof<std::_Container_proxy>
  00014	83 c4 04	 add	 esp, 4
  00017	50		 push	 eax
  00018	6a 08		 push	 8
  0001a	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  0001f	83 c4 08	 add	 esp, 8
  00022	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00028	51		 push	 ecx
  00029	e8 00 00 00 00	 call	 ??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z ; std::forward<std::_Container_base12 *>
  0002e	83 c4 04	 add	 esp, 4
  00031	8b 10		 mov	 edx, DWORD PTR [eax]
  00033	52		 push	 edx
  00034	8b 4d fc	 mov	 ecx, DWORD PTR $T1[ebp]
  00037	e8 00 00 00 00	 call	 ??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z ; std::_Container_proxy::_Container_proxy

; 200  :         _Ty(_STD forward<_Types>(_Args)...);
; 201  : }

  0003c	83 c4 04	 add	 esp, 4
  0003f	3b ec		 cmp	 ebp, esp
  00041	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z ENDP ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstddef
;	COMDAT ??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z PROC ; std::addressof<std::_Container_base12>, COMDAT

; 279  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept { // return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  :     return __builtin_addressof(_Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 281  : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z ENDP ; std::addressof<std::_Container_base12>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstddef
;	COMDAT ??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z PROC ; std::_Unfancy<std::_Container_proxy>, COMDAT

; 293  : _Ty* _Unfancy(_Ty* _Ptr) { // do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 294  :     return _Ptr;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 295  : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ENDP ; std::_Unfancy<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT
; _this$ = ecx

; 1414 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>
  00035	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	e8 00 00 00 00	 call	 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
  0003d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00044	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0004b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00051	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00058	59		 pop	 ecx
  00059	83 c4 10	 add	 esp, 16			; 00000010H
  0005c	3b ec		 cmp	 ebp, esp
  0005e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
__ehhandler$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >, COMDAT
; _this$ = ecx

; 1418 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002d	8b 45 0c	 mov	 eax, DWORD PTR __Val1$[ebp]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ; std::forward<std::allocator<char> >
  00036	83 c4 04	 add	 esp, 4
  00039	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	e8 00 00 00 00	 call	 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
  00041	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00048	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0004f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00052	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00055	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005c	59		 pop	 ecx
  0005d	83 c4 10	 add	 esp, 16			; 00000010H
  00060	3b ec		 cmp	 ebp, esp
  00062	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
__ehhandler$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\type_traits
;	COMDAT ??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z PROC ; std::move<std::allocator<char> &>, COMDAT

; 1432 : _NODISCARD constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept { // forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1433 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1434 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ENDP ; std::move<std::allocator<char> &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstddef
;	COMDAT ??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 279  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept { // return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  :     return __builtin_addressof(_Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 281  : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>, COMDAT
; _this$ = ecx

; 863  :     constexpr allocator(const allocator<_Other>&) noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstddef
;	COMDAT ??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z PROC ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >, COMDAT

; 279  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept { // return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  :     return __builtin_addressof(_Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 281  : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z ENDP ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstddef
;	COMDAT ??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<char> > >, COMDAT

; 279  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept { // return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  :     return __builtin_addressof(_Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 281  : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstddef
;	COMDAT ??$_Unfancy@D@std@@YAPADPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@D@std@@YAPADPAD@Z PROC			; std::_Unfancy<char>, COMDAT

; 293  : _Ty* _Unfancy(_Ty* _Ptr) { // do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 294  :     return _Ptr;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 295  : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unfancy@D@std@@YAPADPAD@Z ENDP			; std::_Unfancy<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ PROC ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >, COMDAT
; _this$ = ecx

; 1382 :     ~_Container_proxy_ptr12() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1383 :         if (_Ptr) {

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	83 38 00	 cmp	 DWORD PTR [eax], 0
  00014	74 15		 je	 SHORT $LN1@Container_

; 1384 :             _Delete_plain_internal(_Al, _Ptr);

  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001b	52		 push	 edx
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00022	51		 push	 ecx
  00023	e8 00 00 00 00	 call	 ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
  00028	83 c4 08	 add	 esp, 8
$LN1@Container_:

; 1385 :         }
; 1386 :     }

  0002b	83 c4 04	 add	 esp, 4
  0002e	3b ec		 cmp	 ebp, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ENDP ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
__Al_$ = 8						; size = 4
__Mycont$ = 12						; size = 4
??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z PROC ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >, COMDAT
; _this$ = ecx

; 1368 :     _Container_proxy_ptr12(_Alloc& _Al_, _Container_base12& _Mycont)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1369 :         : _Al(_Al_) { // create a new _Container_proxy pointing at _Mycont

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Al_$[ebp]
  0001d	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1370 :         _Ptr = _Unfancy(_Al_.allocate(1));

  00020	6a 01		 push	 1
  00022	8b 4d 08	 mov	 ecx, DWORD PTR __Al_$[ebp]
  00025	e8 00 00 00 00	 call	 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ; std::_Unfancy<std::_Container_proxy>
  00030	83 c4 04	 add	 esp, 4
  00033	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00036	89 02		 mov	 DWORD PTR [edx], eax

; 1371 :         _Construct_in_place(*_Ptr, _STD addressof(_Mycont));

  00038	8b 45 0c	 mov	 eax, DWORD PTR __Mycont$[ebp]
  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 ??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z ; std::addressof<std::_Container_base12>
  00041	83 c4 04	 add	 esp, 4
  00044	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
  00047	8d 4d f8	 lea	 ecx, DWORD PTR $T1[ebp]
  0004a	51		 push	 ecx
  0004b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0004e	8b 02		 mov	 eax, DWORD PTR [edx]
  00050	50		 push	 eax
  00051	e8 00 00 00 00	 call	 ??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
  00056	83 c4 08	 add	 esp, 8

; 1372 :         _Mycont._Myproxy = _Ptr;

  00059	8b 4d 0c	 mov	 ecx, DWORD PTR __Mycont$[ebp]
  0005c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0005f	8b 02		 mov	 eax, DWORD PTR [edx]
  00061	89 01		 mov	 DWORD PTR [ecx], eax

; 1373 :     }

  00063	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00066	83 c4 08	 add	 esp, 8
  00069	3b ec		 cmp	 ebp, esp
  0006b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c2 08 00	 ret	 8
??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z ENDP ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\utility
;	COMDAT ??$_Min_value@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
tv65 = -8						; size = 4
$T1 = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Min_value@I@std@@YAABIABI0@Z PROC			; std::_Min_value<unsigned int>, COMDAT

; 25   :     _NOEXCEPT_COND(noexcept(_Right < _Left)) { // return smaller of _Left and _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 26   :     return _Right < _Left ? _Right : _Left;

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00017	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0001a	8b 10		 mov	 edx, DWORD PTR [eax]
  0001c	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0001e	73 08		 jae	 SHORT $LN3@Min_value
  00020	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00023	89 45 f8	 mov	 DWORD PTR tv65[ebp], eax
  00026	eb 06		 jmp	 SHORT $LN4@Min_value
$LN3@Min_value:
  00028	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0002b	89 4d f8	 mov	 DWORD PTR tv65[ebp], ecx
$LN4@Min_value:
  0002e	8b 55 f8	 mov	 edx, DWORD PTR tv65[ebp]
  00031	89 55 fc	 mov	 DWORD PTR $T1[ebp], edx
  00034	8b 45 fc	 mov	 eax, DWORD PTR $T1[ebp]

; 27   : }

  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
??$_Min_value@I@std@@YAABIABI0@Z ENDP			; std::_Min_value<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\type_traits
;	COMDAT ??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>, COMDAT

; 1432 : _NODISCARD constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept { // forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1433 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1434 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\type_traits
;	COMDAT ??$forward@Uhandle_deleter@@@std@@YA$$QAUhandle_deleter@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@Uhandle_deleter@@@std@@YA$$QAUhandle_deleter@@AAU1@@Z PROC ; std::forward<handle_deleter>, COMDAT

; 1420 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1421 :     return static_cast<_Ty&&>(_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1422 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@Uhandle_deleter@@@std@@YA$$QAUhandle_deleter@@AAU1@@Z ENDP ; std::forward<handle_deleter>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstddef
;	COMDAT ??$addressof@V?$unique_ptr@XUhandle_deleter@@@std@@@std@@YAPAV?$unique_ptr@XUhandle_deleter@@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$unique_ptr@XUhandle_deleter@@@std@@@std@@YAPAV?$unique_ptr@XUhandle_deleter@@@0@AAV10@@Z PROC ; std::addressof<std::unique_ptr<void,handle_deleter> >, COMDAT

; 279  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept { // return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  :     return __builtin_addressof(_Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 281  : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@V?$unique_ptr@XUhandle_deleter@@@std@@@std@@YAPAV?$unique_ptr@XUhandle_deleter@@@0@AAV10@@Z ENDP ; std::addressof<std::unique_ptr<void,handle_deleter> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\utility
;	COMDAT ??$exchange@PAXAAPAX@std@@YAPAXAAPAX0@Z
_TEXT	SEGMENT
__Old_val$ = -4						; size = 4
__Val$ = 8						; size = 4
__New_val$ = 12						; size = 4
??$exchange@PAXAAPAX@std@@YAPAXAAPAX0@Z PROC		; std::exchange<void *,void * &>, COMDAT

; 526  : _Ty exchange(_Ty& _Val, _Other&& _New_val) { // assign _New_val to _Val, return previous _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 527  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  0000b	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0000e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00010	89 4d fc	 mov	 DWORD PTR __Old_val$[ebp], ecx

; 528  :     _Val         = static_cast<_Other&&>(_New_val);

  00013	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  00016	8b 45 0c	 mov	 eax, DWORD PTR __New_val$[ebp]
  00019	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001b	89 0a		 mov	 DWORD PTR [edx], ecx

; 529  :     return _Old_val;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR __Old_val$[ebp]

; 530  : }

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??$exchange@PAXAAPAX@std@@YAPAXAAPAX0@Z ENDP		; std::exchange<void *,void * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\type_traits
;	COMDAT ??$forward@U?$default_delete@VRGYPipeProcess@@@std@@@std@@YA$$QAU?$default_delete@VRGYPipeProcess@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$default_delete@VRGYPipeProcess@@@std@@@std@@YA$$QAU?$default_delete@VRGYPipeProcess@@@0@AAU10@@Z PROC ; std::forward<std::default_delete<RGYPipeProcess> >, COMDAT

; 1420 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1421 :     return static_cast<_Ty&&>(_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1422 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@U?$default_delete@VRGYPipeProcess@@@std@@@std@@YA$$QAU?$default_delete@VRGYPipeProcess@@@0@AAU10@@Z ENDP ; std::forward<std::default_delete<RGYPipeProcess> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstddef
;	COMDAT ??$addressof@V?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@@std@@YAPAV?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@@std@@YAPAV?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::unique_ptr<RGYPipeProcess,std::default_delete<RGYPipeProcess> > >, COMDAT

; 279  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept { // return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  :     return __builtin_addressof(_Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 281  : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@V?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@@std@@YAPAV?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::unique_ptr<RGYPipeProcess,std::default_delete<RGYPipeProcess> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\utility
;	COMDAT ??$exchange@PAVRGYPipeProcess@@AAPAV1@@std@@YAPAVRGYPipeProcess@@AAPAV1@0@Z
_TEXT	SEGMENT
__Old_val$ = -4						; size = 4
__Val$ = 8						; size = 4
__New_val$ = 12						; size = 4
??$exchange@PAVRGYPipeProcess@@AAPAV1@@std@@YAPAVRGYPipeProcess@@AAPAV1@0@Z PROC ; std::exchange<RGYPipeProcess *,RGYPipeProcess * &>, COMDAT

; 526  : _Ty exchange(_Ty& _Val, _Other&& _New_val) { // assign _New_val to _Val, return previous _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 527  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  0000b	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0000e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00010	89 4d fc	 mov	 DWORD PTR __Old_val$[ebp], ecx

; 528  :     _Val         = static_cast<_Other&&>(_New_val);

  00013	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  00016	8b 45 0c	 mov	 eax, DWORD PTR __New_val$[ebp]
  00019	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001b	89 0a		 mov	 DWORD PTR [edx], ecx

; 529  :     return _Old_val;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR __Old_val$[ebp]

; 530  : }

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??$exchange@PAVRGYPipeProcess@@AAPAV1@@std@@YAPAVRGYPipeProcess@@AAPAV1@0@Z ENDP ; std::exchange<RGYPipeProcess *,RGYPipeProcess * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\type_traits
;	COMDAT ??$forward@Ufp_deleter@@@std@@YA$$QAUfp_deleter@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@Ufp_deleter@@@std@@YA$$QAUfp_deleter@@AAU1@@Z PROC ; std::forward<fp_deleter>, COMDAT

; 1420 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1421 :     return static_cast<_Ty&&>(_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1422 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@Ufp_deleter@@@std@@YA$$QAUfp_deleter@@AAU1@@Z ENDP ; std::forward<fp_deleter>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstddef
;	COMDAT ??$addressof@V?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@@std@@YAPAV?$unique_ptr@U_iobuf@@Ufp_deleter@@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@@std@@YAPAV?$unique_ptr@U_iobuf@@Ufp_deleter@@@0@AAV10@@Z PROC ; std::addressof<std::unique_ptr<_iobuf,fp_deleter> >, COMDAT

; 279  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept { // return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  :     return __builtin_addressof(_Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 281  : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@V?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@@std@@YAPAV?$unique_ptr@U_iobuf@@Ufp_deleter@@@0@AAV10@@Z ENDP ; std::addressof<std::unique_ptr<_iobuf,fp_deleter> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\utility
;	COMDAT ??$exchange@PAU_iobuf@@AAPAU1@@std@@YAPAU_iobuf@@AAPAU1@0@Z
_TEXT	SEGMENT
__Old_val$ = -4						; size = 4
__Val$ = 8						; size = 4
__New_val$ = 12						; size = 4
??$exchange@PAU_iobuf@@AAPAU1@@std@@YAPAU_iobuf@@AAPAU1@0@Z PROC ; std::exchange<_iobuf *,_iobuf * &>, COMDAT

; 526  : _Ty exchange(_Ty& _Val, _Other&& _New_val) { // assign _New_val to _Val, return previous _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 527  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  0000b	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0000e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00010	89 4d fc	 mov	 DWORD PTR __Old_val$[ebp], ecx

; 528  :     _Val         = static_cast<_Other&&>(_New_val);

  00013	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  00016	8b 45 0c	 mov	 eax, DWORD PTR __New_val$[ebp]
  00019	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001b	89 0a		 mov	 DWORD PTR [edx], ecx

; 529  :     return _Old_val;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR __Old_val$[ebp]

; 530  : }

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??$exchange@PAU_iobuf@@AAPAU1@@std@@YAPAU_iobuf@@AAPAU1@0@Z ENDP ; std::exchange<_iobuf *,_iobuf * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
__New_proxy$ = -8					; size = 4
_this$ = -4						; size = 4
__Al$ = 8						; size = 4
??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z PROC ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >, COMDAT
; _this$ = ecx

; 1184 :     void _Alloc_proxy(_Alloc&& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1185 :         _Container_proxy* const _New_proxy = _Unfancy(_Al.allocate(1));

  0001e	6a 01		 push	 1
  00020	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  00023	e8 00 00 00 00	 call	 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ; std::_Unfancy<std::_Container_proxy>
  0002e	83 c4 04	 add	 esp, 4
  00031	89 45 f8	 mov	 DWORD PTR __New_proxy$[ebp], eax

; 1186 :         _Construct_in_place(*_New_proxy, this);

  00034	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00037	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
  0003a	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  0003d	51		 push	 ecx
  0003e	8b 55 f8	 mov	 edx, DWORD PTR __New_proxy$[ebp]
  00041	52		 push	 edx
  00042	e8 00 00 00 00	 call	 ??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
  00047	83 c4 08	 add	 esp, 8

; 1187 :         _Myproxy            = _New_proxy;

  0004a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	8b 4d f8	 mov	 ecx, DWORD PTR __New_proxy$[ebp]
  00050	89 08		 mov	 DWORD PTR [eax], ecx

; 1188 :         _New_proxy->_Mycont = this;

  00052	8b 55 f8	 mov	 edx, DWORD PTR __New_proxy$[ebp]
  00055	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00058	89 02		 mov	 DWORD PTR [edx], eax

; 1189 :     }

  0005a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005d	3b ec		 cmp	 ebp, esp
  0005f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c2 04 00	 ret	 4
??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z ENDP ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@PBD@std@@V?$_Vector_val@U?$_Simple_types@PBD@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@PBD@std@@V?$_Vector_val@U?$_Simple_types@PBD@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<char const *>,std::_Vector_val<std::_Simple_types<char const *> >,1>::_Compressed_pair<std::allocator<char const *>,std::_Vector_val<std::_Simple_types<char const *> >,1><>, COMDAT
; _this$ = ecx

; 1414 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??0?$allocator@PBD@std@@QAE@XZ ; std::allocator<char const *>::allocator<char const *>
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@PBD@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<char const *> >::_Vector_val<std::_Simple_types<char const *> >
  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	83 c4 04	 add	 esp, 4
  00024	3b ec		 cmp	 ebp, esp
  00026	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@V?$allocator@PBD@std@@V?$_Vector_val@U?$_Simple_types@PBD@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char const *>,std::_Vector_val<std::_Simple_types<char const *> >,1>::_Compressed_pair<std::allocator<char const *>,std::_Vector_val<std::_Simple_types<char const *> >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z PROC ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >, COMDAT

; 1109 : void _Delete_plain_internal(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1110 :     // destroy *_Ptr in place, then deallocate _Ptr using _Al; used for internal container types the user didn't name
; 1111 :     using _Ty = typename _Alloc::value_type;
; 1112 :     _Ptr->~_Ty();
; 1113 :     _Deallocate_plain(_Al, _Ptr);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  0000a	51		 push	 ecx
  0000b	e8 00 00 00 00	 call	 ??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
  00010	83 c4 08	 add	 esp, 8

; 1114 : }

  00013	3b ec		 cmp	 ebp, esp
  00015	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ENDP ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\utility
;	COMDAT ??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z
_TEXT	SEGMENT
__Old_val$ = -4						; size = 4
__Val$ = 8						; size = 4
__New_val$ = 12						; size = 4
??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z PROC ; std::exchange<std::_Container_proxy *,std::nullptr_t>, COMDAT

; 526  : _Ty exchange(_Ty& _Val, _Other&& _New_val) { // assign _New_val to _Val, return previous _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 527  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  0000b	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0000e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00010	89 4d fc	 mov	 DWORD PTR __Old_val$[ebp], ecx

; 528  :     _Val         = static_cast<_Other&&>(_New_val);

  00013	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  00016	8b 45 0c	 mov	 eax, DWORD PTR __New_val$[ebp]
  00019	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001b	89 0a		 mov	 DWORD PTR [edx], ecx

; 529  :     return _Old_val;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR __Old_val$[ebp]

; 530  : }

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z ENDP ; std::exchange<std::_Container_proxy *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ??$?0PBD@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@PBD@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0PBD@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@PBD@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char const *>, COMDAT
; _this$ = ecx

; 863  :     constexpr allocator(const allocator<_Other>&) noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
??$?0PBD@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@PBD@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char const *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z PROC ; std::allocator<std::_Container_proxy>::allocate, COMDAT
; _this$ = ecx

; 870  :     _NODISCARD _DECLSPEC_ALLOCATOR _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 871  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$_Get_size_of_n@$07@std@@YAII@Z ; std::_Get_size_of_n<8>
  00017	83 c4 04	 add	 esp, 4
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00020	83 c4 04	 add	 esp, 4

; 872  :     }

  00023	83 c4 04	 add	 esp, 4
  00026	3b ec		 cmp	 ebp, esp
  00028	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ENDP ; std::allocator<std::_Container_proxy>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\vector
;	COMDAT ??$_Emplace_reallocate@ABQBD@?$vector@PBDV?$allocator@PBD@std@@@std@@QAEPAPBDQAPBDABQBD@Z
_TEXT	SEGMENT
__Constructed_first$ = -64				; size = 4
__Constructed_last$ = -60				; size = 4
__Newvec$ = -56						; size = 4
__Newcapacity$ = -52					; size = 4
__Newsize$ = -48					; size = 4
__Oldsize$ = -44					; size = 4
__Whereoff$ = -40					; size = 4
__Mylast$ = -36						; size = 4
__Myfirst$ = -32					; size = 4
__My_data$ = -28					; size = 4
__Al$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABQBD@?$vector@PBDV?$allocator@PBD@std@@@std@@QAEPAPBDQAPBDABQBD@Z PROC ; std::vector<char const *,std::allocator<char const *> >::_Emplace_reallocate<char const * const &>, COMDAT
; _this$ = ecx

; 676  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Emplace_reallocate@ABQBD@?$vector@PBDV?$allocator@PBD@std@@@std@@QAEPAPBDQAPBDABQBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 30	 sub	 esp, 48			; 00000030H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	51		 push	 ecx
  00019	8d 7d c0	 lea	 edi, DWORD PTR [ebp-64]
  0001c	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	59		 pop	 ecx
  00029	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002e	33 c5		 xor	 eax, ebp
  00030	50		 push	 eax
  00031	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00034	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003a	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0003d	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 677  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 678  :         _Alty& _Al        = _Getal();

  00040	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	e8 00 00 00 00	 call	 ?_Getal@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEAAV?$allocator@PBD@2@XZ ; std::vector<char const *,std::allocator<char const *> >::_Getal
  00048	89 45 e8	 mov	 DWORD PTR __Al$[ebp], eax

; 679  :         auto& _My_data    = _Mypair._Myval2;

  0004b	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0004e	89 45 e4	 mov	 DWORD PTR __My_data$[ebp], eax

; 680  :         pointer& _Myfirst = _My_data._Myfirst;

  00051	8b 4d e4	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00054	83 c1 04	 add	 ecx, 4
  00057	89 4d e0	 mov	 DWORD PTR __Myfirst$[ebp], ecx

; 681  :         pointer& _Mylast  = _My_data._Mylast;

  0005a	8b 55 e4	 mov	 edx, DWORD PTR __My_data$[ebp]
  0005d	83 c2 08	 add	 edx, 8
  00060	89 55 dc	 mov	 DWORD PTR __Mylast$[ebp], edx

; 682  : 
; 683  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 684  : 
; 685  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00063	8b 45 e0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00066	8b 4d 08	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  00069	2b 08		 sub	 ecx, DWORD PTR [eax]
  0006b	c1 f9 02	 sar	 ecx, 2
  0006e	89 4d d8	 mov	 DWORD PTR __Whereoff$[ebp], ecx

; 686  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00071	8b 55 dc	 mov	 edx, DWORD PTR __Mylast$[ebp]
  00074	8b 45 e0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00077	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00079	2b 08		 sub	 ecx, DWORD PTR [eax]
  0007b	c1 f9 02	 sar	 ecx, 2
  0007e	89 4d d4	 mov	 DWORD PTR __Oldsize$[ebp], ecx

; 687  : 
; 688  :         if (_Oldsize == max_size()) {

  00081	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00084	e8 00 00 00 00	 call	 ?max_size@?$vector@PBDV?$allocator@PBD@std@@@std@@QBEIXZ ; std::vector<char const *,std::allocator<char const *> >::max_size
  00089	39 45 d4	 cmp	 DWORD PTR __Oldsize$[ebp], eax
  0008c	75 05		 jne	 SHORT $LN2@Emplace_re

; 689  :             _Xlength();

  0008e	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PBDV?$allocator@PBD@std@@@std@@CAXXZ ; std::vector<char const *,std::allocator<char const *> >::_Xlength
$LN2@Emplace_re:

; 690  :         }
; 691  : 
; 692  :         const size_type _Newsize     = _Oldsize + 1;

  00093	8b 55 d4	 mov	 edx, DWORD PTR __Oldsize$[ebp]
  00096	83 c2 01	 add	 edx, 1
  00099	89 55 d0	 mov	 DWORD PTR __Newsize$[ebp], edx

; 693  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

  0009c	8b 45 d0	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0009f	50		 push	 eax
  000a0	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000a3	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@PBDV?$allocator@PBD@std@@@std@@ABEII@Z ; std::vector<char const *,std::allocator<char const *> >::_Calculate_growth
  000a8	89 45 cc	 mov	 DWORD PTR __Newcapacity$[ebp], eax

; 694  : 
; 695  :         const pointer _Newvec           = _Al.allocate(_Newcapacity);

  000ab	8b 4d cc	 mov	 ecx, DWORD PTR __Newcapacity$[ebp]
  000ae	51		 push	 ecx
  000af	8b 4d e8	 mov	 ecx, DWORD PTR __Al$[ebp]
  000b2	e8 00 00 00 00	 call	 ?allocate@?$allocator@PBD@std@@QAEPAPBDI@Z ; std::allocator<char const *>::allocate
  000b7	89 45 c8	 mov	 DWORD PTR __Newvec$[ebp], eax

; 696  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  000ba	8b 55 d8	 mov	 edx, DWORD PTR __Whereoff$[ebp]
  000bd	8b 45 c8	 mov	 eax, DWORD PTR __Newvec$[ebp]
  000c0	8d 4c 90 04	 lea	 ecx, DWORD PTR [eax+edx*4+4]
  000c4	89 4d c4	 mov	 DWORD PTR __Constructed_last$[ebp], ecx

; 697  :         pointer _Constructed_first      = _Constructed_last;

  000c7	8b 55 c4	 mov	 edx, DWORD PTR __Constructed_last$[ebp]
  000ca	89 55 c0	 mov	 DWORD PTR __Constructed_first$[ebp], edx

; 698  : 
; 699  :         _TRY_BEGIN

  000cd	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 700  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  000d4	8b 45 0c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  000d7	50		 push	 eax
  000d8	e8 00 00 00 00	 call	 ??$forward@ABQBD@std@@YAABQBDABQBD@Z ; std::forward<char const * const &>
  000dd	83 c4 04	 add	 esp, 4
  000e0	50		 push	 eax
  000e1	8b 4d d8	 mov	 ecx, DWORD PTR __Whereoff$[ebp]
  000e4	8b 55 c8	 mov	 edx, DWORD PTR __Newvec$[ebp]
  000e7	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  000ea	50		 push	 eax
  000eb	e8 00 00 00 00	 call	 ??$_Unfancy@PBD@std@@YAPAPBDPAPBD@Z ; std::_Unfancy<char const *>
  000f0	83 c4 04	 add	 esp, 4
  000f3	50		 push	 eax
  000f4	8b 4d e8	 mov	 ecx, DWORD PTR __Al$[ebp]
  000f7	51		 push	 ecx
  000f8	e8 00 00 00 00	 call	 ??$construct@PBDABQBD@?$_Default_allocator_traits@V?$allocator@PBD@std@@@std@@SAXAAV?$allocator@PBD@1@QAPBDABQBD@Z ; std::_Default_allocator_traits<std::allocator<char const *> >::construct<char const *,char const * const &>
  000fd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 701  :         _Constructed_first = _Newvec + _Whereoff;

  00100	8b 55 d8	 mov	 edx, DWORD PTR __Whereoff$[ebp]
  00103	8b 45 c8	 mov	 eax, DWORD PTR __Newvec$[ebp]
  00106	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  00109	89 4d c0	 mov	 DWORD PTR __Constructed_first$[ebp], ecx

; 702  : 
; 703  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  0010c	8b 55 dc	 mov	 edx, DWORD PTR __Mylast$[ebp]
  0010f	8b 45 08	 mov	 eax, DWORD PTR __Whereptr$[ebp]
  00112	3b 02		 cmp	 eax, DWORD PTR [edx]
  00114	75 1a		 jne	 SHORT $LN4@Emplace_re

; 704  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  00116	8b 4d c8	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00119	51		 push	 ecx
  0011a	8b 55 dc	 mov	 edx, DWORD PTR __Mylast$[ebp]
  0011d	8b 02		 mov	 eax, DWORD PTR [edx]
  0011f	50		 push	 eax
  00120	8b 4d e0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00123	8b 11		 mov	 edx, DWORD PTR [ecx]
  00125	52		 push	 edx
  00126	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00129	e8 00 00 00 00	 call	 ?_Umove_if_noexcept@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEXPAPBD00@Z ; std::vector<char const *,std::allocator<char const *> >::_Umove_if_noexcept

; 705  :         } else { // provide basic guarantee

  0012e	eb 39		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 706  :             _Umove(_Myfirst, _Whereptr, _Newvec);

  00130	8b 45 c8	 mov	 eax, DWORD PTR __Newvec$[ebp]
  00133	50		 push	 eax
  00134	8b 4d 08	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  00137	51		 push	 ecx
  00138	8b 55 e0	 mov	 edx, DWORD PTR __Myfirst$[ebp]
  0013b	8b 02		 mov	 eax, DWORD PTR [edx]
  0013d	50		 push	 eax
  0013e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00141	e8 00 00 00 00	 call	 ?_Umove@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEPAPBDPAPBD00@Z ; std::vector<char const *,std::allocator<char const *> >::_Umove

; 707  :             _Constructed_first = _Newvec;

  00146	8b 4d c8	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00149	89 4d c0	 mov	 DWORD PTR __Constructed_first$[ebp], ecx

; 708  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  0014c	8b 55 d8	 mov	 edx, DWORD PTR __Whereoff$[ebp]
  0014f	8b 45 c8	 mov	 eax, DWORD PTR __Newvec$[ebp]
  00152	8d 4c 90 04	 lea	 ecx, DWORD PTR [eax+edx*4+4]
  00156	51		 push	 ecx
  00157	8b 55 dc	 mov	 edx, DWORD PTR __Mylast$[ebp]
  0015a	8b 02		 mov	 eax, DWORD PTR [edx]
  0015c	50		 push	 eax
  0015d	8b 4d 08	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  00160	51		 push	 ecx
  00161	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00164	e8 00 00 00 00	 call	 ?_Umove@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEPAPBDPAPBD00@Z ; std::vector<char const *,std::allocator<char const *> >::_Umove
$LN5@Emplace_re:
  00169	eb 2f		 jmp	 SHORT $LN7@Emplace_re
__catch$??$_Emplace_reallocate@ABQBD@?$vector@PBDV?$allocator@PBD@std@@@std@@QAEPAPBDQAPBDABQBD@Z$0:

; 709  :         }
; 710  :         _CATCH_ALL
; 711  :         _Destroy(_Constructed_first, _Constructed_last);

  0016b	8b 55 c4	 mov	 edx, DWORD PTR __Constructed_last$[ebp]
  0016e	52		 push	 edx
  0016f	8b 45 c0	 mov	 eax, DWORD PTR __Constructed_first$[ebp]
  00172	50		 push	 eax
  00173	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00176	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEXPAPBD0@Z ; std::vector<char const *,std::allocator<char const *> >::_Destroy

; 712  :         _Al.deallocate(_Newvec, _Newcapacity);

  0017b	8b 4d cc	 mov	 ecx, DWORD PTR __Newcapacity$[ebp]
  0017e	51		 push	 ecx
  0017f	8b 55 c8	 mov	 edx, DWORD PTR __Newvec$[ebp]
  00182	52		 push	 edx
  00183	8b 4d e8	 mov	 ecx, DWORD PTR __Al$[ebp]
  00186	e8 00 00 00 00	 call	 ?deallocate@?$allocator@PBD@std@@QAEXQAPBDI@Z ; std::allocator<char const *>::deallocate

; 713  :         _RERAISE;

  0018b	6a 00		 push	 0
  0018d	6a 00		 push	 0
  0018f	e8 00 00 00 00	 call	 __CxxThrowException@8

; 714  :         _CATCH_END

  00194	b8 00 00 00 00	 mov	 eax, $LN10@Emplace_re
  00199	c3		 ret	 0
$LN7@Emplace_re:
  0019a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  001a1	eb 07		 jmp	 SHORT __tryend$??$_Emplace_reallocate@ABQBD@?$vector@PBDV?$allocator@PBD@std@@@std@@QAEPAPBDQAPBDABQBD@Z$1
$LN10@Emplace_re:
  001a3	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Emplace_reallocate@ABQBD@?$vector@PBDV?$allocator@PBD@std@@@std@@QAEPAPBDQAPBDABQBD@Z$1:

; 715  : 
; 716  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  001aa	8b 45 cc	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  001ad	50		 push	 eax
  001ae	8b 4d d0	 mov	 ecx, DWORD PTR __Newsize$[ebp]
  001b1	51		 push	 ecx
  001b2	8b 55 c8	 mov	 edx, DWORD PTR __Newvec$[ebp]
  001b5	52		 push	 edx
  001b6	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001b9	e8 00 00 00 00	 call	 ?_Change_array@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEXQAPBDII@Z ; std::vector<char const *,std::allocator<char const *> >::_Change_array

; 717  :         return _Newvec + _Whereoff;

  001be	8b 45 d8	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  001c1	8b 4d c8	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  001c4	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
$LN6@Emplace_re:

; 718  :     }

  001c7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  001ca	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001d1	59		 pop	 ecx
  001d2	5f		 pop	 edi
  001d3	5e		 pop	 esi
  001d4	5b		 pop	 ebx
  001d5	83 c4 40	 add	 esp, 64			; 00000040H
  001d8	3b ec		 cmp	 ebp, esp
  001da	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001df	8b e5		 mov	 esp, ebp
  001e1	5d		 pop	 ebp
  001e2	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABQBD@?$vector@PBDV?$allocator@PBD@std@@@std@@QAEPAPBDQAPBDABQBD@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a bc	 mov	 ecx, DWORD PTR [edx-68]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABQBD@?$vector@PBDV?$allocator@PBD@std@@@std@@QAEPAPBDQAPBDABQBD@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABQBD@?$vector@PBDV?$allocator@PBD@std@@@std@@QAEPAPBDQAPBDABQBD@Z ENDP ; std::vector<char const *,std::allocator<char const *> >::_Emplace_reallocate<char const * const &>
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ??$construct@PBDABQBD@?$_Default_allocator_traits@V?$allocator@PBD@std@@@std@@SAXAAV?$allocator@PBD@1@QAPBDABQBD@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PBDABQBD@?$_Default_allocator_traits@V?$allocator@PBD@std@@@std@@SAXAAV?$allocator@PBD@1@QAPBDABQBD@Z PROC ; std::_Default_allocator_traits<std::allocator<char const *> >::construct<char const *,char const * const &>, COMDAT

; 757  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 758  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  0000b	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000e	50		 push	 eax
  0000f	6a 04		 push	 4
  00011	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00016	83 c4 08	 add	 esp, 8
  00019	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  0001c	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ??$forward@ABQBD@std@@YAABQBDABQBD@Z ; std::forward<char const * const &>
  00025	83 c4 04	 add	 esp, 4
  00028	8b 55 fc	 mov	 edx, DWORD PTR $T1[ebp]
  0002b	8b 00		 mov	 eax, DWORD PTR [eax]
  0002d	89 02		 mov	 DWORD PTR [edx], eax

; 759  :     }

  0002f	83 c4 04	 add	 esp, 4
  00032	3b ec		 cmp	 ebp, esp
  00034	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
??$construct@PBDABQBD@?$_Default_allocator_traits@V?$allocator@PBD@std@@@std@@SAXAAV?$allocator@PBD@1@QAPBDABQBD@Z ENDP ; std::_Default_allocator_traits<std::allocator<char const *> >::construct<char const *,char const * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABQBD@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEXABQBD@Z
_TEXT	SEGMENT
__Result$ = -16						; size = 4
__Mylast$ = -12						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABQBD@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEXABQBD@Z PROC ; std::vector<char const *,std::allocator<char const *> >::_Emplace_back_with_unused_capacity<char const * const &>, COMDAT
; _this$ = ecx

; 633  :     decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000e	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00011	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00014	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00017	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 634  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 635  :         auto& _My_data   = _Mypair._Myval2;

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 636  :         pointer& _Mylast = _My_data._Mylast;

  00020	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00023	83 c1 08	 add	 ecx, 8
  00026	89 4d f4	 mov	 DWORD PTR __Mylast$[ebp], ecx

; 637  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 638  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  00029	8b 55 08	 mov	 edx, DWORD PTR _<_Val_0>$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$forward@ABQBD@std@@YAABQBDABQBD@Z ; std::forward<char const * const &>
  00032	83 c4 04	 add	 esp, 4
  00035	50		 push	 eax
  00036	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00039	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003b	51		 push	 ecx
  0003c	e8 00 00 00 00	 call	 ??$_Unfancy@PBD@std@@YAPAPBDPAPBD@Z ; std::_Unfancy<char const *>
  00041	83 c4 04	 add	 esp, 4
  00044	50		 push	 eax
  00045	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	e8 00 00 00 00	 call	 ?_Getal@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEAAV?$allocator@PBD@2@XZ ; std::vector<char const *,std::allocator<char const *> >::_Getal
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ??$construct@PBDABQBD@?$_Default_allocator_traits@V?$allocator@PBD@std@@@std@@SAXAAV?$allocator@PBD@1@QAPBDABQBD@Z ; std::_Default_allocator_traits<std::allocator<char const *> >::construct<char const *,char const * const &>
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH

; 639  :         _Orphan_range(_Mylast, _Mylast);

  00056	8b 55 f4	 mov	 edx, DWORD PTR __Mylast$[ebp]
  00059	8b 02		 mov	 eax, DWORD PTR [edx]
  0005b	50		 push	 eax
  0005c	8b 4d f4	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  0005f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00061	52		 push	 edx
  00062	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00065	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@PBDV?$allocator@PBD@std@@@std@@ABEXPAPBD0@Z ; std::vector<char const *,std::allocator<char const *> >::_Orphan_range

; 640  :         _Ty& _Result = *_Mylast;

  0006a	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0006d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006f	89 4d f0	 mov	 DWORD PTR __Result$[ebp], ecx

; 641  :         ++_Mylast;

  00072	8b 55 f4	 mov	 edx, DWORD PTR __Mylast$[ebp]
  00075	8b 02		 mov	 eax, DWORD PTR [edx]
  00077	83 c0 04	 add	 eax, 4
  0007a	8b 4d f4	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  0007d	89 01		 mov	 DWORD PTR [ecx], eax

; 642  : #if _HAS_CXX17
; 643  :         return _Result;
; 644  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 645  :         (void) _Result;
; 646  : #endif // _HAS_CXX17
; 647  :     }

  0007f	83 c4 10	 add	 esp, 16			; 00000010H
  00082	3b ec		 cmp	 ebp, esp
  00084	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00089	8b e5		 mov	 esp, ebp
  0008b	5d		 pop	 ebp
  0008c	c2 04 00	 ret	 4
??$_Emplace_back_with_unused_capacity@ABQBD@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEXABQBD@Z ENDP ; std::vector<char const *,std::allocator<char const *> >::_Emplace_back_with_unused_capacity<char const * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\type_traits
;	COMDAT ??$forward@ABQBD@std@@YAABQBDABQBD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABQBD@std@@YAABQBDABQBD@Z PROC		; std::forward<char const * const &>, COMDAT

; 1420 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1421 :     return static_cast<_Ty&&>(_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1422 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABQBD@std@@YAABQBDABQBD@Z ENDP		; std::forward<char const * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\vector
;	COMDAT ??$emplace_back@ABQBD@?$vector@PBDV?$allocator@PBD@std@@@std@@QAEXABQBD@Z
_TEXT	SEGMENT
__Result$ = -16						; size = 4
__Mylast$ = -12						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABQBD@?$vector@PBDV?$allocator@PBD@std@@@std@@QAEXABQBD@Z PROC ; std::vector<char const *,std::allocator<char const *> >::emplace_back<char const * const &>, COMDAT
; _this$ = ecx

; 651  :     decltype(auto) emplace_back(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000e	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00011	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00014	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00017	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 652  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 653  :         auto& _My_data   = _Mypair._Myval2;

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 654  :         pointer& _Mylast = _My_data._Mylast;

  00020	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00023	83 c1 08	 add	 ecx, 8
  00026	89 4d f4	 mov	 DWORD PTR __Mylast$[ebp], ecx

; 655  :         if (_Mylast != _My_data._Myend) {

  00029	8b 55 f4	 mov	 edx, DWORD PTR __Mylast$[ebp]
  0002c	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  0002f	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00031	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  00034	74 17		 je	 SHORT $LN2@emplace_ba

; 656  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  00036	8b 55 08	 mov	 edx, DWORD PTR _<_Val_0>$[ebp]
  00039	52		 push	 edx
  0003a	e8 00 00 00 00	 call	 ??$forward@ABQBD@std@@YAABQBDABQBD@Z ; std::forward<char const * const &>
  0003f	83 c4 04	 add	 esp, 4
  00042	50		 push	 eax
  00043	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	e8 00 00 00 00	 call	 ??$_Emplace_back_with_unused_capacity@ABQBD@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEXABQBD@Z ; std::vector<char const *,std::allocator<char const *> >::_Emplace_back_with_unused_capacity<char const * const &>
  0004b	eb 1e		 jmp	 SHORT $LN1@emplace_ba
$LN2@emplace_ba:

; 657  :         }
; 658  : 
; 659  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0004d	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00050	50		 push	 eax
  00051	e8 00 00 00 00	 call	 ??$forward@ABQBD@std@@YAABQBDABQBD@Z ; std::forward<char const * const &>
  00056	83 c4 04	 add	 esp, 4
  00059	50		 push	 eax
  0005a	8b 4d f4	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  0005d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005f	52		 push	 edx
  00060	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00063	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABQBD@?$vector@PBDV?$allocator@PBD@std@@@std@@QAEPAPBDQAPBDABQBD@Z ; std::vector<char const *,std::allocator<char const *> >::_Emplace_reallocate<char const * const &>
  00068	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax
$LN1@emplace_ba:

; 660  : #if _HAS_CXX17
; 661  :         return _Result;
; 662  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 663  :         (void) _Result;
; 664  : #endif // _HAS_CXX17
; 665  :     }

  0006b	83 c4 10	 add	 esp, 16			; 00000010H
  0006e	3b ec		 cmp	 ebp, esp
  00070	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00075	8b e5		 mov	 esp, ebp
  00077	5d		 pop	 ebp
  00078	c2 04 00	 ret	 4
??$emplace_back@ABQBD@?$vector@PBDV?$allocator@PBD@std@@@std@@QAEXABQBD@Z ENDP ; std::vector<char const *,std::allocator<char const *> >::emplace_back<char const * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\vector
;	COMDAT ??$_Emplace_reallocate@PBD@?$vector@PBDV?$allocator@PBD@std@@@std@@QAEPAPBDQAPBD$$QAPBD@Z
_TEXT	SEGMENT
__Constructed_first$ = -64				; size = 4
__Constructed_last$ = -60				; size = 4
__Newvec$ = -56						; size = 4
__Newcapacity$ = -52					; size = 4
__Newsize$ = -48					; size = 4
__Oldsize$ = -44					; size = 4
__Whereoff$ = -40					; size = 4
__Mylast$ = -36						; size = 4
__Myfirst$ = -32					; size = 4
__My_data$ = -28					; size = 4
__Al$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@PBD@?$vector@PBDV?$allocator@PBD@std@@@std@@QAEPAPBDQAPBD$$QAPBD@Z PROC ; std::vector<char const *,std::allocator<char const *> >::_Emplace_reallocate<char const *>, COMDAT
; _this$ = ecx

; 676  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Emplace_reallocate@PBD@?$vector@PBDV?$allocator@PBD@std@@@std@@QAEPAPBDQAPBD$$QAPBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 30	 sub	 esp, 48			; 00000030H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	51		 push	 ecx
  00019	8d 7d c0	 lea	 edi, DWORD PTR [ebp-64]
  0001c	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	59		 pop	 ecx
  00029	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002e	33 c5		 xor	 eax, ebp
  00030	50		 push	 eax
  00031	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00034	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003a	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0003d	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 677  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 678  :         _Alty& _Al        = _Getal();

  00040	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	e8 00 00 00 00	 call	 ?_Getal@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEAAV?$allocator@PBD@2@XZ ; std::vector<char const *,std::allocator<char const *> >::_Getal
  00048	89 45 e8	 mov	 DWORD PTR __Al$[ebp], eax

; 679  :         auto& _My_data    = _Mypair._Myval2;

  0004b	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0004e	89 45 e4	 mov	 DWORD PTR __My_data$[ebp], eax

; 680  :         pointer& _Myfirst = _My_data._Myfirst;

  00051	8b 4d e4	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00054	83 c1 04	 add	 ecx, 4
  00057	89 4d e0	 mov	 DWORD PTR __Myfirst$[ebp], ecx

; 681  :         pointer& _Mylast  = _My_data._Mylast;

  0005a	8b 55 e4	 mov	 edx, DWORD PTR __My_data$[ebp]
  0005d	83 c2 08	 add	 edx, 8
  00060	89 55 dc	 mov	 DWORD PTR __Mylast$[ebp], edx

; 682  : 
; 683  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 684  : 
; 685  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00063	8b 45 e0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00066	8b 4d 08	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  00069	2b 08		 sub	 ecx, DWORD PTR [eax]
  0006b	c1 f9 02	 sar	 ecx, 2
  0006e	89 4d d8	 mov	 DWORD PTR __Whereoff$[ebp], ecx

; 686  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00071	8b 55 dc	 mov	 edx, DWORD PTR __Mylast$[ebp]
  00074	8b 45 e0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00077	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00079	2b 08		 sub	 ecx, DWORD PTR [eax]
  0007b	c1 f9 02	 sar	 ecx, 2
  0007e	89 4d d4	 mov	 DWORD PTR __Oldsize$[ebp], ecx

; 687  : 
; 688  :         if (_Oldsize == max_size()) {

  00081	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00084	e8 00 00 00 00	 call	 ?max_size@?$vector@PBDV?$allocator@PBD@std@@@std@@QBEIXZ ; std::vector<char const *,std::allocator<char const *> >::max_size
  00089	39 45 d4	 cmp	 DWORD PTR __Oldsize$[ebp], eax
  0008c	75 05		 jne	 SHORT $LN2@Emplace_re

; 689  :             _Xlength();

  0008e	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PBDV?$allocator@PBD@std@@@std@@CAXXZ ; std::vector<char const *,std::allocator<char const *> >::_Xlength
$LN2@Emplace_re:

; 690  :         }
; 691  : 
; 692  :         const size_type _Newsize     = _Oldsize + 1;

  00093	8b 55 d4	 mov	 edx, DWORD PTR __Oldsize$[ebp]
  00096	83 c2 01	 add	 edx, 1
  00099	89 55 d0	 mov	 DWORD PTR __Newsize$[ebp], edx

; 693  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

  0009c	8b 45 d0	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0009f	50		 push	 eax
  000a0	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000a3	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@PBDV?$allocator@PBD@std@@@std@@ABEII@Z ; std::vector<char const *,std::allocator<char const *> >::_Calculate_growth
  000a8	89 45 cc	 mov	 DWORD PTR __Newcapacity$[ebp], eax

; 694  : 
; 695  :         const pointer _Newvec           = _Al.allocate(_Newcapacity);

  000ab	8b 4d cc	 mov	 ecx, DWORD PTR __Newcapacity$[ebp]
  000ae	51		 push	 ecx
  000af	8b 4d e8	 mov	 ecx, DWORD PTR __Al$[ebp]
  000b2	e8 00 00 00 00	 call	 ?allocate@?$allocator@PBD@std@@QAEPAPBDI@Z ; std::allocator<char const *>::allocate
  000b7	89 45 c8	 mov	 DWORD PTR __Newvec$[ebp], eax

; 696  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  000ba	8b 55 d8	 mov	 edx, DWORD PTR __Whereoff$[ebp]
  000bd	8b 45 c8	 mov	 eax, DWORD PTR __Newvec$[ebp]
  000c0	8d 4c 90 04	 lea	 ecx, DWORD PTR [eax+edx*4+4]
  000c4	89 4d c4	 mov	 DWORD PTR __Constructed_last$[ebp], ecx

; 697  :         pointer _Constructed_first      = _Constructed_last;

  000c7	8b 55 c4	 mov	 edx, DWORD PTR __Constructed_last$[ebp]
  000ca	89 55 c0	 mov	 DWORD PTR __Constructed_first$[ebp], edx

; 698  : 
; 699  :         _TRY_BEGIN

  000cd	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 700  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  000d4	8b 45 0c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  000d7	50		 push	 eax
  000d8	e8 00 00 00 00	 call	 ??$forward@PBD@std@@YA$$QAPBDAAPBD@Z ; std::forward<char const *>
  000dd	83 c4 04	 add	 esp, 4
  000e0	50		 push	 eax
  000e1	8b 4d d8	 mov	 ecx, DWORD PTR __Whereoff$[ebp]
  000e4	8b 55 c8	 mov	 edx, DWORD PTR __Newvec$[ebp]
  000e7	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  000ea	50		 push	 eax
  000eb	e8 00 00 00 00	 call	 ??$_Unfancy@PBD@std@@YAPAPBDPAPBD@Z ; std::_Unfancy<char const *>
  000f0	83 c4 04	 add	 esp, 4
  000f3	50		 push	 eax
  000f4	8b 4d e8	 mov	 ecx, DWORD PTR __Al$[ebp]
  000f7	51		 push	 ecx
  000f8	e8 00 00 00 00	 call	 ??$construct@PBDPBD@?$_Default_allocator_traits@V?$allocator@PBD@std@@@std@@SAXAAV?$allocator@PBD@1@QAPBD$$QAPBD@Z ; std::_Default_allocator_traits<std::allocator<char const *> >::construct<char const *,char const *>
  000fd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 701  :         _Constructed_first = _Newvec + _Whereoff;

  00100	8b 55 d8	 mov	 edx, DWORD PTR __Whereoff$[ebp]
  00103	8b 45 c8	 mov	 eax, DWORD PTR __Newvec$[ebp]
  00106	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  00109	89 4d c0	 mov	 DWORD PTR __Constructed_first$[ebp], ecx

; 702  : 
; 703  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  0010c	8b 55 dc	 mov	 edx, DWORD PTR __Mylast$[ebp]
  0010f	8b 45 08	 mov	 eax, DWORD PTR __Whereptr$[ebp]
  00112	3b 02		 cmp	 eax, DWORD PTR [edx]
  00114	75 1a		 jne	 SHORT $LN4@Emplace_re

; 704  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  00116	8b 4d c8	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00119	51		 push	 ecx
  0011a	8b 55 dc	 mov	 edx, DWORD PTR __Mylast$[ebp]
  0011d	8b 02		 mov	 eax, DWORD PTR [edx]
  0011f	50		 push	 eax
  00120	8b 4d e0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00123	8b 11		 mov	 edx, DWORD PTR [ecx]
  00125	52		 push	 edx
  00126	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00129	e8 00 00 00 00	 call	 ?_Umove_if_noexcept@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEXPAPBD00@Z ; std::vector<char const *,std::allocator<char const *> >::_Umove_if_noexcept

; 705  :         } else { // provide basic guarantee

  0012e	eb 39		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 706  :             _Umove(_Myfirst, _Whereptr, _Newvec);

  00130	8b 45 c8	 mov	 eax, DWORD PTR __Newvec$[ebp]
  00133	50		 push	 eax
  00134	8b 4d 08	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  00137	51		 push	 ecx
  00138	8b 55 e0	 mov	 edx, DWORD PTR __Myfirst$[ebp]
  0013b	8b 02		 mov	 eax, DWORD PTR [edx]
  0013d	50		 push	 eax
  0013e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00141	e8 00 00 00 00	 call	 ?_Umove@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEPAPBDPAPBD00@Z ; std::vector<char const *,std::allocator<char const *> >::_Umove

; 707  :             _Constructed_first = _Newvec;

  00146	8b 4d c8	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00149	89 4d c0	 mov	 DWORD PTR __Constructed_first$[ebp], ecx

; 708  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  0014c	8b 55 d8	 mov	 edx, DWORD PTR __Whereoff$[ebp]
  0014f	8b 45 c8	 mov	 eax, DWORD PTR __Newvec$[ebp]
  00152	8d 4c 90 04	 lea	 ecx, DWORD PTR [eax+edx*4+4]
  00156	51		 push	 ecx
  00157	8b 55 dc	 mov	 edx, DWORD PTR __Mylast$[ebp]
  0015a	8b 02		 mov	 eax, DWORD PTR [edx]
  0015c	50		 push	 eax
  0015d	8b 4d 08	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  00160	51		 push	 ecx
  00161	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00164	e8 00 00 00 00	 call	 ?_Umove@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEPAPBDPAPBD00@Z ; std::vector<char const *,std::allocator<char const *> >::_Umove
$LN5@Emplace_re:
  00169	eb 2f		 jmp	 SHORT $LN7@Emplace_re
__catch$??$_Emplace_reallocate@PBD@?$vector@PBDV?$allocator@PBD@std@@@std@@QAEPAPBDQAPBD$$QAPBD@Z$0:

; 709  :         }
; 710  :         _CATCH_ALL
; 711  :         _Destroy(_Constructed_first, _Constructed_last);

  0016b	8b 55 c4	 mov	 edx, DWORD PTR __Constructed_last$[ebp]
  0016e	52		 push	 edx
  0016f	8b 45 c0	 mov	 eax, DWORD PTR __Constructed_first$[ebp]
  00172	50		 push	 eax
  00173	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00176	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEXPAPBD0@Z ; std::vector<char const *,std::allocator<char const *> >::_Destroy

; 712  :         _Al.deallocate(_Newvec, _Newcapacity);

  0017b	8b 4d cc	 mov	 ecx, DWORD PTR __Newcapacity$[ebp]
  0017e	51		 push	 ecx
  0017f	8b 55 c8	 mov	 edx, DWORD PTR __Newvec$[ebp]
  00182	52		 push	 edx
  00183	8b 4d e8	 mov	 ecx, DWORD PTR __Al$[ebp]
  00186	e8 00 00 00 00	 call	 ?deallocate@?$allocator@PBD@std@@QAEXQAPBDI@Z ; std::allocator<char const *>::deallocate

; 713  :         _RERAISE;

  0018b	6a 00		 push	 0
  0018d	6a 00		 push	 0
  0018f	e8 00 00 00 00	 call	 __CxxThrowException@8

; 714  :         _CATCH_END

  00194	b8 00 00 00 00	 mov	 eax, $LN10@Emplace_re
  00199	c3		 ret	 0
$LN7@Emplace_re:
  0019a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  001a1	eb 07		 jmp	 SHORT __tryend$??$_Emplace_reallocate@PBD@?$vector@PBDV?$allocator@PBD@std@@@std@@QAEPAPBDQAPBD$$QAPBD@Z$1
$LN10@Emplace_re:
  001a3	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Emplace_reallocate@PBD@?$vector@PBDV?$allocator@PBD@std@@@std@@QAEPAPBDQAPBD$$QAPBD@Z$1:

; 715  : 
; 716  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  001aa	8b 45 cc	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  001ad	50		 push	 eax
  001ae	8b 4d d0	 mov	 ecx, DWORD PTR __Newsize$[ebp]
  001b1	51		 push	 ecx
  001b2	8b 55 c8	 mov	 edx, DWORD PTR __Newvec$[ebp]
  001b5	52		 push	 edx
  001b6	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001b9	e8 00 00 00 00	 call	 ?_Change_array@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEXQAPBDII@Z ; std::vector<char const *,std::allocator<char const *> >::_Change_array

; 717  :         return _Newvec + _Whereoff;

  001be	8b 45 d8	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  001c1	8b 4d c8	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  001c4	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
$LN6@Emplace_re:

; 718  :     }

  001c7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  001ca	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001d1	59		 pop	 ecx
  001d2	5f		 pop	 edi
  001d3	5e		 pop	 esi
  001d4	5b		 pop	 ebx
  001d5	83 c4 40	 add	 esp, 64			; 00000040H
  001d8	3b ec		 cmp	 ebp, esp
  001da	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001df	8b e5		 mov	 esp, ebp
  001e1	5d		 pop	 ebp
  001e2	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@PBD@?$vector@PBDV?$allocator@PBD@std@@@std@@QAEPAPBDQAPBD$$QAPBD@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a bc	 mov	 ecx, DWORD PTR [edx-68]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@PBD@?$vector@PBDV?$allocator@PBD@std@@@std@@QAEPAPBDQAPBD$$QAPBD@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@PBD@?$vector@PBDV?$allocator@PBD@std@@@std@@QAEPAPBDQAPBD$$QAPBD@Z ENDP ; std::vector<char const *,std::allocator<char const *> >::_Emplace_reallocate<char const *>
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ??$construct@PBDPBD@?$_Default_allocator_traits@V?$allocator@PBD@std@@@std@@SAXAAV?$allocator@PBD@1@QAPBD$$QAPBD@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PBDPBD@?$_Default_allocator_traits@V?$allocator@PBD@std@@@std@@SAXAAV?$allocator@PBD@1@QAPBD$$QAPBD@Z PROC ; std::_Default_allocator_traits<std::allocator<char const *> >::construct<char const *,char const *>, COMDAT

; 757  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 758  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  0000b	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000e	50		 push	 eax
  0000f	6a 04		 push	 4
  00011	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00016	83 c4 08	 add	 esp, 8
  00019	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  0001c	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ??$forward@PBD@std@@YA$$QAPBDAAPBD@Z ; std::forward<char const *>
  00025	83 c4 04	 add	 esp, 4
  00028	8b 55 fc	 mov	 edx, DWORD PTR $T1[ebp]
  0002b	8b 00		 mov	 eax, DWORD PTR [eax]
  0002d	89 02		 mov	 DWORD PTR [edx], eax

; 759  :     }

  0002f	83 c4 04	 add	 esp, 4
  00032	3b ec		 cmp	 ebp, esp
  00034	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
??$construct@PBDPBD@?$_Default_allocator_traits@V?$allocator@PBD@std@@@std@@SAXAAV?$allocator@PBD@1@QAPBD$$QAPBD@Z ENDP ; std::_Default_allocator_traits<std::allocator<char const *> >::construct<char const *,char const *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstddef
;	COMDAT ??$_Unfancy@PBD@std@@YAPAPBDPAPBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@PBD@std@@YAPAPBDPAPBD@Z PROC		; std::_Unfancy<char const *>, COMDAT

; 293  : _Ty* _Unfancy(_Ty* _Ptr) { // do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 294  :     return _Ptr;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 295  : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unfancy@PBD@std@@YAPAPBDPAPBD@Z ENDP		; std::_Unfancy<char const *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@PBD@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEX$$QAPBD@Z
_TEXT	SEGMENT
__Result$ = -16						; size = 4
__Mylast$ = -12						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@PBD@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEX$$QAPBD@Z PROC ; std::vector<char const *,std::allocator<char const *> >::_Emplace_back_with_unused_capacity<char const *>, COMDAT
; _this$ = ecx

; 633  :     decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000e	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00011	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00014	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00017	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 634  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 635  :         auto& _My_data   = _Mypair._Myval2;

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 636  :         pointer& _Mylast = _My_data._Mylast;

  00020	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00023	83 c1 08	 add	 ecx, 8
  00026	89 4d f4	 mov	 DWORD PTR __Mylast$[ebp], ecx

; 637  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 638  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  00029	8b 55 08	 mov	 edx, DWORD PTR _<_Val_0>$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$forward@PBD@std@@YA$$QAPBDAAPBD@Z ; std::forward<char const *>
  00032	83 c4 04	 add	 esp, 4
  00035	50		 push	 eax
  00036	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00039	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003b	51		 push	 ecx
  0003c	e8 00 00 00 00	 call	 ??$_Unfancy@PBD@std@@YAPAPBDPAPBD@Z ; std::_Unfancy<char const *>
  00041	83 c4 04	 add	 esp, 4
  00044	50		 push	 eax
  00045	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	e8 00 00 00 00	 call	 ?_Getal@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEAAV?$allocator@PBD@2@XZ ; std::vector<char const *,std::allocator<char const *> >::_Getal
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ??$construct@PBDPBD@?$_Default_allocator_traits@V?$allocator@PBD@std@@@std@@SAXAAV?$allocator@PBD@1@QAPBD$$QAPBD@Z ; std::_Default_allocator_traits<std::allocator<char const *> >::construct<char const *,char const *>
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH

; 639  :         _Orphan_range(_Mylast, _Mylast);

  00056	8b 55 f4	 mov	 edx, DWORD PTR __Mylast$[ebp]
  00059	8b 02		 mov	 eax, DWORD PTR [edx]
  0005b	50		 push	 eax
  0005c	8b 4d f4	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  0005f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00061	52		 push	 edx
  00062	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00065	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@PBDV?$allocator@PBD@std@@@std@@ABEXPAPBD0@Z ; std::vector<char const *,std::allocator<char const *> >::_Orphan_range

; 640  :         _Ty& _Result = *_Mylast;

  0006a	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0006d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006f	89 4d f0	 mov	 DWORD PTR __Result$[ebp], ecx

; 641  :         ++_Mylast;

  00072	8b 55 f4	 mov	 edx, DWORD PTR __Mylast$[ebp]
  00075	8b 02		 mov	 eax, DWORD PTR [edx]
  00077	83 c0 04	 add	 eax, 4
  0007a	8b 4d f4	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  0007d	89 01		 mov	 DWORD PTR [ecx], eax

; 642  : #if _HAS_CXX17
; 643  :         return _Result;
; 644  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 645  :         (void) _Result;
; 646  : #endif // _HAS_CXX17
; 647  :     }

  0007f	83 c4 10	 add	 esp, 16			; 00000010H
  00082	3b ec		 cmp	 ebp, esp
  00084	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00089	8b e5		 mov	 esp, ebp
  0008b	5d		 pop	 ebp
  0008c	c2 04 00	 ret	 4
??$_Emplace_back_with_unused_capacity@PBD@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEX$$QAPBD@Z ENDP ; std::vector<char const *,std::allocator<char const *> >::_Emplace_back_with_unused_capacity<char const *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\type_traits
;	COMDAT ??$forward@PBD@std@@YA$$QAPBDAAPBD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@PBD@std@@YA$$QAPBDAAPBD@Z PROC		; std::forward<char const *>, COMDAT

; 1420 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1421 :     return static_cast<_Ty&&>(_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1422 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@PBD@std@@YA$$QAPBDAAPBD@Z ENDP		; std::forward<char const *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\vector
;	COMDAT ??$emplace_back@PBD@?$vector@PBDV?$allocator@PBD@std@@@std@@QAEX$$QAPBD@Z
_TEXT	SEGMENT
__Result$ = -16						; size = 4
__Mylast$ = -12						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$emplace_back@PBD@?$vector@PBDV?$allocator@PBD@std@@@std@@QAEX$$QAPBD@Z PROC ; std::vector<char const *,std::allocator<char const *> >::emplace_back<char const *>, COMDAT
; _this$ = ecx

; 651  :     decltype(auto) emplace_back(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000e	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00011	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00014	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00017	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 652  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 653  :         auto& _My_data   = _Mypair._Myval2;

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 654  :         pointer& _Mylast = _My_data._Mylast;

  00020	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00023	83 c1 08	 add	 ecx, 8
  00026	89 4d f4	 mov	 DWORD PTR __Mylast$[ebp], ecx

; 655  :         if (_Mylast != _My_data._Myend) {

  00029	8b 55 f4	 mov	 edx, DWORD PTR __Mylast$[ebp]
  0002c	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  0002f	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00031	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  00034	74 17		 je	 SHORT $LN2@emplace_ba

; 656  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  00036	8b 55 08	 mov	 edx, DWORD PTR _<_Val_0>$[ebp]
  00039	52		 push	 edx
  0003a	e8 00 00 00 00	 call	 ??$forward@PBD@std@@YA$$QAPBDAAPBD@Z ; std::forward<char const *>
  0003f	83 c4 04	 add	 esp, 4
  00042	50		 push	 eax
  00043	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	e8 00 00 00 00	 call	 ??$_Emplace_back_with_unused_capacity@PBD@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEX$$QAPBD@Z ; std::vector<char const *,std::allocator<char const *> >::_Emplace_back_with_unused_capacity<char const *>
  0004b	eb 1e		 jmp	 SHORT $LN1@emplace_ba
$LN2@emplace_ba:

; 657  :         }
; 658  : 
; 659  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0004d	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00050	50		 push	 eax
  00051	e8 00 00 00 00	 call	 ??$forward@PBD@std@@YA$$QAPBDAAPBD@Z ; std::forward<char const *>
  00056	83 c4 04	 add	 esp, 4
  00059	50		 push	 eax
  0005a	8b 4d f4	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  0005d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005f	52		 push	 edx
  00060	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00063	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@PBD@?$vector@PBDV?$allocator@PBD@std@@@std@@QAEPAPBDQAPBD$$QAPBD@Z ; std::vector<char const *,std::allocator<char const *> >::_Emplace_reallocate<char const *>
  00068	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax
$LN1@emplace_ba:

; 660  : #if _HAS_CXX17
; 661  :         return _Result;
; 662  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 663  :         (void) _Result;
; 664  : #endif // _HAS_CXX17
; 665  :     }

  0006b	83 c4 10	 add	 esp, 16			; 00000010H
  0006e	3b ec		 cmp	 ebp, esp
  00070	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00075	8b e5		 mov	 esp, ebp
  00077	5d		 pop	 ebp
  00078	c2 04 00	 ret	 4
??$emplace_back@PBD@?$vector@PBDV?$allocator@PBD@std@@@std@@QAEX$$QAPBD@Z ENDP ; std::vector<char const *,std::allocator<char const *> >::emplace_back<char const *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\type_traits
;	COMDAT ??$move@AAPBD@std@@YA$$QAPBDAAPBD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAPBD@std@@YA$$QAPBDAAPBD@Z PROC		; std::move<char const * &>, COMDAT

; 1432 : _NODISCARD constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept { // forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1433 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1434 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAPBD@std@@YA$$QAPBDAAPBD@Z ENDP		; std::move<char const * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\thread
;	COMDAT ??$sleep_for@_JU?$ratio@$00$0DOI@@std@@@this_thread@std@@YAXABV?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@1@@Z
_TEXT	SEGMENT
$T1 = -16						; size = 8
$T2 = -8						; size = 8
__Rel_time$ = 8						; size = 4
??$sleep_for@_JU?$ratio@$00$0DOI@@std@@@this_thread@std@@YAXABV?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@1@@Z PROC ; std::this_thread::sleep_for<__int64,std::ratio<1,1000> >, COMDAT

; 169  :     void sleep_for(const chrono::duration<_Rep, _Period>& _Rel_time) { // sleep for duration

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000e	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00011	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00014	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 170  :         sleep_until(chrono::steady_clock::now() + _Rel_time);

  00017	8b 45 08	 mov	 eax, DWORD PTR __Rel_time$[ebp]
  0001a	50		 push	 eax
  0001b	8d 4d f8	 lea	 ecx, DWORD PTR $T2[ebp]
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 ?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ ; std::chrono::steady_clock::now
  00024	83 c4 04	 add	 esp, 4
  00027	50		 push	 eax
  00028	8d 55 f0	 lea	 edx, DWORD PTR $T1[ebp]
  0002b	52		 push	 edx
  0002c	e8 00 00 00 00	 call	 ??$?HUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@_JU?$ratio@$00$0DOI@@2@@chrono@std@@YA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@ABV201@ABV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@@Z ; std::chrono::operator+<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000> >
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 ??$sleep_until@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@this_thread@std@@YAXABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@1@@Z ; std::this_thread::sleep_until<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
  0003a	83 c4 04	 add	 esp, 4

; 171  :     }

  0003d	83 c4 10	 add	 esp, 16			; 00000010H
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
??$sleep_for@_JU?$ratio@$00$0DOI@@std@@@this_thread@std@@YAXABV?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@1@@Z ENDP ; std::this_thread::sleep_for<__int64,std::ratio<1,1000> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\rgy_perf_monitor.cpp
;	COMDAT ??R<lambda_ee86f6c47a1a90e9cd4ba874c2bef330>@@QBEXPAXPAUPROCESS_TIME@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_hThread$ = 8						; size = 4
_time$ = 12						; size = 4
??R<lambda_ee86f6c47a1a90e9cd4ba874c2bef330>@@QBEXPAXPAUPROCESS_TIME@@@Z PROC ; <lambda_ee86f6c47a1a90e9cd4ba874c2bef330>::operator(), COMDAT
; _this$ = ecx

; 879  :     auto getThreadTime = [](HANDLE hThread, PROCESS_TIME *time) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 880  :         GetThreadTimes(hThread, (FILETIME *)&time->creation, (FILETIME *)&time->exit, (FILETIME *)&time->kernel, (FILETIME *)&time->user);

  0000f	8b 45 0c	 mov	 eax, DWORD PTR _time$[ebp]
  00012	83 c0 18	 add	 eax, 24			; 00000018H
  00015	8b f4		 mov	 esi, esp
  00017	50		 push	 eax
  00018	8b 4d 0c	 mov	 ecx, DWORD PTR _time$[ebp]
  0001b	83 c1 10	 add	 ecx, 16			; 00000010H
  0001e	51		 push	 ecx
  0001f	8b 55 0c	 mov	 edx, DWORD PTR _time$[ebp]
  00022	83 c2 08	 add	 edx, 8
  00025	52		 push	 edx
  00026	8b 45 0c	 mov	 eax, DWORD PTR _time$[ebp]
  00029	50		 push	 eax
  0002a	8b 4d 08	 mov	 ecx, DWORD PTR _hThread$[ebp]
  0002d	51		 push	 ecx
  0002e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetThreadTimes@20
  00034	3b f4		 cmp	 esi, esp
  00036	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 881  :     };

  0003b	5e		 pop	 esi
  0003c	83 c4 04	 add	 esp, 4
  0003f	3b ec		 cmp	 ebp, esp
  00041	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c2 08 00	 ret	 8
??R<lambda_ee86f6c47a1a90e9cd4ba874c2bef330>@@QBEXPAXPAUPROCESS_TIME@@@Z ENDP ; <lambda_ee86f6c47a1a90e9cd4ba874c2bef330>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\memory
;	COMDAT ??$?CVEncodeStatus@@$0A@@?$shared_ptr@VEncodeStatus@@@std@@QBEPAVEncodeStatus@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$?CVEncodeStatus@@$0A@@?$shared_ptr@VEncodeStatus@@@std@@QBEPAVEncodeStatus@@XZ PROC ; std::shared_ptr<EncodeStatus>::operator-><EncodeStatus,0>, COMDAT
; _this$ = ecx

; 1204 :     _NODISCARD _Ty2* operator->() const noexcept { // return pointer to resource

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1205 :         return get();

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?get@?$_Ptr_base@VEncodeStatus@@@std@@IBEPAVEncodeStatus@@XZ ; std::_Ptr_base<EncodeStatus>::get

; 1206 :     }

  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??$?CVEncodeStatus@@$0A@@?$shared_ptr@VEncodeStatus@@@std@@QBEPAVEncodeStatus@@XZ ENDP ; std::shared_ptr<EncodeStatus>::operator-><EncodeStatus,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\thread
;	COMDAT ??$?0A6AXPAX@ZPAVCPerfMonitor@@X@thread@std@@QAE@A6AXPAX@Z$$QAPAVCPerfMonitor@@@Z
_TEXT	SEGMENT
__Invoker_proc$ = -32					; size = 4
__Decay_copied$ = -24					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Fx$ = 8						; size = 4
_<_Ax_0>$ = 12						; size = 4
??$?0A6AXPAX@ZPAVCPerfMonitor@@X@thread@std@@QAE@A6AXPAX@Z$$QAPAVCPerfMonitor@@@Z PROC ; std::thread::thread<void (__cdecl&)(void *),CPerfMonitor *,void>, COMDAT
; _this$ = ecx

; 53   :     explicit thread(_Fn&& _Fx, _Args&&... _Ax) { // construct with _Fx(_Ax...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?0A6AXPAX@ZPAVCPerfMonitor@@X@thread@std@@QAE@A6AXPAX@Z$$QAPAVCPerfMonitor@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	56		 push	 esi
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  0001d	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  00020	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00023	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00026	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00029	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002e	33 c5		 xor	 eax, ebp
  00030	50		 push	 eax
  00031	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00034	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003a	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 54   :         using _Tuple                 = tuple<decay_t<_Fn>, decay_t<_Args>...>;
; 55   :         auto _Decay_copied           = _STD make_unique<_Tuple>(_STD forward<_Fn>(_Fx), _STD forward<_Args>(_Ax)...);

  0003d	8b 45 0c	 mov	 eax, DWORD PTR _<_Ax_0>$[ebp]
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 ??$forward@PAVCPerfMonitor@@@std@@YA$$QAPAVCPerfMonitor@@AAPAV1@@Z ; std::forward<CPerfMonitor *>
  00046	83 c4 04	 add	 esp, 4
  00049	50		 push	 eax
  0004a	8b 4d 08	 mov	 ecx, DWORD PTR __Fx$[ebp]
  0004d	51		 push	 ecx
  0004e	e8 00 00 00 00	 call	 ??$forward@A6AXPAX@Z@std@@YAA6AXPAX@ZA6AX0@Z@Z ; std::forward<void (__cdecl&)(void *)>
  00053	83 c4 04	 add	 esp, 4
  00056	50		 push	 eax
  00057	8d 55 e8	 lea	 edx, DWORD PTR __Decay_copied$[ebp]
  0005a	52		 push	 edx
  0005b	e8 00 00 00 00	 call	 ??$make_unique@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@A6AXPAX@ZPAVCPerfMonitor@@$0A@@std@@YA?AV?$unique_ptr@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@2@@0@A6AXPAX@Z$$QAPAVCPerfMonitor@@@Z ; std::make_unique<std::tuple<void (__cdecl*)(void *),CPerfMonitor *>,void (__cdecl&)(void *),CPerfMonitor *,0>
  00060	83 c4 0c	 add	 esp, 12			; 0000000cH
  00063	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 56   :         constexpr auto _Invoker_proc = _Get_invoke<_Tuple>(make_index_sequence<1 + sizeof...(_Args)>{});

  0006a	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR __Invoker_proc$[ebp], OFFSET ??$_Invoke@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@$0A@$00@thread@std@@CGIPAX@Z ; std::thread::_Invoke<std::tuple<void (__cdecl*)(void *),CPerfMonitor *>,0,1>

; 57   : 
; 58   : #pragma warning(push)
; 59   : #pragma warning(disable : 5039) // pointer or reference to potentially throwing function passed to
; 60   :                                 // extern C function under -EHc. Undefined behavior may occur
; 61   :                                 // if this function throws an exception. (/Wall)
; 62   :         _Thr._Hnd =

  00071	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00074	83 c0 04	 add	 eax, 4
  00077	8b f4		 mov	 esi, esp
  00079	50		 push	 eax
  0007a	6a 00		 push	 0
  0007c	8d 4d e8	 lea	 ecx, DWORD PTR __Decay_copied$[ebp]
  0007f	e8 00 00 00 00	 call	 ?get@?$unique_ptr@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@2@@std@@QBEPAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@2@XZ ; std::unique_ptr<std::tuple<void (__cdecl*)(void *),CPerfMonitor *>,std::default_delete<std::tuple<void (__cdecl*)(void *),CPerfMonitor *> > >::get
  00084	50		 push	 eax
  00085	8b 4d e0	 mov	 ecx, DWORD PTR __Invoker_proc$[ebp]
  00088	51		 push	 ecx
  00089	6a 00		 push	 0
  0008b	6a 00		 push	 0
  0008d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___beginthreadex
  00093	83 c4 18	 add	 esp, 24			; 00000018H
  00096	3b f4		 cmp	 esi, esp
  00098	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009d	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  000a0	89 02		 mov	 DWORD PTR [edx], eax

; 63   :             reinterpret_cast<void*>(_CSTD _beginthreadex(nullptr, 0, _Invoker_proc, _Decay_copied.get(), 0, &_Thr._Id));
; 64   : #pragma warning(pop)
; 65   : 
; 66   :         if (_Thr._Hnd) { // ownership transferred to the thread

  000a2	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000a5	83 38 00	 cmp	 DWORD PTR [eax], 0
  000a8	74 0a		 je	 SHORT $LN2@thread

; 67   :             (void) _Decay_copied.release();

  000aa	8d 4d e8	 lea	 ecx, DWORD PTR __Decay_copied$[ebp]
  000ad	e8 00 00 00 00	 call	 ?release@?$unique_ptr@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@2@@std@@QAEPAV?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@2@XZ ; std::unique_ptr<std::tuple<void (__cdecl*)(void *),CPerfMonitor *>,std::default_delete<std::tuple<void (__cdecl*)(void *),CPerfMonitor *> > >::release

; 68   :         } else { // failed to start thread

  000b2	eb 11		 jmp	 SHORT $LN3@thread
$LN2@thread:

; 69   :             _Thr._Id = 0;

  000b4	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000b7	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 70   :             _Throw_Cpp_error(_RESOURCE_UNAVAILABLE_TRY_AGAIN);

  000be	6a 06		 push	 6
  000c0	e8 00 00 00 00	 call	 ?_Throw_Cpp_error@std@@YAXH@Z ; std::_Throw_Cpp_error
$LN3@thread:

; 71   :         }
; 72   :     }

  000c5	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000cc	8d 4d e8	 lea	 ecx, DWORD PTR __Decay_copied$[ebp]
  000cf	e8 00 00 00 00	 call	 ??1?$unique_ptr@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::tuple<void (__cdecl*)(void *),CPerfMonitor *>,std::default_delete<std::tuple<void (__cdecl*)(void *),CPerfMonitor *> > >::~unique_ptr<std::tuple<void (__cdecl*)(void *),CPerfMonitor *>,std::default_delete<std::tuple<void (__cdecl*)(void *),CPerfMonitor *> > >
  000d4	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
$LN4@thread:
  000d7	52		 push	 edx
  000d8	8b cd		 mov	 ecx, ebp
  000da	50		 push	 eax
  000db	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN9@thread
  000e1	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000e6	58		 pop	 eax
  000e7	5a		 pop	 edx
  000e8	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000eb	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000f2	59		 pop	 ecx
  000f3	5e		 pop	 esi
  000f4	83 c4 20	 add	 esp, 32			; 00000020H
  000f7	3b ec		 cmp	 ebp, esp
  000f9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000fe	8b e5		 mov	 esp, ebp
  00100	5d		 pop	 ebp
  00101	c2 08 00	 ret	 8
$LN9@thread:
  00104	01 00 00 00	 DD	 1
  00108	00 00 00 00	 DD	 $LN8@thread
$LN8@thread:
  0010c	e8 ff ff ff	 DD	 -24			; ffffffe8H
  00110	04 00 00 00	 DD	 4
  00114	00 00 00 00	 DD	 $LN6@thread
$LN6@thread:
  00118	5f		 DB	 95			; 0000005fH
  00119	44		 DB	 68			; 00000044H
  0011a	65		 DB	 101			; 00000065H
  0011b	63		 DB	 99			; 00000063H
  0011c	61		 DB	 97			; 00000061H
  0011d	79		 DB	 121			; 00000079H
  0011e	5f		 DB	 95			; 0000005fH
  0011f	63		 DB	 99			; 00000063H
  00120	6f		 DB	 111			; 0000006fH
  00121	70		 DB	 112			; 00000070H
  00122	69		 DB	 105			; 00000069H
  00123	65		 DB	 101			; 00000065H
  00124	64		 DB	 100			; 00000064H
  00125	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?0A6AXPAX@ZPAVCPerfMonitor@@X@thread@std@@QAE@A6AXPAX@Z$$QAPAVCPerfMonitor@@@Z$0:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR __Decay_copied$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$unique_ptr@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@U?$default_delete@V?$tuple@P6AXPAX@ZPAVCPerfMonitor@@@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::tuple<void (__cdecl*)(void *),CPerfMonitor *>,std::default_delete<std::tuple<void (__cdecl*)(void *),CPerfMonitor *> > >::~unique_ptr<std::tuple<void (__cdecl*)(void *),CPerfMonitor *>,std::default_delete<std::tuple<void (__cdecl*)(void *),CPerfMonitor *> > >
__ehhandler$??$?0A6AXPAX@ZPAVCPerfMonitor@@X@thread@std@@QAE@A6AXPAX@Z$$QAPAVCPerfMonitor@@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?0A6AXPAX@ZPAVCPerfMonitor@@X@thread@std@@QAE@A6AXPAX@Z$$QAPAVCPerfMonitor@@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?0A6AXPAX@ZPAVCPerfMonitor@@X@thread@std@@QAE@A6AXPAX@Z$$QAPAVCPerfMonitor@@@Z ENDP ; std::thread::thread<void (__cdecl&)(void *),CPerfMonitor *,void>
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@PBD@std@@V?$_Vector_val@U?$_Simple_types@PBD@std@@@2@$00@std@@QBEABV?$allocator@PBD@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@PBD@std@@V?$_Vector_val@U?$_Simple_types@PBD@std@@@2@$00@std@@QBEABV?$allocator@PBD@2@XZ PROC ; std::_Compressed_pair<std::allocator<char const *>,std::_Vector_val<std::_Simple_types<char const *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1424 :     const _Ty1& _Get_first() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1425 :         return *this;

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1426 :     }

  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@PBD@std@@V?$_Vector_val@U?$_Simple_types@PBD@std@@@2@$00@std@@QBEABV?$allocator@PBD@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char const *>,std::_Vector_val<std::_Simple_types<char const *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@PBD@std@@V?$_Vector_val@U?$_Simple_types@PBD@std@@@2@$00@std@@QAEAAV?$allocator@PBD@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@PBD@std@@V?$_Vector_val@U?$_Simple_types@PBD@std@@@2@$00@std@@QAEAAV?$allocator@PBD@2@XZ PROC ; std::_Compressed_pair<std::allocator<char const *>,std::_Vector_val<std::_Simple_types<char const *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1420 :     _Ty1& _Get_first() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1421 :         return *this;

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1422 :     }

  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@PBD@std@@V?$_Vector_val@U?$_Simple_types@PBD@std@@@2@$00@std@@QAEAAV?$allocator@PBD@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char const *>,std::_Vector_val<std::_Simple_types<char const *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PBD@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Vector_val@U?$_Simple_types@PBD@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<char const *> >::_Vector_val<std::_Simple_types<char const *> >, COMDAT
; _this$ = ecx

; 314  :     _Vector_val() : _Myfirst(), _Mylast(), _Myend() { // initialize values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12
  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  0002a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002d	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0

; 315  :     }

  00034	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00037	83 c4 04	 add	 esp, 4
  0003a	3b ec		 cmp	 ebp, esp
  0003c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@PBD@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<char const *> >::_Vector_val<std::_Simple_types<char const *> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\vector
;	COMDAT ?_Getal@?$vector@PBDV?$allocator@PBD@std@@@std@@ABEABV?$allocator@PBD@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$vector@PBDV?$allocator@PBD@std@@@std@@ABEABV?$allocator@PBD@2@XZ PROC ; std::vector<char const *,std::allocator<char const *> >::_Getal, COMDAT
; _this$ = ecx

; 1692 :     const _Alty& _Getal() const noexcept { // return const reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1693 :         return _Mypair._Get_first();

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@PBD@std@@V?$_Vector_val@U?$_Simple_types@PBD@std@@@2@$00@std@@QBEABV?$allocator@PBD@2@XZ ; std::_Compressed_pair<std::allocator<char const *>,std::_Vector_val<std::_Simple_types<char const *> >,1>::_Get_first

; 1694 :     }

  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
?_Getal@?$vector@PBDV?$allocator@PBD@std@@@std@@ABEABV?$allocator@PBD@2@XZ ENDP ; std::vector<char const *,std::allocator<char const *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\vector
;	COMDAT ?_Getal@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEAAV?$allocator@PBD@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEAAV?$allocator@PBD@2@XZ PROC ; std::vector<char const *,std::allocator<char const *> >::_Getal, COMDAT
; _this$ = ecx

; 1688 :     _Alty& _Getal() noexcept { // return reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1689 :         return _Mypair._Get_first();

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@PBD@std@@V?$_Vector_val@U?$_Simple_types@PBD@std@@@2@$00@std@@QAEAAV?$allocator@PBD@2@XZ ; std::_Compressed_pair<std::allocator<char const *>,std::_Vector_val<std::_Simple_types<char const *> >,1>::_Get_first

; 1690 :     }

  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
?_Getal@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEAAV?$allocator@PBD@2@XZ ENDP ; std::vector<char const *,std::allocator<char const *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\vector
;	COMDAT ?_Orphan_range@?$vector@PBDV?$allocator@PBD@std@@@std@@ABEXPAPBD0@Z
_TEXT	SEGMENT
__Pnextptr$2 = -36					; size = 4
__Pnext$ = -32						; size = 4
__Lock$ = -24						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Orphan_range@?$vector@PBDV?$allocator@PBD@std@@@std@@ABEXPAPBD0@Z PROC ; std::vector<char const *,std::allocator<char const *> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1668 :     void _Orphan_range(pointer _First, pointer _Last) const { // orphan iterators within specified (inclusive) range

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Orphan_range@?$vector@PBDV?$allocator@PBD@std@@@std@@ABEXPAPBD0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	56		 push	 esi
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	89 45 dc	 mov	 DWORD PTR [ebp-36], eax
  0001d	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  00020	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  00023	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00026	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00029	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0002c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00031	33 c5		 xor	 eax, ebp
  00033	50		 push	 eax
  00034	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00037	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003d	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1669 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1670 :         _Lockit _Lock(_LOCK_DEBUG);

  00040	8b f4		 mov	 esi, esp
  00042	6a 03		 push	 3
  00044	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
  0004d	3b f4		 cmp	 esi, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00054	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1671 : 
; 1672 :         _Iterator_base12** _Pnext = &_Mypair._Myval2._Myproxy->_Myfirstiter;

  0005b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00060	83 c1 04	 add	 ecx, 4
  00063	89 4d e0	 mov	 DWORD PTR __Pnext$[ebp], ecx
$LN2@Orphan_ran:

; 1673 :         while (*_Pnext) {

  00066	8b 55 e0	 mov	 edx, DWORD PTR __Pnext$[ebp]
  00069	83 3a 00	 cmp	 DWORD PTR [edx], 0
  0006c	74 42		 je	 SHORT $LN3@Orphan_ran

; 1674 :             const auto _Pnextptr = static_cast<const_iterator&>(**_Pnext)._Ptr;

  0006e	8b 45 e0	 mov	 eax, DWORD PTR __Pnext$[ebp]
  00071	8b 08		 mov	 ecx, DWORD PTR [eax]
  00073	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00076	89 55 dc	 mov	 DWORD PTR __Pnextptr$2[ebp], edx

; 1675 :             if (_Pnextptr < _First || _Last < _Pnextptr) { // skip the iterator

  00079	8b 45 dc	 mov	 eax, DWORD PTR __Pnextptr$2[ebp]
  0007c	3b 45 08	 cmp	 eax, DWORD PTR __First$[ebp]
  0007f	72 08		 jb	 SHORT $LN6@Orphan_ran
  00081	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00084	3b 4d dc	 cmp	 ecx, DWORD PTR __Pnextptr$2[ebp]
  00087	73 0d		 jae	 SHORT $LN4@Orphan_ran
$LN6@Orphan_ran:

; 1676 :                 _Pnext = &(*_Pnext)->_Mynextiter;

  00089	8b 55 e0	 mov	 edx, DWORD PTR __Pnext$[ebp]
  0008c	8b 02		 mov	 eax, DWORD PTR [edx]
  0008e	83 c0 04	 add	 eax, 4
  00091	89 45 e0	 mov	 DWORD PTR __Pnext$[ebp], eax

; 1677 :             } else { // orphan the iterator

  00094	eb 18		 jmp	 SHORT $LN5@Orphan_ran
$LN4@Orphan_ran:

; 1678 :                 (*_Pnext)->_Myproxy = nullptr;

  00096	8b 4d e0	 mov	 ecx, DWORD PTR __Pnext$[ebp]
  00099	8b 11		 mov	 edx, DWORD PTR [ecx]
  0009b	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 1679 :                 *_Pnext             = (*_Pnext)->_Mynextiter;

  000a1	8b 45 e0	 mov	 eax, DWORD PTR __Pnext$[ebp]
  000a4	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a6	8b 55 e0	 mov	 edx, DWORD PTR __Pnext$[ebp]
  000a9	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  000ac	89 02		 mov	 DWORD PTR [edx], eax
$LN5@Orphan_ran:

; 1680 :             }
; 1681 :         }

  000ae	eb b6		 jmp	 SHORT $LN2@Orphan_ran
$LN3@Orphan_ran:

; 1682 : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 2 vvv
; 1683 :         (void) _First;
; 1684 :         (void) _Last;
; 1685 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1686 :     }

  000b0	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000b7	8b f4		 mov	 esi, esp
  000b9	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$[ebp]
  000bc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  000c2	3b f4		 cmp	 esi, esp
  000c4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c9	52		 push	 edx
  000ca	8b cd		 mov	 ecx, ebp
  000cc	50		 push	 eax
  000cd	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN12@Orphan_ran
  000d3	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000d8	58		 pop	 eax
  000d9	5a		 pop	 edx
  000da	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000dd	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000e4	59		 pop	 ecx
  000e5	5e		 pop	 esi
  000e6	83 c4 24	 add	 esp, 36			; 00000024H
  000e9	3b ec		 cmp	 ebp, esp
  000eb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f0	8b e5		 mov	 esp, ebp
  000f2	5d		 pop	 ebp
  000f3	c2 08 00	 ret	 8
  000f6	66 90		 npad	 2
$LN12@Orphan_ran:
  000f8	01 00 00 00	 DD	 1
  000fc	00 00 00 00	 DD	 $LN11@Orphan_ran
$LN11@Orphan_ran:
  00100	e8 ff ff ff	 DD	 -24			; ffffffe8H
  00104	04 00 00 00	 DD	 4
  00108	00 00 00 00	 DD	 $LN9@Orphan_ran
$LN9@Orphan_ran:
  0010c	5f		 DB	 95			; 0000005fH
  0010d	4c		 DB	 76			; 0000004cH
  0010e	6f		 DB	 111			; 0000006fH
  0010f	63		 DB	 99			; 00000063H
  00110	6b		 DB	 107			; 0000006bH
  00111	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Orphan_range@?$vector@PBDV?$allocator@PBD@std@@@std@@ABEXPAPBD0@Z$0:
  00000	8b f4		 mov	 esi, esp
  00002	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  0000b	3b f4		 cmp	 esi, esp
  0000d	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
__ehhandler$?_Orphan_range@?$vector@PBDV?$allocator@PBD@std@@@std@@ABEXPAPBD0@Z:
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00019	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Orphan_range@?$vector@PBDV?$allocator@PBD@std@@@std@@ABEXPAPBD0@Z
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Orphan_range@?$vector@PBDV?$allocator@PBD@std@@@std@@ABEXPAPBD0@Z ENDP ; std::vector<char const *,std::allocator<char const *> >::_Orphan_range
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\vector
;	COMDAT ?_Xlength@?$vector@PBDV?$allocator@PBD@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PBDV?$allocator@PBD@std@@@std@@CAXXZ PROC ; std::vector<char const *,std::allocator<char const *> >::_Xlength, COMDAT

; 1660 :     [[noreturn]] static void _Xlength() { // report a length_error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1661 :         _Xlength_error("vector<T> too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1662 :     }

  0000d	3b ec		 cmp	 ebp, esp
  0000f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Xlength@?$vector@PBDV?$allocator@PBD@std@@@std@@CAXXZ ENDP ; std::vector<char const *,std::allocator<char const *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\vector
;	COMDAT ?_Tidy@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEXXZ
_TEXT	SEGMENT
__Myend$ = -32						; size = 4
__Mylast$ = -28						; size = 4
__Myfirst$ = -24					; size = 4
__My_data$ = -20					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?_Tidy@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEXXZ PROC ; std::vector<char const *,std::allocator<char const *> >::_Tidy, COMDAT
; _this$ = ecx

; 1642 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Tidy@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  0001c	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  0001f	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00022	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00025	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002d	33 c5		 xor	 eax, ebp
  0002f	50		 push	 eax
  00030	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00033	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00039	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1643 :         auto& _My_data    = _Mypair._Myval2;

  0003c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0003f	89 45 ec	 mov	 DWORD PTR __My_data$[ebp], eax

; 1644 :         pointer& _Myfirst = _My_data._Myfirst;

  00042	8b 4d ec	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00045	83 c1 04	 add	 ecx, 4
  00048	89 4d e8	 mov	 DWORD PTR __Myfirst$[ebp], ecx

; 1645 :         pointer& _Mylast  = _My_data._Mylast;

  0004b	8b 55 ec	 mov	 edx, DWORD PTR __My_data$[ebp]
  0004e	83 c2 08	 add	 edx, 8
  00051	89 55 e4	 mov	 DWORD PTR __Mylast$[ebp], edx

; 1646 :         pointer& _Myend   = _My_data._Myend;

  00054	8b 45 ec	 mov	 eax, DWORD PTR __My_data$[ebp]
  00057	83 c0 0c	 add	 eax, 12			; 0000000cH
  0005a	89 45 e0	 mov	 DWORD PTR __Myend$[ebp], eax

; 1647 : 
; 1648 :         _My_data._Orphan_all();

  0005d	8b 4d ec	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00060	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 1649 : 
; 1650 :         if (_Myfirst) { // destroy and deallocate old array

  00065	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00068	83 39 00	 cmp	 DWORD PTR [ecx], 0
  0006b	74 52		 je	 SHORT $LN1@Tidy

; 1651 :             _Destroy(_Myfirst, _Mylast);

  0006d	8b 55 e4	 mov	 edx, DWORD PTR __Mylast$[ebp]
  00070	8b 02		 mov	 eax, DWORD PTR [edx]
  00072	50		 push	 eax
  00073	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00076	8b 11		 mov	 edx, DWORD PTR [ecx]
  00078	52		 push	 edx
  00079	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0007c	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEXPAPBD0@Z ; std::vector<char const *,std::allocator<char const *> >::_Destroy

; 1652 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00081	8b 45 e0	 mov	 eax, DWORD PTR __Myend$[ebp]
  00084	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00087	8b 10		 mov	 edx, DWORD PTR [eax]
  00089	2b 11		 sub	 edx, DWORD PTR [ecx]
  0008b	c1 fa 02	 sar	 edx, 2
  0008e	52		 push	 edx
  0008f	8b 45 e8	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00092	8b 08		 mov	 ecx, DWORD PTR [eax]
  00094	51		 push	 ecx
  00095	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00098	e8 00 00 00 00	 call	 ?_Getal@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEAAV?$allocator@PBD@2@XZ ; std::vector<char const *,std::allocator<char const *> >::_Getal
  0009d	8b c8		 mov	 ecx, eax
  0009f	e8 00 00 00 00	 call	 ?deallocate@?$allocator@PBD@std@@QAEXQAPBDI@Z ; std::allocator<char const *>::deallocate

; 1653 : 
; 1654 :             _Myfirst = pointer();

  000a4	8b 55 e8	 mov	 edx, DWORD PTR __Myfirst$[ebp]
  000a7	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 1655 :             _Mylast  = pointer();

  000ad	8b 45 e4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  000b0	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1656 :             _Myend   = pointer();

  000b6	8b 4d e0	 mov	 ecx, DWORD PTR __Myend$[ebp]
  000b9	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
$LN1@Tidy:

; 1657 :         }
; 1658 :     }

  000bf	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000c9	59		 pop	 ecx
  000ca	83 c4 20	 add	 esp, 32			; 00000020H
  000cd	3b ec		 cmp	 ebp, esp
  000cf	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d4	8b e5		 mov	 esp, ebp
  000d6	5d		 pop	 ebp
  000d7	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Tidy@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEXXZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Tidy@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEXXZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Tidy@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEXXZ ENDP ; std::vector<char const *,std::allocator<char const *> >::_Tidy
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\vector
;	COMDAT ?_Change_array@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEXQAPBDII@Z
_TEXT	SEGMENT
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
__Myfirst$ = -12					; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEXQAPBDII@Z PROC ; std::vector<char const *,std::allocator<char const *> >::_Change_array, COMDAT
; _this$ = ecx

; 1623 :     void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0000e	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00011	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00014	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00017	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  0001a	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1624 :         // orphan all iterators, discard old array, acquire new array
; 1625 :         auto& _My_data    = _Mypair._Myval2;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1626 :         pointer& _Myfirst = _My_data._Myfirst;

  00023	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00026	83 c1 04	 add	 ecx, 4
  00029	89 4d f4	 mov	 DWORD PTR __Myfirst$[ebp], ecx

; 1627 :         pointer& _Mylast  = _My_data._Mylast;

  0002c	8b 55 f8	 mov	 edx, DWORD PTR __My_data$[ebp]
  0002f	83 c2 08	 add	 edx, 8
  00032	89 55 f0	 mov	 DWORD PTR __Mylast$[ebp], edx

; 1628 :         pointer& _Myend   = _My_data._Myend;

  00035	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00038	83 c0 0c	 add	 eax, 12			; 0000000cH
  0003b	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1629 : 
; 1630 :         _My_data._Orphan_all();

  0003e	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00041	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 1631 : 
; 1632 :         if (_Myfirst) { // destroy and deallocate old array

  00046	8b 4d f4	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00049	83 39 00	 cmp	 DWORD PTR [ecx], 0
  0004c	74 37		 je	 SHORT $LN2@Change_arr

; 1633 :             _Destroy(_Myfirst, _Mylast);

  0004e	8b 55 f0	 mov	 edx, DWORD PTR __Mylast$[ebp]
  00051	8b 02		 mov	 eax, DWORD PTR [edx]
  00053	50		 push	 eax
  00054	8b 4d f4	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00057	8b 11		 mov	 edx, DWORD PTR [ecx]
  00059	52		 push	 edx
  0005a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEXPAPBD0@Z ; std::vector<char const *,std::allocator<char const *> >::_Destroy

; 1634 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00062	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  00065	8b 4d f4	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00068	8b 10		 mov	 edx, DWORD PTR [eax]
  0006a	2b 11		 sub	 edx, DWORD PTR [ecx]
  0006c	c1 fa 02	 sar	 edx, 2
  0006f	52		 push	 edx
  00070	8b 45 f4	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00073	8b 08		 mov	 ecx, DWORD PTR [eax]
  00075	51		 push	 ecx
  00076	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00079	e8 00 00 00 00	 call	 ?_Getal@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEAAV?$allocator@PBD@2@XZ ; std::vector<char const *,std::allocator<char const *> >::_Getal
  0007e	8b c8		 mov	 ecx, eax
  00080	e8 00 00 00 00	 call	 ?deallocate@?$allocator@PBD@std@@QAEXQAPBDI@Z ; std::allocator<char const *>::deallocate
$LN2@Change_arr:

; 1635 :         }
; 1636 : 
; 1637 :         _Myfirst = _Newvec;

  00085	8b 55 f4	 mov	 edx, DWORD PTR __Myfirst$[ebp]
  00088	8b 45 08	 mov	 eax, DWORD PTR __Newvec$[ebp]
  0008b	89 02		 mov	 DWORD PTR [edx], eax

; 1638 :         _Mylast  = _Newvec + _Newsize;

  0008d	8b 4d 0c	 mov	 ecx, DWORD PTR __Newsize$[ebp]
  00090	8b 55 08	 mov	 edx, DWORD PTR __Newvec$[ebp]
  00093	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  00096	8b 4d f0	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  00099	89 01		 mov	 DWORD PTR [ecx], eax

; 1639 :         _Myend   = _Newvec + _Newcapacity;

  0009b	8b 55 10	 mov	 edx, DWORD PTR __Newcapacity$[ebp]
  0009e	8b 45 08	 mov	 eax, DWORD PTR __Newvec$[ebp]
  000a1	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  000a4	8b 55 ec	 mov	 edx, DWORD PTR __Myend$[ebp]
  000a7	89 0a		 mov	 DWORD PTR [edx], ecx

; 1640 :     }

  000a9	83 c4 14	 add	 esp, 20			; 00000014H
  000ac	3b ec		 cmp	 ebp, esp
  000ae	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b3	8b e5		 mov	 esp, ebp
  000b5	5d		 pop	 ebp
  000b6	c2 0c 00	 ret	 12			; 0000000cH
?_Change_array@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEXQAPBDII@Z ENDP ; std::vector<char const *,std::allocator<char const *> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\vector
;	COMDAT ?_Calculate_growth@?$vector@PBDV?$allocator@PBD@std@@@std@@ABEII@Z
_TEXT	SEGMENT
__Geometric$ = -12					; size = 4
__Oldcapacity$ = -8					; size = 4
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@PBDV?$allocator@PBD@std@@@std@@ABEII@Z PROC ; std::vector<char const *,std::allocator<char const *> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1571 :     size_type _Calculate_growth(const size_type _Newsize) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1572 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1573 :         const size_type _Oldcapacity = capacity();

  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	e8 00 00 00 00	 call	 ?capacity@?$vector@PBDV?$allocator@PBD@std@@@std@@QBEIXZ ; std::vector<char const *,std::allocator<char const *> >::capacity
  00026	89 45 f8	 mov	 DWORD PTR __Oldcapacity$[ebp], eax

; 1574 : 
; 1575 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ?max_size@?$vector@PBDV?$allocator@PBD@std@@@std@@QBEIXZ ; std::vector<char const *,std::allocator<char const *> >::max_size
  00031	8b 4d f8	 mov	 ecx, DWORD PTR __Oldcapacity$[ebp]
  00034	d1 e9		 shr	 ecx, 1
  00036	2b c1		 sub	 eax, ecx
  00038	39 45 f8	 cmp	 DWORD PTR __Oldcapacity$[ebp], eax
  0003b	76 05		 jbe	 SHORT $LN2@Calculate_

; 1576 :             return _Newsize; // geometric growth would overflow

  0003d	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00040	eb 1b		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1577 :         }
; 1578 : 
; 1579 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00042	8b 55 f8	 mov	 edx, DWORD PTR __Oldcapacity$[ebp]
  00045	d1 ea		 shr	 edx, 1
  00047	03 55 f8	 add	 edx, DWORD PTR __Oldcapacity$[ebp]
  0004a	89 55 f4	 mov	 DWORD PTR __Geometric$[ebp], edx

; 1580 : 
; 1581 :         if (_Geometric < _Newsize) {

  0004d	8b 45 f4	 mov	 eax, DWORD PTR __Geometric$[ebp]
  00050	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  00053	73 05		 jae	 SHORT $LN3@Calculate_

; 1582 :             return _Newsize; // geometric growth would be insufficient

  00055	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00058	eb 03		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1583 :         }
; 1584 : 
; 1585 :         return _Geometric; // geometric growth is sufficient

  0005a	8b 45 f4	 mov	 eax, DWORD PTR __Geometric$[ebp]
$LN1@Calculate_:

; 1586 :     }

  0005d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00060	3b ec		 cmp	 ebp, esp
  00062	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@PBDV?$allocator@PBD@std@@@std@@ABEII@Z ENDP ; std::vector<char const *,std::allocator<char const *> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\vector
;	COMDAT ?_Destroy@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEXPAPBD0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEXPAPBD0@Z PROC ; std::vector<char const *,std::allocator<char const *> >::_Destroy, COMDAT
; _this$ = ecx

; 1567 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1568 :         _Destroy_range(_First, _Last, _Getal());

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Getal@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEAAV?$allocator@PBD@2@XZ ; std::vector<char const *,std::allocator<char const *> >::_Getal
  00016	50		 push	 eax
  00017	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0001a	50		 push	 eax
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PBD@std@@@std@@YAXPAPBDQAPBDAAV?$allocator@PBD@0@@Z ; std::_Destroy_range<std::allocator<char const *> >
  00024	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1569 :     }

  00027	83 c4 04	 add	 esp, 4
  0002a	3b ec		 cmp	 ebp, esp
  0002c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c2 08 00	 ret	 8
?_Destroy@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEXPAPBD0@Z ENDP ; std::vector<char const *,std::allocator<char const *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEXPAPBD00@Z
_TEXT	SEGMENT
$T1 = -5						; size = 1
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEXPAPBD00@Z PROC ; std::vector<char const *,std::allocator<char const *> >::_Umove_if_noexcept, COMDAT
; _this$ = ecx

; 1561 :     void _Umove_if_noexcept(pointer _First, pointer _Last, pointer _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1562 :         // move_if_noexcept [_First, _Last) to raw _Dest, using allocator
; 1563 :         _Umove_if_noexcept1(_First, _Last, _Dest,

  00017	33 c0		 xor	 eax, eax
  00019	88 45 fb	 mov	 BYTE PTR $T1[ebp], al
  0001c	0f b6 4d fb	 movzx	 ecx, BYTE PTR $T1[ebp]
  00020	51		 push	 ecx
  00021	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00024	52		 push	 edx
  00025	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00028	50		 push	 eax
  00029	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0002c	51		 push	 ecx
  0002d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ?_Umove_if_noexcept1@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEXPAPBD00U?$integral_constant@_N$00@2@@Z ; std::vector<char const *,std::allocator<char const *> >::_Umove_if_noexcept1

; 1564 :             bool_constant<disjunction_v<is_nothrow_move_constructible<_Ty>, negation<is_copy_constructible<_Ty>>>>{});
; 1565 :     }

  00035	83 c4 08	 add	 esp, 8
  00038	3b ec		 cmp	 ebp, esp
  0003a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 0c 00	 ret	 12			; 0000000cH
?_Umove_if_noexcept@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEXPAPBD00@Z ENDP ; std::vector<char const *,std::allocator<char const *> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEXPAPBD00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEXPAPBD00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<char const *,std::allocator<char const *> >::_Umove_if_noexcept1, COMDAT
; _this$ = ecx

; 1551 :     void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest, true_type) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1552 :         // move [_First, _Last) to raw _Dest, using allocator
; 1553 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Getal@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEAAV?$allocator@PBD@2@XZ ; std::vector<char const *,std::allocator<char const *> >::_Getal
  00016	50		 push	 eax
  00017	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0001a	50		 push	 eax
  0001b	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0001e	51		 push	 ecx
  0001f	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00022	52		 push	 edx
  00023	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPBDV?$allocator@PBD@std@@@std@@YAPAPBDQAPBD0PAPBDAAV?$allocator@PBD@0@@Z ; std::_Uninitialized_move<char const * *,std::allocator<char const *> >
  00028	83 c4 10	 add	 esp, 16			; 00000010H

; 1554 :     }

  0002b	83 c4 04	 add	 esp, 4
  0002e	3b ec		 cmp	 ebp, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 10 00	 ret	 16			; 00000010H
?_Umove_if_noexcept1@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEXPAPBD00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<char const *,std::allocator<char const *> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\vector
;	COMDAT ?_Umove@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEPAPBDPAPBD00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEPAPBDPAPBD00@Z PROC ; std::vector<char const *,std::allocator<char const *> >::_Umove, COMDAT
; _this$ = ecx

; 1547 :     pointer _Umove(pointer _First, pointer _Last, pointer _Dest) { // move [_First, _Last) to raw _Dest, using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1548 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Getal@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEAAV?$allocator@PBD@2@XZ ; std::vector<char const *,std::allocator<char const *> >::_Getal
  00016	50		 push	 eax
  00017	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0001a	50		 push	 eax
  0001b	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0001e	51		 push	 ecx
  0001f	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00022	52		 push	 edx
  00023	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPBDV?$allocator@PBD@std@@@std@@YAPAPBDQAPBD0PAPBDAAV?$allocator@PBD@0@@Z ; std::_Uninitialized_move<char const * *,std::allocator<char const *> >
  00028	83 c4 10	 add	 esp, 16			; 00000010H

; 1549 :     }

  0002b	83 c4 04	 add	 esp, 4
  0002e	3b ec		 cmp	 ebp, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 0c 00	 ret	 12			; 0000000cH
?_Umove@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEPAPBDPAPBD00@Z ENDP ; std::vector<char const *,std::allocator<char const *> >::_Umove
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\vector
;	COMDAT ?capacity@?$vector@PBDV?$allocator@PBD@std@@@std@@QBEIXZ
_TEXT	SEGMENT
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@PBDV?$allocator@PBD@std@@@std@@QBEIXZ PROC ; std::vector<char const *,std::allocator<char const *> >::capacity, COMDAT
; _this$ = ecx

; 1446 :     _NODISCARD size_type capacity() const noexcept { // return current length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1447 :         auto& _My_data = _Mypair._Myval2;

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1448 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0001d	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00020	8b 55 f8	 mov	 edx, DWORD PTR __My_data$[ebp]
  00023	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00026	2b 42 04	 sub	 eax, DWORD PTR [edx+4]
  00029	c1 f8 02	 sar	 eax, 2

; 1449 :     }

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
?capacity@?$vector@PBDV?$allocator@PBD@std@@@std@@QBEIXZ ENDP ; std::vector<char const *,std::allocator<char const *> >::capacity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\vector
;	COMDAT ?max_size@?$vector@PBDV?$allocator@PBD@std@@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$vector@PBDV?$allocator@PBD@std@@@std@@QBEIXZ PROC ; std::vector<char const *,std::allocator<char const *> >::max_size, COMDAT
; _this$ = ecx

; 1441 :     _NODISCARD size_type max_size() const noexcept { // return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1442 :         return _Min_value(

  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	e8 00 00 00 00	 call	 ?_Getal@?$vector@PBDV?$allocator@PBD@std@@@std@@ABEABV?$allocator@PBD@2@XZ ; std::vector<char const *,std::allocator<char const *> >::_Getal
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ?max_size@?$_Default_allocator_traits@V?$allocator@PBD@std@@@std@@SAIABV?$allocator@PBD@2@@Z ; std::_Default_allocator_traits<std::allocator<char const *> >::max_size
  0002c	83 c4 04	 add	 esp, 4
  0002f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
  00032	e8 00 00 00 00	 call	 ?max@?$numeric_limits@H@std@@SAHXZ ; std::numeric_limits<int>::max
  00037	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
  0003a	8d 45 f8	 lea	 eax, DWORD PTR $T2[ebp]
  0003d	50		 push	 eax
  0003e	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00041	51		 push	 ecx
  00042	e8 00 00 00 00	 call	 ??$_Min_value@I@std@@YAABIABI0@Z ; std::_Min_value<unsigned int>
  00047	83 c4 08	 add	 esp, 8
  0004a	8b 00		 mov	 eax, DWORD PTR [eax]

; 1443 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1444 :     }

  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004f	3b ec		 cmp	 ebp, esp
  00051	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
?max_size@?$vector@PBDV?$allocator@PBD@std@@@std@@QBEIXZ ENDP ; std::vector<char const *,std::allocator<char const *> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\vector
;	COMDAT ?push_back@?$vector@PBDV?$allocator@PBD@std@@@std@@QAEX$$QAPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@PBDV?$allocator@PBD@std@@@std@@QAEX$$QAPBD@Z PROC ; std::vector<char const *,std::allocator<char const *> >::push_back, COMDAT
; _this$ = ecx

; 671  :     void push_back(_Ty&& _Val) { // insert by moving into element at end, provide strong guarantee

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 672  :         emplace_back(_STD move(_Val));

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$move@AAPBD@std@@YA$$QAPBDAAPBD@Z ; std::move<char const * &>
  00017	83 c4 04	 add	 esp, 4
  0001a	50		 push	 eax
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e8 00 00 00 00	 call	 ??$emplace_back@PBD@?$vector@PBDV?$allocator@PBD@std@@@std@@QAEX$$QAPBD@Z ; std::vector<char const *,std::allocator<char const *> >::emplace_back<char const *>

; 673  :     }

  00023	83 c4 04	 add	 esp, 4
  00026	3b ec		 cmp	 ebp, esp
  00028	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
?push_back@?$vector@PBDV?$allocator@PBD@std@@@std@@QAEX$$QAPBD@Z ENDP ; std::vector<char const *,std::allocator<char const *> >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\vector
;	COMDAT ?push_back@?$vector@PBDV?$allocator@PBD@std@@@std@@QAEXABQBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@PBDV?$allocator@PBD@std@@@std@@QAEXABQBD@Z PROC ; std::vector<char const *,std::allocator<char const *> >::push_back, COMDAT
; _this$ = ecx

; 667  :     void push_back(const _Ty& _Val) { // insert element at end, provide strong guarantee

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 668  :         emplace_back(_Val);

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ??$emplace_back@ABQBD@?$vector@PBDV?$allocator@PBD@std@@@std@@QAEXABQBD@Z ; std::vector<char const *,std::allocator<char const *> >::emplace_back<char const * const &>

; 669  :     }

  0001a	83 c4 04	 add	 esp, 4
  0001d	3b ec		 cmp	 ebp, esp
  0001f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?push_back@?$vector@PBDV?$allocator@PBD@std@@@std@@QAEXABQBD@Z ENDP ; std::vector<char const *,std::allocator<char const *> >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\vector
;	COMDAT ??1?$vector@PBDV?$allocator@PBD@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T2 = -36						; size = 4
_$S1$ = -25						; size = 1
__Alproxy$ = -20					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@PBDV?$allocator@PBD@std@@@std@@QAE@XZ PROC	; std::vector<char const *,std::allocator<char const *> >::~vector<char const *,std::allocator<char const *> >, COMDAT
; _this$ = ecx

; 623  :     ~vector() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$vector@PBDV?$allocator@PBD@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	89 45 dc	 mov	 DWORD PTR [ebp-36], eax
  0001c	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  0001f	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  00022	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00025	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00028	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	50		 push	 eax
  00033	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00036	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003c	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 624  :         _Tidy();

  0003f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEXXZ ; std::vector<char const *,std::allocator<char const *> >::_Tidy

; 625  : #if _ITERATOR_DEBUG_LEVEL != 0
; 626  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  00047	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	e8 00 00 00 00	 call	 ?_Getal@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEAAV?$allocator@PBD@2@XZ ; std::vector<char const *,std::allocator<char const *> >::_Getal
  0004f	50		 push	 eax
  00050	8d 4d e7	 lea	 ecx, DWORD PTR _$S1$[ebp]
  00053	e8 00 00 00 00	 call	 ??$?0PBD@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@PBD@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char const *>
  00058	8d 45 e7	 lea	 eax, DWORD PTR _$S1$[ebp]
  0005b	89 45 ec	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 627  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));

  0005e	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  00065	8d 4d dc	 lea	 ecx, DWORD PTR $T2[ebp]
  00068	51		 push	 ecx
  00069	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0006c	52		 push	 edx
  0006d	e8 00 00 00 00	 call	 ??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z ; std::exchange<std::_Container_proxy *,std::nullptr_t>
  00072	83 c4 08	 add	 esp, 8
  00075	50		 push	 eax
  00076	8b 45 ec	 mov	 eax, DWORD PTR __Alproxy$[ebp]
  00079	50		 push	 eax
  0007a	e8 00 00 00 00	 call	 ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
  0007f	83 c4 08	 add	 esp, 8

; 628  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 629  :     }

  00082	52		 push	 edx
  00083	8b cd		 mov	 ecx, ebp
  00085	50		 push	 eax
  00086	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN6@vector
  0008c	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00091	58		 pop	 eax
  00092	5a		 pop	 edx
  00093	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00096	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0009d	59		 pop	 ecx
  0009e	83 c4 24	 add	 esp, 36			; 00000024H
  000a1	3b ec		 cmp	 ebp, esp
  000a3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a8	8b e5		 mov	 esp, ebp
  000aa	5d		 pop	 ebp
  000ab	c3		 ret	 0
$LN6@vector:
  000ac	01 00 00 00	 DD	 1
  000b0	00 00 00 00	 DD	 $LN5@vector
$LN5@vector:
  000b4	e7 ff ff ff	 DD	 -25			; ffffffe7H
  000b8	01 00 00 00	 DD	 1
  000bc	00 00 00 00	 DD	 $LN3@vector
$LN3@vector:
  000c0	24		 DB	 36			; 00000024H
  000c1	53		 DB	 83			; 00000053H
  000c2	31		 DB	 49			; 00000031H
  000c3	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$vector@PBDV?$allocator@PBD@std@@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$vector@PBDV?$allocator@PBD@std@@@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$vector@PBDV?$allocator@PBD@std@@@std@@QAE@XZ ENDP	; std::vector<char const *,std::allocator<char const *> >::~vector<char const *,std::allocator<char const *> >
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\vector
;	COMDAT ??0?$vector@PBDV?$allocator@PBD@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T2 = -18						; size = 1
$T3 = -17						; size = 1
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@PBDV?$allocator@PBD@std@@@std@@QAE@XZ PROC	; std::vector<char const *,std::allocator<char const *> >::vector<char const *,std::allocator<char const *> >, COMDAT
; _this$ = ecx

; 385  :     vector() _NOEXCEPT_COND(is_nothrow_default_constructible_v<_Alty>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$vector@PBDV?$allocator@PBD@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	c7 45 ec cc cc
	cc cc		 mov	 DWORD PTR [ebp-20], -858993460 ; ccccccccH
  0001b	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00027	33 c5		 xor	 eax, ebp
  00029	50		 push	 eax
  0002a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0002d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00033	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 386  :         : _Mypair(_Zero_then_variadic_args_t()) { // construct empty vector

  00036	0f b6 45 ef	 movzx	 eax, BYTE PTR $T3[ebp]
  0003a	50		 push	 eax
  0003b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	e8 00 00 00 00	 call	 ??$?0$$V@?$_Compressed_pair@V?$allocator@PBD@std@@V?$_Vector_val@U?$_Simple_types@PBD@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char const *>,std::_Vector_val<std::_Simple_types<char const *> >,1>::_Compressed_pair<std::allocator<char const *>,std::_Vector_val<std::_Simple_types<char const *> >,1><>

; 387  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

  00043	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	e8 00 00 00 00	 call	 ?_Getal@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEAAV?$allocator@PBD@2@XZ ; std::vector<char const *,std::allocator<char const *> >::_Getal
  0004b	50		 push	 eax
  0004c	8d 4d ee	 lea	 ecx, DWORD PTR $T2[ebp]
  0004f	e8 00 00 00 00	 call	 ??$?0PBD@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@PBD@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char const *>
  00054	50		 push	 eax
  00055	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	e8 00 00 00 00	 call	 ??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >

; 388  :     }

  0005d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00060	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00063	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006a	59		 pop	 ecx
  0006b	83 c4 14	 add	 esp, 20			; 00000014H
  0006e	3b ec		 cmp	 ebp, esp
  00070	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00075	8b e5		 mov	 esp, ebp
  00077	5d		 pop	 ebp
  00078	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$vector@PBDV?$allocator@PBD@std@@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$vector@PBDV?$allocator@PBD@std@@@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$vector@PBDV?$allocator@PBD@std@@@std@@QAE@XZ ENDP	; std::vector<char const *,std::allocator<char const *> >::vector<char const *,std::allocator<char const *> >
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@PBD@std@@@std@@SAIABV?$allocator@PBD@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?max_size@?$_Default_allocator_traits@V?$allocator@PBD@std@@@std@@SAIABV?$allocator@PBD@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<char const *> >::max_size, COMDAT

; 766  :     _NODISCARD static size_type max_size(const _Alloc&) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 767  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00003	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 768  :     }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@PBD@std@@@std@@SAIABV?$allocator@PBD@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char const *> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ?allocate@?$allocator@PBD@std@@QAEPAPBDI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@PBD@std@@QAEPAPBDI@Z PROC		; std::allocator<char const *>::allocate, COMDAT
; _this$ = ecx

; 870  :     _NODISCARD _DECLSPEC_ALLOCATOR _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 871  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$_Get_size_of_n@$03@std@@YAII@Z ; std::_Get_size_of_n<4>
  00017	83 c4 04	 add	 esp, 4
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00020	83 c4 04	 add	 esp, 4

; 872  :     }

  00023	83 c4 04	 add	 esp, 4
  00026	3b ec		 cmp	 ebp, esp
  00028	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
?allocate@?$allocator@PBD@std@@QAEPAPBDI@Z ENDP		; std::allocator<char const *>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ?deallocate@?$allocator@PBD@std@@QAEXQAPBDI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@PBD@std@@QAEXQAPBDI@Z PROC	; std::allocator<char const *>::deallocate, COMDAT
; _this$ = ecx

; 865  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 866  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 867  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000e	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00011	c1 e0 02	 shl	 eax, 2
  00014	50		 push	 eax
  00015	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00018	51		 push	 ecx
  00019	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0001e	83 c4 08	 add	 esp, 8

; 868  :     }

  00021	83 c4 04	 add	 esp, 4
  00024	3b ec		 cmp	 ebp, esp
  00026	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c2 08 00	 ret	 8
?deallocate@?$allocator@PBD@std@@QAEXQAPBDI@Z ENDP	; std::allocator<char const *>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ??0?$allocator@PBD@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@PBD@std@@QAE@XZ PROC			; std::allocator<char const *>::allocator<char const *>, COMDAT
; _this$ = ecx

; 859  :     constexpr allocator() noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??0?$allocator@PBD@std@@QAE@XZ ENDP			; std::allocator<char const *>::allocator<char const *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\memory
;	COMDAT ??$?0U?$default_delete@VRGYPipeProcess@@@std@@$0A@@?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@QAE@PAVRGYPipeProcess@@@Z
_TEXT	SEGMENT
$T2 = -17						; size = 1
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
??$?0U?$default_delete@VRGYPipeProcess@@@std@@$0A@@?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@QAE@PAVRGYPipeProcess@@@Z PROC ; std::unique_ptr<RGYPipeProcess,std::default_delete<RGYPipeProcess> >::unique_ptr<RGYPipeProcess,std::default_delete<RGYPipeProcess> ><std::default_delete<RGYPipeProcess>,0>, COMDAT
; _this$ = ecx

; 1820 :     explicit unique_ptr(pointer _Ptr) noexcept : _Mypair(_Zero_then_variadic_args_t(), _Ptr) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?0U?$default_delete@VRGYPipeProcess@@@std@@$0A@@?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@QAE@PAVRGYPipeProcess@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	c7 45 ec cc cc
	cc cc		 mov	 DWORD PTR [ebp-20], -858993460 ; ccccccccH
  0001b	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00027	33 c5		 xor	 eax, ebp
  00029	50		 push	 eax
  0002a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0002d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00033	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00036	8d 45 08	 lea	 eax, DWORD PTR __Ptr$[ebp]
  00039	50		 push	 eax
  0003a	0f b6 4d ef	 movzx	 ecx, BYTE PTR $T2[ebp]
  0003e	51		 push	 ecx
  0003f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e8 00 00 00 00	 call	 ??$?0AAPAVRGYPipeProcess@@@?$_Compressed_pair@U?$default_delete@VRGYPipeProcess@@@std@@PAVRGYPipeProcess@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAVRGYPipeProcess@@@Z ; std::_Compressed_pair<std::default_delete<RGYPipeProcess>,RGYPipeProcess *,1>::_Compressed_pair<std::default_delete<RGYPipeProcess>,RGYPipeProcess *,1><RGYPipeProcess * &>
  00047	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00054	59		 pop	 ecx
  00055	83 c4 14	 add	 esp, 20			; 00000014H
  00058	3b ec		 cmp	 ebp, esp
  0005a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$?0U?$default_delete@VRGYPipeProcess@@@std@@$0A@@?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@QAE@PAVRGYPipeProcess@@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?0U?$default_delete@VRGYPipeProcess@@@std@@$0A@@?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@QAE@PAVRGYPipeProcess@@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?0U?$default_delete@VRGYPipeProcess@@@std@@$0A@@?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@QAE@PAVRGYPipeProcess@@@Z ENDP ; std::unique_ptr<RGYPipeProcess,std::default_delete<RGYPipeProcess> >::unique_ptr<RGYPipeProcess,std::default_delete<RGYPipeProcess> ><std::default_delete<RGYPipeProcess>,0>
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\memory
;	COMDAT ??$?0Ufp_deleter@@$0A@@?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@QAE@PAU_iobuf@@@Z
_TEXT	SEGMENT
$T2 = -17						; size = 1
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
??$?0Ufp_deleter@@$0A@@?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@QAE@PAU_iobuf@@@Z PROC ; std::unique_ptr<_iobuf,fp_deleter>::unique_ptr<_iobuf,fp_deleter><fp_deleter,0>, COMDAT
; _this$ = ecx

; 1820 :     explicit unique_ptr(pointer _Ptr) noexcept : _Mypair(_Zero_then_variadic_args_t(), _Ptr) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?0Ufp_deleter@@$0A@@?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@QAE@PAU_iobuf@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	c7 45 ec cc cc
	cc cc		 mov	 DWORD PTR [ebp-20], -858993460 ; ccccccccH
  0001b	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00027	33 c5		 xor	 eax, ebp
  00029	50		 push	 eax
  0002a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0002d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00033	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00036	8d 45 08	 lea	 eax, DWORD PTR __Ptr$[ebp]
  00039	50		 push	 eax
  0003a	0f b6 4d ef	 movzx	 ecx, BYTE PTR $T2[ebp]
  0003e	51		 push	 ecx
  0003f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e8 00 00 00 00	 call	 ??$?0AAPAU_iobuf@@@?$_Compressed_pair@Ufp_deleter@@PAU_iobuf@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAU_iobuf@@@Z ; std::_Compressed_pair<fp_deleter,_iobuf *,1>::_Compressed_pair<fp_deleter,_iobuf *,1><_iobuf * &>
  00047	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00054	59		 pop	 ecx
  00055	83 c4 14	 add	 esp, 20			; 00000014H
  00058	3b ec		 cmp	 ebp, esp
  0005a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$?0Ufp_deleter@@$0A@@?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@QAE@PAU_iobuf@@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?0Ufp_deleter@@$0A@@?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@QAE@PAU_iobuf@@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?0Ufp_deleter@@$0A@@?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@QAE@PAU_iobuf@@@Z ENDP ; std::unique_ptr<_iobuf,fp_deleter>::unique_ptr<_iobuf,fp_deleter><fp_deleter,0>
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\type_traits
;	COMDAT ??$move@AAV?$unique_ptr@XUhandle_deleter@@@std@@@std@@YA$$QAV?$unique_ptr@XUhandle_deleter@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$unique_ptr@XUhandle_deleter@@@std@@@std@@YA$$QAV?$unique_ptr@XUhandle_deleter@@@0@AAV10@@Z PROC ; std::move<std::unique_ptr<void,handle_deleter> &>, COMDAT

; 1432 : _NODISCARD constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept { // forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1433 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1434 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAV?$unique_ptr@XUhandle_deleter@@@std@@@std@@YA$$QAV?$unique_ptr@XUhandle_deleter@@@0@AAV10@@Z ENDP ; std::move<std::unique_ptr<void,handle_deleter> &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\memory
;	COMDAT ??$?0Ufp_deleter@@$0A@@?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@QAE@XZ
_TEXT	SEGMENT
$T2 = -17						; size = 1
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??$?0Ufp_deleter@@$0A@@?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@QAE@XZ PROC ; std::unique_ptr<_iobuf,fp_deleter>::unique_ptr<_iobuf,fp_deleter><fp_deleter,0>, COMDAT
; _this$ = ecx

; 1809 :     constexpr unique_ptr() noexcept : _Mypair(_Zero_then_variadic_args_t()) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?0Ufp_deleter@@$0A@@?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	c7 45 ec cc cc
	cc cc		 mov	 DWORD PTR [ebp-20], -858993460 ; ccccccccH
  0001b	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00027	33 c5		 xor	 eax, ebp
  00029	50		 push	 eax
  0002a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0002d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00033	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00036	0f b6 45 ef	 movzx	 eax, BYTE PTR $T2[ebp]
  0003a	50		 push	 eax
  0003b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	e8 00 00 00 00	 call	 ??$?0$$V@?$_Compressed_pair@Ufp_deleter@@PAU_iobuf@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<fp_deleter,_iobuf *,1>::_Compressed_pair<fp_deleter,_iobuf *,1><>
  00043	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00046	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00049	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00050	59		 pop	 ecx
  00051	83 c4 14	 add	 esp, 20			; 00000014H
  00054	3b ec		 cmp	 ebp, esp
  00056	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$?0Ufp_deleter@@$0A@@?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?0Ufp_deleter@@$0A@@?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?0Ufp_deleter@@$0A@@?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@QAE@XZ ENDP ; std::unique_ptr<_iobuf,fp_deleter>::unique_ptr<_iobuf,fp_deleter><fp_deleter,0>
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\memory
;	COMDAT ??$?0U?$default_delete@VRGYPipeProcess@@@std@@$0A@@?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T2 = -17						; size = 1
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??$?0U?$default_delete@VRGYPipeProcess@@@std@@$0A@@?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@QAE@XZ PROC ; std::unique_ptr<RGYPipeProcess,std::default_delete<RGYPipeProcess> >::unique_ptr<RGYPipeProcess,std::default_delete<RGYPipeProcess> ><std::default_delete<RGYPipeProcess>,0>, COMDAT
; _this$ = ecx

; 1809 :     constexpr unique_ptr() noexcept : _Mypair(_Zero_then_variadic_args_t()) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?0U?$default_delete@VRGYPipeProcess@@@std@@$0A@@?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	c7 45 ec cc cc
	cc cc		 mov	 DWORD PTR [ebp-20], -858993460 ; ccccccccH
  0001b	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00027	33 c5		 xor	 eax, ebp
  00029	50		 push	 eax
  0002a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0002d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00033	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00036	0f b6 45 ef	 movzx	 eax, BYTE PTR $T2[ebp]
  0003a	50		 push	 eax
  0003b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	e8 00 00 00 00	 call	 ??$?0$$V@?$_Compressed_pair@U?$default_delete@VRGYPipeProcess@@@std@@PAVRGYPipeProcess@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::default_delete<RGYPipeProcess>,RGYPipeProcess *,1>::_Compressed_pair<std::default_delete<RGYPipeProcess>,RGYPipeProcess *,1><>
  00043	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00046	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00049	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00050	59		 pop	 ecx
  00051	83 c4 14	 add	 esp, 20			; 00000014H
  00054	3b ec		 cmp	 ebp, esp
  00056	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$?0U?$default_delete@VRGYPipeProcess@@@std@@$0A@@?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?0U?$default_delete@VRGYPipeProcess@@@std@@$0A@@?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?0U?$default_delete@VRGYPipeProcess@@@std@@$0A@@?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@QAE@XZ ENDP ; std::unique_ptr<RGYPipeProcess,std::default_delete<RGYPipeProcess> >::unique_ptr<RGYPipeProcess,std::default_delete<RGYPipeProcess> ><std::default_delete<RGYPipeProcess>,0>
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\memory
;	COMDAT ??$?0Uhandle_deleter@@$0A@@?$unique_ptr@XUhandle_deleter@@@std@@QAE@XZ
_TEXT	SEGMENT
$T2 = -17						; size = 1
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??$?0Uhandle_deleter@@$0A@@?$unique_ptr@XUhandle_deleter@@@std@@QAE@XZ PROC ; std::unique_ptr<void,handle_deleter>::unique_ptr<void,handle_deleter><handle_deleter,0>, COMDAT
; _this$ = ecx

; 1809 :     constexpr unique_ptr() noexcept : _Mypair(_Zero_then_variadic_args_t()) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?0Uhandle_deleter@@$0A@@?$unique_ptr@XUhandle_deleter@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	c7 45 ec cc cc
	cc cc		 mov	 DWORD PTR [ebp-20], -858993460 ; ccccccccH
  0001b	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00027	33 c5		 xor	 eax, ebp
  00029	50		 push	 eax
  0002a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0002d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00033	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00036	0f b6 45 ef	 movzx	 eax, BYTE PTR $T2[ebp]
  0003a	50		 push	 eax
  0003b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	e8 00 00 00 00	 call	 ??$?0$$V@?$_Compressed_pair@Uhandle_deleter@@PAX$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<handle_deleter,void *,1>::_Compressed_pair<handle_deleter,void *,1><>
  00043	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00046	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00049	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00050	59		 pop	 ecx
  00051	83 c4 14	 add	 esp, 20			; 00000014H
  00054	3b ec		 cmp	 ebp, esp
  00056	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$?0Uhandle_deleter@@$0A@@?$unique_ptr@XUhandle_deleter@@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?0Uhandle_deleter@@$0A@@?$unique_ptr@XUhandle_deleter@@@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?0Uhandle_deleter@@$0A@@?$unique_ptr@XUhandle_deleter@@@std@@QAE@XZ ENDP ; std::unique_ptr<void,handle_deleter>::unique_ptr<void,handle_deleter><handle_deleter,0>
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\chrono
;	COMDAT ??$?0HX@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QAE@ABH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??$?0HX@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QAE@ABH@Z PROC ; std::chrono::duration<__int64,std::ratio<1,1000> >::duration<__int64,std::ratio<1,1000> ><int,void>, COMDAT
; _this$ = ecx

; 78   :             : _MyRep(static_cast<_Rep>(_Val)) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00011	8b 00		 mov	 eax, DWORD PTR [eax]
  00013	99		 cdq
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	89 01		 mov	 DWORD PTR [ecx], eax
  00019	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
??$?0HX@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QAE@ABH@Z ENDP ; std::chrono::duration<__int64,std::ratio<1,1000> >::duration<__int64,std::ratio<1,1000> ><int,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\chrono
;	COMDAT ??$?GUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z
_TEXT	SEGMENT
$T1 = -16						; size = 8
$T2 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?GUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z PROC ; std::chrono::operator-<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,std::chrono::duration<__int64,std::ratio<1,1000000000> > >, COMDAT

; 524  :             is_arithmetic_v<typename _Duration1::rep>&& is_arithmetic_v<typename _Duration2::rep>) { // strengthened

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000e	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00011	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00014	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 525  :         // add time_point to time_point
; 526  :         return _Left.time_since_epoch() - _Right.time_since_epoch();

  00017	8d 45 f8	 lea	 eax, DWORD PTR $T2[ebp]
  0001a	50		 push	 eax
  0001b	8b 4d 10	 mov	 ecx, DWORD PTR __Right$[ebp]
  0001e	e8 00 00 00 00	 call	 ?time_since_epoch@?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QBE?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@XZ ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_since_epoch
  00023	50		 push	 eax
  00024	8d 4d f0	 lea	 ecx, DWORD PTR $T1[ebp]
  00027	51		 push	 ecx
  00028	8b 4d 0c	 mov	 ecx, DWORD PTR __Left$[ebp]
  0002b	e8 00 00 00 00	 call	 ?time_since_epoch@?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QBE?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@XZ ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_since_epoch
  00030	50		 push	 eax
  00031	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00034	52		 push	 edx
  00035	e8 00 00 00 00	 call	 ??$?G_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV201@0@Z ; std::chrono::operator-<__int64,std::ratio<1,1000000000>,__int64,std::ratio<1,1000000000> >
  0003a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 527  :     }

  00040	83 c4 10	 add	 esp, 16			; 00000010H
  00043	3b ec		 cmp	 ebp, esp
  00045	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
??$?GUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z ENDP ; std::chrono::operator-<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\memory
;	COMDAT ??$?CVRGYLog@@$0A@@?$shared_ptr@VRGYLog@@@std@@QBEPAVRGYLog@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$?CVRGYLog@@$0A@@?$shared_ptr@VRGYLog@@@std@@QBEPAVRGYLog@@XZ PROC ; std::shared_ptr<RGYLog>::operator-><RGYLog,0>, COMDAT
; _this$ = ecx

; 1204 :     _NODISCARD _Ty2* operator->() const noexcept { // return pointer to resource

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1205 :         return get();

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?get@?$_Ptr_base@VRGYLog@@@std@@IBEPAVRGYLog@@XZ ; std::_Ptr_base<RGYLog>::get

; 1206 :     }

  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??$?CVRGYLog@@$0A@@?$shared_ptr@VRGYLog@@@std@@QBEPAVRGYLog@@XZ ENDP ; std::shared_ptr<RGYLog>::operator-><RGYLog,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\rgy_status.h
;	COMDAT ?GetEncodeData@EncodeStatus@@QAE?AUEncodeStatusData@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetEncodeData@EncodeStatus@@QAE?AUEncodeStatusData@@XZ PROC ; EncodeStatus::GetEncodeData, COMDAT
; _this$ = ecx

; 388  :     EncodeStatusData GetEncodeData() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000d	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 389  :         return m_sData;

  00010	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  00013	83 c6 08	 add	 esi, 8
  00016	b9 2c 00 00 00	 mov	 ecx, 44			; 0000002cH
  0001b	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  0001e	f3 a5		 rep movsd
  00020	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 390  :     }

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?GetEncodeData@EncodeStatus@@QAE?AUEncodeStatusData@@XZ ENDP ; EncodeStatus::GetEncodeData
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\rgy_status.h
;	COMDAT ?getEncStarted@EncodeStatus@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getEncStarted@EncodeStatus@@QAE_NXZ PROC		; EncodeStatus::getEncStarted, COMDAT
; _this$ = ecx

; 379  :     bool getEncStarted() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 380  :         return m_bEncStarted;

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8a 80 01 01 00
	00		 mov	 al, BYTE PTR [eax+257]

; 381  :     }

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?getEncStarted@EncodeStatus@@QAE_NXZ ENDP		; EncodeStatus::getEncStarted
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\rgy_status.h
;	COMDAT ?getStartTimeMicroSec@EncodeStatus@@QAE_JXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getStartTimeMicroSec@EncodeStatus@@QAE_JXZ PROC	; EncodeStatus::getStartTimeMicroSec, COMDAT
; _this$ = ecx

; 372  :     int64_t getStartTimeMicroSec() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 373  : #if defined(_WIN32) || defined(_WIN64)
; 374  :         return m_sStartTime.creation / 10;

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	6a 00		 push	 0
  00013	6a 0a		 push	 10			; 0000000aH
  00015	8b 88 d4 00 00
	00		 mov	 ecx, DWORD PTR [eax+212]
  0001b	51		 push	 ecx
  0001c	8b 90 d0 00 00
	00		 mov	 edx, DWORD PTR [eax+208]
  00022	52		 push	 edx
  00023	e8 00 00 00 00	 call	 __aulldiv

; 375  : #else
; 376  :         return (int)(m_sStartTime.creation * (double)(1e6 / CLOCKS_PER_SEC) + 0.5);
; 377  : #endif
; 378  :     }

  00028	83 c4 04	 add	 esp, 4
  0002b	3b ec		 cmp	 ebp, esp
  0002d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
?getStartTimeMicroSec@EncodeStatus@@QAE_JXZ ENDP	; EncodeStatus::getStartTimeMicroSec
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\memory
;	COMDAT ?reset@?$shared_ptr@VRGYLog@@@std@@QAEXXZ
_TEXT	SEGMENT
tv71 = -32						; size = 4
tv72 = -28						; size = 4
$T2 = -24						; size = 8
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?reset@?$shared_ptr@VRGYLog@@@std@@QAEXXZ PROC		; std::shared_ptr<RGYLog>::reset, COMDAT
; _this$ = ecx

; 1177 :     void reset() noexcept { // release resource and convert to empty shared_ptr object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?reset@?$shared_ptr@VRGYLog@@@std@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  0001c	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  0001f	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00022	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00025	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002d	33 c5		 xor	 eax, ebp
  0002f	50		 push	 eax
  00030	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00033	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00039	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1178 :         shared_ptr().swap(*this);

  0003c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0003f	50		 push	 eax
  00040	8d 4d e8	 lea	 ecx, DWORD PTR $T2[ebp]
  00043	e8 00 00 00 00	 call	 ??0?$shared_ptr@VRGYLog@@@std@@QAE@XZ ; std::shared_ptr<RGYLog>::shared_ptr<RGYLog>
  00048	89 45 e4	 mov	 DWORD PTR tv72[ebp], eax
  0004b	8b 4d e4	 mov	 ecx, DWORD PTR tv72[ebp]
  0004e	89 4d e0	 mov	 DWORD PTR tv71[ebp], ecx
  00051	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00058	8b 4d e0	 mov	 ecx, DWORD PTR tv71[ebp]
  0005b	e8 00 00 00 00	 call	 ?swap@?$shared_ptr@VRGYLog@@@std@@QAEXAAV12@@Z ; std::shared_ptr<RGYLog>::swap
  00060	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00067	8d 4d e8	 lea	 ecx, DWORD PTR $T2[ebp]
  0006a	e8 00 00 00 00	 call	 ??1?$shared_ptr@VRGYLog@@@std@@QAE@XZ ; std::shared_ptr<RGYLog>::~shared_ptr<RGYLog>

; 1179 :     }

  0006f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00072	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00079	59		 pop	 ecx
  0007a	83 c4 20	 add	 esp, 32			; 00000020H
  0007d	3b ec		 cmp	 ebp, esp
  0007f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?reset@?$shared_ptr@VRGYLog@@@std@@QAEXXZ$0:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR $T2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VRGYLog@@@std@@QAE@XZ ; std::shared_ptr<RGYLog>::~shared_ptr<RGYLog>
__ehhandler$?reset@?$shared_ptr@VRGYLog@@@std@@QAEXXZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?reset@?$shared_ptr@VRGYLog@@@std@@QAEXXZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?reset@?$shared_ptr@VRGYLog@@@std@@QAEXXZ ENDP		; std::shared_ptr<RGYLog>::reset
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\memory
;	COMDAT ?swap@?$shared_ptr@VRGYLog@@@std@@QAEXAAV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
?swap@?$shared_ptr@VRGYLog@@@std@@QAEXAAV12@@Z PROC	; std::shared_ptr<RGYLog>::swap, COMDAT
; _this$ = ecx

; 1173 :     void swap(shared_ptr& _Other) noexcept { // swap pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1174 :         this->_Swap(_Other);

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ?_Swap@?$_Ptr_base@VRGYLog@@@std@@IAEXAAV12@@Z ; std::_Ptr_base<RGYLog>::_Swap

; 1175 :     }

  0001a	83 c4 04	 add	 esp, 4
  0001d	3b ec		 cmp	 ebp, esp
  0001f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?swap@?$shared_ptr@VRGYLog@@@std@@QAEXAAV12@@Z ENDP	; std::shared_ptr<RGYLog>::swap
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\memory
;	COMDAT ??4?$shared_ptr@VRGYLog@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
tv72 = -32						; size = 4
tv73 = -28						; size = 4
$T2 = -24						; size = 8
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??4?$shared_ptr@VRGYLog@@@std@@QAEAAV01@ABV01@@Z PROC	; std::shared_ptr<RGYLog>::operator=, COMDAT
; _this$ = ecx

; 1136 :     shared_ptr& operator=(const shared_ptr& _Right) noexcept { // assign shared ownership of resource owned by _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??4?$shared_ptr@VRGYLog@@@std@@QAEAAV01@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  0001c	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  0001f	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00022	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00025	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002d	33 c5		 xor	 eax, ebp
  0002f	50		 push	 eax
  00030	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00033	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00039	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1137 :         shared_ptr(_Right).swap(*this);

  0003c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0003f	50		 push	 eax
  00040	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00043	51		 push	 ecx
  00044	8d 4d e8	 lea	 ecx, DWORD PTR $T2[ebp]
  00047	e8 00 00 00 00	 call	 ??0?$shared_ptr@VRGYLog@@@std@@QAE@ABV01@@Z ; std::shared_ptr<RGYLog>::shared_ptr<RGYLog>
  0004c	89 45 e4	 mov	 DWORD PTR tv73[ebp], eax
  0004f	8b 55 e4	 mov	 edx, DWORD PTR tv73[ebp]
  00052	89 55 e0	 mov	 DWORD PTR tv72[ebp], edx
  00055	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0005c	8b 4d e0	 mov	 ecx, DWORD PTR tv72[ebp]
  0005f	e8 00 00 00 00	 call	 ?swap@?$shared_ptr@VRGYLog@@@std@@QAEXAAV12@@Z ; std::shared_ptr<RGYLog>::swap
  00064	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0006b	8d 4d e8	 lea	 ecx, DWORD PTR $T2[ebp]
  0006e	e8 00 00 00 00	 call	 ??1?$shared_ptr@VRGYLog@@@std@@QAE@XZ ; std::shared_ptr<RGYLog>::~shared_ptr<RGYLog>

; 1138 :         return *this;

  00073	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]

; 1139 :     }

  00076	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00079	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00080	59		 pop	 ecx
  00081	83 c4 20	 add	 esp, 32			; 00000020H
  00084	3b ec		 cmp	 ebp, esp
  00086	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008b	8b e5		 mov	 esp, ebp
  0008d	5d		 pop	 ebp
  0008e	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??4?$shared_ptr@VRGYLog@@@std@@QAEAAV01@ABV01@@Z$0:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR $T2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VRGYLog@@@std@@QAE@XZ ; std::shared_ptr<RGYLog>::~shared_ptr<RGYLog>
__ehhandler$??4?$shared_ptr@VRGYLog@@@std@@QAEAAV01@ABV01@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??4?$shared_ptr@VRGYLog@@@std@@QAEAAV01@ABV01@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??4?$shared_ptr@VRGYLog@@@std@@QAEAAV01@ABV01@@Z ENDP	; std::shared_ptr<RGYLog>::operator=
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\memory
;	COMDAT ??1?$shared_ptr@VRGYLog@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$shared_ptr@VRGYLog@@@std@@QAE@XZ PROC		; std::shared_ptr<RGYLog>::~shared_ptr<RGYLog>, COMDAT
; _this$ = ecx

; 1132 :     ~shared_ptr() noexcept { // release resource

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1133 :         this->_Decref();

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Decref@?$_Ptr_base@VRGYLog@@@std@@IAEXXZ ; std::_Ptr_base<RGYLog>::_Decref

; 1134 :     }

  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1?$shared_ptr@VRGYLog@@@std@@QAE@XZ ENDP		; std::shared_ptr<RGYLog>::~shared_ptr<RGYLog>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\memory
;	COMDAT ??0?$shared_ptr@VRGYLog@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
??0?$shared_ptr@VRGYLog@@@std@@QAE@ABV01@@Z PROC	; std::shared_ptr<RGYLog>::shared_ptr<RGYLog>, COMDAT
; _this$ = ecx

; 1078 :     shared_ptr(const shared_ptr& _Other) noexcept { // construct shared_ptr object that owns same resource as _Other

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??0?$_Ptr_base@VRGYLog@@@std@@IAE@XZ ; std::_Ptr_base<RGYLog>::_Ptr_base<RGYLog>

; 1079 :         this->_Copy_construct_from(_Other);

  00016	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  00019	50		 push	 eax
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	e8 00 00 00 00	 call	 ??$_Copy_construct_from@VRGYLog@@@?$_Ptr_base@VRGYLog@@@std@@IAEXABV?$shared_ptr@VRGYLog@@@1@@Z ; std::_Ptr_base<RGYLog>::_Copy_construct_from<RGYLog>

; 1080 :     }

  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	83 c4 04	 add	 esp, 4
  00028	3b ec		 cmp	 ebp, esp
  0002a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
??0?$shared_ptr@VRGYLog@@@std@@QAE@ABV01@@Z ENDP	; std::shared_ptr<RGYLog>::shared_ptr<RGYLog>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\memory
;	COMDAT ??0?$shared_ptr@VRGYLog@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$shared_ptr@VRGYLog@@@std@@QAE@XZ PROC		; std::shared_ptr<RGYLog>::shared_ptr<RGYLog>, COMDAT
; _this$ = ecx

; 1016 :     constexpr shared_ptr() noexcept {} // construct empty shared_ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??0?$_Ptr_base@VRGYLog@@@std@@IAE@XZ ; std::_Ptr_base<RGYLog>::_Ptr_base<RGYLog>
  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	83 c4 04	 add	 esp, 4
  0001c	3b ec		 cmp	 ebp, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??0?$shared_ptr@VRGYLog@@@std@@QAE@XZ ENDP		; std::shared_ptr<RGYLog>::shared_ptr<RGYLog>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\memory
;	COMDAT ?_Swap@?$_Ptr_base@VRGYLog@@@std@@IAEXAAV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
?_Swap@?$_Ptr_base@VRGYLog@@@std@@IAEXAAV12@@Z PROC	; std::_Ptr_base<RGYLog>::_Swap, COMDAT
; _this$ = ecx

; 887  :     void _Swap(_Ptr_base& _Right) noexcept { // swap pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 888  :         _STD swap(_Ptr, _Right._Ptr);

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	51		 push	 ecx
  00016	e8 00 00 00 00	 call	 ??$swap@PAVRGYLog@@X@std@@YAXAAPAVRGYLog@@0@Z ; std::swap<RGYLog *,void>
  0001b	83 c4 08	 add	 esp, 8

; 889  :         _STD swap(_Rep, _Right._Rep);

  0001e	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00021	83 c2 04	 add	 edx, 4
  00024	52		 push	 edx
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	83 c0 04	 add	 eax, 4
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ??$swap@PAV_Ref_count_base@std@@X@std@@YAXAAPAV_Ref_count_base@0@0@Z ; std::swap<std::_Ref_count_base *,void>
  00031	83 c4 08	 add	 esp, 8

; 890  :     }

  00034	83 c4 04	 add	 esp, 4
  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
?_Swap@?$_Ptr_base@VRGYLog@@@std@@IAEXAAV12@@Z ENDP	; std::_Ptr_base<RGYLog>::_Swap
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\memory
;	COMDAT ?_Decref@?$_Ptr_base@VRGYLog@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Decref@?$_Ptr_base@VRGYLog@@@std@@IAEXXZ PROC		; std::_Ptr_base<RGYLog>::_Decref, COMDAT
; _this$ = ecx

; 881  :     void _Decref() noexcept { // decrement reference count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 882  :         if (_Rep) {

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00015	74 0b		 je	 SHORT $LN1@Decref

; 883  :             _Rep->_Decref();

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0001d	e8 00 00 00 00	 call	 ?_Decref@_Ref_count_base@std@@QAEXXZ ; std::_Ref_count_base::_Decref
$LN1@Decref:

; 884  :         }
; 885  :     }

  00022	83 c4 04	 add	 esp, 4
  00025	3b ec		 cmp	 ebp, esp
  00027	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
?_Decref@?$_Ptr_base@VRGYLog@@@std@@IAEXXZ ENDP		; std::_Ptr_base<RGYLog>::_Decref
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\rgy_perf_monitor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\memory
; File D:\work\intel\intel_codec\QSVPipeline\rgy_perf_monitor.cpp
;	COMDAT ??0?$_Ptr_base@VRGYLog@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ptr_base@VRGYLog@@@std@@IAE@XZ PROC		; std::_Ptr_base<RGYLog>::_Ptr_base<RGYLog>, COMDAT
; _this$ = ecx

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\memory

; 910  :     element_type* _Ptr{nullptr};

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 911  :     _Ref_count_base* _Rep{nullptr};

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
; File D:\work\intel\intel_codec\QSVPipeline\rgy_perf_monitor.cpp

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??0?$_Ptr_base@VRGYLog@@@std@@IAE@XZ ENDP		; std::_Ptr_base<RGYLog>::_Ptr_base<RGYLog>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\memory
;	COMDAT ?get@?$_Ptr_base@VRGYLog@@@std@@IBEPAVRGYLog@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$_Ptr_base@VRGYLog@@@std@@IBEPAVRGYLog@@XZ PROC	; std::_Ptr_base<RGYLog>::get, COMDAT
; _this$ = ecx

; 816  :     _NODISCARD element_type* get() const noexcept { // return pointer to resource

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 817  :         return _Ptr;

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 00		 mov	 eax, DWORD PTR [eax]

; 818  :     }

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?get@?$_Ptr_base@VRGYLog@@@std@@IBEPAVRGYLog@@XZ ENDP	; std::_Ptr_base<RGYLog>::get
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@Ufp_deleter@@PAU_iobuf@@$00@std@@QAEAAUfp_deleter@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@Ufp_deleter@@PAU_iobuf@@$00@std@@QAEAAUfp_deleter@@XZ PROC ; std::_Compressed_pair<fp_deleter,_iobuf *,1>::_Get_first, COMDAT
; _this$ = ecx

; 1420 :     _Ty1& _Get_first() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1421 :         return *this;

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1422 :     }

  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?_Get_first@?$_Compressed_pair@Ufp_deleter@@PAU_iobuf@@$00@std@@QAEAAUfp_deleter@@XZ ENDP ; std::_Compressed_pair<fp_deleter,_iobuf *,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\memory
;	COMDAT ?reset@?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@QAEXPAU_iobuf@@@Z
_TEXT	SEGMENT
__Old$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
?reset@?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@QAEXPAU_iobuf@@@Z PROC ; std::unique_ptr<_iobuf,fp_deleter>::reset, COMDAT
; _this$ = ecx

; 1907 :     void reset(pointer _Ptr = pointer()) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?reset@?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@QAEXPAU_iobuf@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	c7 45 ec cc cc
	cc cc		 mov	 DWORD PTR [ebp-20], -858993460 ; ccccccccH
  0001b	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00027	33 c5		 xor	 eax, ebp
  00029	50		 push	 eax
  0002a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0002d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00033	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1908 :         pointer _Old = _STD exchange(_Mypair._Myval2, _Ptr);

  00036	8d 45 08	 lea	 eax, DWORD PTR __Ptr$[ebp]
  00039	50		 push	 eax
  0003a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	51		 push	 ecx
  0003e	e8 00 00 00 00	 call	 ??$exchange@PAU_iobuf@@AAPAU1@@std@@YAPAU_iobuf@@AAPAU1@0@Z ; std::exchange<_iobuf *,_iobuf * &>
  00043	83 c4 08	 add	 esp, 8
  00046	89 45 ec	 mov	 DWORD PTR __Old$[ebp], eax

; 1909 :         if (_Old) {

  00049	83 7d ec 00	 cmp	 DWORD PTR __Old$[ebp], 0
  0004d	74 13		 je	 SHORT $LN1@reset

; 1910 :             _Mypair._Get_first()(_Old);

  0004f	8b 55 ec	 mov	 edx, DWORD PTR __Old$[ebp]
  00052	52		 push	 edx
  00053	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@Ufp_deleter@@PAU_iobuf@@$00@std@@QAEAAUfp_deleter@@XZ ; std::_Compressed_pair<fp_deleter,_iobuf *,1>::_Get_first
  0005b	8b c8		 mov	 ecx, eax
  0005d	e8 00 00 00 00	 call	 ??Rfp_deleter@@QBEXPAU_iobuf@@@Z ; fp_deleter::operator()
$LN1@reset:

; 1911 :         }
; 1912 :     }

  00062	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00065	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006c	59		 pop	 ecx
  0006d	83 c4 14	 add	 esp, 20			; 00000014H
  00070	3b ec		 cmp	 ebp, esp
  00072	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?reset@?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@QAEXPAU_iobuf@@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?reset@?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@QAEXPAU_iobuf@@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?reset@?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@QAEXPAU_iobuf@@@Z ENDP ; std::unique_ptr<_iobuf,fp_deleter>::reset
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\memory
;	COMDAT ?release@?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@QAEPAU_iobuf@@XZ
_TEXT	SEGMENT
$T2 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?release@?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@QAEPAU_iobuf@@XZ PROC ; std::unique_ptr<_iobuf,fp_deleter>::release, COMDAT
; _this$ = ecx

; 1903 :     pointer release() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?release@?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@QAEPAU_iobuf@@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	c7 45 ec cc cc
	cc cc		 mov	 DWORD PTR [ebp-20], -858993460 ; ccccccccH
  0001b	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00027	33 c5		 xor	 eax, ebp
  00029	50		 push	 eax
  0002a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0002d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00033	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1904 :         return _STD exchange(_Mypair._Myval2, pointer());

  00036	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  0003d	8d 45 ec	 lea	 eax, DWORD PTR $T2[ebp]
  00040	50		 push	 eax
  00041	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	51		 push	 ecx
  00045	e8 00 00 00 00	 call	 ??$exchange@PAU_iobuf@@PAU1@@std@@YAPAU_iobuf@@AAPAU1@$$QAPAU1@@Z ; std::exchange<_iobuf *,_iobuf *>
  0004a	83 c4 08	 add	 esp, 8

; 1905 :     }

  0004d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00050	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00057	59		 pop	 ecx
  00058	83 c4 14	 add	 esp, 20			; 00000014H
  0005b	3b ec		 cmp	 ebp, esp
  0005d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?release@?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@QAEPAU_iobuf@@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?release@?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@QAEPAU_iobuf@@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?release@?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@QAEPAU_iobuf@@XZ ENDP ; std::unique_ptr<_iobuf,fp_deleter>::release
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\memory
;	COMDAT ??B?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@QBE_NXZ
_TEXT	SEGMENT
tv67 = -5						; size = 1
_this$ = -4						; size = 4
??B?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@QBE_NXZ PROC ; std::unique_ptr<_iobuf,fp_deleter>::operator bool, COMDAT
; _this$ = ecx

; 1899 :     explicit operator bool() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1900 :         return static_cast<bool>(_Mypair._Myval2);

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0001d	74 06		 je	 SHORT $LN3@operator
  0001f	c6 45 fb 01	 mov	 BYTE PTR tv67[ebp], 1
  00023	eb 04		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00025	c6 45 fb 00	 mov	 BYTE PTR tv67[ebp], 0
$LN4@operator:
  00029	8a 45 fb	 mov	 al, BYTE PTR tv67[ebp]

; 1901 :     }

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
??B?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@QBE_NXZ ENDP ; std::unique_ptr<_iobuf,fp_deleter>::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\memory
;	COMDAT ?get@?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@QBEPAU_iobuf@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@QBEPAU_iobuf@@XZ PROC ; std::unique_ptr<_iobuf,fp_deleter>::get, COMDAT
; _this$ = ecx

; 1895 :     _NODISCARD pointer get() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1896 :         return _Mypair._Myval2;

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 00		 mov	 eax, DWORD PTR [eax]

; 1897 :     }

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?get@?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@QBEPAU_iobuf@@XZ ENDP ; std::unique_ptr<_iobuf,fp_deleter>::get
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\memory
;	COMDAT ??1?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@QAE@XZ PROC	; std::unique_ptr<_iobuf,fp_deleter>::~unique_ptr<_iobuf,fp_deleter>, COMDAT
; _this$ = ecx

; 1873 :     ~unique_ptr() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1874 :         if (_Mypair._Myval2) {

  0002d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 38 00	 cmp	 DWORD PTR [eax], 0
  00033	74 15		 je	 SHORT $LN1@unique_ptr

; 1875 :             _Mypair._Get_first()(_Mypair._Myval2);

  00035	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	8b 11		 mov	 edx, DWORD PTR [ecx]
  0003a	52		 push	 edx
  0003b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@Ufp_deleter@@PAU_iobuf@@$00@std@@QAEAAUfp_deleter@@XZ ; std::_Compressed_pair<fp_deleter,_iobuf *,1>::_Get_first
  00043	8b c8		 mov	 ecx, eax
  00045	e8 00 00 00 00	 call	 ??Rfp_deleter@@QBEXPAU_iobuf@@@Z ; fp_deleter::operator()
$LN1@unique_ptr:

; 1876 :         }
; 1877 :     }

  0004a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00054	59		 pop	 ecx
  00055	83 c4 10	 add	 esp, 16			; 00000010H
  00058	3b ec		 cmp	 ebp, esp
  0005a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@QAE@XZ ENDP	; std::unique_ptr<_iobuf,fp_deleter>::~unique_ptr<_iobuf,fp_deleter>
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\memory
;	COMDAT ??4?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??4?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@QAEAAV01@$$QAV01@@Z PROC ; std::unique_ptr<_iobuf,fp_deleter>::operator=, COMDAT
; _this$ = ecx

; 1860 :     unique_ptr& operator=(unique_ptr&& _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1861 :         if (this != _STD addressof(_Right)) {

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$addressof@V?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@@std@@YAPAV?$unique_ptr@U_iobuf@@Ufp_deleter@@@0@AAV10@@Z ; std::addressof<std::unique_ptr<_iobuf,fp_deleter> >
  00017	83 c4 04	 add	 esp, 4
  0001a	39 45 fc	 cmp	 DWORD PTR _this$[ebp], eax
  0001d	74 2a		 je	 SHORT $LN2@operator

; 1862 :             reset(_Right.release());

  0001f	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00022	e8 00 00 00 00	 call	 ?release@?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@QAEPAU_iobuf@@XZ ; std::unique_ptr<_iobuf,fp_deleter>::release
  00027	50		 push	 eax
  00028	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	e8 00 00 00 00	 call	 ?reset@?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@QAEXPAU_iobuf@@@Z ; std::unique_ptr<_iobuf,fp_deleter>::reset

; 1863 :             _Mypair._Get_first() = _STD forward<_Dx>(_Right._Mypair._Get_first());

  00030	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00033	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@Ufp_deleter@@PAU_iobuf@@$00@std@@QAEAAUfp_deleter@@XZ ; std::_Compressed_pair<fp_deleter,_iobuf *,1>::_Get_first
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ??$forward@Ufp_deleter@@@std@@YA$$QAUfp_deleter@@AAU1@@Z ; std::forward<fp_deleter>
  0003e	83 c4 04	 add	 esp, 4
  00041	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@Ufp_deleter@@PAU_iobuf@@$00@std@@QAEAAUfp_deleter@@XZ ; std::_Compressed_pair<fp_deleter,_iobuf *,1>::_Get_first
$LN2@operator:

; 1864 :         }
; 1865 :         return *this;

  00049	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1866 :     }

  0004c	83 c4 04	 add	 esp, 4
  0004f	3b ec		 cmp	 ebp, esp
  00051	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c2 04 00	 ret	 4
??4?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@QAEAAV01@$$QAV01@@Z ENDP ; std::unique_ptr<_iobuf,fp_deleter>::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\memory
;	COMDAT ??B?$shared_ptr@VEncodeStatus@@@std@@QBE_NXZ
_TEXT	SEGMENT
tv71 = -8						; size = 4
_this$ = -4						; size = 4
??B?$shared_ptr@VEncodeStatus@@@std@@QBE_NXZ PROC	; std::shared_ptr<EncodeStatus>::operator bool, COMDAT
; _this$ = ecx

; 1218 :     explicit operator bool() const noexcept { // test if shared_ptr object owns a resource

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1219 :         return get() != nullptr;

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?get@?$_Ptr_base@VEncodeStatus@@@std@@IBEPAVEncodeStatus@@XZ ; std::_Ptr_base<EncodeStatus>::get
  0001f	85 c0		 test	 eax, eax
  00021	74 09		 je	 SHORT $LN3@operator
  00023	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv71[ebp], 1
  0002a	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  0002c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
$LN4@operator:
  00033	8a 45 f8	 mov	 al, BYTE PTR tv71[ebp]

; 1220 :     }

  00036	83 c4 08	 add	 esp, 8
  00039	3b ec		 cmp	 ebp, esp
  0003b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
??B?$shared_ptr@VEncodeStatus@@@std@@QBE_NXZ ENDP	; std::shared_ptr<EncodeStatus>::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\memory
;	COMDAT ?swap@?$shared_ptr@VEncodeStatus@@@std@@QAEXAAV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
?swap@?$shared_ptr@VEncodeStatus@@@std@@QAEXAAV12@@Z PROC ; std::shared_ptr<EncodeStatus>::swap, COMDAT
; _this$ = ecx

; 1173 :     void swap(shared_ptr& _Other) noexcept { // swap pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1174 :         this->_Swap(_Other);

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ?_Swap@?$_Ptr_base@VEncodeStatus@@@std@@IAEXAAV12@@Z ; std::_Ptr_base<EncodeStatus>::_Swap

; 1175 :     }

  0001a	83 c4 04	 add	 esp, 4
  0001d	3b ec		 cmp	 ebp, esp
  0001f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?swap@?$shared_ptr@VEncodeStatus@@@std@@QAEXAAV12@@Z ENDP ; std::shared_ptr<EncodeStatus>::swap
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\memory
;	COMDAT ??4?$shared_ptr@VEncodeStatus@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
tv72 = -32						; size = 4
tv73 = -28						; size = 4
$T2 = -24						; size = 8
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??4?$shared_ptr@VEncodeStatus@@@std@@QAEAAV01@ABV01@@Z PROC ; std::shared_ptr<EncodeStatus>::operator=, COMDAT
; _this$ = ecx

; 1136 :     shared_ptr& operator=(const shared_ptr& _Right) noexcept { // assign shared ownership of resource owned by _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??4?$shared_ptr@VEncodeStatus@@@std@@QAEAAV01@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  0001c	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  0001f	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00022	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00025	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002d	33 c5		 xor	 eax, ebp
  0002f	50		 push	 eax
  00030	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00033	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00039	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1137 :         shared_ptr(_Right).swap(*this);

  0003c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0003f	50		 push	 eax
  00040	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00043	51		 push	 ecx
  00044	8d 4d e8	 lea	 ecx, DWORD PTR $T2[ebp]
  00047	e8 00 00 00 00	 call	 ??0?$shared_ptr@VEncodeStatus@@@std@@QAE@ABV01@@Z ; std::shared_ptr<EncodeStatus>::shared_ptr<EncodeStatus>
  0004c	89 45 e4	 mov	 DWORD PTR tv73[ebp], eax
  0004f	8b 55 e4	 mov	 edx, DWORD PTR tv73[ebp]
  00052	89 55 e0	 mov	 DWORD PTR tv72[ebp], edx
  00055	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0005c	8b 4d e0	 mov	 ecx, DWORD PTR tv72[ebp]
  0005f	e8 00 00 00 00	 call	 ?swap@?$shared_ptr@VEncodeStatus@@@std@@QAEXAAV12@@Z ; std::shared_ptr<EncodeStatus>::swap
  00064	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0006b	8d 4d e8	 lea	 ecx, DWORD PTR $T2[ebp]
  0006e	e8 00 00 00 00	 call	 ??1?$shared_ptr@VEncodeStatus@@@std@@QAE@XZ ; std::shared_ptr<EncodeStatus>::~shared_ptr<EncodeStatus>

; 1138 :         return *this;

  00073	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]

; 1139 :     }

  00076	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00079	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00080	59		 pop	 ecx
  00081	83 c4 20	 add	 esp, 32			; 00000020H
  00084	3b ec		 cmp	 ebp, esp
  00086	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008b	8b e5		 mov	 esp, ebp
  0008d	5d		 pop	 ebp
  0008e	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??4?$shared_ptr@VEncodeStatus@@@std@@QAEAAV01@ABV01@@Z$0:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR $T2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VEncodeStatus@@@std@@QAE@XZ ; std::shared_ptr<EncodeStatus>::~shared_ptr<EncodeStatus>
__ehhandler$??4?$shared_ptr@VEncodeStatus@@@std@@QAEAAV01@ABV01@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??4?$shared_ptr@VEncodeStatus@@@std@@QAEAAV01@ABV01@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??4?$shared_ptr@VEncodeStatus@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::shared_ptr<EncodeStatus>::operator=
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\memory
;	COMDAT ??1?$shared_ptr@VEncodeStatus@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$shared_ptr@VEncodeStatus@@@std@@QAE@XZ PROC	; std::shared_ptr<EncodeStatus>::~shared_ptr<EncodeStatus>, COMDAT
; _this$ = ecx

; 1132 :     ~shared_ptr() noexcept { // release resource

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1133 :         this->_Decref();

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Decref@?$_Ptr_base@VEncodeStatus@@@std@@IAEXXZ ; std::_Ptr_base<EncodeStatus>::_Decref

; 1134 :     }

  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1?$shared_ptr@VEncodeStatus@@@std@@QAE@XZ ENDP	; std::shared_ptr<EncodeStatus>::~shared_ptr<EncodeStatus>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\memory
;	COMDAT ??0?$shared_ptr@VEncodeStatus@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
??0?$shared_ptr@VEncodeStatus@@@std@@QAE@ABV01@@Z PROC	; std::shared_ptr<EncodeStatus>::shared_ptr<EncodeStatus>, COMDAT
; _this$ = ecx

; 1078 :     shared_ptr(const shared_ptr& _Other) noexcept { // construct shared_ptr object that owns same resource as _Other

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??0?$_Ptr_base@VEncodeStatus@@@std@@IAE@XZ ; std::_Ptr_base<EncodeStatus>::_Ptr_base<EncodeStatus>

; 1079 :         this->_Copy_construct_from(_Other);

  00016	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  00019	50		 push	 eax
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	e8 00 00 00 00	 call	 ??$_Copy_construct_from@VEncodeStatus@@@?$_Ptr_base@VEncodeStatus@@@std@@IAEXABV?$shared_ptr@VEncodeStatus@@@1@@Z ; std::_Ptr_base<EncodeStatus>::_Copy_construct_from<EncodeStatus>

; 1080 :     }

  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	83 c4 04	 add	 esp, 4
  00028	3b ec		 cmp	 ebp, esp
  0002a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
??0?$shared_ptr@VEncodeStatus@@@std@@QAE@ABV01@@Z ENDP	; std::shared_ptr<EncodeStatus>::shared_ptr<EncodeStatus>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\memory
;	COMDAT ??0?$shared_ptr@VEncodeStatus@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$shared_ptr@VEncodeStatus@@@std@@QAE@XZ PROC	; std::shared_ptr<EncodeStatus>::shared_ptr<EncodeStatus>, COMDAT
; _this$ = ecx

; 1016 :     constexpr shared_ptr() noexcept {} // construct empty shared_ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??0?$_Ptr_base@VEncodeStatus@@@std@@IAE@XZ ; std::_Ptr_base<EncodeStatus>::_Ptr_base<EncodeStatus>
  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	83 c4 04	 add	 esp, 4
  0001c	3b ec		 cmp	 ebp, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??0?$shared_ptr@VEncodeStatus@@@std@@QAE@XZ ENDP	; std::shared_ptr<EncodeStatus>::shared_ptr<EncodeStatus>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\memory
;	COMDAT ?_Swap@?$_Ptr_base@VEncodeStatus@@@std@@IAEXAAV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
?_Swap@?$_Ptr_base@VEncodeStatus@@@std@@IAEXAAV12@@Z PROC ; std::_Ptr_base<EncodeStatus>::_Swap, COMDAT
; _this$ = ecx

; 887  :     void _Swap(_Ptr_base& _Right) noexcept { // swap pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 888  :         _STD swap(_Ptr, _Right._Ptr);

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	51		 push	 ecx
  00016	e8 00 00 00 00	 call	 ??$swap@PAVEncodeStatus@@X@std@@YAXAAPAVEncodeStatus@@0@Z ; std::swap<EncodeStatus *,void>
  0001b	83 c4 08	 add	 esp, 8

; 889  :         _STD swap(_Rep, _Right._Rep);

  0001e	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00021	83 c2 04	 add	 edx, 4
  00024	52		 push	 edx
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	83 c0 04	 add	 eax, 4
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ??$swap@PAV_Ref_count_base@std@@X@std@@YAXAAPAV_Ref_count_base@0@0@Z ; std::swap<std::_Ref_count_base *,void>
  00031	83 c4 08	 add	 esp, 8

; 890  :     }

  00034	83 c4 04	 add	 esp, 4
  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
?_Swap@?$_Ptr_base@VEncodeStatus@@@std@@IAEXAAV12@@Z ENDP ; std::_Ptr_base<EncodeStatus>::_Swap
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\memory
;	COMDAT ?_Decref@?$_Ptr_base@VEncodeStatus@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Decref@?$_Ptr_base@VEncodeStatus@@@std@@IAEXXZ PROC	; std::_Ptr_base<EncodeStatus>::_Decref, COMDAT
; _this$ = ecx

; 881  :     void _Decref() noexcept { // decrement reference count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 882  :         if (_Rep) {

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00015	74 0b		 je	 SHORT $LN1@Decref

; 883  :             _Rep->_Decref();

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0001d	e8 00 00 00 00	 call	 ?_Decref@_Ref_count_base@std@@QAEXXZ ; std::_Ref_count_base::_Decref
$LN1@Decref:

; 884  :         }
; 885  :     }

  00022	83 c4 04	 add	 esp, 4
  00025	3b ec		 cmp	 ebp, esp
  00027	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
?_Decref@?$_Ptr_base@VEncodeStatus@@@std@@IAEXXZ ENDP	; std::_Ptr_base<EncodeStatus>::_Decref
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\rgy_perf_monitor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\memory
; File D:\work\intel\intel_codec\QSVPipeline\rgy_perf_monitor.cpp
;	COMDAT ??0?$_Ptr_base@VEncodeStatus@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ptr_base@VEncodeStatus@@@std@@IAE@XZ PROC		; std::_Ptr_base<EncodeStatus>::_Ptr_base<EncodeStatus>, COMDAT
; _this$ = ecx

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\memory

; 910  :     element_type* _Ptr{nullptr};

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 911  :     _Ref_count_base* _Rep{nullptr};

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
; File D:\work\intel\intel_codec\QSVPipeline\rgy_perf_monitor.cpp

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??0?$_Ptr_base@VEncodeStatus@@@std@@IAE@XZ ENDP		; std::_Ptr_base<EncodeStatus>::_Ptr_base<EncodeStatus>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\memory
;	COMDAT ?get@?$_Ptr_base@VEncodeStatus@@@std@@IBEPAVEncodeStatus@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$_Ptr_base@VEncodeStatus@@@std@@IBEPAVEncodeStatus@@XZ PROC ; std::_Ptr_base<EncodeStatus>::get, COMDAT
; _this$ = ecx

; 816  :     _NODISCARD element_type* get() const noexcept { // return pointer to resource

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 817  :         return _Ptr;

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 00		 mov	 eax, DWORD PTR [eax]

; 818  :     }

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?get@?$_Ptr_base@VEncodeStatus@@@std@@IBEPAVEncodeStatus@@XZ ENDP ; std::_Ptr_base<EncodeStatus>::get
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$default_delete@VRGYPipeProcess@@@std@@PAVRGYPipeProcess@@$00@std@@QAEAAU?$default_delete@VRGYPipeProcess@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@U?$default_delete@VRGYPipeProcess@@@std@@PAVRGYPipeProcess@@$00@std@@QAEAAU?$default_delete@VRGYPipeProcess@@@2@XZ PROC ; std::_Compressed_pair<std::default_delete<RGYPipeProcess>,RGYPipeProcess *,1>::_Get_first, COMDAT
; _this$ = ecx

; 1420 :     _Ty1& _Get_first() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1421 :         return *this;

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1422 :     }

  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$default_delete@VRGYPipeProcess@@@std@@PAVRGYPipeProcess@@$00@std@@QAEAAU?$default_delete@VRGYPipeProcess@@@2@XZ ENDP ; std::_Compressed_pair<std::default_delete<RGYPipeProcess>,RGYPipeProcess *,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\memory
;	COMDAT ?reset@?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@QAEXPAVRGYPipeProcess@@@Z
_TEXT	SEGMENT
__Old$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
?reset@?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@QAEXPAVRGYPipeProcess@@@Z PROC ; std::unique_ptr<RGYPipeProcess,std::default_delete<RGYPipeProcess> >::reset, COMDAT
; _this$ = ecx

; 1907 :     void reset(pointer _Ptr = pointer()) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?reset@?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@QAEXPAVRGYPipeProcess@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	c7 45 ec cc cc
	cc cc		 mov	 DWORD PTR [ebp-20], -858993460 ; ccccccccH
  0001b	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00027	33 c5		 xor	 eax, ebp
  00029	50		 push	 eax
  0002a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0002d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00033	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1908 :         pointer _Old = _STD exchange(_Mypair._Myval2, _Ptr);

  00036	8d 45 08	 lea	 eax, DWORD PTR __Ptr$[ebp]
  00039	50		 push	 eax
  0003a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	51		 push	 ecx
  0003e	e8 00 00 00 00	 call	 ??$exchange@PAVRGYPipeProcess@@AAPAV1@@std@@YAPAVRGYPipeProcess@@AAPAV1@0@Z ; std::exchange<RGYPipeProcess *,RGYPipeProcess * &>
  00043	83 c4 08	 add	 esp, 8
  00046	89 45 ec	 mov	 DWORD PTR __Old$[ebp], eax

; 1909 :         if (_Old) {

  00049	83 7d ec 00	 cmp	 DWORD PTR __Old$[ebp], 0
  0004d	74 13		 je	 SHORT $LN1@reset

; 1910 :             _Mypair._Get_first()(_Old);

  0004f	8b 55 ec	 mov	 edx, DWORD PTR __Old$[ebp]
  00052	52		 push	 edx
  00053	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@U?$default_delete@VRGYPipeProcess@@@std@@PAVRGYPipeProcess@@$00@std@@QAEAAU?$default_delete@VRGYPipeProcess@@@2@XZ ; std::_Compressed_pair<std::default_delete<RGYPipeProcess>,RGYPipeProcess *,1>::_Get_first
  0005b	8b c8		 mov	 ecx, eax
  0005d	e8 00 00 00 00	 call	 ??R?$default_delete@VRGYPipeProcess@@@std@@QBEXPAVRGYPipeProcess@@@Z ; std::default_delete<RGYPipeProcess>::operator()
$LN1@reset:

; 1911 :         }
; 1912 :     }

  00062	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00065	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006c	59		 pop	 ecx
  0006d	83 c4 14	 add	 esp, 20			; 00000014H
  00070	3b ec		 cmp	 ebp, esp
  00072	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?reset@?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@QAEXPAVRGYPipeProcess@@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?reset@?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@QAEXPAVRGYPipeProcess@@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?reset@?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@QAEXPAVRGYPipeProcess@@@Z ENDP ; std::unique_ptr<RGYPipeProcess,std::default_delete<RGYPipeProcess> >::reset
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\memory
;	COMDAT ?release@?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@QAEPAVRGYPipeProcess@@XZ
_TEXT	SEGMENT
$T2 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?release@?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@QAEPAVRGYPipeProcess@@XZ PROC ; std::unique_ptr<RGYPipeProcess,std::default_delete<RGYPipeProcess> >::release, COMDAT
; _this$ = ecx

; 1903 :     pointer release() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?release@?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@QAEPAVRGYPipeProcess@@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	c7 45 ec cc cc
	cc cc		 mov	 DWORD PTR [ebp-20], -858993460 ; ccccccccH
  0001b	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00027	33 c5		 xor	 eax, ebp
  00029	50		 push	 eax
  0002a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0002d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00033	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1904 :         return _STD exchange(_Mypair._Myval2, pointer());

  00036	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  0003d	8d 45 ec	 lea	 eax, DWORD PTR $T2[ebp]
  00040	50		 push	 eax
  00041	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	51		 push	 ecx
  00045	e8 00 00 00 00	 call	 ??$exchange@PAVRGYPipeProcess@@PAV1@@std@@YAPAVRGYPipeProcess@@AAPAV1@$$QAPAV1@@Z ; std::exchange<RGYPipeProcess *,RGYPipeProcess *>
  0004a	83 c4 08	 add	 esp, 8

; 1905 :     }

  0004d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00050	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00057	59		 pop	 ecx
  00058	83 c4 14	 add	 esp, 20			; 00000014H
  0005b	3b ec		 cmp	 ebp, esp
  0005d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?release@?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@QAEPAVRGYPipeProcess@@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?release@?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@QAEPAVRGYPipeProcess@@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?release@?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@QAEPAVRGYPipeProcess@@XZ ENDP ; std::unique_ptr<RGYPipeProcess,std::default_delete<RGYPipeProcess> >::release
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\memory
;	COMDAT ??B?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
tv67 = -5						; size = 1
_this$ = -4						; size = 4
??B?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@QBE_NXZ PROC ; std::unique_ptr<RGYPipeProcess,std::default_delete<RGYPipeProcess> >::operator bool, COMDAT
; _this$ = ecx

; 1899 :     explicit operator bool() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1900 :         return static_cast<bool>(_Mypair._Myval2);

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0001d	74 06		 je	 SHORT $LN3@operator
  0001f	c6 45 fb 01	 mov	 BYTE PTR tv67[ebp], 1
  00023	eb 04		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00025	c6 45 fb 00	 mov	 BYTE PTR tv67[ebp], 0
$LN4@operator:
  00029	8a 45 fb	 mov	 al, BYTE PTR tv67[ebp]

; 1901 :     }

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
??B?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@QBE_NXZ ENDP ; std::unique_ptr<RGYPipeProcess,std::default_delete<RGYPipeProcess> >::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\memory
;	COMDAT ?get@?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@QBEPAVRGYPipeProcess@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@QBEPAVRGYPipeProcess@@XZ PROC ; std::unique_ptr<RGYPipeProcess,std::default_delete<RGYPipeProcess> >::get, COMDAT
; _this$ = ecx

; 1895 :     _NODISCARD pointer get() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1896 :         return _Mypair._Myval2;

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 00		 mov	 eax, DWORD PTR [eax]

; 1897 :     }

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?get@?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@QBEPAVRGYPipeProcess@@XZ ENDP ; std::unique_ptr<RGYPipeProcess,std::default_delete<RGYPipeProcess> >::get
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\memory
;	COMDAT ??C?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@QBEPAVRGYPipeProcess@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??C?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@QBEPAVRGYPipeProcess@@XZ PROC ; std::unique_ptr<RGYPipeProcess,std::default_delete<RGYPipeProcess> >::operator->, COMDAT
; _this$ = ecx

; 1891 :     _NODISCARD pointer operator->() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1892 :         return _Mypair._Myval2;

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 00		 mov	 eax, DWORD PTR [eax]

; 1893 :     }

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??C?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@QBEPAVRGYPipeProcess@@XZ ENDP ; std::unique_ptr<RGYPipeProcess,std::default_delete<RGYPipeProcess> >::operator->
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\memory
;	COMDAT ??1?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@QAE@XZ PROC ; std::unique_ptr<RGYPipeProcess,std::default_delete<RGYPipeProcess> >::~unique_ptr<RGYPipeProcess,std::default_delete<RGYPipeProcess> >, COMDAT
; _this$ = ecx

; 1873 :     ~unique_ptr() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1874 :         if (_Mypair._Myval2) {

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	83 38 00	 cmp	 DWORD PTR [eax], 0
  00014	74 15		 je	 SHORT $LN1@unique_ptr

; 1875 :             _Mypair._Get_first()(_Mypair._Myval2);

  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001b	52		 push	 edx
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@U?$default_delete@VRGYPipeProcess@@@std@@PAVRGYPipeProcess@@$00@std@@QAEAAU?$default_delete@VRGYPipeProcess@@@2@XZ ; std::_Compressed_pair<std::default_delete<RGYPipeProcess>,RGYPipeProcess *,1>::_Get_first
  00024	8b c8		 mov	 ecx, eax
  00026	e8 00 00 00 00	 call	 ??R?$default_delete@VRGYPipeProcess@@@std@@QBEXPAVRGYPipeProcess@@@Z ; std::default_delete<RGYPipeProcess>::operator()
$LN1@unique_ptr:

; 1876 :         }
; 1877 :     }

  0002b	83 c4 04	 add	 esp, 4
  0002e	3b ec		 cmp	 ebp, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
??1?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@QAE@XZ ENDP ; std::unique_ptr<RGYPipeProcess,std::default_delete<RGYPipeProcess> >::~unique_ptr<RGYPipeProcess,std::default_delete<RGYPipeProcess> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\memory
;	COMDAT ??4?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??4?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@QAEAAV01@$$QAV01@@Z PROC ; std::unique_ptr<RGYPipeProcess,std::default_delete<RGYPipeProcess> >::operator=, COMDAT
; _this$ = ecx

; 1860 :     unique_ptr& operator=(unique_ptr&& _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1861 :         if (this != _STD addressof(_Right)) {

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$addressof@V?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@@std@@YAPAV?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@0@AAV10@@Z ; std::addressof<std::unique_ptr<RGYPipeProcess,std::default_delete<RGYPipeProcess> > >
  00017	83 c4 04	 add	 esp, 4
  0001a	39 45 fc	 cmp	 DWORD PTR _this$[ebp], eax
  0001d	74 2a		 je	 SHORT $LN2@operator

; 1862 :             reset(_Right.release());

  0001f	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00022	e8 00 00 00 00	 call	 ?release@?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@QAEPAVRGYPipeProcess@@XZ ; std::unique_ptr<RGYPipeProcess,std::default_delete<RGYPipeProcess> >::release
  00027	50		 push	 eax
  00028	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	e8 00 00 00 00	 call	 ?reset@?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@QAEXPAVRGYPipeProcess@@@Z ; std::unique_ptr<RGYPipeProcess,std::default_delete<RGYPipeProcess> >::reset

; 1863 :             _Mypair._Get_first() = _STD forward<_Dx>(_Right._Mypair._Get_first());

  00030	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00033	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@U?$default_delete@VRGYPipeProcess@@@std@@PAVRGYPipeProcess@@$00@std@@QAEAAU?$default_delete@VRGYPipeProcess@@@2@XZ ; std::_Compressed_pair<std::default_delete<RGYPipeProcess>,RGYPipeProcess *,1>::_Get_first
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ??$forward@U?$default_delete@VRGYPipeProcess@@@std@@@std@@YA$$QAU?$default_delete@VRGYPipeProcess@@@0@AAU10@@Z ; std::forward<std::default_delete<RGYPipeProcess> >
  0003e	83 c4 04	 add	 esp, 4
  00041	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@U?$default_delete@VRGYPipeProcess@@@std@@PAVRGYPipeProcess@@$00@std@@QAEAAU?$default_delete@VRGYPipeProcess@@@2@XZ ; std::_Compressed_pair<std::default_delete<RGYPipeProcess>,RGYPipeProcess *,1>::_Get_first
$LN2@operator:

; 1864 :         }
; 1865 :         return *this;

  00049	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1866 :     }

  0004c	83 c4 04	 add	 esp, 4
  0004f	3b ec		 cmp	 ebp, esp
  00051	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c2 04 00	 ret	 4
??4?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@QAEAAV01@$$QAV01@@Z ENDP ; std::unique_ptr<RGYPipeProcess,std::default_delete<RGYPipeProcess> >::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\memory
;	COMDAT ??R?$default_delete@VRGYPipeProcess@@@std@@QBEXPAVRGYPipeProcess@@@Z
_TEXT	SEGMENT
tv70 = -12						; size = 4
$T1 = -8						; size = 4
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??R?$default_delete@VRGYPipeProcess@@@std@@QBEXPAVRGYPipeProcess@@@Z PROC ; std::default_delete<RGYPipeProcess>::operator(), COMDAT
; _this$ = ecx

; 1765 :     void operator()(_Ty* _Ptr) const noexcept { // delete a pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000e	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00015	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1766 :         static_assert(0 < sizeof(_Ty), "can't delete an incomplete type");
; 1767 :         delete _Ptr;

  0001f	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00022	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
  00025	83 7d f8 00	 cmp	 DWORD PTR $T1[ebp], 0
  00029	74 1c		 je	 SHORT $LN3@operator
  0002b	8b f4		 mov	 esi, esp
  0002d	6a 01		 push	 1
  0002f	8b 4d f8	 mov	 ecx, DWORD PTR $T1[ebp]
  00032	8b 11		 mov	 edx, DWORD PTR [ecx]
  00034	8b 4d f8	 mov	 ecx, DWORD PTR $T1[ebp]
  00037	8b 02		 mov	 eax, DWORD PTR [edx]
  00039	ff d0		 call	 eax
  0003b	3b f4		 cmp	 esi, esp
  0003d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00042	89 45 f4	 mov	 DWORD PTR tv70[ebp], eax
  00045	eb 07		 jmp	 SHORT $LN1@operator
$LN3@operator:
  00047	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
$LN1@operator:

; 1768 :     }

  0004e	5e		 pop	 esi
  0004f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00052	3b ec		 cmp	 ebp, esp
  00054	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
??R?$default_delete@VRGYPipeProcess@@@std@@QBEXPAVRGYPipeProcess@@@Z ENDP ; std::default_delete<RGYPipeProcess>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@Uhandle_deleter@@PAX$00@std@@QAEAAUhandle_deleter@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@Uhandle_deleter@@PAX$00@std@@QAEAAUhandle_deleter@@XZ PROC ; std::_Compressed_pair<handle_deleter,void *,1>::_Get_first, COMDAT
; _this$ = ecx

; 1420 :     _Ty1& _Get_first() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1421 :         return *this;

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1422 :     }

  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?_Get_first@?$_Compressed_pair@Uhandle_deleter@@PAX$00@std@@QAEAAUhandle_deleter@@XZ ENDP ; std::_Compressed_pair<handle_deleter,void *,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\memory
;	COMDAT ?reset@?$unique_ptr@XUhandle_deleter@@@std@@QAEXPAX@Z
_TEXT	SEGMENT
__Old$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
?reset@?$unique_ptr@XUhandle_deleter@@@std@@QAEXPAX@Z PROC ; std::unique_ptr<void,handle_deleter>::reset, COMDAT
; _this$ = ecx

; 1907 :     void reset(pointer _Ptr = pointer()) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?reset@?$unique_ptr@XUhandle_deleter@@@std@@QAEXPAX@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	c7 45 ec cc cc
	cc cc		 mov	 DWORD PTR [ebp-20], -858993460 ; ccccccccH
  0001b	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00027	33 c5		 xor	 eax, ebp
  00029	50		 push	 eax
  0002a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0002d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00033	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1908 :         pointer _Old = _STD exchange(_Mypair._Myval2, _Ptr);

  00036	8d 45 08	 lea	 eax, DWORD PTR __Ptr$[ebp]
  00039	50		 push	 eax
  0003a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	51		 push	 ecx
  0003e	e8 00 00 00 00	 call	 ??$exchange@PAXAAPAX@std@@YAPAXAAPAX0@Z ; std::exchange<void *,void * &>
  00043	83 c4 08	 add	 esp, 8
  00046	89 45 ec	 mov	 DWORD PTR __Old$[ebp], eax

; 1909 :         if (_Old) {

  00049	83 7d ec 00	 cmp	 DWORD PTR __Old$[ebp], 0
  0004d	74 13		 je	 SHORT $LN1@reset

; 1910 :             _Mypair._Get_first()(_Old);

  0004f	8b 55 ec	 mov	 edx, DWORD PTR __Old$[ebp]
  00052	52		 push	 edx
  00053	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@Uhandle_deleter@@PAX$00@std@@QAEAAUhandle_deleter@@XZ ; std::_Compressed_pair<handle_deleter,void *,1>::_Get_first
  0005b	8b c8		 mov	 ecx, eax
  0005d	e8 00 00 00 00	 call	 ??Rhandle_deleter@@QBEXPAX@Z ; handle_deleter::operator()
$LN1@reset:

; 1911 :         }
; 1912 :     }

  00062	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00065	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006c	59		 pop	 ecx
  0006d	83 c4 14	 add	 esp, 20			; 00000014H
  00070	3b ec		 cmp	 ebp, esp
  00072	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?reset@?$unique_ptr@XUhandle_deleter@@@std@@QAEXPAX@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?reset@?$unique_ptr@XUhandle_deleter@@@std@@QAEXPAX@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?reset@?$unique_ptr@XUhandle_deleter@@@std@@QAEXPAX@Z ENDP ; std::unique_ptr<void,handle_deleter>::reset
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\memory
;	COMDAT ?release@?$unique_ptr@XUhandle_deleter@@@std@@QAEPAXXZ
_TEXT	SEGMENT
$T2 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?release@?$unique_ptr@XUhandle_deleter@@@std@@QAEPAXXZ PROC ; std::unique_ptr<void,handle_deleter>::release, COMDAT
; _this$ = ecx

; 1903 :     pointer release() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?release@?$unique_ptr@XUhandle_deleter@@@std@@QAEPAXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	c7 45 ec cc cc
	cc cc		 mov	 DWORD PTR [ebp-20], -858993460 ; ccccccccH
  0001b	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00027	33 c5		 xor	 eax, ebp
  00029	50		 push	 eax
  0002a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0002d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00033	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1904 :         return _STD exchange(_Mypair._Myval2, pointer());

  00036	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  0003d	8d 45 ec	 lea	 eax, DWORD PTR $T2[ebp]
  00040	50		 push	 eax
  00041	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	51		 push	 ecx
  00045	e8 00 00 00 00	 call	 ??$exchange@PAXPAX@std@@YAPAXAAPAX$$QAPAX@Z ; std::exchange<void *,void *>
  0004a	83 c4 08	 add	 esp, 8

; 1905 :     }

  0004d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00050	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00057	59		 pop	 ecx
  00058	83 c4 14	 add	 esp, 20			; 00000014H
  0005b	3b ec		 cmp	 ebp, esp
  0005d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?release@?$unique_ptr@XUhandle_deleter@@@std@@QAEPAXXZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?release@?$unique_ptr@XUhandle_deleter@@@std@@QAEPAXXZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?release@?$unique_ptr@XUhandle_deleter@@@std@@QAEPAXXZ ENDP ; std::unique_ptr<void,handle_deleter>::release
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\memory
;	COMDAT ??B?$unique_ptr@XUhandle_deleter@@@std@@QBE_NXZ
_TEXT	SEGMENT
tv67 = -5						; size = 1
_this$ = -4						; size = 4
??B?$unique_ptr@XUhandle_deleter@@@std@@QBE_NXZ PROC	; std::unique_ptr<void,handle_deleter>::operator bool, COMDAT
; _this$ = ecx

; 1899 :     explicit operator bool() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1900 :         return static_cast<bool>(_Mypair._Myval2);

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0001d	74 06		 je	 SHORT $LN3@operator
  0001f	c6 45 fb 01	 mov	 BYTE PTR tv67[ebp], 1
  00023	eb 04		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00025	c6 45 fb 00	 mov	 BYTE PTR tv67[ebp], 0
$LN4@operator:
  00029	8a 45 fb	 mov	 al, BYTE PTR tv67[ebp]

; 1901 :     }

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
??B?$unique_ptr@XUhandle_deleter@@@std@@QBE_NXZ ENDP	; std::unique_ptr<void,handle_deleter>::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\memory
;	COMDAT ?get@?$unique_ptr@XUhandle_deleter@@@std@@QBEPAXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$unique_ptr@XUhandle_deleter@@@std@@QBEPAXXZ PROC	; std::unique_ptr<void,handle_deleter>::get, COMDAT
; _this$ = ecx

; 1895 :     _NODISCARD pointer get() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1896 :         return _Mypair._Myval2;

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 00		 mov	 eax, DWORD PTR [eax]

; 1897 :     }

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?get@?$unique_ptr@XUhandle_deleter@@@std@@QBEPAXXZ ENDP	; std::unique_ptr<void,handle_deleter>::get
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\memory
;	COMDAT ??1?$unique_ptr@XUhandle_deleter@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$unique_ptr@XUhandle_deleter@@@std@@QAE@XZ PROC	; std::unique_ptr<void,handle_deleter>::~unique_ptr<void,handle_deleter>, COMDAT
; _this$ = ecx

; 1873 :     ~unique_ptr() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$unique_ptr@XUhandle_deleter@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1874 :         if (_Mypair._Myval2) {

  0002d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 38 00	 cmp	 DWORD PTR [eax], 0
  00033	74 15		 je	 SHORT $LN1@unique_ptr

; 1875 :             _Mypair._Get_first()(_Mypair._Myval2);

  00035	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	8b 11		 mov	 edx, DWORD PTR [ecx]
  0003a	52		 push	 edx
  0003b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@Uhandle_deleter@@PAX$00@std@@QAEAAUhandle_deleter@@XZ ; std::_Compressed_pair<handle_deleter,void *,1>::_Get_first
  00043	8b c8		 mov	 ecx, eax
  00045	e8 00 00 00 00	 call	 ??Rhandle_deleter@@QBEXPAX@Z ; handle_deleter::operator()
$LN1@unique_ptr:

; 1876 :         }
; 1877 :     }

  0004a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00054	59		 pop	 ecx
  00055	83 c4 10	 add	 esp, 16			; 00000010H
  00058	3b ec		 cmp	 ebp, esp
  0005a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$unique_ptr@XUhandle_deleter@@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$unique_ptr@XUhandle_deleter@@@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$unique_ptr@XUhandle_deleter@@@std@@QAE@XZ ENDP	; std::unique_ptr<void,handle_deleter>::~unique_ptr<void,handle_deleter>
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\memory
;	COMDAT ??4?$unique_ptr@XUhandle_deleter@@@std@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??4?$unique_ptr@XUhandle_deleter@@@std@@QAEAAV01@$$QAV01@@Z PROC ; std::unique_ptr<void,handle_deleter>::operator=, COMDAT
; _this$ = ecx

; 1860 :     unique_ptr& operator=(unique_ptr&& _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1861 :         if (this != _STD addressof(_Right)) {

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$addressof@V?$unique_ptr@XUhandle_deleter@@@std@@@std@@YAPAV?$unique_ptr@XUhandle_deleter@@@0@AAV10@@Z ; std::addressof<std::unique_ptr<void,handle_deleter> >
  00017	83 c4 04	 add	 esp, 4
  0001a	39 45 fc	 cmp	 DWORD PTR _this$[ebp], eax
  0001d	74 2a		 je	 SHORT $LN2@operator

; 1862 :             reset(_Right.release());

  0001f	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00022	e8 00 00 00 00	 call	 ?release@?$unique_ptr@XUhandle_deleter@@@std@@QAEPAXXZ ; std::unique_ptr<void,handle_deleter>::release
  00027	50		 push	 eax
  00028	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	e8 00 00 00 00	 call	 ?reset@?$unique_ptr@XUhandle_deleter@@@std@@QAEXPAX@Z ; std::unique_ptr<void,handle_deleter>::reset

; 1863 :             _Mypair._Get_first() = _STD forward<_Dx>(_Right._Mypair._Get_first());

  00030	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00033	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@Uhandle_deleter@@PAX$00@std@@QAEAAUhandle_deleter@@XZ ; std::_Compressed_pair<handle_deleter,void *,1>::_Get_first
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ??$forward@Uhandle_deleter@@@std@@YA$$QAUhandle_deleter@@AAU1@@Z ; std::forward<handle_deleter>
  0003e	83 c4 04	 add	 esp, 4
  00041	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@Uhandle_deleter@@PAX$00@std@@QAEAAUhandle_deleter@@XZ ; std::_Compressed_pair<handle_deleter,void *,1>::_Get_first
$LN2@operator:

; 1864 :         }
; 1865 :         return *this;

  00049	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1866 :     }

  0004c	83 c4 04	 add	 esp, 4
  0004f	3b ec		 cmp	 ebp, esp
  00051	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c2 04 00	 ret	 4
??4?$unique_ptr@XUhandle_deleter@@@std@@QAEAAV01@$$QAV01@@Z ENDP ; std::unique_ptr<void,handle_deleter>::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\rgy_perf_monitor.cpp
_TEXT	SEGMENT
$T2 = -64						; size = 4
_i$3 = -60						; size = 4
_str$ = -52						; size = 28
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_select$ = 12						; size = 4
?SelectedCounters@CPerfMonitor@@IAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z PROC ; CPerfMonitor::SelectedCounters
; _this$ = ecx

; 451  : tstring CPerfMonitor::SelectedCounters(int select) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?SelectedCounters@CPerfMonitor@@IAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 34	 sub	 esp, 52			; 00000034H
  00014	57		 push	 edi
  00015	51		 push	 ecx
  00016	8d 7d c0	 lea	 edi, DWORD PTR [ebp-64]
  00019	b9 0d 00 00 00	 mov	 ecx, 13			; 0000000dH
  0001e	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00023	f3 ab		 rep stosd
  00025	59		 pop	 ecx
  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002b	33 c5		 xor	 eax, ebp
  0002d	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00030	50		 push	 eax
  00031	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00034	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003a	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  0003d	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0

; 452  :     if (select == 0) {

  00044	83 7d 0c 00	 cmp	 DWORD PTR _select$[ebp], 0
  00048	75 25		 jne	 SHORT $LN5@SelectedCo

; 453  :         return _T("none");

  0004a	68 00 00 00 00	 push	 OFFSET $SG118036
  0004f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00052	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00057	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0005e	8b 45 c0	 mov	 eax, DWORD PTR $T2[ebp]
  00061	83 c8 01	 or	 eax, 1
  00064	89 45 c0	 mov	 DWORD PTR $T2[ebp], eax
  00067	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0006a	e9 b1 00 00 00	 jmp	 $LN1@SelectedCo
$LN5@SelectedCo:

; 454  :     }
; 455  :     tstring str;

  0006f	8d 4d cc	 lea	 ecx, DWORD PTR _str$[ebp]
  00072	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00077	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 456  :     for (uint32_t i = 0; i < _countof(list_pref_monitor); i++) {

  0007e	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _i$3[ebp], 0
  00085	eb 09		 jmp	 SHORT $LN4@SelectedCo
$LN2@SelectedCo:
  00087	8b 4d c4	 mov	 ecx, DWORD PTR _i$3[ebp]
  0008a	83 c1 01	 add	 ecx, 1
  0008d	89 4d c4	 mov	 DWORD PTR _i$3[ebp], ecx
$LN4@SelectedCo:
  00090	83 7d c4 1f	 cmp	 DWORD PTR _i$3[ebp], 31	; 0000001fH
  00094	73 66		 jae	 SHORT $LN3@SelectedCo

; 457  :         if (list_pref_monitor[i].desc &&

  00096	8b 55 c4	 mov	 edx, DWORD PTR _i$3[ebp]
  00099	83 3c d5 00 00
	00 00 00	 cmp	 DWORD PTR ?list_pref_monitor@@3QBUCX_DESC@@B[edx*8], 0
  000a1	74 57		 je	 SHORT $LN6@SelectedCo
  000a3	8b 45 c4	 mov	 eax, DWORD PTR _i$3[ebp]
  000a6	8b 4d 0c	 mov	 ecx, DWORD PTR _select$[ebp]
  000a9	23 0c c5 04 00
	00 00		 and	 ecx, DWORD PTR ?list_pref_monitor@@3QBUCX_DESC@@B[eax*8+4]
  000b0	8b 55 c4	 mov	 edx, DWORD PTR _i$3[ebp]
  000b3	3b 0c d5 04 00
	00 00		 cmp	 ecx, DWORD PTR ?list_pref_monitor@@3QBUCX_DESC@@B[edx*8+4]
  000ba	75 3e		 jne	 SHORT $LN6@SelectedCo

; 458  :             (select & list_pref_monitor[i].value) == list_pref_monitor[i].value) {
; 459  :             if (str.length()) {

  000bc	8d 4d cc	 lea	 ecx, DWORD PTR _str$[ebp]
  000bf	e8 00 00 00 00	 call	 ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
  000c4	85 c0		 test	 eax, eax
  000c6	74 0d		 je	 SHORT $LN7@SelectedCo

; 460  :                 str += _T(",");

  000c8	68 00 00 00 00	 push	 OFFSET $SG118039
  000cd	8d 4d cc	 lea	 ecx, DWORD PTR _str$[ebp]
  000d0	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
$LN7@SelectedCo:

; 461  :             }
; 462  :             str += list_pref_monitor[i].desc;

  000d5	8b 45 c4	 mov	 eax, DWORD PTR _i$3[ebp]
  000d8	8b 0c c5 00 00
	00 00		 mov	 ecx, DWORD PTR ?list_pref_monitor@@3QBUCX_DESC@@B[eax*8]
  000df	51		 push	 ecx
  000e0	8d 4d cc	 lea	 ecx, DWORD PTR _str$[ebp]
  000e3	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=

; 463  :             select &= ~(list_pref_monitor[i].value);

  000e8	8b 55 c4	 mov	 edx, DWORD PTR _i$3[ebp]
  000eb	8b 04 d5 04 00
	00 00		 mov	 eax, DWORD PTR ?list_pref_monitor@@3QBUCX_DESC@@B[edx*8+4]
  000f2	f7 d0		 not	 eax
  000f4	23 45 0c	 and	 eax, DWORD PTR _select$[ebp]
  000f7	89 45 0c	 mov	 DWORD PTR _select$[ebp], eax
$LN6@SelectedCo:

; 464  :         }
; 465  :     }

  000fa	eb 8b		 jmp	 SHORT $LN2@SelectedCo
$LN3@SelectedCo:

; 466  :     return str;

  000fc	8d 4d cc	 lea	 ecx, DWORD PTR _str$[ebp]
  000ff	51		 push	 ecx
  00100	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00103	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00108	8b 55 c0	 mov	 edx, DWORD PTR $T2[ebp]
  0010b	83 ca 01	 or	 edx, 1
  0010e	89 55 c0	 mov	 DWORD PTR $T2[ebp], edx
  00111	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00115	8d 4d cc	 lea	 ecx, DWORD PTR _str$[ebp]
  00118	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0011d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN1@SelectedCo:

; 467  : }

  00120	52		 push	 edx
  00121	8b cd		 mov	 ecx, ebp
  00123	50		 push	 eax
  00124	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN15@SelectedCo
  0012a	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0012f	58		 pop	 eax
  00130	5a		 pop	 edx
  00131	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00134	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0013b	59		 pop	 ecx
  0013c	5f		 pop	 edi
  0013d	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00140	33 cd		 xor	 ecx, ebp
  00142	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00147	83 c4 40	 add	 esp, 64			; 00000040H
  0014a	3b ec		 cmp	 ebp, esp
  0014c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00151	8b e5		 mov	 esp, ebp
  00153	5d		 pop	 ebp
  00154	c2 08 00	 ret	 8
  00157	90		 npad	 1
$LN15@SelectedCo:
  00158	01 00 00 00	 DD	 1
  0015c	00 00 00 00	 DD	 $LN14@SelectedCo
$LN14@SelectedCo:
  00160	cc ff ff ff	 DD	 -52			; ffffffccH
  00164	1c 00 00 00	 DD	 28			; 0000001cH
  00168	00 00 00 00	 DD	 $LN12@SelectedCo
$LN12@SelectedCo:
  0016c	73		 DB	 115			; 00000073H
  0016d	74		 DB	 116			; 00000074H
  0016e	72		 DB	 114			; 00000072H
  0016f	00		 DB	 0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?SelectedCounters@CPerfMonitor@@IAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z$0:
  00000	8b 45 c0	 mov	 eax, DWORD PTR $T2[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0c 00 00
	00		 je	 $LN10@SelectedCo
  0000c	83 65 c0 fe	 and	 DWORD PTR $T2[ebp], -2	; fffffffeH
  00010	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN10@SelectedCo:
  00018	c3		 ret	 0
__unwindfunclet$?SelectedCounters@CPerfMonitor@@IAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z$1:
  00019	8d 4d cc	 lea	 ecx, DWORD PTR _str$[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?SelectedCounters@CPerfMonitor@@IAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z:
  00021	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00025	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00028	8b 4a c4	 mov	 ecx, DWORD PTR [edx-60]
  0002b	33 c8		 xor	 ecx, eax
  0002d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00032	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00035	33 c8		 xor	 ecx, eax
  00037	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SelectedCounters@CPerfMonitor@@IAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z
  00041	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SelectedCounters@CPerfMonitor@@IAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ENDP ; CPerfMonitor::SelectedCounters
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\rgy_perf_monitor.cpp
_TEXT	SEGMENT
_prm$ = 8						; size = 4
?loader@CPerfMonitor@@KAXPAX@Z PROC			; CPerfMonitor::loader

; 1243 : void CPerfMonitor::loader(void *prm) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1244 :     reinterpret_cast<CPerfMonitor*>(prm)->run();

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _prm$[ebp]
  00006	e8 00 00 00 00	 call	 ?run@CPerfMonitor@@IAEXXZ ; CPerfMonitor::run

; 1245 : }

  0000b	3b ec		 cmp	 ebp, esp
  0000d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?loader@CPerfMonitor@@KAXPAX@Z ENDP			; CPerfMonitor::loader
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\rgy_perf_monitor.cpp
_TEXT	SEGMENT
tv600 = -1176						; size = 4
tv630 = -1172						; size = 4
tv598 = -1168						; size = 4
tv629 = -1164						; size = 4
tv596 = -1160						; size = 4
tv628 = -1156						; size = 4
tv594 = -1152						; size = 4
tv627 = -1148						; size = 4
tv592 = -1144						; size = 4
tv626 = -1140						; size = 4
tv590 = -1136						; size = 4
tv625 = -1132						; size = 4
tv588 = -1128						; size = 4
tv624 = -1124						; size = 4
tv586 = -1120						; size = 4
tv623 = -1116						; size = 4
tv584 = -1112						; size = 4
tv622 = -1108						; size = 4
tv582 = -1104						; size = 4
tv621 = -1100						; size = 4
tv580 = -1096						; size = 4
tv620 = -1092						; size = 4
tv578 = -1088						; size = 4
tv619 = -1084						; size = 4
tv576 = -1080						; size = 4
tv618 = -1076						; size = 4
tv574 = -1072						; size = 4
tv617 = -1068						; size = 4
tv572 = -1064						; size = 4
tv616 = -1060						; size = 4
tv570 = -1056						; size = 4
tv615 = -1052						; size = 4
tv568 = -1048						; size = 4
tv614 = -1044						; size = 4
tv566 = -1040						; size = 4
tv613 = -1036						; size = 4
tv564 = -1032						; size = 4
tv612 = -1028						; size = 4
tv562 = -1024						; size = 4
tv611 = -1020						; size = 4
tv560 = -1016						; size = 4
tv610 = -1012						; size = 4
tv558 = -1008						; size = 4
tv609 = -1004						; size = 4
tv556 = -1000						; size = 4
tv608 = -996						; size = 4
tv554 = -992						; size = 4
tv607 = -988						; size = 4
tv552 = -984						; size = 4
tv606 = -980						; size = 4
tv550 = -976						; size = 4
tv605 = -972						; size = 4
tv548 = -968						; size = 4
tv604 = -964						; size = 4
tv546 = -960						; size = 4
tv603 = -956						; size = 4
tv544 = -952						; size = 4
tv602 = -948						; size = 4
tv510 = -944						; size = 4
tv601 = -940						; size = 4
tv508 = -936						; size = 4
tv71 = -932						; size = 4
$T2 = -928						; size = 28
$T3 = -900						; size = 28
$T4 = -872						; size = 28
$T5 = -844						; size = 28
$T6 = -816						; size = 28
$T7 = -788						; size = 28
$T8 = -760						; size = 28
$T9 = -732						; size = 28
$T10 = -704						; size = 28
$T11 = -676						; size = 28
$T12 = -648						; size = 28
$T13 = -620						; size = 28
$T14 = -592						; size = 28
$T15 = -564						; size = 28
$T16 = -536						; size = 28
$T17 = -508						; size = 28
$T18 = -480						; size = 28
$T19 = -452						; size = 28
$T20 = -424						; size = 28
$T21 = -396						; size = 28
$T22 = -368						; size = 28
$T23 = -340						; size = 28
$T24 = -312						; size = 28
$T25 = -284						; size = 28
$T26 = -256						; size = 28
$T27 = -228						; size = 28
$T28 = -200						; size = 28
$T29 = -172						; size = 28
$T30 = -144						; size = 28
$T31 = -116						; size = 28
$T32 = -88						; size = 28
_str$ = -56						; size = 28
_pInfo$ = -24						; size = 4
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_fp$ = 8						; size = 4
_nSelect$ = 12						; size = 4
?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z PROC		; CPerfMonitor::write
; _this$ = ecx

; 1141 : void CPerfMonitor::write(FILE *fp, int nSelect) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 8c 04 00
	00		 sub	 esp, 1164		; 0000048cH
  00017	56		 push	 esi
  00018	57		 push	 edi
  00019	51		 push	 ecx
  0001a	8d bd 68 fb ff
	ff		 lea	 edi, DWORD PTR [ebp-1176]
  00020	b9 23 01 00 00	 mov	 ecx, 291		; 00000123H
  00025	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002a	f3 ab		 rep stosd
  0002c	59		 pop	 ecx
  0002d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00032	33 c5		 xor	 eax, ebp
  00034	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00037	50		 push	 eax
  00038	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0003b	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00041	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 1142 :     if (fp == NULL) {

  00044	83 7d 08 00	 cmp	 DWORD PTR _fp$[ebp], 0
  00048	75 05		 jne	 SHORT $LN2@write

; 1143 :         return;

  0004a	e9 b9 0c 00 00	 jmp	 $LN1@write
$LN2@write:

; 1144 :     }
; 1145 :     const PerfInfo *pInfo = &m_info[m_nStep & 1];

  0004f	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00052	8b 08		 mov	 ecx, DWORD PTR [eax]
  00054	83 e1 01	 and	 ecx, 1
  00057	69 d1 38 01 00
	00		 imul	 edx, ecx, 312
  0005d	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00060	8d 4c 10 20	 lea	 ecx, DWORD PTR [eax+edx+32]
  00064	89 4d e8	 mov	 DWORD PTR _pInfo$[ebp], ecx

; 1146 :     std::string str = strsprintf("%lf", pInfo->time_us * 1e-6);

  00067	8b 55 e8	 mov	 edx, DWORD PTR _pInfo$[ebp]
  0006a	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0006c	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  0006f	e8 00 00 00 00	 call	 __ltod3
  00074	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3eb0c6f7a0b5ed8d
  0007c	83 ec 08	 sub	 esp, 8
  0007f	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00084	68 00 00 00 00	 push	 OFFSET $SG119208
  00089	8d 45 c8	 lea	 eax, DWORD PTR _str$[ebp]
  0008c	50		 push	 eax
  0008d	e8 00 00 00 00	 call	 ?strsprintf@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; strsprintf
  00092	83 c4 10	 add	 esp, 16			; 00000010H
  00095	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1147 :     if (nSelect & PERF_MONITOR_CPU) {

  0009c	8b 4d 0c	 mov	 ecx, DWORD PTR _nSelect$[ebp]
  0009f	83 e1 01	 and	 ecx, 1
  000a2	74 55		 je	 SHORT $LN3@write

; 1148 :         str += strsprintf(",%lf", pInfo->cpu_percent);

  000a4	8b 55 e8	 mov	 edx, DWORD PTR _pInfo$[ebp]
  000a7	83 ec 08	 sub	 esp, 8
  000aa	f2 0f 10 82 b0
	00 00 00	 movsd	 xmm0, QWORD PTR [edx+176]
  000b2	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  000b7	68 00 00 00 00	 push	 OFFSET $SG119210
  000bc	8d 45 a8	 lea	 eax, DWORD PTR $T32[ebp]
  000bf	50		 push	 eax
  000c0	e8 00 00 00 00	 call	 ?strsprintf@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; strsprintf
  000c5	83 c4 10	 add	 esp, 16			; 00000010H
  000c8	89 85 5c fc ff
	ff		 mov	 DWORD PTR tv71[ebp], eax
  000ce	8b 8d 5c fc ff
	ff		 mov	 ecx, DWORD PTR tv71[ebp]
  000d4	89 8d 58 fc ff
	ff		 mov	 DWORD PTR tv508[ebp], ecx
  000da	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  000de	8b 95 58 fc ff
	ff		 mov	 edx, DWORD PTR tv508[ebp]
  000e4	52		 push	 edx
  000e5	8d 4d c8	 lea	 ecx, DWORD PTR _str$[ebp]
  000e8	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
  000ed	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  000f1	8d 4d a8	 lea	 ecx, DWORD PTR $T32[ebp]
  000f4	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN3@write:

; 1149 :     }
; 1150 :     if (nSelect & PERF_MONITOR_CPU_KERNEL) {

  000f9	8b 45 0c	 mov	 eax, DWORD PTR _nSelect$[ebp]
  000fc	83 e0 02	 and	 eax, 2
  000ff	74 55		 je	 SHORT $LN4@write

; 1151 :         str += strsprintf(",%lf", pInfo->cpu_kernel_percent);

  00101	8b 4d e8	 mov	 ecx, DWORD PTR _pInfo$[ebp]
  00104	83 ec 08	 sub	 esp, 8
  00107	f2 0f 10 81 b8
	00 00 00	 movsd	 xmm0, QWORD PTR [ecx+184]
  0010f	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00114	68 00 00 00 00	 push	 OFFSET $SG119212
  00119	8d 55 8c	 lea	 edx, DWORD PTR $T31[ebp]
  0011c	52		 push	 edx
  0011d	e8 00 00 00 00	 call	 ?strsprintf@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; strsprintf
  00122	83 c4 10	 add	 esp, 16			; 00000010H
  00125	89 85 54 fc ff
	ff		 mov	 DWORD PTR tv601[ebp], eax
  0012b	8b 85 54 fc ff
	ff		 mov	 eax, DWORD PTR tv601[ebp]
  00131	89 85 50 fc ff
	ff		 mov	 DWORD PTR tv510[ebp], eax
  00137	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0013b	8b 8d 50 fc ff
	ff		 mov	 ecx, DWORD PTR tv510[ebp]
  00141	51		 push	 ecx
  00142	8d 4d c8	 lea	 ecx, DWORD PTR _str$[ebp]
  00145	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
  0014a	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0014e	8d 4d 8c	 lea	 ecx, DWORD PTR $T31[ebp]
  00151	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN4@write:

; 1152 :     }
; 1153 :     if (nSelect & PERF_MONITOR_THREAD_MAIN) {

  00156	8b 55 0c	 mov	 edx, DWORD PTR _nSelect$[ebp]
  00159	81 e2 00 04 00
	00		 and	 edx, 1024		; 00000400H
  0015f	74 5b		 je	 SHORT $LN5@write

; 1154 :         str += strsprintf(",%lf", pInfo->main_thread_percent);

  00161	8b 45 e8	 mov	 eax, DWORD PTR _pInfo$[ebp]
  00164	83 ec 08	 sub	 esp, 8
  00167	f2 0f 10 80 c0
	00 00 00	 movsd	 xmm0, QWORD PTR [eax+192]
  0016f	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00174	68 00 00 00 00	 push	 OFFSET $SG119214
  00179	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR $T30[ebp]
  0017f	51		 push	 ecx
  00180	e8 00 00 00 00	 call	 ?strsprintf@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; strsprintf
  00185	83 c4 10	 add	 esp, 16			; 00000010H
  00188	89 85 4c fc ff
	ff		 mov	 DWORD PTR tv602[ebp], eax
  0018e	8b 95 4c fc ff
	ff		 mov	 edx, DWORD PTR tv602[ebp]
  00194	89 95 48 fc ff
	ff		 mov	 DWORD PTR tv544[ebp], edx
  0019a	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  0019e	8b 85 48 fc ff
	ff		 mov	 eax, DWORD PTR tv544[ebp]
  001a4	50		 push	 eax
  001a5	8d 4d c8	 lea	 ecx, DWORD PTR _str$[ebp]
  001a8	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
  001ad	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  001b1	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR $T30[ebp]
  001b7	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN5@write:

; 1155 :     }
; 1156 :     if (nSelect & PERF_MONITOR_THREAD_ENC) {

  001bc	8b 4d 0c	 mov	 ecx, DWORD PTR _nSelect$[ebp]
  001bf	81 e1 00 08 00
	00		 and	 ecx, 2048		; 00000800H
  001c5	74 5b		 je	 SHORT $LN6@write

; 1157 :         str += strsprintf(",%lf", pInfo->enc_thread_percent);

  001c7	8b 55 e8	 mov	 edx, DWORD PTR _pInfo$[ebp]
  001ca	83 ec 08	 sub	 esp, 8
  001cd	f2 0f 10 82 c8
	00 00 00	 movsd	 xmm0, QWORD PTR [edx+200]
  001d5	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  001da	68 00 00 00 00	 push	 OFFSET $SG119216
  001df	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR $T29[ebp]
  001e5	50		 push	 eax
  001e6	e8 00 00 00 00	 call	 ?strsprintf@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; strsprintf
  001eb	83 c4 10	 add	 esp, 16			; 00000010H
  001ee	89 85 44 fc ff
	ff		 mov	 DWORD PTR tv603[ebp], eax
  001f4	8b 8d 44 fc ff
	ff		 mov	 ecx, DWORD PTR tv603[ebp]
  001fa	89 8d 40 fc ff
	ff		 mov	 DWORD PTR tv546[ebp], ecx
  00200	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  00204	8b 95 40 fc ff
	ff		 mov	 edx, DWORD PTR tv546[ebp]
  0020a	52		 push	 edx
  0020b	8d 4d c8	 lea	 ecx, DWORD PTR _str$[ebp]
  0020e	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
  00213	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00217	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR $T29[ebp]
  0021d	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN6@write:

; 1158 :     }
; 1159 :     if (nSelect & PERF_MONITOR_THREAD_AUDP) {

  00222	8b 45 0c	 mov	 eax, DWORD PTR _nSelect$[ebp]
  00225	25 00 10 00 00	 and	 eax, 4096		; 00001000H
  0022a	74 5b		 je	 SHORT $LN7@write

; 1160 :         str += strsprintf(",%lf", pInfo->aud_proc_thread_percent);

  0022c	8b 4d e8	 mov	 ecx, DWORD PTR _pInfo$[ebp]
  0022f	83 ec 08	 sub	 esp, 8
  00232	f2 0f 10 81 d0
	00 00 00	 movsd	 xmm0, QWORD PTR [ecx+208]
  0023a	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0023f	68 00 00 00 00	 push	 OFFSET $SG119218
  00244	8d 95 38 ff ff
	ff		 lea	 edx, DWORD PTR $T28[ebp]
  0024a	52		 push	 edx
  0024b	e8 00 00 00 00	 call	 ?strsprintf@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; strsprintf
  00250	83 c4 10	 add	 esp, 16			; 00000010H
  00253	89 85 3c fc ff
	ff		 mov	 DWORD PTR tv604[ebp], eax
  00259	8b 85 3c fc ff
	ff		 mov	 eax, DWORD PTR tv604[ebp]
  0025f	89 85 38 fc ff
	ff		 mov	 DWORD PTR tv548[ebp], eax
  00265	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  00269	8b 8d 38 fc ff
	ff		 mov	 ecx, DWORD PTR tv548[ebp]
  0026f	51		 push	 ecx
  00270	8d 4d c8	 lea	 ecx, DWORD PTR _str$[ebp]
  00273	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
  00278	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0027c	8d 8d 38 ff ff
	ff		 lea	 ecx, DWORD PTR $T28[ebp]
  00282	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN7@write:

; 1161 :     }
; 1162 :     if (nSelect & PERF_MONITOR_THREAD_AUDE) {

  00287	8b 55 0c	 mov	 edx, DWORD PTR _nSelect$[ebp]
  0028a	81 e2 00 20 00
	00		 and	 edx, 8192		; 00002000H
  00290	74 5b		 je	 SHORT $LN8@write

; 1163 :         str += strsprintf(",%lf", pInfo->aud_enc_thread_percent);

  00292	8b 45 e8	 mov	 eax, DWORD PTR _pInfo$[ebp]
  00295	83 ec 08	 sub	 esp, 8
  00298	f2 0f 10 80 d8
	00 00 00	 movsd	 xmm0, QWORD PTR [eax+216]
  002a0	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  002a5	68 00 00 00 00	 push	 OFFSET $SG119220
  002aa	8d 8d 1c ff ff
	ff		 lea	 ecx, DWORD PTR $T27[ebp]
  002b0	51		 push	 ecx
  002b1	e8 00 00 00 00	 call	 ?strsprintf@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; strsprintf
  002b6	83 c4 10	 add	 esp, 16			; 00000010H
  002b9	89 85 34 fc ff
	ff		 mov	 DWORD PTR tv605[ebp], eax
  002bf	8b 95 34 fc ff
	ff		 mov	 edx, DWORD PTR tv605[ebp]
  002c5	89 95 30 fc ff
	ff		 mov	 DWORD PTR tv550[ebp], edx
  002cb	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  002cf	8b 85 30 fc ff
	ff		 mov	 eax, DWORD PTR tv550[ebp]
  002d5	50		 push	 eax
  002d6	8d 4d c8	 lea	 ecx, DWORD PTR _str$[ebp]
  002d9	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
  002de	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  002e2	8d 8d 1c ff ff
	ff		 lea	 ecx, DWORD PTR $T27[ebp]
  002e8	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN8@write:

; 1164 :     }
; 1165 :     if (nSelect & PERF_MONITOR_THREAD_IN) {

  002ed	8b 4d 0c	 mov	 ecx, DWORD PTR _nSelect$[ebp]
  002f0	81 e1 00 80 00
	00		 and	 ecx, 32768		; 00008000H
  002f6	74 5b		 je	 SHORT $LN9@write

; 1166 :         str += strsprintf(",%lf", pInfo->in_thread_percent);

  002f8	8b 55 e8	 mov	 edx, DWORD PTR _pInfo$[ebp]
  002fb	83 ec 08	 sub	 esp, 8
  002fe	f2 0f 10 82 e8
	00 00 00	 movsd	 xmm0, QWORD PTR [edx+232]
  00306	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0030b	68 00 00 00 00	 push	 OFFSET $SG119222
  00310	8d 85 00 ff ff
	ff		 lea	 eax, DWORD PTR $T26[ebp]
  00316	50		 push	 eax
  00317	e8 00 00 00 00	 call	 ?strsprintf@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; strsprintf
  0031c	83 c4 10	 add	 esp, 16			; 00000010H
  0031f	89 85 2c fc ff
	ff		 mov	 DWORD PTR tv606[ebp], eax
  00325	8b 8d 2c fc ff
	ff		 mov	 ecx, DWORD PTR tv606[ebp]
  0032b	89 8d 28 fc ff
	ff		 mov	 DWORD PTR tv552[ebp], ecx
  00331	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  00335	8b 95 28 fc ff
	ff		 mov	 edx, DWORD PTR tv552[ebp]
  0033b	52		 push	 edx
  0033c	8d 4d c8	 lea	 ecx, DWORD PTR _str$[ebp]
  0033f	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
  00344	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00348	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR $T26[ebp]
  0034e	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN9@write:

; 1167 :     }
; 1168 :     if (nSelect & PERF_MONITOR_THREAD_OUT) {

  00353	8b 45 0c	 mov	 eax, DWORD PTR _nSelect$[ebp]
  00356	25 00 40 00 00	 and	 eax, 16384		; 00004000H
  0035b	74 5b		 je	 SHORT $LN10@write

; 1169 :         str += strsprintf(",%lf", pInfo->out_thread_percent);

  0035d	8b 4d e8	 mov	 ecx, DWORD PTR _pInfo$[ebp]
  00360	83 ec 08	 sub	 esp, 8
  00363	f2 0f 10 81 e0
	00 00 00	 movsd	 xmm0, QWORD PTR [ecx+224]
  0036b	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00370	68 00 00 00 00	 push	 OFFSET $SG119224
  00375	8d 95 e4 fe ff
	ff		 lea	 edx, DWORD PTR $T25[ebp]
  0037b	52		 push	 edx
  0037c	e8 00 00 00 00	 call	 ?strsprintf@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; strsprintf
  00381	83 c4 10	 add	 esp, 16			; 00000010H
  00384	89 85 24 fc ff
	ff		 mov	 DWORD PTR tv607[ebp], eax
  0038a	8b 85 24 fc ff
	ff		 mov	 eax, DWORD PTR tv607[ebp]
  00390	89 85 20 fc ff
	ff		 mov	 DWORD PTR tv554[ebp], eax
  00396	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  0039a	8b 8d 20 fc ff
	ff		 mov	 ecx, DWORD PTR tv554[ebp]
  003a0	51		 push	 ecx
  003a1	8d 4d c8	 lea	 ecx, DWORD PTR _str$[ebp]
  003a4	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
  003a9	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  003ad	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR $T25[ebp]
  003b3	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN10@write:

; 1170 :     }
; 1171 :     if (nSelect & PERF_MONITOR_GPU_LOAD) {

  003b8	8b 55 0c	 mov	 edx, DWORD PTR _nSelect$[ebp]
  003bb	81 e2 00 00 04
	00		 and	 edx, 262144		; 00040000H
  003c1	74 5b		 je	 SHORT $LN11@write

; 1172 :         str += strsprintf(",%lf", pInfo->gpu_load_percent);

  003c3	8b 45 e8	 mov	 eax, DWORD PTR _pInfo$[ebp]
  003c6	83 ec 08	 sub	 esp, 8
  003c9	f2 0f 10 80 f8
	00 00 00	 movsd	 xmm0, QWORD PTR [eax+248]
  003d1	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  003d6	68 00 00 00 00	 push	 OFFSET $SG119226
  003db	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR $T24[ebp]
  003e1	51		 push	 ecx
  003e2	e8 00 00 00 00	 call	 ?strsprintf@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; strsprintf
  003e7	83 c4 10	 add	 esp, 16			; 00000010H
  003ea	89 85 1c fc ff
	ff		 mov	 DWORD PTR tv608[ebp], eax
  003f0	8b 95 1c fc ff
	ff		 mov	 edx, DWORD PTR tv608[ebp]
  003f6	89 95 18 fc ff
	ff		 mov	 DWORD PTR tv556[ebp], edx
  003fc	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
  00400	8b 85 18 fc ff
	ff		 mov	 eax, DWORD PTR tv556[ebp]
  00406	50		 push	 eax
  00407	8d 4d c8	 lea	 ecx, DWORD PTR _str$[ebp]
  0040a	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
  0040f	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00413	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR $T24[ebp]
  00419	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN11@write:

; 1173 :     }
; 1174 :     if (nSelect & PERF_MONITOR_GPU_CLOCK) {

  0041e	8b 4d 0c	 mov	 ecx, DWORD PTR _nSelect$[ebp]
  00421	81 e1 00 00 08
	00		 and	 ecx, 524288		; 00080000H
  00427	74 5b		 je	 SHORT $LN12@write

; 1175 :         str += strsprintf(",%lf", pInfo->gpu_clock);

  00429	8b 55 e8	 mov	 edx, DWORD PTR _pInfo$[ebp]
  0042c	83 ec 08	 sub	 esp, 8
  0042f	f2 0f 10 82 00
	01 00 00	 movsd	 xmm0, QWORD PTR [edx+256]
  00437	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0043c	68 00 00 00 00	 push	 OFFSET $SG119228
  00441	8d 85 ac fe ff
	ff		 lea	 eax, DWORD PTR $T23[ebp]
  00447	50		 push	 eax
  00448	e8 00 00 00 00	 call	 ?strsprintf@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; strsprintf
  0044d	83 c4 10	 add	 esp, 16			; 00000010H
  00450	89 85 14 fc ff
	ff		 mov	 DWORD PTR tv609[ebp], eax
  00456	8b 8d 14 fc ff
	ff		 mov	 ecx, DWORD PTR tv609[ebp]
  0045c	89 8d 10 fc ff
	ff		 mov	 DWORD PTR tv558[ebp], ecx
  00462	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+8], 10 ; 0000000aH
  00466	8b 95 10 fc ff
	ff		 mov	 edx, DWORD PTR tv558[ebp]
  0046c	52		 push	 edx
  0046d	8d 4d c8	 lea	 ecx, DWORD PTR _str$[ebp]
  00470	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
  00475	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00479	8d 8d ac fe ff
	ff		 lea	 ecx, DWORD PTR $T23[ebp]
  0047f	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN12@write:

; 1176 :     }
; 1177 :     if (nSelect & PERF_MONITOR_MFX_LOAD) {

  00484	8b 45 0c	 mov	 eax, DWORD PTR _nSelect$[ebp]
  00487	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  0048c	74 5b		 je	 SHORT $LN13@write

; 1178 :         str += strsprintf(",%lf", pInfo->mfx_load_percent);

  0048e	8b 4d e8	 mov	 ecx, DWORD PTR _pInfo$[ebp]
  00491	83 ec 08	 sub	 esp, 8
  00494	f2 0f 10 81 08
	01 00 00	 movsd	 xmm0, QWORD PTR [ecx+264]
  0049c	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  004a1	68 00 00 00 00	 push	 OFFSET $SG119230
  004a6	8d 95 90 fe ff
	ff		 lea	 edx, DWORD PTR $T22[ebp]
  004ac	52		 push	 edx
  004ad	e8 00 00 00 00	 call	 ?strsprintf@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; strsprintf
  004b2	83 c4 10	 add	 esp, 16			; 00000010H
  004b5	89 85 0c fc ff
	ff		 mov	 DWORD PTR tv610[ebp], eax
  004bb	8b 85 0c fc ff
	ff		 mov	 eax, DWORD PTR tv610[ebp]
  004c1	89 85 08 fc ff
	ff		 mov	 DWORD PTR tv560[ebp], eax
  004c7	c6 45 fc 0b	 mov	 BYTE PTR __$EHRec$[ebp+8], 11 ; 0000000bH
  004cb	8b 8d 08 fc ff
	ff		 mov	 ecx, DWORD PTR tv560[ebp]
  004d1	51		 push	 ecx
  004d2	8d 4d c8	 lea	 ecx, DWORD PTR _str$[ebp]
  004d5	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
  004da	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  004de	8d 8d 90 fe ff
	ff		 lea	 ecx, DWORD PTR $T22[ebp]
  004e4	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN13@write:

; 1179 :     }
; 1180 :     if (nSelect & PERF_MONITOR_VEE_LOAD) {

  004e9	8b 55 0c	 mov	 edx, DWORD PTR _nSelect$[ebp]
  004ec	81 e2 00 00 00
	04		 and	 edx, 67108864		; 04000000H
  004f2	74 5b		 je	 SHORT $LN14@write

; 1181 :         str += strsprintf(",%lf", pInfo->vee_load_percent);

  004f4	8b 45 e8	 mov	 eax, DWORD PTR _pInfo$[ebp]
  004f7	83 ec 08	 sub	 esp, 8
  004fa	f2 0f 10 80 10
	01 00 00	 movsd	 xmm0, QWORD PTR [eax+272]
  00502	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00507	68 00 00 00 00	 push	 OFFSET $SG119232
  0050c	8d 8d 74 fe ff
	ff		 lea	 ecx, DWORD PTR $T21[ebp]
  00512	51		 push	 ecx
  00513	e8 00 00 00 00	 call	 ?strsprintf@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; strsprintf
  00518	83 c4 10	 add	 esp, 16			; 00000010H
  0051b	89 85 04 fc ff
	ff		 mov	 DWORD PTR tv611[ebp], eax
  00521	8b 95 04 fc ff
	ff		 mov	 edx, DWORD PTR tv611[ebp]
  00527	89 95 00 fc ff
	ff		 mov	 DWORD PTR tv562[ebp], edx
  0052d	c6 45 fc 0c	 mov	 BYTE PTR __$EHRec$[ebp+8], 12 ; 0000000cH
  00531	8b 85 00 fc ff
	ff		 mov	 eax, DWORD PTR tv562[ebp]
  00537	50		 push	 eax
  00538	8d 4d c8	 lea	 ecx, DWORD PTR _str$[ebp]
  0053b	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
  00540	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00544	8d 8d 74 fe ff
	ff		 lea	 ecx, DWORD PTR $T21[ebp]
  0054a	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN14@write:

; 1182 :     }
; 1183 :     if (nSelect & PERF_MONITOR_VED_LOAD) {

  0054f	8b 4d 0c	 mov	 ecx, DWORD PTR _nSelect$[ebp]
  00552	81 e1 00 00 00
	08		 and	 ecx, 134217728		; 08000000H
  00558	74 5b		 je	 SHORT $LN15@write

; 1184 :         str += strsprintf(",%lf", pInfo->ved_load_percent);

  0055a	8b 55 e8	 mov	 edx, DWORD PTR _pInfo$[ebp]
  0055d	83 ec 08	 sub	 esp, 8
  00560	f2 0f 10 82 18
	01 00 00	 movsd	 xmm0, QWORD PTR [edx+280]
  00568	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0056d	68 00 00 00 00	 push	 OFFSET $SG119234
  00572	8d 85 58 fe ff
	ff		 lea	 eax, DWORD PTR $T20[ebp]
  00578	50		 push	 eax
  00579	e8 00 00 00 00	 call	 ?strsprintf@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; strsprintf
  0057e	83 c4 10	 add	 esp, 16			; 00000010H
  00581	89 85 fc fb ff
	ff		 mov	 DWORD PTR tv612[ebp], eax
  00587	8b 8d fc fb ff
	ff		 mov	 ecx, DWORD PTR tv612[ebp]
  0058d	89 8d f8 fb ff
	ff		 mov	 DWORD PTR tv564[ebp], ecx
  00593	c6 45 fc 0d	 mov	 BYTE PTR __$EHRec$[ebp+8], 13 ; 0000000dH
  00597	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR tv564[ebp]
  0059d	52		 push	 edx
  0059e	8d 4d c8	 lea	 ecx, DWORD PTR _str$[ebp]
  005a1	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
  005a6	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  005aa	8d 8d 58 fe ff
	ff		 lea	 ecx, DWORD PTR $T20[ebp]
  005b0	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN15@write:

; 1185 :     }
; 1186 :     if (nSelect & PERF_MONITOR_VE_CLOCK) {

  005b5	8b 45 0c	 mov	 eax, DWORD PTR _nSelect$[ebp]
  005b8	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  005bd	74 5b		 je	 SHORT $LN16@write

; 1187 :         str += strsprintf(",%lf", pInfo->ve_clock);

  005bf	8b 4d e8	 mov	 ecx, DWORD PTR _pInfo$[ebp]
  005c2	83 ec 08	 sub	 esp, 8
  005c5	f2 0f 10 81 20
	01 00 00	 movsd	 xmm0, QWORD PTR [ecx+288]
  005cd	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  005d2	68 00 00 00 00	 push	 OFFSET $SG119236
  005d7	8d 95 3c fe ff
	ff		 lea	 edx, DWORD PTR $T19[ebp]
  005dd	52		 push	 edx
  005de	e8 00 00 00 00	 call	 ?strsprintf@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; strsprintf
  005e3	83 c4 10	 add	 esp, 16			; 00000010H
  005e6	89 85 f4 fb ff
	ff		 mov	 DWORD PTR tv613[ebp], eax
  005ec	8b 85 f4 fb ff
	ff		 mov	 eax, DWORD PTR tv613[ebp]
  005f2	89 85 f0 fb ff
	ff		 mov	 DWORD PTR tv566[ebp], eax
  005f8	c6 45 fc 0e	 mov	 BYTE PTR __$EHRec$[ebp+8], 14 ; 0000000eH
  005fc	8b 8d f0 fb ff
	ff		 mov	 ecx, DWORD PTR tv566[ebp]
  00602	51		 push	 ecx
  00603	8d 4d c8	 lea	 ecx, DWORD PTR _str$[ebp]
  00606	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
  0060b	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0060f	8d 8d 3c fe ff
	ff		 lea	 ecx, DWORD PTR $T19[ebp]
  00615	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN16@write:

; 1188 :     }
; 1189 :     if (nSelect & PERF_MONITOR_PCIE_LOAD) {

  0061a	8b 55 0c	 mov	 edx, DWORD PTR _nSelect$[ebp]
  0061d	81 e2 00 00 00
	10		 and	 edx, 268435456		; 10000000H
  00623	0f 84 00 01 00
	00		 je	 $LN17@write

; 1190 :         str += strsprintf(",PCIe %dx%d", pInfo->pcie_gen, pInfo->pcie_link);

  00629	8b 45 e8	 mov	 eax, DWORD PTR _pInfo$[ebp]
  0062c	8b 88 2c 01 00
	00		 mov	 ecx, DWORD PTR [eax+300]
  00632	51		 push	 ecx
  00633	8b 55 e8	 mov	 edx, DWORD PTR _pInfo$[ebp]
  00636	8b 82 28 01 00
	00		 mov	 eax, DWORD PTR [edx+296]
  0063c	50		 push	 eax
  0063d	68 00 00 00 00	 push	 OFFSET $SG119238
  00642	8d 8d 20 fe ff
	ff		 lea	 ecx, DWORD PTR $T18[ebp]
  00648	51		 push	 ecx
  00649	e8 00 00 00 00	 call	 ?strsprintf@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; strsprintf
  0064e	83 c4 10	 add	 esp, 16			; 00000010H
  00651	89 85 ec fb ff
	ff		 mov	 DWORD PTR tv614[ebp], eax
  00657	8b 95 ec fb ff
	ff		 mov	 edx, DWORD PTR tv614[ebp]
  0065d	89 95 e8 fb ff
	ff		 mov	 DWORD PTR tv568[ebp], edx
  00663	c6 45 fc 0f	 mov	 BYTE PTR __$EHRec$[ebp+8], 15 ; 0000000fH
  00667	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR tv568[ebp]
  0066d	50		 push	 eax
  0066e	8d 4d c8	 lea	 ecx, DWORD PTR _str$[ebp]
  00671	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
  00676	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0067a	8d 8d 20 fe ff
	ff		 lea	 ecx, DWORD PTR $T18[ebp]
  00680	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 1191 :         str += strsprintf(",%lf", pInfo->pcie_throughput_tx_per_sec);

  00685	8b 4d e8	 mov	 ecx, DWORD PTR _pInfo$[ebp]
  00688	8b 91 30 01 00
	00		 mov	 edx, DWORD PTR [ecx+304]
  0068e	52		 push	 edx
  0068f	68 00 00 00 00	 push	 OFFSET $SG119239
  00694	8d 85 04 fe ff
	ff		 lea	 eax, DWORD PTR $T17[ebp]
  0069a	50		 push	 eax
  0069b	e8 00 00 00 00	 call	 ?strsprintf@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; strsprintf
  006a0	83 c4 0c	 add	 esp, 12			; 0000000cH
  006a3	89 85 e4 fb ff
	ff		 mov	 DWORD PTR tv615[ebp], eax
  006a9	8b 8d e4 fb ff
	ff		 mov	 ecx, DWORD PTR tv615[ebp]
  006af	89 8d e0 fb ff
	ff		 mov	 DWORD PTR tv570[ebp], ecx
  006b5	c6 45 fc 10	 mov	 BYTE PTR __$EHRec$[ebp+8], 16 ; 00000010H
  006b9	8b 95 e0 fb ff
	ff		 mov	 edx, DWORD PTR tv570[ebp]
  006bf	52		 push	 edx
  006c0	8d 4d c8	 lea	 ecx, DWORD PTR _str$[ebp]
  006c3	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
  006c8	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  006cc	8d 8d 04 fe ff
	ff		 lea	 ecx, DWORD PTR $T17[ebp]
  006d2	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 1192 :         str += strsprintf(",%lf", pInfo->pcie_throughput_rx_per_sec);

  006d7	8b 45 e8	 mov	 eax, DWORD PTR _pInfo$[ebp]
  006da	8b 88 34 01 00
	00		 mov	 ecx, DWORD PTR [eax+308]
  006e0	51		 push	 ecx
  006e1	68 00 00 00 00	 push	 OFFSET $SG119240
  006e6	8d 95 e8 fd ff
	ff		 lea	 edx, DWORD PTR $T16[ebp]
  006ec	52		 push	 edx
  006ed	e8 00 00 00 00	 call	 ?strsprintf@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; strsprintf
  006f2	83 c4 0c	 add	 esp, 12			; 0000000cH
  006f5	89 85 dc fb ff
	ff		 mov	 DWORD PTR tv616[ebp], eax
  006fb	8b 85 dc fb ff
	ff		 mov	 eax, DWORD PTR tv616[ebp]
  00701	89 85 d8 fb ff
	ff		 mov	 DWORD PTR tv572[ebp], eax
  00707	c6 45 fc 11	 mov	 BYTE PTR __$EHRec$[ebp+8], 17 ; 00000011H
  0070b	8b 8d d8 fb ff
	ff		 mov	 ecx, DWORD PTR tv572[ebp]
  00711	51		 push	 ecx
  00712	8d 4d c8	 lea	 ecx, DWORD PTR _str$[ebp]
  00715	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
  0071a	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0071e	8d 8d e8 fd ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp]
  00724	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN17@write:

; 1193 :     }
; 1194 :     if (nSelect & PERF_MONITOR_QUEUE_VID_IN) {

  00729	8b 55 0c	 mov	 edx, DWORD PTR _nSelect$[ebp]
  0072c	81 e2 00 00 10
	00		 and	 edx, 1048576		; 00100000H
  00732	74 52		 je	 SHORT $LN18@write

; 1195 :         str += strsprintf(",%d", (int)m_QueueInfo.usage_vid_in);

  00734	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00737	8b 88 4c 0b 00
	00		 mov	 ecx, DWORD PTR [eax+2892]
  0073d	51		 push	 ecx
  0073e	68 00 00 00 00	 push	 OFFSET $SG119242
  00743	8d 95 cc fd ff
	ff		 lea	 edx, DWORD PTR $T15[ebp]
  00749	52		 push	 edx
  0074a	e8 00 00 00 00	 call	 ?strsprintf@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; strsprintf
  0074f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00752	89 85 d4 fb ff
	ff		 mov	 DWORD PTR tv617[ebp], eax
  00758	8b 85 d4 fb ff
	ff		 mov	 eax, DWORD PTR tv617[ebp]
  0075e	89 85 d0 fb ff
	ff		 mov	 DWORD PTR tv574[ebp], eax
  00764	c6 45 fc 12	 mov	 BYTE PTR __$EHRec$[ebp+8], 18 ; 00000012H
  00768	8b 8d d0 fb ff
	ff		 mov	 ecx, DWORD PTR tv574[ebp]
  0076e	51		 push	 ecx
  0076f	8d 4d c8	 lea	 ecx, DWORD PTR _str$[ebp]
  00772	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
  00777	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0077b	8d 8d cc fd ff
	ff		 lea	 ecx, DWORD PTR $T15[ebp]
  00781	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN18@write:

; 1196 :     }
; 1197 :     if (nSelect & PERF_MONITOR_QUEUE_AUD_IN) {

  00786	8b 55 0c	 mov	 edx, DWORD PTR _nSelect$[ebp]
  00789	81 e2 00 00 40
	00		 and	 edx, 4194304		; 00400000H
  0078f	74 52		 je	 SHORT $LN19@write

; 1198 :         str += strsprintf(",%d", (int)m_QueueInfo.usage_aud_in);

  00791	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00794	8b 88 50 0b 00
	00		 mov	 ecx, DWORD PTR [eax+2896]
  0079a	51		 push	 ecx
  0079b	68 00 00 00 00	 push	 OFFSET $SG119244
  007a0	8d 95 b0 fd ff
	ff		 lea	 edx, DWORD PTR $T14[ebp]
  007a6	52		 push	 edx
  007a7	e8 00 00 00 00	 call	 ?strsprintf@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; strsprintf
  007ac	83 c4 0c	 add	 esp, 12			; 0000000cH
  007af	89 85 cc fb ff
	ff		 mov	 DWORD PTR tv618[ebp], eax
  007b5	8b 85 cc fb ff
	ff		 mov	 eax, DWORD PTR tv618[ebp]
  007bb	89 85 c8 fb ff
	ff		 mov	 DWORD PTR tv576[ebp], eax
  007c1	c6 45 fc 13	 mov	 BYTE PTR __$EHRec$[ebp+8], 19 ; 00000013H
  007c5	8b 8d c8 fb ff
	ff		 mov	 ecx, DWORD PTR tv576[ebp]
  007cb	51		 push	 ecx
  007cc	8d 4d c8	 lea	 ecx, DWORD PTR _str$[ebp]
  007cf	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
  007d4	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  007d8	8d 8d b0 fd ff
	ff		 lea	 ecx, DWORD PTR $T14[ebp]
  007de	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN19@write:

; 1199 :     }
; 1200 :     if (nSelect & PERF_MONITOR_QUEUE_VID_OUT) {

  007e3	8b 55 0c	 mov	 edx, DWORD PTR _nSelect$[ebp]
  007e6	81 e2 00 00 20
	00		 and	 edx, 2097152		; 00200000H
  007ec	74 52		 je	 SHORT $LN20@write

; 1201 :         str += strsprintf(",%d", (int)m_QueueInfo.usage_vid_out);

  007ee	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  007f1	8b 88 54 0b 00
	00		 mov	 ecx, DWORD PTR [eax+2900]
  007f7	51		 push	 ecx
  007f8	68 00 00 00 00	 push	 OFFSET $SG119246
  007fd	8d 95 94 fd ff
	ff		 lea	 edx, DWORD PTR $T13[ebp]
  00803	52		 push	 edx
  00804	e8 00 00 00 00	 call	 ?strsprintf@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; strsprintf
  00809	83 c4 0c	 add	 esp, 12			; 0000000cH
  0080c	89 85 c4 fb ff
	ff		 mov	 DWORD PTR tv619[ebp], eax
  00812	8b 85 c4 fb ff
	ff		 mov	 eax, DWORD PTR tv619[ebp]
  00818	89 85 c0 fb ff
	ff		 mov	 DWORD PTR tv578[ebp], eax
  0081e	c6 45 fc 14	 mov	 BYTE PTR __$EHRec$[ebp+8], 20 ; 00000014H
  00822	8b 8d c0 fb ff
	ff		 mov	 ecx, DWORD PTR tv578[ebp]
  00828	51		 push	 ecx
  00829	8d 4d c8	 lea	 ecx, DWORD PTR _str$[ebp]
  0082c	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
  00831	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00835	8d 8d 94 fd ff
	ff		 lea	 ecx, DWORD PTR $T13[ebp]
  0083b	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN20@write:

; 1202 :     }
; 1203 :     if (nSelect & PERF_MONITOR_QUEUE_AUD_OUT) {

  00840	8b 55 0c	 mov	 edx, DWORD PTR _nSelect$[ebp]
  00843	81 e2 00 00 80
	00		 and	 edx, 8388608		; 00800000H
  00849	74 52		 je	 SHORT $LN21@write

; 1204 :         str += strsprintf(",%d", (int)m_QueueInfo.usage_aud_out);

  0084b	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0084e	8b 88 58 0b 00
	00		 mov	 ecx, DWORD PTR [eax+2904]
  00854	51		 push	 ecx
  00855	68 00 00 00 00	 push	 OFFSET $SG119248
  0085a	8d 95 78 fd ff
	ff		 lea	 edx, DWORD PTR $T12[ebp]
  00860	52		 push	 edx
  00861	e8 00 00 00 00	 call	 ?strsprintf@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; strsprintf
  00866	83 c4 0c	 add	 esp, 12			; 0000000cH
  00869	89 85 bc fb ff
	ff		 mov	 DWORD PTR tv620[ebp], eax
  0086f	8b 85 bc fb ff
	ff		 mov	 eax, DWORD PTR tv620[ebp]
  00875	89 85 b8 fb ff
	ff		 mov	 DWORD PTR tv580[ebp], eax
  0087b	c6 45 fc 15	 mov	 BYTE PTR __$EHRec$[ebp+8], 21 ; 00000015H
  0087f	8b 8d b8 fb ff
	ff		 mov	 ecx, DWORD PTR tv580[ebp]
  00885	51		 push	 ecx
  00886	8d 4d c8	 lea	 ecx, DWORD PTR _str$[ebp]
  00889	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
  0088e	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00892	8d 8d 78 fd ff
	ff		 lea	 ecx, DWORD PTR $T12[ebp]
  00898	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN21@write:

; 1205 :     }
; 1206 :     if (nSelect & PERF_MONITOR_MEM_PRIVATE) {

  0089d	8b 55 0c	 mov	 edx, DWORD PTR _nSelect$[ebp]
  008a0	83 e2 04	 and	 edx, 4
  008a3	74 66		 je	 SHORT $LN22@write

; 1207 :         str += strsprintf(",%.2lf", pInfo->mem_private / (double)(1024 * 1024));

  008a5	8b 45 e8	 mov	 eax, DWORD PTR _pInfo$[ebp]
  008a8	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  008ab	8b 50 4c	 mov	 edx, DWORD PTR [eax+76]
  008ae	e8 00 00 00 00	 call	 __ltod3
  008b3	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@4130000000000000
  008bb	83 ec 08	 sub	 esp, 8
  008be	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  008c3	68 00 00 00 00	 push	 OFFSET $SG119250
  008c8	8d 8d 5c fd ff
	ff		 lea	 ecx, DWORD PTR $T11[ebp]
  008ce	51		 push	 ecx
  008cf	e8 00 00 00 00	 call	 ?strsprintf@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; strsprintf
  008d4	83 c4 10	 add	 esp, 16			; 00000010H
  008d7	89 85 b4 fb ff
	ff		 mov	 DWORD PTR tv621[ebp], eax
  008dd	8b 95 b4 fb ff
	ff		 mov	 edx, DWORD PTR tv621[ebp]
  008e3	89 95 b0 fb ff
	ff		 mov	 DWORD PTR tv582[ebp], edx
  008e9	c6 45 fc 16	 mov	 BYTE PTR __$EHRec$[ebp+8], 22 ; 00000016H
  008ed	8b 85 b0 fb ff
	ff		 mov	 eax, DWORD PTR tv582[ebp]
  008f3	50		 push	 eax
  008f4	8d 4d c8	 lea	 ecx, DWORD PTR _str$[ebp]
  008f7	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
  008fc	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00900	8d 8d 5c fd ff
	ff		 lea	 ecx, DWORD PTR $T11[ebp]
  00906	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN22@write:

; 1208 :     }
; 1209 :     if (nSelect & PERF_MONITOR_MEM_VIRTUAL) {

  0090b	8b 4d 0c	 mov	 ecx, DWORD PTR _nSelect$[ebp]
  0090e	83 e1 08	 and	 ecx, 8
  00911	74 66		 je	 SHORT $LN23@write

; 1210 :         str += strsprintf(",%.2lf", pInfo->mem_virtual / (double)(1024 * 1024));

  00913	8b 55 e8	 mov	 edx, DWORD PTR _pInfo$[ebp]
  00916	8b 4a 50	 mov	 ecx, DWORD PTR [edx+80]
  00919	8b 52 54	 mov	 edx, DWORD PTR [edx+84]
  0091c	e8 00 00 00 00	 call	 __ltod3
  00921	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@4130000000000000
  00929	83 ec 08	 sub	 esp, 8
  0092c	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00931	68 00 00 00 00	 push	 OFFSET $SG119252
  00936	8d 85 40 fd ff
	ff		 lea	 eax, DWORD PTR $T10[ebp]
  0093c	50		 push	 eax
  0093d	e8 00 00 00 00	 call	 ?strsprintf@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; strsprintf
  00942	83 c4 10	 add	 esp, 16			; 00000010H
  00945	89 85 ac fb ff
	ff		 mov	 DWORD PTR tv622[ebp], eax
  0094b	8b 8d ac fb ff
	ff		 mov	 ecx, DWORD PTR tv622[ebp]
  00951	89 8d a8 fb ff
	ff		 mov	 DWORD PTR tv584[ebp], ecx
  00957	c6 45 fc 17	 mov	 BYTE PTR __$EHRec$[ebp+8], 23 ; 00000017H
  0095b	8b 95 a8 fb ff
	ff		 mov	 edx, DWORD PTR tv584[ebp]
  00961	52		 push	 edx
  00962	8d 4d c8	 lea	 ecx, DWORD PTR _str$[ebp]
  00965	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
  0096a	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0096e	8d 8d 40 fd ff
	ff		 lea	 ecx, DWORD PTR $T10[ebp]
  00974	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN23@write:

; 1211 :     }
; 1212 :     if (nSelect & PERF_MONITOR_FRAME_IN) {

  00979	8b 45 0c	 mov	 eax, DWORD PTR _nSelect$[ebp]
  0097c	25 00 00 01 00	 and	 eax, 65536		; 00010000H
  00981	74 53		 je	 SHORT $LN24@write

; 1213 :         str += strsprintf(",%d", pInfo->frames_in);

  00983	8b 4d e8	 mov	 ecx, DWORD PTR _pInfo$[ebp]
  00986	8b 51 6c	 mov	 edx, DWORD PTR [ecx+108]
  00989	52		 push	 edx
  0098a	8b 41 68	 mov	 eax, DWORD PTR [ecx+104]
  0098d	50		 push	 eax
  0098e	68 00 00 00 00	 push	 OFFSET $SG119254
  00993	8d 8d 24 fd ff
	ff		 lea	 ecx, DWORD PTR $T9[ebp]
  00999	51		 push	 ecx
  0099a	e8 00 00 00 00	 call	 ?strsprintf@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; strsprintf
  0099f	83 c4 10	 add	 esp, 16			; 00000010H
  009a2	89 85 a4 fb ff
	ff		 mov	 DWORD PTR tv623[ebp], eax
  009a8	8b 95 a4 fb ff
	ff		 mov	 edx, DWORD PTR tv623[ebp]
  009ae	89 95 a0 fb ff
	ff		 mov	 DWORD PTR tv586[ebp], edx
  009b4	c6 45 fc 18	 mov	 BYTE PTR __$EHRec$[ebp+8], 24 ; 00000018H
  009b8	8b 85 a0 fb ff
	ff		 mov	 eax, DWORD PTR tv586[ebp]
  009be	50		 push	 eax
  009bf	8d 4d c8	 lea	 ecx, DWORD PTR _str$[ebp]
  009c2	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
  009c7	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  009cb	8d 8d 24 fd ff
	ff		 lea	 ecx, DWORD PTR $T9[ebp]
  009d1	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN24@write:

; 1214 :     }
; 1215 :     if (nSelect & PERF_MONITOR_FRAME_OUT) {

  009d6	8b 4d 0c	 mov	 ecx, DWORD PTR _nSelect$[ebp]
  009d9	81 e1 00 00 02
	00		 and	 ecx, 131072		; 00020000H
  009df	74 53		 je	 SHORT $LN25@write

; 1216 :         str += strsprintf(",%d", pInfo->frames_out);

  009e1	8b 55 e8	 mov	 edx, DWORD PTR _pInfo$[ebp]
  009e4	8b 42 74	 mov	 eax, DWORD PTR [edx+116]
  009e7	50		 push	 eax
  009e8	8b 4a 70	 mov	 ecx, DWORD PTR [edx+112]
  009eb	51		 push	 ecx
  009ec	68 00 00 00 00	 push	 OFFSET $SG119256
  009f1	8d 95 08 fd ff
	ff		 lea	 edx, DWORD PTR $T8[ebp]
  009f7	52		 push	 edx
  009f8	e8 00 00 00 00	 call	 ?strsprintf@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; strsprintf
  009fd	83 c4 10	 add	 esp, 16			; 00000010H
  00a00	89 85 9c fb ff
	ff		 mov	 DWORD PTR tv624[ebp], eax
  00a06	8b 85 9c fb ff
	ff		 mov	 eax, DWORD PTR tv624[ebp]
  00a0c	89 85 98 fb ff
	ff		 mov	 DWORD PTR tv588[ebp], eax
  00a12	c6 45 fc 19	 mov	 BYTE PTR __$EHRec$[ebp+8], 25 ; 00000019H
  00a16	8b 8d 98 fb ff
	ff		 mov	 ecx, DWORD PTR tv588[ebp]
  00a1c	51		 push	 ecx
  00a1d	8d 4d c8	 lea	 ecx, DWORD PTR _str$[ebp]
  00a20	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
  00a25	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00a29	8d 8d 08 fd ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp]
  00a2f	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN25@write:

; 1217 :     }
; 1218 :     if (nSelect & PERF_MONITOR_FPS) {

  00a34	8b 55 0c	 mov	 edx, DWORD PTR _nSelect$[ebp]
  00a37	83 e2 10	 and	 edx, 16			; 00000010H
  00a3a	74 5b		 je	 SHORT $LN26@write

; 1219 :         str += strsprintf(",%lf", pInfo->fps);

  00a3c	8b 45 e8	 mov	 eax, DWORD PTR _pInfo$[ebp]
  00a3f	83 ec 08	 sub	 esp, 8
  00a42	f2 0f 10 80 80
	00 00 00	 movsd	 xmm0, QWORD PTR [eax+128]
  00a4a	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00a4f	68 00 00 00 00	 push	 OFFSET $SG119258
  00a54	8d 8d ec fc ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  00a5a	51		 push	 ecx
  00a5b	e8 00 00 00 00	 call	 ?strsprintf@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; strsprintf
  00a60	83 c4 10	 add	 esp, 16			; 00000010H
  00a63	89 85 94 fb ff
	ff		 mov	 DWORD PTR tv625[ebp], eax
  00a69	8b 95 94 fb ff
	ff		 mov	 edx, DWORD PTR tv625[ebp]
  00a6f	89 95 90 fb ff
	ff		 mov	 DWORD PTR tv590[ebp], edx
  00a75	c6 45 fc 1a	 mov	 BYTE PTR __$EHRec$[ebp+8], 26 ; 0000001aH
  00a79	8b 85 90 fb ff
	ff		 mov	 eax, DWORD PTR tv590[ebp]
  00a7f	50		 push	 eax
  00a80	8d 4d c8	 lea	 ecx, DWORD PTR _str$[ebp]
  00a83	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
  00a88	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00a8c	8d 8d ec fc ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  00a92	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN26@write:

; 1220 :     }
; 1221 :     if (nSelect & PERF_MONITOR_FPS_AVG) {

  00a97	8b 4d 0c	 mov	 ecx, DWORD PTR _nSelect$[ebp]
  00a9a	83 e1 20	 and	 ecx, 32			; 00000020H
  00a9d	74 5b		 je	 SHORT $LN27@write

; 1222 :         str += strsprintf(",%lf", pInfo->fps_avg);

  00a9f	8b 55 e8	 mov	 edx, DWORD PTR _pInfo$[ebp]
  00aa2	83 ec 08	 sub	 esp, 8
  00aa5	f2 0f 10 82 88
	00 00 00	 movsd	 xmm0, QWORD PTR [edx+136]
  00aad	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00ab2	68 00 00 00 00	 push	 OFFSET $SG119260
  00ab7	8d 85 d0 fc ff
	ff		 lea	 eax, DWORD PTR $T6[ebp]
  00abd	50		 push	 eax
  00abe	e8 00 00 00 00	 call	 ?strsprintf@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; strsprintf
  00ac3	83 c4 10	 add	 esp, 16			; 00000010H
  00ac6	89 85 8c fb ff
	ff		 mov	 DWORD PTR tv626[ebp], eax
  00acc	8b 8d 8c fb ff
	ff		 mov	 ecx, DWORD PTR tv626[ebp]
  00ad2	89 8d 88 fb ff
	ff		 mov	 DWORD PTR tv592[ebp], ecx
  00ad8	c6 45 fc 1b	 mov	 BYTE PTR __$EHRec$[ebp+8], 27 ; 0000001bH
  00adc	8b 95 88 fb ff
	ff		 mov	 edx, DWORD PTR tv592[ebp]
  00ae2	52		 push	 edx
  00ae3	8d 4d c8	 lea	 ecx, DWORD PTR _str$[ebp]
  00ae6	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
  00aeb	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00aef	8d 8d d0 fc ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  00af5	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN27@write:

; 1223 :     }
; 1224 :     if (nSelect & PERF_MONITOR_BITRATE) {

  00afa	8b 45 0c	 mov	 eax, DWORD PTR _nSelect$[ebp]
  00afd	83 e0 40	 and	 eax, 64			; 00000040H
  00b00	74 5b		 je	 SHORT $LN28@write

; 1225 :         str += strsprintf(",%lf", pInfo->bitrate_kbps);

  00b02	8b 4d e8	 mov	 ecx, DWORD PTR _pInfo$[ebp]
  00b05	83 ec 08	 sub	 esp, 8
  00b08	f2 0f 10 81 90
	00 00 00	 movsd	 xmm0, QWORD PTR [ecx+144]
  00b10	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00b15	68 00 00 00 00	 push	 OFFSET $SG119262
  00b1a	8d 95 b4 fc ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  00b20	52		 push	 edx
  00b21	e8 00 00 00 00	 call	 ?strsprintf@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; strsprintf
  00b26	83 c4 10	 add	 esp, 16			; 00000010H
  00b29	89 85 84 fb ff
	ff		 mov	 DWORD PTR tv627[ebp], eax
  00b2f	8b 85 84 fb ff
	ff		 mov	 eax, DWORD PTR tv627[ebp]
  00b35	89 85 80 fb ff
	ff		 mov	 DWORD PTR tv594[ebp], eax
  00b3b	c6 45 fc 1c	 mov	 BYTE PTR __$EHRec$[ebp+8], 28 ; 0000001cH
  00b3f	8b 8d 80 fb ff
	ff		 mov	 ecx, DWORD PTR tv594[ebp]
  00b45	51		 push	 ecx
  00b46	8d 4d c8	 lea	 ecx, DWORD PTR _str$[ebp]
  00b49	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
  00b4e	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00b52	8d 8d b4 fc ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  00b58	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN28@write:

; 1226 :     }
; 1227 :     if (nSelect & PERF_MONITOR_BITRATE_AVG) {

  00b5d	8b 55 0c	 mov	 edx, DWORD PTR _nSelect$[ebp]
  00b60	81 e2 80 00 00
	00		 and	 edx, 128		; 00000080H
  00b66	74 5b		 je	 SHORT $LN29@write

; 1228 :         str += strsprintf(",%lf", pInfo->bitrate_kbps_avg);

  00b68	8b 45 e8	 mov	 eax, DWORD PTR _pInfo$[ebp]
  00b6b	83 ec 08	 sub	 esp, 8
  00b6e	f2 0f 10 80 98
	00 00 00	 movsd	 xmm0, QWORD PTR [eax+152]
  00b76	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00b7b	68 00 00 00 00	 push	 OFFSET $SG119264
  00b80	8d 8d 98 fc ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  00b86	51		 push	 ecx
  00b87	e8 00 00 00 00	 call	 ?strsprintf@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; strsprintf
  00b8c	83 c4 10	 add	 esp, 16			; 00000010H
  00b8f	89 85 7c fb ff
	ff		 mov	 DWORD PTR tv628[ebp], eax
  00b95	8b 95 7c fb ff
	ff		 mov	 edx, DWORD PTR tv628[ebp]
  00b9b	89 95 78 fb ff
	ff		 mov	 DWORD PTR tv596[ebp], edx
  00ba1	c6 45 fc 1d	 mov	 BYTE PTR __$EHRec$[ebp+8], 29 ; 0000001dH
  00ba5	8b 85 78 fb ff
	ff		 mov	 eax, DWORD PTR tv596[ebp]
  00bab	50		 push	 eax
  00bac	8d 4d c8	 lea	 ecx, DWORD PTR _str$[ebp]
  00baf	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
  00bb4	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00bb8	8d 8d 98 fc ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  00bbe	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN29@write:

; 1229 :     }
; 1230 :     if (nSelect & PERF_MONITOR_IO_READ) {

  00bc3	8b 4d 0c	 mov	 ecx, DWORD PTR _nSelect$[ebp]
  00bc6	81 e1 00 01 00
	00		 and	 ecx, 256		; 00000100H
  00bcc	74 63		 je	 SHORT $LN30@write

; 1231 :         str += strsprintf(",%lf", pInfo->io_read_per_sec / (double)(1024 * 1024));

  00bce	8b 55 e8	 mov	 edx, DWORD PTR _pInfo$[ebp]
  00bd1	f2 0f 10 82 a0
	00 00 00	 movsd	 xmm0, QWORD PTR [edx+160]
  00bd9	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@4130000000000000
  00be1	83 ec 08	 sub	 esp, 8
  00be4	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00be9	68 00 00 00 00	 push	 OFFSET $SG119266
  00bee	8d 85 7c fc ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  00bf4	50		 push	 eax
  00bf5	e8 00 00 00 00	 call	 ?strsprintf@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; strsprintf
  00bfa	83 c4 10	 add	 esp, 16			; 00000010H
  00bfd	89 85 74 fb ff
	ff		 mov	 DWORD PTR tv629[ebp], eax
  00c03	8b 8d 74 fb ff
	ff		 mov	 ecx, DWORD PTR tv629[ebp]
  00c09	89 8d 70 fb ff
	ff		 mov	 DWORD PTR tv598[ebp], ecx
  00c0f	c6 45 fc 1e	 mov	 BYTE PTR __$EHRec$[ebp+8], 30 ; 0000001eH
  00c13	8b 95 70 fb ff
	ff		 mov	 edx, DWORD PTR tv598[ebp]
  00c19	52		 push	 edx
  00c1a	8d 4d c8	 lea	 ecx, DWORD PTR _str$[ebp]
  00c1d	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
  00c22	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00c26	8d 8d 7c fc ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00c2c	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN30@write:

; 1232 :     }
; 1233 :     if (nSelect & PERF_MONITOR_IO_WRITE) {

  00c31	8b 45 0c	 mov	 eax, DWORD PTR _nSelect$[ebp]
  00c34	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00c39	74 63		 je	 SHORT $LN31@write

; 1234 :         str += strsprintf(",%lf", pInfo->io_write_per_sec / (double)(1024 * 1024));

  00c3b	8b 4d e8	 mov	 ecx, DWORD PTR _pInfo$[ebp]
  00c3e	f2 0f 10 81 a8
	00 00 00	 movsd	 xmm0, QWORD PTR [ecx+168]
  00c46	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@4130000000000000
  00c4e	83 ec 08	 sub	 esp, 8
  00c51	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00c56	68 00 00 00 00	 push	 OFFSET $SG119268
  00c5b	8d 95 60 fc ff
	ff		 lea	 edx, DWORD PTR $T2[ebp]
  00c61	52		 push	 edx
  00c62	e8 00 00 00 00	 call	 ?strsprintf@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; strsprintf
  00c67	83 c4 10	 add	 esp, 16			; 00000010H
  00c6a	89 85 6c fb ff
	ff		 mov	 DWORD PTR tv630[ebp], eax
  00c70	8b 85 6c fb ff
	ff		 mov	 eax, DWORD PTR tv630[ebp]
  00c76	89 85 68 fb ff
	ff		 mov	 DWORD PTR tv600[ebp], eax
  00c7c	c6 45 fc 1f	 mov	 BYTE PTR __$EHRec$[ebp+8], 31 ; 0000001fH
  00c80	8b 8d 68 fb ff
	ff		 mov	 ecx, DWORD PTR tv600[ebp]
  00c86	51		 push	 ecx
  00c87	8d 4d c8	 lea	 ecx, DWORD PTR _str$[ebp]
  00c8a	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
  00c8f	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00c93	8d 8d 60 fc ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00c99	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN31@write:

; 1235 :     }
; 1236 :     str += "\n";

  00c9e	68 00 00 00 00	 push	 OFFSET $SG119269
  00ca3	8d 4d c8	 lea	 ecx, DWORD PTR _str$[ebp]
  00ca6	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=

; 1237 :     fwrite(str.c_str(), 1, str.length(), fp);

  00cab	8b f4		 mov	 esi, esp
  00cad	8b 55 08	 mov	 edx, DWORD PTR _fp$[ebp]
  00cb0	52		 push	 edx
  00cb1	8d 4d c8	 lea	 ecx, DWORD PTR _str$[ebp]
  00cb4	e8 00 00 00 00	 call	 ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
  00cb9	50		 push	 eax
  00cba	6a 01		 push	 1
  00cbc	8d 4d c8	 lea	 ecx, DWORD PTR _str$[ebp]
  00cbf	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  00cc4	50		 push	 eax
  00cc5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  00ccb	83 c4 10	 add	 esp, 16			; 00000010H
  00cce	3b f4		 cmp	 esi, esp
  00cd0	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1238 :     if (fp == m_pipes.f_stdin) {

  00cd5	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00cd8	8b 4d 08	 mov	 ecx, DWORD PTR _fp$[ebp]
  00cdb	3b 88 d0 02 00
	00		 cmp	 ecx, DWORD PTR [eax+720]
  00ce1	75 16		 jne	 SHORT $LN32@write

; 1239 :         fflush(fp);

  00ce3	8b f4		 mov	 esi, esp
  00ce5	8b 55 08	 mov	 edx, DWORD PTR _fp$[ebp]
  00ce8	52		 push	 edx
  00ce9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fflush
  00cef	83 c4 04	 add	 esp, 4
  00cf2	3b f4		 cmp	 esi, esp
  00cf4	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN32@write:

; 1240 :     }
; 1241 : }

  00cf9	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00d00	8d 4d c8	 lea	 ecx, DWORD PTR _str$[ebp]
  00d03	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN1@write:
  00d08	52		 push	 edx
  00d09	8b cd		 mov	 ecx, ebp
  00d0b	50		 push	 eax
  00d0c	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN69@write
  00d12	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00d17	58		 pop	 eax
  00d18	5a		 pop	 edx
  00d19	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00d1c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00d23	59		 pop	 ecx
  00d24	5f		 pop	 edi
  00d25	5e		 pop	 esi
  00d26	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00d29	33 cd		 xor	 ecx, ebp
  00d2b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00d30	81 c4 98 04 00
	00		 add	 esp, 1176		; 00000498H
  00d36	3b ec		 cmp	 ebp, esp
  00d38	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00d3d	8b e5		 mov	 esp, ebp
  00d3f	5d		 pop	 ebp
  00d40	c2 08 00	 ret	 8
  00d43	90		 npad	 1
$LN69@write:
  00d44	01 00 00 00	 DD	 1
  00d48	00 00 00 00	 DD	 $LN68@write
$LN68@write:
  00d4c	c8 ff ff ff	 DD	 -56			; ffffffc8H
  00d50	1c 00 00 00	 DD	 28			; 0000001cH
  00d54	00 00 00 00	 DD	 $LN66@write
$LN66@write:
  00d58	73		 DB	 115			; 00000073H
  00d59	74		 DB	 116			; 00000074H
  00d5a	72		 DB	 114			; 00000072H
  00d5b	00		 DB	 0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z$0:
  00000	8d 4d c8	 lea	 ecx, DWORD PTR _str$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z$1:
  00008	8d 4d a8	 lea	 ecx, DWORD PTR $T32[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z$2:
  00010	8d 4d 8c	 lea	 ecx, DWORD PTR $T31[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z$3:
  00018	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR $T30[ebp]
  0001e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z$4:
  00023	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR $T29[ebp]
  00029	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z$5:
  0002e	8d 8d 38 ff ff
	ff		 lea	 ecx, DWORD PTR $T28[ebp]
  00034	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z$6:
  00039	8d 8d 1c ff ff
	ff		 lea	 ecx, DWORD PTR $T27[ebp]
  0003f	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z$7:
  00044	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR $T26[ebp]
  0004a	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z$8:
  0004f	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR $T25[ebp]
  00055	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z$9:
  0005a	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR $T24[ebp]
  00060	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z$10:
  00065	8d 8d ac fe ff
	ff		 lea	 ecx, DWORD PTR $T23[ebp]
  0006b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z$11:
  00070	8d 8d 90 fe ff
	ff		 lea	 ecx, DWORD PTR $T22[ebp]
  00076	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z$12:
  0007b	8d 8d 74 fe ff
	ff		 lea	 ecx, DWORD PTR $T21[ebp]
  00081	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z$13:
  00086	8d 8d 58 fe ff
	ff		 lea	 ecx, DWORD PTR $T20[ebp]
  0008c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z$14:
  00091	8d 8d 3c fe ff
	ff		 lea	 ecx, DWORD PTR $T19[ebp]
  00097	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z$15:
  0009c	8d 8d 20 fe ff
	ff		 lea	 ecx, DWORD PTR $T18[ebp]
  000a2	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z$16:
  000a7	8d 8d 04 fe ff
	ff		 lea	 ecx, DWORD PTR $T17[ebp]
  000ad	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z$17:
  000b2	8d 8d e8 fd ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp]
  000b8	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z$18:
  000bd	8d 8d cc fd ff
	ff		 lea	 ecx, DWORD PTR $T15[ebp]
  000c3	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z$19:
  000c8	8d 8d b0 fd ff
	ff		 lea	 ecx, DWORD PTR $T14[ebp]
  000ce	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z$20:
  000d3	8d 8d 94 fd ff
	ff		 lea	 ecx, DWORD PTR $T13[ebp]
  000d9	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z$21:
  000de	8d 8d 78 fd ff
	ff		 lea	 ecx, DWORD PTR $T12[ebp]
  000e4	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z$22:
  000e9	8d 8d 5c fd ff
	ff		 lea	 ecx, DWORD PTR $T11[ebp]
  000ef	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z$23:
  000f4	8d 8d 40 fd ff
	ff		 lea	 ecx, DWORD PTR $T10[ebp]
  000fa	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z$24:
  000ff	8d 8d 24 fd ff
	ff		 lea	 ecx, DWORD PTR $T9[ebp]
  00105	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z$25:
  0010a	8d 8d 08 fd ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp]
  00110	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z$26:
  00115	8d 8d ec fc ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  0011b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z$27:
  00120	8d 8d d0 fc ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  00126	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z$28:
  0012b	8d 8d b4 fc ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  00131	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z$29:
  00136	8d 8d 98 fc ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  0013c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z$30:
  00141	8d 8d 7c fc ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00147	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z$31:
  0014c	8d 8d 60 fc ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00152	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z:
  00157	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0015b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0015e	8b 8a 68 fb ff
	ff		 mov	 ecx, DWORD PTR [edx-1176]
  00164	33 c8		 xor	 ecx, eax
  00166	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0016b	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0016e	33 c8		 xor	 ecx, eax
  00170	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00175	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z
  0017a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z ENDP		; CPerfMonitor::write
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\rgy_perf_monitor.cpp
_TEXT	SEGMENT
_str$ = -52						; size = 28
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_fp$ = 8						; size = 4
_nSelect$ = 12						; size = 4
?write_header@CPerfMonitor@@IAEXPAU_iobuf@@H@Z PROC	; CPerfMonitor::write_header
; _this$ = ecx

; 567  : void CPerfMonitor::write_header(FILE *fp, int nSelect) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?write_header@CPerfMonitor@@IAEXPAU_iobuf@@H@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	51		 push	 ecx
  00017	8d 7d c8	 lea	 edi, DWORD PTR [ebp-56]
  0001a	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	59		 pop	 ecx
  00027	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002c	33 c5		 xor	 eax, ebp
  0002e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00031	50		 push	 eax
  00032	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00035	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003b	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 568  :     if (fp == NULL || nSelect == 0) {

  0003e	83 7d 08 00	 cmp	 DWORD PTR _fp$[ebp], 0
  00042	74 06		 je	 SHORT $LN3@write_head
  00044	83 7d 0c 00	 cmp	 DWORD PTR _nSelect$[ebp], 0
  00048	75 05		 jne	 SHORT $LN2@write_head
$LN3@write_head:

; 569  :         return;

  0004a	e9 06 03 00 00	 jmp	 $LN1@write_head
$LN2@write_head:

; 570  :     }
; 571  :     std::string str;

  0004f	8d 4d cc	 lea	 ecx, DWORD PTR _str$[ebp]
  00052	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00057	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 572  :     if (nSelect & PERF_MONITOR_CPU) {

  0005e	8b 45 0c	 mov	 eax, DWORD PTR _nSelect$[ebp]
  00061	83 e0 01	 and	 eax, 1
  00064	74 0d		 je	 SHORT $LN4@write_head

; 573  :         str += ",cpu (%)";

  00066	68 00 00 00 00	 push	 OFFSET $SG118192
  0006b	8d 4d cc	 lea	 ecx, DWORD PTR _str$[ebp]
  0006e	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
$LN4@write_head:

; 574  :     }
; 575  :     if (nSelect & PERF_MONITOR_CPU_KERNEL) {

  00073	8b 4d 0c	 mov	 ecx, DWORD PTR _nSelect$[ebp]
  00076	83 e1 02	 and	 ecx, 2
  00079	74 0d		 je	 SHORT $LN5@write_head

; 576  :         str += ",cpu kernel (%)";

  0007b	68 00 00 00 00	 push	 OFFSET $SG118194
  00080	8d 4d cc	 lea	 ecx, DWORD PTR _str$[ebp]
  00083	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
$LN5@write_head:

; 577  :     }
; 578  :     if (nSelect & PERF_MONITOR_THREAD_MAIN) {

  00088	8b 55 0c	 mov	 edx, DWORD PTR _nSelect$[ebp]
  0008b	81 e2 00 04 00
	00		 and	 edx, 1024		; 00000400H
  00091	74 0d		 je	 SHORT $LN6@write_head

; 579  :         str += ",cpu main thread (%)";

  00093	68 00 00 00 00	 push	 OFFSET $SG118196
  00098	8d 4d cc	 lea	 ecx, DWORD PTR _str$[ebp]
  0009b	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
$LN6@write_head:

; 580  :     }
; 581  :     if (nSelect & PERF_MONITOR_THREAD_ENC) {

  000a0	8b 45 0c	 mov	 eax, DWORD PTR _nSelect$[ebp]
  000a3	25 00 08 00 00	 and	 eax, 2048		; 00000800H
  000a8	74 0d		 je	 SHORT $LN7@write_head

; 582  :         str += ",cpu enc thread (%)";

  000aa	68 00 00 00 00	 push	 OFFSET $SG118198
  000af	8d 4d cc	 lea	 ecx, DWORD PTR _str$[ebp]
  000b2	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
$LN7@write_head:

; 583  :     }
; 584  :     if (nSelect & PERF_MONITOR_THREAD_AUDP) {

  000b7	8b 4d 0c	 mov	 ecx, DWORD PTR _nSelect$[ebp]
  000ba	81 e1 00 10 00
	00		 and	 ecx, 4096		; 00001000H
  000c0	74 0d		 je	 SHORT $LN8@write_head

; 585  :         str += ",cpu aud proc thread (%)";

  000c2	68 00 00 00 00	 push	 OFFSET $SG118200
  000c7	8d 4d cc	 lea	 ecx, DWORD PTR _str$[ebp]
  000ca	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
$LN8@write_head:

; 586  :     }
; 587  :     if (nSelect & PERF_MONITOR_THREAD_AUDE) {

  000cf	8b 55 0c	 mov	 edx, DWORD PTR _nSelect$[ebp]
  000d2	81 e2 00 20 00
	00		 and	 edx, 8192		; 00002000H
  000d8	74 0d		 je	 SHORT $LN9@write_head

; 588  :         str += ",cpu aud enc thread (%)";

  000da	68 00 00 00 00	 push	 OFFSET $SG118202
  000df	8d 4d cc	 lea	 ecx, DWORD PTR _str$[ebp]
  000e2	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
$LN9@write_head:

; 589  :     }
; 590  :     if (nSelect & PERF_MONITOR_THREAD_IN) {

  000e7	8b 45 0c	 mov	 eax, DWORD PTR _nSelect$[ebp]
  000ea	25 00 80 00 00	 and	 eax, 32768		; 00008000H
  000ef	74 0d		 je	 SHORT $LN10@write_head

; 591  :         str += ",cpu in thread (%)";

  000f1	68 00 00 00 00	 push	 OFFSET $SG118204
  000f6	8d 4d cc	 lea	 ecx, DWORD PTR _str$[ebp]
  000f9	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
$LN10@write_head:

; 592  :     }
; 593  :     if (nSelect & PERF_MONITOR_THREAD_OUT) {

  000fe	8b 4d 0c	 mov	 ecx, DWORD PTR _nSelect$[ebp]
  00101	81 e1 00 40 00
	00		 and	 ecx, 16384		; 00004000H
  00107	74 0d		 je	 SHORT $LN11@write_head

; 594  :         str += ",cpu out thread (%)";

  00109	68 00 00 00 00	 push	 OFFSET $SG118206
  0010e	8d 4d cc	 lea	 ecx, DWORD PTR _str$[ebp]
  00111	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
$LN11@write_head:

; 595  :     }
; 596  :     if (nSelect & PERF_MONITOR_GPU_LOAD) {

  00116	8b 55 0c	 mov	 edx, DWORD PTR _nSelect$[ebp]
  00119	81 e2 00 00 04
	00		 and	 edx, 262144		; 00040000H
  0011f	74 0d		 je	 SHORT $LN12@write_head

; 597  :         str += ",gpu load (%)";

  00121	68 00 00 00 00	 push	 OFFSET $SG118208
  00126	8d 4d cc	 lea	 ecx, DWORD PTR _str$[ebp]
  00129	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
$LN12@write_head:

; 598  :     }
; 599  :     if (nSelect & PERF_MONITOR_GPU_CLOCK) {

  0012e	8b 45 0c	 mov	 eax, DWORD PTR _nSelect$[ebp]
  00131	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  00136	74 0d		 je	 SHORT $LN13@write_head

; 600  :         str += ",gpu clock (MHz)";

  00138	68 00 00 00 00	 push	 OFFSET $SG118210
  0013d	8d 4d cc	 lea	 ecx, DWORD PTR _str$[ebp]
  00140	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
$LN13@write_head:

; 601  :     }
; 602  :     if (nSelect & PERF_MONITOR_MFX_LOAD) {

  00145	8b 4d 0c	 mov	 ecx, DWORD PTR _nSelect$[ebp]
  00148	81 e1 00 00 00
	01		 and	 ecx, 16777216		; 01000000H
  0014e	74 0d		 je	 SHORT $LN14@write_head

; 603  :         str += ",mfx load (%)";

  00150	68 00 00 00 00	 push	 OFFSET $SG118212
  00155	8d 4d cc	 lea	 ecx, DWORD PTR _str$[ebp]
  00158	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
$LN14@write_head:

; 604  :     }
; 605  :     if (nSelect & PERF_MONITOR_VEE_LOAD) {

  0015d	8b 55 0c	 mov	 edx, DWORD PTR _nSelect$[ebp]
  00160	81 e2 00 00 00
	04		 and	 edx, 67108864		; 04000000H
  00166	74 0d		 je	 SHORT $LN15@write_head

; 606  :         str += ",video encoder load (%)";

  00168	68 00 00 00 00	 push	 OFFSET $SG118214
  0016d	8d 4d cc	 lea	 ecx, DWORD PTR _str$[ebp]
  00170	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
$LN15@write_head:

; 607  :     }
; 608  :     if (nSelect & PERF_MONITOR_VED_LOAD) {

  00175	8b 45 0c	 mov	 eax, DWORD PTR _nSelect$[ebp]
  00178	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0017d	74 0d		 je	 SHORT $LN16@write_head

; 609  :         str += ",video decoder load (%)";

  0017f	68 00 00 00 00	 push	 OFFSET $SG118216
  00184	8d 4d cc	 lea	 ecx, DWORD PTR _str$[ebp]
  00187	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
$LN16@write_head:

; 610  :     }
; 611  :     if (nSelect & PERF_MONITOR_VE_CLOCK) {

  0018c	8b 4d 0c	 mov	 ecx, DWORD PTR _nSelect$[ebp]
  0018f	81 e1 00 00 00
	02		 and	 ecx, 33554432		; 02000000H
  00195	74 0d		 je	 SHORT $LN17@write_head

; 612  :         str += ",video engine clock (MHz)";

  00197	68 00 00 00 00	 push	 OFFSET $SG118218
  0019c	8d 4d cc	 lea	 ecx, DWORD PTR _str$[ebp]
  0019f	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
$LN17@write_head:

; 613  :     }
; 614  :     if (nSelect & PERF_MONITOR_PCIE_LOAD) {

  001a4	8b 55 0c	 mov	 edx, DWORD PTR _nSelect$[ebp]
  001a7	81 e2 00 00 00
	10		 and	 edx, 268435456		; 10000000H
  001ad	74 0d		 je	 SHORT $LN18@write_head

; 615  :         str += ",pcie link,pcie tx, pci rx";

  001af	68 00 00 00 00	 push	 OFFSET $SG118220
  001b4	8d 4d cc	 lea	 ecx, DWORD PTR _str$[ebp]
  001b7	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
$LN18@write_head:

; 616  :     }
; 617  :     if (nSelect & PERF_MONITOR_QUEUE_VID_IN) {

  001bc	8b 45 0c	 mov	 eax, DWORD PTR _nSelect$[ebp]
  001bf	25 00 00 10 00	 and	 eax, 1048576		; 00100000H
  001c4	74 0d		 je	 SHORT $LN19@write_head

; 618  :         str += ",queue vid in";

  001c6	68 00 00 00 00	 push	 OFFSET $SG118222
  001cb	8d 4d cc	 lea	 ecx, DWORD PTR _str$[ebp]
  001ce	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
$LN19@write_head:

; 619  :     }
; 620  :     if (nSelect & PERF_MONITOR_QUEUE_AUD_IN) {

  001d3	8b 4d 0c	 mov	 ecx, DWORD PTR _nSelect$[ebp]
  001d6	81 e1 00 00 40
	00		 and	 ecx, 4194304		; 00400000H
  001dc	74 0d		 je	 SHORT $LN20@write_head

; 621  :         str += ",queue aud in";

  001de	68 00 00 00 00	 push	 OFFSET $SG118224
  001e3	8d 4d cc	 lea	 ecx, DWORD PTR _str$[ebp]
  001e6	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
$LN20@write_head:

; 622  :     }
; 623  :     if (nSelect & PERF_MONITOR_QUEUE_VID_OUT) {

  001eb	8b 55 0c	 mov	 edx, DWORD PTR _nSelect$[ebp]
  001ee	81 e2 00 00 20
	00		 and	 edx, 2097152		; 00200000H
  001f4	74 0d		 je	 SHORT $LN21@write_head

; 624  :         str += ",queue vid out";

  001f6	68 00 00 00 00	 push	 OFFSET $SG118226
  001fb	8d 4d cc	 lea	 ecx, DWORD PTR _str$[ebp]
  001fe	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
$LN21@write_head:

; 625  :     }
; 626  :     if (nSelect & PERF_MONITOR_QUEUE_AUD_OUT) {

  00203	8b 45 0c	 mov	 eax, DWORD PTR _nSelect$[ebp]
  00206	25 00 00 80 00	 and	 eax, 8388608		; 00800000H
  0020b	74 0d		 je	 SHORT $LN22@write_head

; 627  :         str += ",queue aud out";

  0020d	68 00 00 00 00	 push	 OFFSET $SG118228
  00212	8d 4d cc	 lea	 ecx, DWORD PTR _str$[ebp]
  00215	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
$LN22@write_head:

; 628  :     }
; 629  :     if (nSelect & PERF_MONITOR_MEM_PRIVATE) {

  0021a	8b 4d 0c	 mov	 ecx, DWORD PTR _nSelect$[ebp]
  0021d	83 e1 04	 and	 ecx, 4
  00220	74 0d		 je	 SHORT $LN23@write_head

; 630  :         str += ",mem private (MB)";

  00222	68 00 00 00 00	 push	 OFFSET $SG118230
  00227	8d 4d cc	 lea	 ecx, DWORD PTR _str$[ebp]
  0022a	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
$LN23@write_head:

; 631  :     }
; 632  :     if (nSelect & PERF_MONITOR_MEM_VIRTUAL) {

  0022f	8b 55 0c	 mov	 edx, DWORD PTR _nSelect$[ebp]
  00232	83 e2 08	 and	 edx, 8
  00235	74 0d		 je	 SHORT $LN24@write_head

; 633  :         str += ",mem virtual (MB)";

  00237	68 00 00 00 00	 push	 OFFSET $SG118232
  0023c	8d 4d cc	 lea	 ecx, DWORD PTR _str$[ebp]
  0023f	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
$LN24@write_head:

; 634  :     }
; 635  :     if (nSelect & PERF_MONITOR_FRAME_IN) {

  00244	8b 45 0c	 mov	 eax, DWORD PTR _nSelect$[ebp]
  00247	25 00 00 01 00	 and	 eax, 65536		; 00010000H
  0024c	74 0d		 je	 SHORT $LN25@write_head

; 636  :         str += ",frame in";

  0024e	68 00 00 00 00	 push	 OFFSET $SG118234
  00253	8d 4d cc	 lea	 ecx, DWORD PTR _str$[ebp]
  00256	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
$LN25@write_head:

; 637  :     }
; 638  :     if (nSelect & PERF_MONITOR_FRAME_OUT) {

  0025b	8b 4d 0c	 mov	 ecx, DWORD PTR _nSelect$[ebp]
  0025e	81 e1 00 00 02
	00		 and	 ecx, 131072		; 00020000H
  00264	74 0d		 je	 SHORT $LN26@write_head

; 639  :         str += ",frame out";

  00266	68 00 00 00 00	 push	 OFFSET $SG118236
  0026b	8d 4d cc	 lea	 ecx, DWORD PTR _str$[ebp]
  0026e	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
$LN26@write_head:

; 640  :     }
; 641  :     if (nSelect & PERF_MONITOR_FPS) {

  00273	8b 55 0c	 mov	 edx, DWORD PTR _nSelect$[ebp]
  00276	83 e2 10	 and	 edx, 16			; 00000010H
  00279	74 0d		 je	 SHORT $LN27@write_head

; 642  :         str += ",enc speed (fps)";

  0027b	68 00 00 00 00	 push	 OFFSET $SG118238
  00280	8d 4d cc	 lea	 ecx, DWORD PTR _str$[ebp]
  00283	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
$LN27@write_head:

; 643  :     }
; 644  :     if (nSelect & PERF_MONITOR_FPS_AVG) {

  00288	8b 45 0c	 mov	 eax, DWORD PTR _nSelect$[ebp]
  0028b	83 e0 20	 and	 eax, 32			; 00000020H
  0028e	74 0d		 je	 SHORT $LN28@write_head

; 645  :         str += ",enc speed avg (fps)";

  00290	68 00 00 00 00	 push	 OFFSET $SG118240
  00295	8d 4d cc	 lea	 ecx, DWORD PTR _str$[ebp]
  00298	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
$LN28@write_head:

; 646  :     }
; 647  :     if (nSelect & PERF_MONITOR_BITRATE) {

  0029d	8b 4d 0c	 mov	 ecx, DWORD PTR _nSelect$[ebp]
  002a0	83 e1 40	 and	 ecx, 64			; 00000040H
  002a3	74 0d		 je	 SHORT $LN29@write_head

; 648  :         str += ",bitrate (kbps)";

  002a5	68 00 00 00 00	 push	 OFFSET $SG118242
  002aa	8d 4d cc	 lea	 ecx, DWORD PTR _str$[ebp]
  002ad	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
$LN29@write_head:

; 649  :     }
; 650  :     if (nSelect & PERF_MONITOR_BITRATE_AVG) {

  002b2	8b 55 0c	 mov	 edx, DWORD PTR _nSelect$[ebp]
  002b5	81 e2 80 00 00
	00		 and	 edx, 128		; 00000080H
  002bb	74 0d		 je	 SHORT $LN30@write_head

; 651  :         str += ",bitrate avg (kbps)";

  002bd	68 00 00 00 00	 push	 OFFSET $SG118244
  002c2	8d 4d cc	 lea	 ecx, DWORD PTR _str$[ebp]
  002c5	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
$LN30@write_head:

; 652  :     }
; 653  :     if (nSelect & PERF_MONITOR_IO_READ) {

  002ca	8b 45 0c	 mov	 eax, DWORD PTR _nSelect$[ebp]
  002cd	25 00 01 00 00	 and	 eax, 256		; 00000100H
  002d2	74 0d		 je	 SHORT $LN31@write_head

; 654  :         str += ",read (MB/s)";

  002d4	68 00 00 00 00	 push	 OFFSET $SG118246
  002d9	8d 4d cc	 lea	 ecx, DWORD PTR _str$[ebp]
  002dc	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
$LN31@write_head:

; 655  :     }
; 656  :     if (nSelect & PERF_MONITOR_IO_WRITE) {

  002e1	8b 4d 0c	 mov	 ecx, DWORD PTR _nSelect$[ebp]
  002e4	81 e1 00 02 00
	00		 and	 ecx, 512		; 00000200H
  002ea	74 0d		 je	 SHORT $LN32@write_head

; 657  :         str += ",write (MB/s)";

  002ec	68 00 00 00 00	 push	 OFFSET $SG118248
  002f1	8d 4d cc	 lea	 ecx, DWORD PTR _str$[ebp]
  002f4	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
$LN32@write_head:

; 658  :     }
; 659  :     str += "\n";

  002f9	68 00 00 00 00	 push	 OFFSET $SG118249
  002fe	8d 4d cc	 lea	 ecx, DWORD PTR _str$[ebp]
  00301	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=

; 660  :     fwrite(str.c_str(), 1, str.length(), fp);

  00306	8b f4		 mov	 esi, esp
  00308	8b 55 08	 mov	 edx, DWORD PTR _fp$[ebp]
  0030b	52		 push	 edx
  0030c	8d 4d cc	 lea	 ecx, DWORD PTR _str$[ebp]
  0030f	e8 00 00 00 00	 call	 ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
  00314	50		 push	 eax
  00315	6a 01		 push	 1
  00317	8d 4d cc	 lea	 ecx, DWORD PTR _str$[ebp]
  0031a	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  0031f	50		 push	 eax
  00320	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  00326	83 c4 10	 add	 esp, 16			; 00000010H
  00329	3b f4		 cmp	 esi, esp
  0032b	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 661  :     fflush(fp);

  00330	8b f4		 mov	 esi, esp
  00332	8b 45 08	 mov	 eax, DWORD PTR _fp$[ebp]
  00335	50		 push	 eax
  00336	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fflush
  0033c	83 c4 04	 add	 esp, 4
  0033f	3b f4		 cmp	 esi, esp
  00341	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 662  : }

  00346	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0034d	8d 4d cc	 lea	 ecx, DWORD PTR _str$[ebp]
  00350	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN1@write_head:
  00355	52		 push	 edx
  00356	8b cd		 mov	 ecx, ebp
  00358	50		 push	 eax
  00359	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN38@write_head
  0035f	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00364	58		 pop	 eax
  00365	5a		 pop	 edx
  00366	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00369	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00370	59		 pop	 ecx
  00371	5f		 pop	 edi
  00372	5e		 pop	 esi
  00373	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00376	33 cd		 xor	 ecx, ebp
  00378	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0037d	83 c4 38	 add	 esp, 56			; 00000038H
  00380	3b ec		 cmp	 ebp, esp
  00382	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00387	8b e5		 mov	 esp, ebp
  00389	5d		 pop	 ebp
  0038a	c2 08 00	 ret	 8
  0038d	0f 1f 00	 npad	 3
$LN38@write_head:
  00390	01 00 00 00	 DD	 1
  00394	00 00 00 00	 DD	 $LN37@write_head
$LN37@write_head:
  00398	cc ff ff ff	 DD	 -52			; ffffffccH
  0039c	1c 00 00 00	 DD	 28			; 0000001cH
  003a0	00 00 00 00	 DD	 $LN35@write_head
$LN35@write_head:
  003a4	73		 DB	 115			; 00000073H
  003a5	74		 DB	 116			; 00000074H
  003a6	72		 DB	 114			; 00000072H
  003a7	00		 DB	 0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?write_header@CPerfMonitor@@IAEXPAU_iobuf@@H@Z$0:
  00000	8d 4d cc	 lea	 ecx, DWORD PTR _str$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?write_header@CPerfMonitor@@IAEXPAU_iobuf@@H@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a c8	 mov	 ecx, DWORD PTR [edx-56]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?write_header@CPerfMonitor@@IAEXPAU_iobuf@@H@Z
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?write_header@CPerfMonitor@@IAEXPAU_iobuf@@H@Z ENDP	; CPerfMonitor::write_header
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\rgy_perf_monitor.cpp
_TEXT	SEGMENT
tv129 = -20						; size = 4
tv77 = -16						; size = 4
$T1 = -12						; size = 8
_this$ = -4						; size = 4
?run@CPerfMonitor@@IAEXXZ PROC				; CPerfMonitor::run
; _this$ = ecx

; 1247 : void CPerfMonitor::run() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0000f	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00012	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00015	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00018	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  0001b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
$LN2@run:

; 1248 :     while (!m_bAbort) {

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	0f b6 88 18 0b
	00 00		 movzx	 ecx, BYTE PTR [eax+2840]
  00028	85 c9		 test	 ecx, ecx
  0002a	0f 85 2f 01 00
	00		 jne	 $LN3@run

; 1249 :         check();

  00030	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	e8 00 00 00 00	 call	 ?check@CPerfMonitor@@IAEXXZ ; CPerfMonitor::check

; 1250 :         if (m_pProcess && !m_pProcess->processAlive()) {

  00038	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	81 c1 9c 02 00
	00		 add	 ecx, 668		; 0000029cH
  00041	e8 00 00 00 00	 call	 ??B?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@QBE_NXZ ; std::unique_ptr<RGYPipeProcess,std::default_delete<RGYPipeProcess> >::operator bool
  00046	0f b6 d0	 movzx	 edx, al
  00049	85 d2		 test	 edx, edx
  0004b	0f 84 b2 00 00
	00		 je	 $LN4@run
  00051	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	81 c1 9c 02 00
	00		 add	 ecx, 668		; 0000029cH
  0005a	e8 00 00 00 00	 call	 ??C?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@QBEPAVRGYPipeProcess@@XZ ; std::unique_ptr<RGYPipeProcess,std::default_delete<RGYPipeProcess> >::operator->
  0005f	89 45 f0	 mov	 DWORD PTR tv77[ebp], eax
  00062	8b 45 f0	 mov	 eax, DWORD PTR tv77[ebp]
  00065	8b 10		 mov	 edx, DWORD PTR [eax]
  00067	8b f4		 mov	 esi, esp
  00069	8b 4d f0	 mov	 ecx, DWORD PTR tv77[ebp]
  0006c	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0006f	ff d0		 call	 eax
  00071	3b f4		 cmp	 esi, esp
  00073	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00078	0f b6 c8	 movzx	 ecx, al
  0007b	85 c9		 test	 ecx, ecx
  0007d	0f 85 80 00 00
	00		 jne	 $LN4@run

; 1251 :             if (m_pipes.f_stdin) {

  00083	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00086	83 ba d0 02 00
	00 00		 cmp	 DWORD PTR [edx+720], 0
  0008d	74 1c		 je	 SHORT $LN5@run

; 1252 :                 fclose(m_pipes.f_stdin);

  0008f	8b f4		 mov	 esi, esp
  00091	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00094	8b 88 d0 02 00
	00		 mov	 ecx, DWORD PTR [eax+720]
  0009a	51		 push	 ecx
  0009b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  000a1	83 c4 04	 add	 esp, 4
  000a4	3b f4		 cmp	 esi, esp
  000a6	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN5@run:

; 1253 :             }
; 1254 :             m_pipes.f_stdin = NULL;

  000ab	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000ae	c7 82 d0 02 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+720], 0

; 1255 :             if (m_nSelectOutputPlot) {

  000b8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000bb	83 b8 48 0b 00
	00 00		 cmp	 DWORD PTR [eax+2888], 0
  000c2	74 3f		 je	 SHORT $LN4@run

; 1256 :                 m_pRGYLog->write(RGY_LOG_WARN, _T("Error occured running python for perf-monitor-plot.\n"));

  000c4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c7	81 c1 64 0b 00
	00		 add	 ecx, 2916		; 00000b64H
  000cd	e8 00 00 00 00	 call	 ??$?CVRGYLog@@$0A@@?$shared_ptr@VRGYLog@@@std@@QBEPAVRGYLog@@XZ ; std::shared_ptr<RGYLog>::operator-><RGYLog,0>
  000d2	89 45 ec	 mov	 DWORD PTR tv129[ebp], eax
  000d5	8b f4		 mov	 esi, esp
  000d7	68 00 00 00 00	 push	 OFFSET $SG119290
  000dc	6a 01		 push	 1
  000de	8b 4d ec	 mov	 ecx, DWORD PTR tv129[ebp]
  000e1	51		 push	 ecx
  000e2	8b 55 ec	 mov	 edx, DWORD PTR tv129[ebp]
  000e5	8b 02		 mov	 eax, DWORD PTR [edx]
  000e7	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  000ea	ff d1		 call	 ecx
  000ec	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ef	3b f4		 cmp	 esi, esp
  000f1	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1257 :                 m_nSelectOutputPlot = 0;

  000f6	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000f9	c7 82 48 0b 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+2888], 0
$LN4@run:

; 1258 :             }
; 1259 :         }
; 1260 :         write(m_fpLog.get(),   m_nSelectOutputLog);

  00103	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00106	8b 88 44 0b 00
	00		 mov	 ecx, DWORD PTR [eax+2884]
  0010c	51		 push	 ecx
  0010d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00110	81 c1 3c 0b 00
	00		 add	 ecx, 2876		; 00000b3cH
  00116	e8 00 00 00 00	 call	 ?get@?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@QBEPAU_iobuf@@XZ ; std::unique_ptr<_iobuf,fp_deleter>::get
  0011b	50		 push	 eax
  0011c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0011f	e8 00 00 00 00	 call	 ?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z ; CPerfMonitor::write

; 1261 :         write(m_pipes.f_stdin, m_nSelectOutputPlot);

  00124	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00127	8b 82 48 0b 00
	00		 mov	 eax, DWORD PTR [edx+2888]
  0012d	50		 push	 eax
  0012e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00131	8b 91 d0 02 00
	00		 mov	 edx, DWORD PTR [ecx+720]
  00137	52		 push	 edx
  00138	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0013b	e8 00 00 00 00	 call	 ?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z ; CPerfMonitor::write

; 1262 :         std::this_thread::sleep_for(std::chrono::milliseconds(m_nInterval));

  00140	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00143	05 1c 0b 00 00	 add	 eax, 2844		; 00000b1cH
  00148	50		 push	 eax
  00149	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  0014c	e8 00 00 00 00	 call	 ??$?0HX@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QAE@ABH@Z ; std::chrono::duration<__int64,std::ratio<1,1000> >::duration<__int64,std::ratio<1,1000> ><int,void>
  00151	50		 push	 eax
  00152	e8 00 00 00 00	 call	 ??$sleep_for@_JU?$ratio@$00$0DOI@@std@@@this_thread@std@@YAXABV?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@1@@Z ; std::this_thread::sleep_for<__int64,std::ratio<1,1000> >
  00157	83 c4 04	 add	 esp, 4

; 1263 :     }

  0015a	e9 bf fe ff ff	 jmp	 $LN2@run
$LN3@run:

; 1264 :     check();

  0015f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00162	e8 00 00 00 00	 call	 ?check@CPerfMonitor@@IAEXXZ ; CPerfMonitor::check

; 1265 :     write(m_fpLog.get(),   m_nSelectOutputLog);

  00167	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0016a	8b 91 44 0b 00
	00		 mov	 edx, DWORD PTR [ecx+2884]
  00170	52		 push	 edx
  00171	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00174	81 c1 3c 0b 00
	00		 add	 ecx, 2876		; 00000b3cH
  0017a	e8 00 00 00 00	 call	 ?get@?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@QBEPAU_iobuf@@XZ ; std::unique_ptr<_iobuf,fp_deleter>::get
  0017f	50		 push	 eax
  00180	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00183	e8 00 00 00 00	 call	 ?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z ; CPerfMonitor::write

; 1266 :     write(m_pipes.f_stdin, m_nSelectOutputPlot);

  00188	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0018b	8b 88 48 0b 00
	00		 mov	 ecx, DWORD PTR [eax+2888]
  00191	51		 push	 ecx
  00192	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00195	8b 82 d0 02 00
	00		 mov	 eax, DWORD PTR [edx+720]
  0019b	50		 push	 eax
  0019c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0019f	e8 00 00 00 00	 call	 ?write@CPerfMonitor@@IAEXPAU_iobuf@@H@Z ; CPerfMonitor::write

; 1267 : }

  001a4	5e		 pop	 esi
  001a5	83 c4 14	 add	 esp, 20			; 00000014H
  001a8	3b ec		 cmp	 ebp, esp
  001aa	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001af	8b e5		 mov	 esp, ebp
  001b1	5d		 pop	 ebp
  001b2	c3		 ret	 0
?run@CPerfMonitor@@IAEXXZ ENDP				; CPerfMonitor::run
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\rgy_perf_monitor.cpp
_TEXT	SEGMENT
tv1205 = -552						; size = 4
tv1204 = -548						; size = 4
tv1234 = -544						; size = 8
tv1232 = -536						; size = 8
tv1102 = -528						; size = 4
tv1101 = -524						; size = 4
tv1230 = -520						; size = 8
tv1060 = -512						; size = 4
tv1059 = -508						; size = 4
tv677 = -504						; size = 4
tv676 = -500						; size = 4
$T1 = -493						; size = 1
_videoSecDiff$2 = -492					; size = 8
_videoSec$3 = -484					; size = 8
_data$4 = -472						; size = 176
_exit_code$5 = -288					; size = 4
_exit_code$6 = -276					; size = 4
_exit_code$7 = -264					; size = 4
_exit_code$8 = -252					; size = 4
_exit_code$9 = -240					; size = 4
_logical_cpu_inv$10 = -232				; size = 8
_time_diff_inv$ = -224					; size = 8
_pt$ = -212						; size = 32
_systime$ = -172					; size = 16
_current_time$ = -148					; size = 8
_io_counters$ = -132					; size = 48
_mem_counters$ = -76					; size = 40
_getThreadTime$ = -25					; size = 1
_hProcess$ = -20					; size = 4
_pInfoOld$ = -16					; size = 4
_pInfoNew$ = -12					; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
?check@CPerfMonitor@@IAEXXZ PROC			; CPerfMonitor::check
; _this$ = ecx

; 872  : void CPerfMonitor::check() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 28 02 00
	00		 sub	 esp, 552		; 00000228H
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	51		 push	 ecx
  0000c	8d bd d8 fd ff
	ff		 lea	 edi, DWORD PTR [ebp-552]
  00012	b9 8a 00 00 00	 mov	 ecx, 138		; 0000008aH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	59		 pop	 ecx
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c5		 xor	 eax, ebp
  00026	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00029	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 873  :     PerfInfo *pInfoNew = &m_info[(m_nStep + 1) & 1];

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00031	83 c1 01	 add	 ecx, 1
  00034	83 e1 01	 and	 ecx, 1
  00037	69 d1 38 01 00
	00		 imul	 edx, ecx, 312
  0003d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00040	8d 4c 10 20	 lea	 ecx, DWORD PTR [eax+edx+32]
  00044	89 4d f4	 mov	 DWORD PTR _pInfoNew$[ebp], ecx

; 874  :     PerfInfo *pInfoOld = &m_info[ m_nStep      & 1];

  00047	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0004a	8b 02		 mov	 eax, DWORD PTR [edx]
  0004c	83 e0 01	 and	 eax, 1
  0004f	69 c8 38 01 00
	00		 imul	 ecx, eax, 312
  00055	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00058	8d 44 0a 20	 lea	 eax, DWORD PTR [edx+ecx+32]
  0005c	89 45 f0	 mov	 DWORD PTR _pInfoOld$[ebp], eax

; 875  :     memcpy(pInfoNew, pInfoOld, sizeof(pInfoNew[0]));

  0005f	68 38 01 00 00	 push	 312			; 00000138H
  00064	8b 4d f0	 mov	 ecx, DWORD PTR _pInfoOld$[ebp]
  00067	51		 push	 ecx
  00068	8b 55 f4	 mov	 edx, DWORD PTR _pInfoNew$[ebp]
  0006b	52		 push	 edx
  0006c	e8 00 00 00 00	 call	 _memcpy
  00071	83 c4 0c	 add	 esp, 12			; 0000000cH

; 876  : 
; 877  : #if defined(_WIN32) || defined(_WIN64)
; 878  :     const auto hProcess = GetCurrentProcess();

  00074	8b f4		 mov	 esi, esp
  00076	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentProcess@0
  0007c	3b f4		 cmp	 esi, esp
  0007e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00083	89 45 ec	 mov	 DWORD PTR _hProcess$[ebp], eax

; 879  :     auto getThreadTime = [](HANDLE hThread, PROCESS_TIME *time) {

  00086	33 c0		 xor	 eax, eax
  00088	88 85 13 fe ff
	ff		 mov	 BYTE PTR $T1[ebp], al

; 880  :         GetThreadTimes(hThread, (FILETIME *)&time->creation, (FILETIME *)&time->exit, (FILETIME *)&time->kernel, (FILETIME *)&time->user);
; 881  :     };
; 882  : 
; 883  :     //
; 884  :     PROCESS_MEMORY_COUNTERS mem_counters = { 0 };

  0008e	33 c9		 xor	 ecx, ecx
  00090	89 4d b4	 mov	 DWORD PTR _mem_counters$[ebp], ecx
  00093	89 4d b8	 mov	 DWORD PTR _mem_counters$[ebp+4], ecx
  00096	89 4d bc	 mov	 DWORD PTR _mem_counters$[ebp+8], ecx
  00099	89 4d c0	 mov	 DWORD PTR _mem_counters$[ebp+12], ecx
  0009c	89 4d c4	 mov	 DWORD PTR _mem_counters$[ebp+16], ecx
  0009f	89 4d c8	 mov	 DWORD PTR _mem_counters$[ebp+20], ecx
  000a2	89 4d cc	 mov	 DWORD PTR _mem_counters$[ebp+24], ecx
  000a5	89 4d d0	 mov	 DWORD PTR _mem_counters$[ebp+28], ecx
  000a8	89 4d d4	 mov	 DWORD PTR _mem_counters$[ebp+32], ecx
  000ab	89 4d d8	 mov	 DWORD PTR _mem_counters$[ebp+36], ecx

; 885  :     mem_counters.cb = sizeof(PROCESS_MEMORY_COUNTERS);

  000ae	c7 45 b4 28 00
	00 00		 mov	 DWORD PTR _mem_counters$[ebp], 40 ; 00000028H

; 886  :     GetProcessMemoryInfo(hProcess, &mem_counters, sizeof(mem_counters));

  000b5	6a 28		 push	 40			; 00000028H
  000b7	8d 55 b4	 lea	 edx, DWORD PTR _mem_counters$[ebp]
  000ba	52		 push	 edx
  000bb	8b 45 ec	 mov	 eax, DWORD PTR _hProcess$[ebp]
  000be	50		 push	 eax
  000bf	e8 00 00 00 00	 call	 _K32GetProcessMemoryInfo@12

; 887  :     pInfoNew->mem_private = mem_counters.WorkingSetSize;

  000c4	8b 4d c0	 mov	 ecx, DWORD PTR _mem_counters$[ebp+12]
  000c7	33 d2		 xor	 edx, edx
  000c9	8b 45 f4	 mov	 eax, DWORD PTR _pInfoNew$[ebp]
  000cc	89 48 48	 mov	 DWORD PTR [eax+72], ecx
  000cf	89 50 4c	 mov	 DWORD PTR [eax+76], edx

; 888  :     pInfoNew->mem_virtual = mem_counters.PagefileUsage;

  000d2	8b 4d d4	 mov	 ecx, DWORD PTR _mem_counters$[ebp+32]
  000d5	33 d2		 xor	 edx, edx
  000d7	8b 45 f4	 mov	 eax, DWORD PTR _pInfoNew$[ebp]
  000da	89 48 50	 mov	 DWORD PTR [eax+80], ecx
  000dd	89 50 54	 mov	 DWORD PTR [eax+84], edx

; 889  : 
; 890  :     //IO
; 891  :     IO_COUNTERS io_counters = { 0 };

  000e0	6a 30		 push	 48			; 00000030H
  000e2	6a 00		 push	 0
  000e4	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _io_counters$[ebp]
  000ea	51		 push	 ecx
  000eb	e8 00 00 00 00	 call	 _memset
  000f0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 892  :     GetProcessIoCounters(hProcess, &io_counters);

  000f3	8b f4		 mov	 esi, esp
  000f5	8d 95 7c ff ff
	ff		 lea	 edx, DWORD PTR _io_counters$[ebp]
  000fb	52		 push	 edx
  000fc	8b 45 ec	 mov	 eax, DWORD PTR _hProcess$[ebp]
  000ff	50		 push	 eax
  00100	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcessIoCounters@8
  00106	3b f4		 cmp	 esi, esp
  00108	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 893  :     pInfoNew->io_total_read = io_counters.ReadTransferCount;

  0010d	8b 4d f4	 mov	 ecx, DWORD PTR _pInfoNew$[ebp]
  00110	8b 55 94	 mov	 edx, DWORD PTR _io_counters$[ebp+24]
  00113	89 51 58	 mov	 DWORD PTR [ecx+88], edx
  00116	8b 45 98	 mov	 eax, DWORD PTR _io_counters$[ebp+28]
  00119	89 41 5c	 mov	 DWORD PTR [ecx+92], eax

; 894  :     pInfoNew->io_total_write = io_counters.WriteTransferCount;

  0011c	8b 4d f4	 mov	 ecx, DWORD PTR _pInfoNew$[ebp]
  0011f	8b 55 9c	 mov	 edx, DWORD PTR _io_counters$[ebp+32]
  00122	89 51 60	 mov	 DWORD PTR [ecx+96], edx
  00125	8b 45 a0	 mov	 eax, DWORD PTR _io_counters$[ebp+36]
  00128	89 41 64	 mov	 DWORD PTR [ecx+100], eax

; 895  : 
; 896  :     //
; 897  :     uint64_t current_time = 0;

  0012b	0f 57 c0	 xorps	 xmm0, xmm0
  0012e	66 0f 13 85 6c
	ff ff ff	 movlpd	 QWORD PTR _current_time$[ebp], xmm0

; 898  :     SYSTEMTIME systime = { 0 };

  00136	33 c9		 xor	 ecx, ecx
  00138	89 8d 54 ff ff
	ff		 mov	 DWORD PTR _systime$[ebp], ecx
  0013e	89 8d 58 ff ff
	ff		 mov	 DWORD PTR _systime$[ebp+4], ecx
  00144	89 8d 5c ff ff
	ff		 mov	 DWORD PTR _systime$[ebp+8], ecx
  0014a	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _systime$[ebp+12], ecx

; 899  :     GetSystemTime(&systime);

  00150	8b f4		 mov	 esi, esp
  00152	8d 95 54 ff ff
	ff		 lea	 edx, DWORD PTR _systime$[ebp]
  00158	52		 push	 edx
  00159	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSystemTime@4
  0015f	3b f4		 cmp	 esi, esp
  00161	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 900  :     SystemTimeToFileTime(&systime, (FILETIME *)&current_time);

  00166	8b f4		 mov	 esi, esp
  00168	8d 85 6c ff ff
	ff		 lea	 eax, DWORD PTR _current_time$[ebp]
  0016e	50		 push	 eax
  0016f	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR _systime$[ebp]
  00175	51		 push	 ecx
  00176	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SystemTimeToFileTime@8
  0017c	3b f4		 cmp	 esi, esp
  0017e	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 901  : 
; 902  :     //CPU
; 903  :     PROCESS_TIME pt = { 0 };

  00183	33 d2		 xor	 edx, edx
  00185	89 95 2c ff ff
	ff		 mov	 DWORD PTR _pt$[ebp], edx
  0018b	89 95 30 ff ff
	ff		 mov	 DWORD PTR _pt$[ebp+4], edx
  00191	89 95 34 ff ff
	ff		 mov	 DWORD PTR _pt$[ebp+8], edx
  00197	89 95 38 ff ff
	ff		 mov	 DWORD PTR _pt$[ebp+12], edx
  0019d	89 95 3c ff ff
	ff		 mov	 DWORD PTR _pt$[ebp+16], edx
  001a3	89 95 40 ff ff
	ff		 mov	 DWORD PTR _pt$[ebp+20], edx
  001a9	89 95 44 ff ff
	ff		 mov	 DWORD PTR _pt$[ebp+24], edx
  001af	89 95 48 ff ff
	ff		 mov	 DWORD PTR _pt$[ebp+28], edx

; 904  :     GetProcessTimes(hProcess, (FILETIME *)&pt.creation, (FILETIME *)&pt.exit, (FILETIME *)&pt.kernel, (FILETIME *)&pt.user);

  001b5	8b f4		 mov	 esi, esp
  001b7	8d 85 44 ff ff
	ff		 lea	 eax, DWORD PTR _pt$[ebp+24]
  001bd	50		 push	 eax
  001be	8d 8d 3c ff ff
	ff		 lea	 ecx, DWORD PTR _pt$[ebp+16]
  001c4	51		 push	 ecx
  001c5	8d 95 34 ff ff
	ff		 lea	 edx, DWORD PTR _pt$[ebp+8]
  001cb	52		 push	 edx
  001cc	8d 85 2c ff ff
	ff		 lea	 eax, DWORD PTR _pt$[ebp]
  001d2	50		 push	 eax
  001d3	8b 4d ec	 mov	 ecx, DWORD PTR _hProcess$[ebp]
  001d6	51		 push	 ecx
  001d7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcessTimes@20
  001dd	3b f4		 cmp	 esi, esp
  001df	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 905  :     pInfoNew->time_us = (current_time - pt.creation) / 10;

  001e4	8b 95 6c ff ff
	ff		 mov	 edx, DWORD PTR _current_time$[ebp]
  001ea	2b 95 2c ff ff
	ff		 sub	 edx, DWORD PTR _pt$[ebp]
  001f0	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _current_time$[ebp+4]
  001f6	1b 85 30 ff ff
	ff		 sbb	 eax, DWORD PTR _pt$[ebp+4]
  001fc	6a 00		 push	 0
  001fe	6a 0a		 push	 10			; 0000000aH
  00200	50		 push	 eax
  00201	52		 push	 edx
  00202	e8 00 00 00 00	 call	 __aulldiv
  00207	8b 4d f4	 mov	 ecx, DWORD PTR _pInfoNew$[ebp]
  0020a	89 01		 mov	 DWORD PTR [ecx], eax
  0020c	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 906  :     const double time_diff_inv = 1.0 / (pInfoNew->time_us - pInfoOld->time_us);

  0020f	8b 55 f4	 mov	 edx, DWORD PTR _pInfoNew$[ebp]
  00212	8b 45 f0	 mov	 eax, DWORD PTR _pInfoOld$[ebp]
  00215	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00217	2b 08		 sub	 ecx, DWORD PTR [eax]
  00219	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  0021c	1b 50 04	 sbb	 edx, DWORD PTR [eax+4]
  0021f	e8 00 00 00 00	 call	 __ltod3
  00224	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@3ff0000000000000
  0022c	f2 0f 5e c8	 divsd	 xmm1, xmm0
  00230	f2 0f 11 8d 20
	ff ff ff	 movsd	 QWORD PTR _time_diff_inv$[ebp], xmm1

; 907  : 
; 908  :     //GPU
; 909  :     m_bGPUZInfoValid = false;

  00238	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0023b	c6 81 78 19 03
	00 00		 mov	 BYTE PTR [ecx+203128], 0

; 910  :     pInfoNew->gpu_info_valid = FALSE;

  00242	8b 55 f4	 mov	 edx, DWORD PTR _pInfoNew$[ebp]
  00245	c7 82 f0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+240], 0

; 911  : #if ENABLE_METRIC_FRAMEWORK
; 912  :     QSVGPUInfo qsvinfo = { 0 };
; 913  :     if (m_Consumer.getMFXLoad(&qsvinfo)) {
; 914  :         pInfoNew->gpu_info_valid = TRUE;
; 915  :         pInfoNew->mfx_load_percent = qsvinfo.dMFXLoad;
; 916  :         pInfoNew->gpu_load_percent = qsvinfo.dEULoad;
; 917  :         pInfoNew->gpu_clock = qsvinfo.dGPUFreq;
; 918  :     } else {
; 919  : #endif //#if ENABLE_METRIC_FRAMEWORK
; 920  : #if ENABLE_NVML
; 921  :     pInfoNew->gpu_info_valid   = FALSE;
; 922  :     pInfoNew->gpu_clock = 0.0;
; 923  :     pInfoNew->gpu_load_percent = 0.0;
; 924  :     pInfoNew->ve_clock = 0.0;
; 925  :     pInfoNew->vee_load_percent = 0.0;
; 926  :     pInfoNew->ved_load_percent = 0.0;
; 927  :     pInfoNew->pcie_gen = 0;
; 928  :     pInfoNew->pcie_link = 0;
; 929  :     pInfoNew->pcie_throughput_tx_per_sec = 0;
; 930  :     pInfoNew->pcie_throughput_rx_per_sec = 0;
; 931  :     NVMLMonitorInfo nvmlInfo;
; 932  :     if (m_nvmlMonitor.getData(&nvmlInfo) == NVML_SUCCESS) {
; 933  :         m_nvmlInfo = nvmlInfo;
; 934  :         pInfoNew->gpu_info_valid   = TRUE;
; 935  :         pInfoNew->gpu_clock        = m_nvmlInfo.GPUFreq;
; 936  :         pInfoNew->gpu_load_percent = m_nvmlInfo.GPULoad;
; 937  :         pInfoNew->ve_clock         = m_nvmlInfo.VEFreq;
; 938  :         pInfoNew->vee_load_percent = m_nvmlInfo.VEELoad;
; 939  :         pInfoNew->ved_load_percent = m_nvmlInfo.VEDLoad;
; 940  :         pInfoNew->pcie_gen         = m_nvmlInfo.pcieGen;
; 941  :         pInfoNew->pcie_link        = m_nvmlInfo.pcieLink;
; 942  :         pInfoNew->pcie_throughput_tx_per_sec = m_nvmlInfo.pcieLoadTX;
; 943  :         pInfoNew->pcie_throughput_rx_per_sec = m_nvmlInfo.pcieLoadRX;
; 944  :     } else {
; 945  : #endif //#if ENABLE_NVML
; 946  :         pInfoNew->gpu_clock = 0.0;

  0024f	8b 45 f4	 mov	 eax, DWORD PTR _pInfoNew$[ebp]
  00252	0f 57 c0	 xorps	 xmm0, xmm0
  00255	f2 0f 11 80 00
	01 00 00	 movsd	 QWORD PTR [eax+256], xmm0

; 947  :         pInfoNew->gpu_load_percent = 0.0;

  0025d	8b 4d f4	 mov	 ecx, DWORD PTR _pInfoNew$[ebp]
  00260	0f 57 c0	 xorps	 xmm0, xmm0
  00263	f2 0f 11 81 f8
	00 00 00	 movsd	 QWORD PTR [ecx+248], xmm0

; 948  :         pInfoNew->ve_clock = 0.0;

  0026b	8b 55 f4	 mov	 edx, DWORD PTR _pInfoNew$[ebp]
  0026e	0f 57 c0	 xorps	 xmm0, xmm0
  00271	f2 0f 11 82 20
	01 00 00	 movsd	 QWORD PTR [edx+288], xmm0

; 949  :         pInfoNew->vee_load_percent = 0.0;

  00279	8b 45 f4	 mov	 eax, DWORD PTR _pInfoNew$[ebp]
  0027c	0f 57 c0	 xorps	 xmm0, xmm0
  0027f	f2 0f 11 80 10
	01 00 00	 movsd	 QWORD PTR [eax+272], xmm0

; 950  :         pInfoNew->ved_load_percent = 0.0;

  00287	8b 4d f4	 mov	 ecx, DWORD PTR _pInfoNew$[ebp]
  0028a	0f 57 c0	 xorps	 xmm0, xmm0
  0028d	f2 0f 11 81 18
	01 00 00	 movsd	 QWORD PTR [ecx+280], xmm0

; 951  :         pInfoNew->pcie_gen = 0;

  00295	8b 55 f4	 mov	 edx, DWORD PTR _pInfoNew$[ebp]
  00298	c7 82 28 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+296], 0

; 952  :         pInfoNew->pcie_link = 0;

  002a2	8b 45 f4	 mov	 eax, DWORD PTR _pInfoNew$[ebp]
  002a5	c7 80 2c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+300], 0

; 953  :         pInfoNew->pcie_throughput_tx_per_sec = 0;

  002af	8b 4d f4	 mov	 ecx, DWORD PTR _pInfoNew$[ebp]
  002b2	c7 81 30 01 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+304], 0

; 954  :         pInfoNew->pcie_throughput_rx_per_sec = 0;

  002bc	8b 55 f4	 mov	 edx, DWORD PTR _pInfoNew$[ebp]
  002bf	c7 82 34 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+308], 0

; 955  : #if ENABLE_GPUZ_INFO
; 956  :         memset(&m_GPUZInfo, 0, sizeof(m_GPUZInfo));

  002c9	68 0c 0e 03 00	 push	 200204			; 00030e0cH
  002ce	6a 00		 push	 0
  002d0	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  002d3	05 6c 0b 00 00	 add	 eax, 2924		; 00000b6cH
  002d8	50		 push	 eax
  002d9	e8 00 00 00 00	 call	 _memset
  002de	83 c4 0c	 add	 esp, 12			; 0000000cH

; 957  :         if (0 == get_gpuz_info(&m_GPUZInfo)) {

  002e1	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  002e4	81 c1 6c 0b 00
	00		 add	 ecx, 2924		; 00000b6cH
  002ea	51		 push	 ecx
  002eb	e8 00 00 00 00	 call	 ?get_gpuz_info@@YAHPAUGPUZ_SH_MEM@@@Z ; get_gpuz_info
  002f0	83 c4 04	 add	 esp, 4
  002f3	85 c0		 test	 eax, eax
  002f5	75 69		 jne	 SHORT $LN2@check

; 958  :             m_bGPUZInfoValid = true;

  002f7	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  002fa	c6 82 78 19 03
	00 01		 mov	 BYTE PTR [edx+203128], 1

; 959  :             pInfoNew->gpu_info_valid = TRUE;

  00301	8b 45 f4	 mov	 eax, DWORD PTR _pInfoNew$[ebp]
  00304	c7 80 f0 00 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+240], 1

; 960  :             pInfoNew->gpu_load_percent = gpu_load(&m_GPUZInfo);

  0030e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00311	81 c1 6c 0b 00
	00		 add	 ecx, 2924		; 00000b6cH
  00317	51		 push	 ecx
  00318	e8 00 00 00 00	 call	 ?gpu_load@@YANPAUGPUZ_SH_MEM@@@Z ; gpu_load
  0031d	83 c4 04	 add	 esp, 4
  00320	8b 55 f4	 mov	 edx, DWORD PTR _pInfoNew$[ebp]
  00323	dd 9a f8 00 00
	00		 fstp	 QWORD PTR [edx+248]

; 961  :             pInfoNew->vee_load_percent = video_engine_load(&m_GPUZInfo, nullptr);

  00329	6a 00		 push	 0
  0032b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0032e	05 6c 0b 00 00	 add	 eax, 2924		; 00000b6cH
  00333	50		 push	 eax
  00334	e8 00 00 00 00	 call	 ?video_engine_load@@YANPAUGPUZ_SH_MEM@@PA_N@Z ; video_engine_load
  00339	83 c4 08	 add	 esp, 8
  0033c	8b 4d f4	 mov	 ecx, DWORD PTR _pInfoNew$[ebp]
  0033f	dd 99 10 01 00
	00		 fstp	 QWORD PTR [ecx+272]

; 962  :             pInfoNew->gpu_clock = gpu_core_clock(&m_GPUZInfo);

  00345	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00348	81 c2 6c 0b 00
	00		 add	 edx, 2924		; 00000b6cH
  0034e	52		 push	 edx
  0034f	e8 00 00 00 00	 call	 ?gpu_core_clock@@YANPAUGPUZ_SH_MEM@@@Z ; gpu_core_clock
  00354	83 c4 04	 add	 esp, 4
  00357	8b 45 f4	 mov	 eax, DWORD PTR _pInfoNew$[ebp]
  0035a	dd 98 00 01 00
	00		 fstp	 QWORD PTR [eax+256]
$LN2@check:

; 963  :         }
; 964  : #endif //#if ENABLE_GPUZ_INFO
; 965  : #if ENABLE_METRIC_FRAMEWORK || ENABLE_NVML
; 966  :     }
; 967  : #endif //#if ENABLE_METRIC_FRAMEWORK || ENABLE_NVML
; 968  : #else
; 969  :     struct rusage usage = { 0 };
; 970  :     getrusage(RUSAGE_SELF, &usage);
; 971  : 
; 972  :     //
; 973  :     uint64_t current_time = clock() * (1e7 / CLOCKS_PER_SEC);
; 974  : 
; 975  :     std::string proc_dir = strsprintf("/proc/%d/", (int)getpid());
; 976  :     //
; 977  :     FILE *fp_mem = popen((std::string("cat ") + proc_dir + std::string("status")).c_str(), "r");
; 978  :     if (fp_mem) {
; 979  :         char buffer[2048] = { 0 };
; 980  :         while (NULL != fgets(buffer, _countof(buffer), fp_mem)) {
; 981  :             if (nullptr != strstr(buffer, "VmSize")) {
; 982  :                 long long i = 0;
; 983  :                 if (1 == sscanf(buffer, "VmSize: %lld kB", &i)) {
; 984  :                     pInfoNew->mem_virtual = i << 10;
; 985  :                 }
; 986  :             } else if (nullptr != strstr(buffer, "VmRSS")) {
; 987  :                 long long i = 0;
; 988  :                 if (1 == sscanf(buffer, "VmRSS: %lld kB", &i)) {
; 989  :                     pInfoNew->mem_private = i << 10;
; 990  :                 }
; 991  :             }
; 992  :         }
; 993  :         fclose(fp_mem);
; 994  :     }
; 995  :     //IO
; 996  :     FILE *fp_io = popen((std::string("cat ") + proc_dir + std::string("io")).c_str(), "r");
; 997  :     if (fp_io) {
; 998  :         char buffer[2048] = { 0 };
; 999  :         while (NULL != fgets(buffer, _countof(buffer), fp_io)) {
; 1000 :             if (nullptr != strstr(buffer, "rchar:")) {
; 1001 :                 long long i = 0;
; 1002 :                 if (1 == sscanf(buffer, "rchar: %lld", &i)) {
; 1003 :                     pInfoNew->io_total_read = i;
; 1004 :                 }
; 1005 :             } else if (nullptr != strstr(buffer, "wchar")) {
; 1006 :                 long long i = 0;
; 1007 :                 if (1 == sscanf(buffer, "wchar: %lld", &i)) {
; 1008 :                     pInfoNew->io_total_write = i;
; 1009 :                 }
; 1010 :             }
; 1011 :         }
; 1012 :         fclose(fp_io);
; 1013 :     }
; 1014 : 
; 1015 :     //CPU
; 1016 :     pInfoNew->time_us = (current_time - m_nCreateTime100ns) / 10;
; 1017 :     const double time_diff_inv = 1.0 / (pInfoNew->time_us - pInfoOld->time_us);
; 1018 : #endif
; 1019 : 
; 1020 :     if (pInfoNew->time_us > pInfoOld->time_us) {

  00360	8b 4d f4	 mov	 ecx, DWORD PTR _pInfoNew$[ebp]
  00363	8b 55 f0	 mov	 edx, DWORD PTR _pInfoOld$[ebp]
  00366	89 8d 0c fe ff
	ff		 mov	 DWORD PTR tv676[ebp], ecx
  0036c	89 95 08 fe ff
	ff		 mov	 DWORD PTR tv677[ebp], edx
  00372	8b 85 0c fe ff
	ff		 mov	 eax, DWORD PTR tv676[ebp]
  00378	8b 8d 08 fe ff
	ff		 mov	 ecx, DWORD PTR tv677[ebp]
  0037e	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00381	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00384	0f 8c 65 06 00
	00		 jl	 $LN19@check
  0038a	7f 16		 jg	 SHORT $LN27@check
  0038c	8b 85 0c fe ff
	ff		 mov	 eax, DWORD PTR tv676[ebp]
  00392	8b 8d 08 fe ff
	ff		 mov	 ecx, DWORD PTR tv677[ebp]
  00398	8b 10		 mov	 edx, DWORD PTR [eax]
  0039a	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0039c	0f 86 4d 06 00
	00		 jbe	 $LN19@check
$LN27@check:

; 1021 : #if defined(_WIN32) || defined(_WIN64)
; 1022 :         pInfoNew->cpu_total_us = (pt.user + pt.kernel) / 10;

  003a2	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _pt$[ebp+24]
  003a8	03 85 3c ff ff
	ff		 add	 eax, DWORD PTR _pt$[ebp+16]
  003ae	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR _pt$[ebp+28]
  003b4	13 8d 40 ff ff
	ff		 adc	 ecx, DWORD PTR _pt$[ebp+20]
  003ba	6a 00		 push	 0
  003bc	6a 0a		 push	 10			; 0000000aH
  003be	51		 push	 ecx
  003bf	50		 push	 eax
  003c0	e8 00 00 00 00	 call	 __aulldiv
  003c5	8b 4d f4	 mov	 ecx, DWORD PTR _pInfoNew$[ebp]
  003c8	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  003cb	89 51 0c	 mov	 DWORD PTR [ecx+12], edx

; 1023 :         pInfoNew->cpu_total_kernel_us = pt.kernel / 10;

  003ce	6a 00		 push	 0
  003d0	6a 0a		 push	 10			; 0000000aH
  003d2	8b 95 40 ff ff
	ff		 mov	 edx, DWORD PTR _pt$[ebp+20]
  003d8	52		 push	 edx
  003d9	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _pt$[ebp+16]
  003df	50		 push	 eax
  003e0	e8 00 00 00 00	 call	 __aulldiv
  003e5	8b 4d f4	 mov	 ecx, DWORD PTR _pInfoNew$[ebp]
  003e8	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  003eb	89 51 14	 mov	 DWORD PTR [ecx+20], edx

; 1024 : #else
; 1025 :         int64_t cpu_user_us = usage.ru_utime.tv_sec * 1000000 + usage.ru_utime.tv_usec;
; 1026 :         int64_t cpu_kernel_us = usage.ru_stime.tv_sec * 1000000 + usage.ru_stime.tv_usec;
; 1027 :         pInfoNew->cpu_total_us = cpu_user_us + cpu_kernel_us;
; 1028 :         pInfoNew->cpu_total_kernel_us = cpu_kernel_us;
; 1029 : #endif //#if defined(_WIN32) || defined(_WIN64)
; 1030 : 
; 1031 :         //CPU
; 1032 :         const double logical_cpu_inv       = 1.0 / m_nLogicalCPU;

  003ee	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  003f1	f2 0f 2a 82 ec
	0a 00 00	 cvtsi2sd xmm0, DWORD PTR [edx+2796]
  003f9	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@3ff0000000000000
  00401	f2 0f 5e c8	 divsd	 xmm1, xmm0
  00405	f2 0f 11 8d 18
	ff ff ff	 movsd	 QWORD PTR _logical_cpu_inv$10[ebp], xmm1

; 1033 :         pInfoNew->cpu_percent        = (pInfoNew->cpu_total_us        - pInfoOld->cpu_total_us) * 100.0 * logical_cpu_inv * time_diff_inv;

  0040d	8b 45 f4	 mov	 eax, DWORD PTR _pInfoNew$[ebp]
  00410	8b 4d f0	 mov	 ecx, DWORD PTR _pInfoOld$[ebp]
  00413	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  00416	2b 71 08	 sub	 esi, DWORD PTR [ecx+8]
  00419	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0041c	1b 51 0c	 sbb	 edx, DWORD PTR [ecx+12]
  0041f	8b ce		 mov	 ecx, esi
  00421	e8 00 00 00 00	 call	 __ltod3
  00426	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@4059000000000000
  0042e	f2 0f 59 85 18
	ff ff ff	 mulsd	 xmm0, QWORD PTR _logical_cpu_inv$10[ebp]
  00436	f2 0f 59 85 20
	ff ff ff	 mulsd	 xmm0, QWORD PTR _time_diff_inv$[ebp]
  0043e	8b 55 f4	 mov	 edx, DWORD PTR _pInfoNew$[ebp]
  00441	f2 0f 11 82 b0
	00 00 00	 movsd	 QWORD PTR [edx+176], xmm0

; 1034 :         pInfoNew->cpu_kernel_percent = (pInfoNew->cpu_total_kernel_us - pInfoOld->cpu_total_kernel_us) * 100.0 * logical_cpu_inv * time_diff_inv;

  00449	8b 45 f4	 mov	 eax, DWORD PTR _pInfoNew$[ebp]
  0044c	8b 4d f0	 mov	 ecx, DWORD PTR _pInfoOld$[ebp]
  0044f	8b 70 10	 mov	 esi, DWORD PTR [eax+16]
  00452	2b 71 10	 sub	 esi, DWORD PTR [ecx+16]
  00455	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00458	1b 51 14	 sbb	 edx, DWORD PTR [ecx+20]
  0045b	8b ce		 mov	 ecx, esi
  0045d	e8 00 00 00 00	 call	 __ltod3
  00462	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@4059000000000000
  0046a	f2 0f 59 85 18
	ff ff ff	 mulsd	 xmm0, QWORD PTR _logical_cpu_inv$10[ebp]
  00472	f2 0f 59 85 20
	ff ff ff	 mulsd	 xmm0, QWORD PTR _time_diff_inv$[ebp]
  0047a	8b 55 f4	 mov	 edx, DWORD PTR _pInfoNew$[ebp]
  0047d	f2 0f 11 82 b8
	00 00 00	 movsd	 QWORD PTR [edx+184], xmm0

; 1035 : 
; 1036 :         //IO
; 1037 :         pInfoNew->io_read_per_sec = (pInfoNew->io_total_read - pInfoOld->io_total_read) * time_diff_inv * 1e6;

  00485	8b 45 f4	 mov	 eax, DWORD PTR _pInfoNew$[ebp]
  00488	8b 4d f0	 mov	 ecx, DWORD PTR _pInfoOld$[ebp]
  0048b	8b 70 58	 mov	 esi, DWORD PTR [eax+88]
  0048e	2b 71 58	 sub	 esi, DWORD PTR [ecx+88]
  00491	8b 50 5c	 mov	 edx, DWORD PTR [eax+92]
  00494	1b 51 5c	 sbb	 edx, DWORD PTR [ecx+92]
  00497	8b ce		 mov	 ecx, esi
  00499	e8 00 00 00 00	 call	 __ltod3
  0049e	f2 0f 59 85 20
	ff ff ff	 mulsd	 xmm0, QWORD PTR _time_diff_inv$[ebp]
  004a6	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@412e848000000000
  004ae	8b 55 f4	 mov	 edx, DWORD PTR _pInfoNew$[ebp]
  004b1	f2 0f 11 82 a0
	00 00 00	 movsd	 QWORD PTR [edx+160], xmm0

; 1038 :         pInfoNew->io_write_per_sec = (pInfoNew->io_total_write - pInfoOld->io_total_write) * time_diff_inv * 1e6;

  004b9	8b 45 f4	 mov	 eax, DWORD PTR _pInfoNew$[ebp]
  004bc	8b 4d f0	 mov	 ecx, DWORD PTR _pInfoOld$[ebp]
  004bf	8b 70 60	 mov	 esi, DWORD PTR [eax+96]
  004c2	2b 71 60	 sub	 esi, DWORD PTR [ecx+96]
  004c5	8b 50 64	 mov	 edx, DWORD PTR [eax+100]
  004c8	1b 51 64	 sbb	 edx, DWORD PTR [ecx+100]
  004cb	8b ce		 mov	 ecx, esi
  004cd	e8 00 00 00 00	 call	 __ltod3
  004d2	f2 0f 59 85 20
	ff ff ff	 mulsd	 xmm0, QWORD PTR _time_diff_inv$[ebp]
  004da	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@412e848000000000
  004e2	8b 55 f4	 mov	 edx, DWORD PTR _pInfoNew$[ebp]
  004e5	f2 0f 11 82 a8
	00 00 00	 movsd	 QWORD PTR [edx+168], xmm0

; 1039 : 
; 1040 : #if defined(_WIN32) || defined(_WIN64)
; 1041 :         //CPU
; 1042 :         if (m_thMainThread) {

  004ed	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  004f0	81 c1 98 02 00
	00		 add	 ecx, 664		; 00000298H
  004f6	e8 00 00 00 00	 call	 ??B?$unique_ptr@XUhandle_deleter@@@std@@QBE_NXZ ; std::unique_ptr<void,handle_deleter>::operator bool
  004fb	0f b6 c0	 movzx	 eax, al
  004fe	85 c0		 test	 eax, eax
  00500	0f 84 84 00 00
	00		 je	 $LN4@check

; 1043 :             getThreadTime(m_thMainThread.get(), &pt);

  00506	8d 8d 2c ff ff
	ff		 lea	 ecx, DWORD PTR _pt$[ebp]
  0050c	51		 push	 ecx
  0050d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00510	81 c1 98 02 00
	00		 add	 ecx, 664		; 00000298H
  00516	e8 00 00 00 00	 call	 ?get@?$unique_ptr@XUhandle_deleter@@@std@@QBEPAXXZ ; std::unique_ptr<void,handle_deleter>::get
  0051b	50		 push	 eax
  0051c	8d 4d e7	 lea	 ecx, DWORD PTR _getThreadTime$[ebp]
  0051f	e8 00 00 00 00	 call	 ??R<lambda_ee86f6c47a1a90e9cd4ba874c2bef330>@@QBEXPAXPAUPROCESS_TIME@@@Z ; <lambda_ee86f6c47a1a90e9cd4ba874c2bef330>::operator()

; 1044 :             pInfoNew->main_thread_total_active_us = (pt.user + pt.kernel) / 10;

  00524	8b 95 44 ff ff
	ff		 mov	 edx, DWORD PTR _pt$[ebp+24]
  0052a	03 95 3c ff ff
	ff		 add	 edx, DWORD PTR _pt$[ebp+16]
  00530	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _pt$[ebp+28]
  00536	13 85 40 ff ff
	ff		 adc	 eax, DWORD PTR _pt$[ebp+20]
  0053c	6a 00		 push	 0
  0053e	6a 0a		 push	 10			; 0000000aH
  00540	50		 push	 eax
  00541	52		 push	 edx
  00542	e8 00 00 00 00	 call	 __aulldiv
  00547	8b 4d f4	 mov	 ecx, DWORD PTR _pInfoNew$[ebp]
  0054a	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  0054d	89 51 1c	 mov	 DWORD PTR [ecx+28], edx

; 1045 :             pInfoNew->main_thread_percent = (pInfoNew->main_thread_total_active_us - pInfoOld->main_thread_total_active_us) * 100.0 * logical_cpu_inv * time_diff_inv;

  00550	8b 55 f4	 mov	 edx, DWORD PTR _pInfoNew$[ebp]
  00553	8b 45 f0	 mov	 eax, DWORD PTR _pInfoOld$[ebp]
  00556	8b 4a 18	 mov	 ecx, DWORD PTR [edx+24]
  00559	2b 48 18	 sub	 ecx, DWORD PTR [eax+24]
  0055c	8b 52 1c	 mov	 edx, DWORD PTR [edx+28]
  0055f	1b 50 1c	 sbb	 edx, DWORD PTR [eax+28]
  00562	e8 00 00 00 00	 call	 __ltod3
  00567	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@4059000000000000
  0056f	f2 0f 59 85 18
	ff ff ff	 mulsd	 xmm0, QWORD PTR _logical_cpu_inv$10[ebp]
  00577	f2 0f 59 85 20
	ff ff ff	 mulsd	 xmm0, QWORD PTR _time_diff_inv$[ebp]
  0057f	8b 4d f4	 mov	 ecx, DWORD PTR _pInfoNew$[ebp]
  00582	f2 0f 11 81 c0
	00 00 00	 movsd	 QWORD PTR [ecx+192], xmm0
$LN4@check:

; 1046 :         }
; 1047 : 
; 1048 :         if (m_thEncThread) {

  0058a	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0058d	83 ba d8 0a 00
	00 00		 cmp	 DWORD PTR [edx+2776], 0
  00594	0f 84 d1 00 00
	00		 je	 $LN7@check

; 1049 :             DWORD exit_code = 0;

  0059a	c7 85 10 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _exit_code$9[ebp], 0

; 1050 :             if (0 != GetExitCodeThread(m_thEncThread, &exit_code) && exit_code == STILL_ACTIVE) {

  005a4	8b f4		 mov	 esi, esp
  005a6	8d 85 10 ff ff
	ff		 lea	 eax, DWORD PTR _exit_code$9[ebp]
  005ac	50		 push	 eax
  005ad	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  005b0	8b 91 d8 0a 00
	00		 mov	 edx, DWORD PTR [ecx+2776]
  005b6	52		 push	 edx
  005b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetExitCodeThread@8
  005bd	3b f4		 cmp	 esi, esp
  005bf	e8 00 00 00 00	 call	 __RTC_CheckEsp
  005c4	85 c0		 test	 eax, eax
  005c6	0f 84 91 00 00
	00		 je	 $LN6@check
  005cc	81 bd 10 ff ff
	ff 03 01 00 00	 cmp	 DWORD PTR _exit_code$9[ebp], 259 ; 00000103H
  005d6	0f 85 81 00 00
	00		 jne	 $LN6@check

; 1051 :                 getThreadTime(m_thEncThread, &pt);

  005dc	8d 85 2c ff ff
	ff		 lea	 eax, DWORD PTR _pt$[ebp]
  005e2	50		 push	 eax
  005e3	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  005e6	8b 91 d8 0a 00
	00		 mov	 edx, DWORD PTR [ecx+2776]
  005ec	52		 push	 edx
  005ed	8d 4d e7	 lea	 ecx, DWORD PTR _getThreadTime$[ebp]
  005f0	e8 00 00 00 00	 call	 ??R<lambda_ee86f6c47a1a90e9cd4ba874c2bef330>@@QBEXPAXPAUPROCESS_TIME@@@Z ; <lambda_ee86f6c47a1a90e9cd4ba874c2bef330>::operator()

; 1052 :                 pInfoNew->enc_thread_total_active_us = (pt.user + pt.kernel) / 10;

  005f5	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _pt$[ebp+24]
  005fb	03 85 3c ff ff
	ff		 add	 eax, DWORD PTR _pt$[ebp+16]
  00601	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR _pt$[ebp+28]
  00607	13 8d 40 ff ff
	ff		 adc	 ecx, DWORD PTR _pt$[ebp+20]
  0060d	6a 00		 push	 0
  0060f	6a 0a		 push	 10			; 0000000aH
  00611	51		 push	 ecx
  00612	50		 push	 eax
  00613	e8 00 00 00 00	 call	 __aulldiv
  00618	8b 4d f4	 mov	 ecx, DWORD PTR _pInfoNew$[ebp]
  0061b	89 41 20	 mov	 DWORD PTR [ecx+32], eax
  0061e	89 51 24	 mov	 DWORD PTR [ecx+36], edx

; 1053 :                 pInfoNew->enc_thread_percent  = (pInfoNew->enc_thread_total_active_us  - pInfoOld->enc_thread_total_active_us) * 100.0 * logical_cpu_inv * time_diff_inv;

  00621	8b 55 f4	 mov	 edx, DWORD PTR _pInfoNew$[ebp]
  00624	8b 45 f0	 mov	 eax, DWORD PTR _pInfoOld$[ebp]
  00627	8b 4a 20	 mov	 ecx, DWORD PTR [edx+32]
  0062a	2b 48 20	 sub	 ecx, DWORD PTR [eax+32]
  0062d	8b 52 24	 mov	 edx, DWORD PTR [edx+36]
  00630	1b 50 24	 sbb	 edx, DWORD PTR [eax+36]
  00633	e8 00 00 00 00	 call	 __ltod3
  00638	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@4059000000000000
  00640	f2 0f 59 85 18
	ff ff ff	 mulsd	 xmm0, QWORD PTR _logical_cpu_inv$10[ebp]
  00648	f2 0f 59 85 20
	ff ff ff	 mulsd	 xmm0, QWORD PTR _time_diff_inv$[ebp]
  00650	8b 4d f4	 mov	 ecx, DWORD PTR _pInfoNew$[ebp]
  00653	f2 0f 11 81 c8
	00 00 00	 movsd	 QWORD PTR [ecx+200], xmm0

; 1054 :             } else {

  0065b	eb 0e		 jmp	 SHORT $LN7@check
$LN6@check:

; 1055 :                 pInfoNew->enc_thread_percent = 0.0;

  0065d	8b 55 f4	 mov	 edx, DWORD PTR _pInfoNew$[ebp]
  00660	0f 57 c0	 xorps	 xmm0, xmm0
  00663	f2 0f 11 82 c8
	00 00 00	 movsd	 QWORD PTR [edx+200], xmm0
$LN7@check:

; 1056 :             }
; 1057 :         }
; 1058 : 
; 1059 :         if (m_thAudProcThread) {

  0066b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0066e	83 b8 e4 0a 00
	00 00		 cmp	 DWORD PTR [eax+2788], 0
  00675	0f 84 d1 00 00
	00		 je	 $LN10@check

; 1060 :             DWORD exit_code = 0;

  0067b	c7 85 04 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _exit_code$8[ebp], 0

; 1061 :             if (0 != GetExitCodeThread(m_thAudProcThread, &exit_code) && exit_code == STILL_ACTIVE) {

  00685	8b f4		 mov	 esi, esp
  00687	8d 8d 04 ff ff
	ff		 lea	 ecx, DWORD PTR _exit_code$8[ebp]
  0068d	51		 push	 ecx
  0068e	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00691	8b 82 e4 0a 00
	00		 mov	 eax, DWORD PTR [edx+2788]
  00697	50		 push	 eax
  00698	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetExitCodeThread@8
  0069e	3b f4		 cmp	 esi, esp
  006a0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  006a5	85 c0		 test	 eax, eax
  006a7	0f 84 91 00 00
	00		 je	 $LN9@check
  006ad	81 bd 04 ff ff
	ff 03 01 00 00	 cmp	 DWORD PTR _exit_code$8[ebp], 259 ; 00000103H
  006b7	0f 85 81 00 00
	00		 jne	 $LN9@check

; 1062 :                 getThreadTime(m_thAudProcThread, &pt);

  006bd	8d 8d 2c ff ff
	ff		 lea	 ecx, DWORD PTR _pt$[ebp]
  006c3	51		 push	 ecx
  006c4	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  006c7	8b 82 e4 0a 00
	00		 mov	 eax, DWORD PTR [edx+2788]
  006cd	50		 push	 eax
  006ce	8d 4d e7	 lea	 ecx, DWORD PTR _getThreadTime$[ebp]
  006d1	e8 00 00 00 00	 call	 ??R<lambda_ee86f6c47a1a90e9cd4ba874c2bef330>@@QBEXPAXPAUPROCESS_TIME@@@Z ; <lambda_ee86f6c47a1a90e9cd4ba874c2bef330>::operator()

; 1063 :                 pInfoNew->aud_proc_thread_total_active_us = (pt.user + pt.kernel) / 10;

  006d6	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _pt$[ebp+24]
  006dc	03 8d 3c ff ff
	ff		 add	 ecx, DWORD PTR _pt$[ebp+16]
  006e2	8b 95 48 ff ff
	ff		 mov	 edx, DWORD PTR _pt$[ebp+28]
  006e8	13 95 40 ff ff
	ff		 adc	 edx, DWORD PTR _pt$[ebp+20]
  006ee	6a 00		 push	 0
  006f0	6a 0a		 push	 10			; 0000000aH
  006f2	52		 push	 edx
  006f3	51		 push	 ecx
  006f4	e8 00 00 00 00	 call	 __aulldiv
  006f9	8b 4d f4	 mov	 ecx, DWORD PTR _pInfoNew$[ebp]
  006fc	89 41 28	 mov	 DWORD PTR [ecx+40], eax
  006ff	89 51 2c	 mov	 DWORD PTR [ecx+44], edx

; 1064 :                 pInfoNew->aud_proc_thread_percent  = (pInfoNew->aud_proc_thread_total_active_us  - pInfoOld->aud_proc_thread_total_active_us) * 100.0 * logical_cpu_inv * time_diff_inv;

  00702	8b 55 f4	 mov	 edx, DWORD PTR _pInfoNew$[ebp]
  00705	8b 45 f0	 mov	 eax, DWORD PTR _pInfoOld$[ebp]
  00708	8b 4a 28	 mov	 ecx, DWORD PTR [edx+40]
  0070b	2b 48 28	 sub	 ecx, DWORD PTR [eax+40]
  0070e	8b 52 2c	 mov	 edx, DWORD PTR [edx+44]
  00711	1b 50 2c	 sbb	 edx, DWORD PTR [eax+44]
  00714	e8 00 00 00 00	 call	 __ltod3
  00719	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@4059000000000000
  00721	f2 0f 59 85 18
	ff ff ff	 mulsd	 xmm0, QWORD PTR _logical_cpu_inv$10[ebp]
  00729	f2 0f 59 85 20
	ff ff ff	 mulsd	 xmm0, QWORD PTR _time_diff_inv$[ebp]
  00731	8b 4d f4	 mov	 ecx, DWORD PTR _pInfoNew$[ebp]
  00734	f2 0f 11 81 d0
	00 00 00	 movsd	 QWORD PTR [ecx+208], xmm0

; 1065 :             } else {

  0073c	eb 0e		 jmp	 SHORT $LN10@check
$LN9@check:

; 1066 :                 pInfoNew->aud_proc_thread_percent = 0.0;

  0073e	8b 55 f4	 mov	 edx, DWORD PTR _pInfoNew$[ebp]
  00741	0f 57 c0	 xorps	 xmm0, xmm0
  00744	f2 0f 11 82 d0
	00 00 00	 movsd	 QWORD PTR [edx+208], xmm0
$LN10@check:

; 1067 :             }
; 1068 :         }
; 1069 : 
; 1070 :         if (m_thAudEncThread) {

  0074c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0074f	83 b8 e8 0a 00
	00 00		 cmp	 DWORD PTR [eax+2792], 0
  00756	0f 84 d1 00 00
	00		 je	 $LN13@check

; 1071 :             DWORD exit_code = 0;

  0075c	c7 85 f8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _exit_code$7[ebp], 0

; 1072 :             if (0 != GetExitCodeThread(m_thAudEncThread, &exit_code) && exit_code == STILL_ACTIVE) {

  00766	8b f4		 mov	 esi, esp
  00768	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _exit_code$7[ebp]
  0076e	51		 push	 ecx
  0076f	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00772	8b 82 e8 0a 00
	00		 mov	 eax, DWORD PTR [edx+2792]
  00778	50		 push	 eax
  00779	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetExitCodeThread@8
  0077f	3b f4		 cmp	 esi, esp
  00781	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00786	85 c0		 test	 eax, eax
  00788	0f 84 91 00 00
	00		 je	 $LN12@check
  0078e	81 bd f8 fe ff
	ff 03 01 00 00	 cmp	 DWORD PTR _exit_code$7[ebp], 259 ; 00000103H
  00798	0f 85 81 00 00
	00		 jne	 $LN12@check

; 1073 :                 getThreadTime(m_thAudEncThread, &pt);

  0079e	8d 8d 2c ff ff
	ff		 lea	 ecx, DWORD PTR _pt$[ebp]
  007a4	51		 push	 ecx
  007a5	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  007a8	8b 82 e8 0a 00
	00		 mov	 eax, DWORD PTR [edx+2792]
  007ae	50		 push	 eax
  007af	8d 4d e7	 lea	 ecx, DWORD PTR _getThreadTime$[ebp]
  007b2	e8 00 00 00 00	 call	 ??R<lambda_ee86f6c47a1a90e9cd4ba874c2bef330>@@QBEXPAXPAUPROCESS_TIME@@@Z ; <lambda_ee86f6c47a1a90e9cd4ba874c2bef330>::operator()

; 1074 :                 pInfoNew->aud_enc_thread_total_active_us = (pt.user + pt.kernel) / 10;

  007b7	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _pt$[ebp+24]
  007bd	03 8d 3c ff ff
	ff		 add	 ecx, DWORD PTR _pt$[ebp+16]
  007c3	8b 95 48 ff ff
	ff		 mov	 edx, DWORD PTR _pt$[ebp+28]
  007c9	13 95 40 ff ff
	ff		 adc	 edx, DWORD PTR _pt$[ebp+20]
  007cf	6a 00		 push	 0
  007d1	6a 0a		 push	 10			; 0000000aH
  007d3	52		 push	 edx
  007d4	51		 push	 ecx
  007d5	e8 00 00 00 00	 call	 __aulldiv
  007da	8b 4d f4	 mov	 ecx, DWORD PTR _pInfoNew$[ebp]
  007dd	89 41 30	 mov	 DWORD PTR [ecx+48], eax
  007e0	89 51 34	 mov	 DWORD PTR [ecx+52], edx

; 1075 :                 pInfoNew->aud_enc_thread_percent  = (pInfoNew->aud_enc_thread_total_active_us  - pInfoOld->aud_enc_thread_total_active_us) * 100.0 * logical_cpu_inv * time_diff_inv;

  007e3	8b 55 f4	 mov	 edx, DWORD PTR _pInfoNew$[ebp]
  007e6	8b 45 f0	 mov	 eax, DWORD PTR _pInfoOld$[ebp]
  007e9	8b 4a 30	 mov	 ecx, DWORD PTR [edx+48]
  007ec	2b 48 30	 sub	 ecx, DWORD PTR [eax+48]
  007ef	8b 52 34	 mov	 edx, DWORD PTR [edx+52]
  007f2	1b 50 34	 sbb	 edx, DWORD PTR [eax+52]
  007f5	e8 00 00 00 00	 call	 __ltod3
  007fa	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@4059000000000000
  00802	f2 0f 59 85 18
	ff ff ff	 mulsd	 xmm0, QWORD PTR _logical_cpu_inv$10[ebp]
  0080a	f2 0f 59 85 20
	ff ff ff	 mulsd	 xmm0, QWORD PTR _time_diff_inv$[ebp]
  00812	8b 4d f4	 mov	 ecx, DWORD PTR _pInfoNew$[ebp]
  00815	f2 0f 11 81 d8
	00 00 00	 movsd	 QWORD PTR [ecx+216], xmm0

; 1076 :             } else {

  0081d	eb 0e		 jmp	 SHORT $LN13@check
$LN12@check:

; 1077 :                 pInfoNew->aud_enc_thread_percent = 0.0;

  0081f	8b 55 f4	 mov	 edx, DWORD PTR _pInfoNew$[ebp]
  00822	0f 57 c0	 xorps	 xmm0, xmm0
  00825	f2 0f 11 82 d8
	00 00 00	 movsd	 QWORD PTR [edx+216], xmm0
$LN13@check:

; 1078 :             }
; 1079 :         }
; 1080 : 
; 1081 :         if (m_thInThread) {

  0082d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00830	83 b8 dc 0a 00
	00 00		 cmp	 DWORD PTR [eax+2780], 0
  00837	0f 84 d1 00 00
	00		 je	 $LN16@check

; 1082 :             DWORD exit_code = 0;

  0083d	c7 85 ec fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _exit_code$6[ebp], 0

; 1083 :             if (0 != GetExitCodeThread(m_thInThread, &exit_code) && exit_code == STILL_ACTIVE) {

  00847	8b f4		 mov	 esi, esp
  00849	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _exit_code$6[ebp]
  0084f	51		 push	 ecx
  00850	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00853	8b 82 dc 0a 00
	00		 mov	 eax, DWORD PTR [edx+2780]
  00859	50		 push	 eax
  0085a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetExitCodeThread@8
  00860	3b f4		 cmp	 esi, esp
  00862	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00867	85 c0		 test	 eax, eax
  00869	0f 84 91 00 00
	00		 je	 $LN15@check
  0086f	81 bd ec fe ff
	ff 03 01 00 00	 cmp	 DWORD PTR _exit_code$6[ebp], 259 ; 00000103H
  00879	0f 85 81 00 00
	00		 jne	 $LN15@check

; 1084 :                 getThreadTime(m_thInThread, &pt);

  0087f	8d 8d 2c ff ff
	ff		 lea	 ecx, DWORD PTR _pt$[ebp]
  00885	51		 push	 ecx
  00886	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00889	8b 82 dc 0a 00
	00		 mov	 eax, DWORD PTR [edx+2780]
  0088f	50		 push	 eax
  00890	8d 4d e7	 lea	 ecx, DWORD PTR _getThreadTime$[ebp]
  00893	e8 00 00 00 00	 call	 ??R<lambda_ee86f6c47a1a90e9cd4ba874c2bef330>@@QBEXPAXPAUPROCESS_TIME@@@Z ; <lambda_ee86f6c47a1a90e9cd4ba874c2bef330>::operator()

; 1085 :                 pInfoNew->in_thread_total_active_us = (pt.user + pt.kernel) / 10;

  00898	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _pt$[ebp+24]
  0089e	03 8d 3c ff ff
	ff		 add	 ecx, DWORD PTR _pt$[ebp+16]
  008a4	8b 95 48 ff ff
	ff		 mov	 edx, DWORD PTR _pt$[ebp+28]
  008aa	13 95 40 ff ff
	ff		 adc	 edx, DWORD PTR _pt$[ebp+20]
  008b0	6a 00		 push	 0
  008b2	6a 0a		 push	 10			; 0000000aH
  008b4	52		 push	 edx
  008b5	51		 push	 ecx
  008b6	e8 00 00 00 00	 call	 __aulldiv
  008bb	8b 4d f4	 mov	 ecx, DWORD PTR _pInfoNew$[ebp]
  008be	89 41 40	 mov	 DWORD PTR [ecx+64], eax
  008c1	89 51 44	 mov	 DWORD PTR [ecx+68], edx

; 1086 :                 pInfoNew->in_thread_percent  = (pInfoNew->in_thread_total_active_us  - pInfoOld->in_thread_total_active_us) * 100.0 * logical_cpu_inv * time_diff_inv;

  008c4	8b 55 f4	 mov	 edx, DWORD PTR _pInfoNew$[ebp]
  008c7	8b 45 f0	 mov	 eax, DWORD PTR _pInfoOld$[ebp]
  008ca	8b 4a 40	 mov	 ecx, DWORD PTR [edx+64]
  008cd	2b 48 40	 sub	 ecx, DWORD PTR [eax+64]
  008d0	8b 52 44	 mov	 edx, DWORD PTR [edx+68]
  008d3	1b 50 44	 sbb	 edx, DWORD PTR [eax+68]
  008d6	e8 00 00 00 00	 call	 __ltod3
  008db	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@4059000000000000
  008e3	f2 0f 59 85 18
	ff ff ff	 mulsd	 xmm0, QWORD PTR _logical_cpu_inv$10[ebp]
  008eb	f2 0f 59 85 20
	ff ff ff	 mulsd	 xmm0, QWORD PTR _time_diff_inv$[ebp]
  008f3	8b 4d f4	 mov	 ecx, DWORD PTR _pInfoNew$[ebp]
  008f6	f2 0f 11 81 e8
	00 00 00	 movsd	 QWORD PTR [ecx+232], xmm0

; 1087 :             } else {

  008fe	eb 0e		 jmp	 SHORT $LN16@check
$LN15@check:

; 1088 :                 pInfoNew->in_thread_percent = 0.0;

  00900	8b 55 f4	 mov	 edx, DWORD PTR _pInfoNew$[ebp]
  00903	0f 57 c0	 xorps	 xmm0, xmm0
  00906	f2 0f 11 82 e8
	00 00 00	 movsd	 QWORD PTR [edx+232], xmm0
$LN16@check:

; 1089 :             }
; 1090 :         }
; 1091 : 
; 1092 :         if (m_thOutThread) {

  0090e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00911	83 b8 e0 0a 00
	00 00		 cmp	 DWORD PTR [eax+2784], 0
  00918	0f 84 d1 00 00
	00		 je	 $LN19@check

; 1093 :             DWORD exit_code = 0;

  0091e	c7 85 e0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _exit_code$5[ebp], 0

; 1094 :             if (0 != GetExitCodeThread(m_thOutThread, &exit_code) && exit_code == STILL_ACTIVE) {

  00928	8b f4		 mov	 esi, esp
  0092a	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR _exit_code$5[ebp]
  00930	51		 push	 ecx
  00931	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00934	8b 82 e0 0a 00
	00		 mov	 eax, DWORD PTR [edx+2784]
  0093a	50		 push	 eax
  0093b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetExitCodeThread@8
  00941	3b f4		 cmp	 esi, esp
  00943	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00948	85 c0		 test	 eax, eax
  0094a	0f 84 91 00 00
	00		 je	 $LN18@check
  00950	81 bd e0 fe ff
	ff 03 01 00 00	 cmp	 DWORD PTR _exit_code$5[ebp], 259 ; 00000103H
  0095a	0f 85 81 00 00
	00		 jne	 $LN18@check

; 1095 :                 getThreadTime(m_thOutThread, &pt);

  00960	8d 8d 2c ff ff
	ff		 lea	 ecx, DWORD PTR _pt$[ebp]
  00966	51		 push	 ecx
  00967	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0096a	8b 82 e0 0a 00
	00		 mov	 eax, DWORD PTR [edx+2784]
  00970	50		 push	 eax
  00971	8d 4d e7	 lea	 ecx, DWORD PTR _getThreadTime$[ebp]
  00974	e8 00 00 00 00	 call	 ??R<lambda_ee86f6c47a1a90e9cd4ba874c2bef330>@@QBEXPAXPAUPROCESS_TIME@@@Z ; <lambda_ee86f6c47a1a90e9cd4ba874c2bef330>::operator()

; 1096 :                 pInfoNew->out_thread_total_active_us = (pt.user + pt.kernel) / 10;

  00979	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _pt$[ebp+24]
  0097f	03 8d 3c ff ff
	ff		 add	 ecx, DWORD PTR _pt$[ebp+16]
  00985	8b 95 48 ff ff
	ff		 mov	 edx, DWORD PTR _pt$[ebp+28]
  0098b	13 95 40 ff ff
	ff		 adc	 edx, DWORD PTR _pt$[ebp+20]
  00991	6a 00		 push	 0
  00993	6a 0a		 push	 10			; 0000000aH
  00995	52		 push	 edx
  00996	51		 push	 ecx
  00997	e8 00 00 00 00	 call	 __aulldiv
  0099c	8b 4d f4	 mov	 ecx, DWORD PTR _pInfoNew$[ebp]
  0099f	89 41 38	 mov	 DWORD PTR [ecx+56], eax
  009a2	89 51 3c	 mov	 DWORD PTR [ecx+60], edx

; 1097 :                 pInfoNew->out_thread_percent  = (pInfoNew->out_thread_total_active_us  - pInfoOld->out_thread_total_active_us) * 100.0 * logical_cpu_inv * time_diff_inv;

  009a5	8b 55 f4	 mov	 edx, DWORD PTR _pInfoNew$[ebp]
  009a8	8b 45 f0	 mov	 eax, DWORD PTR _pInfoOld$[ebp]
  009ab	8b 4a 38	 mov	 ecx, DWORD PTR [edx+56]
  009ae	2b 48 38	 sub	 ecx, DWORD PTR [eax+56]
  009b1	8b 52 3c	 mov	 edx, DWORD PTR [edx+60]
  009b4	1b 50 3c	 sbb	 edx, DWORD PTR [eax+60]
  009b7	e8 00 00 00 00	 call	 __ltod3
  009bc	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@4059000000000000
  009c4	f2 0f 59 85 18
	ff ff ff	 mulsd	 xmm0, QWORD PTR _logical_cpu_inv$10[ebp]
  009cc	f2 0f 59 85 20
	ff ff ff	 mulsd	 xmm0, QWORD PTR _time_diff_inv$[ebp]
  009d4	8b 4d f4	 mov	 ecx, DWORD PTR _pInfoNew$[ebp]
  009d7	f2 0f 11 81 e0
	00 00 00	 movsd	 QWORD PTR [ecx+224], xmm0

; 1098 :             } else {

  009df	eb 0e		 jmp	 SHORT $LN19@check
$LN18@check:

; 1099 :                 pInfoNew->out_thread_percent = 0.0;

  009e1	8b 55 f4	 mov	 edx, DWORD PTR _pInfoNew$[ebp]
  009e4	0f 57 c0	 xorps	 xmm0, xmm0
  009e7	f2 0f 11 82 e0
	00 00 00	 movsd	 QWORD PTR [edx+224], xmm0
$LN19@check:

; 1100 :             }
; 1101 :         }
; 1102 : #endif //defined(_WIN32) || defined(_WIN64)
; 1103 :     }
; 1104 : 
; 1105 :     if (!m_bEncStarted && m_pEncStatus) {

  009ef	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  009f2	0f b6 88 19 0b
	00 00		 movzx	 ecx, BYTE PTR [eax+2841]
  009f9	85 c9		 test	 ecx, ecx
  009fb	75 65		 jne	 SHORT $LN21@check
  009fd	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00a00	81 c1 f0 0a 00
	00		 add	 ecx, 2800		; 00000af0H
  00a06	e8 00 00 00 00	 call	 ??B?$shared_ptr@VEncodeStatus@@@std@@QBE_NXZ ; std::shared_ptr<EncodeStatus>::operator bool
  00a0b	0f b6 d0	 movzx	 edx, al
  00a0e	85 d2		 test	 edx, edx
  00a10	74 50		 je	 SHORT $LN21@check

; 1106 :         m_bEncStarted = m_pEncStatus->getEncStarted();

  00a12	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00a15	81 c1 f0 0a 00
	00		 add	 ecx, 2800		; 00000af0H
  00a1b	e8 00 00 00 00	 call	 ??$?CVEncodeStatus@@$0A@@?$shared_ptr@VEncodeStatus@@@std@@QBEPAVEncodeStatus@@XZ ; std::shared_ptr<EncodeStatus>::operator-><EncodeStatus,0>
  00a20	8b c8		 mov	 ecx, eax
  00a22	e8 00 00 00 00	 call	 ?getEncStarted@EncodeStatus@@QAE_NXZ ; EncodeStatus::getEncStarted
  00a27	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00a2a	88 81 19 0b 00
	00		 mov	 BYTE PTR [ecx+2841], al

; 1107 :         if (m_bEncStarted) {

  00a30	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00a33	0f b6 82 19 0b
	00 00		 movzx	 eax, BYTE PTR [edx+2841]
  00a3a	85 c0		 test	 eax, eax
  00a3c	74 24		 je	 SHORT $LN21@check

; 1108 :             m_nEncStartTime = m_pEncStatus->getStartTimeMicroSec();

  00a3e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00a41	81 c1 f0 0a 00
	00		 add	 ecx, 2800		; 00000af0H
  00a47	e8 00 00 00 00	 call	 ??$?CVEncodeStatus@@$0A@@?$shared_ptr@VEncodeStatus@@@std@@QBEPAVEncodeStatus@@XZ ; std::shared_ptr<EncodeStatus>::operator-><EncodeStatus,0>
  00a4c	8b c8		 mov	 ecx, eax
  00a4e	e8 00 00 00 00	 call	 ?getStartTimeMicroSec@EncodeStatus@@QAE_JXZ ; EncodeStatus::getStartTimeMicroSec
  00a53	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00a56	89 81 f8 0a 00
	00		 mov	 DWORD PTR [ecx+2808], eax
  00a5c	89 91 fc 0a 00
	00		 mov	 DWORD PTR [ecx+2812], edx
$LN21@check:

; 1109 :         }
; 1110 :     }
; 1111 : 
; 1112 :     pInfoNew->bitrate_kbps = 0;

  00a62	8b 55 f4	 mov	 edx, DWORD PTR _pInfoNew$[ebp]
  00a65	0f 57 c0	 xorps	 xmm0, xmm0
  00a68	f2 0f 11 82 90
	00 00 00	 movsd	 QWORD PTR [edx+144], xmm0

; 1113 :     pInfoNew->frames_out_byte = 0;

  00a70	8b 45 f4	 mov	 eax, DWORD PTR _pInfoNew$[ebp]
  00a73	c7 40 78 00 00
	00 00		 mov	 DWORD PTR [eax+120], 0
  00a7a	c7 40 7c 00 00
	00 00		 mov	 DWORD PTR [eax+124], 0

; 1114 :     pInfoNew->fps = 0.0;

  00a81	8b 4d f4	 mov	 ecx, DWORD PTR _pInfoNew$[ebp]
  00a84	0f 57 c0	 xorps	 xmm0, xmm0
  00a87	f2 0f 11 81 80
	00 00 00	 movsd	 QWORD PTR [ecx+128], xmm0

; 1115 :     if (m_bEncStarted && m_pEncStatus) {

  00a8f	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00a92	0f b6 82 19 0b
	00 00		 movzx	 eax, BYTE PTR [edx+2841]
  00a99	85 c0		 test	 eax, eax
  00a9b	0f 84 d1 02 00
	00		 je	 $LN25@check
  00aa1	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00aa4	81 c1 f0 0a 00
	00		 add	 ecx, 2800		; 00000af0H
  00aaa	e8 00 00 00 00	 call	 ??B?$shared_ptr@VEncodeStatus@@@std@@QBE_NXZ ; std::shared_ptr<EncodeStatus>::operator bool
  00aaf	0f b6 c8	 movzx	 ecx, al
  00ab2	85 c9		 test	 ecx, ecx
  00ab4	0f 84 b8 02 00
	00		 je	 $LN25@check

; 1116 :         EncodeStatusData data = m_pEncStatus->GetEncodeData();

  00aba	8d 95 28 fe ff
	ff		 lea	 edx, DWORD PTR _data$4[ebp]
  00ac0	52		 push	 edx
  00ac1	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00ac4	81 c1 f0 0a 00
	00		 add	 ecx, 2800		; 00000af0H
  00aca	e8 00 00 00 00	 call	 ??$?CVEncodeStatus@@$0A@@?$shared_ptr@VEncodeStatus@@@std@@QBEPAVEncodeStatus@@XZ ; std::shared_ptr<EncodeStatus>::operator-><EncodeStatus,0>
  00acf	8b c8		 mov	 ecx, eax
  00ad1	e8 00 00 00 00	 call	 ?GetEncodeData@EncodeStatus@@QAE?AUEncodeStatusData@@XZ ; EncodeStatus::GetEncodeData

; 1117 : 
; 1118 :         //fps
; 1119 :         pInfoNew->frames_out = data.frameTotal;

  00ad6	8b 85 40 fe ff
	ff		 mov	 eax, DWORD PTR _data$4[ebp+24]
  00adc	33 c9		 xor	 ecx, ecx
  00ade	8b 55 f4	 mov	 edx, DWORD PTR _pInfoNew$[ebp]
  00ae1	89 42 70	 mov	 DWORD PTR [edx+112], eax
  00ae4	89 4a 74	 mov	 DWORD PTR [edx+116], ecx

; 1120 :         if (pInfoNew->frames_out > pInfoOld->frames_out) {

  00ae7	8b 45 f4	 mov	 eax, DWORD PTR _pInfoNew$[ebp]
  00aea	8b 4d f0	 mov	 ecx, DWORD PTR _pInfoOld$[ebp]
  00aed	89 85 04 fe ff
	ff		 mov	 DWORD PTR tv1059[ebp], eax
  00af3	89 8d 00 fe ff
	ff		 mov	 DWORD PTR tv1060[ebp], ecx
  00af9	8b 95 04 fe ff
	ff		 mov	 edx, DWORD PTR tv1059[ebp]
  00aff	8b 85 00 fe ff
	ff		 mov	 eax, DWORD PTR tv1060[ebp]
  00b05	8b 4a 74	 mov	 ecx, DWORD PTR [edx+116]
  00b08	3b 48 74	 cmp	 ecx, DWORD PTR [eax+116]
  00b0b	0f 8c 61 02 00
	00		 jl	 $LN25@check
  00b11	7f 18		 jg	 SHORT $LN28@check
  00b13	8b 95 04 fe ff
	ff		 mov	 edx, DWORD PTR tv1059[ebp]
  00b19	8b 85 00 fe ff
	ff		 mov	 eax, DWORD PTR tv1060[ebp]
  00b1f	8b 4a 70	 mov	 ecx, DWORD PTR [edx+112]
  00b22	3b 48 70	 cmp	 ecx, DWORD PTR [eax+112]
  00b25	0f 86 47 02 00
	00		 jbe	 $LN25@check
$LN28@check:

; 1121 :             pInfoNew->fps_avg = pInfoNew->frames_out / (double)(current_time / 10 - m_nEncStartTime) * 1e6;

  00b2b	8b 55 f4	 mov	 edx, DWORD PTR _pInfoNew$[ebp]
  00b2e	8b 4a 70	 mov	 ecx, DWORD PTR [edx+112]
  00b31	8b 52 74	 mov	 edx, DWORD PTR [edx+116]
  00b34	e8 00 00 00 00	 call	 __ltod3
  00b39	6a 00		 push	 0
  00b3b	6a 0a		 push	 10			; 0000000aH
  00b3d	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _current_time$[ebp+4]
  00b43	50		 push	 eax
  00b44	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR _current_time$[ebp]
  00b4a	51		 push	 ecx
  00b4b	f2 0f 11 85 f8
	fd ff ff	 movsd	 QWORD PTR tv1230[ebp], xmm0
  00b53	e8 00 00 00 00	 call	 __aulldiv
  00b58	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00b5b	2b 81 f8 0a 00
	00		 sub	 eax, DWORD PTR [ecx+2808]
  00b61	1b 91 fc 0a 00
	00		 sbb	 edx, DWORD PTR [ecx+2812]
  00b67	8b c8		 mov	 ecx, eax
  00b69	e8 00 00 00 00	 call	 __ultod3
  00b6e	f2 0f 10 8d f8
	fd ff ff	 movsd	 xmm1, QWORD PTR tv1230[ebp]
  00b76	f2 0f 5e c8	 divsd	 xmm1, xmm0
  00b7a	f2 0f 59 0d 00
	00 00 00	 mulsd	 xmm1, QWORD PTR __real@412e848000000000
  00b82	8b 55 f4	 mov	 edx, DWORD PTR _pInfoNew$[ebp]
  00b85	f2 0f 11 8a 88
	00 00 00	 movsd	 QWORD PTR [edx+136], xmm1

; 1122 :             if (pInfoNew->time_us > pInfoOld->time_us) {

  00b8d	8b 45 f4	 mov	 eax, DWORD PTR _pInfoNew$[ebp]
  00b90	8b 4d f0	 mov	 ecx, DWORD PTR _pInfoOld$[ebp]
  00b93	89 85 f4 fd ff
	ff		 mov	 DWORD PTR tv1101[ebp], eax
  00b99	89 8d f0 fd ff
	ff		 mov	 DWORD PTR tv1102[ebp], ecx
  00b9f	8b 95 f4 fd ff
	ff		 mov	 edx, DWORD PTR tv1101[ebp]
  00ba5	8b 85 f0 fd ff
	ff		 mov	 eax, DWORD PTR tv1102[ebp]
  00bab	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00bae	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00bb1	7c 46		 jl	 SHORT $LN24@check
  00bb3	7f 12		 jg	 SHORT $LN29@check
  00bb5	8b 95 f4 fd ff
	ff		 mov	 edx, DWORD PTR tv1101[ebp]
  00bbb	8b 85 f0 fd ff
	ff		 mov	 eax, DWORD PTR tv1102[ebp]
  00bc1	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00bc3	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00bc5	76 32		 jbe	 SHORT $LN24@check
$LN29@check:

; 1123 :                 pInfoNew->fps     = (pInfoNew->frames_out - pInfoOld->frames_out) * time_diff_inv * 1e6;

  00bc7	8b 55 f4	 mov	 edx, DWORD PTR _pInfoNew$[ebp]
  00bca	8b 45 f0	 mov	 eax, DWORD PTR _pInfoOld$[ebp]
  00bcd	8b 4a 70	 mov	 ecx, DWORD PTR [edx+112]
  00bd0	2b 48 70	 sub	 ecx, DWORD PTR [eax+112]
  00bd3	8b 52 74	 mov	 edx, DWORD PTR [edx+116]
  00bd6	1b 50 74	 sbb	 edx, DWORD PTR [eax+116]
  00bd9	e8 00 00 00 00	 call	 __ltod3
  00bde	f2 0f 59 85 20
	ff ff ff	 mulsd	 xmm0, QWORD PTR _time_diff_inv$[ebp]
  00be6	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@412e848000000000
  00bee	8b 4d f4	 mov	 ecx, DWORD PTR _pInfoNew$[ebp]
  00bf1	f2 0f 11 81 80
	00 00 00	 movsd	 QWORD PTR [ecx+128], xmm0
$LN24@check:

; 1124 :             }
; 1125 : 
; 1126 :             //
; 1127 :             double videoSec     = pInfoNew->frames_out * m_nOutputFPSScale / (double)m_nOutputFPSRate;

  00bf9	8b 55 f4	 mov	 edx, DWORD PTR _pInfoNew$[ebp]
  00bfc	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00bff	8b 88 0c 0b 00
	00		 mov	 ecx, DWORD PTR [eax+2828]
  00c05	51		 push	 ecx
  00c06	8b 80 08 0b 00
	00		 mov	 eax, DWORD PTR [eax+2824]
  00c0c	50		 push	 eax
  00c0d	8b 4a 74	 mov	 ecx, DWORD PTR [edx+116]
  00c10	51		 push	 ecx
  00c11	8b 52 70	 mov	 edx, DWORD PTR [edx+112]
  00c14	52		 push	 edx
  00c15	e8 00 00 00 00	 call	 __allmul
  00c1a	8b c8		 mov	 ecx, eax
  00c1c	e8 00 00 00 00	 call	 __ltod3
  00c21	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00c24	8b 88 00 0b 00
	00		 mov	 ecx, DWORD PTR [eax+2816]
  00c2a	8b 90 04 0b 00
	00		 mov	 edx, DWORD PTR [eax+2820]
  00c30	f2 0f 11 85 e8
	fd ff ff	 movsd	 QWORD PTR tv1232[ebp], xmm0
  00c38	e8 00 00 00 00	 call	 __ltod3
  00c3d	f2 0f 10 8d e8
	fd ff ff	 movsd	 xmm1, QWORD PTR tv1232[ebp]
  00c45	f2 0f 5e c8	 divsd	 xmm1, xmm0
  00c49	f2 0f 11 8d 1c
	fe ff ff	 movsd	 QWORD PTR _videoSec$3[ebp], xmm1

; 1128 :             double videoSecDiff = (pInfoNew->frames_out - pInfoOld->frames_out) * m_nOutputFPSScale / (double)m_nOutputFPSRate;

  00c51	8b 4d f4	 mov	 ecx, DWORD PTR _pInfoNew$[ebp]
  00c54	8b 55 f0	 mov	 edx, DWORD PTR _pInfoOld$[ebp]
  00c57	8b 41 70	 mov	 eax, DWORD PTR [ecx+112]
  00c5a	2b 42 70	 sub	 eax, DWORD PTR [edx+112]
  00c5d	8b 49 74	 mov	 ecx, DWORD PTR [ecx+116]
  00c60	1b 4a 74	 sbb	 ecx, DWORD PTR [edx+116]
  00c63	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00c66	8b b2 0c 0b 00
	00		 mov	 esi, DWORD PTR [edx+2828]
  00c6c	56		 push	 esi
  00c6d	8b 92 08 0b 00
	00		 mov	 edx, DWORD PTR [edx+2824]
  00c73	52		 push	 edx
  00c74	51		 push	 ecx
  00c75	50		 push	 eax
  00c76	e8 00 00 00 00	 call	 __allmul
  00c7b	8b c8		 mov	 ecx, eax
  00c7d	e8 00 00 00 00	 call	 __ltod3
  00c82	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00c85	8b 88 00 0b 00
	00		 mov	 ecx, DWORD PTR [eax+2816]
  00c8b	8b 90 04 0b 00
	00		 mov	 edx, DWORD PTR [eax+2820]
  00c91	f2 0f 11 85 e0
	fd ff ff	 movsd	 QWORD PTR tv1234[ebp], xmm0
  00c99	e8 00 00 00 00	 call	 __ltod3
  00c9e	f2 0f 10 8d e0
	fd ff ff	 movsd	 xmm1, QWORD PTR tv1234[ebp]
  00ca6	f2 0f 5e c8	 divsd	 xmm1, xmm0
  00caa	f2 0f 11 8d 14
	fe ff ff	 movsd	 QWORD PTR _videoSecDiff$2[ebp], xmm1

; 1129 : 
; 1130 :             pInfoNew->frames_out_byte = data.outFileSize;

  00cb2	8b 4d f4	 mov	 ecx, DWORD PTR _pInfoNew$[ebp]
  00cb5	8b 95 30 fe ff
	ff		 mov	 edx, DWORD PTR _data$4[ebp+8]
  00cbb	89 51 78	 mov	 DWORD PTR [ecx+120], edx
  00cbe	8b 85 34 fe ff
	ff		 mov	 eax, DWORD PTR _data$4[ebp+12]
  00cc4	89 41 7c	 mov	 DWORD PTR [ecx+124], eax

; 1131 :             pInfoNew->bitrate_kbps_avg =  pInfoNew->frames_out_byte * 8.0 / videoSec * 1e-3;

  00cc7	8b 4d f4	 mov	 ecx, DWORD PTR _pInfoNew$[ebp]
  00cca	8b 41 78	 mov	 eax, DWORD PTR [ecx+120]
  00ccd	8b 51 7c	 mov	 edx, DWORD PTR [ecx+124]
  00cd0	8b c8		 mov	 ecx, eax
  00cd2	e8 00 00 00 00	 call	 __ltod3
  00cd7	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@4020000000000000
  00cdf	f2 0f 5e 85 1c
	fe ff ff	 divsd	 xmm0, QWORD PTR _videoSec$3[ebp]
  00ce7	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3f50624dd2f1a9fc
  00cef	8b 4d f4	 mov	 ecx, DWORD PTR _pInfoNew$[ebp]
  00cf2	f2 0f 11 81 98
	00 00 00	 movsd	 QWORD PTR [ecx+152], xmm0

; 1132 :             if (pInfoNew->time_us > pInfoOld->time_us) {

  00cfa	8b 55 f4	 mov	 edx, DWORD PTR _pInfoNew$[ebp]
  00cfd	8b 45 f0	 mov	 eax, DWORD PTR _pInfoOld$[ebp]
  00d00	89 95 dc fd ff
	ff		 mov	 DWORD PTR tv1204[ebp], edx
  00d06	89 85 d8 fd ff
	ff		 mov	 DWORD PTR tv1205[ebp], eax
  00d0c	8b 8d dc fd ff
	ff		 mov	 ecx, DWORD PTR tv1204[ebp]
  00d12	8b 95 d8 fd ff
	ff		 mov	 edx, DWORD PTR tv1205[ebp]
  00d18	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00d1b	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  00d1e	7c 52		 jl	 SHORT $LN25@check
  00d20	7f 12		 jg	 SHORT $LN30@check
  00d22	8b 8d dc fd ff
	ff		 mov	 ecx, DWORD PTR tv1204[ebp]
  00d28	8b 95 d8 fd ff
	ff		 mov	 edx, DWORD PTR tv1205[ebp]
  00d2e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00d30	3b 02		 cmp	 eax, DWORD PTR [edx]
  00d32	76 3e		 jbe	 SHORT $LN25@check
$LN30@check:

; 1133 :                 pInfoNew->bitrate_kbps     = (pInfoNew->frames_out_byte - pInfoOld->frames_out_byte) * 8.0 / videoSecDiff * 1e-3;

  00d34	8b 4d f4	 mov	 ecx, DWORD PTR _pInfoNew$[ebp]
  00d37	8b 55 f0	 mov	 edx, DWORD PTR _pInfoOld$[ebp]
  00d3a	8b 41 78	 mov	 eax, DWORD PTR [ecx+120]
  00d3d	2b 42 78	 sub	 eax, DWORD PTR [edx+120]
  00d40	8b 49 7c	 mov	 ecx, DWORD PTR [ecx+124]
  00d43	1b 4a 7c	 sbb	 ecx, DWORD PTR [edx+124]
  00d46	8b d1		 mov	 edx, ecx
  00d48	8b c8		 mov	 ecx, eax
  00d4a	e8 00 00 00 00	 call	 __ltod3
  00d4f	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@4020000000000000
  00d57	f2 0f 5e 85 14
	fe ff ff	 divsd	 xmm0, QWORD PTR _videoSecDiff$2[ebp]
  00d5f	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3f50624dd2f1a9fc
  00d67	8b 55 f4	 mov	 edx, DWORD PTR _pInfoNew$[ebp]
  00d6a	f2 0f 11 82 90
	00 00 00	 movsd	 QWORD PTR [edx+144], xmm0
$LN25@check:

; 1134 :             }
; 1135 :         }
; 1136 :     }
; 1137 : 
; 1138 :     m_nStep++;

  00d72	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00d75	8b 08		 mov	 ecx, DWORD PTR [eax]
  00d77	83 c1 01	 add	 ecx, 1
  00d7a	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00d7d	89 0a		 mov	 DWORD PTR [edx], ecx

; 1139 : }

  00d7f	52		 push	 edx
  00d80	8b cd		 mov	 ecx, ebp
  00d82	50		 push	 eax
  00d83	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN44@check
  00d89	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00d8e	58		 pop	 eax
  00d8f	5a		 pop	 edx
  00d90	5f		 pop	 edi
  00d91	5e		 pop	 esi
  00d92	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00d95	33 cd		 xor	 ecx, ebp
  00d97	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00d9c	81 c4 28 02 00
	00		 add	 esp, 552		; 00000228H
  00da2	3b ec		 cmp	 ebp, esp
  00da4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00da9	8b e5		 mov	 esp, ebp
  00dab	5d		 pop	 ebp
  00dac	c3		 ret	 0
  00dad	0f 1f 00	 npad	 3
$LN44@check:
  00db0	0c 00 00 00	 DD	 12			; 0000000cH
  00db4	00 00 00 00	 DD	 $LN43@check
$LN43@check:
  00db8	e7 ff ff ff	 DD	 -25			; ffffffe7H
  00dbc	01 00 00 00	 DD	 1
  00dc0	00 00 00 00	 DD	 $LN31@check
  00dc4	b4 ff ff ff	 DD	 -76			; ffffffb4H
  00dc8	28 00 00 00	 DD	 40			; 00000028H
  00dcc	00 00 00 00	 DD	 $LN32@check
  00dd0	7c ff ff ff	 DD	 -132			; ffffff7cH
  00dd4	30 00 00 00	 DD	 48			; 00000030H
  00dd8	00 00 00 00	 DD	 $LN33@check
  00ddc	6c ff ff ff	 DD	 -148			; ffffff6cH
  00de0	08 00 00 00	 DD	 8
  00de4	00 00 00 00	 DD	 $LN34@check
  00de8	54 ff ff ff	 DD	 -172			; ffffff54H
  00dec	10 00 00 00	 DD	 16			; 00000010H
  00df0	00 00 00 00	 DD	 $LN35@check
  00df4	2c ff ff ff	 DD	 -212			; ffffff2cH
  00df8	20 00 00 00	 DD	 32			; 00000020H
  00dfc	00 00 00 00	 DD	 $LN36@check
  00e00	10 ff ff ff	 DD	 -240			; ffffff10H
  00e04	04 00 00 00	 DD	 4
  00e08	00 00 00 00	 DD	 $LN37@check
  00e0c	04 ff ff ff	 DD	 -252			; ffffff04H
  00e10	04 00 00 00	 DD	 4
  00e14	00 00 00 00	 DD	 $LN38@check
  00e18	f8 fe ff ff	 DD	 -264			; fffffef8H
  00e1c	04 00 00 00	 DD	 4
  00e20	00 00 00 00	 DD	 $LN39@check
  00e24	ec fe ff ff	 DD	 -276			; fffffeecH
  00e28	04 00 00 00	 DD	 4
  00e2c	00 00 00 00	 DD	 $LN40@check
  00e30	e0 fe ff ff	 DD	 -288			; fffffee0H
  00e34	04 00 00 00	 DD	 4
  00e38	00 00 00 00	 DD	 $LN41@check
  00e3c	28 fe ff ff	 DD	 -472			; fffffe28H
  00e40	b0 00 00 00	 DD	 176			; 000000b0H
  00e44	00 00 00 00	 DD	 $LN42@check
$LN42@check:
  00e48	64		 DB	 100			; 00000064H
  00e49	61		 DB	 97			; 00000061H
  00e4a	74		 DB	 116			; 00000074H
  00e4b	61		 DB	 97			; 00000061H
  00e4c	00		 DB	 0
$LN41@check:
  00e4d	65		 DB	 101			; 00000065H
  00e4e	78		 DB	 120			; 00000078H
  00e4f	69		 DB	 105			; 00000069H
  00e50	74		 DB	 116			; 00000074H
  00e51	5f		 DB	 95			; 0000005fH
  00e52	63		 DB	 99			; 00000063H
  00e53	6f		 DB	 111			; 0000006fH
  00e54	64		 DB	 100			; 00000064H
  00e55	65		 DB	 101			; 00000065H
  00e56	00		 DB	 0
$LN40@check:
  00e57	65		 DB	 101			; 00000065H
  00e58	78		 DB	 120			; 00000078H
  00e59	69		 DB	 105			; 00000069H
  00e5a	74		 DB	 116			; 00000074H
  00e5b	5f		 DB	 95			; 0000005fH
  00e5c	63		 DB	 99			; 00000063H
  00e5d	6f		 DB	 111			; 0000006fH
  00e5e	64		 DB	 100			; 00000064H
  00e5f	65		 DB	 101			; 00000065H
  00e60	00		 DB	 0
$LN39@check:
  00e61	65		 DB	 101			; 00000065H
  00e62	78		 DB	 120			; 00000078H
  00e63	69		 DB	 105			; 00000069H
  00e64	74		 DB	 116			; 00000074H
  00e65	5f		 DB	 95			; 0000005fH
  00e66	63		 DB	 99			; 00000063H
  00e67	6f		 DB	 111			; 0000006fH
  00e68	64		 DB	 100			; 00000064H
  00e69	65		 DB	 101			; 00000065H
  00e6a	00		 DB	 0
$LN38@check:
  00e6b	65		 DB	 101			; 00000065H
  00e6c	78		 DB	 120			; 00000078H
  00e6d	69		 DB	 105			; 00000069H
  00e6e	74		 DB	 116			; 00000074H
  00e6f	5f		 DB	 95			; 0000005fH
  00e70	63		 DB	 99			; 00000063H
  00e71	6f		 DB	 111			; 0000006fH
  00e72	64		 DB	 100			; 00000064H
  00e73	65		 DB	 101			; 00000065H
  00e74	00		 DB	 0
$LN37@check:
  00e75	65		 DB	 101			; 00000065H
  00e76	78		 DB	 120			; 00000078H
  00e77	69		 DB	 105			; 00000069H
  00e78	74		 DB	 116			; 00000074H
  00e79	5f		 DB	 95			; 0000005fH
  00e7a	63		 DB	 99			; 00000063H
  00e7b	6f		 DB	 111			; 0000006fH
  00e7c	64		 DB	 100			; 00000064H
  00e7d	65		 DB	 101			; 00000065H
  00e7e	00		 DB	 0
$LN36@check:
  00e7f	70		 DB	 112			; 00000070H
  00e80	74		 DB	 116			; 00000074H
  00e81	00		 DB	 0
$LN35@check:
  00e82	73		 DB	 115			; 00000073H
  00e83	79		 DB	 121			; 00000079H
  00e84	73		 DB	 115			; 00000073H
  00e85	74		 DB	 116			; 00000074H
  00e86	69		 DB	 105			; 00000069H
  00e87	6d		 DB	 109			; 0000006dH
  00e88	65		 DB	 101			; 00000065H
  00e89	00		 DB	 0
$LN34@check:
  00e8a	63		 DB	 99			; 00000063H
  00e8b	75		 DB	 117			; 00000075H
  00e8c	72		 DB	 114			; 00000072H
  00e8d	72		 DB	 114			; 00000072H
  00e8e	65		 DB	 101			; 00000065H
  00e8f	6e		 DB	 110			; 0000006eH
  00e90	74		 DB	 116			; 00000074H
  00e91	5f		 DB	 95			; 0000005fH
  00e92	74		 DB	 116			; 00000074H
  00e93	69		 DB	 105			; 00000069H
  00e94	6d		 DB	 109			; 0000006dH
  00e95	65		 DB	 101			; 00000065H
  00e96	00		 DB	 0
$LN33@check:
  00e97	69		 DB	 105			; 00000069H
  00e98	6f		 DB	 111			; 0000006fH
  00e99	5f		 DB	 95			; 0000005fH
  00e9a	63		 DB	 99			; 00000063H
  00e9b	6f		 DB	 111			; 0000006fH
  00e9c	75		 DB	 117			; 00000075H
  00e9d	6e		 DB	 110			; 0000006eH
  00e9e	74		 DB	 116			; 00000074H
  00e9f	65		 DB	 101			; 00000065H
  00ea0	72		 DB	 114			; 00000072H
  00ea1	73		 DB	 115			; 00000073H
  00ea2	00		 DB	 0
$LN32@check:
  00ea3	6d		 DB	 109			; 0000006dH
  00ea4	65		 DB	 101			; 00000065H
  00ea5	6d		 DB	 109			; 0000006dH
  00ea6	5f		 DB	 95			; 0000005fH
  00ea7	63		 DB	 99			; 00000063H
  00ea8	6f		 DB	 111			; 0000006fH
  00ea9	75		 DB	 117			; 00000075H
  00eaa	6e		 DB	 110			; 0000006eH
  00eab	74		 DB	 116			; 00000074H
  00eac	65		 DB	 101			; 00000065H
  00ead	72		 DB	 114			; 00000072H
  00eae	73		 DB	 115			; 00000073H
  00eaf	00		 DB	 0
$LN31@check:
  00eb0	67		 DB	 103			; 00000067H
  00eb1	65		 DB	 101			; 00000065H
  00eb2	74		 DB	 116			; 00000074H
  00eb3	54		 DB	 84			; 00000054H
  00eb4	68		 DB	 104			; 00000068H
  00eb5	72		 DB	 114			; 00000072H
  00eb6	65		 DB	 101			; 00000065H
  00eb7	61		 DB	 97			; 00000061H
  00eb8	64		 DB	 100			; 00000064H
  00eb9	54		 DB	 84			; 00000054H
  00eba	69		 DB	 105			; 00000069H
  00ebb	6d		 DB	 109			; 0000006dH
  00ebc	65		 DB	 101			; 00000065H
  00ebd	00		 DB	 0
?check@CPerfMonitor@@IAEXXZ ENDP			; CPerfMonitor::check
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\rgy_perf_monitor.cpp
_TEXT	SEGMENT
_hModule$ = -40						; size = 4
_hResourceData$ = -36					; size = 4
_hResource$ = -32					; size = 4
_pDataPtr$ = -28					; size = 4
_fp$ = -20						; size = 4
_resourceSize$ = -12					; size = 4
_ret$ = -8						; size = 4
_this$ = -4						; size = 4
_pywPath$ = 8						; size = 4
?createPerfMpnitorPyw@CPerfMonitor@@IAEHPBD@Z PROC	; CPerfMonitor::createPerfMpnitorPyw
; _this$ = ecx

; 532  : int CPerfMonitor::createPerfMpnitorPyw(const TCHAR *pywPath) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	51		 push	 ecx
  00009	8d 7d d8	 lea	 edi, DWORD PTR [ebp-40]
  0000c	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  00011	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00016	f3 ab		 rep stosd
  00018	59		 pop	 ecx
  00019	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 533  :     //
; 534  :     int ret = 0;

  0001c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 0

; 535  :     uint32_t resourceSize = 0;

  00023	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _resourceSize$[ebp], 0

; 536  :     FILE *fp = NULL;

  0002a	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _fp$[ebp], 0

; 537  :     const char *pDataPtr = NULL;

  00031	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _pDataPtr$[ebp], 0

; 538  : #if defined(_WIN32) || defined(_WIN64)
; 539  :     HRSRC hResource = NULL;

  00038	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _hResource$[ebp], 0

; 540  :     HGLOBAL hResourceData = NULL;

  0003f	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _hResourceData$[ebp], 0

; 541  : #if BUILD_AUO
; 542  :     HMODULE hModule = GetModuleHandleA(AUO_NAME);

  00046	8b f4		 mov	 esi, esp
  00048	68 00 00 00 00	 push	 OFFSET $SG118171
  0004d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleHandleA@4
  00053	3b f4		 cmp	 esi, esp
  00055	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005a	89 45 d8	 mov	 DWORD PTR _hModule$[ebp], eax

; 543  : #else
; 544  :     HMODULE hModule = GetModuleHandleA(NULL);
; 545  : #endif
; 546  :     if (   NULL == hModule
; 547  :         || NULL == (hResource = FindResource(hModule, _T("PERF_MONITOR_PYW"), _T("PERF_MONITOR_SRC")))
; 548  :         || NULL == (hResourceData = LoadResource(hModule, hResource))
; 549  :         || NULL == (pDataPtr = (const char *)LockResource(hResourceData))
; 550  :         || 0    == (resourceSize = SizeofResource(hModule, hResource))) {

  0005d	83 7d d8 00	 cmp	 DWORD PTR _hModule$[ebp], 0
  00061	0f 84 82 00 00
	00		 je	 $LN4@createPerf
  00067	8b f4		 mov	 esi, esp
  00069	68 00 00 00 00	 push	 OFFSET $SG118175
  0006e	68 00 00 00 00	 push	 OFFSET $SG118176
  00073	8b 45 d8	 mov	 eax, DWORD PTR _hModule$[ebp]
  00076	50		 push	 eax
  00077	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindResourceA@12
  0007d	3b f4		 cmp	 esi, esp
  0007f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00084	89 45 e0	 mov	 DWORD PTR _hResource$[ebp], eax
  00087	83 7d e0 00	 cmp	 DWORD PTR _hResource$[ebp], 0
  0008b	74 5c		 je	 SHORT $LN4@createPerf
  0008d	8b f4		 mov	 esi, esp
  0008f	8b 4d e0	 mov	 ecx, DWORD PTR _hResource$[ebp]
  00092	51		 push	 ecx
  00093	8b 55 d8	 mov	 edx, DWORD PTR _hModule$[ebp]
  00096	52		 push	 edx
  00097	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadResource@8
  0009d	3b f4		 cmp	 esi, esp
  0009f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a4	89 45 dc	 mov	 DWORD PTR _hResourceData$[ebp], eax
  000a7	83 7d dc 00	 cmp	 DWORD PTR _hResourceData$[ebp], 0
  000ab	74 3c		 je	 SHORT $LN4@createPerf
  000ad	8b f4		 mov	 esi, esp
  000af	8b 45 dc	 mov	 eax, DWORD PTR _hResourceData$[ebp]
  000b2	50		 push	 eax
  000b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LockResource@4
  000b9	3b f4		 cmp	 esi, esp
  000bb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c0	89 45 e4	 mov	 DWORD PTR _pDataPtr$[ebp], eax
  000c3	83 7d e4 00	 cmp	 DWORD PTR _pDataPtr$[ebp], 0
  000c7	74 20		 je	 SHORT $LN4@createPerf
  000c9	8b f4		 mov	 esi, esp
  000cb	8b 4d e0	 mov	 ecx, DWORD PTR _hResource$[ebp]
  000ce	51		 push	 ecx
  000cf	8b 55 d8	 mov	 edx, DWORD PTR _hModule$[ebp]
  000d2	52		 push	 edx
  000d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SizeofResource@8
  000d9	3b f4		 cmp	 esi, esp
  000db	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e0	89 45 f4	 mov	 DWORD PTR _resourceSize$[ebp], eax
  000e3	83 7d f4 00	 cmp	 DWORD PTR _resourceSize$[ebp], 0
  000e7	75 09		 jne	 SHORT $LN2@createPerf
$LN4@createPerf:

; 551  :         ret = 1;

  000e9	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 1

; 552  :     } else

  000f0	eb 5e		 jmp	 SHORT $LN3@createPerf
$LN2@createPerf:

; 553  : #else
; 554  :     pDataPtr = _binary_PerfMonitor_perf_monitor_pyw_start;
; 555  :     resourceSize = (uint32_t)(size_t)_binary_PerfMonitor_perf_monitor_pyw_size;
; 556  : #endif //#if defined(_WIN32) || defined(_WIN64)
; 557  :     if (_tfopen_s(&fp, pywPath, _T("wb")) || NULL == fp) {

  000f2	8b f4		 mov	 esi, esp
  000f4	68 00 00 00 00	 push	 OFFSET $SG118180
  000f9	8b 45 08	 mov	 eax, DWORD PTR _pywPath$[ebp]
  000fc	50		 push	 eax
  000fd	8d 4d ec	 lea	 ecx, DWORD PTR _fp$[ebp]
  00100	51		 push	 ecx
  00101	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen_s
  00107	83 c4 0c	 add	 esp, 12			; 0000000cH
  0010a	3b f4		 cmp	 esi, esp
  0010c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00111	85 c0		 test	 eax, eax
  00113	75 06		 jne	 SHORT $LN7@createPerf
  00115	83 7d ec 00	 cmp	 DWORD PTR _fp$[ebp], 0
  00119	75 09		 jne	 SHORT $LN5@createPerf
$LN7@createPerf:

; 558  :         ret = 1;

  0011b	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 1
  00122	eb 2c		 jmp	 SHORT $LN3@createPerf
$LN5@createPerf:

; 559  :     } else if (resourceSize != fwrite(pDataPtr, 1, resourceSize, fp)) {

  00124	8b f4		 mov	 esi, esp
  00126	8b 55 ec	 mov	 edx, DWORD PTR _fp$[ebp]
  00129	52		 push	 edx
  0012a	8b 45 f4	 mov	 eax, DWORD PTR _resourceSize$[ebp]
  0012d	50		 push	 eax
  0012e	6a 01		 push	 1
  00130	8b 4d e4	 mov	 ecx, DWORD PTR _pDataPtr$[ebp]
  00133	51		 push	 ecx
  00134	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  0013a	83 c4 10	 add	 esp, 16			; 00000010H
  0013d	3b f4		 cmp	 esi, esp
  0013f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00144	39 45 f4	 cmp	 DWORD PTR _resourceSize$[ebp], eax
  00147	74 07		 je	 SHORT $LN3@createPerf

; 560  :         ret = 1;

  00149	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 1
$LN3@createPerf:

; 561  :     }
; 562  :     if (fp)

  00150	83 7d ec 00	 cmp	 DWORD PTR _fp$[ebp], 0
  00154	74 16		 je	 SHORT $LN9@createPerf

; 563  :         fclose(fp);

  00156	8b f4		 mov	 esi, esp
  00158	8b 55 ec	 mov	 edx, DWORD PTR _fp$[ebp]
  0015b	52		 push	 edx
  0015c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  00162	83 c4 04	 add	 esp, 4
  00165	3b f4		 cmp	 esi, esp
  00167	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN9@createPerf:

; 564  :     return ret;

  0016c	8b 45 f8	 mov	 eax, DWORD PTR _ret$[ebp]

; 565  : }

  0016f	52		 push	 edx
  00170	8b cd		 mov	 ecx, ebp
  00172	50		 push	 eax
  00173	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN13@createPerf
  00179	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0017e	58		 pop	 eax
  0017f	5a		 pop	 edx
  00180	5f		 pop	 edi
  00181	5e		 pop	 esi
  00182	83 c4 28	 add	 esp, 40			; 00000028H
  00185	3b ec		 cmp	 ebp, esp
  00187	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0018c	8b e5		 mov	 esp, ebp
  0018e	5d		 pop	 ebp
  0018f	c2 04 00	 ret	 4
  00192	66 90		 npad	 2
$LN13@createPerf:
  00194	01 00 00 00	 DD	 1
  00198	00 00 00 00	 DD	 $LN12@createPerf
$LN12@createPerf:
  0019c	ec ff ff ff	 DD	 -20			; ffffffecH
  001a0	04 00 00 00	 DD	 4
  001a4	00 00 00 00	 DD	 $LN11@createPerf
$LN11@createPerf:
  001a8	66		 DB	 102			; 00000066H
  001a9	70		 DB	 112			; 00000070H
  001aa	00		 DB	 0
?createPerfMpnitorPyw@CPerfMonitor@@IAEHPBD@Z ENDP	; CPerfMonitor::createPerfMpnitorPyw
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\rgy_perf_monitor.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?clear@CPerfMonitor@@QAEXXZ PROC			; CPerfMonitor::clear
; _this$ = ecx

; 496  : void CPerfMonitor::clear() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 497  :     if (m_thCheck.joinable()) {

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	81 c1 90 02 00
	00		 add	 ecx, 656		; 00000290H
  00018	e8 00 00 00 00	 call	 ?joinable@thread@std@@QBE_NXZ ; std::thread::joinable
  0001d	0f b6 c0	 movzx	 eax, al
  00020	85 c0		 test	 eax, eax
  00022	74 18		 je	 SHORT $LN2@clear

; 498  :         m_bAbort = true;

  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	c6 81 18 0b 00
	00 01		 mov	 BYTE PTR [ecx+2840], 1

; 499  :         m_thCheck.join();

  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	81 c1 90 02 00
	00		 add	 ecx, 656		; 00000290H
  00037	e8 00 00 00 00	 call	 ?join@thread@std@@QAEXXZ ; std::thread::join
$LN2@clear:

; 500  :     }
; 501  :     memset(m_info, 0, sizeof(m_info));

  0003c	68 70 02 00 00	 push	 624			; 00000270H
  00041	6a 00		 push	 0
  00043	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00046	83 c2 20	 add	 edx, 32			; 00000020H
  00049	52		 push	 edx
  0004a	e8 00 00 00 00	 call	 _memset
  0004f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 502  :     memset(&m_QueueInfo, 0, sizeof(m_QueueInfo));

  00052	6a 18		 push	 24			; 00000018H
  00054	6a 00		 push	 0
  00056	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00059	05 4c 0b 00 00	 add	 eax, 2892		; 00000b4cH
  0005e	50		 push	 eax
  0005f	e8 00 00 00 00	 call	 _memset
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH

; 503  : #if ENABLE_METRIC_FRAMEWORK
; 504  :     if (m_pManager) {
; 505  :         const auto metricsUsed = m_Consumer.getMetricUsed();
; 506  :         for (auto metric = metricsUsed.cbegin(); metric != metricsUsed.cend(); metric++) {
; 507  :             m_pManager->UnsubscribeMetric(m_Consumer, metric->first);
; 508  :         }
; 509  :     }
; 510  :     m_pManager.reset();
; 511  : #endif //#if ENABLE_METRIC_FRAMEWORK
; 512  : 
; 513  :     m_nStep = 0;

  00067	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 514  :     m_thMainThread.reset();

  00070	6a 00		 push	 0
  00072	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	81 c1 98 02 00
	00		 add	 ecx, 664		; 00000298H
  0007b	e8 00 00 00 00	 call	 ?reset@?$unique_ptr@XUhandle_deleter@@@std@@QAEXPAX@Z ; std::unique_ptr<void,handle_deleter>::reset

; 515  :     m_thAudProcThread = NULL;

  00080	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00083	c7 82 e4 0a 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+2788], 0

; 516  :     m_thEncThread = NULL;

  0008d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00090	c7 80 d8 0a 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+2776], 0

; 517  :     m_thOutThread = NULL;

  0009a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0009d	c7 81 e0 0a 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+2784], 0

; 518  :     m_bAbort = false;

  000a7	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000aa	c6 82 18 0b 00
	00 00		 mov	 BYTE PTR [edx+2840], 0

; 519  :     m_bEncStarted = false;

  000b1	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000b4	c6 80 19 0b 00
	00 00		 mov	 BYTE PTR [eax+2841], 0

; 520  :     if (m_fpLog) {

  000bb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000be	81 c1 3c 0b 00
	00		 add	 ecx, 2876		; 00000b3cH
  000c4	e8 00 00 00 00	 call	 ??B?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@QBE_NXZ ; std::unique_ptr<_iobuf,fp_deleter>::operator bool
  000c9	0f b6 c8	 movzx	 ecx, al
  000cc	85 c9		 test	 ecx, ecx
  000ce	74 1c		 je	 SHORT $LN3@clear

; 521  :         fprintf(m_fpLog.get(), "\n\n");

  000d0	68 00 00 00 00	 push	 OFFSET $SG118157
  000d5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d8	81 c1 3c 0b 00
	00		 add	 ecx, 2876		; 00000b3cH
  000de	e8 00 00 00 00	 call	 ?get@?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@QBEPAU_iobuf@@XZ ; std::unique_ptr<_iobuf,fp_deleter>::get
  000e3	50		 push	 eax
  000e4	e8 00 00 00 00	 call	 _fprintf
  000e9	83 c4 08	 add	 esp, 8
$LN3@clear:

; 522  :     }
; 523  :     m_fpLog.reset();

  000ec	6a 00		 push	 0
  000ee	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000f1	81 c1 3c 0b 00
	00		 add	 ecx, 2876		; 00000b3cH
  000f7	e8 00 00 00 00	 call	 ?reset@?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@QAEXPAU_iobuf@@@Z ; std::unique_ptr<_iobuf,fp_deleter>::reset

; 524  :     if (m_pipes.f_stdin) {

  000fc	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000ff	83 ba d0 02 00
	00 00		 cmp	 DWORD PTR [edx+720], 0
  00106	74 29		 je	 SHORT $LN4@clear

; 525  :         fclose(m_pipes.f_stdin);

  00108	8b f4		 mov	 esi, esp
  0010a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0010d	8b 88 d0 02 00
	00		 mov	 ecx, DWORD PTR [eax+720]
  00113	51		 push	 ecx
  00114	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  0011a	83 c4 04	 add	 esp, 4
  0011d	3b f4		 cmp	 esi, esp
  0011f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 526  :         m_pipes.f_stdin = NULL;

  00124	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00127	c7 82 d0 02 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+720], 0
$LN4@clear:

; 527  :     }
; 528  :     m_pProcess.reset();

  00131	6a 00		 push	 0
  00133	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00136	81 c1 9c 02 00
	00		 add	 ecx, 668		; 0000029cH
  0013c	e8 00 00 00 00	 call	 ?reset@?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@QAEXPAVRGYPipeProcess@@@Z ; std::unique_ptr<RGYPipeProcess,std::default_delete<RGYPipeProcess> >::reset

; 529  :     m_pRGYLog.reset();

  00141	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00144	81 c1 64 0b 00
	00		 add	 ecx, 2916		; 00000b64H
  0014a	e8 00 00 00 00	 call	 ?reset@?$shared_ptr@VRGYLog@@@std@@QAEXXZ ; std::shared_ptr<RGYLog>::reset

; 530  : }

  0014f	5e		 pop	 esi
  00150	83 c4 04	 add	 esp, 4
  00153	3b ec		 cmp	 ebp, esp
  00155	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0015a	8b e5		 mov	 esp, ebp
  0015c	5d		 pop	 ebp
  0015d	c3		 ret	 0
?clear@CPerfMonitor@@QAEXXZ ENDP			; CPerfMonitor::clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\rgy_perf_monitor.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_thEncThread$ = 8					; size = 4
_thInThread$ = 12					; size = 4
_thOutThread$ = 16					; size = 4
_thAudProcThread$ = 20					; size = 4
_thAudEncThread$ = 24					; size = 4
?SetThreadHandles@CPerfMonitor@@QAEXPAX0000@Z PROC	; CPerfMonitor::SetThreadHandles
; _this$ = ecx

; 864  : void CPerfMonitor::SetThreadHandles(HANDLE thEncThread, HANDLE thInThread, HANDLE thOutThread, HANDLE thAudProcThread, HANDLE thAudEncThread) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 865  :     m_thEncThread = thEncThread;

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 4d 08	 mov	 ecx, DWORD PTR _thEncThread$[ebp]
  00014	89 88 d8 0a 00
	00		 mov	 DWORD PTR [eax+2776], ecx

; 866  :     m_thInThread = thInThread;

  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	8b 45 0c	 mov	 eax, DWORD PTR _thInThread$[ebp]
  00020	89 82 dc 0a 00
	00		 mov	 DWORD PTR [edx+2780], eax

; 867  :     m_thOutThread = thOutThread;

  00026	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	8b 55 10	 mov	 edx, DWORD PTR _thOutThread$[ebp]
  0002c	89 91 e0 0a 00
	00		 mov	 DWORD PTR [ecx+2784], edx

; 868  :     m_thAudProcThread = thAudProcThread;

  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	8b 4d 14	 mov	 ecx, DWORD PTR _thAudProcThread$[ebp]
  00038	89 88 e4 0a 00
	00		 mov	 DWORD PTR [eax+2788], ecx

; 869  :     m_thAudEncThread = thAudEncThread;

  0003e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00041	8b 45 18	 mov	 eax, DWORD PTR _thAudEncThread$[ebp]
  00044	89 82 e8 0a 00
	00		 mov	 DWORD PTR [edx+2792], eax

; 870  : }

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 14 00	 ret	 20			; 00000014H
?SetThreadHandles@CPerfMonitor@@QAEXPAX0000@Z ENDP	; CPerfMonitor::SetThreadHandles
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\rgy_perf_monitor.cpp
_TEXT	SEGMENT
_data$ = -200						; size = 176
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_encStatus$ = 8						; size = 8
?SetEncStatus@CPerfMonitor@@QAEXV?$shared_ptr@VEncodeStatus@@@std@@@Z PROC ; CPerfMonitor::SetEncStatus
; _this$ = ecx

; 857  : void CPerfMonitor::SetEncStatus(std::shared_ptr<EncodeStatus> encStatus) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?SetEncStatus@CPerfMonitor@@QAEXV?$shared_ptr@VEncodeStatus@@@std@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00017	57		 push	 edi
  00018	51		 push	 ecx
  00019	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  0001f	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00024	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00029	f3 ab		 rep stosd
  0002b	59		 pop	 ecx
  0002c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00031	33 c5		 xor	 eax, ebp
  00033	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00036	50		 push	 eax
  00037	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0003a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00040	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00043	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 858  :     m_pEncStatus = encStatus;

  0004a	8d 45 08	 lea	 eax, DWORD PTR _encStatus$[ebp]
  0004d	50		 push	 eax
  0004e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	81 c1 f0 0a 00
	00		 add	 ecx, 2800		; 00000af0H
  00057	e8 00 00 00 00	 call	 ??4?$shared_ptr@VEncodeStatus@@@std@@QAEAAV01@ABV01@@Z ; std::shared_ptr<EncodeStatus>::operator=

; 859  :     EncodeStatusData data = m_pEncStatus->GetEncodeData();

  0005c	8d 8d 38 ff ff
	ff		 lea	 ecx, DWORD PTR _data$[ebp]
  00062	51		 push	 ecx
  00063	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00066	81 c1 f0 0a 00
	00		 add	 ecx, 2800		; 00000af0H
  0006c	e8 00 00 00 00	 call	 ??$?CVEncodeStatus@@$0A@@?$shared_ptr@VEncodeStatus@@@std@@QBEPAVEncodeStatus@@XZ ; std::shared_ptr<EncodeStatus>::operator-><EncodeStatus,0>
  00071	8b c8		 mov	 ecx, eax
  00073	e8 00 00 00 00	 call	 ?GetEncodeData@EncodeStatus@@QAE?AUEncodeStatusData@@XZ ; EncodeStatus::GetEncodeData

; 860  :     m_nOutputFPSScale = data.outputFPSScale;

  00078	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR _data$[ebp+4]
  0007e	33 c0		 xor	 eax, eax
  00080	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00083	89 91 08 0b 00
	00		 mov	 DWORD PTR [ecx+2824], edx
  00089	89 81 0c 0b 00
	00		 mov	 DWORD PTR [ecx+2828], eax

; 861  :     m_nOutputFPSRate = data.outputFPSRate;

  0008f	8b 95 38 ff ff
	ff		 mov	 edx, DWORD PTR _data$[ebp]
  00095	33 c0		 xor	 eax, eax
  00097	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0009a	89 91 00 0b 00
	00		 mov	 DWORD PTR [ecx+2816], edx
  000a0	89 81 04 0b 00
	00		 mov	 DWORD PTR [ecx+2820], eax

; 862  : }

  000a6	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000ad	8d 4d 08	 lea	 ecx, DWORD PTR _encStatus$[ebp]
  000b0	e8 00 00 00 00	 call	 ??1?$shared_ptr@VEncodeStatus@@@std@@QAE@XZ ; std::shared_ptr<EncodeStatus>::~shared_ptr<EncodeStatus>
  000b5	52		 push	 edx
  000b6	8b cd		 mov	 ecx, ebp
  000b8	50		 push	 eax
  000b9	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN7@SetEncStat
  000bf	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000c4	58		 pop	 eax
  000c5	5a		 pop	 edx
  000c6	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c9	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d0	59		 pop	 ecx
  000d1	5f		 pop	 edi
  000d2	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000d5	33 cd		 xor	 ecx, ebp
  000d7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000dc	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000e2	3b ec		 cmp	 ebp, esp
  000e4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e9	8b e5		 mov	 esp, ebp
  000eb	5d		 pop	 ebp
  000ec	c2 08 00	 ret	 8
  000ef	90		 npad	 1
$LN7@SetEncStat:
  000f0	01 00 00 00	 DD	 1
  000f4	00 00 00 00	 DD	 $LN6@SetEncStat
$LN6@SetEncStat:
  000f8	38 ff ff ff	 DD	 -200			; ffffff38H
  000fc	b0 00 00 00	 DD	 176			; 000000b0H
  00100	00 00 00 00	 DD	 $LN4@SetEncStat
$LN4@SetEncStat:
  00104	64		 DB	 100			; 00000064H
  00105	61		 DB	 97			; 00000061H
  00106	74		 DB	 116			; 00000074H
  00107	61		 DB	 97			; 00000061H
  00108	00		 DB	 0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?SetEncStatus@CPerfMonitor@@QAEXV?$shared_ptr@VEncodeStatus@@@std@@@Z$0:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR _encStatus$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VEncodeStatus@@@std@@QAE@XZ ; std::shared_ptr<EncodeStatus>::~shared_ptr<EncodeStatus>
__ehhandler$?SetEncStatus@CPerfMonitor@@QAEXV?$shared_ptr@VEncodeStatus@@@std@@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 8a 38 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-200]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001f	33 c8		 xor	 ecx, eax
  00021	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00026	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SetEncStatus@CPerfMonitor@@QAEXV?$shared_ptr@VEncodeStatus@@@std@@@Z
  0002b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SetEncStatus@CPerfMonitor@@QAEXV?$shared_ptr@VEncodeStatus@@@std@@@Z ENDP ; CPerfMonitor::SetEncStatus
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\rgy_perf_monitor.cpp
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CPerfMonitor@@QAE@XZ PROC				; CPerfMonitor::~CPerfMonitor
; _this$ = ecx

; 492  : CPerfMonitor::~CPerfMonitor() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CPerfMonitor@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002d	c7 45 fc 07 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 7

; 493  :     clear();

  00034	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	e8 00 00 00 00	 call	 ?clear@CPerfMonitor@@QAEXXZ ; CPerfMonitor::clear

; 494  : }

  0003c	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  00040	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	81 c1 64 0b 00
	00		 add	 ecx, 2916		; 00000b64H
  00049	e8 00 00 00 00	 call	 ??1?$shared_ptr@VRGYLog@@@std@@QAE@XZ ; std::shared_ptr<RGYLog>::~shared_ptr<RGYLog>
  0004e	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  00052	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	81 c1 3c 0b 00
	00		 add	 ecx, 2876		; 00000b3cH
  0005b	e8 00 00 00 00	 call	 ??1?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@QAE@XZ ; std::unique_ptr<_iobuf,fp_deleter>::~unique_ptr<_iobuf,fp_deleter>
  00060	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  00064	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00067	81 c1 20 0b 00
	00		 add	 ecx, 2848		; 00000b20H
  0006d	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00072	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00076	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00079	81 c1 f0 0a 00
	00		 add	 ecx, 2800		; 00000af0H
  0007f	e8 00 00 00 00	 call	 ??1?$shared_ptr@VEncodeStatus@@@std@@QAE@XZ ; std::shared_ptr<EncodeStatus>::~shared_ptr<EncodeStatus>
  00084	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00088	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0008b	81 c1 9c 02 00
	00		 add	 ecx, 668		; 0000029cH
  00091	e8 00 00 00 00	 call	 ??1?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@QAE@XZ ; std::unique_ptr<RGYPipeProcess,std::default_delete<RGYPipeProcess> >::~unique_ptr<RGYPipeProcess,std::default_delete<RGYPipeProcess> >
  00096	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0009a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0009d	81 c1 98 02 00
	00		 add	 ecx, 664		; 00000298H
  000a3	e8 00 00 00 00	 call	 ??1?$unique_ptr@XUhandle_deleter@@@std@@QAE@XZ ; std::unique_ptr<void,handle_deleter>::~unique_ptr<void,handle_deleter>
  000a8	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  000ac	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000af	81 c1 90 02 00
	00		 add	 ecx, 656		; 00000290H
  000b5	e8 00 00 00 00	 call	 ??1thread@std@@QAE@XZ	; std::thread::~thread
  000ba	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000c1	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000c4	83 c1 04	 add	 ecx, 4
  000c7	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  000cc	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000cf	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d6	59		 pop	 ecx
  000d7	83 c4 10	 add	 esp, 16			; 00000010H
  000da	3b ec		 cmp	 ebp, esp
  000dc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e1	8b e5		 mov	 esp, ebp
  000e3	5d		 pop	 ebp
  000e4	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??1CPerfMonitor@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??1CPerfMonitor@@QAE@XZ$1:
  0000b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	81 c1 90 02 00
	00		 add	 ecx, 656		; 00000290H
  00014	e9 00 00 00 00	 jmp	 ??1thread@std@@QAE@XZ	; std::thread::~thread
__unwindfunclet$??1CPerfMonitor@@QAE@XZ$2:
  00019	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	81 c1 98 02 00
	00		 add	 ecx, 664		; 00000298H
  00022	e9 00 00 00 00	 jmp	 ??1?$unique_ptr@XUhandle_deleter@@@std@@QAE@XZ ; std::unique_ptr<void,handle_deleter>::~unique_ptr<void,handle_deleter>
__unwindfunclet$??1CPerfMonitor@@QAE@XZ$3:
  00027	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	81 c1 9c 02 00
	00		 add	 ecx, 668		; 0000029cH
  00030	e9 00 00 00 00	 jmp	 ??1?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@QAE@XZ ; std::unique_ptr<RGYPipeProcess,std::default_delete<RGYPipeProcess> >::~unique_ptr<RGYPipeProcess,std::default_delete<RGYPipeProcess> >
__unwindfunclet$??1CPerfMonitor@@QAE@XZ$4:
  00035	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	81 c1 f0 0a 00
	00		 add	 ecx, 2800		; 00000af0H
  0003e	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VEncodeStatus@@@std@@QAE@XZ ; std::shared_ptr<EncodeStatus>::~shared_ptr<EncodeStatus>
__unwindfunclet$??1CPerfMonitor@@QAE@XZ$5:
  00043	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	81 c1 20 0b 00
	00		 add	 ecx, 2848		; 00000b20H
  0004c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??1CPerfMonitor@@QAE@XZ$6:
  00051	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	81 c1 3c 0b 00
	00		 add	 ecx, 2876		; 00000b3cH
  0005a	e9 00 00 00 00	 jmp	 ??1?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@QAE@XZ ; std::unique_ptr<_iobuf,fp_deleter>::~unique_ptr<_iobuf,fp_deleter>
__unwindfunclet$??1CPerfMonitor@@QAE@XZ$7:
  0005f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00062	81 c1 64 0b 00
	00		 add	 ecx, 2916		; 00000b64H
  00068	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VRGYLog@@@std@@QAE@XZ ; std::shared_ptr<RGYLog>::~shared_ptr<RGYLog>
__ehhandler$??1CPerfMonitor@@QAE@XZ:
  0006d	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00071	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00074	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00077	33 c8		 xor	 ecx, eax
  00079	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007e	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CPerfMonitor@@QAE@XZ
  00083	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CPerfMonitor@@QAE@XZ ENDP				; CPerfMonitor::~CPerfMonitor
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\rgy_perf_monitor.cpp
_TEXT	SEGMENT
tv534 = -2704						; size = 4
tv548 = -2700						; size = 4
tv532 = -2696						; size = 4
tv312 = -2692						; size = 4
tv459 = -2688						; size = 4
tv530 = -2684						; size = 4
tv318 = -2680						; size = 4
tv441 = -2676						; size = 4
tv398 = -2672						; size = 4
tv389 = -2668						; size = 4
tv341 = -2664						; size = 4
tv306 = -2660						; size = 4
tv297 = -2656						; size = 4
tv526 = -2652						; size = 4
tv547 = -2648						; size = 4
tv524 = -2644						; size = 4
tv546 = -2640						; size = 4
tv522 = -2636						; size = 4
tv545 = -2632						; size = 4
tv520 = -2628						; size = 4
tv544 = -2624						; size = 4
tv518 = -2620						; size = 4
tv543 = -2616						; size = 4
tv516 = -2612						; size = 4
tv542 = -2608						; size = 4
tv514 = -2604						; size = 4
tv541 = -2600						; size = 4
tv512 = -2596						; size = 4
tv231 = -2592						; size = 4
tv233 = -2588						; size = 4
tv509 = -2584						; size = 4
tv540 = -2580						; size = 4
tv507 = -2576						; size = 4
tv539 = -2572						; size = 4
tv196 = -2568						; size = 4
tv170 = -2564						; size = 4
tv157 = -2560						; size = 4
tv500 = -2556						; size = 4
tv538 = -2552						; size = 4
$T2 = -2548						; size = 4
$T3 = -2544						; size = 4
$T4 = -2540						; size = 8
$T5 = -2532						; size = 4
$T6 = -2528						; size = 4
$T7 = -2524						; size = 4
$T8 = -2520						; size = 4
$T9 = -2516						; size = 4
$T10 = -2512						; size = 4
$T11 = -2508						; size = 4
$T12 = -2504						; size = 4
$T13 = -2500						; size = 4
$T14 = -2496						; size = 4
$T15 = -2492						; size = 28
$T16 = -2464						; size = 28
_args$17 = -2432					; size = 16
_sInterval$18 = -2408					; size = 28
$T19 = -2376						; size = 28
$T20 = -2348						; size = 28
$T21 = -2320						; size = 28
$T22 = -2292						; size = 28
$T23 = -2264						; size = 28
$T24 = -2236						; size = 28
$T25 = -2208						; size = 28
$T26 = -2180						; size = 28
_sPythonPath$27 = -2148					; size = 28
_priority$28 = -2116					; size = 4
$T29 = -2112						; size = 28
_tempPath$30 = -2080					; size = 1024
_tempDir$31 = -1048					; size = 1024
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_filename$ = 8						; size = 28
_pPythonPath$ = 36					; size = 4
_interval$ = 40						; size = 4
_nSelectOutputLog$ = 44					; size = 4
_nSelectOutputPlot$ = 48				; size = 4
_thMainThread$ = 52					; size = 4
_pRGYLog$ = 56						; size = 8
_prm$ = 64						; size = 4
?init@CPerfMonitor@@QAEHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDHHHV?$unique_ptr@XUhandle_deleter@@@3@V?$shared_ptr@VRGYLog@@@3@PAUCPerfMonitorPrm@@@Z PROC ; CPerfMonitor::init
; _this$ = ecx

; 667  :     std::shared_ptr<RGYLog> pRGYLog, CPerfMonitorPrm *prm) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?init@CPerfMonitor@@QAEHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDHHHV?$unique_ptr@XUhandle_deleter@@@3@V?$shared_ptr@VRGYLog@@@3@PAUCPerfMonitorPrm@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 84 0a 00
	00		 sub	 esp, 2692		; 00000a84H
  00017	56		 push	 esi
  00018	57		 push	 edi
  00019	51		 push	 ecx
  0001a	8d bd 70 f5 ff
	ff		 lea	 edi, DWORD PTR [ebp-2704]
  00020	b9 a1 02 00 00	 mov	 ecx, 673		; 000002a1H
  00025	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002a	f3 ab		 rep stosd
  0002c	59		 pop	 ecx
  0002d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00032	33 c5		 xor	 eax, ebp
  00034	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00037	50		 push	 eax
  00038	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0003b	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00041	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00044	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2

; 668  :     clear();

  0004b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	e8 00 00 00 00	 call	 ?clear@CPerfMonitor@@QAEXXZ ; CPerfMonitor::clear

; 669  :     m_pRGYLog = pRGYLog;

  00053	8d 45 38	 lea	 eax, DWORD PTR _pRGYLog$[ebp]
  00056	50		 push	 eax
  00057	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0005a	81 c1 64 0b 00
	00		 add	 ecx, 2916		; 00000b64H
  00060	e8 00 00 00 00	 call	 ??4?$shared_ptr@VRGYLog@@@std@@QAEAAV01@ABV01@@Z ; std::shared_ptr<RGYLog>::operator=

; 670  : 
; 671  :     m_nCreateTime100ns = (int64_t)(clock() * (1e7 / CLOCKS_PER_SEC) + 0.5);

  00065	8b f4		 mov	 esi, esp
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__clock
  0006d	3b f4		 cmp	 esi, esp
  0006f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00074	f2 0f 2a c0	 cvtsi2sd xmm0, eax
  00078	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@40c3880000000000
  00080	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@3fe0000000000000
  00088	e8 00 00 00 00	 call	 __dtol3
  0008d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00090	89 81 10 0b 00
	00		 mov	 DWORD PTR [ecx+2832], eax
  00096	89 91 14 0b 00
	00		 mov	 DWORD PTR [ecx+2836], edx

; 672  :     m_sMonitorFilename = filename;

  0009c	8d 55 08	 lea	 edx, DWORD PTR _filename$[ebp]
  0009f	52		 push	 edx
  000a0	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000a3	81 c1 20 0b 00
	00		 add	 ecx, 2848		; 00000b20H
  000a9	e8 00 00 00 00	 call	 ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 673  :     m_nInterval = interval;

  000ae	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000b1	8b 4d 28	 mov	 ecx, DWORD PTR _interval$[ebp]
  000b4	89 88 1c 0b 00
	00		 mov	 DWORD PTR [eax+2844], ecx

; 674  :     m_nSelectOutputPlot = nSelectOutputPlot;

  000ba	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000bd	8b 45 30	 mov	 eax, DWORD PTR _nSelectOutputPlot$[ebp]
  000c0	89 82 48 0b 00
	00		 mov	 DWORD PTR [edx+2888], eax

; 675  :     m_nSelectOutputLog = nSelectOutputLog;

  000c6	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000c9	8b 55 2c	 mov	 edx, DWORD PTR _nSelectOutputLog$[ebp]
  000cc	89 91 44 0b 00
	00		 mov	 DWORD PTR [ecx+2884], edx

; 676  :     m_nSelectCheck = m_nSelectOutputLog | m_nSelectOutputPlot;

  000d2	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000d5	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000d8	8b 90 44 0b 00
	00		 mov	 edx, DWORD PTR [eax+2884]
  000de	0b 91 48 0b 00
	00		 or	 edx, DWORD PTR [ecx+2888]
  000e4	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000e7	89 90 40 0b 00
	00		 mov	 DWORD PTR [eax+2880], edx

; 677  :     m_thMainThread = std::move(thMainThread);

  000ed	8d 4d 34	 lea	 ecx, DWORD PTR _thMainThread$[ebp]
  000f0	51		 push	 ecx
  000f1	e8 00 00 00 00	 call	 ??$move@AAV?$unique_ptr@XUhandle_deleter@@@std@@@std@@YA$$QAV?$unique_ptr@XUhandle_deleter@@@0@AAV10@@Z ; std::move<std::unique_ptr<void,handle_deleter> &>
  000f6	83 c4 04	 add	 esp, 4
  000f9	50		 push	 eax
  000fa	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000fd	81 c1 98 02 00
	00		 add	 ecx, 664		; 00000298H
  00103	e8 00 00 00 00	 call	 ??4?$unique_ptr@XUhandle_deleter@@@std@@QAEAAV01@$$QAV01@@Z ; std::unique_ptr<void,handle_deleter>::operator=

; 678  : 
; 679  :     if (!m_fpLog && m_sMonitorFilename.length() > 0) {

  00108	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0010b	81 c1 3c 0b 00
	00		 add	 ecx, 2876		; 00000b3cH
  00111	e8 00 00 00 00	 call	 ??B?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@QBE_NXZ ; std::unique_ptr<_iobuf,fp_deleter>::operator bool
  00116	0f b6 d0	 movzx	 edx, al
  00119	85 d2		 test	 edx, edx
  0011b	0f 85 5c 01 00
	00		 jne	 $LN3@init
  00121	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00124	81 c1 20 0b 00
	00		 add	 ecx, 2848		; 00000b20H
  0012a	e8 00 00 00 00	 call	 ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
  0012f	85 c0		 test	 eax, eax
  00131	0f 86 46 01 00
	00		 jbe	 $LN3@init

; 680  :         m_fpLog = std::unique_ptr<FILE, fp_deleter>(_tfopen(m_sMonitorFilename.c_str(), _T("a")));

  00137	8b f4		 mov	 esi, esp
  00139	68 00 00 00 00	 push	 OFFSET $SG118976
  0013e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00141	81 c1 20 0b 00
	00		 add	 ecx, 2848		; 00000b20H
  00147	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  0014c	50		 push	 eax
  0014d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  00153	83 c4 08	 add	 esp, 8
  00156	3b f4		 cmp	 esi, esp
  00158	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0015d	50		 push	 eax
  0015e	8d 8d 40 f6 ff
	ff		 lea	 ecx, DWORD PTR $T14[ebp]
  00164	e8 00 00 00 00	 call	 ??$?0Ufp_deleter@@$0A@@?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@QAE@PAU_iobuf@@@Z ; std::unique_ptr<_iobuf,fp_deleter>::unique_ptr<_iobuf,fp_deleter><fp_deleter,0>
  00169	89 85 08 f6 ff
	ff		 mov	 DWORD PTR tv538[ebp], eax
  0016f	8b 85 08 f6 ff
	ff		 mov	 eax, DWORD PTR tv538[ebp]
  00175	89 85 04 f6 ff
	ff		 mov	 DWORD PTR tv500[ebp], eax
  0017b	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  0017f	8b 8d 04 f6 ff
	ff		 mov	 ecx, DWORD PTR tv500[ebp]
  00185	51		 push	 ecx
  00186	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00189	81 c1 3c 0b 00
	00		 add	 ecx, 2876		; 00000b3cH
  0018f	e8 00 00 00 00	 call	 ??4?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@QAEAAV01@$$QAV01@@Z ; std::unique_ptr<_iobuf,fp_deleter>::operator=
  00194	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00198	8d 8d 40 f6 ff
	ff		 lea	 ecx, DWORD PTR $T14[ebp]
  0019e	e8 00 00 00 00	 call	 ??1?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@QAE@XZ ; std::unique_ptr<_iobuf,fp_deleter>::~unique_ptr<_iobuf,fp_deleter>

; 681  :         if (!m_fpLog) {

  001a3	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001a6	81 c1 3c 0b 00
	00		 add	 ecx, 2876		; 00000b3cH
  001ac	e8 00 00 00 00	 call	 ??B?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@QBE_NXZ ; std::unique_ptr<_iobuf,fp_deleter>::operator bool
  001b1	0f b6 d0	 movzx	 edx, al
  001b4	85 d2		 test	 edx, edx
  001b6	0f 85 c1 00 00
	00		 jne	 $LN3@init

; 682  :             m_pRGYLog->write(RGY_LOG_WARN, _T("Failed to open performance monitor log file: %s\n"), m_sMonitorFilename.c_str());

  001bc	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001bf	81 c1 64 0b 00
	00		 add	 ecx, 2916		; 00000b64H
  001c5	e8 00 00 00 00	 call	 ??$?CVRGYLog@@$0A@@?$shared_ptr@VRGYLog@@@std@@QBEPAVRGYLog@@XZ ; std::shared_ptr<RGYLog>::operator-><RGYLog,0>
  001ca	89 85 00 f6 ff
	ff		 mov	 DWORD PTR tv157[ebp], eax
  001d0	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001d3	81 c1 20 0b 00
	00		 add	 ecx, 2848		; 00000b20H
  001d9	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  001de	8b f4		 mov	 esi, esp
  001e0	50		 push	 eax
  001e1	68 00 00 00 00	 push	 OFFSET $SG118978
  001e6	6a 01		 push	 1
  001e8	8b 85 00 f6 ff
	ff		 mov	 eax, DWORD PTR tv157[ebp]
  001ee	50		 push	 eax
  001ef	8b 8d 00 f6 ff
	ff		 mov	 ecx, DWORD PTR tv157[ebp]
  001f5	8b 11		 mov	 edx, DWORD PTR [ecx]
  001f7	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  001fa	ff d0		 call	 eax
  001fc	83 c4 10	 add	 esp, 16			; 00000010H
  001ff	3b f4		 cmp	 esi, esp
  00201	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 683  :             m_pRGYLog->write(RGY_LOG_WARN, _T("performance monitoring disabled.\n"));

  00206	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00209	81 c1 64 0b 00
	00		 add	 ecx, 2916		; 00000b64H
  0020f	e8 00 00 00 00	 call	 ??$?CVRGYLog@@$0A@@?$shared_ptr@VRGYLog@@@std@@QBEPAVRGYLog@@XZ ; std::shared_ptr<RGYLog>::operator-><RGYLog,0>
  00214	89 85 fc f5 ff
	ff		 mov	 DWORD PTR tv170[ebp], eax
  0021a	8b f4		 mov	 esi, esp
  0021c	68 00 00 00 00	 push	 OFFSET $SG118979
  00221	6a 01		 push	 1
  00223	8b 8d fc f5 ff
	ff		 mov	 ecx, DWORD PTR tv170[ebp]
  00229	51		 push	 ecx
  0022a	8b 95 fc f5 ff
	ff		 mov	 edx, DWORD PTR tv170[ebp]
  00230	8b 02		 mov	 eax, DWORD PTR [edx]
  00232	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00235	ff d1		 call	 ecx
  00237	83 c4 0c	 add	 esp, 12			; 0000000cH
  0023a	3b f4		 cmp	 esi, esp
  0023c	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 684  :             return 1;

  00241	c7 85 3c f6 ff
	ff 01 00 00 00	 mov	 DWORD PTR $T13[ebp], 1
  0024b	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0024f	8d 4d 08	 lea	 ecx, DWORD PTR _filename$[ebp]
  00252	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00257	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0025b	8d 4d 34	 lea	 ecx, DWORD PTR _thMainThread$[ebp]
  0025e	e8 00 00 00 00	 call	 ??1?$unique_ptr@XUhandle_deleter@@@std@@QAE@XZ ; std::unique_ptr<void,handle_deleter>::~unique_ptr<void,handle_deleter>
  00263	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0026a	8d 4d 38	 lea	 ecx, DWORD PTR _pRGYLog$[ebp]
  0026d	e8 00 00 00 00	 call	 ??1?$shared_ptr@VRGYLog@@@std@@QAE@XZ ; std::shared_ptr<RGYLog>::~shared_ptr<RGYLog>
  00272	8b 85 3c f6 ff
	ff		 mov	 eax, DWORD PTR $T13[ebp]
  00278	e9 f7 08 00 00	 jmp	 $LN1@init
$LN3@init:

; 685  :         }
; 686  :     }
; 687  : #if ENABLE_METRIC_FRAMEWORK
; 688  :     //LoadAll
; 689  :     //putenv("GM_EXTENSION_LIB_SKIP_LIST=SEPPublisher,PVRPublisher,CPUInfoPublisher,RenderPerfPublisher");
; 690  :     m_pLoader = ExtensionLoader::Create();
; 691  :     //m_pLoader->AddSearchPath(loadPath.c_str());
; 692  :     if (m_pLoader->Load("DefaultManager") == 0) {
; 693  :         pRGYLog->write(RGY_LOG_DEBUG, _T("PerfMonitor: Failed to load DefaultManager\n"));
; 694  :     } else if (m_pLoader->CommitExtensions() == 0) {
; 695  :     //} else if (m_pLoader->Load("LogPublisher") == 0) {
; 696  :         //pRGYLog->write(RGY_LOG_DEBUG, _T("PerfMonitor: Failed to load LogPublisher\n"));
; 697  :     //LoadAll
; 698  :     //} else if (m_pLoader->LoadAll() == 0) {
; 699  :         //pRGYLog->write(RGY_LOG_DEBUG, _T("PerfMonitor: Failed to load Metric dlls\n"));
; 700  :     //mfx2
; 701  :     } else if (m_pLoader->Load("MediaPerfPublisher") == 0) {
; 702  :         pRGYLog->write(RGY_LOG_DEBUG, _T("PerfMonitor: Failed to load MediaPerfPublisher\n"));
; 703  :     } else if (m_pLoader->Load("RenderPerfPublisher") == 0) {
; 704  :         pRGYLog->write(RGY_LOG_DEBUG, _T("PerfMonitor: Failed to load RenderPerfPublisher\n"));
; 705  :     //GPU
; 706  :     //} else if (m_pLoader->Load("GfxDrvSampledPublisher") == 0) {
; 707  :         //pRGYLog->write(RGY_LOG_DEBUG, _T("PerfMonitor: Failed to load GfxDrvSampledPublisher\n"));
; 708  :     } else if (m_pLoader->CommitExtensions() == 0) {
; 709  :         //pRGYLog->write(RGY_LOG_DEBUG, _T("PerfMonitor: Failed to CommitExtensions\n"));
; 710  :     } else {
; 711  :         //
; 712  :         m_pLoader->AddExtension("CQSVConsumer", &m_Consumer);
; 713  :         m_pManager.reset(GM_GET_DEFAULT_CLIENT_MANAGER(m_pLoader));
; 714  :         if (m_pManager == nullptr) {
; 715  :             pRGYLog->write(RGY_LOG_WARN, _T("No default Client Manager available\n"));
; 716  :         } else {
; 717  :             RegistrySearcher regsearcher(m_pManager.get(), RESOURCE_TYPE_METRIC, PAYLOAD_TYPE_ANY, 0);
; 718  :             std::map<MetricHandle, std::string> validMetrics;
; 719  :             for (int i = 0; i < _countof(METRIC_NAMES); i++) {
; 720  :                 PathHandle h = regsearcher[METRIC_NAMES[i]];
; 721  :                 if (h != 0) {
; 722  :                     validMetrics[h] = METRIC_NAMES[i];
; 723  :                 }
; 724  :             }
; 725  :             std::map<MetricHandle, std::string> subscribedMetrics;
; 726  :             for (auto metric = validMetrics.cbegin(); metric != validMetrics.cend(); metric++) {
; 727  :                 GM_STATUS status = m_pManager->SubscribeMetric(m_Consumer.GetHandle(), metric->first);
; 728  :                 if (GM_STATUS_SUCCESS != status) {
; 729  :                     pRGYLog->write(RGY_LOG_WARN, _T("Failure to subscribe %s metric: %d.\n"), char_to_tstring(metric->second).c_str(), status);
; 730  :                 } else {
; 731  :                     pRGYLog->write(RGY_LOG_DEBUG, _T("subscribed %s metric\n"), char_to_tstring(metric->second).c_str());
; 732  :                     subscribedMetrics[metric->first] = metric->second;
; 733  :                 }
; 734  :             }
; 735  :             m_Consumer.AddMetrics(subscribedMetrics);
; 736  :             if (subscribedMetrics.size() != _countof(METRIC_NAMES)) {
; 737  :                 pRGYLog->write(RGY_LOG_DEBUG, _T("metrics was not fully load, disable metric framework features.\n"));
; 738  :                 if (m_pManager) {
; 739  :                     const auto metricsUsed = m_Consumer.getMetricUsed();
; 740  :                     for (auto metric = metricsUsed.cbegin(); metric != metricsUsed.cend(); metric++) {
; 741  :                         m_pManager->UnsubscribeMetric(m_Consumer, metric->first);
; 742  :                     }
; 743  :                 }
; 744  :                 m_pManager.reset();
; 745  :             }
; 746  :         }
; 747  :     }
; 748  : #endif //#if ENABLE_METRIC_FRAMEWORK
; 749  : #if ENABLE_NVML
; 750  :     auto nvml_ret = m_nvmlMonitor.Init(prm->pciBusId);
; 751  :     if (nvml_ret != NVML_SUCCESS) {
; 752  :         pRGYLog->write(RGY_LOG_INFO, _T("Failed to start NVML Monitoring for \"%s\": %s.\n"), char_to_tstring(prm->pciBusId).c_str(), nvmlErrStr(nvml_ret));
; 753  :     } else {
; 754  :         pRGYLog->write(RGY_LOG_DEBUG, _T("Eanble NVML Monitoring\n"));
; 755  :     }
; 756  : #else
; 757  :     UNREFERENCED_PARAMETER(prm);
; 758  : #endif //#if ENABLE_NVML
; 759  : 
; 760  :     if (m_nSelectOutputPlot) {

  0027d	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00280	83 ba 48 0b 00
	00 00		 cmp	 DWORD PTR [edx+2888], 0
  00287	0f 84 89 06 00
	00		 je	 $LN4@init

; 761  : #if defined(_WIN32) || defined(_WIN64)
; 762  :         m_pProcess = std::unique_ptr<RGYPipeProcess>(new RGYPipeProcessWin());

  0028d	6a 18		 push	 24			; 00000018H
  0028f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00294	83 c4 04	 add	 esp, 4
  00297	89 85 30 f6 ff
	ff		 mov	 DWORD PTR $T10[ebp], eax
  0029d	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  002a1	83 bd 30 f6 ff
	ff 00		 cmp	 DWORD PTR $T10[ebp], 0
  002a8	74 13		 je	 SHORT $LN10@init
  002aa	8b 8d 30 f6 ff
	ff		 mov	 ecx, DWORD PTR $T10[ebp]
  002b0	e8 00 00 00 00	 call	 ??0RGYPipeProcessWin@@QAE@XZ ; RGYPipeProcessWin::RGYPipeProcessWin
  002b5	89 85 f8 f5 ff
	ff		 mov	 DWORD PTR tv196[ebp], eax
  002bb	eb 0a		 jmp	 SHORT $LN11@init
$LN10@init:
  002bd	c7 85 f8 f5 ff
	ff 00 00 00 00	 mov	 DWORD PTR tv196[ebp], 0
$LN11@init:
  002c7	8b 85 f8 f5 ff
	ff		 mov	 eax, DWORD PTR tv196[ebp]
  002cd	89 85 34 f6 ff
	ff		 mov	 DWORD PTR $T11[ebp], eax
  002d3	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  002d7	8b 8d 34 f6 ff
	ff		 mov	 ecx, DWORD PTR $T11[ebp]
  002dd	51		 push	 ecx
  002de	8d 8d 38 f6 ff
	ff		 lea	 ecx, DWORD PTR $T12[ebp]
  002e4	e8 00 00 00 00	 call	 ??$?0U?$default_delete@VRGYPipeProcess@@@std@@$0A@@?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@QAE@PAVRGYPipeProcess@@@Z ; std::unique_ptr<RGYPipeProcess,std::default_delete<RGYPipeProcess> >::unique_ptr<RGYPipeProcess,std::default_delete<RGYPipeProcess> ><std::default_delete<RGYPipeProcess>,0>
  002e9	89 85 f4 f5 ff
	ff		 mov	 DWORD PTR tv539[ebp], eax
  002ef	8b 95 f4 f5 ff
	ff		 mov	 edx, DWORD PTR tv539[ebp]
  002f5	89 95 f0 f5 ff
	ff		 mov	 DWORD PTR tv507[ebp], edx
  002fb	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  002ff	8b 85 f0 f5 ff
	ff		 mov	 eax, DWORD PTR tv507[ebp]
  00305	50		 push	 eax
  00306	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00309	81 c1 9c 02 00
	00		 add	 ecx, 668		; 0000029cH
  0030f	e8 00 00 00 00	 call	 ??4?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@QAEAAV01@$$QAV01@@Z ; std::unique_ptr<RGYPipeProcess,std::default_delete<RGYPipeProcess> >::operator=
  00314	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00318	8d 8d 38 f6 ff
	ff		 lea	 ecx, DWORD PTR $T12[ebp]
  0031e	e8 00 00 00 00	 call	 ??1?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@QAE@XZ ; std::unique_ptr<RGYPipeProcess,std::default_delete<RGYPipeProcess> >::~unique_ptr<RGYPipeProcess,std::default_delete<RGYPipeProcess> >

; 763  :         m_pipes.stdIn.mode = PIPE_MODE_ENABLE;

  00323	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00326	c7 81 a8 02 00
	00 01 00 00 00	 mov	 DWORD PTR [ecx+680], 1

; 764  :         TCHAR tempDir[1024] = { 0 };

  00330	68 00 04 00 00	 push	 1024			; 00000400H
  00335	6a 00		 push	 0
  00337	8d 95 e8 fb ff
	ff		 lea	 edx, DWORD PTR _tempDir$31[ebp]
  0033d	52		 push	 edx
  0033e	e8 00 00 00 00	 call	 _memset
  00343	83 c4 0c	 add	 esp, 12			; 0000000cH

; 765  :         TCHAR tempPath[1024] = { 0 };

  00346	68 00 04 00 00	 push	 1024			; 00000400H
  0034b	6a 00		 push	 0
  0034d	8d 85 e0 f7 ff
	ff		 lea	 eax, DWORD PTR _tempPath$30[ebp]
  00353	50		 push	 eax
  00354	e8 00 00 00 00	 call	 _memset
  00359	83 c4 0c	 add	 esp, 12			; 0000000cH

; 766  :         GetModuleFileName(NULL, tempDir, _countof(tempDir));

  0035c	8b f4		 mov	 esi, esp
  0035e	68 00 04 00 00	 push	 1024			; 00000400H
  00363	8d 8d e8 fb ff
	ff		 lea	 ecx, DWORD PTR _tempDir$31[ebp]
  00369	51		 push	 ecx
  0036a	6a 00		 push	 0
  0036c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleFileNameA@12
  00372	3b f4		 cmp	 esi, esp
  00374	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 767  :         PathRemoveFileSpec(tempDir);

  00379	8b f4		 mov	 esi, esp
  0037b	8d 95 e8 fb ff
	ff		 lea	 edx, DWORD PTR _tempDir$31[ebp]
  00381	52		 push	 edx
  00382	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PathRemoveFileSpecA@4
  00388	3b f4		 cmp	 esi, esp
  0038a	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 768  :         PathCombine(tempPath, tempDir, strsprintf(_T("qsvencc_perf_monitor_%d.pyw"), GetProcessId(GetCurrentProcess())).c_str());

  0038f	8b f4		 mov	 esi, esp
  00391	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentProcess@0
  00397	3b f4		 cmp	 esi, esp
  00399	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0039e	8b f4		 mov	 esi, esp
  003a0	50		 push	 eax
  003a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcessId@4
  003a7	3b f4		 cmp	 esi, esp
  003a9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003ae	50		 push	 eax
  003af	68 00 00 00 00	 push	 OFFSET $SG118983
  003b4	8d 85 c0 f7 ff
	ff		 lea	 eax, DWORD PTR $T29[ebp]
  003ba	50		 push	 eax
  003bb	e8 00 00 00 00	 call	 ?strsprintf@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; strsprintf
  003c0	83 c4 0c	 add	 esp, 12			; 0000000cH
  003c3	89 85 ec f5 ff
	ff		 mov	 DWORD PTR tv540[ebp], eax
  003c9	8b 8d ec f5 ff
	ff		 mov	 ecx, DWORD PTR tv540[ebp]
  003cf	89 8d e8 f5 ff
	ff		 mov	 DWORD PTR tv509[ebp], ecx
  003d5	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  003d9	8b 8d e8 f5 ff
	ff		 mov	 ecx, DWORD PTR tv509[ebp]
  003df	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  003e4	8b f4		 mov	 esi, esp
  003e6	50		 push	 eax
  003e7	8d 95 e8 fb ff
	ff		 lea	 edx, DWORD PTR _tempDir$31[ebp]
  003ed	52		 push	 edx
  003ee	8d 85 e0 f7 ff
	ff		 lea	 eax, DWORD PTR _tempPath$30[ebp]
  003f4	50		 push	 eax
  003f5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PathCombineA@12
  003fb	3b f4		 cmp	 esi, esp
  003fd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00402	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00406	8d 8d c0 f7 ff
	ff		 lea	 ecx, DWORD PTR $T29[ebp]
  0040c	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 769  :         m_sPywPath = tempPath;

  00411	8d 8d e0 f7 ff
	ff		 lea	 ecx, DWORD PTR _tempPath$30[ebp]
  00417	51		 push	 ecx
  00418	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0041b	83 c1 04	 add	 ecx, 4
  0041e	e8 00 00 00 00	 call	 ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 770  :         uint32_t priority = NORMAL_PRIORITY_CLASS;

  00423	c7 85 bc f7 ff
	ff 20 00 00 00	 mov	 DWORD PTR _priority$28[ebp], 32 ; 00000020H

; 771  : #else
; 772  :         m_pProcess = std::unique_ptr<RGYPipeProcess>(new RGYPipeProcessLinux());
; 773  :         m_pipes.stdIn.mode = PIPE_MODE_ENABLE;
; 774  :         m_sPywPath = tstring(_T("/tmp/")) + strsprintf(_T("qsvencc_perf_monitor_%d.pyw"), (int)getpid());
; 775  :         uint32_t priority = 0;
; 776  : #endif
; 777  :         tstring sPythonPath = (pPythonPath) ? pPythonPath : _T("python");

  0042d	83 7d 24 00	 cmp	 DWORD PTR _pPythonPath$[ebp], 0
  00431	74 0b		 je	 SHORT $LN12@init
  00433	8b 55 24	 mov	 edx, DWORD PTR _pPythonPath$[ebp]
  00436	89 95 e4 f5 ff
	ff		 mov	 DWORD PTR tv233[ebp], edx
  0043c	eb 0a		 jmp	 SHORT $LN13@init
$LN12@init:
  0043e	c7 85 e4 f5 ff
	ff 00 00 00 00	 mov	 DWORD PTR tv233[ebp], OFFSET $SG118984
$LN13@init:
  00448	8b 85 e4 f5 ff
	ff		 mov	 eax, DWORD PTR tv233[ebp]
  0044e	50		 push	 eax
  0044f	8d 8d 9c f7 ff
	ff		 lea	 ecx, DWORD PTR _sPythonPath$27[ebp]
  00455	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0045a	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7

; 778  : #if defined(_WIN32) || defined(_WIN64)
; 779  :         sPythonPath = tstring(_T("\"")) + sPythonPath + tstring(_T("\""));

  0045e	68 00 00 00 00	 push	 OFFSET $SG118985
  00463	8d 8d 44 f7 ff
	ff		 lea	 ecx, DWORD PTR $T24[ebp]
  00469	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0046e	89 85 e0 f5 ff
	ff		 mov	 DWORD PTR tv231[ebp], eax
  00474	8b 8d e0 f5 ff
	ff		 mov	 ecx, DWORD PTR tv231[ebp]
  0047a	89 8d dc f5 ff
	ff		 mov	 DWORD PTR tv512[ebp], ecx
  00480	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  00484	8b 95 dc f5 ff
	ff		 mov	 edx, DWORD PTR tv512[ebp]
  0048a	52		 push	 edx
  0048b	8d 85 9c f7 ff
	ff		 lea	 eax, DWORD PTR _sPythonPath$27[ebp]
  00491	50		 push	 eax
  00492	68 00 00 00 00	 push	 OFFSET $SG118986
  00497	8d 8d 7c f7 ff
	ff		 lea	 ecx, DWORD PTR $T26[ebp]
  0049d	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  004a2	89 85 d8 f5 ff
	ff		 mov	 DWORD PTR tv541[ebp], eax
  004a8	8b 8d d8 f5 ff
	ff		 mov	 ecx, DWORD PTR tv541[ebp]
  004ae	89 8d d4 f5 ff
	ff		 mov	 DWORD PTR tv514[ebp], ecx
  004b4	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
  004b8	8b 95 d4 f5 ff
	ff		 mov	 edx, DWORD PTR tv514[ebp]
  004be	52		 push	 edx
  004bf	8d 85 60 f7 ff
	ff		 lea	 eax, DWORD PTR $T25[ebp]
  004c5	50		 push	 eax
  004c6	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@ABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  004cb	83 c4 0c	 add	 esp, 12			; 0000000cH
  004ce	89 85 d0 f5 ff
	ff		 mov	 DWORD PTR tv542[ebp], eax
  004d4	8b 8d d0 f5 ff
	ff		 mov	 ecx, DWORD PTR tv542[ebp]
  004da	89 8d cc f5 ff
	ff		 mov	 DWORD PTR tv516[ebp], ecx
  004e0	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+8], 10 ; 0000000aH
  004e4	8b 95 cc f5 ff
	ff		 mov	 edx, DWORD PTR tv516[ebp]
  004ea	52		 push	 edx
  004eb	8d 85 28 f7 ff
	ff		 lea	 eax, DWORD PTR $T23[ebp]
  004f1	50		 push	 eax
  004f2	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  004f7	83 c4 0c	 add	 esp, 12			; 0000000cH
  004fa	89 85 c8 f5 ff
	ff		 mov	 DWORD PTR tv543[ebp], eax
  00500	8b 8d c8 f5 ff
	ff		 mov	 ecx, DWORD PTR tv543[ebp]
  00506	89 8d c4 f5 ff
	ff		 mov	 DWORD PTR tv518[ebp], ecx
  0050c	c6 45 fc 0b	 mov	 BYTE PTR __$EHRec$[ebp+8], 11 ; 0000000bH
  00510	8b 95 c4 f5 ff
	ff		 mov	 edx, DWORD PTR tv518[ebp]
  00516	52		 push	 edx
  00517	8d 8d 9c f7 ff
	ff		 lea	 ecx, DWORD PTR _sPythonPath$27[ebp]
  0051d	e8 00 00 00 00	 call	 ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
  00522	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+8], 10 ; 0000000aH
  00526	8d 8d 28 f7 ff
	ff		 lea	 ecx, DWORD PTR $T23[ebp]
  0052c	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00531	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
  00535	8d 8d 60 f7 ff
	ff		 lea	 ecx, DWORD PTR $T25[ebp]
  0053b	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00540	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  00544	8d 8d 7c f7 ff
	ff		 lea	 ecx, DWORD PTR $T26[ebp]
  0054a	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0054f	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  00553	8d 8d 44 f7 ff
	ff		 lea	 ecx, DWORD PTR $T24[ebp]
  00559	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 780  :         m_sPywPath = tstring(_T("\"")) + m_sPywPath + tstring(_T("\""));

  0055e	68 00 00 00 00	 push	 OFFSET $SG118987
  00563	8d 8d d4 f6 ff
	ff		 lea	 ecx, DWORD PTR $T20[ebp]
  00569	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0056e	89 85 c0 f5 ff
	ff		 mov	 DWORD PTR tv544[ebp], eax
  00574	8b 85 c0 f5 ff
	ff		 mov	 eax, DWORD PTR tv544[ebp]
  0057a	89 85 bc f5 ff
	ff		 mov	 DWORD PTR tv520[ebp], eax
  00580	c6 45 fc 0c	 mov	 BYTE PTR __$EHRec$[ebp+8], 12 ; 0000000cH
  00584	8b 8d bc f5 ff
	ff		 mov	 ecx, DWORD PTR tv520[ebp]
  0058a	51		 push	 ecx
  0058b	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0058e	83 c2 04	 add	 edx, 4
  00591	52		 push	 edx
  00592	68 00 00 00 00	 push	 OFFSET $SG118988
  00597	8d 8d 0c f7 ff
	ff		 lea	 ecx, DWORD PTR $T22[ebp]
  0059d	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  005a2	89 85 b8 f5 ff
	ff		 mov	 DWORD PTR tv545[ebp], eax
  005a8	8b 85 b8 f5 ff
	ff		 mov	 eax, DWORD PTR tv545[ebp]
  005ae	89 85 b4 f5 ff
	ff		 mov	 DWORD PTR tv522[ebp], eax
  005b4	c6 45 fc 0d	 mov	 BYTE PTR __$EHRec$[ebp+8], 13 ; 0000000dH
  005b8	8b 8d b4 f5 ff
	ff		 mov	 ecx, DWORD PTR tv522[ebp]
  005be	51		 push	 ecx
  005bf	8d 95 f0 f6 ff
	ff		 lea	 edx, DWORD PTR $T21[ebp]
  005c5	52		 push	 edx
  005c6	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@ABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  005cb	83 c4 0c	 add	 esp, 12			; 0000000cH
  005ce	89 85 b0 f5 ff
	ff		 mov	 DWORD PTR tv546[ebp], eax
  005d4	8b 85 b0 f5 ff
	ff		 mov	 eax, DWORD PTR tv546[ebp]
  005da	89 85 ac f5 ff
	ff		 mov	 DWORD PTR tv524[ebp], eax
  005e0	c6 45 fc 0e	 mov	 BYTE PTR __$EHRec$[ebp+8], 14 ; 0000000eH
  005e4	8b 8d ac f5 ff
	ff		 mov	 ecx, DWORD PTR tv524[ebp]
  005ea	51		 push	 ecx
  005eb	8d 95 b8 f6 ff
	ff		 lea	 edx, DWORD PTR $T19[ebp]
  005f1	52		 push	 edx
  005f2	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  005f7	83 c4 0c	 add	 esp, 12			; 0000000cH
  005fa	89 85 a8 f5 ff
	ff		 mov	 DWORD PTR tv547[ebp], eax
  00600	8b 85 a8 f5 ff
	ff		 mov	 eax, DWORD PTR tv547[ebp]
  00606	89 85 a4 f5 ff
	ff		 mov	 DWORD PTR tv526[ebp], eax
  0060c	c6 45 fc 0f	 mov	 BYTE PTR __$EHRec$[ebp+8], 15 ; 0000000fH
  00610	8b 8d a4 f5 ff
	ff		 mov	 ecx, DWORD PTR tv526[ebp]
  00616	51		 push	 ecx
  00617	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0061a	83 c1 04	 add	 ecx, 4
  0061d	e8 00 00 00 00	 call	 ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
  00622	c6 45 fc 0e	 mov	 BYTE PTR __$EHRec$[ebp+8], 14 ; 0000000eH
  00626	8d 8d b8 f6 ff
	ff		 lea	 ecx, DWORD PTR $T19[ebp]
  0062c	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00631	c6 45 fc 0d	 mov	 BYTE PTR __$EHRec$[ebp+8], 13 ; 0000000dH
  00635	8d 8d f0 f6 ff
	ff		 lea	 ecx, DWORD PTR $T21[ebp]
  0063b	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00640	c6 45 fc 0c	 mov	 BYTE PTR __$EHRec$[ebp+8], 12 ; 0000000cH
  00644	8d 8d 0c f7 ff
	ff		 lea	 ecx, DWORD PTR $T22[ebp]
  0064a	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0064f	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  00653	8d 8d d4 f6 ff
	ff		 lea	 ecx, DWORD PTR $T20[ebp]
  00659	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 781  : #else
; 782  :         int ret = 0;
; 783  :         if (0 > (ret = system((sPythonPath + " --version > /dev/null 2>&1").c_str()))) {
; 784  :             m_pRGYLog->write(RGY_LOG_WARN, _T("Failed to run \"%s\". \n")
; 785  :                 _T("--perf-monitor-plot requires python3.x, please set python3 path by \"--python\".\n"), sPythonPath.c_str());
; 786  :             m_nSelectOutputPlot = 0;
; 787  :         } else if (0 > (ret = system((sPythonPath + " -c \"print 'test'\" > /dev/null 2>&1").c_str())) || WEXITSTATUS(ret) == 0) {
; 788  :             m_pRGYLog->write(RGY_LOG_WARN, _T("\"%s\" is not python3.x.\n")
; 789  :                     _T("--perf-monitor-plot requires python3.x, please set python3 path by \"--python\".\n"), sPythonPath.c_str());
; 790  :             m_nSelectOutputPlot = 0;
; 791  :         }
; 792  : #endif
; 793  :         if (createPerfMpnitorPyw(m_sPywPath.c_str())) {

  0065e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00661	83 c1 04	 add	 ecx, 4
  00664	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  00669	50		 push	 eax
  0066a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0066d	e8 00 00 00 00	 call	 ?createPerfMpnitorPyw@CPerfMonitor@@IAEHPBD@Z ; CPerfMonitor::createPerfMpnitorPyw
  00672	85 c0		 test	 eax, eax
  00674	0f 84 88 00 00
	00		 je	 $LN5@init

; 794  :             m_pRGYLog->write(RGY_LOG_WARN, _T("Failed to create file qsvencc_perf_monitor.pyw for performance monitor plot.\n"));

  0067a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0067d	81 c1 64 0b 00
	00		 add	 ecx, 2916		; 00000b64H
  00683	e8 00 00 00 00	 call	 ??$?CVRGYLog@@$0A@@?$shared_ptr@VRGYLog@@@std@@QBEPAVRGYLog@@XZ ; std::shared_ptr<RGYLog>::operator-><RGYLog,0>
  00688	89 85 a0 f5 ff
	ff		 mov	 DWORD PTR tv297[ebp], eax
  0068e	8b f4		 mov	 esi, esp
  00690	68 00 00 00 00	 push	 OFFSET $SG118991
  00695	6a 01		 push	 1
  00697	8b 95 a0 f5 ff
	ff		 mov	 edx, DWORD PTR tv297[ebp]
  0069d	52		 push	 edx
  0069e	8b 85 a0 f5 ff
	ff		 mov	 eax, DWORD PTR tv297[ebp]
  006a4	8b 08		 mov	 ecx, DWORD PTR [eax]
  006a6	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  006a9	ff d2		 call	 edx
  006ab	83 c4 0c	 add	 esp, 12			; 0000000cH
  006ae	3b f4		 cmp	 esi, esp
  006b0	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 795  :             m_pRGYLog->write(RGY_LOG_WARN, _T("performance monitor plot disabled.\n"));

  006b5	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  006b8	81 c1 64 0b 00
	00		 add	 ecx, 2916		; 00000b64H
  006be	e8 00 00 00 00	 call	 ??$?CVRGYLog@@$0A@@?$shared_ptr@VRGYLog@@@std@@QBEPAVRGYLog@@XZ ; std::shared_ptr<RGYLog>::operator-><RGYLog,0>
  006c3	89 85 9c f5 ff
	ff		 mov	 DWORD PTR tv306[ebp], eax
  006c9	8b f4		 mov	 esi, esp
  006cb	68 00 00 00 00	 push	 OFFSET $SG118992
  006d0	6a 01		 push	 1
  006d2	8b 85 9c f5 ff
	ff		 mov	 eax, DWORD PTR tv306[ebp]
  006d8	50		 push	 eax
  006d9	8b 8d 9c f5 ff
	ff		 mov	 ecx, DWORD PTR tv306[ebp]
  006df	8b 11		 mov	 edx, DWORD PTR [ecx]
  006e1	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  006e4	ff d0		 call	 eax
  006e6	83 c4 0c	 add	 esp, 12			; 0000000cH
  006e9	3b f4		 cmp	 esi, esp
  006eb	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 796  :             m_nSelectOutputPlot = 0;

  006f0	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  006f3	c7 81 48 0b 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+2888], 0

; 797  :         } else {

  006fd	e9 05 02 00 00	 jmp	 $LN6@init
$LN5@init:

; 798  :             tstring sInterval = strsprintf(_T("%d"), interval);

  00702	8b 55 28	 mov	 edx, DWORD PTR _interval$[ebp]
  00705	52		 push	 edx
  00706	68 00 00 00 00	 push	 OFFSET $SG118993
  0070b	8d 85 98 f6 ff
	ff		 lea	 eax, DWORD PTR _sInterval$18[ebp]
  00711	50		 push	 eax
  00712	e8 00 00 00 00	 call	 ?strsprintf@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; strsprintf
  00717	83 c4 0c	 add	 esp, 12			; 0000000cH
  0071a	c6 45 fc 10	 mov	 BYTE PTR __$EHRec$[ebp+8], 16 ; 00000010H

; 799  :             std::vector<const TCHAR *> args;

  0071e	8d 8d 80 f6 ff
	ff		 lea	 ecx, DWORD PTR _args$17[ebp]
  00724	e8 00 00 00 00	 call	 ??0?$vector@PBDV?$allocator@PBD@std@@@std@@QAE@XZ ; std::vector<char const *,std::allocator<char const *> >::vector<char const *,std::allocator<char const *> >
  00729	c6 45 fc 11	 mov	 BYTE PTR __$EHRec$[ebp+8], 17 ; 00000011H

; 800  :             args.push_back(sPythonPath.c_str());

  0072d	8d 8d 9c f7 ff
	ff		 lea	 ecx, DWORD PTR _sPythonPath$27[ebp]
  00733	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  00738	89 85 2c f6 ff
	ff		 mov	 DWORD PTR $T9[ebp], eax
  0073e	8d 8d 2c f6 ff
	ff		 lea	 ecx, DWORD PTR $T9[ebp]
  00744	51		 push	 ecx
  00745	8d 8d 80 f6 ff
	ff		 lea	 ecx, DWORD PTR _args$17[ebp]
  0074b	e8 00 00 00 00	 call	 ?push_back@?$vector@PBDV?$allocator@PBD@std@@@std@@QAEX$$QAPBD@Z ; std::vector<char const *,std::allocator<char const *> >::push_back

; 801  :             args.push_back(m_sPywPath.c_str());

  00750	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00753	83 c1 04	 add	 ecx, 4
  00756	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  0075b	89 85 28 f6 ff
	ff		 mov	 DWORD PTR $T8[ebp], eax
  00761	8d 95 28 f6 ff
	ff		 lea	 edx, DWORD PTR $T8[ebp]
  00767	52		 push	 edx
  00768	8d 8d 80 f6 ff
	ff		 lea	 ecx, DWORD PTR _args$17[ebp]
  0076e	e8 00 00 00 00	 call	 ?push_back@?$vector@PBDV?$allocator@PBD@std@@@std@@QAEX$$QAPBD@Z ; std::vector<char const *,std::allocator<char const *> >::push_back

; 802  :             args.push_back(_T("-i"));

  00773	c7 85 24 f6 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T7[ebp], OFFSET $SG118994
  0077d	8d 85 24 f6 ff
	ff		 lea	 eax, DWORD PTR $T7[ebp]
  00783	50		 push	 eax
  00784	8d 8d 80 f6 ff
	ff		 lea	 ecx, DWORD PTR _args$17[ebp]
  0078a	e8 00 00 00 00	 call	 ?push_back@?$vector@PBDV?$allocator@PBD@std@@@std@@QAEXABQBD@Z ; std::vector<char const *,std::allocator<char const *> >::push_back

; 803  :             args.push_back(sInterval.c_str());

  0078f	8d 8d 98 f6 ff
	ff		 lea	 ecx, DWORD PTR _sInterval$18[ebp]
  00795	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  0079a	89 85 20 f6 ff
	ff		 mov	 DWORD PTR $T6[ebp], eax
  007a0	8d 8d 20 f6 ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  007a6	51		 push	 ecx
  007a7	8d 8d 80 f6 ff
	ff		 lea	 ecx, DWORD PTR _args$17[ebp]
  007ad	e8 00 00 00 00	 call	 ?push_back@?$vector@PBDV?$allocator@PBD@std@@@std@@QAEX$$QAPBD@Z ; std::vector<char const *,std::allocator<char const *> >::push_back

; 804  :             args.push_back(nullptr);

  007b2	c7 85 1c f6 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T5[ebp], 0
  007bc	8d 95 1c f6 ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  007c2	52		 push	 edx
  007c3	8d 8d 80 f6 ff
	ff		 lea	 ecx, DWORD PTR _args$17[ebp]
  007c9	e8 00 00 00 00	 call	 ?push_back@?$vector@PBDV?$allocator@PBD@std@@@std@@QAEX$$QAPBD@Z ; std::vector<char const *,std::allocator<char const *> >::push_back

; 805  :             if (m_pProcess->run(args, nullptr, &m_pipes, priority, false, false)) {

  007ce	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  007d1	81 c1 9c 02 00
	00		 add	 ecx, 668		; 0000029cH
  007d7	e8 00 00 00 00	 call	 ??C?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@QBEPAVRGYPipeProcess@@XZ ; std::unique_ptr<RGYPipeProcess,std::default_delete<RGYPipeProcess> >::operator->
  007dc	89 85 98 f5 ff
	ff		 mov	 DWORD PTR tv341[ebp], eax
  007e2	8b f4		 mov	 esi, esp
  007e4	6a 00		 push	 0
  007e6	6a 00		 push	 0
  007e8	8b 85 bc f7 ff
	ff		 mov	 eax, DWORD PTR _priority$28[ebp]
  007ee	50		 push	 eax
  007ef	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  007f2	81 c1 a0 02 00
	00		 add	 ecx, 672		; 000002a0H
  007f8	51		 push	 ecx
  007f9	6a 00		 push	 0
  007fb	8d 95 80 f6 ff
	ff		 lea	 edx, DWORD PTR _args$17[ebp]
  00801	52		 push	 edx
  00802	8b 85 98 f5 ff
	ff		 mov	 eax, DWORD PTR tv341[ebp]
  00808	8b 10		 mov	 edx, DWORD PTR [eax]
  0080a	8b 8d 98 f5 ff
	ff		 mov	 ecx, DWORD PTR tv341[ebp]
  00810	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00813	ff d0		 call	 eax
  00815	3b f4		 cmp	 esi, esp
  00817	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0081c	85 c0		 test	 eax, eax
  0081e	0f 84 85 00 00
	00		 je	 $LN7@init

; 806  :                 m_pRGYLog->write(RGY_LOG_WARN, _T("Failed to run performance monitor plot.\n"));

  00824	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00827	81 c1 64 0b 00
	00		 add	 ecx, 2916		; 00000b64H
  0082d	e8 00 00 00 00	 call	 ??$?CVRGYLog@@$0A@@?$shared_ptr@VRGYLog@@@std@@QBEPAVRGYLog@@XZ ; std::shared_ptr<RGYLog>::operator-><RGYLog,0>
  00832	89 85 94 f5 ff
	ff		 mov	 DWORD PTR tv389[ebp], eax
  00838	8b f4		 mov	 esi, esp
  0083a	68 00 00 00 00	 push	 OFFSET $SG118997
  0083f	6a 01		 push	 1
  00841	8b 8d 94 f5 ff
	ff		 mov	 ecx, DWORD PTR tv389[ebp]
  00847	51		 push	 ecx
  00848	8b 95 94 f5 ff
	ff		 mov	 edx, DWORD PTR tv389[ebp]
  0084e	8b 02		 mov	 eax, DWORD PTR [edx]
  00850	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00853	ff d1		 call	 ecx
  00855	83 c4 0c	 add	 esp, 12			; 0000000cH
  00858	3b f4		 cmp	 esi, esp
  0085a	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 807  :                 m_pRGYLog->write(RGY_LOG_WARN, _T("performance monitor plot disabled.\n"));

  0085f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00862	81 c1 64 0b 00
	00		 add	 ecx, 2916		; 00000b64H
  00868	e8 00 00 00 00	 call	 ??$?CVRGYLog@@$0A@@?$shared_ptr@VRGYLog@@@std@@QBEPAVRGYLog@@XZ ; std::shared_ptr<RGYLog>::operator-><RGYLog,0>
  0086d	89 85 90 f5 ff
	ff		 mov	 DWORD PTR tv398[ebp], eax
  00873	8b f4		 mov	 esi, esp
  00875	68 00 00 00 00	 push	 OFFSET $SG118998
  0087a	6a 01		 push	 1
  0087c	8b 95 90 f5 ff
	ff		 mov	 edx, DWORD PTR tv398[ebp]
  00882	52		 push	 edx
  00883	8b 85 90 f5 ff
	ff		 mov	 eax, DWORD PTR tv398[ebp]
  00889	8b 08		 mov	 ecx, DWORD PTR [eax]
  0088b	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0088e	ff d2		 call	 edx
  00890	83 c4 0c	 add	 esp, 12			; 0000000cH
  00893	3b f4		 cmp	 esi, esp
  00895	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 808  :                 m_nSelectOutputPlot = 0;

  0089a	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0089d	c7 80 48 0b 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+2888], 0

; 809  : #if defined(_WIN32) || defined(_WIN64)
; 810  :             } else {

  008a7	eb 40		 jmp	 SHORT $LN8@init
$LN7@init:

; 811  :                 WaitForInputIdle(dynamic_cast<RGYPipeProcessWin *>(m_pProcess.get())->getProcessInfo().hProcess, INFINITE);

  008a9	8b f4		 mov	 esi, esp
  008ab	6a ff		 push	 -1
  008ad	6a 00		 push	 0
  008af	68 00 00 00 00	 push	 OFFSET ??_R0?AVRGYPipeProcessWin@@@8
  008b4	68 00 00 00 00	 push	 OFFSET ??_R0?AVRGYPipeProcess@@@8
  008b9	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  008bc	81 c1 9c 02 00
	00		 add	 ecx, 668		; 0000029cH
  008c2	e8 00 00 00 00	 call	 ?get@?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@QBEPAVRGYPipeProcess@@XZ ; std::unique_ptr<RGYPipeProcess,std::default_delete<RGYPipeProcess> >::get
  008c7	6a 00		 push	 0
  008c9	50		 push	 eax
  008ca	e8 00 00 00 00	 call	 ___RTDynamicCast
  008cf	83 c4 14	 add	 esp, 20			; 00000014H
  008d2	8b c8		 mov	 ecx, eax
  008d4	e8 00 00 00 00	 call	 ?getProcessInfo@RGYPipeProcessWin@@QAEABU_PROCESS_INFORMATION@@XZ ; RGYPipeProcessWin::getProcessInfo
  008d9	8b 08		 mov	 ecx, DWORD PTR [eax]
  008db	51		 push	 ecx
  008dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForInputIdle@8
  008e2	3b f4		 cmp	 esi, esp
  008e4	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN8@init:

; 812  : #endif
; 813  :             }
; 814  :         }

  008e9	c6 45 fc 10	 mov	 BYTE PTR __$EHRec$[ebp+8], 16 ; 00000010H
  008ed	8d 8d 80 f6 ff
	ff		 lea	 ecx, DWORD PTR _args$17[ebp]
  008f3	e8 00 00 00 00	 call	 ??1?$vector@PBDV?$allocator@PBD@std@@@std@@QAE@XZ ; std::vector<char const *,std::allocator<char const *> >::~vector<char const *,std::allocator<char const *> >
  008f8	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  008fc	8d 8d 98 f6 ff
	ff		 lea	 ecx, DWORD PTR _sInterval$18[ebp]
  00902	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN6@init:

; 815  :     }

  00907	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0090b	8d 8d 9c f7 ff
	ff		 lea	 ecx, DWORD PTR _sPythonPath$27[ebp]
  00911	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN4@init:

; 816  : 
; 817  :     //
; 818  :     m_nSelectCheck &= (~PERF_MONITOR_FRAME_IN);

  00916	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00919	8b 82 40 0b 00
	00		 mov	 eax, DWORD PTR [edx+2880]
  0091f	25 ff ff fe ff	 and	 eax, -65537		; fffeffffH
  00924	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00927	89 81 40 0b 00
	00		 mov	 DWORD PTR [ecx+2880], eax

; 819  : 
; 820  :     //
; 821  : #if !(defined(_WIN32) || defined(_WIN64))
; 822  :     m_nSelectCheck &= (~PERF_MONITOR_THREAD_MAIN);
; 823  :     m_nSelectCheck &= (~PERF_MONITOR_THREAD_ENC);
; 824  :     m_nSelectCheck &= (~PERF_MONITOR_THREAD_AUDP);
; 825  :     m_nSelectCheck &= (~PERF_MONITOR_THREAD_AUDE);
; 826  :     m_nSelectCheck &= (~PERF_MONITOR_THREAD_OUT);
; 827  :     m_nSelectCheck &= (~PERF_MONITOR_THREAD_IN);
; 828  :     m_nSelectCheck &= (~PERF_MONITOR_GPU_CLOCK);
; 829  :     m_nSelectCheck &= (~PERF_MONITOR_GPU_LOAD);
; 830  :     m_nSelectCheck &= (~PERF_MONITOR_MFX_LOAD);
; 831  : #endif //#if defined(_WIN32) || defined(_WIN64)
; 832  : 
; 833  : #if ENCODER_QSV
; 834  :     m_nSelectCheck &= (~PERF_MONITOR_VED_LOAD);

  0092d	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00930	8b 82 40 0b 00
	00		 mov	 eax, DWORD PTR [edx+2880]
  00936	25 ff ff ff f7	 and	 eax, -134217729		; f7ffffffH
  0093b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0093e	89 81 40 0b 00
	00		 mov	 DWORD PTR [ecx+2880], eax

; 835  :     m_nSelectCheck &= (~PERF_MONITOR_VEE_LOAD);

  00944	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00947	8b 82 40 0b 00
	00		 mov	 eax, DWORD PTR [edx+2880]
  0094d	25 ff ff ff fb	 and	 eax, -67108865		; fbffffffH
  00952	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00955	89 81 40 0b 00
	00		 mov	 DWORD PTR [ecx+2880], eax

; 836  :     m_nSelectCheck &= (~PERF_MONITOR_VE_CLOCK);

  0095b	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0095e	8b 82 40 0b 00
	00		 mov	 eax, DWORD PTR [edx+2880]
  00964	25 ff ff ff fd	 and	 eax, -33554433		; fdffffffH
  00969	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0096c	89 81 40 0b 00
	00		 mov	 DWORD PTR [ecx+2880], eax

; 837  : #endif
; 838  : #if ENCODER_NVENC
; 839  :     m_nSelectCheck &= (~PERF_MONITOR_MFX_LOAD);
; 840  :     //
; 841  :     m_nSelectCheck &= (~PERF_MONITOR_VED_LOAD);
; 842  : #endif
; 843  : 
; 844  :     m_nSelectOutputLog &= m_nSelectCheck;

  00972	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00975	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00978	8b 8a 44 0b 00
	00		 mov	 ecx, DWORD PTR [edx+2884]
  0097e	23 88 40 0b 00
	00		 and	 ecx, DWORD PTR [eax+2880]
  00984	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00987	89 8a 44 0b 00
	00		 mov	 DWORD PTR [edx+2884], ecx

; 845  :     m_nSelectOutputPlot &= m_nSelectCheck;

  0098d	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00990	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00993	8b 90 48 0b 00
	00		 mov	 edx, DWORD PTR [eax+2888]
  00999	23 91 40 0b 00
	00		 and	 edx, DWORD PTR [ecx+2880]
  0099f	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  009a2	89 90 48 0b 00
	00		 mov	 DWORD PTR [eax+2888], edx

; 846  : 
; 847  :     pRGYLog->write(RGY_LOG_DEBUG, _T("Performace Monitor: %s\n"), CPerfMonitor::SelectedCounters(m_nSelectOutputLog).c_str());

  009a8	8d 4d 38	 lea	 ecx, DWORD PTR _pRGYLog$[ebp]
  009ab	e8 00 00 00 00	 call	 ??$?CVRGYLog@@$0A@@?$shared_ptr@VRGYLog@@@std@@QBEPAVRGYLog@@XZ ; std::shared_ptr<RGYLog>::operator-><RGYLog,0>
  009b0	89 85 8c f5 ff
	ff		 mov	 DWORD PTR tv441[ebp], eax
  009b6	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  009b9	8b 91 44 0b 00
	00		 mov	 edx, DWORD PTR [ecx+2884]
  009bf	52		 push	 edx
  009c0	8d 85 60 f6 ff
	ff		 lea	 eax, DWORD PTR $T16[ebp]
  009c6	50		 push	 eax
  009c7	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  009ca	e8 00 00 00 00	 call	 ?SelectedCounters@CPerfMonitor@@IAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; CPerfMonitor::SelectedCounters
  009cf	89 85 88 f5 ff
	ff		 mov	 DWORD PTR tv318[ebp], eax
  009d5	8b 8d 88 f5 ff
	ff		 mov	 ecx, DWORD PTR tv318[ebp]
  009db	89 8d 84 f5 ff
	ff		 mov	 DWORD PTR tv530[ebp], ecx
  009e1	c6 45 fc 12	 mov	 BYTE PTR __$EHRec$[ebp+8], 18 ; 00000012H
  009e5	8b 8d 84 f5 ff
	ff		 mov	 ecx, DWORD PTR tv530[ebp]
  009eb	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  009f0	8b f4		 mov	 esi, esp
  009f2	50		 push	 eax
  009f3	68 00 00 00 00	 push	 OFFSET $SG118999
  009f8	6a fe		 push	 -2			; fffffffeH
  009fa	8b 95 8c f5 ff
	ff		 mov	 edx, DWORD PTR tv441[ebp]
  00a00	52		 push	 edx
  00a01	8b 85 8c f5 ff
	ff		 mov	 eax, DWORD PTR tv441[ebp]
  00a07	8b 08		 mov	 ecx, DWORD PTR [eax]
  00a09	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00a0c	ff d2		 call	 edx
  00a0e	83 c4 10	 add	 esp, 16			; 00000010H
  00a11	3b f4		 cmp	 esi, esp
  00a13	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00a18	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00a1c	8d 8d 60 f6 ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp]
  00a22	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 848  :     pRGYLog->write(RGY_LOG_DEBUG, _T("Performace Plot   : %s\n"), CPerfMonitor::SelectedCounters(m_nSelectOutputPlot).c_str());

  00a27	8d 4d 38	 lea	 ecx, DWORD PTR _pRGYLog$[ebp]
  00a2a	e8 00 00 00 00	 call	 ??$?CVRGYLog@@$0A@@?$shared_ptr@VRGYLog@@@std@@QBEPAVRGYLog@@XZ ; std::shared_ptr<RGYLog>::operator-><RGYLog,0>
  00a2f	89 85 80 f5 ff
	ff		 mov	 DWORD PTR tv459[ebp], eax
  00a35	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00a38	8b 88 48 0b 00
	00		 mov	 ecx, DWORD PTR [eax+2888]
  00a3e	51		 push	 ecx
  00a3f	8d 95 44 f6 ff
	ff		 lea	 edx, DWORD PTR $T15[ebp]
  00a45	52		 push	 edx
  00a46	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00a49	e8 00 00 00 00	 call	 ?SelectedCounters@CPerfMonitor@@IAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; CPerfMonitor::SelectedCounters
  00a4e	89 85 7c f5 ff
	ff		 mov	 DWORD PTR tv312[ebp], eax
  00a54	8b 85 7c f5 ff
	ff		 mov	 eax, DWORD PTR tv312[ebp]
  00a5a	89 85 78 f5 ff
	ff		 mov	 DWORD PTR tv532[ebp], eax
  00a60	c6 45 fc 13	 mov	 BYTE PTR __$EHRec$[ebp+8], 19 ; 00000013H
  00a64	8b 8d 78 f5 ff
	ff		 mov	 ecx, DWORD PTR tv532[ebp]
  00a6a	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  00a6f	8b f4		 mov	 esi, esp
  00a71	50		 push	 eax
  00a72	68 00 00 00 00	 push	 OFFSET $SG119000
  00a77	6a fe		 push	 -2			; fffffffeH
  00a79	8b 8d 80 f5 ff
	ff		 mov	 ecx, DWORD PTR tv459[ebp]
  00a7f	51		 push	 ecx
  00a80	8b 95 80 f5 ff
	ff		 mov	 edx, DWORD PTR tv459[ebp]
  00a86	8b 02		 mov	 eax, DWORD PTR [edx]
  00a88	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00a8b	ff d1		 call	 ecx
  00a8d	83 c4 10	 add	 esp, 16			; 00000010H
  00a90	3b f4		 cmp	 esi, esp
  00a92	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00a97	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00a9b	8d 8d 44 f6 ff
	ff		 lea	 ecx, DWORD PTR $T15[ebp]
  00aa1	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 849  : 
; 850  :     write_header(m_fpLog.get(),   m_nSelectOutputLog);

  00aa6	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00aa9	8b 82 44 0b 00
	00		 mov	 eax, DWORD PTR [edx+2884]
  00aaf	50		 push	 eax
  00ab0	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00ab3	81 c1 3c 0b 00
	00		 add	 ecx, 2876		; 00000b3cH
  00ab9	e8 00 00 00 00	 call	 ?get@?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@QBEPAU_iobuf@@XZ ; std::unique_ptr<_iobuf,fp_deleter>::get
  00abe	50		 push	 eax
  00abf	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00ac2	e8 00 00 00 00	 call	 ?write_header@CPerfMonitor@@IAEXPAU_iobuf@@H@Z ; CPerfMonitor::write_header

; 851  :     write_header(m_pipes.f_stdin, m_nSelectOutputPlot);

  00ac7	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00aca	8b 91 48 0b 00
	00		 mov	 edx, DWORD PTR [ecx+2888]
  00ad0	52		 push	 edx
  00ad1	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00ad4	8b 88 d0 02 00
	00		 mov	 ecx, DWORD PTR [eax+720]
  00ada	51		 push	 ecx
  00adb	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00ade	e8 00 00 00 00	 call	 ?write_header@CPerfMonitor@@IAEXPAU_iobuf@@H@Z ; CPerfMonitor::write_header

; 852  : 
; 853  :     m_thCheck = std::thread(loader, this);

  00ae3	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00ae6	89 95 10 f6 ff
	ff		 mov	 DWORD PTR $T3[ebp], edx
  00aec	8d 85 10 f6 ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  00af2	50		 push	 eax
  00af3	68 00 00 00 00	 push	 OFFSET ?loader@CPerfMonitor@@KAXPAX@Z ; CPerfMonitor::loader
  00af8	8d 8d 14 f6 ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  00afe	e8 00 00 00 00	 call	 ??$?0A6AXPAX@ZPAVCPerfMonitor@@X@thread@std@@QAE@A6AXPAX@Z$$QAPAVCPerfMonitor@@@Z ; std::thread::thread<void (__cdecl&)(void *),CPerfMonitor *,void>
  00b03	89 85 74 f5 ff
	ff		 mov	 DWORD PTR tv548[ebp], eax
  00b09	8b 8d 74 f5 ff
	ff		 mov	 ecx, DWORD PTR tv548[ebp]
  00b0f	89 8d 70 f5 ff
	ff		 mov	 DWORD PTR tv534[ebp], ecx
  00b15	c6 45 fc 14	 mov	 BYTE PTR __$EHRec$[ebp+8], 20 ; 00000014H
  00b19	8b 95 70 f5 ff
	ff		 mov	 edx, DWORD PTR tv534[ebp]
  00b1f	52		 push	 edx
  00b20	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00b23	81 c1 90 02 00
	00		 add	 ecx, 656		; 00000290H
  00b29	e8 00 00 00 00	 call	 ??4thread@std@@QAEAAV01@$$QAV01@@Z ; std::thread::operator=
  00b2e	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00b32	8d 8d 14 f6 ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  00b38	e8 00 00 00 00	 call	 ??1thread@std@@QAE@XZ	; std::thread::~thread

; 854  :     return 0;

  00b3d	c7 85 0c f6 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], 0
  00b47	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00b4b	8d 4d 08	 lea	 ecx, DWORD PTR _filename$[ebp]
  00b4e	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00b53	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00b57	8d 4d 34	 lea	 ecx, DWORD PTR _thMainThread$[ebp]
  00b5a	e8 00 00 00 00	 call	 ??1?$unique_ptr@XUhandle_deleter@@@std@@QAE@XZ ; std::unique_ptr<void,handle_deleter>::~unique_ptr<void,handle_deleter>
  00b5f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00b66	8d 4d 38	 lea	 ecx, DWORD PTR _pRGYLog$[ebp]
  00b69	e8 00 00 00 00	 call	 ??1?$shared_ptr@VRGYLog@@@std@@QAE@XZ ; std::shared_ptr<RGYLog>::~shared_ptr<RGYLog>
  00b6e	8b 85 0c f6 ff
	ff		 mov	 eax, DWORD PTR $T2[ebp]
$LN1@init:

; 855  : }

  00b74	52		 push	 edx
  00b75	8b cd		 mov	 ecx, ebp
  00b77	50		 push	 eax
  00b78	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN42@init
  00b7e	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00b83	58		 pop	 eax
  00b84	5a		 pop	 edx
  00b85	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00b88	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00b8f	59		 pop	 ecx
  00b90	5f		 pop	 edi
  00b91	5e		 pop	 esi
  00b92	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00b95	33 cd		 xor	 ecx, ebp
  00b97	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00b9c	81 c4 90 0a 00
	00		 add	 esp, 2704		; 00000a90H
  00ba2	3b ec		 cmp	 ebp, esp
  00ba4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00ba9	8b e5		 mov	 esp, ebp
  00bab	5d		 pop	 ebp
  00bac	c2 3c 00	 ret	 60			; 0000003cH
  00baf	90		 npad	 1
$LN42@init:
  00bb0	05 00 00 00	 DD	 5
  00bb4	00 00 00 00	 DD	 $LN41@init
$LN41@init:
  00bb8	e8 fb ff ff	 DD	 -1048			; fffffbe8H
  00bbc	00 04 00 00	 DD	 1024			; 00000400H
  00bc0	00 00 00 00	 DD	 $LN35@init
  00bc4	e0 f7 ff ff	 DD	 -2080			; fffff7e0H
  00bc8	00 04 00 00	 DD	 1024			; 00000400H
  00bcc	00 00 00 00	 DD	 $LN36@init
  00bd0	9c f7 ff ff	 DD	 -2148			; fffff79cH
  00bd4	1c 00 00 00	 DD	 28			; 0000001cH
  00bd8	00 00 00 00	 DD	 $LN37@init
  00bdc	98 f6 ff ff	 DD	 -2408			; fffff698H
  00be0	1c 00 00 00	 DD	 28			; 0000001cH
  00be4	00 00 00 00	 DD	 $LN38@init
  00be8	80 f6 ff ff	 DD	 -2432			; fffff680H
  00bec	10 00 00 00	 DD	 16			; 00000010H
  00bf0	00 00 00 00	 DD	 $LN39@init
$LN39@init:
  00bf4	61		 DB	 97			; 00000061H
  00bf5	72		 DB	 114			; 00000072H
  00bf6	67		 DB	 103			; 00000067H
  00bf7	73		 DB	 115			; 00000073H
  00bf8	00		 DB	 0
$LN38@init:
  00bf9	73		 DB	 115			; 00000073H
  00bfa	49		 DB	 73			; 00000049H
  00bfb	6e		 DB	 110			; 0000006eH
  00bfc	74		 DB	 116			; 00000074H
  00bfd	65		 DB	 101			; 00000065H
  00bfe	72		 DB	 114			; 00000072H
  00bff	76		 DB	 118			; 00000076H
  00c00	61		 DB	 97			; 00000061H
  00c01	6c		 DB	 108			; 0000006cH
  00c02	00		 DB	 0
$LN37@init:
  00c03	73		 DB	 115			; 00000073H
  00c04	50		 DB	 80			; 00000050H
  00c05	79		 DB	 121			; 00000079H
  00c06	74		 DB	 116			; 00000074H
  00c07	68		 DB	 104			; 00000068H
  00c08	6f		 DB	 111			; 0000006fH
  00c09	6e		 DB	 110			; 0000006eH
  00c0a	50		 DB	 80			; 00000050H
  00c0b	61		 DB	 97			; 00000061H
  00c0c	74		 DB	 116			; 00000074H
  00c0d	68		 DB	 104			; 00000068H
  00c0e	00		 DB	 0
$LN36@init:
  00c0f	74		 DB	 116			; 00000074H
  00c10	65		 DB	 101			; 00000065H
  00c11	6d		 DB	 109			; 0000006dH
  00c12	70		 DB	 112			; 00000070H
  00c13	50		 DB	 80			; 00000050H
  00c14	61		 DB	 97			; 00000061H
  00c15	74		 DB	 116			; 00000074H
  00c16	68		 DB	 104			; 00000068H
  00c17	00		 DB	 0
$LN35@init:
  00c18	74		 DB	 116			; 00000074H
  00c19	65		 DB	 101			; 00000065H
  00c1a	6d		 DB	 109			; 0000006dH
  00c1b	70		 DB	 112			; 00000070H
  00c1c	44		 DB	 68			; 00000044H
  00c1d	69		 DB	 105			; 00000069H
  00c1e	72		 DB	 114			; 00000072H
  00c1f	00		 DB	 0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?init@CPerfMonitor@@QAEHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDHHHV?$unique_ptr@XUhandle_deleter@@@3@V?$shared_ptr@VRGYLog@@@3@PAUCPerfMonitorPrm@@@Z$0:
  00000	8d 4d 38	 lea	 ecx, DWORD PTR _pRGYLog$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VRGYLog@@@std@@QAE@XZ ; std::shared_ptr<RGYLog>::~shared_ptr<RGYLog>
__unwindfunclet$?init@CPerfMonitor@@QAEHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDHHHV?$unique_ptr@XUhandle_deleter@@@3@V?$shared_ptr@VRGYLog@@@3@PAUCPerfMonitorPrm@@@Z$1:
  00008	8d 4d 34	 lea	 ecx, DWORD PTR _thMainThread$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$unique_ptr@XUhandle_deleter@@@std@@QAE@XZ ; std::unique_ptr<void,handle_deleter>::~unique_ptr<void,handle_deleter>
__unwindfunclet$?init@CPerfMonitor@@QAEHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDHHHV?$unique_ptr@XUhandle_deleter@@@3@V?$shared_ptr@VRGYLog@@@3@PAUCPerfMonitorPrm@@@Z$2:
  00010	8d 4d 08	 lea	 ecx, DWORD PTR _filename$[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?init@CPerfMonitor@@QAEHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDHHHV?$unique_ptr@XUhandle_deleter@@@3@V?$shared_ptr@VRGYLog@@@3@PAUCPerfMonitorPrm@@@Z$3:
  00018	8d 8d 40 f6 ff
	ff		 lea	 ecx, DWORD PTR $T14[ebp]
  0001e	e9 00 00 00 00	 jmp	 ??1?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@QAE@XZ ; std::unique_ptr<_iobuf,fp_deleter>::~unique_ptr<_iobuf,fp_deleter>
__unwindfunclet$?init@CPerfMonitor@@QAEHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDHHHV?$unique_ptr@XUhandle_deleter@@@3@V?$shared_ptr@VRGYLog@@@3@PAUCPerfMonitorPrm@@@Z$4:
  00023	6a 18		 push	 24			; 00000018H
  00025	8b 85 30 f6 ff
	ff		 mov	 eax, DWORD PTR $T10[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00031	83 c4 08	 add	 esp, 8
  00034	c3		 ret	 0
__unwindfunclet$?init@CPerfMonitor@@QAEHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDHHHV?$unique_ptr@XUhandle_deleter@@@3@V?$shared_ptr@VRGYLog@@@3@PAUCPerfMonitorPrm@@@Z$5:
  00035	8d 8d 38 f6 ff
	ff		 lea	 ecx, DWORD PTR $T12[ebp]
  0003b	e9 00 00 00 00	 jmp	 ??1?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@QAE@XZ ; std::unique_ptr<RGYPipeProcess,std::default_delete<RGYPipeProcess> >::~unique_ptr<RGYPipeProcess,std::default_delete<RGYPipeProcess> >
__unwindfunclet$?init@CPerfMonitor@@QAEHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDHHHV?$unique_ptr@XUhandle_deleter@@@3@V?$shared_ptr@VRGYLog@@@3@PAUCPerfMonitorPrm@@@Z$6:
  00040	8d 8d c0 f7 ff
	ff		 lea	 ecx, DWORD PTR $T29[ebp]
  00046	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?init@CPerfMonitor@@QAEHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDHHHV?$unique_ptr@XUhandle_deleter@@@3@V?$shared_ptr@VRGYLog@@@3@PAUCPerfMonitorPrm@@@Z$7:
  0004b	8d 8d 9c f7 ff
	ff		 lea	 ecx, DWORD PTR _sPythonPath$27[ebp]
  00051	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?init@CPerfMonitor@@QAEHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDHHHV?$unique_ptr@XUhandle_deleter@@@3@V?$shared_ptr@VRGYLog@@@3@PAUCPerfMonitorPrm@@@Z$8:
  00056	8d 8d 44 f7 ff
	ff		 lea	 ecx, DWORD PTR $T24[ebp]
  0005c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?init@CPerfMonitor@@QAEHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDHHHV?$unique_ptr@XUhandle_deleter@@@3@V?$shared_ptr@VRGYLog@@@3@PAUCPerfMonitorPrm@@@Z$9:
  00061	8d 8d 7c f7 ff
	ff		 lea	 ecx, DWORD PTR $T26[ebp]
  00067	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?init@CPerfMonitor@@QAEHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDHHHV?$unique_ptr@XUhandle_deleter@@@3@V?$shared_ptr@VRGYLog@@@3@PAUCPerfMonitorPrm@@@Z$10:
  0006c	8d 8d 60 f7 ff
	ff		 lea	 ecx, DWORD PTR $T25[ebp]
  00072	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?init@CPerfMonitor@@QAEHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDHHHV?$unique_ptr@XUhandle_deleter@@@3@V?$shared_ptr@VRGYLog@@@3@PAUCPerfMonitorPrm@@@Z$11:
  00077	8d 8d 28 f7 ff
	ff		 lea	 ecx, DWORD PTR $T23[ebp]
  0007d	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?init@CPerfMonitor@@QAEHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDHHHV?$unique_ptr@XUhandle_deleter@@@3@V?$shared_ptr@VRGYLog@@@3@PAUCPerfMonitorPrm@@@Z$12:
  00082	8d 8d d4 f6 ff
	ff		 lea	 ecx, DWORD PTR $T20[ebp]
  00088	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?init@CPerfMonitor@@QAEHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDHHHV?$unique_ptr@XUhandle_deleter@@@3@V?$shared_ptr@VRGYLog@@@3@PAUCPerfMonitorPrm@@@Z$13:
  0008d	8d 8d 0c f7 ff
	ff		 lea	 ecx, DWORD PTR $T22[ebp]
  00093	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?init@CPerfMonitor@@QAEHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDHHHV?$unique_ptr@XUhandle_deleter@@@3@V?$shared_ptr@VRGYLog@@@3@PAUCPerfMonitorPrm@@@Z$14:
  00098	8d 8d f0 f6 ff
	ff		 lea	 ecx, DWORD PTR $T21[ebp]
  0009e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?init@CPerfMonitor@@QAEHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDHHHV?$unique_ptr@XUhandle_deleter@@@3@V?$shared_ptr@VRGYLog@@@3@PAUCPerfMonitorPrm@@@Z$15:
  000a3	8d 8d b8 f6 ff
	ff		 lea	 ecx, DWORD PTR $T19[ebp]
  000a9	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?init@CPerfMonitor@@QAEHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDHHHV?$unique_ptr@XUhandle_deleter@@@3@V?$shared_ptr@VRGYLog@@@3@PAUCPerfMonitorPrm@@@Z$16:
  000ae	8d 8d 98 f6 ff
	ff		 lea	 ecx, DWORD PTR _sInterval$18[ebp]
  000b4	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?init@CPerfMonitor@@QAEHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDHHHV?$unique_ptr@XUhandle_deleter@@@3@V?$shared_ptr@VRGYLog@@@3@PAUCPerfMonitorPrm@@@Z$17:
  000b9	8d 8d 80 f6 ff
	ff		 lea	 ecx, DWORD PTR _args$17[ebp]
  000bf	e9 00 00 00 00	 jmp	 ??1?$vector@PBDV?$allocator@PBD@std@@@std@@QAE@XZ ; std::vector<char const *,std::allocator<char const *> >::~vector<char const *,std::allocator<char const *> >
__unwindfunclet$?init@CPerfMonitor@@QAEHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDHHHV?$unique_ptr@XUhandle_deleter@@@3@V?$shared_ptr@VRGYLog@@@3@PAUCPerfMonitorPrm@@@Z$18:
  000c4	8d 8d 60 f6 ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp]
  000ca	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?init@CPerfMonitor@@QAEHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDHHHV?$unique_ptr@XUhandle_deleter@@@3@V?$shared_ptr@VRGYLog@@@3@PAUCPerfMonitorPrm@@@Z$19:
  000cf	8d 8d 44 f6 ff
	ff		 lea	 ecx, DWORD PTR $T15[ebp]
  000d5	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?init@CPerfMonitor@@QAEHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDHHHV?$unique_ptr@XUhandle_deleter@@@3@V?$shared_ptr@VRGYLog@@@3@PAUCPerfMonitorPrm@@@Z$20:
  000da	8d 8d 14 f6 ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  000e0	e9 00 00 00 00	 jmp	 ??1thread@std@@QAE@XZ	; std::thread::~thread
__ehhandler$?init@CPerfMonitor@@QAEHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDHHHV?$unique_ptr@XUhandle_deleter@@@3@V?$shared_ptr@VRGYLog@@@3@PAUCPerfMonitorPrm@@@Z:
  000e5	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  000e9	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  000ec	8b 8a 70 f5 ff
	ff		 mov	 ecx, DWORD PTR [edx-2704]
  000f2	33 c8		 xor	 ecx, eax
  000f4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f9	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  000fc	33 c8		 xor	 ecx, eax
  000fe	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00103	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?init@CPerfMonitor@@QAEHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDHHHV?$unique_ptr@XUhandle_deleter@@@3@V?$shared_ptr@VRGYLog@@@3@PAUCPerfMonitorPrm@@@Z
  00108	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?init@CPerfMonitor@@QAEHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDHHHV?$unique_ptr@XUhandle_deleter@@@3@V?$shared_ptr@VRGYLog@@@3@PAUCPerfMonitorPrm@@@Z ENDP ; CPerfMonitor::init
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\rgy_perf_monitor.cpp
_TEXT	SEGMENT
_cpu_info$ = -136					; size = 112
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
??0CPerfMonitor@@QAE@XZ PROC				; CPerfMonitor::CPerfMonitor
; _this$ = ecx

; 469  : CPerfMonitor::CPerfMonitor() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CPerfMonitor@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00017	57		 push	 edi
  00018	51		 push	 ecx
  00019	8d bd 74 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-140]
  0001f	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00024	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00029	f3 ab		 rep stosd
  0002b	59		 pop	 ecx
  0002c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00031	33 c5		 xor	 eax, ebp
  00033	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00036	50		 push	 eax
  00037	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0003a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00040	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00043	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	83 c1 04	 add	 ecx, 4
  00049	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0004e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00055	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	81 c1 90 02 00
	00		 add	 ecx, 656		; 00000290H
  0005e	e8 00 00 00 00	 call	 ??0thread@std@@QAE@XZ	; std::thread::thread
  00063	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00067	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	81 c1 98 02 00
	00		 add	 ecx, 664		; 00000298H
  00070	e8 00 00 00 00	 call	 ??$?0Uhandle_deleter@@$0A@@?$unique_ptr@XUhandle_deleter@@@std@@QAE@XZ ; std::unique_ptr<void,handle_deleter>::unique_ptr<void,handle_deleter><handle_deleter,0>
  00075	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00079	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0007c	81 c1 9c 02 00
	00		 add	 ecx, 668		; 0000029cH
  00082	e8 00 00 00 00	 call	 ??$?0U?$default_delete@VRGYPipeProcess@@@std@@$0A@@?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@QAE@XZ ; std::unique_ptr<RGYPipeProcess,std::default_delete<RGYPipeProcess> >::unique_ptr<RGYPipeProcess,std::default_delete<RGYPipeProcess> ><std::default_delete<RGYPipeProcess>,0>
  00087	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  0008b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0008e	81 c1 f0 0a 00
	00		 add	 ecx, 2800		; 00000af0H
  00094	e8 00 00 00 00	 call	 ??0?$shared_ptr@VEncodeStatus@@@std@@QAE@XZ ; std::shared_ptr<EncodeStatus>::shared_ptr<EncodeStatus>
  00099	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  0009d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000a0	81 c1 20 0b 00
	00		 add	 ecx, 2848		; 00000b20H
  000a6	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  000ab	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  000af	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000b2	81 c1 3c 0b 00
	00		 add	 ecx, 2876		; 00000b3cH
  000b8	e8 00 00 00 00	 call	 ??$?0Ufp_deleter@@$0A@@?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@QAE@XZ ; std::unique_ptr<_iobuf,fp_deleter>::unique_ptr<_iobuf,fp_deleter><fp_deleter,0>
  000bd	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  000c1	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000c4	81 c1 64 0b 00
	00		 add	 ecx, 2916		; 00000b64H
  000ca	e8 00 00 00 00	 call	 ??0?$shared_ptr@VRGYLog@@@std@@QAE@XZ ; std::shared_ptr<RGYLog>::shared_ptr<RGYLog>
  000cf	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7

; 470  :     memset(m_info, 0, sizeof(m_info));

  000d3	68 70 02 00 00	 push	 624			; 00000270H
  000d8	6a 00		 push	 0
  000da	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000dd	83 c0 20	 add	 eax, 32			; 00000020H
  000e0	50		 push	 eax
  000e1	e8 00 00 00 00	 call	 _memset
  000e6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 471  :     memset(&m_pipes, 0, sizeof(m_pipes));

  000e9	68 38 08 00 00	 push	 2104			; 00000838H
  000ee	6a 00		 push	 0
  000f0	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000f3	81 c1 a0 02 00
	00		 add	 ecx, 672		; 000002a0H
  000f9	51		 push	 ecx
  000fa	e8 00 00 00 00	 call	 _memset
  000ff	83 c4 0c	 add	 esp, 12			; 0000000cH

; 472  :     memset(&m_QueueInfo, 0, sizeof(m_QueueInfo));

  00102	6a 18		 push	 24			; 00000018H
  00104	6a 00		 push	 0
  00106	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00109	81 c2 4c 0b 00
	00		 add	 edx, 2892		; 00000b4cH
  0010f	52		 push	 edx
  00110	e8 00 00 00 00	 call	 _memset
  00115	83 c4 0c	 add	 esp, 12			; 0000000cH

; 473  : #if ENABLE_METRIC_FRAMEWORK
; 474  :     m_pManager = nullptr;
; 475  : #endif //#if ENABLE_METRIC_FRAMEWORK
; 476  : #if ENABLE_NVML
; 477  :     memset(&m_nvmlInfo, 0, sizeof(m_nvmlInfo));
; 478  : #endif
; 479  : #if ENABLE_GPUZ_INFO
; 480  :     memset(&m_GPUZInfo, 0, sizeof(m_GPUZInfo));

  00118	68 0c 0e 03 00	 push	 200204			; 00030e0cH
  0011d	6a 00		 push	 0
  0011f	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00122	05 6c 0b 00 00	 add	 eax, 2924		; 00000b6cH
  00127	50		 push	 eax
  00128	e8 00 00 00 00	 call	 _memset
  0012d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 481  : #endif //#if ENABLE_GPUZ_INFO
; 482  :     m_bGPUZInfoValid = false;

  00130	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00133	c6 81 78 19 03
	00 00		 mov	 BYTE PTR [ecx+203128], 0

; 483  : 
; 484  :     cpu_info_t cpu_info;
; 485  :     get_cpu_info(&cpu_info);

  0013a	8d 95 78 ff ff
	ff		 lea	 edx, DWORD PTR _cpu_info$[ebp]
  00140	52		 push	 edx
  00141	e8 00 00 00 00	 call	 ?get_cpu_info@@YA_NPAUcpu_info_t@@@Z ; get_cpu_info
  00146	83 c4 04	 add	 esp, 4

; 486  :     m_nLogicalCPU = cpu_info.logical_cores;

  00149	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0014c	8b 4d 80	 mov	 ecx, DWORD PTR _cpu_info$[ebp+8]
  0014f	89 88 ec 0a 00
	00		 mov	 DWORD PTR [eax+2796], ecx

; 487  :     m_thAudProcThread = NULL;

  00155	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00158	c7 82 e4 0a 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+2788], 0

; 488  :     m_thEncThread = NULL;

  00162	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00165	c7 80 d8 0a 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+2776], 0

; 489  :     m_thOutThread = NULL;

  0016f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00172	c7 81 e0 0a 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+2784], 0

; 490  : }

  0017c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00183	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00186	52		 push	 edx
  00187	8b cd		 mov	 ecx, ebp
  00189	50		 push	 eax
  0018a	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN14@CPerfMonit
  00190	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00195	58		 pop	 eax
  00196	5a		 pop	 edx
  00197	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0019a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001a1	59		 pop	 ecx
  001a2	5f		 pop	 edi
  001a3	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001a6	33 cd		 xor	 ecx, ebp
  001a8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001ad	81 c4 8c 00 00
	00		 add	 esp, 140		; 0000008cH
  001b3	3b ec		 cmp	 ebp, esp
  001b5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001ba	8b e5		 mov	 esp, ebp
  001bc	5d		 pop	 ebp
  001bd	c3		 ret	 0
  001be	66 90		 npad	 2
$LN14@CPerfMonit:
  001c0	01 00 00 00	 DD	 1
  001c4	00 00 00 00	 DD	 $LN13@CPerfMonit
$LN13@CPerfMonit:
  001c8	78 ff ff ff	 DD	 -136			; ffffff78H
  001cc	70 00 00 00	 DD	 112			; 00000070H
  001d0	00 00 00 00	 DD	 $LN11@CPerfMonit
$LN11@CPerfMonit:
  001d4	63		 DB	 99			; 00000063H
  001d5	70		 DB	 112			; 00000070H
  001d6	75		 DB	 117			; 00000075H
  001d7	5f		 DB	 95			; 0000005fH
  001d8	69		 DB	 105			; 00000069H
  001d9	6e		 DB	 110			; 0000006eH
  001da	66		 DB	 102			; 00000066H
  001db	6f		 DB	 111			; 0000006fH
  001dc	00		 DB	 0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0CPerfMonitor@@QAE@XZ$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0CPerfMonitor@@QAE@XZ$1:
  0000b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	81 c1 90 02 00
	00		 add	 ecx, 656		; 00000290H
  00014	e9 00 00 00 00	 jmp	 ??1thread@std@@QAE@XZ	; std::thread::~thread
__unwindfunclet$??0CPerfMonitor@@QAE@XZ$2:
  00019	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	81 c1 98 02 00
	00		 add	 ecx, 664		; 00000298H
  00022	e9 00 00 00 00	 jmp	 ??1?$unique_ptr@XUhandle_deleter@@@std@@QAE@XZ ; std::unique_ptr<void,handle_deleter>::~unique_ptr<void,handle_deleter>
__unwindfunclet$??0CPerfMonitor@@QAE@XZ$3:
  00027	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	81 c1 9c 02 00
	00		 add	 ecx, 668		; 0000029cH
  00030	e9 00 00 00 00	 jmp	 ??1?$unique_ptr@VRGYPipeProcess@@U?$default_delete@VRGYPipeProcess@@@std@@@std@@QAE@XZ ; std::unique_ptr<RGYPipeProcess,std::default_delete<RGYPipeProcess> >::~unique_ptr<RGYPipeProcess,std::default_delete<RGYPipeProcess> >
__unwindfunclet$??0CPerfMonitor@@QAE@XZ$4:
  00035	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	81 c1 f0 0a 00
	00		 add	 ecx, 2800		; 00000af0H
  0003e	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VEncodeStatus@@@std@@QAE@XZ ; std::shared_ptr<EncodeStatus>::~shared_ptr<EncodeStatus>
__unwindfunclet$??0CPerfMonitor@@QAE@XZ$5:
  00043	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	81 c1 20 0b 00
	00		 add	 ecx, 2848		; 00000b20H
  0004c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0CPerfMonitor@@QAE@XZ$6:
  00051	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	81 c1 3c 0b 00
	00		 add	 ecx, 2876		; 00000b3cH
  0005a	e9 00 00 00 00	 jmp	 ??1?$unique_ptr@U_iobuf@@Ufp_deleter@@@std@@QAE@XZ ; std::unique_ptr<_iobuf,fp_deleter>::~unique_ptr<_iobuf,fp_deleter>
__unwindfunclet$??0CPerfMonitor@@QAE@XZ$7:
  0005f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00062	81 c1 64 0b 00
	00		 add	 ecx, 2916		; 00000b64H
  00068	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VRGYLog@@@std@@QAE@XZ ; std::shared_ptr<RGYLog>::~shared_ptr<RGYLog>
__ehhandler$??0CPerfMonitor@@QAE@XZ:
  0006d	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00071	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00074	8b 8a 78 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-136]
  0007a	33 c8		 xor	 ecx, eax
  0007c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00081	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00084	33 c8		 xor	 ecx, eax
  00086	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0008b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CPerfMonitor@@QAE@XZ
  00090	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CPerfMonitor@@QAE@XZ ENDP				; CPerfMonitor::CPerfMonitor
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 4299 :     basic_string<_Elem, _Traits, _Alloc>&& _Right) { // return string + string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00020	33 c5		 xor	 eax, ebp
  00022	50		 push	 eax
  00023	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00026	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002c	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0

; 4300 :     if (_Right.size() <= _Left.capacity() - _Left.size() || _Right.capacity() - _Right.size() < _Left.size()) {

  00033	8b 4d 10	 mov	 ecx, DWORD PTR __Right$[ebp]
  00036	e8 00 00 00 00	 call	 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
  0003b	8b f0		 mov	 esi, eax
  0003d	8b 4d 0c	 mov	 ecx, DWORD PTR __Left$[ebp]
  00040	e8 00 00 00 00	 call	 ?capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::capacity
  00045	8b f8		 mov	 edi, eax
  00047	8b 4d 0c	 mov	 ecx, DWORD PTR __Left$[ebp]
  0004a	e8 00 00 00 00	 call	 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
  0004f	2b f8		 sub	 edi, eax
  00051	3b f7		 cmp	 esi, edi
  00053	76 20		 jbe	 SHORT $LN4@operator
  00055	8b 4d 10	 mov	 ecx, DWORD PTR __Right$[ebp]
  00058	e8 00 00 00 00	 call	 ?capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::capacity
  0005d	8b f0		 mov	 esi, eax
  0005f	8b 4d 10	 mov	 ecx, DWORD PTR __Right$[ebp]
  00062	e8 00 00 00 00	 call	 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
  00067	2b f0		 sub	 esi, eax
  00069	8b 4d 0c	 mov	 ecx, DWORD PTR __Left$[ebp]
  0006c	e8 00 00 00 00	 call	 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
  00071	3b f0		 cmp	 esi, eax
  00073	73 35		 jae	 SHORT $LN2@operator
$LN4@operator:

; 4301 :         return _STD move(_Left.append(_Right));

  00075	8b 45 10	 mov	 eax, DWORD PTR __Right$[ebp]
  00078	50		 push	 eax
  00079	8b 4d 0c	 mov	 ecx, DWORD PTR __Left$[ebp]
  0007c	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  00081	50		 push	 eax
  00082	e8 00 00 00 00	 call	 ??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
  00087	83 c4 04	 add	 esp, 4
  0008a	50		 push	 eax
  0008b	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0008e	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00093	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0009a	8b 4d f0	 mov	 ecx, DWORD PTR $T2[ebp]
  0009d	83 c9 01	 or	 ecx, 1
  000a0	89 4d f0	 mov	 DWORD PTR $T2[ebp], ecx
  000a3	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000a6	eb 35		 jmp	 SHORT $LN1@operator

; 4302 :     } else {

  000a8	eb 33		 jmp	 SHORT $LN1@operator
$LN2@operator:

; 4303 :         return _STD move(_Right.insert(0, _Left));

  000aa	8b 55 0c	 mov	 edx, DWORD PTR __Left$[ebp]
  000ad	52		 push	 edx
  000ae	6a 00		 push	 0
  000b0	8b 4d 10	 mov	 ecx, DWORD PTR __Right$[ebp]
  000b3	e8 00 00 00 00	 call	 ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
  000b8	50		 push	 eax
  000b9	e8 00 00 00 00	 call	 ??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
  000be	83 c4 04	 add	 esp, 4
  000c1	50		 push	 eax
  000c2	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  000c5	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  000ca	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000d1	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  000d4	83 c8 01	 or	 eax, 1
  000d7	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
  000da	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN1@operator:

; 4304 :     }
; 4305 : }

  000dd	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000e0	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000e7	59		 pop	 ecx
  000e8	5f		 pop	 edi
  000e9	5e		 pop	 esi
  000ea	83 c4 10	 add	 esp, 16			; 00000010H
  000ed	3b ec		 cmp	 ebp, esp
  000ef	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f4	8b e5		 mov	 esp, ebp
  000f6	5d		 pop	 ebp
  000f7	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0c 00 00
	00		 je	 $LN7@operator
  0000c	83 65 f0 fe	 and	 DWORD PTR $T2[ebp], -2	; fffffffeH
  00010	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN7@operator:
  00018	c3		 ret	 0
__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z:
  00019	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00020	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@ABV10@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@ABV10@@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 4293 :     const basic_string<_Elem, _Traits, _Alloc>& _Right) { // return string + string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@ABV10@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0

; 4294 :     return _STD move(_Left.append(_Right));

  00031	8b 45 10	 mov	 eax, DWORD PTR __Right$[ebp]
  00034	50		 push	 eax
  00035	8b 4d 0c	 mov	 ecx, DWORD PTR __Left$[ebp]
  00038	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 ??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
  00043	83 c4 04	 add	 esp, 4
  00046	50		 push	 eax
  00047	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0004a	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0004f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00056	8b 4d f0	 mov	 ecx, DWORD PTR $T2[ebp]
  00059	83 c9 01	 or	 ecx, 1
  0005c	89 4d f0	 mov	 DWORD PTR $T2[ebp], ecx
  0005f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 4295 : }

  00062	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00065	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006c	59		 pop	 ecx
  0006d	83 c4 10	 add	 esp, 16			; 00000010H
  00070	3b ec		 cmp	 ebp, esp
  00072	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@ABV10@@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0c 00 00
	00		 je	 $LN4@operator
  0000c	83 65 f0 fe	 and	 DWORD PTR $T2[ebp], -2	; fffffffeH
  00010	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN4@operator:
  00018	c3		 ret	 0
__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@ABV10@@Z:
  00019	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00020	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@ABV10@@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@ABV10@@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\rgy_util.h
;	COMDAT ??__ECspColorprimList@@YAXXZ
text$di	SEGMENT
$T1 = -148						; size = 48
$T2 = -100						; size = 4
$T3 = -96						; size = 4
$T4 = -92						; size = 4
$T5 = -88						; size = 4
$T6 = -84						; size = 4
$T7 = -80						; size = 4
$T8 = -76						; size = 4
$T9 = -72						; size = 4
$T10 = -68						; size = 4
$T11 = -64						; size = 4
$T12 = -60						; size = 4
$T13 = -56						; size = 4
$T14 = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
??__ECspColorprimList@@YAXXZ PROC			; `dynamic initializer for 'CspColorprimList'', COMDAT

; 1187 : );

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 94 00 00
	00		 sub	 esp, 148		; 00000094H
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8d bd 6c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-148]
  00011	b9 25 00 00 00	 mov	 ecx, 37			; 00000025H
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1174 : static const auto CspColorprimList = make_array<CspColorprim>(

  00027	c7 45 c8 0d 00
	00 00		 mov	 DWORD PTR $T13[ebp], 13	; 0000000dH
  0002e	c7 45 c4 0c 00
	00 00		 mov	 DWORD PTR $T12[ebp], 12	; 0000000cH
  00035	c7 45 c0 0b 00
	00 00		 mov	 DWORD PTR $T11[ebp], 11	; 0000000bH
  0003c	c7 45 bc 0a 00
	00 00		 mov	 DWORD PTR $T10[ebp], 10	; 0000000aH
  00043	c7 45 b8 09 00
	00 00		 mov	 DWORD PTR $T9[ebp], 9
  0004a	c7 45 b4 08 00
	00 00		 mov	 DWORD PTR $T8[ebp], 8
  00051	c7 45 b0 07 00
	00 00		 mov	 DWORD PTR $T7[ebp], 7
  00058	c7 45 ac 06 00
	00 00		 mov	 DWORD PTR $T6[ebp], 6
  0005f	c7 45 a8 05 00
	00 00		 mov	 DWORD PTR $T5[ebp], 5
  00066	c7 45 a4 04 00
	00 00		 mov	 DWORD PTR $T4[ebp], 4
  0006d	c7 45 a0 02 00
	00 00		 mov	 DWORD PTR $T3[ebp], 2
  00074	c7 45 9c 01 00
	00 00		 mov	 DWORD PTR $T2[ebp], 1
  0007b	8d 45 c8	 lea	 eax, DWORD PTR $T13[ebp]
  0007e	50		 push	 eax
  0007f	8d 4d c4	 lea	 ecx, DWORD PTR $T12[ebp]
  00082	51		 push	 ecx
  00083	8d 55 c0	 lea	 edx, DWORD PTR $T11[ebp]
  00086	52		 push	 edx
  00087	8d 45 bc	 lea	 eax, DWORD PTR $T10[ebp]
  0008a	50		 push	 eax
  0008b	8d 4d b8	 lea	 ecx, DWORD PTR $T9[ebp]
  0008e	51		 push	 ecx
  0008f	8d 55 b4	 lea	 edx, DWORD PTR $T8[ebp]
  00092	52		 push	 edx
  00093	8d 45 b0	 lea	 eax, DWORD PTR $T7[ebp]
  00096	50		 push	 eax
  00097	8d 4d ac	 lea	 ecx, DWORD PTR $T6[ebp]
  0009a	51		 push	 ecx
  0009b	8d 55 a8	 lea	 edx, DWORD PTR $T5[ebp]
  0009e	52		 push	 edx
  0009f	8d 45 a4	 lea	 eax, DWORD PTR $T4[ebp]
  000a2	50		 push	 eax
  000a3	8d 4d a0	 lea	 ecx, DWORD PTR $T3[ebp]
  000a6	51		 push	 ecx
  000a7	8d 55 9c	 lea	 edx, DWORD PTR $T2[ebp]
  000aa	52		 push	 edx
  000ab	8d 85 6c ff ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  000b1	50		 push	 eax
  000b2	e8 00 00 00 00	 call	 ??$make_array@W4CspColorprim@@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@@@YA?AV?$array@W4CspColorprim@@$0M@@std@@$$QAW4CspColorprim@@00000000000@Z ; make_array<enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim>
  000b7	83 c4 34	 add	 esp, 52			; 00000034H
  000ba	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  000bf	8b f0		 mov	 esi, eax
  000c1	8d 7d cc	 lea	 edi, DWORD PTR $T14[ebp]
  000c4	f3 a5		 rep movsd
  000c6	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  000cb	8d 75 cc	 lea	 esi, DWORD PTR $T14[ebp]
  000ce	bf 00 00 00 00	 mov	 edi, OFFSET ?CspColorprimList@@3V?$array@W4CspColorprim@@$0M@@std@@B
  000d3	f3 a5		 rep movsd
  000d5	5f		 pop	 edi
  000d6	5e		 pop	 esi
  000d7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000da	33 cd		 xor	 ecx, ebp
  000dc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e1	81 c4 94 00 00
	00		 add	 esp, 148		; 00000094H
  000e7	3b ec		 cmp	 ebp, esp
  000e9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ee	8b e5		 mov	 esp, ebp
  000f0	5d		 pop	 ebp
  000f1	c3		 ret	 0
??__ECspColorprimList@@YAXXZ ENDP			; `dynamic initializer for 'CspColorprimList''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\rgy_util.h
;	COMDAT ??$make_array@W4CspColorprim@@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@@@YA?AV?$array@W4CspColorprim@@$0M@@std@@$$QAW4CspColorprim@@00000000000@Z
_TEXT	SEGMENT
$T1 = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
$T2 = 8							; size = 4
_<args_0>$ = 12						; size = 4
_<args_1>$ = 16						; size = 4
_<args_2>$ = 20						; size = 4
_<args_3>$ = 24						; size = 4
_<args_4>$ = 28						; size = 4
_<args_5>$ = 32						; size = 4
_<args_6>$ = 36						; size = 4
_<args_7>$ = 40						; size = 4
_<args_8>$ = 44						; size = 4
_<args_9>$ = 48						; size = 4
_<args_10>$ = 52					; size = 4
_<args_11>$ = 56					; size = 4
??$make_array@W4CspColorprim@@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@@@YA?AV?$array@W4CspColorprim@@$0M@@std@@$$QAW4CspColorprim@@00000000000@Z PROC ; make_array<enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim>, COMDAT

; 129  : constexpr std::array<T, sizeof...(Args)> make_array(Args&&... args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8d 7d cc	 lea	 edi, DWORD PTR [ebp-52]
  0000b	b9 0d 00 00 00	 mov	 ecx, 13			; 0000000dH
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 130  :     return std::array<T, sizeof...(Args)>{ static_cast<Args&&>(args)... };

  00021	8b 45 0c	 mov	 eax, DWORD PTR _<args_0>$[ebp]
  00024	8b 08		 mov	 ecx, DWORD PTR [eax]
  00026	89 4d cc	 mov	 DWORD PTR $T1[ebp], ecx
  00029	8b 55 10	 mov	 edx, DWORD PTR _<args_1>$[ebp]
  0002c	8b 02		 mov	 eax, DWORD PTR [edx]
  0002e	89 45 d0	 mov	 DWORD PTR $T1[ebp+4], eax
  00031	8b 4d 14	 mov	 ecx, DWORD PTR _<args_2>$[ebp]
  00034	8b 11		 mov	 edx, DWORD PTR [ecx]
  00036	89 55 d4	 mov	 DWORD PTR $T1[ebp+8], edx
  00039	8b 45 18	 mov	 eax, DWORD PTR _<args_3>$[ebp]
  0003c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003e	89 4d d8	 mov	 DWORD PTR $T1[ebp+12], ecx
  00041	8b 55 1c	 mov	 edx, DWORD PTR _<args_4>$[ebp]
  00044	8b 02		 mov	 eax, DWORD PTR [edx]
  00046	89 45 dc	 mov	 DWORD PTR $T1[ebp+16], eax
  00049	8b 4d 20	 mov	 ecx, DWORD PTR _<args_5>$[ebp]
  0004c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004e	89 55 e0	 mov	 DWORD PTR $T1[ebp+20], edx
  00051	8b 45 24	 mov	 eax, DWORD PTR _<args_6>$[ebp]
  00054	8b 08		 mov	 ecx, DWORD PTR [eax]
  00056	89 4d e4	 mov	 DWORD PTR $T1[ebp+24], ecx
  00059	8b 55 28	 mov	 edx, DWORD PTR _<args_7>$[ebp]
  0005c	8b 02		 mov	 eax, DWORD PTR [edx]
  0005e	89 45 e8	 mov	 DWORD PTR $T1[ebp+28], eax
  00061	8b 4d 2c	 mov	 ecx, DWORD PTR _<args_8>$[ebp]
  00064	8b 11		 mov	 edx, DWORD PTR [ecx]
  00066	89 55 ec	 mov	 DWORD PTR $T1[ebp+32], edx
  00069	8b 45 30	 mov	 eax, DWORD PTR _<args_9>$[ebp]
  0006c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006e	89 4d f0	 mov	 DWORD PTR $T1[ebp+36], ecx
  00071	8b 55 34	 mov	 edx, DWORD PTR _<args_10>$[ebp]
  00074	8b 02		 mov	 eax, DWORD PTR [edx]
  00076	89 45 f4	 mov	 DWORD PTR $T1[ebp+40], eax
  00079	8b 4d 38	 mov	 ecx, DWORD PTR _<args_11>$[ebp]
  0007c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0007e	89 55 f8	 mov	 DWORD PTR $T1[ebp+44], edx
  00081	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  00086	8d 75 cc	 lea	 esi, DWORD PTR $T1[ebp]
  00089	8b 7d 08	 mov	 edi, DWORD PTR $T2[ebp]
  0008c	f3 a5		 rep movsd
  0008e	8b 45 08	 mov	 eax, DWORD PTR $T2[ebp]

; 131  : }

  00091	5f		 pop	 edi
  00092	5e		 pop	 esi
  00093	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00096	33 cd		 xor	 ecx, ebp
  00098	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009d	8b e5		 mov	 esp, ebp
  0009f	5d		 pop	 ebp
  000a0	c3		 ret	 0
??$make_array@W4CspColorprim@@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@@@YA?AV?$array@W4CspColorprim@@$0M@@std@@$$QAW4CspColorprim@@00000000000@Z ENDP ; make_array<enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\rgy_util.h
;	COMDAT ??__ECspTransferList@@YAXXZ
text$di	SEGMENT
$T1 = -184						; size = 60
$T2 = -124						; size = 4
$T3 = -120						; size = 4
$T4 = -116						; size = 4
$T5 = -112						; size = 4
$T6 = -108						; size = 4
$T7 = -104						; size = 4
$T8 = -100						; size = 4
$T9 = -96						; size = 4
$T10 = -92						; size = 4
$T11 = -88						; size = 4
$T12 = -84						; size = 4
$T13 = -80						; size = 4
$T14 = -76						; size = 4
$T15 = -72						; size = 4
$T16 = -68						; size = 4
$T17 = -64						; size = 60
__$ArrayPad$ = -4					; size = 4
??__ECspTransferList@@YAXXZ PROC			; `dynamic initializer for 'CspTransferList'', COMDAT

; 1135 : );

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec b8 00 00
	00		 sub	 esp, 184		; 000000b8H
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8d bd 48 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-184]
  00011	b9 2e 00 00 00	 mov	 ecx, 46			; 0000002eH
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1119 : static const auto CspTransferList = make_array<CspTransfer>(

  00027	c7 45 bc 12 00
	00 00		 mov	 DWORD PTR $T16[ebp], 18	; 00000012H
  0002e	c7 45 b8 10 00
	00 00		 mov	 DWORD PTR $T15[ebp], 16	; 00000010H
  00035	c7 45 b4 0f 00
	00 00		 mov	 DWORD PTR $T14[ebp], 15	; 0000000fH
  0003c	c7 45 b0 0e 00
	00 00		 mov	 DWORD PTR $T13[ebp], 14	; 0000000eH
  00043	c7 45 ac 0d 00
	00 00		 mov	 DWORD PTR $T12[ebp], 13	; 0000000dH
  0004a	c7 45 a8 0b 00
	00 00		 mov	 DWORD PTR $T11[ebp], 11	; 0000000bH
  00051	c7 45 a4 0a 00
	00 00		 mov	 DWORD PTR $T10[ebp], 10	; 0000000aH
  00058	c7 45 a0 09 00
	00 00		 mov	 DWORD PTR $T9[ebp], 9
  0005f	c7 45 9c 08 00
	00 00		 mov	 DWORD PTR $T8[ebp], 8
  00066	c7 45 98 07 00
	00 00		 mov	 DWORD PTR $T7[ebp], 7
  0006d	c7 45 94 06 00
	00 00		 mov	 DWORD PTR $T6[ebp], 6
  00074	c7 45 90 05 00
	00 00		 mov	 DWORD PTR $T5[ebp], 5
  0007b	c7 45 8c 04 00
	00 00		 mov	 DWORD PTR $T4[ebp], 4
  00082	c7 45 88 02 00
	00 00		 mov	 DWORD PTR $T3[ebp], 2
  00089	c7 45 84 01 00
	00 00		 mov	 DWORD PTR $T2[ebp], 1
  00090	8d 45 bc	 lea	 eax, DWORD PTR $T16[ebp]
  00093	50		 push	 eax
  00094	8d 4d b8	 lea	 ecx, DWORD PTR $T15[ebp]
  00097	51		 push	 ecx
  00098	8d 55 b4	 lea	 edx, DWORD PTR $T14[ebp]
  0009b	52		 push	 edx
  0009c	8d 45 b0	 lea	 eax, DWORD PTR $T13[ebp]
  0009f	50		 push	 eax
  000a0	8d 4d ac	 lea	 ecx, DWORD PTR $T12[ebp]
  000a3	51		 push	 ecx
  000a4	8d 55 a8	 lea	 edx, DWORD PTR $T11[ebp]
  000a7	52		 push	 edx
  000a8	8d 45 a4	 lea	 eax, DWORD PTR $T10[ebp]
  000ab	50		 push	 eax
  000ac	8d 4d a0	 lea	 ecx, DWORD PTR $T9[ebp]
  000af	51		 push	 ecx
  000b0	8d 55 9c	 lea	 edx, DWORD PTR $T8[ebp]
  000b3	52		 push	 edx
  000b4	8d 45 98	 lea	 eax, DWORD PTR $T7[ebp]
  000b7	50		 push	 eax
  000b8	8d 4d 94	 lea	 ecx, DWORD PTR $T6[ebp]
  000bb	51		 push	 ecx
  000bc	8d 55 90	 lea	 edx, DWORD PTR $T5[ebp]
  000bf	52		 push	 edx
  000c0	8d 45 8c	 lea	 eax, DWORD PTR $T4[ebp]
  000c3	50		 push	 eax
  000c4	8d 4d 88	 lea	 ecx, DWORD PTR $T3[ebp]
  000c7	51		 push	 ecx
  000c8	8d 55 84	 lea	 edx, DWORD PTR $T2[ebp]
  000cb	52		 push	 edx
  000cc	8d 85 48 ff ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  000d2	50		 push	 eax
  000d3	e8 00 00 00 00	 call	 ??$make_array@W4CspTransfer@@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@@@YA?AV?$array@W4CspTransfer@@$0P@@std@@$$QAW4CspTransfer@@00000000000000@Z ; make_array<enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer>
  000d8	83 c4 40	 add	 esp, 64			; 00000040H
  000db	b9 0f 00 00 00	 mov	 ecx, 15			; 0000000fH
  000e0	8b f0		 mov	 esi, eax
  000e2	8d 7d c0	 lea	 edi, DWORD PTR $T17[ebp]
  000e5	f3 a5		 rep movsd
  000e7	b9 0f 00 00 00	 mov	 ecx, 15			; 0000000fH
  000ec	8d 75 c0	 lea	 esi, DWORD PTR $T17[ebp]
  000ef	bf 00 00 00 00	 mov	 edi, OFFSET ?CspTransferList@@3V?$array@W4CspTransfer@@$0P@@std@@B
  000f4	f3 a5		 rep movsd
  000f6	5f		 pop	 edi
  000f7	5e		 pop	 esi
  000f8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000fb	33 cd		 xor	 ecx, ebp
  000fd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00102	81 c4 b8 00 00
	00		 add	 esp, 184		; 000000b8H
  00108	3b ec		 cmp	 ebp, esp
  0010a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0010f	8b e5		 mov	 esp, ebp
  00111	5d		 pop	 ebp
  00112	c3		 ret	 0
??__ECspTransferList@@YAXXZ ENDP			; `dynamic initializer for 'CspTransferList''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\rgy_util.h
;	COMDAT ??$make_array@W4CspTransfer@@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@@@YA?AV?$array@W4CspTransfer@@$0P@@std@@$$QAW4CspTransfer@@00000000000000@Z
_TEXT	SEGMENT
$T1 = -64						; size = 60
__$ArrayPad$ = -4					; size = 4
$T2 = 8							; size = 4
_<args_0>$ = 12						; size = 4
_<args_1>$ = 16						; size = 4
_<args_2>$ = 20						; size = 4
_<args_3>$ = 24						; size = 4
_<args_4>$ = 28						; size = 4
_<args_5>$ = 32						; size = 4
_<args_6>$ = 36						; size = 4
_<args_7>$ = 40						; size = 4
_<args_8>$ = 44						; size = 4
_<args_9>$ = 48						; size = 4
_<args_10>$ = 52					; size = 4
_<args_11>$ = 56					; size = 4
_<args_12>$ = 60					; size = 4
_<args_13>$ = 64					; size = 4
_<args_14>$ = 68					; size = 4
??$make_array@W4CspTransfer@@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@@@YA?AV?$array@W4CspTransfer@@$0P@@std@@$$QAW4CspTransfer@@00000000000000@Z PROC ; make_array<enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer>, COMDAT

; 129  : constexpr std::array<T, sizeof...(Args)> make_array(Args&&... args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8d 7d c0	 lea	 edi, DWORD PTR [ebp-64]
  0000b	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 130  :     return std::array<T, sizeof...(Args)>{ static_cast<Args&&>(args)... };

  00021	8b 45 0c	 mov	 eax, DWORD PTR _<args_0>$[ebp]
  00024	8b 08		 mov	 ecx, DWORD PTR [eax]
  00026	89 4d c0	 mov	 DWORD PTR $T1[ebp], ecx
  00029	8b 55 10	 mov	 edx, DWORD PTR _<args_1>$[ebp]
  0002c	8b 02		 mov	 eax, DWORD PTR [edx]
  0002e	89 45 c4	 mov	 DWORD PTR $T1[ebp+4], eax
  00031	8b 4d 14	 mov	 ecx, DWORD PTR _<args_2>$[ebp]
  00034	8b 11		 mov	 edx, DWORD PTR [ecx]
  00036	89 55 c8	 mov	 DWORD PTR $T1[ebp+8], edx
  00039	8b 45 18	 mov	 eax, DWORD PTR _<args_3>$[ebp]
  0003c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003e	89 4d cc	 mov	 DWORD PTR $T1[ebp+12], ecx
  00041	8b 55 1c	 mov	 edx, DWORD PTR _<args_4>$[ebp]
  00044	8b 02		 mov	 eax, DWORD PTR [edx]
  00046	89 45 d0	 mov	 DWORD PTR $T1[ebp+16], eax
  00049	8b 4d 20	 mov	 ecx, DWORD PTR _<args_5>$[ebp]
  0004c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004e	89 55 d4	 mov	 DWORD PTR $T1[ebp+20], edx
  00051	8b 45 24	 mov	 eax, DWORD PTR _<args_6>$[ebp]
  00054	8b 08		 mov	 ecx, DWORD PTR [eax]
  00056	89 4d d8	 mov	 DWORD PTR $T1[ebp+24], ecx
  00059	8b 55 28	 mov	 edx, DWORD PTR _<args_7>$[ebp]
  0005c	8b 02		 mov	 eax, DWORD PTR [edx]
  0005e	89 45 dc	 mov	 DWORD PTR $T1[ebp+28], eax
  00061	8b 4d 2c	 mov	 ecx, DWORD PTR _<args_8>$[ebp]
  00064	8b 11		 mov	 edx, DWORD PTR [ecx]
  00066	89 55 e0	 mov	 DWORD PTR $T1[ebp+32], edx
  00069	8b 45 30	 mov	 eax, DWORD PTR _<args_9>$[ebp]
  0006c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006e	89 4d e4	 mov	 DWORD PTR $T1[ebp+36], ecx
  00071	8b 55 34	 mov	 edx, DWORD PTR _<args_10>$[ebp]
  00074	8b 02		 mov	 eax, DWORD PTR [edx]
  00076	89 45 e8	 mov	 DWORD PTR $T1[ebp+40], eax
  00079	8b 4d 38	 mov	 ecx, DWORD PTR _<args_11>$[ebp]
  0007c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0007e	89 55 ec	 mov	 DWORD PTR $T1[ebp+44], edx
  00081	8b 45 3c	 mov	 eax, DWORD PTR _<args_12>$[ebp]
  00084	8b 08		 mov	 ecx, DWORD PTR [eax]
  00086	89 4d f0	 mov	 DWORD PTR $T1[ebp+48], ecx
  00089	8b 55 40	 mov	 edx, DWORD PTR _<args_13>$[ebp]
  0008c	8b 02		 mov	 eax, DWORD PTR [edx]
  0008e	89 45 f4	 mov	 DWORD PTR $T1[ebp+52], eax
  00091	8b 4d 44	 mov	 ecx, DWORD PTR _<args_14>$[ebp]
  00094	8b 11		 mov	 edx, DWORD PTR [ecx]
  00096	89 55 f8	 mov	 DWORD PTR $T1[ebp+56], edx
  00099	b9 0f 00 00 00	 mov	 ecx, 15			; 0000000fH
  0009e	8d 75 c0	 lea	 esi, DWORD PTR $T1[ebp]
  000a1	8b 7d 08	 mov	 edi, DWORD PTR $T2[ebp]
  000a4	f3 a5		 rep movsd
  000a6	8b 45 08	 mov	 eax, DWORD PTR $T2[ebp]

; 131  : }

  000a9	5f		 pop	 edi
  000aa	5e		 pop	 esi
  000ab	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ae	33 cd		 xor	 ecx, ebp
  000b0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b5	8b e5		 mov	 esp, ebp
  000b7	5d		 pop	 ebp
  000b8	c3		 ret	 0
??$make_array@W4CspTransfer@@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@@@YA?AV?$array@W4CspTransfer@@$0P@@std@@$$QAW4CspTransfer@@00000000000000@Z ENDP ; make_array<enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\rgy_util.h
;	COMDAT ??__ECspMatrixList@@YAXXZ
text$di	SEGMENT
$T1 = -172						; size = 56
$T2 = -116						; size = 4
$T3 = -112						; size = 4
$T4 = -108						; size = 4
$T5 = -104						; size = 4
$T6 = -100						; size = 4
$T7 = -96						; size = 4
$T8 = -92						; size = 4
$T9 = -88						; size = 4
$T10 = -84						; size = 4
$T11 = -80						; size = 4
$T12 = -76						; size = 4
$T13 = -72						; size = 4
$T14 = -68						; size = 4
$T15 = -64						; size = 4
$T16 = -60						; size = 56
__$ArrayPad$ = -4					; size = 4
??__ECspMatrixList@@YAXXZ PROC				; `dynamic initializer for 'CspMatrixList'', COMDAT

; 1080 : );

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec ac 00 00
	00		 sub	 esp, 172		; 000000acH
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8d bd 54 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-172]
  00011	b9 2b 00 00 00	 mov	 ecx, 43			; 0000002bH
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1065 : static const auto CspMatrixList = make_array<CspMatrix>(

  00027	c7 45 c0 0f 00
	00 00		 mov	 DWORD PTR $T15[ebp], 15	; 0000000fH
  0002e	c7 45 bc 0e 00
	00 00		 mov	 DWORD PTR $T14[ebp], 14	; 0000000eH
  00035	c7 45 b8 0d 00
	00 00		 mov	 DWORD PTR $T13[ebp], 13	; 0000000dH
  0003c	c7 45 b4 0c 00
	00 00		 mov	 DWORD PTR $T12[ebp], 12	; 0000000cH
  00043	c7 45 b0 0a 00
	00 00		 mov	 DWORD PTR $T11[ebp], 10	; 0000000aH
  0004a	c7 45 ac 09 00
	00 00		 mov	 DWORD PTR $T10[ebp], 9
  00051	c7 45 a8 08 00
	00 00		 mov	 DWORD PTR $T9[ebp], 8
  00058	c7 45 a4 07 00
	00 00		 mov	 DWORD PTR $T8[ebp], 7
  0005f	c7 45 a0 06 00
	00 00		 mov	 DWORD PTR $T7[ebp], 6
  00066	c7 45 9c 05 00
	00 00		 mov	 DWORD PTR $T6[ebp], 5
  0006d	c7 45 98 04 00
	00 00		 mov	 DWORD PTR $T5[ebp], 4
  00074	c7 45 94 02 00
	00 00		 mov	 DWORD PTR $T4[ebp], 2
  0007b	c7 45 90 01 00
	00 00		 mov	 DWORD PTR $T3[ebp], 1
  00082	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  00089	8d 45 c0	 lea	 eax, DWORD PTR $T15[ebp]
  0008c	50		 push	 eax
  0008d	8d 4d bc	 lea	 ecx, DWORD PTR $T14[ebp]
  00090	51		 push	 ecx
  00091	8d 55 b8	 lea	 edx, DWORD PTR $T13[ebp]
  00094	52		 push	 edx
  00095	8d 45 b4	 lea	 eax, DWORD PTR $T12[ebp]
  00098	50		 push	 eax
  00099	8d 4d b0	 lea	 ecx, DWORD PTR $T11[ebp]
  0009c	51		 push	 ecx
  0009d	8d 55 ac	 lea	 edx, DWORD PTR $T10[ebp]
  000a0	52		 push	 edx
  000a1	8d 45 a8	 lea	 eax, DWORD PTR $T9[ebp]
  000a4	50		 push	 eax
  000a5	8d 4d a4	 lea	 ecx, DWORD PTR $T8[ebp]
  000a8	51		 push	 ecx
  000a9	8d 55 a0	 lea	 edx, DWORD PTR $T7[ebp]
  000ac	52		 push	 edx
  000ad	8d 45 9c	 lea	 eax, DWORD PTR $T6[ebp]
  000b0	50		 push	 eax
  000b1	8d 4d 98	 lea	 ecx, DWORD PTR $T5[ebp]
  000b4	51		 push	 ecx
  000b5	8d 55 94	 lea	 edx, DWORD PTR $T4[ebp]
  000b8	52		 push	 edx
  000b9	8d 45 90	 lea	 eax, DWORD PTR $T3[ebp]
  000bc	50		 push	 eax
  000bd	8d 4d 8c	 lea	 ecx, DWORD PTR $T2[ebp]
  000c0	51		 push	 ecx
  000c1	8d 95 54 ff ff
	ff		 lea	 edx, DWORD PTR $T1[ebp]
  000c7	52		 push	 edx
  000c8	e8 00 00 00 00	 call	 ??$make_array@W4CspMatrix@@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@@@YA?AV?$array@W4CspMatrix@@$0O@@std@@$$QAW4CspMatrix@@0000000000000@Z ; make_array<enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix>
  000cd	83 c4 3c	 add	 esp, 60			; 0000003cH
  000d0	b9 0e 00 00 00	 mov	 ecx, 14			; 0000000eH
  000d5	8b f0		 mov	 esi, eax
  000d7	8d 7d c4	 lea	 edi, DWORD PTR $T16[ebp]
  000da	f3 a5		 rep movsd
  000dc	b9 0e 00 00 00	 mov	 ecx, 14			; 0000000eH
  000e1	8d 75 c4	 lea	 esi, DWORD PTR $T16[ebp]
  000e4	bf 00 00 00 00	 mov	 edi, OFFSET ?CspMatrixList@@3V?$array@W4CspMatrix@@$0O@@std@@B
  000e9	f3 a5		 rep movsd
  000eb	5f		 pop	 edi
  000ec	5e		 pop	 esi
  000ed	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f0	33 cd		 xor	 ecx, ebp
  000f2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f7	81 c4 ac 00 00
	00		 add	 esp, 172		; 000000acH
  000fd	3b ec		 cmp	 ebp, esp
  000ff	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00104	8b e5		 mov	 esp, ebp
  00106	5d		 pop	 ebp
  00107	c3		 ret	 0
??__ECspMatrixList@@YAXXZ ENDP				; `dynamic initializer for 'CspMatrixList''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\rgy_util.h
;	COMDAT ??$make_array@W4CspMatrix@@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@@@YA?AV?$array@W4CspMatrix@@$0O@@std@@$$QAW4CspMatrix@@0000000000000@Z
_TEXT	SEGMENT
$T1 = -60						; size = 56
__$ArrayPad$ = -4					; size = 4
$T2 = 8							; size = 4
_<args_0>$ = 12						; size = 4
_<args_1>$ = 16						; size = 4
_<args_2>$ = 20						; size = 4
_<args_3>$ = 24						; size = 4
_<args_4>$ = 28						; size = 4
_<args_5>$ = 32						; size = 4
_<args_6>$ = 36						; size = 4
_<args_7>$ = 40						; size = 4
_<args_8>$ = 44						; size = 4
_<args_9>$ = 48						; size = 4
_<args_10>$ = 52					; size = 4
_<args_11>$ = 56					; size = 4
_<args_12>$ = 60					; size = 4
_<args_13>$ = 64					; size = 4
??$make_array@W4CspMatrix@@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@@@YA?AV?$array@W4CspMatrix@@$0O@@std@@$$QAW4CspMatrix@@0000000000000@Z PROC ; make_array<enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix>, COMDAT

; 129  : constexpr std::array<T, sizeof...(Args)> make_array(Args&&... args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8d 7d c4	 lea	 edi, DWORD PTR [ebp-60]
  0000b	b9 0f 00 00 00	 mov	 ecx, 15			; 0000000fH
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 130  :     return std::array<T, sizeof...(Args)>{ static_cast<Args&&>(args)... };

  00021	8b 45 0c	 mov	 eax, DWORD PTR _<args_0>$[ebp]
  00024	8b 08		 mov	 ecx, DWORD PTR [eax]
  00026	89 4d c4	 mov	 DWORD PTR $T1[ebp], ecx
  00029	8b 55 10	 mov	 edx, DWORD PTR _<args_1>$[ebp]
  0002c	8b 02		 mov	 eax, DWORD PTR [edx]
  0002e	89 45 c8	 mov	 DWORD PTR $T1[ebp+4], eax
  00031	8b 4d 14	 mov	 ecx, DWORD PTR _<args_2>$[ebp]
  00034	8b 11		 mov	 edx, DWORD PTR [ecx]
  00036	89 55 cc	 mov	 DWORD PTR $T1[ebp+8], edx
  00039	8b 45 18	 mov	 eax, DWORD PTR _<args_3>$[ebp]
  0003c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003e	89 4d d0	 mov	 DWORD PTR $T1[ebp+12], ecx
  00041	8b 55 1c	 mov	 edx, DWORD PTR _<args_4>$[ebp]
  00044	8b 02		 mov	 eax, DWORD PTR [edx]
  00046	89 45 d4	 mov	 DWORD PTR $T1[ebp+16], eax
  00049	8b 4d 20	 mov	 ecx, DWORD PTR _<args_5>$[ebp]
  0004c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004e	89 55 d8	 mov	 DWORD PTR $T1[ebp+20], edx
  00051	8b 45 24	 mov	 eax, DWORD PTR _<args_6>$[ebp]
  00054	8b 08		 mov	 ecx, DWORD PTR [eax]
  00056	89 4d dc	 mov	 DWORD PTR $T1[ebp+24], ecx
  00059	8b 55 28	 mov	 edx, DWORD PTR _<args_7>$[ebp]
  0005c	8b 02		 mov	 eax, DWORD PTR [edx]
  0005e	89 45 e0	 mov	 DWORD PTR $T1[ebp+28], eax
  00061	8b 4d 2c	 mov	 ecx, DWORD PTR _<args_8>$[ebp]
  00064	8b 11		 mov	 edx, DWORD PTR [ecx]
  00066	89 55 e4	 mov	 DWORD PTR $T1[ebp+32], edx
  00069	8b 45 30	 mov	 eax, DWORD PTR _<args_9>$[ebp]
  0006c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006e	89 4d e8	 mov	 DWORD PTR $T1[ebp+36], ecx
  00071	8b 55 34	 mov	 edx, DWORD PTR _<args_10>$[ebp]
  00074	8b 02		 mov	 eax, DWORD PTR [edx]
  00076	89 45 ec	 mov	 DWORD PTR $T1[ebp+40], eax
  00079	8b 4d 38	 mov	 ecx, DWORD PTR _<args_11>$[ebp]
  0007c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0007e	89 55 f0	 mov	 DWORD PTR $T1[ebp+44], edx
  00081	8b 45 3c	 mov	 eax, DWORD PTR _<args_12>$[ebp]
  00084	8b 08		 mov	 ecx, DWORD PTR [eax]
  00086	89 4d f4	 mov	 DWORD PTR $T1[ebp+48], ecx
  00089	8b 55 40	 mov	 edx, DWORD PTR _<args_13>$[ebp]
  0008c	8b 02		 mov	 eax, DWORD PTR [edx]
  0008e	89 45 f8	 mov	 DWORD PTR $T1[ebp+52], eax
  00091	b9 0e 00 00 00	 mov	 ecx, 14			; 0000000eH
  00096	8d 75 c4	 lea	 esi, DWORD PTR $T1[ebp]
  00099	8b 7d 08	 mov	 edi, DWORD PTR $T2[ebp]
  0009c	f3 a5		 rep movsd
  0009e	8b 45 08	 mov	 eax, DWORD PTR $T2[ebp]

; 131  : }

  000a1	5f		 pop	 edi
  000a2	5e		 pop	 esi
  000a3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a6	33 cd		 xor	 ecx, ebp
  000a8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ad	8b e5		 mov	 esp, ebp
  000af	5d		 pop	 ebp
  000b0	c3		 ret	 0
??$make_array@W4CspMatrix@@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@@@YA?AV?$array@W4CspMatrix@@$0O@@std@@$$QAW4CspMatrix@@0000000000000@Z ENDP ; make_array<enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\rgy_util.h
;	COMDAT ??Rhandle_deleter@@QBEXPAX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_handle$ = 8						; size = 4
??Rhandle_deleter@@QBEXPAX@Z PROC			; handle_deleter::operator(), COMDAT
; _this$ = ecx

; 188  :     void operator()(HANDLE handle) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 189  :         if (handle) {

  0000f	83 7d 08 00	 cmp	 DWORD PTR _handle$[ebp], 0
  00013	74 13		 je	 SHORT $LN1@operator

; 190  : #if defined(_WIN32) || defined(_WIN64)
; 191  :             CloseHandle(handle);

  00015	8b f4		 mov	 esi, esp
  00017	8b 45 08	 mov	 eax, DWORD PTR _handle$[ebp]
  0001a	50		 push	 eax
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
  00021	3b f4		 cmp	 esi, esp
  00023	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@operator:

; 192  : #endif //#if defined(_WIN32) || defined(_WIN64)
; 193  :         }
; 194  :     }

  00028	5e		 pop	 esi
  00029	83 c4 04	 add	 esp, 4
  0002c	3b ec		 cmp	 ebp, esp
  0002e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
??Rhandle_deleter@@QBEXPAX@Z ENDP			; handle_deleter::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\rgy_util.h
;	COMDAT ??Rfp_deleter@@QBEXPAU_iobuf@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_fp$ = 8						; size = 4
??Rfp_deleter@@QBEXPAU_iobuf@@@Z PROC			; fp_deleter::operator(), COMDAT
; _this$ = ecx

; 179  :     void operator()(FILE* fp) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 180  :         if (fp) {

  0000f	83 7d 08 00	 cmp	 DWORD PTR _fp$[ebp], 0
  00013	74 2c		 je	 SHORT $LN1@operator

; 181  :             fflush(fp);

  00015	8b f4		 mov	 esi, esp
  00017	8b 45 08	 mov	 eax, DWORD PTR _fp$[ebp]
  0001a	50		 push	 eax
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fflush
  00021	83 c4 04	 add	 esp, 4
  00024	3b f4		 cmp	 esi, esp
  00026	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 182  :             fclose(fp);

  0002b	8b f4		 mov	 esi, esp
  0002d	8b 4d 08	 mov	 ecx, DWORD PTR _fp$[ebp]
  00030	51		 push	 ecx
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  00037	83 c4 04	 add	 esp, 4
  0003a	3b f4		 cmp	 esi, esp
  0003c	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@operator:

; 183  :         }
; 184  :     }

  00041	5e		 pop	 esi
  00042	83 c4 04	 add	 esp, 4
  00045	3b ec		 cmp	 ebp, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c2 04 00	 ret	 4
??Rfp_deleter@@QBEXPAU_iobuf@@@Z ENDP			; fp_deleter::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00034	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0003b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	e8 00 00 00 00	 call	 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
  00043	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00046	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0004d	59		 pop	 ecx
  0004e	83 c4 10	 add	 esp, 16			; 00000010H
  00051	3b ec		 cmp	 ebp, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
__ehhandler$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1424 :     const _Ty1& _Get_first() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1425 :         return *this;

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1426 :     }

  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1420 :     _Ty1& _Get_first() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1421 :         return *this;

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1422 :     }

  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT
; _this$ = ecx

; 4198 :     const _Alty& _Getal() const noexcept { // return const reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 4199 :         return _Mypair._Get_first();

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first

; 4200 :     }

  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT
; _this$ = ecx

; 4194 :     _Alty& _Getal() noexcept { // return reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 4195 :         return _Mypair._Get_first();

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first

; 4196 :     }

  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring
;	COMDAT ?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators, COMDAT
; _this$ = ecx

; 4190 :     void _Swap_proxy_and_iterators(basic_string& _Right) { // swap all iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 4191 :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ?_Swap_proxy_and_iterators@_Container_base12@std@@QAEXAAU12@@Z ; std::_Container_base12::_Swap_proxy_and_iterators

; 4192 :     }

  0001a	83 c4 04	 add	 esp, 4
  0001d	3b ec		 cmp	 ebp, esp
  0001f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT

; 4180 :     [[noreturn]] static void _Xlen() { // report a length_error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4181 :         _Xlength_error("string too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlen:

; 4182 :     }

  0000d	3b ec		 cmp	 ebp, esp
  0000f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
$T2 = -25						; size = 1
__Al$3 = -24						; size = 4
__Ptr$4 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT
; _this$ = ecx

; 4164 :     void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  0001c	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  0001f	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00022	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00025	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002a	33 c5		 xor	 eax, ebp
  0002c	50		 push	 eax
  0002d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00030	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00036	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 4165 :         _Mypair._Myval2._Orphan_all();

  00039	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 4166 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00041	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
  00049	0f b6 c0	 movzx	 eax, al
  0004c	85 c0		 test	 eax, eax
  0004e	74 39		 je	 SHORT $LN2@Tidy_deall

; 4167 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;

  00050	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00056	89 55 ec	 mov	 DWORD PTR __Ptr$4[ebp], edx

; 4168 :             auto& _Al          = _Getal();

  00059	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005c	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00061	89 45 e8	 mov	 DWORD PTR __Al$3[ebp], eax

; 4169 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);

  00064	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00067	83 c0 04	 add	 eax, 4
  0006a	50		 push	 eax
  0006b	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ; std::_Destroy_in_place<char *>
  00070	83 c4 04	 add	 esp, 4

; 4170 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00073	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00076	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00079	83 c2 01	 add	 edx, 1
  0007c	52		 push	 edx
  0007d	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$4[ebp]
  00080	50		 push	 eax
  00081	8b 4d e8	 mov	 ecx, DWORD PTR __Al$3[ebp]
  00084	e8 00 00 00 00	 call	 ?deallocate@?$allocator@D@std@@QAEXQADI@Z ; std::allocator<char>::deallocate
$LN2@Tidy_deall:

; 4171 :         }
; 4172 : 
; 4173 :         _Mypair._Myval2._Mysize = 0;

  00089	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0008c	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 4174 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00093	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00096	c7 42 18 0f 00
	00 00		 mov	 DWORD PTR [edx+24], 15	; 0000000fH

; 4175 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4176 :         // write can alias this
; 4177 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  0009d	c6 45 e7 00	 mov	 BYTE PTR $T2[ebp], 0
  000a1	8d 45 e7	 lea	 eax, DWORD PTR $T2[ebp]
  000a4	50		 push	 eax
  000a5	b9 01 00 00 00	 mov	 ecx, 1
  000aa	6b d1 00	 imul	 edx, ecx, 0
  000ad	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000b0	8d 4c 10 04	 lea	 ecx, DWORD PTR [eax+edx+4]
  000b4	51		 push	 ecx
  000b5	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
  000ba	83 c4 08	 add	 esp, 8

; 4178 :     }

  000bd	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c0	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000c7	59		 pop	 ecx
  000c8	83 c4 1c	 add	 esp, 28			; 0000001cH
  000cb	3b ec		 cmp	 ebp, esp
  000cd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d2	8b e5		 mov	 esp, ebp
  000d4	5d		 pop	 ebp
  000d5	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring
;	COMDAT ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -5						; size = 1
_this$ = -4						; size = 4
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init, COMDAT
; _this$ = ecx

; 4156 :     void _Tidy_init() noexcept { // initialize basic_string data members

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 4157 :         _Mypair._Myval2._Mysize = 0;

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0

; 4158 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	c7 41 18 0f 00
	00 00		 mov	 DWORD PTR [ecx+24], 15	; 0000000fH

; 4159 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4160 :         // write can alias this
; 4161 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  0002b	c6 45 fb 00	 mov	 BYTE PTR $T1[ebp], 0
  0002f	8d 55 fb	 lea	 edx, DWORD PTR $T1[ebp]
  00032	52		 push	 edx
  00033	b8 01 00 00 00	 mov	 eax, 1
  00038	6b c8 00	 imul	 ecx, eax, 0
  0003b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003e	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
  00048	83 c4 08	 add	 esp, 8

; 4162 :     }

  0004b	83 c4 08	 add	 esp, 8
  0004e	3b ec		 cmp	 ebp, esp
  00050	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Requested$ = 8					; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 4077 :     _NODISCARD size_type _Calculate_growth(const size_type _Requested) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 4078 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00016	50		 push	 eax
  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0001d	51		 push	 ecx
  0001e	8b 55 08	 mov	 edx, DWORD PTR __Requested$[ebp]
  00021	52		 push	 edx
  00022	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  00027	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4079 :     }

  0002a	83 c4 04	 add	 esp, 4
  0002d	3b ec		 cmp	 ebp, esp
  0002f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c2 04 00	 ret	 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
__Masked$ = -8						; size = 4
__Requested$ = 8					; size = 4
__Old$ = 12						; size = 4
__Max$ = 16						; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT

; 4064 :         const size_type _Requested, const size_type _Old, const size_type _Max) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000e	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00011	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00014	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 4065 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  00017	8b 45 08	 mov	 eax, DWORD PTR __Requested$[ebp]
  0001a	83 c8 0f	 or	 eax, 15			; 0000000fH
  0001d	89 45 f8	 mov	 DWORD PTR __Masked$[ebp], eax

; 4066 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00020	8b 4d f8	 mov	 ecx, DWORD PTR __Masked$[ebp]
  00023	3b 4d 10	 cmp	 ecx, DWORD PTR __Max$[ebp]
  00026	76 05		 jbe	 SHORT $LN2@Calculate_

; 4067 :             return _Max;

  00028	8b 45 10	 mov	 eax, DWORD PTR __Max$[ebp]
  0002b	eb 31		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 4068 :         }
; 4069 : 
; 4070 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  0002d	8b 55 0c	 mov	 edx, DWORD PTR __Old$[ebp]
  00030	d1 ea		 shr	 edx, 1
  00032	8b 45 10	 mov	 eax, DWORD PTR __Max$[ebp]
  00035	2b c2		 sub	 eax, edx
  00037	39 45 0c	 cmp	 DWORD PTR __Old$[ebp], eax
  0003a	76 05		 jbe	 SHORT $LN3@Calculate_

; 4071 :             return _Max;

  0003c	8b 45 10	 mov	 eax, DWORD PTR __Max$[ebp]
  0003f	eb 1d		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 4072 :         }
; 4073 : 
; 4074 :         return _Max_value(_Masked, _Old + _Old / 2);

  00041	8b 4d 0c	 mov	 ecx, DWORD PTR __Old$[ebp]
  00044	d1 e9		 shr	 ecx, 1
  00046	03 4d 0c	 add	 ecx, DWORD PTR __Old$[ebp]
  00049	89 4d f0	 mov	 DWORD PTR $T1[ebp], ecx
  0004c	8d 55 f0	 lea	 edx, DWORD PTR $T1[ebp]
  0004f	52		 push	 edx
  00050	8d 45 f8	 lea	 eax, DWORD PTR __Masked$[ebp]
  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 ??$_Max_value@I@std@@YAABIABI0@Z ; std::_Max_value<unsigned int>
  00059	83 c4 08	 add	 esp, 8
  0005c	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1@Calculate_:

; 4075 :     }

  0005e	52		 push	 edx
  0005f	8b cd		 mov	 ecx, ebp
  00061	50		 push	 eax
  00062	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN7@Calculate_
  00068	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0006d	58		 pop	 eax
  0006e	5a		 pop	 edx
  0006f	83 c4 10	 add	 esp, 16			; 00000010H
  00072	3b ec		 cmp	 ebp, esp
  00074	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
  0007d	0f 1f 00	 npad	 3
$LN7@Calculate_:
  00080	01 00 00 00	 DD	 1
  00084	00 00 00 00	 DD	 $LN6@Calculate_
$LN6@Calculate_:
  00088	f8 ff ff ff	 DD	 -8			; fffffff8H
  0008c	04 00 00 00	 DD	 4
  00090	00 00 00 00	 DD	 $LN5@Calculate_
$LN5@Calculate_:
  00094	5f		 DB	 95			; 0000005fH
  00095	4d		 DB	 77			; 0000004dH
  00096	61		 DB	 97			; 00000061H
  00097	73		 DB	 115			; 00000073H
  00098	6b		 DB	 107			; 0000006bH
  00099	65		 DB	 101			; 00000065H
  0009a	64		 DB	 100			; 00000064H
  0009b	00		 DB	 0
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring
;	COMDAT ?capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::capacity, COMDAT
; _this$ = ecx

; 3589 :     _NODISCARD size_type capacity() const noexcept { // return current length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3590 :         return _Mypair._Myval2._Myres;

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 40 18	 mov	 eax, DWORD PTR [eax+24]

; 3591 :     }

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::capacity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -32						; size = 4
$T2 = -28						; size = 4
$T3 = -24						; size = 4
__Storage_max$ = -20					; size = 4
__Alloc_max$ = -12					; size = 4
_this$ = -4						; size = 4
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 3570 :     _NODISCARD size_type max_size() const noexcept { // return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  0000e	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  00011	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00014	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00017	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0001a	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  0001d	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00020	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00023	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3571 :         const size_type _Alloc_max   = _Alty_traits::max_size(_Getal());

  00026	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
  00034	83 c4 04	 add	 esp, 4
  00037	89 45 f4	 mov	 DWORD PTR __Alloc_max$[ebp], eax

; 3572 :         const size_type _Storage_max = // can always store small string

  0003a	c7 45 e8 10 00
	00 00		 mov	 DWORD PTR $T3[ebp], 16	; 00000010H
  00041	8d 45 e8	 lea	 eax, DWORD PTR $T3[ebp]
  00044	50		 push	 eax
  00045	8d 4d f4	 lea	 ecx, DWORD PTR __Alloc_max$[ebp]
  00048	51		 push	 ecx
  00049	e8 00 00 00 00	 call	 ??$_Max_value@I@std@@YAABIABI0@Z ; std::_Max_value<unsigned int>
  0004e	83 c4 08	 add	 esp, 8
  00051	8b 10		 mov	 edx, DWORD PTR [eax]
  00053	89 55 ec	 mov	 DWORD PTR __Storage_max$[ebp], edx

; 3573 :             _Max_value(_Alloc_max, static_cast<size_type>(_BUF_SIZE));
; 3574 :         return _Min_value(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  00056	8b 45 ec	 mov	 eax, DWORD PTR __Storage_max$[ebp]
  00059	83 e8 01	 sub	 eax, 1
  0005c	89 45 e4	 mov	 DWORD PTR $T2[ebp], eax
  0005f	e8 00 00 00 00	 call	 ?max@?$numeric_limits@H@std@@SAHXZ ; std::numeric_limits<int>::max
  00064	89 45 e0	 mov	 DWORD PTR $T1[ebp], eax
  00067	8d 4d e4	 lea	 ecx, DWORD PTR $T2[ebp]
  0006a	51		 push	 ecx
  0006b	8d 55 e0	 lea	 edx, DWORD PTR $T1[ebp]
  0006e	52		 push	 edx
  0006f	e8 00 00 00 00	 call	 ??$_Min_value@I@std@@YAABIABI0@Z ; std::_Min_value<unsigned int>
  00074	83 c4 08	 add	 esp, 8
  00077	8b 00		 mov	 eax, DWORD PTR [eax]

; 3575 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 3576 :         );
; 3577 :     }

  00079	52		 push	 edx
  0007a	8b cd		 mov	 ecx, ebp
  0007c	50		 push	 eax
  0007d	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@max_size
  00083	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00088	58		 pop	 eax
  00089	5a		 pop	 edx
  0008a	83 c4 20	 add	 esp, 32			; 00000020H
  0008d	3b ec		 cmp	 ebp, esp
  0008f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c3		 ret	 0
$LN5@max_size:
  00098	01 00 00 00	 DD	 1
  0009c	00 00 00 00	 DD	 $LN4@max_size
$LN4@max_size:
  000a0	f4 ff ff ff	 DD	 -12			; fffffff4H
  000a4	04 00 00 00	 DD	 4
  000a8	00 00 00 00	 DD	 $LN3@max_size
$LN3@max_size:
  000ac	5f		 DB	 95			; 0000005fH
  000ad	41		 DB	 65			; 00000041H
  000ae	6c		 DB	 108			; 0000006cH
  000af	6c		 DB	 108			; 0000006cH
  000b0	6f		 DB	 111			; 0000006fH
  000b1	63		 DB	 99			; 00000063H
  000b2	5f		 DB	 95			; 0000005fH
  000b3	6d		 DB	 109			; 0000006dH
  000b4	61		 DB	 97			; 00000061H
  000b5	78		 DB	 120			; 00000078H
  000b6	00		 DB	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 3566 :     _NODISCARD size_type size() const noexcept { // return length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3567 :         return _Mypair._Myval2._Mysize;

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 40 14	 mov	 eax, DWORD PTR [eax+20]

; 3568 :     }

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring
;	COMDAT ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length, COMDAT
; _this$ = ecx

; 3562 :     _NODISCARD size_type length() const noexcept { // return length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3563 :         return _Mypair._Myval2._Mysize;

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 40 14	 mov	 eax, DWORD PTR [eax+20]

; 3564 :     }

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 3548 :     _NODISCARD _Ret_z_ const _Elem* c_str() const noexcept { // return pointer to null-terminated immutable array

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 3549 :         return _Mypair._Myval2._Myptr();

  0002d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr

; 3550 :     }

  00035	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00038	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0003f	59		 pop	 ecx
  00040	83 c4 10	 add	 esp, 16			; 00000010H
  00043	3b ec		 cmp	 ebp, esp
  00045	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IQBDI@Z
_TEXT	SEGMENT
$T1 = -21						; size = 1
__Ptr_shifted_after$2 = -20				; size = 4
__Insert_at$3 = -16					; size = 4
__Old_ptr$4 = -12					; size = 4
__Old_size$ = -8					; size = 4
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__Count$ = 16						; size = 4
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IQBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT
; _this$ = ecx

; 2957 :         const size_type _Off, _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  0000e	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00011	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00014	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00017	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  0001a	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  0001d	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2958 :         // insert [_Ptr, _Ptr + _Count) at _Off
; 2959 :         _Mypair._Myval2._Check_offset(_Off);

  00020	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00023	50		 push	 eax
  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEXI@Z ; std::_String_val<std::_Simple_types<char> >::_Check_offset

; 2960 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00032	89 55 f8	 mov	 DWORD PTR __Old_size$[ebp], edx

; 2961 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

  00035	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00038	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0003b	2b 4d f8	 sub	 ecx, DWORD PTR __Old_size$[ebp]
  0003e	39 4d 10	 cmp	 DWORD PTR __Count$[ebp], ecx
  00041	0f 87 ae 00 00
	00		 ja	 $LN2@insert

; 2962 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  00047	8b 55 f8	 mov	 edx, DWORD PTR __Old_size$[ebp]
  0004a	03 55 10	 add	 edx, DWORD PTR __Count$[ebp]
  0004d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00050	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 2963 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

  00053	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0005b	89 45 f4	 mov	 DWORD PTR __Old_ptr$4[ebp], eax

; 2964 :             _Elem* const _Insert_at = _Old_ptr + _Off;

  0005e	8b 4d f4	 mov	 ecx, DWORD PTR __Old_ptr$4[ebp]
  00061	03 4d 08	 add	 ecx, DWORD PTR __Off$[ebp]
  00064	89 4d f0	 mov	 DWORD PTR __Insert_at$3[ebp], ecx

; 2965 :             // the range [_Ptr, _Ptr + _Ptr_shifted_after) is left alone by moving the suffix out,
; 2966 :             // while the range [_Ptr + _Ptr_shifted_after, _Ptr + _Count) shifts down by _Count
; 2967 :             size_type _Ptr_shifted_after;
; 2968 :             if (_Ptr + _Count <= _Insert_at
; 2969 :                 || _Ptr > _Old_ptr + _Old_size) { // inserted content is before the shifted region, or does not alias

  00067	8b 55 0c	 mov	 edx, DWORD PTR __Ptr$[ebp]
  0006a	03 55 10	 add	 edx, DWORD PTR __Count$[ebp]
  0006d	3b 55 f0	 cmp	 edx, DWORD PTR __Insert_at$3[ebp]
  00070	76 0b		 jbe	 SHORT $LN5@insert
  00072	8b 45 f4	 mov	 eax, DWORD PTR __Old_ptr$4[ebp]
  00075	03 45 f8	 add	 eax, DWORD PTR __Old_size$[ebp]
  00078	39 45 0c	 cmp	 DWORD PTR __Ptr$[ebp], eax
  0007b	76 08		 jbe	 SHORT $LN3@insert
$LN5@insert:

; 2970 :                 _Ptr_shifted_after = _Count; // none of _Ptr's data shifts

  0007d	8b 4d 10	 mov	 ecx, DWORD PTR __Count$[ebp]
  00080	89 4d ec	 mov	 DWORD PTR __Ptr_shifted_after$2[ebp], ecx
  00083	eb 1a		 jmp	 SHORT $LN4@insert
$LN3@insert:

; 2971 :             } else if (_Insert_at <= _Ptr) { // all of [_Ptr, _Ptr + _Count) shifts

  00085	8b 55 f0	 mov	 edx, DWORD PTR __Insert_at$3[ebp]
  00088	3b 55 0c	 cmp	 edx, DWORD PTR __Ptr$[ebp]
  0008b	77 09		 ja	 SHORT $LN6@insert

; 2972 :                 _Ptr_shifted_after = 0;

  0008d	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __Ptr_shifted_after$2[ebp], 0

; 2973 :             } else { // [_Ptr, _Ptr + _Count) contains _Insert_at, so only the part after _Insert_at shifts

  00094	eb 09		 jmp	 SHORT $LN4@insert
$LN6@insert:

; 2974 :                 _Ptr_shifted_after = static_cast<size_type>(_Insert_at - _Ptr);

  00096	8b 45 f0	 mov	 eax, DWORD PTR __Insert_at$3[ebp]
  00099	2b 45 0c	 sub	 eax, DWORD PTR __Ptr$[ebp]
  0009c	89 45 ec	 mov	 DWORD PTR __Ptr_shifted_after$2[ebp], eax
$LN4@insert:

; 2975 :             }
; 2976 : 
; 2977 :             _Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); // move suffix + null down

  0009f	8b 4d f8	 mov	 ecx, DWORD PTR __Old_size$[ebp]
  000a2	2b 4d 08	 sub	 ecx, DWORD PTR __Off$[ebp]
  000a5	83 c1 01	 add	 ecx, 1
  000a8	51		 push	 ecx
  000a9	8b 55 f0	 mov	 edx, DWORD PTR __Insert_at$3[ebp]
  000ac	52		 push	 edx
  000ad	8b 45 f0	 mov	 eax, DWORD PTR __Insert_at$3[ebp]
  000b0	03 45 10	 add	 eax, DWORD PTR __Count$[ebp]
  000b3	50		 push	 eax
  000b4	e8 00 00 00 00	 call	 ?move@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Narrow_char_traits<char,int>::move
  000b9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2978 :             _Traits::copy(_Insert_at, _Ptr, _Ptr_shifted_after);

  000bc	8b 4d ec	 mov	 ecx, DWORD PTR __Ptr_shifted_after$2[ebp]
  000bf	51		 push	 ecx
  000c0	8b 55 0c	 mov	 edx, DWORD PTR __Ptr$[ebp]
  000c3	52		 push	 edx
  000c4	8b 45 f0	 mov	 eax, DWORD PTR __Insert_at$3[ebp]
  000c7	50		 push	 eax
  000c8	e8 00 00 00 00	 call	 ?copy@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Narrow_char_traits<char,int>::copy
  000cd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2979 :             _Traits::copy(

  000d0	8b 4d 10	 mov	 ecx, DWORD PTR __Count$[ebp]
  000d3	2b 4d ec	 sub	 ecx, DWORD PTR __Ptr_shifted_after$2[ebp]
  000d6	51		 push	 ecx
  000d7	8b 55 0c	 mov	 edx, DWORD PTR __Ptr$[ebp]
  000da	03 55 10	 add	 edx, DWORD PTR __Count$[ebp]
  000dd	03 55 ec	 add	 edx, DWORD PTR __Ptr_shifted_after$2[ebp]
  000e0	52		 push	 edx
  000e1	8b 45 f0	 mov	 eax, DWORD PTR __Insert_at$3[ebp]
  000e4	03 45 ec	 add	 eax, DWORD PTR __Ptr_shifted_after$2[ebp]
  000e7	50		 push	 eax
  000e8	e8 00 00 00 00	 call	 ?copy@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Narrow_char_traits<char,int>::copy
  000ed	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2980 :                 _Insert_at + _Ptr_shifted_after, _Ptr + _Count + _Ptr_shifted_after, _Count - _Ptr_shifted_after);
; 2981 :             return *this;

  000f0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000f3	eb 22		 jmp	 SHORT $LN1@insert
$LN2@insert:

; 2982 :         }
; 2983 : 
; 2984 :         return _Reallocate_grow_by(

  000f5	33 c9		 xor	 ecx, ecx
  000f7	88 4d eb	 mov	 BYTE PTR $T1[ebp], cl
  000fa	8b 55 10	 mov	 edx, DWORD PTR __Count$[ebp]
  000fd	52		 push	 edx
  000fe	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00101	50		 push	 eax
  00102	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  00105	51		 push	 ecx
  00106	0f b6 55 eb	 movzx	 edx, BYTE PTR $T1[ebp]
  0010a	52		 push	 edx
  0010b	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  0010e	50		 push	 eax
  0010f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00112	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_4d79bb85f269e6e8002a4599002d832c>@@IPBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_4d79bb85f269e6e8002a4599002d832c>@@IPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_4d79bb85f269e6e8002a4599002d832c>,unsigned int,char const *,unsigned int>
$LN1@insert:

; 2985 :             _Count,
; 2986 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Off,
; 2987 :                 const _Elem* const _Ptr, const size_type _Count) {
; 2988 :                 _Traits::copy(_New_ptr, _Old_ptr, _Off);
; 2989 :                 _Traits::copy(_New_ptr + _Off, _Ptr, _Count);
; 2990 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);
; 2991 :             },
; 2992 :             _Off, _Ptr, _Count);
; 2993 :     }

  00117	83 c4 18	 add	 esp, 24			; 00000018H
  0011a	3b ec		 cmp	 ebp, esp
  0011c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00121	8b e5		 mov	 esp, ebp
  00123	5d		 pop	 ebp
  00124	c2 0c 00	 ret	 12			; 0000000cH
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IQBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Right$ = 12						; size = 4
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT
; _this$ = ecx

; 2929 :     basic_string& insert(const size_type _Off, const basic_string& _Right) { // insert _Right at _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2930 :         return insert(_Off, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  0000e	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00011	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00014	51		 push	 ecx
  00015	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00018	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0001d	50		 push	 eax
  0001e	8b 55 08	 mov	 edx, DWORD PTR __Off$[ebp]
  00021	52		 push	 edx
  00022	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	e8 00 00 00 00	 call	 ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert

; 2931 :     }

  0002a	83 c4 04	 add	 esp, 4
  0002d	3b ec		 cmp	 ebp, esp
  0002f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c2 08 00	 ret	 8
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 2860 :     basic_string& assign(_In_z_ const _Elem* const _Ptr) { // assign [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2861 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z ; std::_Narrow_char_traits<char,int>::length
  00017	83 c4 04	 add	 esp, 4
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ??$_Convert_size@I@std@@YAII@Z ; std::_Convert_size<unsigned int>
  00020	83 c4 04	 add	 esp, 4
  00023	50		 push	 eax
  00024	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00027	51		 push	 ecx
  00028	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2862 :     }

  00030	83 c4 04	 add	 esp, 4
  00033	3b ec		 cmp	 ebp, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c2 04 00	 ret	 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
$T1 = -10						; size = 1
$T2 = -9						; size = 1
__Old_ptr$3 = -8					; size = 4
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 2841 :     basic_string& assign(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2842 :         // assign [_Ptr, _Ptr + _Count)
; 2843 :         if (_Count <= _Mypair._Myval2._Myres) {

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00024	3b 48 18	 cmp	 ecx, DWORD PTR [eax+24]
  00027	77 44		 ja	 SHORT $LN2@assign

; 2844 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00031	89 45 f8	 mov	 DWORD PTR __Old_ptr$3[ebp], eax

; 2845 :             _Mypair._Myval2._Mysize = _Count;

  00034	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00037	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0003a	89 42 14	 mov	 DWORD PTR [edx+20], eax

; 2846 :             _Traits::move(_Old_ptr, _Ptr, _Count);

  0003d	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00040	51		 push	 ecx
  00041	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00044	52		 push	 edx
  00045	8b 45 f8	 mov	 eax, DWORD PTR __Old_ptr$3[ebp]
  00048	50		 push	 eax
  00049	e8 00 00 00 00	 call	 ?move@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Narrow_char_traits<char,int>::move
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2847 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  00051	c6 45 f7 00	 mov	 BYTE PTR $T2[ebp], 0
  00055	8d 4d f7	 lea	 ecx, DWORD PTR $T2[ebp]
  00058	51		 push	 ecx
  00059	8b 55 f8	 mov	 edx, DWORD PTR __Old_ptr$3[ebp]
  0005c	03 55 0c	 add	 edx, DWORD PTR __Count$[ebp]
  0005f	52		 push	 edx
  00060	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
  00065	83 c4 08	 add	 esp, 8

; 2848 :             return *this;

  00068	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006b	eb 1a		 jmp	 SHORT $LN1@assign
$LN2@assign:

; 2849 :         }
; 2850 : 
; 2851 :         return _Reallocate_for(

  0006d	33 c0		 xor	 eax, eax
  0006f	88 45 f6	 mov	 BYTE PTR $T1[ebp], al
  00072	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00075	51		 push	 ecx
  00076	0f b6 55 f6	 movzx	 edx, BYTE PTR $T1[ebp]
  0007a	52		 push	 edx
  0007b	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0007e	50		 push	 eax
  0007f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00082	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
$LN1@assign:

; 2852 :             _Count,
; 2853 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {
; 2854 :                 _Traits::copy(_New_ptr, _Ptr, _Count);
; 2855 :                 _Traits::assign(_New_ptr[_Count], _Elem());
; 2856 :             },
; 2857 :             _Ptr);
; 2858 :     }

  00087	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008a	3b ec		 cmp	 ebp, esp
  0008c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c2 08 00	 ret	 8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 2756 :     basic_string& append(_In_z_ const _Elem* const _Ptr) { // append [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2757 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z ; std::_Narrow_char_traits<char,int>::length
  00017	83 c4 04	 add	 esp, 4
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ??$_Convert_size@I@std@@YAII@Z ; std::_Convert_size<unsigned int>
  00020	83 c4 04	 add	 esp, 4
  00023	50		 push	 eax
  00024	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00027	51		 push	 ecx
  00028	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2758 :     }

  00030	83 c4 04	 add	 esp, 4
  00033	3b ec		 cmp	 ebp, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c2 04 00	 ret	 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
$T1 = -14						; size = 1
$T2 = -13						; size = 1
__Old_ptr$3 = -12					; size = 4
__Old_size$ = -8					; size = 4
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 2734 :     basic_string& append(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000e	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00011	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00014	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00017	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2735 :         // append [_Ptr, _Ptr + _Count)
; 2736 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00020	89 4d f8	 mov	 DWORD PTR __Old_size$[ebp], ecx

; 2737 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

  00023	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00026	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00029	2b 45 f8	 sub	 eax, DWORD PTR __Old_size$[ebp]
  0002c	39 45 0c	 cmp	 DWORD PTR __Count$[ebp], eax
  0002f	77 4d		 ja	 SHORT $LN2@append

; 2738 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  00031	8b 4d f8	 mov	 ecx, DWORD PTR __Old_size$[ebp]
  00034	03 4d 0c	 add	 ecx, DWORD PTR __Count$[ebp]
  00037	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003a	89 4a 14	 mov	 DWORD PTR [edx+20], ecx

; 2739 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

  0003d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00040	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00045	89 45 f4	 mov	 DWORD PTR __Old_ptr$3[ebp], eax

; 2740 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  00048	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0004b	50		 push	 eax
  0004c	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0004f	51		 push	 ecx
  00050	8b 55 f4	 mov	 edx, DWORD PTR __Old_ptr$3[ebp]
  00053	03 55 f8	 add	 edx, DWORD PTR __Old_size$[ebp]
  00056	52		 push	 edx
  00057	e8 00 00 00 00	 call	 ?move@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Narrow_char_traits<char,int>::move
  0005c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2741 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

  0005f	c6 45 f3 00	 mov	 BYTE PTR $T2[ebp], 0
  00063	8d 45 f3	 lea	 eax, DWORD PTR $T2[ebp]
  00066	50		 push	 eax
  00067	8b 4d f8	 mov	 ecx, DWORD PTR __Old_size$[ebp]
  0006a	03 4d 0c	 add	 ecx, DWORD PTR __Count$[ebp]
  0006d	03 4d f4	 add	 ecx, DWORD PTR __Old_ptr$3[ebp]
  00070	51		 push	 ecx
  00071	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
  00076	83 c4 08	 add	 esp, 8

; 2742 :             return *this;

  00079	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0007c	eb 1e		 jmp	 SHORT $LN1@append
$LN2@append:

; 2743 :         }
; 2744 : 
; 2745 :         return _Reallocate_grow_by(

  0007e	33 d2		 xor	 edx, edx
  00080	88 55 f2	 mov	 BYTE PTR $T1[ebp], dl
  00083	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00086	50		 push	 eax
  00087	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0008a	51		 push	 ecx
  0008b	0f b6 55 f2	 movzx	 edx, BYTE PTR $T1[ebp]
  0008f	52		 push	 edx
  00090	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00093	50		 push	 eax
  00094	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00097	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
$LN1@append:

; 2746 :             _Count,
; 2747 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem* const _Ptr,
; 2748 :                 const size_type _Count) {
; 2749 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 2750 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
; 2751 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 2752 :             },
; 2753 :             _Ptr, _Count);
; 2754 :     }

  0009c	83 c4 10	 add	 esp, 16			; 00000010H
  0009f	3b ec		 cmp	 ebp, esp
  000a1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a6	8b e5		 mov	 esp, ebp
  000a8	5d		 pop	 ebp
  000a9	c2 08 00	 ret	 8
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 2708 :     basic_string& append(const basic_string& _Right) { // append _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2709 :         return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00011	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00014	51		 push	 ecx
  00015	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00018	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0001d	50		 push	 eax
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2710 :     }

  00026	83 c4 04	 add	 esp, 4
  00029	3b ec		 cmp	 ebp, esp
  0002b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; _this$ = ecx

; 2699 :     basic_string& operator+=(_In_z_ const _Elem* const _Ptr) { // append [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2700 :         return append(_Ptr);

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2701 :     }

  0001a	83 c4 04	 add	 esp, 4
  0001d	3b ec		 cmp	 ebp, esp
  0001f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; _this$ = ecx

; 2688 :     basic_string& operator+=(const basic_string& _Right) { // append _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2689 :         return append(_Right);

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2690 :     }

  0001a	83 c4 04	 add	 esp, 4
  0001d	3b ec		 cmp	 ebp, esp
  0001f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 2676 :     basic_string& operator=(_In_z_ const _Elem* const _Ptr) { // assign [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2677 :         return assign(_Ptr);

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2678 :     }

  0001a	83 c4 04	 add	 esp, 4
  0001d	3b ec		 cmp	 ebp, esp
  0001f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
$T1 = -5						; size = 1
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 2661 :     basic_string& operator=(const basic_string& _Right) { // assign _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2662 :         if (this != _STD addressof(_Right)) { // different, assign it

  00017	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
  00020	83 c4 04	 add	 esp, 4
  00023	39 45 fc	 cmp	 DWORD PTR _this$[ebp], eax
  00026	74 16		 je	 SHORT $LN2@operator

; 2663 :             _Copy_assign(_Right, _Choose_pocca<_Alty>{});

  00028	33 c9		 xor	 ecx, ecx
  0002a	88 4d fb	 mov	 BYTE PTR $T1[ebp], cl
  0002d	0f b6 55 fb	 movzx	 edx, BYTE PTR $T1[ebp]
  00031	52		 push	 edx
  00032	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00035	50		 push	 eax
  00036	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	e8 00 00 00 00	 call	 ?_Copy_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy_assign
$LN2@operator:

; 2664 :         }
; 2665 : 
; 2666 :         return *this;

  0003e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 2667 :     }

  00041	83 c4 08	 add	 esp, 8
  00044	3b ec		 cmp	 ebp, esp
  00046	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c2 04 00	 ret	 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring
;	COMDAT ?_Copy_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
___formal$ = 12						; size = 1
?_Copy_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy_assign, COMDAT
; _this$ = ecx

; 2625 :     void _Copy_assign(const basic_string& _Right, false_type) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2626 :         _Pocca(_Getal(), _Right._Getal());

  0000e	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00016	50		 push	 eax
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@@Z ; std::_Pocca<std::allocator<char> >
  00025	83 c4 08	 add	 esp, 8

; 2627 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  00028	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0002b	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0002e	51		 push	 ecx
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00032	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00037	50		 push	 eax
  00038	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2628 :     }

  00040	83 c4 04	 add	 esp, 4
  00043	3b ec		 cmp	 ebp, esp
  00045	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 08 00	 ret	 8
?_Copy_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy_assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
__To_delete$ = -36					; size = 4
_$S10$ = -25						; size = 1
__Alproxy$ = -20					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2597 :     ~basic_string() noexcept { // destroy the string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	89 45 dc	 mov	 DWORD PTR [ebp-36], eax
  0001c	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  0001f	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  00022	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00025	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00028	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	50		 push	 eax
  00033	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00036	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003c	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0003f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 2598 :         _Tidy_deallocate();

  00046	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 2599 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2600 :         auto&& _Alproxy          = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  0004e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00056	50		 push	 eax
  00057	8d 4d e7	 lea	 ecx, DWORD PTR _$S10$[ebp]
  0005a	e8 00 00 00 00	 call	 ??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
  0005f	8d 45 e7	 lea	 eax, DWORD PTR _$S10$[ebp]
  00062	89 45 ec	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 2601 :         const auto _To_delete    = _Mypair._Myval2._Myproxy;

  00065	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00068	8b 11		 mov	 edx, DWORD PTR [ecx]
  0006a	89 55 dc	 mov	 DWORD PTR __To_delete$[ebp], edx

; 2602 :         _Mypair._Myval2._Myproxy = nullptr;

  0006d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00070	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 2603 :         _Delete_plain_internal(_Alproxy, _To_delete);

  00076	8b 4d dc	 mov	 ecx, DWORD PTR __To_delete$[ebp]
  00079	51		 push	 ecx
  0007a	8b 55 ec	 mov	 edx, DWORD PTR __Alproxy$[ebp]
  0007d	52		 push	 edx
  0007e	e8 00 00 00 00	 call	 ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
  00083	83 c4 08	 add	 esp, 8

; 2604 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2605 :     }

  00086	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0008d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00090	e8 00 00 00 00	 call	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
  00095	52		 push	 edx
  00096	8b cd		 mov	 ecx, ebp
  00098	50		 push	 eax
  00099	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN7@basic_stri
  0009f	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000a4	58		 pop	 eax
  000a5	5a		 pop	 edx
  000a6	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a9	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b0	59		 pop	 ecx
  000b1	83 c4 24	 add	 esp, 36			; 00000024H
  000b4	3b ec		 cmp	 ebp, esp
  000b6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000bb	8b e5		 mov	 esp, ebp
  000bd	5d		 pop	 ebp
  000be	c3		 ret	 0
  000bf	90		 npad	 1
$LN7@basic_stri:
  000c0	01 00 00 00	 DD	 1
  000c4	00 00 00 00	 DD	 $LN6@basic_stri
$LN6@basic_stri:
  000c8	e7 ff ff ff	 DD	 -25			; ffffffe7H
  000cc	01 00 00 00	 DD	 1
  000d0	00 00 00 00	 DD	 $LN4@basic_stri
$LN4@basic_stri:
  000d4	24		 DB	 36			; 00000024H
  000d5	53		 DB	 83			; 00000053H
  000d6	31		 DB	 49			; 00000031H
  000d7	30		 DB	 48			; 00000030H
  000d8	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
__ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring
;	COMDAT ?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
___formal$ = 12						; size = 1
?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@U?$integral_constant@_N$00@2@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents, COMDAT
; _this$ = ecx

; 2484 :     void _Take_contents(basic_string& _Right, true_type) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@U?$integral_constant@_N$00@2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 2485 :         // assign by stealing _Right's buffer, memcpy optimization
; 2486 :         // pre: this != &_Right
; 2487 :         // pre: allocator propagation (POCMA) from _Right, if necessary, is complete
; 2488 :         // pre: *this owns no memory, iterators orphaned (note:
; 2489 :         // _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2490 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2491 :         if (_Right._Mypair._Myval2._Large_string_engaged()) {

  0002d	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00030	e8 00 00 00 00	 call	 ?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
  00035	0f b6 c0	 movzx	 eax, al
  00038	85 c0		 test	 eax, eax
  0003a	74 0e		 je	 SHORT $LN2@Take_conte

; 2492 :             // take ownership of _Right's iterators along with its buffer
; 2493 :             _Swap_proxy_and_iterators(_Right);

  0003c	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0003f	51		 push	 ecx
  00040	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	e8 00 00 00 00	 call	 ?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators

; 2494 :         } else {

  00048	eb 08		 jmp	 SHORT $LN3@Take_conte
$LN2@Take_conte:

; 2495 :             _Right._Mypair._Myval2._Orphan_all();

  0004a	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0004d	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all
$LN3@Take_conte:

; 2496 :         }
; 2497 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2498 : 
; 2499 :         _Memcpy_val_from(_Right);

  00052	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00055	52		 push	 edx
  00056	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	e8 00 00 00 00	 call	 ?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Memcpy_val_from

; 2500 :         _Right._Tidy_init();

  0005e	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00061	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init

; 2501 :     }

  00066	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00069	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00070	59		 pop	 ecx
  00071	83 c4 10	 add	 esp, 16			; 00000010H
  00074	3b ec		 cmp	 ebp, esp
  00076	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@U?$integral_constant@_N$00@2@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@U?$integral_constant@_N$00@2@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@U?$integral_constant@_N$00@2@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring
;	COMDAT ?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z
_TEXT	SEGMENT
__Right_data_mem$ = -24					; size = 4
__My_data_mem$ = -20					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Memcpy_val_from, COMDAT
; _this$ = ecx

; 2475 :     void _Memcpy_val_from(const basic_string& _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	c7 45 e8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-24], -858993460 ; ccccccccH
  0001b	c7 45 ec cc cc
	cc cc		 mov	 DWORD PTR [ebp-20], -858993460 ; ccccccccH
  00022	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00029	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002e	33 c5		 xor	 eax, ebp
  00030	50		 push	 eax
  00031	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00034	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003a	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 2476 :         _STL_INTERNAL_CHECK(_Can_memcpy_val); // TRANSITION, if constexpr
; 2477 :         const auto _My_data_mem =

  0003d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 ??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
  00046	83 c4 04	 add	 esp, 4
  00049	83 c0 04	 add	 eax, 4
  0004c	89 45 ec	 mov	 DWORD PTR __My_data_mem$[ebp], eax

; 2478 :             reinterpret_cast<unsigned char*>(_STD addressof(_Mypair._Myval2)) + _Memcpy_val_offset;
; 2479 :         const auto _Right_data_mem =

  0004f	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00052	51		 push	 ecx
  00053	e8 00 00 00 00	 call	 ??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPBV?$_String_val@U?$_Simple_types@D@std@@@0@ABV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > const >
  00058	83 c4 04	 add	 esp, 4
  0005b	83 c0 04	 add	 eax, 4
  0005e	89 45 e8	 mov	 DWORD PTR __Right_data_mem$[ebp], eax

; 2480 :             reinterpret_cast<const unsigned char*>(_STD addressof(_Right._Mypair._Myval2)) + _Memcpy_val_offset;
; 2481 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00061	6a 18		 push	 24			; 00000018H
  00063	8b 55 e8	 mov	 edx, DWORD PTR __Right_data_mem$[ebp]
  00066	52		 push	 edx
  00067	8b 45 ec	 mov	 eax, DWORD PTR __My_data_mem$[ebp]
  0006a	50		 push	 eax
  0006b	e8 00 00 00 00	 call	 _memcpy
  00070	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2482 :     }

  00073	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00076	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007d	59		 pop	 ecx
  0007e	83 c4 18	 add	 esp, 24			; 00000018H
  00081	3b ec		 cmp	 ebp, esp
  00083	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00088	8b e5		 mov	 esp, ebp
  0008a	5d		 pop	 ebp
  0008b	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Memcpy_val_from
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
$T1 = -5						; size = 1
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 2460 :         _NOEXCEPT_COND(noexcept(_Move_assign(_Right, _Choose_pocma<_Alty>{}))) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2461 :         if (this != _STD addressof(_Right)) {

  00017	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  00020	83 c4 04	 add	 esp, 4
  00023	39 45 fc	 cmp	 DWORD PTR _this$[ebp], eax
  00026	74 16		 je	 SHORT $LN2@operator

; 2462 :             _Move_assign(_Right, _Choose_pocma<_Alty>{});

  00028	33 c9		 xor	 ecx, ecx
  0002a	88 4d fb	 mov	 BYTE PTR $T1[ebp], cl
  0002d	0f b6 55 fb	 movzx	 edx, BYTE PTR $T1[ebp]
  00031	52		 push	 edx
  00032	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00035	50		 push	 eax
  00036	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	e8 00 00 00 00	 call	 ?_Move_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@U_Equal_allocators@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Move_assign
$LN2@operator:

; 2463 :         }
; 2464 : 
; 2465 :         return *this;

  0003e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 2466 :     }

  00041	83 c4 08	 add	 esp, 8
  00044	3b ec		 cmp	 ebp, esp
  00046	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c2 04 00	 ret	 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring
;	COMDAT ?_Move_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@U_Equal_allocators@2@@Z
_TEXT	SEGMENT
$T1 = -5						; size = 1
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
___formal$ = 12						; size = 1
?_Move_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@U_Equal_allocators@2@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Move_assign, COMDAT
; _this$ = ecx

; 2431 :     void _Move_assign(basic_string& _Right, _Equal_allocators) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2432 :         _Tidy_deallocate();

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 2433 :         _Pocma(_Getal(), _Right._Getal());

  0001f	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00022	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00027	50		 push	 eax
  00028	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0@Z ; std::_Pocma<std::allocator<char> >
  00036	83 c4 08	 add	 esp, 8

; 2434 :         _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});

  00039	33 c0		 xor	 eax, eax
  0003b	88 45 fb	 mov	 BYTE PTR $T1[ebp], al
  0003e	0f b6 4d fb	 movzx	 ecx, BYTE PTR $T1[ebp]
  00042	51		 push	 ecx
  00043	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00046	52		 push	 edx
  00047	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	e8 00 00 00 00	 call	 ?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@U?$integral_constant@_N$00@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents

; 2435 :     }

  0004f	83 c4 08	 add	 esp, 8
  00052	3b ec		 cmp	 ebp, esp
  00054	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 08 00	 ret	 8
?_Move_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@U_Equal_allocators@2@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Move_assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
$T2 = -19						; size = 1
$T3 = -18						; size = 1
$T4 = -17						; size = 1
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2383 :     basic_string(basic_string&& _Right) noexcept : _Mypair(_One_then_variadic_args_t(), _STD move(_Right._Getal())) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	c7 45 ec cc cc
	cc cc		 mov	 DWORD PTR [ebp-20], -858993460 ; ccccccccH
  0001b	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00027	33 c5		 xor	 eax, ebp
  00029	50		 push	 eax
  0002a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0002d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00033	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00036	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00039	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 ??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ; std::move<std::allocator<char> &>
  00044	83 c4 04	 add	 esp, 4
  00047	50		 push	 eax
  00048	0f b6 45 ef	 movzx	 eax, BYTE PTR $T4[ebp]
  0004c	50		 push	 eax
  0004d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	e8 00 00 00 00	 call	 ??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
  00055	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 2384 :         // construct by moving _Right
; 2385 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

  0005c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005f	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00064	50		 push	 eax
  00065	8d 4d ee	 lea	 ecx, DWORD PTR $T3[ebp]
  00068	e8 00 00 00 00	 call	 ??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
  0006d	50		 push	 eax
  0006e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00071	e8 00 00 00 00	 call	 ??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >

; 2386 :         _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});

  00076	33 c9		 xor	 ecx, ecx
  00078	88 4d ed	 mov	 BYTE PTR $T2[ebp], cl
  0007b	0f b6 55 ed	 movzx	 edx, BYTE PTR $T2[ebp]
  0007f	52		 push	 edx
  00080	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00083	50		 push	 eax
  00084	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00087	e8 00 00 00 00	 call	 ?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@U?$integral_constant@_N$00@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents

; 2387 :     }

  0008c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00093	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00096	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00099	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a0	59		 pop	 ecx
  000a1	83 c4 14	 add	 esp, 20			; 00000014H
  000a4	3b ec		 cmp	 ebp, esp
  000a6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ab	8b e5		 mov	 esp, ebp
  000ad	5d		 pop	 ebp
  000ae	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
_TEXT	SEGMENT
$T2 = -49						; size = 1
__Proxy$ = -44						; size = 8
_$S12$ = -25						; size = 1
__Alproxy$ = -20					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2297 :     basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t()) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 28	 sub	 esp, 40			; 00000028H
  00014	57		 push	 edi
  00015	51		 push	 ecx
  00016	8d 7d cc	 lea	 edi, DWORD PTR [ebp-52]
  00019	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  0001e	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00023	f3 ab		 rep stosd
  00025	59		 pop	 ecx
  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002b	33 c5		 xor	 eax, ebp
  0002d	50		 push	 eax
  0002e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00031	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00037	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0003a	0f b6 45 cf	 movzx	 eax, BYTE PTR $T2[ebp]
  0003e	50		 push	 eax
  0003f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e8 00 00 00 00	 call	 ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
  00047	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 2298 :         // construct from [_Ptr, <null>)
; 2299 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  0004e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00056	50		 push	 eax
  00057	8d 4d e7	 lea	 ecx, DWORD PTR _$S12$[ebp]
  0005a	e8 00 00 00 00	 call	 ??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
  0005f	8d 4d e7	 lea	 ecx, DWORD PTR _$S12$[ebp]
  00062	89 4d ec	 mov	 DWORD PTR __Alproxy$[ebp], ecx

; 2300 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);

  00065	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00068	52		 push	 edx
  00069	8b 45 ec	 mov	 eax, DWORD PTR __Alproxy$[ebp]
  0006c	50		 push	 eax
  0006d	8d 4d d4	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  00070	e8 00 00 00 00	 call	 ??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  00075	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 2301 :         _Tidy_init();

  00079	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0007c	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init

; 2302 :         assign(_Ptr);

  00081	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00084	51		 push	 ecx
  00085	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00088	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2303 :         _Proxy._Release();

  0008d	8d 4d d4	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  00090	e8 00 00 00 00	 call	 ?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ ; std::_Basic_container_proxy_ptr12::_Release

; 2304 :     }

  00095	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00099	8d 4d d4	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  0009c	e8 00 00 00 00	 call	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  000a1	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000a8	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000ab	52		 push	 edx
  000ac	8b cd		 mov	 ecx, ebp
  000ae	50		 push	 eax
  000af	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN9@basic_stri
  000b5	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000ba	58		 pop	 eax
  000bb	5a		 pop	 edx
  000bc	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000bf	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000c6	59		 pop	 ecx
  000c7	5f		 pop	 edi
  000c8	83 c4 34	 add	 esp, 52			; 00000034H
  000cb	3b ec		 cmp	 ebp, esp
  000cd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d2	8b e5		 mov	 esp, ebp
  000d4	5d		 pop	 ebp
  000d5	c2 04 00	 ret	 4
$LN9@basic_stri:
  000d8	02 00 00 00	 DD	 2
  000dc	00 00 00 00	 DD	 $LN8@basic_stri
$LN8@basic_stri:
  000e0	e7 ff ff ff	 DD	 -25			; ffffffe7H
  000e4	01 00 00 00	 DD	 1
  000e8	00 00 00 00	 DD	 $LN5@basic_stri
  000ec	d4 ff ff ff	 DD	 -44			; ffffffd4H
  000f0	08 00 00 00	 DD	 8
  000f4	00 00 00 00	 DD	 $LN6@basic_stri
$LN6@basic_stri:
  000f8	5f		 DB	 95			; 0000005fH
  000f9	50		 DB	 80			; 00000050H
  000fa	72		 DB	 114			; 00000072H
  000fb	6f		 DB	 111			; 0000006fH
  000fc	78		 DB	 120			; 00000078H
  000fd	79		 DB	 121			; 00000079H
  000fe	00		 DB	 0
$LN5@basic_stri:
  000ff	24		 DB	 36			; 00000024H
  00100	53		 DB	 83			; 00000053H
  00101	31		 DB	 49			; 00000031H
  00102	32		 DB	 50			; 00000032H
  00103	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z$1:
  00008	8d 4d d4	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a d0	 mov	 ecx, DWORD PTR [edx-48]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
$T2 = -18						; size = 1
$T3 = -17						; size = 1
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2247 :     basic_string() _NOEXCEPT_COND(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t()) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	c7 45 ec cc cc
	cc cc		 mov	 DWORD PTR [ebp-20], -858993460 ; ccccccccH
  0001b	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00027	33 c5		 xor	 eax, ebp
  00029	50		 push	 eax
  0002a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0002d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00033	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00036	0f b6 45 ef	 movzx	 eax, BYTE PTR $T3[ebp]
  0003a	50		 push	 eax
  0003b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	e8 00 00 00 00	 call	 ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
  00043	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 2248 :         // construct empty string
; 2249 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

  0004a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00052	50		 push	 eax
  00053	8d 4d ee	 lea	 ecx, DWORD PTR $T2[ebp]
  00056	e8 00 00 00 00	 call	 ??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
  0005b	50		 push	 eax
  0005c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005f	e8 00 00 00 00	 call	 ??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >

; 2250 :         _Tidy_init();

  00064	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00067	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init

; 2251 :     }

  0006c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00073	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00076	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00079	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00080	59		 pop	 ecx
  00081	83 c4 14	 add	 esp, 20			; 00000014H
  00084	3b ec		 cmp	 ebp, esp
  00086	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008b	8b e5		 mov	 esp, ebp
  0008d	5d		 pop	 ebp
  0008e	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00034	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0003b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	83 c1 04	 add	 ecx, 4
  00041	e8 00 00 00 00	 call	 ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
  00046	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00049	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00050	59		 pop	 ecx
  00051	83 c4 10	 add	 esp, 16			; 00000010H
  00054	3b ec		 cmp	 ebp, esp
  00056	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	e9 00 00 00 00	 jmp	 ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
__ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty, COMDAT
; _this$ = ecx

; 2148 :         ~_Bxty() noexcept {} // user-provided, for fancy pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b e5		 mov	 esp, ebp
  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty, COMDAT
; _this$ = ecx

; 2146 :         _Bxty() {} // user-provided, for fancy pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring
;	COMDAT ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ
_TEXT	SEGMENT
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Xran, COMDAT

; 2136 :     [[noreturn]] static void _Xran() { // report an out_of_range error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2137 :         _Xout_of_range("invalid string position");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position@
  00008	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN2@Xran:

; 2138 :     }

  0000d	3b ec		 cmp	 ebp, esp
  0000f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring
;	COMDAT ?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEXI@Z PROC ; std::_String_val<std::_Simple_types<char> >::_Check_offset, COMDAT
; _this$ = ecx

; 2124 :     void _Check_offset(const size_type _Off) const { // checks whether _Off is in the bounds of [0, size()]

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2125 :         if (_Mysize < _Off) {

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00014	3b 4d 08	 cmp	 ecx, DWORD PTR __Off$[ebp]
  00017	73 05		 jae	 SHORT $LN3@Check_offs

; 2126 :             _Xran();

  00019	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
$LN3@Check_offs:

; 2127 :         }
; 2128 :     }

  0001e	83 c4 04	 add	 esp, 4
  00021	3b ec		 cmp	 ebp, esp
  00023	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEXI@Z ENDP ; std::_String_val<std::_Simple_types<char> >::_Check_offset
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring
;	COMDAT ?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
tv66 = -8						; size = 4
_this$ = -4						; size = 4
?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged, COMDAT
; _this$ = ecx

; 2120 :     bool _Large_string_engaged() const { // returns whether the large string mode (allocated memory) is engaged

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2121 :         return _BUF_SIZE <= _Myres;

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	83 78 18 10	 cmp	 DWORD PTR [eax+24], 16	; 00000010H
  0001e	72 09		 jb	 SHORT $LN3@Large_stri
  00020	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
  00027	eb 07		 jmp	 SHORT $LN4@Large_stri
$LN3@Large_stri:
  00029	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
$LN4@Large_stri:
  00030	8a 45 f8	 mov	 al, BYTE PTR tv66[ebp]

; 2122 :     }

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
__Result$ = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2111 :     const value_type* _Myptr() const { // determine current pointer to buffer for immutable string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2112 :         const value_type* _Result = _Bx._Buf;

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	89 45 f8	 mov	 DWORD PTR __Result$[ebp], eax

; 2113 :         if (_Large_string_engaged()) {

  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
  00028	0f b6 c8	 movzx	 ecx, al
  0002b	85 c9		 test	 ecx, ecx
  0002d	74 12		 je	 SHORT $LN2@Myptr

; 2114 :             _Result = _Unfancy(_Bx._Ptr);

  0002f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00032	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPADPAD@Z ; std::_Unfancy<char>
  0003b	83 c4 04	 add	 esp, 4
  0003e	89 45 f8	 mov	 DWORD PTR __Result$[ebp], eax
$LN2@Myptr:

; 2115 :         }
; 2116 : 
; 2117 :         return _Result;

  00041	8b 45 f8	 mov	 eax, DWORD PTR __Result$[ebp]

; 2118 :     }

  00044	83 c4 08	 add	 esp, 8
  00047	3b ec		 cmp	 ebp, esp
  00049	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
__Result$ = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2102 :     value_type* _Myptr() { // determine current pointer to buffer for mutable string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2103 :         value_type* _Result = _Bx._Buf;

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	89 45 f8	 mov	 DWORD PTR __Result$[ebp], eax

; 2104 :         if (_Large_string_engaged()) {

  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
  00028	0f b6 c8	 movzx	 ecx, al
  0002b	85 c9		 test	 ecx, ecx
  0002d	74 12		 je	 SHORT $LN2@Myptr

; 2105 :             _Result = _Unfancy(_Bx._Ptr);

  0002f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00032	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPADPAD@Z ; std::_Unfancy<char>
  0003b	83 c4 04	 add	 esp, 4
  0003e	89 45 f8	 mov	 DWORD PTR __Result$[ebp], eax
$LN2@Myptr:

; 2106 :         }
; 2107 : 
; 2108 :         return _Result;

  00041	8b 45 f8	 mov	 eax, DWORD PTR __Result$[ebp]

; 2109 :     }

  00044	83 c4 08	 add	 esp, 8
  00047	3b ec		 cmp	 ebp, esp
  00049	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 2092 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12
  00035	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	83 c1 04	 add	 ecx, 4
  0003b	e8 00 00 00 00	 call	 ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
  00040	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00047	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0
  00051	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
  0005b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00062	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00065	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00068	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006f	59		 pop	 ecx
  00070	83 c4 10	 add	 esp, 16			; 00000010H
  00073	3b ec		 cmp	 ebp, esp
  00075	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	e9 00 00 00 00	 jmp	 ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
__ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::max_size, COMDAT

; 766  :     _NODISCARD static size_type max_size(const _Alloc&) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 767  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00003	83 c8 ff	 or	 eax, -1

; 768  :     }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 870  :     _NODISCARD _DECLSPEC_ALLOCATOR _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 871  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$_Get_size_of_n@$00@std@@YAII@Z ; std::_Get_size_of_n<1>
  00017	83 c4 04	 add	 esp, 4
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00020	83 c4 04	 add	 esp, 4

; 872  :     }

  00023	83 c4 04	 add	 esp, 4
  00026	3b ec		 cmp	 ebp, esp
  00028	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXQADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXQADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 865  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 866  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 867  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000e	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00011	50		 push	 eax
  00012	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00015	51		 push	 ecx
  00016	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0001b	83 c4 08	 add	 esp, 8

; 868  :     }

  0001e	83 c4 04	 add	 esp, 4
  00021	3b ec		 cmp	 ebp, esp
  00023	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 08 00	 ret	 8
?deallocate@?$allocator@D@std@@QAEXQADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 859  :     constexpr allocator() noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring
;	COMDAT ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z PROC	; std::_Narrow_char_traits<char,int>::assign, COMDAT

; 377  :     static _CONSTEXPR17 void assign(_Elem& _Left, const _Elem& _Right) noexcept { // assign an element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 378  :         _Left = _Right;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00009	8a 11		 mov	 dl, BYTE PTR [ecx]
  0000b	88 10		 mov	 BYTE PTR [eax], dl

; 379  :     }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ENDP	; std::_Narrow_char_traits<char,int>::assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring
;	COMDAT ?move@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z PROC	; std::_Narrow_char_traits<char,int>::move, COMDAT

; 366  :         const size_t _Count) noexcept { // strengthened

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?move@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 367  :         // copy [_First2, _First2 + _Count) to [_First1, ...)
; 368  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

  00022	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00025	50		 push	 eax
  00026	8b 4d 0c	 mov	 ecx, DWORD PTR __First2$[ebp]
  00029	51		 push	 ecx
  0002a	8b 55 08	 mov	 edx, DWORD PTR __First1$[ebp]
  0002d	52		 push	 edx
  0002e	e8 00 00 00 00	 call	 _memmove
  00033	83 c4 0c	 add	 esp, 12			; 0000000cH

; 369  :     }

  00036	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00039	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00040	59		 pop	 ecx
  00041	83 c4 0c	 add	 esp, 12			; 0000000cH
  00044	3b ec		 cmp	 ebp, esp
  00046	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?move@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?move@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?move@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z ENDP	; std::_Narrow_char_traits<char,int>::move
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring
;	COMDAT ?copy@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z PROC	; std::_Narrow_char_traits<char,int>::copy, COMDAT

; 331  :         const size_t _Count) noexcept { // strengthened

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?copy@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 332  :         // copy [_First2, _First2 + _Count) to [_First1, ...)
; 333  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  00022	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00025	50		 push	 eax
  00026	8b 4d 0c	 mov	 ecx, DWORD PTR __First2$[ebp]
  00029	51		 push	 ecx
  0002a	8b 55 08	 mov	 edx, DWORD PTR __First1$[ebp]
  0002d	52		 push	 edx
  0002e	e8 00 00 00 00	 call	 _memcpy
  00033	83 c4 0c	 add	 esp, 12			; 0000000cH

; 334  :     }

  00036	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00039	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00040	59		 pop	 ecx
  00041	83 c4 0c	 add	 esp, 12			; 0000000cH
  00044	3b ec		 cmp	 ebp, esp
  00046	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?copy@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?copy@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?copy@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z ENDP	; std::_Narrow_char_traits<char,int>::copy
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring
;	COMDAT ?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z PROC	; std::_Narrow_char_traits<char,int>::length, COMDAT

; 310  :     _NODISCARD static _CONSTEXPR17 size_t length(_In_z_ const _Elem* const _First) noexcept { // strengthened

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 311  :         // find length of null-terminated string
; 312  : #if _HAS_CXX17
; 313  : #if _HAS_CHAR8_T
; 314  :         if constexpr (is_same_v<_Elem, char8_t>) {
; 315  : #if _HAS_U8_INTRINSICS
; 316  :             return __builtin_u8strlen(_First);
; 317  : #else // ^^^ use u8 intrinsics / no u8 intrinsics vvv
; 318  :             return _Char_traits<_Elem, _Int_type>::length(_First);
; 319  : #endif // _HAS_U8_INTRINSICS
; 320  :         } else
; 321  : #endif // _HAS_CHAR8_T
; 322  :         {
; 323  :             return __builtin_strlen(_First);
; 324  :         }
; 325  : #else // _HAS_CXX17
; 326  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00022	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _strlen
  0002b	83 c4 04	 add	 esp, 4

; 327  : #endif // _HAS_CXX17
; 328  :     }

  0002e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00031	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00038	59		 pop	 ecx
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003c	3b ec		 cmp	 ebp, esp
  0003e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z ENDP	; std::_Narrow_char_traits<char,int>::length
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\utility
;	COMDAT ??$exchange@U_Thrd_imp_t@@U1@@std@@YA?AU_Thrd_imp_t@@AAU1@$$QAU1@@Z
_TEXT	SEGMENT
__Old_val$ = -12					; size = 8
__Val$ = 8						; size = 4
__New_val$ = 12						; size = 4
??$exchange@U_Thrd_imp_t@@U1@@std@@YA?AU_Thrd_imp_t@@AAU1@$$QAU1@@Z PROC ; std::exchange<_Thrd_imp_t,_Thrd_imp_t>, COMDAT

; 526  : _Ty exchange(_Ty& _Val, _Other&& _New_val) { // assign _New_val to _Val, return previous _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000e	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00011	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00014	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 527  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00017	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0001a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001c	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0001f	89 4d f4	 mov	 DWORD PTR __Old_val$[ebp], ecx
  00022	89 55 f8	 mov	 DWORD PTR __Old_val$[ebp+4], edx

; 528  :     _Val         = static_cast<_Other&&>(_New_val);

  00025	8b 45 0c	 mov	 eax, DWORD PTR __New_val$[ebp]
  00028	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002a	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0002d	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00030	89 08		 mov	 DWORD PTR [eax], ecx
  00032	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 529  :     return _Old_val;

  00035	8b 45 f4	 mov	 eax, DWORD PTR __Old_val$[ebp]
  00038	8b 55 f8	 mov	 edx, DWORD PTR __Old_val$[ebp+4]

; 530  : }

  0003b	52		 push	 edx
  0003c	8b cd		 mov	 ecx, ebp
  0003e	50		 push	 eax
  0003f	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@exchange
  00045	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0004a	58		 pop	 eax
  0004b	5a		 pop	 edx
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
$LN5@exchange:
  00050	01 00 00 00	 DD	 1
  00054	00 00 00 00	 DD	 $LN4@exchange
$LN4@exchange:
  00058	f4 ff ff ff	 DD	 -12			; fffffff4H
  0005c	08 00 00 00	 DD	 8
  00060	00 00 00 00	 DD	 $LN3@exchange
$LN3@exchange:
  00064	5f		 DB	 95			; 0000005fH
  00065	4f		 DB	 79			; 0000004fH
  00066	6c		 DB	 108			; 0000006cH
  00067	64		 DB	 100			; 00000064H
  00068	5f		 DB	 95			; 0000005fH
  00069	76		 DB	 118			; 00000076H
  0006a	61		 DB	 97			; 00000061H
  0006b	6c		 DB	 108			; 0000006cH
  0006c	00		 DB	 0
??$exchange@U_Thrd_imp_t@@U1@@std@@YA?AU_Thrd_imp_t@@AAU1@$$QAU1@@Z ENDP ; std::exchange<_Thrd_imp_t,_Thrd_imp_t>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\thread
;	COMDAT ?join@thread@std@@QAEXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 8
_this$ = -4						; size = 4
?join@thread@std@@QAEXXZ PROC				; std::thread::join, COMDAT
; _this$ = ecx

; 104  :     void join() { // join thread

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 105  :         if (!joinable()) {

  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	e8 00 00 00 00	 call	 ?joinable@thread@std@@QBE_NXZ ; std::thread::joinable
  00026	0f b6 c0	 movzx	 eax, al
  00029	85 c0		 test	 eax, eax
  0002b	75 07		 jne	 SHORT $LN2@join

; 106  :             _Throw_Cpp_error(_INVALID_ARGUMENT);

  0002d	6a 01		 push	 1
  0002f	e8 00 00 00 00	 call	 ?_Throw_Cpp_error@std@@YAXH@Z ; std::_Throw_Cpp_error
$LN2@join:

; 107  :         }
; 108  : 
; 109  :         if (_Thr._Id == _Thrd_id()) {

  00034	e8 00 00 00 00	 call	 __Thrd_id
  00039	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	39 41 04	 cmp	 DWORD PTR [ecx+4], eax
  0003f	75 07		 jne	 SHORT $LN3@join

; 110  :             _Throw_Cpp_error(_RESOURCE_DEADLOCK_WOULD_OCCUR);

  00041	6a 05		 push	 5
  00043	e8 00 00 00 00	 call	 ?_Throw_Cpp_error@std@@YAXH@Z ; std::_Throw_Cpp_error
$LN3@join:

; 111  :         }
; 112  : 
; 113  :         if (_Thrd_join(_Thr, nullptr) != _Thrd_success) {

  00048	6a 00		 push	 0
  0004a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0004d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00050	50		 push	 eax
  00051	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00053	51		 push	 ecx
  00054	e8 00 00 00 00	 call	 __Thrd_join
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005c	85 c0		 test	 eax, eax
  0005e	74 07		 je	 SHORT $LN4@join

; 114  :             _Throw_Cpp_error(_NO_SUCH_PROCESS);

  00060	6a 02		 push	 2
  00062	e8 00 00 00 00	 call	 ?_Throw_Cpp_error@std@@YAXH@Z ; std::_Throw_Cpp_error
$LN4@join:

; 115  :         }
; 116  : 
; 117  :         _Thr = {};

  00067	33 d2		 xor	 edx, edx
  00069	89 55 f4	 mov	 DWORD PTR $T1[ebp], edx
  0006c	89 55 f8	 mov	 DWORD PTR $T1[ebp+4], edx
  0006f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00072	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  00075	89 08		 mov	 DWORD PTR [eax], ecx
  00077	8b 55 f8	 mov	 edx, DWORD PTR $T1[ebp+4]
  0007a	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN5@join:

; 118  :     }

  0007d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00080	3b ec		 cmp	 ebp, esp
  00082	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00087	8b e5		 mov	 esp, ebp
  00089	5d		 pop	 ebp
  0008a	c3		 ret	 0
?join@thread@std@@QAEXXZ ENDP				; std::thread::join
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\thread
;	COMDAT ?joinable@thread@std@@QBE_NXZ
_TEXT	SEGMENT
tv67 = -8						; size = 4
_this$ = -4						; size = 4
?joinable@thread@std@@QBE_NXZ PROC			; std::thread::joinable, COMDAT
; _this$ = ecx

; 100  :     _NODISCARD bool joinable() const noexcept { // return true if this thread can be joined

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 101  :         return _Thr._Id != 0;

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0001e	74 09		 je	 SHORT $LN3@joinable
  00020	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv67[ebp], 1
  00027	eb 07		 jmp	 SHORT $LN4@joinable
$LN3@joinable:
  00029	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
$LN4@joinable:
  00030	8a 45 f8	 mov	 al, BYTE PTR tv67[ebp]

; 102  :     }

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
?joinable@thread@std@@QBE_NXZ ENDP			; std::thread::joinable
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\thread
;	COMDAT ??4thread@std@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
$T2 = -32						; size = 8
$T3 = -24						; size = 8
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Other$ = 8						; size = 4
??4thread@std@@QAEAAV01@$$QAV01@@Z PROC			; std::thread::operator=, COMDAT
; _this$ = ecx

; 83   :     thread& operator=(thread&& _Other) noexcept { // move from _Other

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??4thread@std@@QAEAAV01@$$QAV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	56		 push	 esi
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  0001d	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  00020	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00023	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00026	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00029	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002e	33 c5		 xor	 eax, ebp
  00030	50		 push	 eax
  00031	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00034	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003a	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 84   : 
; 85   :         if (joinable()) {

  0003d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00040	e8 00 00 00 00	 call	 ?joinable@thread@std@@QBE_NXZ ; std::thread::joinable
  00045	0f b6 c0	 movzx	 eax, al
  00048	85 c0		 test	 eax, eax
  0004a	74 0f		 je	 SHORT $LN2@operator

; 86   :             _STD terminate();

  0004c	8b f4		 mov	 esi, esp
  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__terminate
  00054	3b f4		 cmp	 esi, esp
  00056	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@operator:

; 87   :         }
; 88   : 
; 89   :         _Thr = _STD exchange(_Other._Thr, {});

  0005b	33 c9		 xor	 ecx, ecx
  0005d	89 4d e0	 mov	 DWORD PTR $T2[ebp], ecx
  00060	89 4d e4	 mov	 DWORD PTR $T2[ebp+4], ecx
  00063	8d 55 e0	 lea	 edx, DWORD PTR $T2[ebp]
  00066	52		 push	 edx
  00067	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  0006a	50		 push	 eax
  0006b	e8 00 00 00 00	 call	 ??$exchange@U_Thrd_imp_t@@U1@@std@@YA?AU_Thrd_imp_t@@AAU1@$$QAU1@@Z ; std::exchange<_Thrd_imp_t,_Thrd_imp_t>
  00070	83 c4 08	 add	 esp, 8
  00073	89 45 e8	 mov	 DWORD PTR $T3[ebp], eax
  00076	89 55 ec	 mov	 DWORD PTR $T3[ebp+4], edx
  00079	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0007c	8b 55 e8	 mov	 edx, DWORD PTR $T3[ebp]
  0007f	89 11		 mov	 DWORD PTR [ecx], edx
  00081	8b 45 ec	 mov	 eax, DWORD PTR $T3[ebp+4]
  00084	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 90   :         return *this;

  00087	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
$LN3@operator:

; 91   :     }

  0008a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0008d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00094	59		 pop	 ecx
  00095	5e		 pop	 esi
  00096	83 c4 20	 add	 esp, 32			; 00000020H
  00099	3b ec		 cmp	 ebp, esp
  0009b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a0	8b e5		 mov	 esp, ebp
  000a2	5d		 pop	 ebp
  000a3	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??4thread@std@@QAEAAV01@$$QAV01@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??4thread@std@@QAEAAV01@$$QAV01@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??4thread@std@@QAEAAV01@$$QAV01@@Z ENDP			; std::thread::operator=
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\thread
;	COMDAT ??1thread@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1thread@std@@QAE@XZ PROC				; std::thread::~thread, COMDAT
; _this$ = ecx

; 74   :     ~thread() noexcept { // clean up

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 75   :         if (joinable()) {

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?joinable@thread@std@@QBE_NXZ ; std::thread::joinable
  00017	0f b6 c0	 movzx	 eax, al
  0001a	85 c0		 test	 eax, eax
  0001c	74 0f		 je	 SHORT $LN3@thread

; 76   :             _STD terminate();

  0001e	8b f4		 mov	 esi, esp
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__terminate
  00026	3b f4		 cmp	 esi, esp
  00028	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@thread:

; 77   :         }
; 78   :     }

  0002d	5e		 pop	 esi
  0002e	83 c4 04	 add	 esp, 4
  00031	3b ec		 cmp	 ebp, esp
  00033	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??1thread@std@@QAE@XZ ENDP				; std::thread::~thread
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\thread
;	COMDAT ??0thread@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0thread@std@@QAE@XZ PROC				; std::thread::thread, COMDAT
; _this$ = ecx

; 31   :     thread() noexcept : _Thr{} { // construct with no thread

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	33 c0		 xor	 eax, eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	89 01		 mov	 DWORD PTR [ecx], eax
  00015	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 32   :     }

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??0thread@std@@QAE@XZ ENDP				; std::thread::thread
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\memory
;	COMDAT ?_Decwref@_Ref_count_base@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Decwref@_Ref_count_base@std@@QAEXXZ PROC		; std::_Ref_count_base::_Decwref, COMDAT
; _this$ = ecx

; 657  :     void _Decwref() noexcept { // decrement weak reference count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 658  :         if (_MT_DECR(_Weaks) == 0) {

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	83 c0 08	 add	 eax, 8
  00015	83 c9 ff	 or	 ecx, -1
  00018	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  0001c	49		 dec	 ecx
  0001d	75 16		 jne	 SHORT $LN1@Decwref

; 659  :             _Delete_this();

  0001f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00022	8b 02		 mov	 eax, DWORD PTR [edx]
  00024	8b f4		 mov	 esi, esp
  00026	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0002c	ff d2		 call	 edx
  0002e	3b f4		 cmp	 esi, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@Decwref:

; 660  :         }
; 661  :     }

  00035	5e		 pop	 esi
  00036	83 c4 04	 add	 esp, 4
  00039	3b ec		 cmp	 ebp, esp
  0003b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
?_Decwref@_Ref_count_base@std@@QAEXXZ ENDP		; std::_Ref_count_base::_Decwref
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\memory
;	COMDAT ?_Decref@_Ref_count_base@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Decref@_Ref_count_base@std@@QAEXXZ PROC		; std::_Ref_count_base::_Decref, COMDAT
; _this$ = ecx

; 650  :     void _Decref() noexcept { // decrement use count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 651  :         if (_MT_DECR(_Uses) == 0) {

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	83 c9 ff	 or	 ecx, -1
  00018	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  0001c	49		 dec	 ecx
  0001d	75 1d		 jne	 SHORT $LN1@Decref

; 652  :             _Destroy();

  0001f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00022	8b 02		 mov	 eax, DWORD PTR [edx]
  00024	8b f4		 mov	 esi, esp
  00026	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	8b 10		 mov	 edx, DWORD PTR [eax]
  0002b	ff d2		 call	 edx
  0002d	3b f4		 cmp	 esi, esp
  0002f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 653  :             _Decwref();

  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	e8 00 00 00 00	 call	 ?_Decwref@_Ref_count_base@std@@QAEXXZ ; std::_Ref_count_base::_Decwref
$LN1@Decref:

; 654  :         }
; 655  :     }

  0003c	5e		 pop	 esi
  0003d	83 c4 04	 add	 esp, 4
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
?_Decref@_Ref_count_base@std@@QAEXXZ ENDP		; std::_Ref_count_base::_Decref
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\memory
;	COMDAT ?_Incref@_Ref_count_base@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Incref@_Ref_count_base@std@@QAEXXZ PROC		; std::_Ref_count_base::_Incref, COMDAT
; _this$ = ecx

; 642  :     void _Incref() noexcept { // increment use count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 643  :         _MT_INCR(_Uses);

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	83 c0 04	 add	 eax, 4
  00014	f0 ff 00	 lock	  inc	 DWORD PTR [eax]

; 644  :     }

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?_Incref@_Ref_count_base@std@@QAEXXZ ENDP		; std::_Ref_count_base::_Incref
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ PROC	; std::_Basic_container_proxy_ptr12::_Release, COMDAT
; _this$ = ecx

; 1348 :     void _Release() noexcept { // disengage this _Basic_container_proxy_ptr12

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1349 :         _Ptr = nullptr;

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1350 :     }

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ ENDP	; std::_Basic_container_proxy_ptr12::_Release
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ?_Swap_proxy_and_iterators@_Container_base12@std@@QAEXAAU12@@Z
_TEXT	SEGMENT
__Temp$ = -32						; size = 4
__Lock$ = -24						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
?_Swap_proxy_and_iterators@_Container_base12@std@@QAEXAAU12@@Z PROC ; std::_Container_base12::_Swap_proxy_and_iterators, COMDAT
; _this$ = ecx

; 1302 : inline void _Container_base12::_Swap_proxy_and_iterators(_Container_base12& _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Swap_proxy_and_iterators@_Container_base12@std@@QAEXAAU12@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	56		 push	 esi
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  0001d	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  00020	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00023	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00026	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00029	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002e	33 c5		 xor	 eax, ebp
  00030	50		 push	 eax
  00031	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00034	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003a	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1303 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1304 :     _Lockit _Lock(_LOCK_DEBUG);

  0003d	8b f4		 mov	 esi, esp
  0003f	6a 03		 push	 3
  00041	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
  0004a	3b f4		 cmp	 esi, esp
  0004c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00051	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1305 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1306 : 
; 1307 :     _Container_proxy* _Temp = _Myproxy;

  00058	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005d	89 4d e0	 mov	 DWORD PTR __Temp$[ebp], ecx

; 1308 :     _Myproxy                = _Right._Myproxy;

  00060	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00063	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00066	8b 08		 mov	 ecx, DWORD PTR [eax]
  00068	89 0a		 mov	 DWORD PTR [edx], ecx

; 1309 :     _Right._Myproxy         = _Temp;

  0006a	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  0006d	8b 45 e0	 mov	 eax, DWORD PTR __Temp$[ebp]
  00070	89 02		 mov	 DWORD PTR [edx], eax

; 1310 : 
; 1311 :     if (_Myproxy) {

  00072	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00078	74 0a		 je	 SHORT $LN2@Swap_proxy

; 1312 :         _Myproxy->_Mycont = this;

  0007a	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0007d	8b 02		 mov	 eax, DWORD PTR [edx]
  0007f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00082	89 08		 mov	 DWORD PTR [eax], ecx
$LN2@Swap_proxy:

; 1313 :     }
; 1314 : 
; 1315 :     if (_Right._Myproxy) {

  00084	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00087	83 3a 00	 cmp	 DWORD PTR [edx], 0
  0008a	74 0a		 je	 SHORT $LN3@Swap_proxy

; 1316 :         _Right._Myproxy->_Mycont = &_Right;

  0008c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0008f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00091	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00094	89 11		 mov	 DWORD PTR [ecx], edx
$LN3@Swap_proxy:

; 1317 :     }
; 1318 : }

  00096	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0009d	8b f4		 mov	 esi, esp
  0009f	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$[ebp]
  000a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  000a8	3b f4		 cmp	 esi, esp
  000aa	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000af	52		 push	 edx
  000b0	8b cd		 mov	 ecx, ebp
  000b2	50		 push	 eax
  000b3	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN9@Swap_proxy
  000b9	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000be	58		 pop	 eax
  000bf	5a		 pop	 edx
  000c0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ca	59		 pop	 ecx
  000cb	5e		 pop	 esi
  000cc	83 c4 20	 add	 esp, 32			; 00000020H
  000cf	3b ec		 cmp	 ebp, esp
  000d1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d6	8b e5		 mov	 esp, ebp
  000d8	5d		 pop	 ebp
  000d9	c2 04 00	 ret	 4
$LN9@Swap_proxy:
  000dc	01 00 00 00	 DD	 1
  000e0	00 00 00 00	 DD	 $LN8@Swap_proxy
$LN8@Swap_proxy:
  000e4	e8 ff ff ff	 DD	 -24			; ffffffe8H
  000e8	04 00 00 00	 DD	 4
  000ec	00 00 00 00	 DD	 $LN6@Swap_proxy
$LN6@Swap_proxy:
  000f0	5f		 DB	 95			; 0000005fH
  000f1	4c		 DB	 76			; 0000004cH
  000f2	6f		 DB	 111			; 0000006fH
  000f3	63		 DB	 99			; 00000063H
  000f4	6b		 DB	 107			; 0000006bH
  000f5	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Swap_proxy_and_iterators@_Container_base12@std@@QAEXAAU12@@Z$0:
  00000	8b f4		 mov	 esi, esp
  00002	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  0000b	3b f4		 cmp	 esi, esp
  0000d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00012	c3		 ret	 0
__ehhandler$?_Swap_proxy_and_iterators@_Container_base12@std@@QAEXAAU12@@Z:
  00013	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00017	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001a	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Swap_proxy_and_iterators@_Container_base12@std@@QAEXAAU12@@Z
  00029	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Swap_proxy_and_iterators@_Container_base12@std@@QAEXAAU12@@Z ENDP ; std::_Container_base12::_Swap_proxy_and_iterators
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ?_Orphan_all@_Container_base12@std@@QAEXXZ
_TEXT	SEGMENT
__Pnext$2 = -32						; size = 4
__Lock$3 = -24						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?_Orphan_all@_Container_base12@std@@QAEXXZ PROC		; std::_Container_base12::_Orphan_all, COMDAT
; _this$ = ecx

; 1288 : inline void _Container_base12::_Orphan_all() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	56		 push	 esi
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  0001d	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  00020	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00023	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00026	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00029	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002e	33 c5		 xor	 eax, ebp
  00030	50		 push	 eax
  00031	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00034	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003a	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1289 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1290 :     if (_Myproxy) { // proxy allocated, drain it

  0003d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00040	83 38 00	 cmp	 DWORD PTR [eax], 0
  00043	74 6f		 je	 SHORT $LN1@Orphan_all

; 1291 :         _Lockit _Lock(_LOCK_DEBUG);

  00045	8b f4		 mov	 esi, esp
  00047	6a 03		 push	 3
  00049	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
  00052	3b f4		 cmp	 esi, esp
  00054	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00059	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1292 : 
; 1293 :         for (auto _Pnext = &_Myproxy->_Myfirstiter; *_Pnext; *_Pnext = (*_Pnext)->_Mynextiter) {

  00060	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00063	8b 11		 mov	 edx, DWORD PTR [ecx]
  00065	83 c2 04	 add	 edx, 4
  00068	89 55 e0	 mov	 DWORD PTR __Pnext$2[ebp], edx
  0006b	eb 0d		 jmp	 SHORT $LN4@Orphan_all
$LN2@Orphan_all:
  0006d	8b 45 e0	 mov	 eax, DWORD PTR __Pnext$2[ebp]
  00070	8b 08		 mov	 ecx, DWORD PTR [eax]
  00072	8b 55 e0	 mov	 edx, DWORD PTR __Pnext$2[ebp]
  00075	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00078	89 02		 mov	 DWORD PTR [edx], eax
$LN4@Orphan_all:
  0007a	8b 4d e0	 mov	 ecx, DWORD PTR __Pnext$2[ebp]
  0007d	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00080	74 0d		 je	 SHORT $LN3@Orphan_all

; 1294 :             (*_Pnext)->_Myproxy = nullptr;

  00082	8b 55 e0	 mov	 edx, DWORD PTR __Pnext$2[ebp]
  00085	8b 02		 mov	 eax, DWORD PTR [edx]
  00087	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1295 :         }

  0008d	eb de		 jmp	 SHORT $LN2@Orphan_all
$LN3@Orphan_all:

; 1296 : 
; 1297 :         _Myproxy->_Myfirstiter = nullptr;

  0008f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00092	8b 11		 mov	 edx, DWORD PTR [ecx]
  00094	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0

; 1298 :     }

  0009b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000a2	8b f4		 mov	 esi, esp
  000a4	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  000a7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  000ad	3b f4		 cmp	 esi, esp
  000af	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@Orphan_all:

; 1299 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1300 : }

  000b4	52		 push	 edx
  000b5	8b cd		 mov	 ecx, ebp
  000b7	50		 push	 eax
  000b8	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN11@Orphan_all
  000be	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000c3	58		 pop	 eax
  000c4	5a		 pop	 edx
  000c5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000cf	59		 pop	 ecx
  000d0	5e		 pop	 esi
  000d1	83 c4 20	 add	 esp, 32			; 00000020H
  000d4	3b ec		 cmp	 ebp, esp
  000d6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000db	8b e5		 mov	 esp, ebp
  000dd	5d		 pop	 ebp
  000de	c3		 ret	 0
  000df	90		 npad	 1
$LN11@Orphan_all:
  000e0	01 00 00 00	 DD	 1
  000e4	00 00 00 00	 DD	 $LN10@Orphan_all
$LN10@Orphan_all:
  000e8	e8 ff ff ff	 DD	 -24			; ffffffe8H
  000ec	04 00 00 00	 DD	 4
  000f0	00 00 00 00	 DD	 $LN8@Orphan_all
$LN8@Orphan_all:
  000f4	5f		 DB	 95			; 0000005fH
  000f5	4c		 DB	 76			; 0000004cH
  000f6	6f		 DB	 111			; 0000006fH
  000f7	63		 DB	 99			; 00000063H
  000f8	6b		 DB	 107			; 0000006bH
  000f9	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0:
  00000	8b f4		 mov	 esi, esp
  00002	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  0000b	3b f4		 cmp	 esi, esp
  0000d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00012	c3		 ret	 0
__ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ:
  00013	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00017	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001a	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ
  00029	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Orphan_all@_Container_base12@std@@QAEXXZ ENDP		; std::_Container_base12::_Orphan_all
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ??0_Container_base12@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Container_base12@std@@QAE@XZ PROC			; std::_Container_base12::_Container_base12, COMDAT
; _this$ = ecx

; 1175 :     _Container_base12() : _Myproxy(nullptr) {} // construct childless container

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??0_Container_base12@std@@QAE@XZ ENDP			; std::_Container_base12::_Container_base12
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Mycont_$ = 8						; size = 4
??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z PROC ; std::_Container_proxy::_Container_proxy, COMDAT
; _this$ = ecx

; 1167 :     _Container_proxy(_Container_base12* _Mycont_) noexcept : _Mycont(_Mycont_), _Myfirstiter(nullptr) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 4d 08	 mov	 ecx, DWORD PTR __Mycont_$[ebp]
  00014	89 08		 mov	 DWORD PTR [eax], ecx
  00016	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00019	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0
  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z ENDP ; std::_Container_proxy::_Container_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ??$_Convert_size@I@std@@YAII@Z
_TEXT	SEGMENT
__Len$ = 8						; size = 4
??$_Convert_size@I@std@@YAII@Z PROC			; std::_Convert_size<unsigned int>, COMDAT

; 1073 : _NODISCARD constexpr size_t _Convert_size<size_t>(const size_t _Len) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1074 :     // convert size_t to size_t, unchanged
; 1075 :     return _Len;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Len$[ebp]

; 1076 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Convert_size@I@std@@YAII@Z ENDP			; std::_Convert_size<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
__Back_shift$ = -16					; size = 4
__Min_back_shift$ = -12					; size = 4
__Ptr_container$ = -8					; size = 4
__Ptr_user$ = -4					; size = 4
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 102  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000f	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00012	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00015	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 103  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 104  :     _Bytes += _Non_user_size;

  00018	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]
  0001b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001d	83 c1 27	 add	 ecx, 39			; 00000027H
  00020	8b 55 0c	 mov	 edx, DWORD PTR __Bytes$[ebp]
  00023	89 0a		 mov	 DWORD PTR [edx], ecx

; 105  : 
; 106  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);

  00025	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00028	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002a	89 4d fc	 mov	 DWORD PTR __Ptr_user$[ebp], ecx

; 107  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0002d	ba 04 00 00 00	 mov	 edx, 4
  00032	6b c2 ff	 imul	 eax, edx, -1
  00035	8b 4d fc	 mov	 ecx, DWORD PTR __Ptr_user$[ebp]
  00038	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  0003b	89 55 f8	 mov	 DWORD PTR __Ptr_container$[ebp], edx
$LN4@Adjust_man:

; 108  : 
; 109  :     // If the following asserts, it likely means that we are performing
; 110  :     // an aligned delete on memory coming from an unaligned allocation.
; 111  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");

  0003e	b8 04 00 00 00	 mov	 eax, 4
  00043	6b c8 fe	 imul	 ecx, eax, -2
  00046	8b 55 fc	 mov	 edx, DWORD PTR __Ptr_user$[ebp]
  00049	81 3c 0a fa fa
	fa fa		 cmp	 DWORD PTR [edx+ecx], -84215046 ; fafafafaH
  00050	75 02		 jne	 SHORT $LN7@Adjust_man
  00052	eb 56		 jmp	 SHORT $LN2@Adjust_man
$LN7@Adjust_man:
  00054	8b f4		 mov	 esi, esp
  00056	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@FCMFBGOM@invalid?5argument@
  0005b	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  00060	6a 00		 push	 0
  00062	6a 6f		 push	 111			; 0000006fH
  00064	68 00 00 00 00	 push	 OFFSET ??_C@_0GI@FJIKDGOA@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
  00069	6a 02		 push	 2
  0006b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  00071	83 c4 18	 add	 esp, 24			; 00000018H
  00074	3b f4		 cmp	 esi, esp
  00076	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007b	83 f8 01	 cmp	 eax, 1
  0007e	75 01		 jne	 SHORT $LN19@Adjust_man
  00080	cc		 int	 3
$LN19@Adjust_man:
  00081	8b f4		 mov	 esi, esp
  00083	6a 00		 push	 0
  00085	6a 6f		 push	 111			; 0000006fH
  00087	68 00 00 00 00	 push	 OFFSET ??_C@_1NA@CDBIFGMM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  0008c	68 00 00 00 00	 push	 OFFSET ??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@
  00091	68 00 00 00 00	 push	 OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
  00096	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  0009c	83 c4 14	 add	 esp, 20			; 00000014H
  0009f	3b f4		 cmp	 esi, esp
  000a1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a6	33 c9		 xor	 ecx, ecx
  000a8	75 aa		 jne	 SHORT $LN7@Adjust_man
$LN2@Adjust_man:
  000aa	33 d2		 xor	 edx, edx
  000ac	75 90		 jne	 SHORT $LN4@Adjust_man

; 112  : 
; 113  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 114  :     // in range [_Min_back_shift, _Non_user_size]
; 115  : #ifdef _DEBUG
; 116  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);

  000ae	c7 45 f4 08 00
	00 00		 mov	 DWORD PTR __Min_back_shift$[ebp], 8

; 117  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 118  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 119  : #endif // _DEBUG
; 120  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000b5	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  000b8	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ba	2b 4d f8	 sub	 ecx, DWORD PTR __Ptr_container$[ebp]
  000bd	89 4d f0	 mov	 DWORD PTR __Back_shift$[ebp], ecx
$LN10@Adjust_man:

; 121  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000c0	83 7d f0 08	 cmp	 DWORD PTR __Back_shift$[ebp], 8
  000c4	72 08		 jb	 SHORT $LN13@Adjust_man
  000c6	83 7d f0 27	 cmp	 DWORD PTR __Back_shift$[ebp], 39 ; 00000027H
  000ca	77 02		 ja	 SHORT $LN13@Adjust_man
  000cc	eb 56		 jmp	 SHORT $LN8@Adjust_man
$LN13@Adjust_man:
  000ce	8b f4		 mov	 esi, esp
  000d0	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@FCMFBGOM@invalid?5argument@
  000d5	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  000da	6a 00		 push	 0
  000dc	6a 79		 push	 121			; 00000079H
  000de	68 00 00 00 00	 push	 OFFSET ??_C@_0GI@FJIKDGOA@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
  000e3	6a 02		 push	 2
  000e5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  000eb	83 c4 18	 add	 esp, 24			; 00000018H
  000ee	3b f4		 cmp	 esi, esp
  000f0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f5	83 f8 01	 cmp	 eax, 1
  000f8	75 01		 jne	 SHORT $LN20@Adjust_man
  000fa	cc		 int	 3
$LN20@Adjust_man:
  000fb	8b f4		 mov	 esi, esp
  000fd	6a 00		 push	 0
  000ff	6a 79		 push	 121			; 00000079H
  00101	68 00 00 00 00	 push	 OFFSET ??_C@_1NA@CDBIFGMM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  00106	68 00 00 00 00	 push	 OFFSET ??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@
  0010b	68 00 00 00 00	 push	 OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
  00110	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  00116	83 c4 14	 add	 esp, 20			; 00000014H
  00119	3b f4		 cmp	 esi, esp
  0011b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00120	33 c0		 xor	 eax, eax
  00122	75 aa		 jne	 SHORT $LN13@Adjust_man
$LN8@Adjust_man:
  00124	33 c9		 xor	 ecx, ecx
  00126	75 98		 jne	 SHORT $LN10@Adjust_man

; 122  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00128	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  0012b	8b 45 f8	 mov	 eax, DWORD PTR __Ptr_container$[ebp]
  0012e	89 02		 mov	 DWORD PTR [edx], eax

; 123  : }

  00130	5e		 pop	 esi
  00131	83 c4 10	 add	 esp, 16			; 00000010H
  00134	3b ec		 cmp	 ebp, esp
  00136	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0013b	8b e5		 mov	 esp, ebp
  0013d	5d		 pop	 ebp
  0013e	c3		 ret	 0
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z PROC	; std::_Default_allocate_traits::_Allocate, COMDAT

; 46   :     _DECLSPEC_ALLOCATOR static void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   :         return ::operator new(_Bytes);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000c	83 c4 04	 add	 esp, 4

; 48   :     }

  0000f	3b ec		 cmp	 ebp, esp
  00011	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ENDP	; std::_Default_allocate_traits::_Allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 323  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 324  :     _THROW(bad_array_new_length{});

  0001b	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  0001e	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  00023	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00028	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN2@Throw_bad_:

; 325  : }

  00031	83 c4 0c	 add	 esp, 12			; 0000000cH
  00034	3b ec		 cmp	 ebp, esp
  00036	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1bad_array_new_length@std@@UAE@XZ
  00016	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00019	83 e0 01	 and	 eax, 1
  0001c	74 0e		 je	 SHORT $LN2@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00029	83 c4 08	 add	 esp, 8
$LN2@scalar:
  0002c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	83 c4 04	 add	 esp, 4
  00032	3b ec		 cmp	 ebp, esp
  00034	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0bad_array_new_length@std@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002d	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00030	50		 push	 eax
  00031	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@ABV01@@Z
  00039	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00040	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_array_new_length@std@@6B@
  00049	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00050	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00053	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00056	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005d	59		 pop	 ecx
  0005e	83 c4 10	 add	 esp, 16			; 00000010H
  00061	3b ec		 cmp	 ebp, esp
  00063	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0bad_array_new_length@std@@QAE@ABV01@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1bad_alloc@std@@UAE@XZ
__ehhandler$??0bad_array_new_length@std@@QAE@ABV01@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0bad_array_new_length@std@@QAE@ABV01@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1bad_array_new_length@std@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00034	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0003b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	e8 00 00 00 00	 call	 ??1bad_alloc@std@@UAE@XZ
  00043	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00046	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0004d	59		 pop	 ecx
  0004e	83 c4 10	 add	 esp, 16			; 00000010H
  00051	3b ec		 cmp	 ebp, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1bad_array_new_length@std@@UAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1bad_alloc@std@@UAE@XZ
__ehhandler$??1bad_array_new_length@std@@UAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1bad_array_new_length@std@@UAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 138  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0bad_array_new_length@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 137  :         : bad_alloc("bad array new length")

  0002d	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
  00032	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ??0bad_alloc@std@@AAE@QBD@Z ; std::bad_alloc::bad_alloc
  0003a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 138  :     {

  00041	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00044	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@

; 139  :     }

  0004a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00051	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00054	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00057	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005e	59		 pop	 ecx
  0005f	83 c4 10	 add	 esp, 16			; 00000010H
  00062	3b ec		 cmp	 ebp, esp
  00064	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00069	8b e5		 mov	 esp, ebp
  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0bad_array_new_length@std@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1bad_alloc@std@@UAE@XZ
__ehhandler$??0bad_array_new_length@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0bad_array_new_length@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1bad_alloc@std@@UAE@XZ
  00016	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00019	83 e0 01	 and	 eax, 1
  0001c	74 0e		 je	 SHORT $LN2@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00029	83 c4 08	 add	 esp, 8
$LN2@scalar:
  0002c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	83 c4 04	 add	 esp, 4
  00032	3b ec		 cmp	 ebp, esp
  00034	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0bad_alloc@std@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002d	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00030	50		 push	 eax
  00031	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00039	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00040	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@
  00049	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00050	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00053	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00056	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005d	59		 pop	 ecx
  0005e	83 c4 10	 add	 esp, 16			; 00000010H
  00061	3b ec		 cmp	 ebp, esp
  00063	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0bad_alloc@std@@QAE@ABV01@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
__ehhandler$??0bad_alloc@std@@QAE@ABV01@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0bad_alloc@std@@QAE@ABV01@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1bad_alloc@std@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00034	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0003b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  00043	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00046	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0004d	59		 pop	 ecx
  0004e	83 c4 10	 add	 esp, 16			; 00000010H
  00051	3b ec		 cmp	 ebp, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1bad_alloc@std@@UAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
__ehhandler$??1bad_alloc@std@@UAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1bad_alloc@std@@UAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@AAE@QBD@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0bad_alloc@std@@AAE@QBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 127  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0bad_alloc@std@@AAE@QBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 126  :         : exception(_Message, 1)

  0002d	6a 01		 push	 1
  0002f	8b 45 08	 mov	 eax, DWORD PTR __Message$[ebp]
  00032	50		 push	 eax
  00033	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00036	e8 00 00 00 00	 call	 ??0exception@std@@QAE@QBDH@Z ; std::exception::exception
  0003b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 127  :     {

  00042	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 128  :     }

  0004b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00052	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00055	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00058	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005f	59		 pop	 ecx
  00060	83 c4 10	 add	 esp, 16			; 00000010H
  00063	3b ec		 cmp	 ebp, esp
  00065	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0bad_alloc@std@@AAE@QBD@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
__ehhandler$??0bad_alloc@std@@AAE@QBD@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0bad_alloc@std@@AAE@QBD@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0bad_alloc@std@@AAE@QBD@Z ENDP			; std::bad_alloc::bad_alloc
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  00016	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00019	83 e0 01	 and	 eax, 1
  0001c	74 0e		 je	 SHORT $LN2@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00029	83 c4 08	 add	 esp, 8
$LN2@scalar:
  0002c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	83 c4 04	 add	 esp, 4
  00032	3b ec		 cmp	 ebp, esp
  00034	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 91   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 92   :         return _Data._What ? _Data._What : "Unknown exception";

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0001e	74 0b		 je	 SHORT $LN3@what
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00026	89 55 f8	 mov	 DWORD PTR tv69[ebp], edx
  00029	eb 07		 jmp	 SHORT $LN4@what
$LN3@what:
  0002b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
$LN4@what:
  00032	8b 45 f8	 mov	 eax, DWORD PTR tv69[ebp]

; 93   :     }

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 86   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1exception@std@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00030	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 87   :         __std_exception_destroy(&_Data);

  00036	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	83 c1 04	 add	 ecx, 4
  0003c	51		 push	 ecx
  0003d	e8 00 00 00 00	 call	 ___std_exception_destroy
  00042	83 c4 04	 add	 esp, 4

; 88   :     }

  00045	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00048	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0004f	59		 pop	 ecx
  00050	83 c4 10	 add	 esp, 16			; 00000010H
  00053	3b ec		 cmp	 ebp, esp
  00055	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1exception@std@@UAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1exception@std@@UAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 69   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0exception@std@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00030	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 68   :         : _Data()

  00036	33 c9		 xor	 ecx, ecx
  00038	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0003b	83 c2 04	 add	 edx, 4
  0003e	89 0a		 mov	 DWORD PTR [edx], ecx
  00040	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 70   :         __std_exception_copy(&_Other._Data, &_Data);

  00043	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00046	83 c0 04	 add	 eax, 4
  00049	50		 push	 eax
  0004a	8b 4d 08	 mov	 ecx, DWORD PTR __Other$[ebp]
  0004d	83 c1 04	 add	 ecx, 4
  00050	51		 push	 ecx
  00051	e8 00 00 00 00	 call	 ___std_exception_copy
  00056	83 c4 08	 add	 esp, 8

; 71   :     }

  00059	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00066	59		 pop	 ecx
  00067	83 c4 10	 add	 esp, 16			; 00000010H
  0006a	3b ec		 cmp	 ebp, esp
  0006c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0exception@std@@QAE@ABV01@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0exception@std@@QAE@ABV01@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@QBDH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
___formal$ = 12						; size = 4
??0exception@std@@QAE@QBDH@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 63   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 62   :         : _Data()

  00017	33 c9		 xor	 ecx, ecx
  00019	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001c	83 c2 04	 add	 edx, 4
  0001f	89 0a		 mov	 DWORD PTR [edx], ecx
  00021	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 64   :         _Data._What = _Message;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	8b 4d 08	 mov	 ecx, DWORD PTR __Message$[ebp]
  0002a	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 65   :     }

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 08 00	 ret	 8
??0exception@std@@QAE@QBDH@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\chrono
;	COMDAT ?count@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBENXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?count@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBENXZ PROC ; std::chrono::duration<double,std::ratio<1,1000000000> >::count, COMDAT
; _this$ = ecx

; 88   :         _NODISCARD constexpr _Rep count() const _NOEXCEPT_COND(is_arithmetic_v<_Rep>) { // strengthened

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :             return _MyRep;

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	dd 00		 fld	 QWORD PTR [eax]

; 90   :         }

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?count@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBENXZ ENDP ; std::chrono::duration<double,std::ratio<1,1000000000> >::count
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\chrono
;	COMDAT ?count@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QBE_JXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?count@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QBE_JXZ PROC ; std::chrono::duration<__int64,std::ratio<1,1000> >::count, COMDAT
; _this$ = ecx

; 88   :         _NODISCARD constexpr _Rep count() const _NOEXCEPT_COND(is_arithmetic_v<_Rep>) { // strengthened

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :             return _MyRep;

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	8b 01		 mov	 eax, DWORD PTR [ecx]
  00013	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]

; 90   :         }

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?count@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QBE_JXZ ENDP ; std::chrono::duration<__int64,std::ratio<1,1000> >::count
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\chrono
;	COMDAT ?count@?$duration@NU?$ratio@$00$00@std@@@chrono@std@@QBENXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?count@?$duration@NU?$ratio@$00$00@std@@@chrono@std@@QBENXZ PROC ; std::chrono::duration<double,std::ratio<1,1> >::count, COMDAT
; _this$ = ecx

; 88   :         _NODISCARD constexpr _Rep count() const _NOEXCEPT_COND(is_arithmetic_v<_Rep>) { // strengthened

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :             return _MyRep;

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	dd 00		 fld	 QWORD PTR [eax]

; 90   :         }

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?count@?$duration@NU?$ratio@$00$00@std@@@chrono@std@@QBENXZ ENDP ; std::chrono::duration<double,std::ratio<1,1> >::count
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\chrono
;	COMDAT ?count@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QBE_JXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?count@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QBE_JXZ PROC ; std::chrono::duration<__int64,std::ratio<1,1> >::count, COMDAT
; _this$ = ecx

; 88   :         _NODISCARD constexpr _Rep count() const _NOEXCEPT_COND(is_arithmetic_v<_Rep>) { // strengthened

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :             return _MyRep;

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	8b 01		 mov	 eax, DWORD PTR [ecx]
  00013	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]

; 90   :         }

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?count@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QBE_JXZ ENDP ; std::chrono::duration<__int64,std::ratio<1,1> >::count
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\chrono
;	COMDAT ??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_J@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_J@Z PROC ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,void>, COMDAT
; _this$ = ecx

; 78   :             : _MyRep(static_cast<_Rep>(_Val)) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 4d 08	 mov	 ecx, DWORD PTR __Val$[ebp]
  00014	8b 11		 mov	 edx, DWORD PTR [ecx]
  00016	89 10		 mov	 DWORD PTR [eax], edx
  00018	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0001b	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_J@Z ENDP ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\chrono
;	COMDAT ?time_since_epoch@?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QBE?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?time_since_epoch@?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QBE?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@XZ PROC ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_since_epoch, COMDAT
; _this$ = ecx

; 194  :         _NODISCARD constexpr _Duration time_since_epoch() const _NOEXCEPT_COND(is_arithmetic_v<rep>) { // strengthened

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 195  :             // get duration from epoch
; 196  :             return _MyDur;

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 08		 mov	 ecx, DWORD PTR [eax]
  00013	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00016	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00019	89 08		 mov	 DWORD PTR [eax], ecx
  0001b	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0001e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 197  :         }

  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
?time_since_epoch@?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QBE?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@XZ ENDP ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_since_epoch
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\chrono
;	COMDAT ??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z PROC ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >, COMDAT
; _this$ = ecx

; 184  :         constexpr explicit time_point(const _Duration& _Other) _NOEXCEPT_COND(is_arithmetic_v<rep>) // strengthened

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 185  :             : _MyDur(_Other) { // construct from a duration

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  00011	8b 08		 mov	 ecx, DWORD PTR [eax]
  00013	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	89 08		 mov	 DWORD PTR [eax], ecx
  0001b	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 186  :         }

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z ENDP ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\chrono
;	COMDAT ??Z?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAEAAV012@ABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??Z?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAEAAV012@ABV012@@Z PROC ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::operator-=, COMDAT
; _this$ = ecx

; 127  :             _NOEXCEPT_COND(is_arithmetic_v<_Rep>) { // strengthened

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 128  :             _MyRep -= _Right._MyRep;

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00014	8b 10		 mov	 edx, DWORD PTR [eax]
  00016	2b 11		 sub	 edx, DWORD PTR [ecx]
  00018	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001b	1b 41 04	 sbb	 eax, DWORD PTR [ecx+4]
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	89 11		 mov	 DWORD PTR [ecx], edx
  00023	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 129  :             return *this;

  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 130  :         }

  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
??Z?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAEAAV012@ABV012@@Z ENDP ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::operator-=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\chrono
;	COMDAT ??Y?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAEAAV012@ABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??Y?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAEAAV012@ABV012@@Z PROC ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::operator+=, COMDAT
; _this$ = ecx

; 121  :             _NOEXCEPT_COND(is_arithmetic_v<_Rep>) { // strengthened

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 122  :             _MyRep += _Right._MyRep;

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00014	8b 10		 mov	 edx, DWORD PTR [eax]
  00016	03 11		 add	 edx, DWORD PTR [ecx]
  00018	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001b	13 41 04	 adc	 eax, DWORD PTR [ecx+4]
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	89 11		 mov	 DWORD PTR [ecx], edx
  00023	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 123  :             return *this;

  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 124  :         }

  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
??Y?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAEAAV012@ABV012@@Z ENDP ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::operator+=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\chrono
;	COMDAT ?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ PROC ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count, COMDAT
; _this$ = ecx

; 88   :         _NODISCARD constexpr _Rep count() const _NOEXCEPT_COND(is_arithmetic_v<_Rep>) { // strengthened

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :             return _MyRep;

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	8b 01		 mov	 eax, DWORD PTR [ecx]
  00013	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]

; 90   :         }

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ENDP ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\chrono
;	COMDAT ?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ
_TEXT	SEGMENT
$T2 = -60						; size = 8
$T3 = -52						; size = 8
__Part$ = -44						; size = 8
__Whole$ = -36						; size = 8
__Ctr$ = -28						; size = 8
__Freq$ = -20						; size = 8
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ PROC ; std::chrono::steady_clock::now, COMDAT

; 647  :         _NODISCARD static time_point now() noexcept { // get current time

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 30	 sub	 esp, 48			; 00000030H
  00014	57		 push	 edi
  00015	8d 7d c4	 lea	 edi, DWORD PTR [ebp-60]
  00018	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  0001d	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00022	f3 ab		 rep stosd
  00024	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00029	33 c5		 xor	 eax, ebp
  0002b	50		 push	 eax
  0002c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0002f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 648  :             const long long _Freq = _Query_perf_frequency(); // doesn't change after system boot

  00035	e8 00 00 00 00	 call	 __Query_perf_frequency
  0003a	89 45 ec	 mov	 DWORD PTR __Freq$[ebp], eax
  0003d	89 55 f0	 mov	 DWORD PTR __Freq$[ebp+4], edx

; 649  :             const long long _Ctr  = _Query_perf_counter();

  00040	e8 00 00 00 00	 call	 __Query_perf_counter
  00045	89 45 e4	 mov	 DWORD PTR __Ctr$[ebp], eax
  00048	89 55 e8	 mov	 DWORD PTR __Ctr$[ebp+4], edx

; 650  :             static_assert(period::num == 1, "This assumes period::num == 1.");
; 651  :             const long long _Whole = (_Ctr / _Freq) * period::den;

  0004b	8b 45 f0	 mov	 eax, DWORD PTR __Freq$[ebp+4]
  0004e	50		 push	 eax
  0004f	8b 4d ec	 mov	 ecx, DWORD PTR __Freq$[ebp]
  00052	51		 push	 ecx
  00053	8b 55 e8	 mov	 edx, DWORD PTR __Ctr$[ebp+4]
  00056	52		 push	 edx
  00057	8b 45 e4	 mov	 eax, DWORD PTR __Ctr$[ebp]
  0005a	50		 push	 eax
  0005b	e8 00 00 00 00	 call	 __alldiv
  00060	6a 00		 push	 0
  00062	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00067	52		 push	 edx
  00068	50		 push	 eax
  00069	e8 00 00 00 00	 call	 __allmul
  0006e	89 45 dc	 mov	 DWORD PTR __Whole$[ebp], eax
  00071	89 55 e0	 mov	 DWORD PTR __Whole$[ebp+4], edx

; 652  :             const long long _Part  = (_Ctr % _Freq) * period::den / _Freq;

  00074	8b 4d f0	 mov	 ecx, DWORD PTR __Freq$[ebp+4]
  00077	51		 push	 ecx
  00078	8b 55 ec	 mov	 edx, DWORD PTR __Freq$[ebp]
  0007b	52		 push	 edx
  0007c	8b 45 e8	 mov	 eax, DWORD PTR __Ctr$[ebp+4]
  0007f	50		 push	 eax
  00080	8b 4d e4	 mov	 ecx, DWORD PTR __Ctr$[ebp]
  00083	51		 push	 ecx
  00084	e8 00 00 00 00	 call	 __allrem
  00089	6a 00		 push	 0
  0008b	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00090	52		 push	 edx
  00091	50		 push	 eax
  00092	e8 00 00 00 00	 call	 __allmul
  00097	8b 4d f0	 mov	 ecx, DWORD PTR __Freq$[ebp+4]
  0009a	51		 push	 ecx
  0009b	8b 4d ec	 mov	 ecx, DWORD PTR __Freq$[ebp]
  0009e	51		 push	 ecx
  0009f	52		 push	 edx
  000a0	50		 push	 eax
  000a1	e8 00 00 00 00	 call	 __alldiv
  000a6	89 45 d4	 mov	 DWORD PTR __Part$[ebp], eax
  000a9	89 55 d8	 mov	 DWORD PTR __Part$[ebp+4], edx

; 653  :             return time_point(duration(_Whole + _Part));

  000ac	8b 55 dc	 mov	 edx, DWORD PTR __Whole$[ebp]
  000af	03 55 d4	 add	 edx, DWORD PTR __Part$[ebp]
  000b2	8b 45 e0	 mov	 eax, DWORD PTR __Whole$[ebp+4]
  000b5	13 45 d8	 adc	 eax, DWORD PTR __Part$[ebp+4]
  000b8	89 55 c4	 mov	 DWORD PTR $T2[ebp], edx
  000bb	89 45 c8	 mov	 DWORD PTR $T2[ebp+4], eax
  000be	8d 4d c4	 lea	 ecx, DWORD PTR $T2[ebp]
  000c1	51		 push	 ecx
  000c2	8d 4d cc	 lea	 ecx, DWORD PTR $T3[ebp]
  000c5	e8 00 00 00 00	 call	 ??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,void>
  000ca	50		 push	 eax
  000cb	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  000ce	e8 00 00 00 00	 call	 ??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
  000d3	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 654  :         }

  000d6	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000d9	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000e0	59		 pop	 ecx
  000e1	5f		 pop	 edi
  000e2	83 c4 3c	 add	 esp, 60			; 0000003cH
  000e5	3b ec		 cmp	 ebp, esp
  000e7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ec	8b e5		 mov	 esp, ebp
  000ee	5d		 pop	 ebp
  000ef	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a c8	 mov	 ecx, DWORD PTR [edx-56]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ ENDP ; std::chrono::steady_clock::now
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\chrono
;	COMDAT ??$?0_JX@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QAE@AB_J@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??$?0_JX@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QAE@AB_J@Z PROC ; std::chrono::duration<__int64,std::ratio<1,10000000> >::duration<__int64,std::ratio<1,10000000> ><__int64,void>, COMDAT
; _this$ = ecx

; 78   :             : _MyRep(static_cast<_Rep>(_Val)) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 4d 08	 mov	 ecx, DWORD PTR __Val$[ebp]
  00014	8b 11		 mov	 edx, DWORD PTR [ecx]
  00016	89 10		 mov	 DWORD PTR [eax], edx
  00018	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0001b	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
??$?0_JX@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QAE@AB_J@Z ENDP ; std::chrono::duration<__int64,std::ratio<1,10000000> >::duration<__int64,std::ratio<1,10000000> ><__int64,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\chrono
;	COMDAT ?time_since_epoch@?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QBE?AV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?time_since_epoch@?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QBE?AV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@XZ PROC ; std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >::time_since_epoch, COMDAT
; _this$ = ecx

; 194  :         _NODISCARD constexpr _Duration time_since_epoch() const _NOEXCEPT_COND(is_arithmetic_v<rep>) { // strengthened

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 195  :             // get duration from epoch
; 196  :             return _MyDur;

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 08		 mov	 ecx, DWORD PTR [eax]
  00013	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00016	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00019	89 08		 mov	 DWORD PTR [eax], ecx
  0001b	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0001e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 197  :         }

  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
?time_since_epoch@?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QBE?AV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@XZ ENDP ; std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >::time_since_epoch
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\chrono
;	COMDAT ??0?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
??0?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@@Z PROC ; std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >, COMDAT
; _this$ = ecx

; 184  :         constexpr explicit time_point(const _Duration& _Other) _NOEXCEPT_COND(is_arithmetic_v<rep>) // strengthened

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 185  :             : _MyDur(_Other) { // construct from a duration

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  00011	8b 08		 mov	 ecx, DWORD PTR [eax]
  00013	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	89 08		 mov	 DWORD PTR [eax], ecx
  0001b	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 186  :         }

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
??0?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@@Z ENDP ; std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\chrono
;	COMDAT ?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE_JXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE_JXZ PROC ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count, COMDAT
; _this$ = ecx

; 88   :         _NODISCARD constexpr _Rep count() const _NOEXCEPT_COND(is_arithmetic_v<_Rep>) { // strengthened

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :             return _MyRep;

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	8b 01		 mov	 eax, DWORD PTR [ecx]
  00013	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]

; 90   :         }

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE_JXZ ENDP ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\chrono
;	COMDAT ?now@system_clock@chrono@std@@SA?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ
_TEXT	SEGMENT
$T2 = -28						; size = 8
$T3 = -20						; size = 8
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?now@system_clock@chrono@std@@SA?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ PROC ; std::chrono::system_clock::now, COMDAT

; 627  :         _NODISCARD static time_point now() noexcept { // get current time

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?now@system_clock@chrono@std@@SA?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  0001c	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  0001f	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00022	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00025	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002a	33 c5		 xor	 eax, ebp
  0002c	50		 push	 eax
  0002d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00030	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 628  :             return time_point(duration(_Xtime_get_ticks()));

  00036	e8 00 00 00 00	 call	 __Xtime_get_ticks
  0003b	89 45 e4	 mov	 DWORD PTR $T2[ebp], eax
  0003e	89 55 e8	 mov	 DWORD PTR $T2[ebp+4], edx
  00041	8d 45 e4	 lea	 eax, DWORD PTR $T2[ebp]
  00044	50		 push	 eax
  00045	8d 4d ec	 lea	 ecx, DWORD PTR $T3[ebp]
  00048	e8 00 00 00 00	 call	 ??$?0_JX@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,10000000> >::duration<__int64,std::ratio<1,10000000> ><__int64,void>
  0004d	50		 push	 eax
  0004e	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00051	e8 00 00 00 00	 call	 ??0?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@@Z ; std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >
  00056	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 629  :         }

  00059	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00063	59		 pop	 ecx
  00064	83 c4 1c	 add	 esp, 28			; 0000001cH
  00067	3b ec		 cmp	 ebp, esp
  00069	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006e	8b e5		 mov	 esp, ebp
  00070	5d		 pop	 ebp
  00071	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?now@system_clock@chrono@std@@SA?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?now@system_clock@chrono@std@@SA?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?now@system_clock@chrono@std@@SA?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ ENDP ; std::chrono::system_clock::now
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__Size$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 168  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 169  :         (void)_Size;
; 170  :         return _Where;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 171  :     }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\limits
;	COMDAT ?max@?$numeric_limits@H@std@@SAHXZ
_TEXT	SEGMENT
?max@?$numeric_limits@H@std@@SAHXZ PROC			; std::numeric_limits<int>::max, COMDAT

; 553  :     _NODISCARD static constexpr int(max)() noexcept { // return maximum value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 554  :         return INT_MAX;

  00003	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 555  :     }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
?max@?$numeric_limits@H@std@@SAHXZ ENDP			; std::numeric_limits<int>::max
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 835  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 836  :         int _Result;
; 837  :         va_list _ArgList;
; 838  :         __crt_va_start(_ArgList, _Format);

  0001b	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  0001e	89 45 f8	 mov	 DWORD PTR __ArgList$[ebp], eax

; 839  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

  00021	8b 4d f8	 mov	 ecx, DWORD PTR __ArgList$[ebp]
  00024	51		 push	 ecx
  00025	6a 00		 push	 0
  00027	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  0002a	52		 push	 edx
  0002b	8b 45 08	 mov	 eax, DWORD PTR __Stream$[ebp]
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 __vfprintf_l
  00034	83 c4 10	 add	 esp, 16			; 00000010H
  00037	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 840  :         __crt_va_end(_ArgList);

  0003a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 841  :         return _Result;

  00041	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]

; 842  :     }

  00044	83 c4 0c	 add	 esp, 12			; 0000000cH
  00047	3b ec		 cmp	 ebp, esp
  00049	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c3		 ret	 0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 642  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00004	8b f4		 mov	 esi, esp
  00006	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00009	50		 push	 eax
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  0000d	51		 push	 ecx
  0000e	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00011	52		 push	 edx
  00012	8b 45 08	 mov	 eax, DWORD PTR __Stream$[ebp]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  0001b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001e	51		 push	 ecx
  0001f	8b 10		 mov	 edx, DWORD PTR [eax]
  00021	52		 push	 edx
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vfprintf
  00028	83 c4 18	 add	 esp, 24			; 00000018H
  0002b	3b f4		 cmp	 esi, esp
  0002d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 644  :     }

  00032	5e		 pop	 esi
  00033	3b ec		 cmp	 ebp, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 86   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

  00003	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\rgy_perf_monitor.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\rgy_perf_monitor.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
