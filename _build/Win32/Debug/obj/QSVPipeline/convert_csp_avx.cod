; Listing generated by Microsoft (R) Optimizing Compiler Version 19.23.28106.4 

	TITLE	D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
?Array_INTERLACE_WEIGHT@@3QAY0CA@$$CBEA DB 01H		; Array_INTERLACE_WEIGHT
	DB	03H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	03H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	01H
$SG7310	DB	'Invalid', 00H
$SG7311	DB	'nv12', 00H
	ORG $+3
$SG7312	DB	'yv12', 00H
	ORG $+3
$SG7313	DB	'yuy2', 00H
	ORG $+3
$SG7314	DB	'yuv422', 00H
	ORG $+1
$SG7315	DB	'nv16', 00H
	ORG $+3
$SG7316	DB	'yuv444', 00H
	ORG $+1
$SG7317	DB	'yv12(9bit)', 00H
	ORG $+1
$SG7318	DB	'yv12(10bit)', 00H
$SG7319	DB	'yv12(12bit)', 00H
$SG7320	DB	'yv12(14bit)', 00H
$SG7321	DB	'yv12(16bit)', 00H
$SG7322	DB	'p010', 00H
	ORG $+3
$SG7323	DB	'yuv422(9bit)', 00H
	ORG $+3
$SG7324	DB	'yuv422(10bit)', 00H
	ORG $+2
$SG7325	DB	'yuv422(12bit)', 00H
	ORG $+2
$SG7326	DB	'yuv422(14bit)', 00H
	ORG $+2
$SG7327	DB	'yuv422(16bit)', 00H
	ORG $+2
$SG7328	DB	'p210', 00H
	ORG $+3
$SG7329	DB	'yuv444(9bit)', 00H
	ORG $+3
$SG7330	DB	'yuv444(10bit)', 00H
	ORG $+2
$SG7331	DB	'yuv444(12bit)', 00H
	ORG $+2
$SG7332	DB	'yuv444(14bit)', 00H
	ORG $+2
$SG7333	DB	'yuv444(16bit)', 00H
	ORG $+2
$SG7334	DB	'yuva444', 00H
$SG7335	DB	'yuva444(16bit)', 00H
	ORG $+1
$SG7336	DB	'rgb24r', 00H
	ORG $+1
$SG7337	DB	'rgb32r', 00H
	ORG $+1
$SG7338	DB	'rgb24', 00H
	ORG $+2
$SG7339	DB	'rgb32', 00H
	ORG $+2
$SG7340	DB	'bgr24', 00H
	ORG $+2
$SG7341	DB	'bgr32', 00H
	ORG $+2
$SG7342	DB	'rgb', 00H
$SG7343	DB	'rgba', 00H
	ORG $+3
$SG7344	DB	'gbr', 00H
$SG7345	DB	'gbra', 00H
	ORG $+3
$SG7346	DB	'yc48', 00H
	ORG $+3
$SG7347	DB	'y8', 00H
	ORG $+1
$SG7348	DB	'yc16', 00H
	ORG $+11
?Array_Y_L_MA_16@@3QBFB DW 0dbH				; Array_Y_L_MA_16
	DW	01H
	DW	0dbH
	DW	01H
	DW	0dbH
	DW	01H
	DW	0dbH
	DW	01H
	DW	0dbH
	DW	01H
	DW	0dbH
	DW	01H
	DW	0dbH
	DW	01H
	DW	0dbH
	DW	01H
?Array_UV_L_MA_16_420P@@3QBFB DW 0eH			; Array_UV_L_MA_16_420P
	DW	00H
	DW	0eH
	DW	00H
	DW	0eH
	DW	00H
	DW	0eH
	DW	00H
	DW	0eH
	DW	00H
	DW	0eH
	DW	00H
	DW	0eH
	DW	00H
	DW	0eH
	DW	00H
?Array_UV_L_MA_16_420I@@3QAY0BA@$$CBFA DW 02aH		; Array_UV_L_MA_16_420I
	DW	00H
	DW	02aH
	DW	00H
	DW	02aH
	DW	00H
	DW	02aH
	DW	00H
	DW	02aH
	DW	00H
	DW	02aH
	DW	00H
	DW	02aH
	DW	00H
	DW	02aH
	DW	00H
	DW	0eH
	DW	00H
	DW	0eH
	DW	00H
	DW	0eH
	DW	00H
	DW	0eH
	DW	00H
	DW	0eH
	DW	00H
	DW	0eH
	DW	00H
	DW	0eH
	DW	00H
	DW	0eH
	DW	00H
?Array_UV_L_MA_16_444@@3QBFB DW 0eH			; Array_UV_L_MA_16_444
	DW	00H
	DW	0eH
	DW	00H
	DW	0eH
	DW	00H
	DW	0eH
	DW	00H
	DW	0eH
	DW	00H
	DW	0eH
	DW	00H
	DW	0eH
	DW	00H
	DW	0eH
	DW	00H
?Array_SUFFLE_YCP_Y@@3QBEB DB 00H			; Array_SUFFLE_YCP_Y
	DB	01H
	DB	06H
	DB	07H
	DB	0cH
	DB	0dH
	DB	02H
	DB	03H
	DB	08H
	DB	09H
	DB	0eH
	DB	0fH
	DB	04H
	DB	05H
	DB	0aH
	DB	0bH
	DB	00H
	DB	01H
	DB	06H
	DB	07H
	DB	0cH
	DB	0dH
	DB	02H
	DB	03H
	DB	08H
	DB	09H
	DB	0eH
	DB	0fH
	DB	04H
	DB	05H
	DB	0aH
	DB	0bH
CONST	ENDS
PUBLIC	?convert_yuy2_to_nv12_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuy2_to_nv12_avx
PUBLIC	?convert_yuy2_to_nv12_i_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuy2_to_nv12_i_avx
PUBLIC	?convert_yv12_to_nv12_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_to_nv12_avx
PUBLIC	?convert_uv_yv12_to_nv12_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_uv_yv12_to_nv12_avx
PUBLIC	?convert_yv12_to_p010_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_to_p010_avx
PUBLIC	?convert_rgb24_to_rgb32_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_rgb24_to_rgb32_avx
PUBLIC	?convert_rgb24r_to_rgb32_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_rgb24r_to_rgb32_avx
PUBLIC	?convert_yc48_to_p010_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yc48_to_p010_avx
PUBLIC	?convert_rgb32_to_rgb32_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_rgb32_to_rgb32_avx
PUBLIC	??$convert_rgb32_to_rgb32_simd@$0BN@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_rgb32_to_rgb32_simd<29>
PUBLIC	?convert_rgb32r_to_rgb32_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_rgb32r_to_rgb32_avx
PUBLIC	?convert_yc48_to_p010_i_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yc48_to_p010_i_avx
PUBLIC	?convert_yc48_to_yuv444_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yc48_to_yuv444_avx
PUBLIC	?convert_yc48_to_yuv444_16bit_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yc48_to_yuv444_16bit_avx
PUBLIC	?convert_yuv444_16bit_to_yc48_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_16bit_to_yc48_avx
PUBLIC	__xmm@00001000000010000000100000001000
PUBLIC	__xmm@00010001000100010001000100010001
PUBLIC	__xmm@00020002000200020002000200020002
PUBLIC	__xmm@00800080008000800080008000800080
PUBLIC	__xmm@08000800080008000800080008000800
PUBLIC	__xmm@082f082f082f082f082f082f082f082f
PUBLIC	__xmm@10001000100010001000100010001000
PUBLIC	__xmm@124a124a124a124a124a124a124a124a
PUBLIC	__xmm@12b412b412b412b412b412b412b412b4
PUBLIC	__xmm@ffffffffffffffffffffffffffffffff
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT __xmm@ffffffffffffffffffffffffffffffff
CONST	SEGMENT
__xmm@ffffffffffffffffffffffffffffffff DB 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH
	DB	0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH
CONST	ENDS
;	COMDAT __xmm@12b412b412b412b412b412b412b412b4
CONST	SEGMENT
__xmm@12b412b412b412b412b412b412b412b4 DB 0b4H, 012H, 0b4H, 012H, 0b4H, 012H
	DB	0b4H, 012H, 0b4H, 012H, 0b4H, 012H, 0b4H, 012H, 0b4H, 012H
CONST	ENDS
;	COMDAT __xmm@124a124a124a124a124a124a124a124a
CONST	SEGMENT
__xmm@124a124a124a124a124a124a124a124a DB 'J', 012H, 'J', 012H, 'J', 012H
	DB	'J', 012H, 'J', 012H, 'J', 012H, 'J', 012H, 'J', 012H
CONST	ENDS
;	COMDAT __xmm@10001000100010001000100010001000
CONST	SEGMENT
__xmm@10001000100010001000100010001000 DB 00H, 010H, 00H, 010H, 00H, 010H
	DB	00H, 010H, 00H, 010H, 00H, 010H, 00H, 010H, 00H, 010H
CONST	ENDS
;	COMDAT __xmm@082f082f082f082f082f082f082f082f
CONST	SEGMENT
__xmm@082f082f082f082f082f082f082f082f DB '/', 08H, '/', 08H, '/', 08H, '/'
	DB	08H, '/', 08H, '/', 08H, '/', 08H, '/', 08H
CONST	ENDS
;	COMDAT __xmm@08000800080008000800080008000800
CONST	SEGMENT
__xmm@08000800080008000800080008000800 DB 00H, 08H, 00H, 08H, 00H, 08H, 00H
	DB	08H, 00H, 08H, 00H, 08H, 00H, 08H, 00H, 08H
CONST	ENDS
;	COMDAT __xmm@00800080008000800080008000800080
CONST	SEGMENT
__xmm@00800080008000800080008000800080 DB 080H, 00H, 080H, 00H, 080H, 00H
	DB	080H, 00H, 080H, 00H, 080H, 00H, 080H, 00H, 080H, 00H
CONST	ENDS
;	COMDAT __xmm@00020002000200020002000200020002
CONST	SEGMENT
__xmm@00020002000200020002000200020002 DB 02H, 00H, 02H, 00H, 02H, 00H, 02H
	DB	00H, 02H, 00H, 02H, 00H, 02H, 00H, 02H, 00H
CONST	ENDS
;	COMDAT __xmm@00010001000100010001000100010001
CONST	SEGMENT
__xmm@00010001000100010001000100010001 DB 01H, 00H, 01H, 00H, 01H, 00H, 01H
	DB	00H, 01H, 00H, 01H, 00H, 01H, 00H, 01H, 00H
CONST	ENDS
;	COMDAT __xmm@00001000000010000000100000001000
CONST	SEGMENT
__xmm@00001000000010000000100000001000 DB 00H, 010H, 00H, 00H, 00H, 010H, 00H
	DB	00H, 00H, 010H, 00H, 00H, 00H, 010H, 00H, 00H
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ?shuffle_yc48@?1??gather_y_u_v_to_yc48@@YAXAAT__m128i@@00@Z@4QBEB
CONST	SEGMENT
?shuffle_yc48@?1??gather_y_u_v_to_yc48@@YAXAAT__m128i@@00@Z@4QBEB DB 00H ; `gather_y_u_v_to_yc48'::`2'::shuffle_yc48
	DB	01H
	DB	06H
	DB	07H
	DB	0cH
	DB	0dH
	DB	02H
	DB	03H
	DB	08H
	DB	09H
	DB	0eH
	DB	0fH
	DB	04H
	DB	05H
	DB	0aH
	DB	0bH
CONST	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
tv201 = -300						; size = 4
tv193 = -296						; size = 4
tv153 = -292						; size = 4
$T1 = -288						; size = 12
$T2 = -272						; size = 16
$T3 = -256						; size = 16
$T4 = -240						; size = 16
$T5 = -224						; size = 16
$T6 = -208						; size = 16
$T7 = -192						; size = 16
_ycp$8 = -172						; size = 4
_ycp_fin$9 = -168					; size = 4
_V$10 = -164						; size = 4
_U$11 = -160						; size = 4
_Y$12 = -156						; size = 4
_y$13 = -152						; size = 4
_x3$ = -144						; size = 16
_x2$ = -112						; size = 16
_x1$ = -80						; size = 16
_pixel$ = -52						; size = 4
_V_line$ = -48						; size = 4
_U_line$ = -44						; size = 4
_Y_line$ = -40						; size = 4
$T14 = -36						; size = 12
_y_range$ = -20						; size = 12
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yuv444_16bit_to_yc48_simd@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_16bit_to_yc48_simd<0>

; 1751 : static __forceinline void convert_yuv444_16bit_to_yc48_simd(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 30 01 00
	00		 sub	 esp, 304		; 00000130H
  0001c	57		 push	 edi
  0001d	8d bd d0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-304]
  00023	b9 4c 00 00 00	 mov	 ecx, 76			; 0000004cH
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1752 :     const auto y_range = thread_y_range(0, height, thread_id, thread_n);

  00039	8b 43 2c	 mov	 eax, DWORD PTR _thread_n$[ebx]
  0003c	50		 push	 eax
  0003d	8b 4b 28	 mov	 ecx, DWORD PTR _thread_id$[ebx]
  00040	51		 push	 ecx
  00041	8b 53 20	 mov	 edx, DWORD PTR _height$[ebx]
  00044	52		 push	 edx
  00045	6a 00		 push	 0
  00047	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00053	83 c4 14	 add	 esp, 20			; 00000014H
  00056	8b 08		 mov	 ecx, DWORD PTR [eax]
  00058	89 4d dc	 mov	 DWORD PTR $T14[ebp], ecx
  0005b	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0005e	89 55 e0	 mov	 DWORD PTR $T14[ebp+4], edx
  00061	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00064	89 45 e4	 mov	 DWORD PTR $T14[ebp+8], eax
  00067	8b 4d dc	 mov	 ecx, DWORD PTR $T14[ebp]
  0006a	89 4d ec	 mov	 DWORD PTR _y_range$[ebp], ecx
  0006d	8b 55 e0	 mov	 edx, DWORD PTR $T14[ebp+4]
  00070	89 55 f0	 mov	 DWORD PTR _y_range$[ebp+4], edx
  00073	8b 45 e4	 mov	 eax, DWORD PTR $T14[ebp+8]
  00076	89 45 f4	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 1753 :     char *Y_line = (char *)src[0] + src_y_pitch_byte * y_range.start_src;

  00079	b9 04 00 00 00	 mov	 ecx, 4
  0007e	6b d1 00	 imul	 edx, ecx, 0
  00081	8b 43 14	 mov	 eax, DWORD PTR _src_y_pitch_byte$[ebx]
  00084	0f af 45 ec	 imul	 eax, DWORD PTR _y_range$[ebp]
  00088	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  0008b	03 04 11	 add	 eax, DWORD PTR [ecx+edx]
  0008e	89 45 d8	 mov	 DWORD PTR _Y_line$[ebp], eax

; 1754 :     char *U_line = (char *)src[1] + src_y_pitch_byte * y_range.start_src;

  00091	ba 04 00 00 00	 mov	 edx, 4
  00096	c1 e2 00	 shl	 edx, 0
  00099	8b 43 14	 mov	 eax, DWORD PTR _src_y_pitch_byte$[ebx]
  0009c	0f af 45 ec	 imul	 eax, DWORD PTR _y_range$[ebp]
  000a0	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  000a3	03 04 11	 add	 eax, DWORD PTR [ecx+edx]
  000a6	89 45 d4	 mov	 DWORD PTR _U_line$[ebp], eax

; 1755 :     char *V_line = (char *)src[2] + src_y_pitch_byte * y_range.start_src;

  000a9	ba 04 00 00 00	 mov	 edx, 4
  000ae	d1 e2		 shl	 edx, 1
  000b0	8b 43 14	 mov	 eax, DWORD PTR _src_y_pitch_byte$[ebx]
  000b3	0f af 45 ec	 imul	 eax, DWORD PTR _y_range$[ebp]
  000b7	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  000ba	03 04 11	 add	 eax, DWORD PTR [ecx+edx]
  000bd	89 45 d0	 mov	 DWORD PTR _V_line$[ebp], eax

; 1756 :     char *pixel = (char *)dst[0] + dst_y_pitch_byte * y_range.start_dst;

  000c0	ba 04 00 00 00	 mov	 edx, 4
  000c5	6b c2 00	 imul	 eax, edx, 0
  000c8	8b 4b 1c	 mov	 ecx, DWORD PTR _dst_y_pitch_byte$[ebx]
  000cb	0f af 4d f0	 imul	 ecx, DWORD PTR _y_range$[ebp+4]
  000cf	8b 53 08	 mov	 edx, DWORD PTR _dst$[ebx]
  000d2	03 0c 02	 add	 ecx, DWORD PTR [edx+eax]
  000d5	89 4d cc	 mov	 DWORD PTR _pixel$[ebp], ecx

; 1757 :     __m128i x1, x2, x3;
; 1758 :     for (int y = 0; y < y_range.len; y++, pixel += dst_y_pitch_byte, Y_line += src_y_pitch_byte, U_line += src_y_pitch_byte, V_line += src_y_pitch_byte) {

  000d8	c7 85 68 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _y$13[ebp], 0
  000e2	eb 33		 jmp	 SHORT $LN4@convert_yu
$LN2@convert_yu:
  000e4	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _y$13[ebp]
  000ea	83 c0 01	 add	 eax, 1
  000ed	89 85 68 ff ff
	ff		 mov	 DWORD PTR _y$13[ebp], eax
  000f3	8b 4d cc	 mov	 ecx, DWORD PTR _pixel$[ebp]
  000f6	03 4b 1c	 add	 ecx, DWORD PTR _dst_y_pitch_byte$[ebx]
  000f9	89 4d cc	 mov	 DWORD PTR _pixel$[ebp], ecx
  000fc	8b 55 d8	 mov	 edx, DWORD PTR _Y_line$[ebp]
  000ff	03 53 14	 add	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  00102	89 55 d8	 mov	 DWORD PTR _Y_line$[ebp], edx
  00105	8b 45 d4	 mov	 eax, DWORD PTR _U_line$[ebp]
  00108	03 43 14	 add	 eax, DWORD PTR _src_y_pitch_byte$[ebx]
  0010b	89 45 d4	 mov	 DWORD PTR _U_line$[ebp], eax
  0010e	8b 4d d0	 mov	 ecx, DWORD PTR _V_line$[ebp]
  00111	03 4b 14	 add	 ecx, DWORD PTR _src_y_pitch_byte$[ebx]
  00114	89 4d d0	 mov	 DWORD PTR _V_line$[ebp], ecx
$LN4@convert_yu:
  00117	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR _y$13[ebp]
  0011d	3b 55 f4	 cmp	 edx, DWORD PTR _y_range$[ebp+8]
  00120	0f 8d fe 01 00
	00		 jge	 $LN1@convert_yu

; 1759 :         short *Y = (short *)Y_line;

  00126	8b 45 d8	 mov	 eax, DWORD PTR _Y_line$[ebp]
  00129	89 85 64 ff ff
	ff		 mov	 DWORD PTR _Y$12[ebp], eax

; 1760 :         short *U = (short *)U_line;

  0012f	8b 4d d4	 mov	 ecx, DWORD PTR _U_line$[ebp]
  00132	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _U$11[ebp], ecx

; 1761 :         short *V = (short *)V_line;

  00138	8b 55 d0	 mov	 edx, DWORD PTR _V_line$[ebp]
  0013b	89 95 5c ff ff
	ff		 mov	 DWORD PTR _V$10[ebp], edx

; 1762 :         short *const ycp_fin = (short *)pixel + width * 3;

  00141	6b 43 10 03	 imul	 eax, DWORD PTR _width$[ebx], 3
  00145	8b 4d cc	 mov	 ecx, DWORD PTR _pixel$[ebp]
  00148	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  0014b	89 95 58 ff ff
	ff		 mov	 DWORD PTR _ycp_fin$9[ebp], edx

; 1763 :         for (short *ycp = (short *)pixel; ycp < ycp_fin; ycp += 24, Y += 8, U += 8, V += 8) {

  00151	8b 45 cc	 mov	 eax, DWORD PTR _pixel$[ebp]
  00154	89 85 54 ff ff
	ff		 mov	 DWORD PTR _ycp$8[ebp], eax
  0015a	eb 3c		 jmp	 SHORT $LN7@convert_yu
$LN5@convert_yu:
  0015c	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _ycp$8[ebp]
  00162	83 c1 30	 add	 ecx, 48			; 00000030H
  00165	89 8d 54 ff ff
	ff		 mov	 DWORD PTR _ycp$8[ebp], ecx
  0016b	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR _Y$12[ebp]
  00171	83 c2 10	 add	 edx, 16			; 00000010H
  00174	89 95 64 ff ff
	ff		 mov	 DWORD PTR _Y$12[ebp], edx
  0017a	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _U$11[ebp]
  00180	83 c0 10	 add	 eax, 16			; 00000010H
  00183	89 85 60 ff ff
	ff		 mov	 DWORD PTR _U$11[ebp], eax
  00189	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _V$10[ebp]
  0018f	83 c1 10	 add	 ecx, 16			; 00000010H
  00192	89 8d 5c ff ff
	ff		 mov	 DWORD PTR _V$10[ebp], ecx
$LN7@convert_yu:
  00198	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR _ycp$8[ebp]
  0019e	3b 95 58 ff ff
	ff		 cmp	 edx, DWORD PTR _ycp_fin$9[ebp]
  001a4	0f 83 75 01 00
	00		 jae	 $LN6@convert_yu

; 1764 :             x1 = _mm_loadu_si128((__m128i *)(Y));

  001aa	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _Y$12[ebp]
  001b0	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  001b3	0f 29 85 40 ff
	ff ff		 movaps	 XMMWORD PTR $T7[ebp], xmm0
  001ba	0f 28 85 40 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T7[ebp]
  001c1	0f 29 45 b0	 movaps	 XMMWORD PTR _x1$[ebp], xmm0

; 1765 :             x2 = _mm_loadu_si128((__m128i *)(U));

  001c5	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _U$11[ebp]
  001cb	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  001ce	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR $T6[ebp], xmm0
  001d5	0f 28 85 30 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T6[ebp]
  001dc	0f 29 45 90	 movaps	 XMMWORD PTR _x2$[ebp], xmm0

; 1766 :             x3 = _mm_loadu_si128((__m128i *)(V));

  001e0	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR _V$10[ebp]
  001e6	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  001e9	0f 29 85 20 ff
	ff ff		 movaps	 XMMWORD PTR $T5[ebp], xmm0
  001f0	0f 28 85 20 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T5[ebp]
  001f7	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR _x3$[ebp], xmm0

; 1767 :             x1 = convert_y_range_to_yc48(x1);

  001fe	0f 28 45 b0	 movaps	 xmm0, XMMWORD PTR _x1$[ebp]
  00202	e8 00 00 00 00	 call	 ?convert_y_range_to_yc48@@YA?AT__m128i@@T1@@Z ; convert_y_range_to_yc48
  00207	0f 29 85 10 ff
	ff ff		 movaps	 XMMWORD PTR $T4[ebp], xmm0
  0020e	0f 28 85 10 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T4[ebp]
  00215	0f 29 45 b0	 movaps	 XMMWORD PTR _x1$[ebp], xmm0

; 1768 :             x2 = convert_uv_range_to_yc48(x2);

  00219	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR _x2$[ebp]
  0021d	e8 00 00 00 00	 call	 ?convert_uv_range_to_yc48@@YA?AT__m128i@@T1@@Z ; convert_uv_range_to_yc48
  00222	0f 29 85 00 ff
	ff ff		 movaps	 XMMWORD PTR $T3[ebp], xmm0
  00229	0f 28 85 00 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T3[ebp]
  00230	0f 29 45 90	 movaps	 XMMWORD PTR _x2$[ebp], xmm0

; 1769 :             x3 = convert_uv_range_to_yc48(x3);

  00234	0f 28 85 70 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x3$[ebp]
  0023b	e8 00 00 00 00	 call	 ?convert_uv_range_to_yc48@@YA?AT__m128i@@T1@@Z ; convert_uv_range_to_yc48
  00240	0f 29 85 f0 fe
	ff ff		 movaps	 XMMWORD PTR $T2[ebp], xmm0
  00247	0f 28 85 f0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T2[ebp]
  0024e	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR _x3$[ebp], xmm0

; 1770 :             gather_y_u_v_to_yc48(x1, x2, x3);

  00255	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR _x3$[ebp]
  0025b	50		 push	 eax
  0025c	8d 4d 90	 lea	 ecx, DWORD PTR _x2$[ebp]
  0025f	51		 push	 ecx
  00260	8d 55 b0	 lea	 edx, DWORD PTR _x1$[ebp]
  00263	52		 push	 edx
  00264	e8 00 00 00 00	 call	 ?gather_y_u_v_to_yc48@@YAXAAT__m128i@@00@Z ; gather_y_u_v_to_yc48
  00269	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1771 :             _mm_store_switch_si128((__m128i *)(ycp +  0), x1);

  0026c	33 c0		 xor	 eax, eax
  0026e	74 19		 je	 SHORT $LN9@convert_yu
  00270	0f 28 45 b0	 movaps	 xmm0, XMMWORD PTR _x1$[ebp]
  00274	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _ycp$8[ebp]
  0027a	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  0027d	c7 85 dc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv153[ebp], 0
  00287	eb 17		 jmp	 SHORT $LN10@convert_yu
$LN9@convert_yu:
  00289	0f 10 45 b0	 movups	 xmm0, XMMWORD PTR _x1$[ebp]
  0028d	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR _ycp$8[ebp]
  00293	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0
  00296	c7 85 dc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv153[ebp], 0
$LN10@convert_yu:

; 1772 :             _mm_store_switch_si128((__m128i *)(ycp +  8), x2);

  002a0	33 c0		 xor	 eax, eax
  002a2	74 1c		 je	 SHORT $LN11@convert_yu
  002a4	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR _x2$[ebp]
  002a8	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _ycp$8[ebp]
  002ae	83 c1 10	 add	 ecx, 16			; 00000010H
  002b1	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  002b4	c7 85 d8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv193[ebp], 0
  002be	eb 1a		 jmp	 SHORT $LN12@convert_yu
$LN11@convert_yu:
  002c0	0f 10 45 90	 movups	 xmm0, XMMWORD PTR _x2$[ebp]
  002c4	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR _ycp$8[ebp]
  002ca	83 c2 10	 add	 edx, 16			; 00000010H
  002cd	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0
  002d0	c7 85 d8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv193[ebp], 0
$LN12@convert_yu:

; 1773 :             _mm_store_switch_si128((__m128i *)(ycp + 16), x3);

  002da	33 c0		 xor	 eax, eax
  002dc	74 1f		 je	 SHORT $LN13@convert_yu
  002de	0f 28 85 70 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x3$[ebp]
  002e5	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _ycp$8[ebp]
  002eb	83 c1 20	 add	 ecx, 32			; 00000020H
  002ee	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  002f1	c7 85 d4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv201[ebp], 0
  002fb	eb 1d		 jmp	 SHORT $LN14@convert_yu
$LN13@convert_yu:
  002fd	0f 10 85 70 ff
	ff ff		 movups	 xmm0, XMMWORD PTR _x3$[ebp]
  00304	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR _ycp$8[ebp]
  0030a	83 c2 20	 add	 edx, 32			; 00000020H
  0030d	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0
  00310	c7 85 d4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv201[ebp], 0
$LN14@convert_yu:

; 1774 :         }

  0031a	e9 3d fe ff ff	 jmp	 $LN5@convert_yu
$LN6@convert_yu:

; 1775 :     }

  0031f	e9 c0 fd ff ff	 jmp	 $LN2@convert_yu
$LN1@convert_yu:

; 1776 : }

  00324	52		 push	 edx
  00325	8b cd		 mov	 ecx, ebp
  00327	50		 push	 eax
  00328	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN20@convert_yu
  0032e	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00333	58		 pop	 eax
  00334	5a		 pop	 edx
  00335	5f		 pop	 edi
  00336	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00339	33 cd		 xor	 ecx, ebp
  0033b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00340	8b e5		 mov	 esp, ebp
  00342	5d		 pop	 ebp
  00343	8b e3		 mov	 esp, ebx
  00345	5b		 pop	 ebx
  00346	c3		 ret	 0
  00347	90		 npad	 1
$LN20@convert_yu:
  00348	04 00 00 00	 DD	 4
  0034c	00 00 00 00	 DD	 $LN19@convert_yu
$LN19@convert_yu:
  00350	ec ff ff ff	 DD	 -20			; ffffffecH
  00354	0c 00 00 00	 DD	 12			; 0000000cH
  00358	00 00 00 00	 DD	 $LN15@convert_yu
  0035c	b0 ff ff ff	 DD	 -80			; ffffffb0H
  00360	10 00 00 00	 DD	 16			; 00000010H
  00364	00 00 00 00	 DD	 $LN16@convert_yu
  00368	90 ff ff ff	 DD	 -112			; ffffff90H
  0036c	10 00 00 00	 DD	 16			; 00000010H
  00370	00 00 00 00	 DD	 $LN17@convert_yu
  00374	70 ff ff ff	 DD	 -144			; ffffff70H
  00378	10 00 00 00	 DD	 16			; 00000010H
  0037c	00 00 00 00	 DD	 $LN18@convert_yu
$LN18@convert_yu:
  00380	78		 DB	 120			; 00000078H
  00381	33		 DB	 51			; 00000033H
  00382	00		 DB	 0
$LN17@convert_yu:
  00383	78		 DB	 120			; 00000078H
  00384	32		 DB	 50			; 00000032H
  00385	00		 DB	 0
$LN16@convert_yu:
  00386	78		 DB	 120			; 00000078H
  00387	31		 DB	 49			; 00000031H
  00388	00		 DB	 0
$LN15@convert_yu:
  00389	79		 DB	 121			; 00000079H
  0038a	5f		 DB	 95			; 0000005fH
  0038b	72		 DB	 114			; 00000072H
  0038c	61		 DB	 97			; 00000061H
  0038d	6e		 DB	 110			; 0000006eH
  0038e	67		 DB	 103			; 00000067H
  0038f	65		 DB	 101			; 00000065H
  00390	00		 DB	 0
??$convert_yuv444_16bit_to_yc48_simd@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_16bit_to_yc48_simd<0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuv444_16bit_to_yc48_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_16bit_to_yc48_avx

; 96   : void convert_yuv444_16bit_to_yc48_avx(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 97   :     convert_yuv444_16bit_to_yc48_simd<false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yuv444_16bit_to_yc48_simd@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_16bit_to_yc48_simd<0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 98   : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yuv444_16bit_to_yc48_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_16bit_to_yc48_avx
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
tv263 = -636						; size = 4
tv233 = -632						; size = 4
tv203 = -628						; size = 4
$T1 = -624						; size = 12
$T2 = -608						; size = 16
$T3 = -592						; size = 16
$T4 = -576						; size = 16
$T5 = -560						; size = 16
$T6 = -544						; size = 16
$T7 = -528						; size = 16
$T8 = -512						; size = 16
$T9 = -496						; size = 16
$T10 = -480						; size = 16
$T11 = -464						; size = 16
$T12 = -448						; size = 16
$T13 = -432						; size = 16
$T14 = -416						; size = 16
$T15 = -400						; size = 16
$T16 = -384						; size = 16
$T17 = -368						; size = 16
$T18 = -352						; size = 16
$T19 = -336						; size = 16
$T20 = -320						; size = 16
_ycp$21 = -300						; size = 4
_ycp_fin$22 = -296					; size = 4
_V$23 = -292						; size = 4
_U$24 = -288						; size = 4
_Y$25 = -284						; size = 4
_y$26 = -280						; size = 4
_x3$ = -272						; size = 16
_x2$ = -240						; size = 16
_x1$ = -208						; size = 16
$T27 = -176						; size = 16
_xC_YCC$ = -144						; size = 16
$T28 = -112						; size = 16
_xC_pw_one$ = -80					; size = 16
_pixel$ = -52						; size = 4
_V_line$ = -48						; size = 4
_U_line$ = -44						; size = 4
_Y_line$ = -40						; size = 4
$T29 = -36						; size = 12
_y_range$ = -20						; size = 12
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yc48_to_yuv444_16bit_simd@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yc48_to_yuv444_16bit_simd<0>

; 1724 : static __forceinline void convert_yc48_to_yuv444_16bit_simd(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 80 02 00
	00		 sub	 esp, 640		; 00000280H
  0001c	57		 push	 edi
  0001d	8d bd 80 fd ff
	ff		 lea	 edi, DWORD PTR [ebp-640]
  00023	b9 a0 00 00 00	 mov	 ecx, 160		; 000000a0H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1725 :     const auto y_range = thread_y_range(0, height, thread_id, thread_n);

  00039	8b 43 2c	 mov	 eax, DWORD PTR _thread_n$[ebx]
  0003c	50		 push	 eax
  0003d	8b 4b 28	 mov	 ecx, DWORD PTR _thread_id$[ebx]
  00040	51		 push	 ecx
  00041	8b 53 20	 mov	 edx, DWORD PTR _height$[ebx]
  00044	52		 push	 edx
  00045	6a 00		 push	 0
  00047	8d 85 90 fd ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00053	83 c4 14	 add	 esp, 20			; 00000014H
  00056	8b 08		 mov	 ecx, DWORD PTR [eax]
  00058	89 4d dc	 mov	 DWORD PTR $T29[ebp], ecx
  0005b	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0005e	89 55 e0	 mov	 DWORD PTR $T29[ebp+4], edx
  00061	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00064	89 45 e4	 mov	 DWORD PTR $T29[ebp+8], eax
  00067	8b 4d dc	 mov	 ecx, DWORD PTR $T29[ebp]
  0006a	89 4d ec	 mov	 DWORD PTR _y_range$[ebp], ecx
  0006d	8b 55 e0	 mov	 edx, DWORD PTR $T29[ebp+4]
  00070	89 55 f0	 mov	 DWORD PTR _y_range$[ebp+4], edx
  00073	8b 45 e4	 mov	 eax, DWORD PTR $T29[ebp+8]
  00076	89 45 f4	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 1726 :     char *Y_line = (char *)dst[0] + dst_y_pitch_byte + y_range.start_dst;

  00079	b9 04 00 00 00	 mov	 ecx, 4
  0007e	6b d1 00	 imul	 edx, ecx, 0
  00081	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  00084	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00087	03 4b 1c	 add	 ecx, DWORD PTR _dst_y_pitch_byte$[ebx]
  0008a	03 4d f0	 add	 ecx, DWORD PTR _y_range$[ebp+4]
  0008d	89 4d d8	 mov	 DWORD PTR _Y_line$[ebp], ecx

; 1727 :     char *U_line = (char *)dst[1] + dst_y_pitch_byte + y_range.start_dst;

  00090	ba 04 00 00 00	 mov	 edx, 4
  00095	c1 e2 00	 shl	 edx, 0
  00098	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  0009b	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  0009e	03 4b 1c	 add	 ecx, DWORD PTR _dst_y_pitch_byte$[ebx]
  000a1	03 4d f0	 add	 ecx, DWORD PTR _y_range$[ebp+4]
  000a4	89 4d d4	 mov	 DWORD PTR _U_line$[ebp], ecx

; 1728 :     char *V_line = (char *)dst[2] + dst_y_pitch_byte + y_range.start_dst;

  000a7	ba 04 00 00 00	 mov	 edx, 4
  000ac	d1 e2		 shl	 edx, 1
  000ae	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  000b1	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  000b4	03 4b 1c	 add	 ecx, DWORD PTR _dst_y_pitch_byte$[ebx]
  000b7	03 4d f0	 add	 ecx, DWORD PTR _y_range$[ebp+4]
  000ba	89 4d d0	 mov	 DWORD PTR _V_line$[ebp], ecx

; 1729 :     char *pixel = (char *)src[0] + src_y_pitch_byte * y_range.start_src;

  000bd	ba 04 00 00 00	 mov	 edx, 4
  000c2	6b c2 00	 imul	 eax, edx, 0
  000c5	8b 4b 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebx]
  000c8	0f af 4d ec	 imul	 ecx, DWORD PTR _y_range$[ebp]
  000cc	8b 53 0c	 mov	 edx, DWORD PTR _src$[ebx]
  000cf	03 0c 02	 add	 ecx, DWORD PTR [edx+eax]
  000d2	89 4d cc	 mov	 DWORD PTR _pixel$[ebp], ecx

; 1730 :     const __m128i xC_pw_one = _mm_set1_epi16(1);

  000d5	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@00010001000100010001000100010001
  000dc	0f 29 45 90	 movaps	 XMMWORD PTR $T28[ebp], xmm0
  000e0	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR $T28[ebp]
  000e4	0f 29 45 b0	 movaps	 XMMWORD PTR _xC_pw_one$[ebp], xmm0

; 1731 :     const __m128i xC_YCC = _mm_set1_epi32(1<<LSFT_YCC_16);

  000e8	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@00001000000010000000100000001000
  000ef	0f 29 85 50 ff
	ff ff		 movaps	 XMMWORD PTR $T27[ebp], xmm0
  000f6	0f 28 85 50 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T27[ebp]
  000fd	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR _xC_YCC$[ebp], xmm0

; 1732 :     __m128i x1, x2, x3;
; 1733 :     for (int y = 0; y < y_range.len; y++, pixel += src_y_pitch_byte, Y_line += dst_y_pitch_byte, U_line += dst_y_pitch_byte, V_line += dst_y_pitch_byte) {

  00104	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _y$26[ebp], 0
  0010e	eb 33		 jmp	 SHORT $LN4@convert_yc
$LN2@convert_yc:
  00110	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _y$26[ebp]
  00116	83 c0 01	 add	 eax, 1
  00119	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _y$26[ebp], eax
  0011f	8b 4d cc	 mov	 ecx, DWORD PTR _pixel$[ebp]
  00122	03 4b 14	 add	 ecx, DWORD PTR _src_y_pitch_byte$[ebx]
  00125	89 4d cc	 mov	 DWORD PTR _pixel$[ebp], ecx
  00128	8b 55 d8	 mov	 edx, DWORD PTR _Y_line$[ebp]
  0012b	03 53 1c	 add	 edx, DWORD PTR _dst_y_pitch_byte$[ebx]
  0012e	89 55 d8	 mov	 DWORD PTR _Y_line$[ebp], edx
  00131	8b 45 d4	 mov	 eax, DWORD PTR _U_line$[ebp]
  00134	03 43 1c	 add	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  00137	89 45 d4	 mov	 DWORD PTR _U_line$[ebp], eax
  0013a	8b 4d d0	 mov	 ecx, DWORD PTR _V_line$[ebp]
  0013d	03 4b 1c	 add	 ecx, DWORD PTR _dst_y_pitch_byte$[ebx]
  00140	89 4d d0	 mov	 DWORD PTR _V_line$[ebp], ecx
$LN4@convert_yc:
  00143	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _y$26[ebp]
  00149	3b 55 f4	 cmp	 edx, DWORD PTR _y_range$[ebp+8]
  0014c	0f 8d 5d 03 00
	00		 jge	 $LN1@convert_yc

; 1734 :         short *Y = (short *)Y_line;

  00152	8b 45 d8	 mov	 eax, DWORD PTR _Y_line$[ebp]
  00155	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _Y$25[ebp], eax

; 1735 :         short *U = (short *)U_line;

  0015b	8b 4d d4	 mov	 ecx, DWORD PTR _U_line$[ebp]
  0015e	89 8d e0 fe ff
	ff		 mov	 DWORD PTR _U$24[ebp], ecx

; 1736 :         short *V = (short *)V_line;

  00164	8b 55 d0	 mov	 edx, DWORD PTR _V_line$[ebp]
  00167	89 95 dc fe ff
	ff		 mov	 DWORD PTR _V$23[ebp], edx

; 1737 :         short *const ycp_fin = (short *)pixel + width * 3;

  0016d	6b 43 10 03	 imul	 eax, DWORD PTR _width$[ebx], 3
  00171	8b 4d cc	 mov	 ecx, DWORD PTR _pixel$[ebp]
  00174	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00177	89 95 d8 fe ff
	ff		 mov	 DWORD PTR _ycp_fin$22[ebp], edx

; 1738 :         for (short *ycp = (short *)pixel; ycp < ycp_fin; ycp += 24, Y += 8, U += 8, V += 8) {

  0017d	8b 45 cc	 mov	 eax, DWORD PTR _pixel$[ebp]
  00180	89 85 d4 fe ff
	ff		 mov	 DWORD PTR _ycp$21[ebp], eax
  00186	eb 3c		 jmp	 SHORT $LN7@convert_yc
$LN5@convert_yc:
  00188	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR _ycp$21[ebp]
  0018e	83 c1 30	 add	 ecx, 48			; 00000030H
  00191	89 8d d4 fe ff
	ff		 mov	 DWORD PTR _ycp$21[ebp], ecx
  00197	8b 95 e4 fe ff
	ff		 mov	 edx, DWORD PTR _Y$25[ebp]
  0019d	83 c2 10	 add	 edx, 16			; 00000010H
  001a0	89 95 e4 fe ff
	ff		 mov	 DWORD PTR _Y$25[ebp], edx
  001a6	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _U$24[ebp]
  001ac	83 c0 10	 add	 eax, 16			; 00000010H
  001af	89 85 e0 fe ff
	ff		 mov	 DWORD PTR _U$24[ebp], eax
  001b5	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR _V$23[ebp]
  001bb	83 c1 10	 add	 ecx, 16			; 00000010H
  001be	89 8d dc fe ff
	ff		 mov	 DWORD PTR _V$23[ebp], ecx
$LN7@convert_yc:
  001c4	8b 95 d4 fe ff
	ff		 mov	 edx, DWORD PTR _ycp$21[ebp]
  001ca	3b 95 d8 fe ff
	ff		 cmp	 edx, DWORD PTR _ycp_fin$22[ebp]
  001d0	0f 83 d4 02 00
	00		 jae	 $LN6@convert_yc

; 1739 :             x1 = _mm_loadu_si128((__m128i *)(ycp +  0));

  001d6	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR _ycp$21[ebp]
  001dc	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  001df	0f 29 85 c0 fe
	ff ff		 movaps	 XMMWORD PTR $T20[ebp], xmm0
  001e6	0f 28 85 c0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T20[ebp]
  001ed	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR _x1$[ebp], xmm0

; 1740 :             x2 = _mm_loadu_si128((__m128i *)(ycp +  8));

  001f4	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR _ycp$21[ebp]
  001fa	83 c1 10	 add	 ecx, 16			; 00000010H
  001fd	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00200	0f 29 85 b0 fe
	ff ff		 movaps	 XMMWORD PTR $T19[ebp], xmm0
  00207	0f 28 85 b0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T19[ebp]
  0020e	0f 29 85 10 ff
	ff ff		 movaps	 XMMWORD PTR _x2$[ebp], xmm0

; 1741 :             x3 = _mm_loadu_si128((__m128i *)(ycp + 16));

  00215	8b 95 d4 fe ff
	ff		 mov	 edx, DWORD PTR _ycp$21[ebp]
  0021b	83 c2 20	 add	 edx, 32			; 00000020H
  0021e	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  00221	0f 29 85 a0 fe
	ff ff		 movaps	 XMMWORD PTR $T18[ebp], xmm0
  00228	0f 28 85 a0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T18[ebp]
  0022f	0f 29 85 f0 fe
	ff ff		 movaps	 XMMWORD PTR _x3$[ebp], xmm0

; 1742 :             gather_y_u_v_from_yc48(x1, x2, x3);

  00236	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _x3$[ebp]
  0023c	50		 push	 eax
  0023d	8d 8d 10 ff ff
	ff		 lea	 ecx, DWORD PTR _x2$[ebp]
  00243	51		 push	 ecx
  00244	8d 95 30 ff ff
	ff		 lea	 edx, DWORD PTR _x1$[ebp]
  0024a	52		 push	 edx
  0024b	e8 00 00 00 00	 call	 ?gather_y_u_v_from_yc48@@YAXAAT__m128i@@00@Z ; gather_y_u_v_from_yc48
  00250	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1743 :             _mm_store_switch_si128((__m128i *)Y, convert_y_range_from_yc48(x1, xC_Y_L_MA_16, Y_L_RSH_16, xC_YCC, xC_pw_one));

  00253	33 c0		 xor	 eax, eax
  00255	74 54		 je	 SHORT $LN9@convert_yc
  00257	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR ?Array_Y_L_MA_16@@3QBFB
  0025e	0f 29 85 90 fe
	ff ff		 movaps	 XMMWORD PTR $T17[ebp], xmm0
  00265	8d 4d b0	 lea	 ecx, DWORD PTR _xC_pw_one$[ebp]
  00268	51		 push	 ecx
  00269	8d 95 70 ff ff
	ff		 lea	 edx, DWORD PTR _xC_YCC$[ebp]
  0026f	52		 push	 edx
  00270	6a 04		 push	 4
  00272	8d 85 90 fe ff
	ff		 lea	 eax, DWORD PTR $T17[ebp]
  00278	50		 push	 eax
  00279	0f 28 85 30 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$[ebp]
  00280	e8 00 00 00 00	 call	 ?convert_y_range_from_yc48@@YA?AT__m128i@@T1@ABT1@H11@Z ; convert_y_range_from_yc48
  00285	83 c4 10	 add	 esp, 16			; 00000010H
  00288	0f 29 85 80 fe
	ff ff		 movaps	 XMMWORD PTR $T16[ebp], xmm0
  0028f	0f 28 85 80 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T16[ebp]
  00296	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _Y$25[ebp]
  0029c	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  0029f	c7 85 8c fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv203[ebp], 0
  002a9	eb 52		 jmp	 SHORT $LN10@convert_yc
$LN9@convert_yc:
  002ab	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR ?Array_Y_L_MA_16@@3QBFB
  002b2	0f 29 85 70 fe
	ff ff		 movaps	 XMMWORD PTR $T15[ebp], xmm0
  002b9	8d 55 b0	 lea	 edx, DWORD PTR _xC_pw_one$[ebp]
  002bc	52		 push	 edx
  002bd	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR _xC_YCC$[ebp]
  002c3	50		 push	 eax
  002c4	6a 04		 push	 4
  002c6	8d 8d 70 fe ff
	ff		 lea	 ecx, DWORD PTR $T15[ebp]
  002cc	51		 push	 ecx
  002cd	0f 28 85 30 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$[ebp]
  002d4	e8 00 00 00 00	 call	 ?convert_y_range_from_yc48@@YA?AT__m128i@@T1@ABT1@H11@Z ; convert_y_range_from_yc48
  002d9	83 c4 10	 add	 esp, 16			; 00000010H
  002dc	0f 29 85 60 fe
	ff ff		 movaps	 XMMWORD PTR $T14[ebp], xmm0
  002e3	0f 10 85 60 fe
	ff ff		 movups	 xmm0, XMMWORD PTR $T14[ebp]
  002ea	8b 95 e4 fe ff
	ff		 mov	 edx, DWORD PTR _Y$25[ebp]
  002f0	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0
  002f3	c7 85 8c fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv203[ebp], 0
$LN10@convert_yc:

; 1744 :             _mm_store_switch_si128((__m128i *)U, convert_uv_range_from_yc48(x2, _mm_set1_epi16(UV_OFFSET_x1), xC_UV_L_MA_16_444, UV_L_RSH_16_444, xC_YCC, xC_pw_one));

  002fd	33 c0		 xor	 eax, eax
  002ff	74 69		 je	 SHORT $LN11@convert_yc
  00301	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR ?Array_UV_L_MA_16_444@@3QBFB
  00308	0f 29 85 40 fe
	ff ff		 movaps	 XMMWORD PTR $T12[ebp], xmm0
  0030f	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@08000800080008000800080008000800
  00316	0f 29 85 50 fe
	ff ff		 movaps	 XMMWORD PTR $T13[ebp], xmm0
  0031d	8d 4d b0	 lea	 ecx, DWORD PTR _xC_pw_one$[ebp]
  00320	51		 push	 ecx
  00321	0f 28 8d 70 ff
	ff ff		 movaps	 xmm1, XMMWORD PTR _xC_YCC$[ebp]
  00328	6a 00		 push	 0
  0032a	8d 95 40 fe ff
	ff		 lea	 edx, DWORD PTR $T12[ebp]
  00330	52		 push	 edx
  00331	8d 85 50 fe ff
	ff		 lea	 eax, DWORD PTR $T13[ebp]
  00337	50		 push	 eax
  00338	0f 28 85 10 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x2$[ebp]
  0033f	e8 00 00 00 00	 call	 ?convert_uv_range_from_yc48@@YA?AT__m128i@@T1@ABT1@1H01@Z ; convert_uv_range_from_yc48
  00344	83 c4 10	 add	 esp, 16			; 00000010H
  00347	0f 29 85 30 fe
	ff ff		 movaps	 XMMWORD PTR $T11[ebp], xmm0
  0034e	0f 28 85 30 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T11[ebp]
  00355	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR _U$24[ebp]
  0035b	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  0035e	c7 85 88 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv233[ebp], 0
  00368	eb 67		 jmp	 SHORT $LN12@convert_yc
$LN11@convert_yc:
  0036a	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR ?Array_UV_L_MA_16_444@@3QBFB
  00371	0f 29 85 10 fe
	ff ff		 movaps	 XMMWORD PTR $T9[ebp], xmm0
  00378	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@08000800080008000800080008000800
  0037f	0f 29 85 20 fe
	ff ff		 movaps	 XMMWORD PTR $T10[ebp], xmm0
  00386	8d 55 b0	 lea	 edx, DWORD PTR _xC_pw_one$[ebp]
  00389	52		 push	 edx
  0038a	0f 28 8d 70 ff
	ff ff		 movaps	 xmm1, XMMWORD PTR _xC_YCC$[ebp]
  00391	6a 00		 push	 0
  00393	8d 85 10 fe ff
	ff		 lea	 eax, DWORD PTR $T9[ebp]
  00399	50		 push	 eax
  0039a	8d 8d 20 fe ff
	ff		 lea	 ecx, DWORD PTR $T10[ebp]
  003a0	51		 push	 ecx
  003a1	0f 28 85 10 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x2$[ebp]
  003a8	e8 00 00 00 00	 call	 ?convert_uv_range_from_yc48@@YA?AT__m128i@@T1@ABT1@1H01@Z ; convert_uv_range_from_yc48
  003ad	83 c4 10	 add	 esp, 16			; 00000010H
  003b0	0f 29 85 00 fe
	ff ff		 movaps	 XMMWORD PTR $T8[ebp], xmm0
  003b7	0f 10 85 00 fe
	ff ff		 movups	 xmm0, XMMWORD PTR $T8[ebp]
  003be	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR _U$24[ebp]
  003c4	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0
  003c7	c7 85 88 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv233[ebp], 0
$LN12@convert_yc:

; 1745 :             _mm_store_switch_si128((__m128i *)V, convert_uv_range_from_yc48(x3, _mm_set1_epi16(UV_OFFSET_x1), xC_UV_L_MA_16_444, UV_L_RSH_16_444, xC_YCC, xC_pw_one));

  003d1	33 c0		 xor	 eax, eax
  003d3	74 69		 je	 SHORT $LN13@convert_yc
  003d5	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR ?Array_UV_L_MA_16_444@@3QBFB
  003dc	0f 29 85 e0 fd
	ff ff		 movaps	 XMMWORD PTR $T6[ebp], xmm0
  003e3	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@08000800080008000800080008000800
  003ea	0f 29 85 f0 fd
	ff ff		 movaps	 XMMWORD PTR $T7[ebp], xmm0
  003f1	8d 4d b0	 lea	 ecx, DWORD PTR _xC_pw_one$[ebp]
  003f4	51		 push	 ecx
  003f5	0f 28 8d 70 ff
	ff ff		 movaps	 xmm1, XMMWORD PTR _xC_YCC$[ebp]
  003fc	6a 00		 push	 0
  003fe	8d 95 e0 fd ff
	ff		 lea	 edx, DWORD PTR $T6[ebp]
  00404	52		 push	 edx
  00405	8d 85 f0 fd ff
	ff		 lea	 eax, DWORD PTR $T7[ebp]
  0040b	50		 push	 eax
  0040c	0f 28 85 f0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _x3$[ebp]
  00413	e8 00 00 00 00	 call	 ?convert_uv_range_from_yc48@@YA?AT__m128i@@T1@ABT1@1H01@Z ; convert_uv_range_from_yc48
  00418	83 c4 10	 add	 esp, 16			; 00000010H
  0041b	0f 29 85 d0 fd
	ff ff		 movaps	 XMMWORD PTR $T5[ebp], xmm0
  00422	0f 28 85 d0 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T5[ebp]
  00429	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR _V$23[ebp]
  0042f	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  00432	c7 85 84 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv263[ebp], 0
  0043c	eb 67		 jmp	 SHORT $LN14@convert_yc
$LN13@convert_yc:
  0043e	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR ?Array_UV_L_MA_16_444@@3QBFB
  00445	0f 29 85 b0 fd
	ff ff		 movaps	 XMMWORD PTR $T3[ebp], xmm0
  0044c	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@08000800080008000800080008000800
  00453	0f 29 85 c0 fd
	ff ff		 movaps	 XMMWORD PTR $T4[ebp], xmm0
  0045a	8d 55 b0	 lea	 edx, DWORD PTR _xC_pw_one$[ebp]
  0045d	52		 push	 edx
  0045e	0f 28 8d 70 ff
	ff ff		 movaps	 xmm1, XMMWORD PTR _xC_YCC$[ebp]
  00465	6a 00		 push	 0
  00467	8d 85 b0 fd ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  0046d	50		 push	 eax
  0046e	8d 8d c0 fd ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  00474	51		 push	 ecx
  00475	0f 28 85 f0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _x3$[ebp]
  0047c	e8 00 00 00 00	 call	 ?convert_uv_range_from_yc48@@YA?AT__m128i@@T1@ABT1@1H01@Z ; convert_uv_range_from_yc48
  00481	83 c4 10	 add	 esp, 16			; 00000010H
  00484	0f 29 85 a0 fd
	ff ff		 movaps	 XMMWORD PTR $T2[ebp], xmm0
  0048b	0f 10 85 a0 fd
	ff ff		 movups	 xmm0, XMMWORD PTR $T2[ebp]
  00492	8b 95 dc fe ff
	ff		 mov	 edx, DWORD PTR _V$23[ebp]
  00498	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0
  0049b	c7 85 84 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv263[ebp], 0
$LN14@convert_yc:

; 1746 :         }

  004a5	e9 de fc ff ff	 jmp	 $LN5@convert_yc
$LN6@convert_yc:

; 1747 :     }

  004aa	e9 61 fc ff ff	 jmp	 $LN2@convert_yc
$LN1@convert_yc:

; 1748 : }

  004af	52		 push	 edx
  004b0	8b cd		 mov	 ecx, ebp
  004b2	50		 push	 eax
  004b3	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN22@convert_yc
  004b9	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  004be	58		 pop	 eax
  004bf	5a		 pop	 edx
  004c0	5f		 pop	 edi
  004c1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004c4	33 cd		 xor	 ecx, ebp
  004c6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004cb	8b e5		 mov	 esp, ebp
  004cd	5d		 pop	 ebp
  004ce	8b e3		 mov	 esp, ebx
  004d0	5b		 pop	 ebx
  004d1	c3		 ret	 0
  004d2	66 90		 npad	 2
$LN22@convert_yc:
  004d4	06 00 00 00	 DD	 6
  004d8	00 00 00 00	 DD	 $LN21@convert_yc
$LN21@convert_yc:
  004dc	ec ff ff ff	 DD	 -20			; ffffffecH
  004e0	0c 00 00 00	 DD	 12			; 0000000cH
  004e4	00 00 00 00	 DD	 $LN15@convert_yc
  004e8	b0 ff ff ff	 DD	 -80			; ffffffb0H
  004ec	10 00 00 00	 DD	 16			; 00000010H
  004f0	00 00 00 00	 DD	 $LN16@convert_yc
  004f4	70 ff ff ff	 DD	 -144			; ffffff70H
  004f8	10 00 00 00	 DD	 16			; 00000010H
  004fc	00 00 00 00	 DD	 $LN17@convert_yc
  00500	30 ff ff ff	 DD	 -208			; ffffff30H
  00504	10 00 00 00	 DD	 16			; 00000010H
  00508	00 00 00 00	 DD	 $LN18@convert_yc
  0050c	10 ff ff ff	 DD	 -240			; ffffff10H
  00510	10 00 00 00	 DD	 16			; 00000010H
  00514	00 00 00 00	 DD	 $LN19@convert_yc
  00518	f0 fe ff ff	 DD	 -272			; fffffef0H
  0051c	10 00 00 00	 DD	 16			; 00000010H
  00520	00 00 00 00	 DD	 $LN20@convert_yc
$LN20@convert_yc:
  00524	78		 DB	 120			; 00000078H
  00525	33		 DB	 51			; 00000033H
  00526	00		 DB	 0
$LN19@convert_yc:
  00527	78		 DB	 120			; 00000078H
  00528	32		 DB	 50			; 00000032H
  00529	00		 DB	 0
$LN18@convert_yc:
  0052a	78		 DB	 120			; 00000078H
  0052b	31		 DB	 49			; 00000031H
  0052c	00		 DB	 0
$LN17@convert_yc:
  0052d	78		 DB	 120			; 00000078H
  0052e	43		 DB	 67			; 00000043H
  0052f	5f		 DB	 95			; 0000005fH
  00530	59		 DB	 89			; 00000059H
  00531	43		 DB	 67			; 00000043H
  00532	43		 DB	 67			; 00000043H
  00533	00		 DB	 0
$LN16@convert_yc:
  00534	78		 DB	 120			; 00000078H
  00535	43		 DB	 67			; 00000043H
  00536	5f		 DB	 95			; 0000005fH
  00537	70		 DB	 112			; 00000070H
  00538	77		 DB	 119			; 00000077H
  00539	5f		 DB	 95			; 0000005fH
  0053a	6f		 DB	 111			; 0000006fH
  0053b	6e		 DB	 110			; 0000006eH
  0053c	65		 DB	 101			; 00000065H
  0053d	00		 DB	 0
$LN15@convert_yc:
  0053e	79		 DB	 121			; 00000079H
  0053f	5f		 DB	 95			; 0000005fH
  00540	72		 DB	 114			; 00000072H
  00541	61		 DB	 97			; 00000061H
  00542	6e		 DB	 110			; 0000006eH
  00543	67		 DB	 103			; 00000067H
  00544	65		 DB	 101			; 00000065H
  00545	00		 DB	 0
??$convert_yc48_to_yuv444_16bit_simd@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yc48_to_yuv444_16bit_simd<0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yc48_to_yuv444_16bit_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yc48_to_yuv444_16bit_avx

; 92   : void convert_yc48_to_yuv444_16bit_avx(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 93   :     convert_yc48_to_yuv444_16bit_simd<false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yc48_to_yuv444_16bit_simd@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yc48_to_yuv444_16bit_simd<0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 94   : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yc48_to_yuv444_16bit_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yc48_to_yuv444_16bit_avx
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
tv334 = -892						; size = 4
tv328 = -888						; size = 4
tv322 = -884						; size = 4
$T1 = -880						; size = 12
$T2 = -864						; size = 16
$T3 = -848						; size = 16
$T4 = -832						; size = 16
$T5 = -816						; size = 16
$T6 = -800						; size = 16
$T7 = -784						; size = 16
$T8 = -768						; size = 16
$T9 = -752						; size = 16
$T10 = -736						; size = 16
$T11 = -720						; size = 16
$T12 = -704						; size = 16
$T13 = -688						; size = 16
$T14 = -672						; size = 16
$T15 = -656						; size = 16
$T16 = -640						; size = 16
$T17 = -624						; size = 16
$T18 = -608						; size = 16
$T19 = -592						; size = 16
$T20 = -576						; size = 16
$T21 = -560						; size = 16
$T22 = -544						; size = 16
$T23 = -528						; size = 16
$T24 = -512						; size = 16
$T25 = -496						; size = 16
$T26 = -480						; size = 16
$T27 = -464						; size = 16
$T28 = -448						; size = 16
$T29 = -432						; size = 16
$T30 = -416						; size = 16
$T31 = -400						; size = 16
$T32 = -384						; size = 16
_ycp$33 = -360						; size = 4
_ycp_fin$34 = -356					; size = 4
_V$35 = -352						; size = 4
_U$36 = -348						; size = 4
_Y$37 = -344						; size = 4
_y$38 = -340						; size = 4
_xV$ = -336						; size = 16
_xU$ = -320						; size = 16
_xY$ = -304						; size = 16
_x3$ = -272						; size = 16
_x2$ = -240						; size = 16
_x1$ = -208						; size = 16
$T39 = -176						; size = 16
_xC_YCC$ = -144						; size = 16
$T40 = -112						; size = 16
_xC_pw_one$ = -80					; size = 16
_ycpLine$ = -52						; size = 4
_VLine$ = -48						; size = 4
_ULine$ = -44						; size = 4
_YLine$ = -40						; size = 4
$T41 = -36						; size = 12
_y_range$ = -20						; size = 12
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yc48_to_yuv444_simd@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yc48_to_yuv444_simd<0>

; 1673 : static void __forceinline convert_yc48_to_yuv444_simd(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 80 03 00
	00		 sub	 esp, 896		; 00000380H
  0001c	57		 push	 edi
  0001d	8d bd 80 fc ff
	ff		 lea	 edi, DWORD PTR [ebp-896]
  00023	b9 e0 00 00 00	 mov	 ecx, 224		; 000000e0H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1674 :     const auto y_range = thread_y_range(0, height, thread_id, thread_n);

  00039	8b 43 2c	 mov	 eax, DWORD PTR _thread_n$[ebx]
  0003c	50		 push	 eax
  0003d	8b 4b 28	 mov	 ecx, DWORD PTR _thread_id$[ebx]
  00040	51		 push	 ecx
  00041	8b 53 20	 mov	 edx, DWORD PTR _height$[ebx]
  00044	52		 push	 edx
  00045	6a 00		 push	 0
  00047	8d 85 90 fc ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00053	83 c4 14	 add	 esp, 20			; 00000014H
  00056	8b 08		 mov	 ecx, DWORD PTR [eax]
  00058	89 4d dc	 mov	 DWORD PTR $T41[ebp], ecx
  0005b	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0005e	89 55 e0	 mov	 DWORD PTR $T41[ebp+4], edx
  00061	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00064	89 45 e4	 mov	 DWORD PTR $T41[ebp+8], eax
  00067	8b 4d dc	 mov	 ecx, DWORD PTR $T41[ebp]
  0006a	89 4d ec	 mov	 DWORD PTR _y_range$[ebp], ecx
  0006d	8b 55 e0	 mov	 edx, DWORD PTR $T41[ebp+4]
  00070	89 55 f0	 mov	 DWORD PTR _y_range$[ebp+4], edx
  00073	8b 45 e4	 mov	 eax, DWORD PTR $T41[ebp+8]
  00076	89 45 f4	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 1675 :     uint8_t *YLine   = (uint8_t *)dst[0] + dst_y_pitch_byte * y_range.start_dst;

  00079	b9 04 00 00 00	 mov	 ecx, 4
  0007e	6b d1 00	 imul	 edx, ecx, 0
  00081	8b 43 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  00084	0f af 45 f0	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  00088	8b 4b 08	 mov	 ecx, DWORD PTR _dst$[ebx]
  0008b	03 04 11	 add	 eax, DWORD PTR [ecx+edx]
  0008e	89 45 d8	 mov	 DWORD PTR _YLine$[ebp], eax

; 1676 :     uint8_t *ULine   = (uint8_t *)dst[1] + dst_y_pitch_byte * y_range.start_dst;

  00091	ba 04 00 00 00	 mov	 edx, 4
  00096	c1 e2 00	 shl	 edx, 0
  00099	8b 43 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  0009c	0f af 45 f0	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  000a0	8b 4b 08	 mov	 ecx, DWORD PTR _dst$[ebx]
  000a3	03 04 11	 add	 eax, DWORD PTR [ecx+edx]
  000a6	89 45 d4	 mov	 DWORD PTR _ULine$[ebp], eax

; 1677 :     uint8_t *VLine   = (uint8_t *)dst[2] + dst_y_pitch_byte * y_range.start_dst;

  000a9	ba 04 00 00 00	 mov	 edx, 4
  000ae	d1 e2		 shl	 edx, 1
  000b0	8b 43 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  000b3	0f af 45 f0	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  000b7	8b 4b 08	 mov	 ecx, DWORD PTR _dst$[ebx]
  000ba	03 04 11	 add	 eax, DWORD PTR [ecx+edx]
  000bd	89 45 d0	 mov	 DWORD PTR _VLine$[ebp], eax

; 1678 :     uint8_t *ycpLine = (uint8_t *)src[0] + src_y_pitch_byte * y_range.start_src;

  000c0	ba 04 00 00 00	 mov	 edx, 4
  000c5	6b c2 00	 imul	 eax, edx, 0
  000c8	8b 4b 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebx]
  000cb	0f af 4d ec	 imul	 ecx, DWORD PTR _y_range$[ebp]
  000cf	8b 53 0c	 mov	 edx, DWORD PTR _src$[ebx]
  000d2	03 0c 02	 add	 ecx, DWORD PTR [edx+eax]
  000d5	89 4d cc	 mov	 DWORD PTR _ycpLine$[ebp], ecx

; 1679 :     const __m128i xC_pw_one = _mm_set1_epi16(1);

  000d8	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@00010001000100010001000100010001
  000df	0f 29 45 90	 movaps	 XMMWORD PTR $T40[ebp], xmm0
  000e3	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR $T40[ebp]
  000e7	0f 29 45 b0	 movaps	 XMMWORD PTR _xC_pw_one$[ebp], xmm0

; 1680 :     const __m128i xC_YCC = _mm_set1_epi32(1<<LSFT_YCC_16);

  000eb	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@00001000000010000000100000001000
  000f2	0f 29 85 50 ff
	ff ff		 movaps	 XMMWORD PTR $T39[ebp], xmm0
  000f9	0f 28 85 50 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T39[ebp]
  00100	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR _xC_YCC$[ebp], xmm0

; 1681 :     __m128i x1, x2, x3, xY, xU, xV;
; 1682 :     for (int y = 0; y < y_range.len; y++, ycpLine += src_y_pitch_byte, YLine += dst_y_pitch_byte, ULine += dst_y_pitch_byte, VLine += dst_y_pitch_byte) {

  00107	c7 85 ac fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _y$38[ebp], 0
  00111	eb 33		 jmp	 SHORT $LN4@convert_yc
$LN2@convert_yc:
  00113	8b 85 ac fe ff
	ff		 mov	 eax, DWORD PTR _y$38[ebp]
  00119	83 c0 01	 add	 eax, 1
  0011c	89 85 ac fe ff
	ff		 mov	 DWORD PTR _y$38[ebp], eax
  00122	8b 4d cc	 mov	 ecx, DWORD PTR _ycpLine$[ebp]
  00125	03 4b 14	 add	 ecx, DWORD PTR _src_y_pitch_byte$[ebx]
  00128	89 4d cc	 mov	 DWORD PTR _ycpLine$[ebp], ecx
  0012b	8b 55 d8	 mov	 edx, DWORD PTR _YLine$[ebp]
  0012e	03 53 1c	 add	 edx, DWORD PTR _dst_y_pitch_byte$[ebx]
  00131	89 55 d8	 mov	 DWORD PTR _YLine$[ebp], edx
  00134	8b 45 d4	 mov	 eax, DWORD PTR _ULine$[ebp]
  00137	03 43 1c	 add	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  0013a	89 45 d4	 mov	 DWORD PTR _ULine$[ebp], eax
  0013d	8b 4d d0	 mov	 ecx, DWORD PTR _VLine$[ebp]
  00140	03 4b 1c	 add	 ecx, DWORD PTR _dst_y_pitch_byte$[ebx]
  00143	89 4d d0	 mov	 DWORD PTR _VLine$[ebp], ecx
$LN4@convert_yc:
  00146	8b 95 ac fe ff
	ff		 mov	 edx, DWORD PTR _y$38[ebp]
  0014c	3b 55 f4	 cmp	 edx, DWORD PTR _y_range$[ebp+8]
  0014f	0f 8d 63 05 00
	00		 jge	 $LN1@convert_yc

; 1683 :         uint8_t *Y = YLine;

  00155	8b 45 d8	 mov	 eax, DWORD PTR _YLine$[ebp]
  00158	89 85 a8 fe ff
	ff		 mov	 DWORD PTR _Y$37[ebp], eax

; 1684 :         uint8_t *U = ULine;

  0015e	8b 4d d4	 mov	 ecx, DWORD PTR _ULine$[ebp]
  00161	89 8d a4 fe ff
	ff		 mov	 DWORD PTR _U$36[ebp], ecx

; 1685 :         uint8_t *V = VLine;

  00167	8b 55 d0	 mov	 edx, DWORD PTR _VLine$[ebp]
  0016a	89 95 a0 fe ff
	ff		 mov	 DWORD PTR _V$35[ebp], edx

; 1686 :         int16_t *const ycp_fin = (int16_t *)ycpLine + width * 3;

  00170	6b 43 10 03	 imul	 eax, DWORD PTR _width$[ebx], 3
  00174	8b 4d cc	 mov	 ecx, DWORD PTR _ycpLine$[ebp]
  00177	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  0017a	89 95 9c fe ff
	ff		 mov	 DWORD PTR _ycp_fin$34[ebp], edx

; 1687 :         for (int16_t *ycp = (int16_t *)ycpLine; ycp < ycp_fin; ycp += 48, Y += 16, U += 16, V += 16) {

  00180	8b 45 cc	 mov	 eax, DWORD PTR _ycpLine$[ebp]
  00183	89 85 98 fe ff
	ff		 mov	 DWORD PTR _ycp$33[ebp], eax
  00189	eb 3c		 jmp	 SHORT $LN7@convert_yc
$LN5@convert_yc:
  0018b	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR _ycp$33[ebp]
  00191	83 c1 60	 add	 ecx, 96			; 00000060H
  00194	89 8d 98 fe ff
	ff		 mov	 DWORD PTR _ycp$33[ebp], ecx
  0019a	8b 95 a8 fe ff
	ff		 mov	 edx, DWORD PTR _Y$37[ebp]
  001a0	83 c2 10	 add	 edx, 16			; 00000010H
  001a3	89 95 a8 fe ff
	ff		 mov	 DWORD PTR _Y$37[ebp], edx
  001a9	8b 85 a4 fe ff
	ff		 mov	 eax, DWORD PTR _U$36[ebp]
  001af	83 c0 10	 add	 eax, 16			; 00000010H
  001b2	89 85 a4 fe ff
	ff		 mov	 DWORD PTR _U$36[ebp], eax
  001b8	8b 8d a0 fe ff
	ff		 mov	 ecx, DWORD PTR _V$35[ebp]
  001be	83 c1 10	 add	 ecx, 16			; 00000010H
  001c1	89 8d a0 fe ff
	ff		 mov	 DWORD PTR _V$35[ebp], ecx
$LN7@convert_yc:
  001c7	8b 95 98 fe ff
	ff		 mov	 edx, DWORD PTR _ycp$33[ebp]
  001cd	3b 95 9c fe ff
	ff		 cmp	 edx, DWORD PTR _ycp_fin$34[ebp]
  001d3	0f 83 da 04 00
	00		 jae	 $LN6@convert_yc

; 1688 :             x1 = _mm_loadu_si128((__m128i *)(ycp +  0));

  001d9	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR _ycp$33[ebp]
  001df	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  001e2	0f 29 85 80 fe
	ff ff		 movaps	 XMMWORD PTR $T32[ebp], xmm0
  001e9	0f 28 85 80 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T32[ebp]
  001f0	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR _x1$[ebp], xmm0

; 1689 :             x2 = _mm_loadu_si128((__m128i *)(ycp +  8));

  001f7	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR _ycp$33[ebp]
  001fd	83 c1 10	 add	 ecx, 16			; 00000010H
  00200	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00203	0f 29 85 70 fe
	ff ff		 movaps	 XMMWORD PTR $T31[ebp], xmm0
  0020a	0f 28 85 70 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T31[ebp]
  00211	0f 29 85 10 ff
	ff ff		 movaps	 XMMWORD PTR _x2$[ebp], xmm0

; 1690 :             x3 = _mm_loadu_si128((__m128i *)(ycp + 16));

  00218	8b 95 98 fe ff
	ff		 mov	 edx, DWORD PTR _ycp$33[ebp]
  0021e	83 c2 20	 add	 edx, 32			; 00000020H
  00221	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  00224	0f 29 85 60 fe
	ff ff		 movaps	 XMMWORD PTR $T30[ebp], xmm0
  0022b	0f 28 85 60 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T30[ebp]
  00232	0f 29 85 f0 fe
	ff ff		 movaps	 XMMWORD PTR _x3$[ebp], xmm0

; 1691 :             gather_y_u_v_from_yc48(x1, x2, x3);

  00239	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _x3$[ebp]
  0023f	50		 push	 eax
  00240	8d 8d 10 ff ff
	ff		 lea	 ecx, DWORD PTR _x2$[ebp]
  00246	51		 push	 ecx
  00247	8d 95 30 ff ff
	ff		 lea	 edx, DWORD PTR _x1$[ebp]
  0024d	52		 push	 edx
  0024e	e8 00 00 00 00	 call	 ?gather_y_u_v_from_yc48@@YAXAAT__m128i@@00@Z ; gather_y_u_v_from_yc48
  00253	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1692 : 
; 1693 :             x1 = convert_y_range_from_yc48(x1, xC_Y_L_MA_16, Y_L_RSH_16, xC_YCC, xC_pw_one);

  00256	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR ?Array_Y_L_MA_16@@3QBFB
  0025d	0f 29 85 50 fe
	ff ff		 movaps	 XMMWORD PTR $T29[ebp], xmm0
  00264	8d 45 b0	 lea	 eax, DWORD PTR _xC_pw_one$[ebp]
  00267	50		 push	 eax
  00268	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR _xC_YCC$[ebp]
  0026e	51		 push	 ecx
  0026f	6a 04		 push	 4
  00271	8d 95 50 fe ff
	ff		 lea	 edx, DWORD PTR $T29[ebp]
  00277	52		 push	 edx
  00278	0f 28 85 30 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$[ebp]
  0027f	e8 00 00 00 00	 call	 ?convert_y_range_from_yc48@@YA?AT__m128i@@T1@ABT1@H11@Z ; convert_y_range_from_yc48
  00284	83 c4 10	 add	 esp, 16			; 00000010H
  00287	0f 29 85 40 fe
	ff ff		 movaps	 XMMWORD PTR $T28[ebp], xmm0
  0028e	0f 28 85 40 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T28[ebp]
  00295	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR _x1$[ebp], xmm0

; 1694 :             x2 = convert_uv_range_from_yc48(x2, _mm_set1_epi16(UV_OFFSET_x1), xC_UV_L_MA_16_444, UV_L_RSH_16_444, xC_YCC, xC_pw_one);

  0029c	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR ?Array_UV_L_MA_16_444@@3QBFB
  002a3	0f 29 85 20 fe
	ff ff		 movaps	 XMMWORD PTR $T26[ebp], xmm0
  002aa	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@08000800080008000800080008000800
  002b1	0f 29 85 30 fe
	ff ff		 movaps	 XMMWORD PTR $T27[ebp], xmm0
  002b8	8d 45 b0	 lea	 eax, DWORD PTR _xC_pw_one$[ebp]
  002bb	50		 push	 eax
  002bc	0f 28 8d 70 ff
	ff ff		 movaps	 xmm1, XMMWORD PTR _xC_YCC$[ebp]
  002c3	6a 00		 push	 0
  002c5	8d 8d 20 fe ff
	ff		 lea	 ecx, DWORD PTR $T26[ebp]
  002cb	51		 push	 ecx
  002cc	8d 95 30 fe ff
	ff		 lea	 edx, DWORD PTR $T27[ebp]
  002d2	52		 push	 edx
  002d3	0f 28 85 10 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x2$[ebp]
  002da	e8 00 00 00 00	 call	 ?convert_uv_range_from_yc48@@YA?AT__m128i@@T1@ABT1@1H01@Z ; convert_uv_range_from_yc48
  002df	83 c4 10	 add	 esp, 16			; 00000010H
  002e2	0f 29 85 10 fe
	ff ff		 movaps	 XMMWORD PTR $T25[ebp], xmm0
  002e9	0f 28 85 10 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T25[ebp]
  002f0	0f 29 85 10 ff
	ff ff		 movaps	 XMMWORD PTR _x2$[ebp], xmm0

; 1695 :             x3 = convert_uv_range_from_yc48(x3, _mm_set1_epi16(UV_OFFSET_x1), xC_UV_L_MA_16_444, UV_L_RSH_16_444, xC_YCC, xC_pw_one);

  002f7	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR ?Array_UV_L_MA_16_444@@3QBFB
  002fe	0f 29 85 f0 fd
	ff ff		 movaps	 XMMWORD PTR $T23[ebp], xmm0
  00305	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@08000800080008000800080008000800
  0030c	0f 29 85 00 fe
	ff ff		 movaps	 XMMWORD PTR $T24[ebp], xmm0
  00313	8d 45 b0	 lea	 eax, DWORD PTR _xC_pw_one$[ebp]
  00316	50		 push	 eax
  00317	0f 28 8d 70 ff
	ff ff		 movaps	 xmm1, XMMWORD PTR _xC_YCC$[ebp]
  0031e	6a 00		 push	 0
  00320	8d 8d f0 fd ff
	ff		 lea	 ecx, DWORD PTR $T23[ebp]
  00326	51		 push	 ecx
  00327	8d 95 00 fe ff
	ff		 lea	 edx, DWORD PTR $T24[ebp]
  0032d	52		 push	 edx
  0032e	0f 28 85 f0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _x3$[ebp]
  00335	e8 00 00 00 00	 call	 ?convert_uv_range_from_yc48@@YA?AT__m128i@@T1@ABT1@1H01@Z ; convert_uv_range_from_yc48
  0033a	83 c4 10	 add	 esp, 16			; 00000010H
  0033d	0f 29 85 e0 fd
	ff ff		 movaps	 XMMWORD PTR $T22[ebp], xmm0
  00344	0f 28 85 e0 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T22[ebp]
  0034b	0f 29 85 f0 fe
	ff ff		 movaps	 XMMWORD PTR _x3$[ebp], xmm0

; 1696 :             xY = _mm_srli_epi16(x1, 8);

  00352	0f 28 85 30 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$[ebp]
  00359	66 0f 71 d0 08	 psrlw	 xmm0, 8
  0035e	0f 29 85 d0 fd
	ff ff		 movaps	 XMMWORD PTR $T21[ebp], xmm0
  00365	0f 28 85 d0 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T21[ebp]
  0036c	0f 29 85 d0 fe
	ff ff		 movaps	 XMMWORD PTR _xY$[ebp], xmm0

; 1697 :             xU = _mm_srli_epi16(x2, 8);

  00373	0f 28 85 10 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x2$[ebp]
  0037a	66 0f 71 d0 08	 psrlw	 xmm0, 8
  0037f	0f 29 85 c0 fd
	ff ff		 movaps	 XMMWORD PTR $T20[ebp], xmm0
  00386	0f 28 85 c0 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T20[ebp]
  0038d	0f 29 85 c0 fe
	ff ff		 movaps	 XMMWORD PTR _xU$[ebp], xmm0

; 1698 :             xV = _mm_srli_epi16(x3, 8);

  00394	0f 28 85 f0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _x3$[ebp]
  0039b	66 0f 71 d0 08	 psrlw	 xmm0, 8
  003a0	0f 29 85 b0 fd
	ff ff		 movaps	 XMMWORD PTR $T19[ebp], xmm0
  003a7	0f 28 85 b0 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T19[ebp]
  003ae	0f 29 85 b0 fe
	ff ff		 movaps	 XMMWORD PTR _xV$[ebp], xmm0

; 1699 : 
; 1700 :             x1 = _mm_loadu_si128((__m128i *)(ycp + 24));

  003b5	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR _ycp$33[ebp]
  003bb	83 c0 30	 add	 eax, 48			; 00000030H
  003be	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  003c1	0f 29 85 a0 fd
	ff ff		 movaps	 XMMWORD PTR $T18[ebp], xmm0
  003c8	0f 28 85 a0 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T18[ebp]
  003cf	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR _x1$[ebp], xmm0

; 1701 :             x2 = _mm_loadu_si128((__m128i *)(ycp + 32));

  003d6	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR _ycp$33[ebp]
  003dc	83 c1 40	 add	 ecx, 64			; 00000040H
  003df	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  003e2	0f 29 85 90 fd
	ff ff		 movaps	 XMMWORD PTR $T17[ebp], xmm0
  003e9	0f 28 85 90 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T17[ebp]
  003f0	0f 29 85 10 ff
	ff ff		 movaps	 XMMWORD PTR _x2$[ebp], xmm0

; 1702 :             x3 = _mm_loadu_si128((__m128i *)(ycp + 40));

  003f7	8b 95 98 fe ff
	ff		 mov	 edx, DWORD PTR _ycp$33[ebp]
  003fd	83 c2 50	 add	 edx, 80			; 00000050H
  00400	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  00403	0f 29 85 80 fd
	ff ff		 movaps	 XMMWORD PTR $T16[ebp], xmm0
  0040a	0f 28 85 80 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T16[ebp]
  00411	0f 29 85 f0 fe
	ff ff		 movaps	 XMMWORD PTR _x3$[ebp], xmm0

; 1703 :             gather_y_u_v_from_yc48(x1, x2, x3);

  00418	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _x3$[ebp]
  0041e	50		 push	 eax
  0041f	8d 8d 10 ff ff
	ff		 lea	 ecx, DWORD PTR _x2$[ebp]
  00425	51		 push	 ecx
  00426	8d 95 30 ff ff
	ff		 lea	 edx, DWORD PTR _x1$[ebp]
  0042c	52		 push	 edx
  0042d	e8 00 00 00 00	 call	 ?gather_y_u_v_from_yc48@@YAXAAT__m128i@@00@Z ; gather_y_u_v_from_yc48
  00432	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1704 : 
; 1705 :             x1 = convert_y_range_from_yc48(x1, xC_Y_L_MA_16, Y_L_RSH_16, xC_YCC, xC_pw_one);

  00435	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR ?Array_Y_L_MA_16@@3QBFB
  0043c	0f 29 85 70 fd
	ff ff		 movaps	 XMMWORD PTR $T15[ebp], xmm0
  00443	8d 45 b0	 lea	 eax, DWORD PTR _xC_pw_one$[ebp]
  00446	50		 push	 eax
  00447	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR _xC_YCC$[ebp]
  0044d	51		 push	 ecx
  0044e	6a 04		 push	 4
  00450	8d 95 70 fd ff
	ff		 lea	 edx, DWORD PTR $T15[ebp]
  00456	52		 push	 edx
  00457	0f 28 85 30 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$[ebp]
  0045e	e8 00 00 00 00	 call	 ?convert_y_range_from_yc48@@YA?AT__m128i@@T1@ABT1@H11@Z ; convert_y_range_from_yc48
  00463	83 c4 10	 add	 esp, 16			; 00000010H
  00466	0f 29 85 60 fd
	ff ff		 movaps	 XMMWORD PTR $T14[ebp], xmm0
  0046d	0f 28 85 60 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T14[ebp]
  00474	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR _x1$[ebp], xmm0

; 1706 :             x2 = convert_uv_range_from_yc48(x2, _mm_set1_epi16(UV_OFFSET_x1), xC_UV_L_MA_16_444, UV_L_RSH_16_444, xC_YCC, xC_pw_one);

  0047b	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR ?Array_UV_L_MA_16_444@@3QBFB
  00482	0f 29 85 40 fd
	ff ff		 movaps	 XMMWORD PTR $T12[ebp], xmm0
  00489	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@08000800080008000800080008000800
  00490	0f 29 85 50 fd
	ff ff		 movaps	 XMMWORD PTR $T13[ebp], xmm0
  00497	8d 45 b0	 lea	 eax, DWORD PTR _xC_pw_one$[ebp]
  0049a	50		 push	 eax
  0049b	0f 28 8d 70 ff
	ff ff		 movaps	 xmm1, XMMWORD PTR _xC_YCC$[ebp]
  004a2	6a 00		 push	 0
  004a4	8d 8d 40 fd ff
	ff		 lea	 ecx, DWORD PTR $T12[ebp]
  004aa	51		 push	 ecx
  004ab	8d 95 50 fd ff
	ff		 lea	 edx, DWORD PTR $T13[ebp]
  004b1	52		 push	 edx
  004b2	0f 28 85 10 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x2$[ebp]
  004b9	e8 00 00 00 00	 call	 ?convert_uv_range_from_yc48@@YA?AT__m128i@@T1@ABT1@1H01@Z ; convert_uv_range_from_yc48
  004be	83 c4 10	 add	 esp, 16			; 00000010H
  004c1	0f 29 85 30 fd
	ff ff		 movaps	 XMMWORD PTR $T11[ebp], xmm0
  004c8	0f 28 85 30 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T11[ebp]
  004cf	0f 29 85 10 ff
	ff ff		 movaps	 XMMWORD PTR _x2$[ebp], xmm0

; 1707 :             x3 = convert_uv_range_from_yc48(x3, _mm_set1_epi16(UV_OFFSET_x1), xC_UV_L_MA_16_444, UV_L_RSH_16_444, xC_YCC, xC_pw_one);

  004d6	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR ?Array_UV_L_MA_16_444@@3QBFB
  004dd	0f 29 85 10 fd
	ff ff		 movaps	 XMMWORD PTR $T9[ebp], xmm0
  004e4	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@08000800080008000800080008000800
  004eb	0f 29 85 20 fd
	ff ff		 movaps	 XMMWORD PTR $T10[ebp], xmm0
  004f2	8d 45 b0	 lea	 eax, DWORD PTR _xC_pw_one$[ebp]
  004f5	50		 push	 eax
  004f6	0f 28 8d 70 ff
	ff ff		 movaps	 xmm1, XMMWORD PTR _xC_YCC$[ebp]
  004fd	6a 00		 push	 0
  004ff	8d 8d 10 fd ff
	ff		 lea	 ecx, DWORD PTR $T9[ebp]
  00505	51		 push	 ecx
  00506	8d 95 20 fd ff
	ff		 lea	 edx, DWORD PTR $T10[ebp]
  0050c	52		 push	 edx
  0050d	0f 28 85 f0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _x3$[ebp]
  00514	e8 00 00 00 00	 call	 ?convert_uv_range_from_yc48@@YA?AT__m128i@@T1@ABT1@1H01@Z ; convert_uv_range_from_yc48
  00519	83 c4 10	 add	 esp, 16			; 00000010H
  0051c	0f 29 85 00 fd
	ff ff		 movaps	 XMMWORD PTR $T8[ebp], xmm0
  00523	0f 28 85 00 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T8[ebp]
  0052a	0f 29 85 f0 fe
	ff ff		 movaps	 XMMWORD PTR _x3$[ebp], xmm0

; 1708 :             x1 = _mm_srli_epi16(x1, 8);

  00531	0f 28 85 30 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$[ebp]
  00538	66 0f 71 d0 08	 psrlw	 xmm0, 8
  0053d	0f 29 85 f0 fc
	ff ff		 movaps	 XMMWORD PTR $T7[ebp], xmm0
  00544	0f 28 85 f0 fc
	ff ff		 movaps	 xmm0, XMMWORD PTR $T7[ebp]
  0054b	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR _x1$[ebp], xmm0

; 1709 :             x2 = _mm_srli_epi16(x2, 8);

  00552	0f 28 85 10 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x2$[ebp]
  00559	66 0f 71 d0 08	 psrlw	 xmm0, 8
  0055e	0f 29 85 e0 fc
	ff ff		 movaps	 XMMWORD PTR $T6[ebp], xmm0
  00565	0f 28 85 e0 fc
	ff ff		 movaps	 xmm0, XMMWORD PTR $T6[ebp]
  0056c	0f 29 85 10 ff
	ff ff		 movaps	 XMMWORD PTR _x2$[ebp], xmm0

; 1710 :             x3 = _mm_srli_epi16(x3, 8);

  00573	0f 28 85 f0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _x3$[ebp]
  0057a	66 0f 71 d0 08	 psrlw	 xmm0, 8
  0057f	0f 29 85 d0 fc
	ff ff		 movaps	 XMMWORD PTR $T5[ebp], xmm0
  00586	0f 28 85 d0 fc
	ff ff		 movaps	 xmm0, XMMWORD PTR $T5[ebp]
  0058d	0f 29 85 f0 fe
	ff ff		 movaps	 XMMWORD PTR _x3$[ebp], xmm0

; 1711 : 
; 1712 :             xY = _mm_packus_epi16(xY, x1);

  00594	0f 28 85 d0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _xY$[ebp]
  0059b	66 0f 67 85 30
	ff ff ff	 packuswb xmm0, XMMWORD PTR _x1$[ebp]
  005a3	0f 29 85 c0 fc
	ff ff		 movaps	 XMMWORD PTR $T4[ebp], xmm0
  005aa	0f 28 85 c0 fc
	ff ff		 movaps	 xmm0, XMMWORD PTR $T4[ebp]
  005b1	0f 29 85 d0 fe
	ff ff		 movaps	 XMMWORD PTR _xY$[ebp], xmm0

; 1713 :             xU = _mm_packus_epi16(xU, x2);

  005b8	0f 28 85 c0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _xU$[ebp]
  005bf	66 0f 67 85 10
	ff ff ff	 packuswb xmm0, XMMWORD PTR _x2$[ebp]
  005c7	0f 29 85 b0 fc
	ff ff		 movaps	 XMMWORD PTR $T3[ebp], xmm0
  005ce	0f 28 85 b0 fc
	ff ff		 movaps	 xmm0, XMMWORD PTR $T3[ebp]
  005d5	0f 29 85 c0 fe
	ff ff		 movaps	 XMMWORD PTR _xU$[ebp], xmm0

; 1714 :             xV = _mm_packus_epi16(xV, x3);

  005dc	0f 28 85 b0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _xV$[ebp]
  005e3	66 0f 67 85 f0
	fe ff ff	 packuswb xmm0, XMMWORD PTR _x3$[ebp]
  005eb	0f 29 85 a0 fc
	ff ff		 movaps	 XMMWORD PTR $T2[ebp], xmm0
  005f2	0f 28 85 a0 fc
	ff ff		 movaps	 xmm0, XMMWORD PTR $T2[ebp]
  005f9	0f 29 85 b0 fe
	ff ff		 movaps	 XMMWORD PTR _xV$[ebp], xmm0

; 1715 : 
; 1716 :             _mm_store_switch_si128((__m128i*)Y, xY);

  00600	33 c0		 xor	 eax, eax
  00602	74 1c		 je	 SHORT $LN9@convert_yc
  00604	0f 28 85 d0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _xY$[ebp]
  0060b	8b 8d a8 fe ff
	ff		 mov	 ecx, DWORD PTR _Y$37[ebp]
  00611	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  00614	c7 85 8c fc ff
	ff 00 00 00 00	 mov	 DWORD PTR tv322[ebp], 0
  0061e	eb 1a		 jmp	 SHORT $LN10@convert_yc
$LN9@convert_yc:
  00620	0f 10 85 d0 fe
	ff ff		 movups	 xmm0, XMMWORD PTR _xY$[ebp]
  00627	8b 95 a8 fe ff
	ff		 mov	 edx, DWORD PTR _Y$37[ebp]
  0062d	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0
  00630	c7 85 8c fc ff
	ff 00 00 00 00	 mov	 DWORD PTR tv322[ebp], 0
$LN10@convert_yc:

; 1717 :             _mm_store_switch_si128((__m128i*)U, xU);

  0063a	33 c0		 xor	 eax, eax
  0063c	74 1c		 je	 SHORT $LN11@convert_yc
  0063e	0f 28 85 c0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _xU$[ebp]
  00645	8b 8d a4 fe ff
	ff		 mov	 ecx, DWORD PTR _U$36[ebp]
  0064b	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  0064e	c7 85 88 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR tv328[ebp], 0
  00658	eb 1a		 jmp	 SHORT $LN12@convert_yc
$LN11@convert_yc:
  0065a	0f 10 85 c0 fe
	ff ff		 movups	 xmm0, XMMWORD PTR _xU$[ebp]
  00661	8b 95 a4 fe ff
	ff		 mov	 edx, DWORD PTR _U$36[ebp]
  00667	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0
  0066a	c7 85 88 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR tv328[ebp], 0
$LN12@convert_yc:

; 1718 :             _mm_store_switch_si128((__m128i*)V, xV);

  00674	33 c0		 xor	 eax, eax
  00676	74 1c		 je	 SHORT $LN13@convert_yc
  00678	0f 28 85 b0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _xV$[ebp]
  0067f	8b 8d a0 fe ff
	ff		 mov	 ecx, DWORD PTR _V$35[ebp]
  00685	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  00688	c7 85 84 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR tv334[ebp], 0
  00692	eb 1a		 jmp	 SHORT $LN14@convert_yc
$LN13@convert_yc:
  00694	0f 10 85 b0 fe
	ff ff		 movups	 xmm0, XMMWORD PTR _xV$[ebp]
  0069b	8b 95 a0 fe ff
	ff		 mov	 edx, DWORD PTR _V$35[ebp]
  006a1	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0
  006a4	c7 85 84 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR tv334[ebp], 0
$LN14@convert_yc:

; 1719 :         }

  006ae	e9 d8 fa ff ff	 jmp	 $LN5@convert_yc
$LN6@convert_yc:

; 1720 :     }

  006b3	e9 5b fa ff ff	 jmp	 $LN2@convert_yc
$LN1@convert_yc:

; 1721 : }

  006b8	52		 push	 edx
  006b9	8b cd		 mov	 ecx, ebp
  006bb	50		 push	 eax
  006bc	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN22@convert_yc
  006c2	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  006c7	58		 pop	 eax
  006c8	5a		 pop	 edx
  006c9	5f		 pop	 edi
  006ca	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  006cd	33 cd		 xor	 ecx, ebp
  006cf	e8 00 00 00 00	 call	 @__security_check_cookie@4
  006d4	8b e5		 mov	 esp, ebp
  006d6	5d		 pop	 ebp
  006d7	8b e3		 mov	 esp, ebx
  006d9	5b		 pop	 ebx
  006da	c3		 ret	 0
  006db	90		 npad	 1
$LN22@convert_yc:
  006dc	06 00 00 00	 DD	 6
  006e0	00 00 00 00	 DD	 $LN21@convert_yc
$LN21@convert_yc:
  006e4	ec ff ff ff	 DD	 -20			; ffffffecH
  006e8	0c 00 00 00	 DD	 12			; 0000000cH
  006ec	00 00 00 00	 DD	 $LN15@convert_yc
  006f0	b0 ff ff ff	 DD	 -80			; ffffffb0H
  006f4	10 00 00 00	 DD	 16			; 00000010H
  006f8	00 00 00 00	 DD	 $LN16@convert_yc
  006fc	70 ff ff ff	 DD	 -144			; ffffff70H
  00700	10 00 00 00	 DD	 16			; 00000010H
  00704	00 00 00 00	 DD	 $LN17@convert_yc
  00708	30 ff ff ff	 DD	 -208			; ffffff30H
  0070c	10 00 00 00	 DD	 16			; 00000010H
  00710	00 00 00 00	 DD	 $LN18@convert_yc
  00714	10 ff ff ff	 DD	 -240			; ffffff10H
  00718	10 00 00 00	 DD	 16			; 00000010H
  0071c	00 00 00 00	 DD	 $LN19@convert_yc
  00720	f0 fe ff ff	 DD	 -272			; fffffef0H
  00724	10 00 00 00	 DD	 16			; 00000010H
  00728	00 00 00 00	 DD	 $LN20@convert_yc
$LN20@convert_yc:
  0072c	78		 DB	 120			; 00000078H
  0072d	33		 DB	 51			; 00000033H
  0072e	00		 DB	 0
$LN19@convert_yc:
  0072f	78		 DB	 120			; 00000078H
  00730	32		 DB	 50			; 00000032H
  00731	00		 DB	 0
$LN18@convert_yc:
  00732	78		 DB	 120			; 00000078H
  00733	31		 DB	 49			; 00000031H
  00734	00		 DB	 0
$LN17@convert_yc:
  00735	78		 DB	 120			; 00000078H
  00736	43		 DB	 67			; 00000043H
  00737	5f		 DB	 95			; 0000005fH
  00738	59		 DB	 89			; 00000059H
  00739	43		 DB	 67			; 00000043H
  0073a	43		 DB	 67			; 00000043H
  0073b	00		 DB	 0
$LN16@convert_yc:
  0073c	78		 DB	 120			; 00000078H
  0073d	43		 DB	 67			; 00000043H
  0073e	5f		 DB	 95			; 0000005fH
  0073f	70		 DB	 112			; 00000070H
  00740	77		 DB	 119			; 00000077H
  00741	5f		 DB	 95			; 0000005fH
  00742	6f		 DB	 111			; 0000006fH
  00743	6e		 DB	 110			; 0000006eH
  00744	65		 DB	 101			; 00000065H
  00745	00		 DB	 0
$LN15@convert_yc:
  00746	79		 DB	 121			; 00000079H
  00747	5f		 DB	 95			; 0000005fH
  00748	72		 DB	 114			; 00000072H
  00749	61		 DB	 97			; 00000061H
  0074a	6e		 DB	 110			; 0000006eH
  0074b	67		 DB	 103			; 00000067H
  0074c	65		 DB	 101			; 00000065H
  0074d	00		 DB	 0
??$convert_yc48_to_yuv444_simd@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yc48_to_yuv444_simd<0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yc48_to_yuv444_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yc48_to_yuv444_avx

; 88   : void convert_yc48_to_yuv444_avx(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   :     convert_yc48_to_yuv444_simd<false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yc48_to_yuv444_simd@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yc48_to_yuv444_simd<0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 90   : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yc48_to_yuv444_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yc48_to_yuv444_avx
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
tv315 = -704						; size = 4
tv259 = -700						; size = 4
tv214 = -696						; size = 4
tv183 = -692						; size = 4
$T1 = -688						; size = 12
$T2 = -672						; size = 16
$T3 = -656						; size = 16
$T4 = -640						; size = 16
$T5 = -624						; size = 16
$T6 = -608						; size = 16
$T7 = -592						; size = 16
$T8 = -576						; size = 16
$T9 = -560						; size = 16
$T10 = -544						; size = 16
$T11 = -528						; size = 16
$T12 = -512						; size = 16
$T13 = -496						; size = 16
$T14 = -480						; size = 16
$T15 = -464						; size = 16
$T16 = -448						; size = 16
$T17 = -432						; size = 16
$T18 = -416						; size = 16
$T19 = -400						; size = 16
$T20 = -384						; size = 16
$T21 = -368						; size = 16
$T22 = -352						; size = 16
$T23 = -336						; size = 16
_x3$ = -320						; size = 16
_x2$ = -288						; size = 16
_x1$ = -256						; size = 16
_x0$ = -224						; size = 16
$T24 = -196						; size = 12
_y_range$ = -180					; size = 12
_dst_y_pitch$ = -164					; size = 4
$T25 = -160						; size = 16
_xC_YCC$ = -128						; size = 16
$T26 = -96						; size = 16
_xC_pw_one$ = -64					; size = 16
_C$ = -44						; size = 4
_Y$ = -40						; size = 4
_ycpw$ = -36						; size = 4
_ycp$ = -32						; size = 4
_pixel$ = -28						; size = 4
_dst_C$ = -24						; size = 4
_dst_Y$ = -20						; size = 4
_i$ = -16						; size = 4
_y$ = -12						; size = 4
_x$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yc48_to_p010_i_simd@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yc48_to_p010_i_simd<0>

; 1633 : static __forceinline void convert_yc48_to_p010_i_simd(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec c0 02 00
	00		 sub	 esp, 704		; 000002c0H
  0001c	57		 push	 edi
  0001d	8d bd 40 fd ff
	ff		 lea	 edi, DWORD PTR [ebp-704]
  00023	b9 b0 00 00 00	 mov	 ecx, 176		; 000000b0H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1634 :     int x, y, i;
; 1635 :     short *dst_Y = (short *)dst[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 08	 mov	 edx, DWORD PTR _dst$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 ec	 mov	 DWORD PTR _dst_Y$[ebp], eax

; 1636 :     short *dst_C = (short *)dst[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 08	 mov	 edx, DWORD PTR _dst$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 e8	 mov	 DWORD PTR _dst_C$[ebp], eax

; 1637 :     const void  *pixel = src[0];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	6b d1 00	 imul	 edx, ecx, 0
  00063	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  00066	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00069	89 4d e4	 mov	 DWORD PTR _pixel$[ebp], ecx

; 1638 :     const short *ycp, *ycpw;
; 1639 :     short *Y = nullptr, *C = nullptr;

  0006c	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _Y$[ebp], 0
  00073	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _C$[ebp], 0

; 1640 :     const __m128i xC_pw_one = _mm_set1_epi16(1);

  0007a	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@00010001000100010001000100010001
  00081	0f 29 45 a0	 movaps	 XMMWORD PTR $T26[ebp], xmm0
  00085	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR $T26[ebp]
  00089	0f 29 45 c0	 movaps	 XMMWORD PTR _xC_pw_one$[ebp], xmm0

; 1641 :     const __m128i xC_YCC = _mm_set1_epi32(1<<LSFT_YCC_16);

  0008d	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@00001000000010000000100000001000
  00094	0f 29 85 60 ff
	ff ff		 movaps	 XMMWORD PTR $T25[ebp], xmm0
  0009b	0f 28 85 60 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T25[ebp]
  000a2	0f 29 45 80	 movaps	 XMMWORD PTR _xC_YCC$[ebp], xmm0

; 1642 :     const int dst_y_pitch = dst_y_pitch_byte >> 1;

  000a6	8b 53 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebx]
  000a9	d1 fa		 sar	 edx, 1
  000ab	89 95 5c ff ff
	ff		 mov	 DWORD PTR _dst_y_pitch$[ebp], edx

; 1643 :     const auto y_range = thread_y_range(0, height, thread_id, thread_n);

  000b1	8b 43 2c	 mov	 eax, DWORD PTR _thread_n$[ebx]
  000b4	50		 push	 eax
  000b5	8b 4b 28	 mov	 ecx, DWORD PTR _thread_id$[ebx]
  000b8	51		 push	 ecx
  000b9	8b 53 20	 mov	 edx, DWORD PTR _height$[ebx]
  000bc	52		 push	 edx
  000bd	6a 00		 push	 0
  000bf	8d 85 50 fd ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  000c5	50		 push	 eax
  000c6	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  000cb	83 c4 14	 add	 esp, 20			; 00000014H
  000ce	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d0	89 8d 3c ff ff
	ff		 mov	 DWORD PTR $T24[ebp], ecx
  000d6	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000d9	89 95 40 ff ff
	ff		 mov	 DWORD PTR $T24[ebp+4], edx
  000df	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000e2	89 85 44 ff ff
	ff		 mov	 DWORD PTR $T24[ebp+8], eax
  000e8	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR $T24[ebp]
  000ee	89 8d 4c ff ff
	ff		 mov	 DWORD PTR _y_range$[ebp], ecx
  000f4	8b 95 40 ff ff
	ff		 mov	 edx, DWORD PTR $T24[ebp+4]
  000fa	89 95 50 ff ff
	ff		 mov	 DWORD PTR _y_range$[ebp+4], edx
  00100	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR $T24[ebp+8]
  00106	89 85 54 ff ff
	ff		 mov	 DWORD PTR _y_range$[ebp+8], eax

; 1644 :     __m128i x0, x1, x2, x3;
; 1645 :     for (y = y_range.start_src; y < (y_range.start_src + y_range.len); y += 4) {

  0010c	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _y_range$[ebp]
  00112	89 4d f4	 mov	 DWORD PTR _y$[ebp], ecx
  00115	eb 09		 jmp	 SHORT $LN4@convert_yc
$LN2@convert_yc:
  00117	8b 55 f4	 mov	 edx, DWORD PTR _y$[ebp]
  0011a	83 c2 04	 add	 edx, 4
  0011d	89 55 f4	 mov	 DWORD PTR _y$[ebp], edx
$LN4@convert_yc:
  00120	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _y_range$[ebp]
  00126	03 85 54 ff ff
	ff		 add	 eax, DWORD PTR _y_range$[ebp+8]
  0012c	39 45 f4	 cmp	 DWORD PTR _y$[ebp], eax
  0012f	0f 8d 5b 04 00
	00		 jge	 $LN1@convert_yc

; 1646 :         for (i = 0; i < 2; i++) {

  00135	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0013c	eb 09		 jmp	 SHORT $LN7@convert_yc
$LN5@convert_yc:
  0013e	8b 4d f0	 mov	 ecx, DWORD PTR _i$[ebp]
  00141	83 c1 01	 add	 ecx, 1
  00144	89 4d f0	 mov	 DWORD PTR _i$[ebp], ecx
$LN7@convert_yc:
  00147	83 7d f0 02	 cmp	 DWORD PTR _i$[ebp], 2
  0014b	0f 8d 3a 04 00
	00		 jge	 $LN6@convert_yc

; 1647 :             ycp = (short*)pixel + width * (y + i) * 3;

  00151	8b 55 f4	 mov	 edx, DWORD PTR _y$[ebp]
  00154	03 55 f0	 add	 edx, DWORD PTR _i$[ebp]
  00157	0f af 53 10	 imul	 edx, DWORD PTR _width$[ebx]
  0015b	6b c2 03	 imul	 eax, edx, 3
  0015e	8b 4d e4	 mov	 ecx, DWORD PTR _pixel$[ebp]
  00161	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00164	89 55 e0	 mov	 DWORD PTR _ycp$[ebp], edx

; 1648 :             ycpw= ycp + width*2*3;

  00167	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  0016a	d1 e0		 shl	 eax, 1
  0016c	6b c8 03	 imul	 ecx, eax, 3
  0016f	8b 55 e0	 mov	 edx, DWORD PTR _ycp$[ebp]
  00172	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  00175	89 45 dc	 mov	 DWORD PTR _ycpw$[ebp], eax

; 1649 :             Y   = dst_Y + dst_y_pitch * (y + i);

  00178	8b 4d f4	 mov	 ecx, DWORD PTR _y$[ebp]
  0017b	03 4d f0	 add	 ecx, DWORD PTR _i$[ebp]
  0017e	0f af 8d 5c ff
	ff ff		 imul	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  00185	8b 55 ec	 mov	 edx, DWORD PTR _dst_Y$[ebp]
  00188	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  0018b	89 45 d8	 mov	 DWORD PTR _Y$[ebp], eax

; 1650 :             C   = dst_C + dst_y_pitch * (y + i*2) / 2;

  0018e	8b 4d f0	 mov	 ecx, DWORD PTR _i$[ebp]
  00191	8b 55 f4	 mov	 edx, DWORD PTR _y$[ebp]
  00194	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  00197	0f af 85 5c ff
	ff ff		 imul	 eax, DWORD PTR _dst_y_pitch$[ebp]
  0019e	99		 cdq
  0019f	2b c2		 sub	 eax, edx
  001a1	d1 f8		 sar	 eax, 1
  001a3	8b 4d e8	 mov	 ecx, DWORD PTR _dst_C$[ebp]
  001a6	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  001a9	89 55 d4	 mov	 DWORD PTR _C$[ebp], edx

; 1651 :             for (x = 0; x < width; x += 8, ycp += 24, ycpw += 24) {

  001ac	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _x$[ebp], 0
  001b3	eb 1b		 jmp	 SHORT $LN10@convert_yc
$LN8@convert_yc:
  001b5	8b 45 f8	 mov	 eax, DWORD PTR _x$[ebp]
  001b8	83 c0 08	 add	 eax, 8
  001bb	89 45 f8	 mov	 DWORD PTR _x$[ebp], eax
  001be	8b 4d e0	 mov	 ecx, DWORD PTR _ycp$[ebp]
  001c1	83 c1 30	 add	 ecx, 48			; 00000030H
  001c4	89 4d e0	 mov	 DWORD PTR _ycp$[ebp], ecx
  001c7	8b 55 dc	 mov	 edx, DWORD PTR _ycpw$[ebp]
  001ca	83 c2 30	 add	 edx, 48			; 00000030H
  001cd	89 55 dc	 mov	 DWORD PTR _ycpw$[ebp], edx
$LN10@convert_yc:
  001d0	8b 45 f8	 mov	 eax, DWORD PTR _x$[ebp]
  001d3	3b 43 10	 cmp	 eax, DWORD PTR _width$[ebx]
  001d6	0f 8d aa 03 00
	00		 jge	 $LN9@convert_yc

; 1652 :                 x1 = _mm_loadu_si128((__m128i *)(ycp +  0));

  001dc	8b 4d e0	 mov	 ecx, DWORD PTR _ycp$[ebp]
  001df	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  001e2	0f 29 85 b0 fe
	ff ff		 movaps	 XMMWORD PTR $T23[ebp], xmm0
  001e9	0f 28 85 b0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T23[ebp]
  001f0	0f 29 85 00 ff
	ff ff		 movaps	 XMMWORD PTR _x1$[ebp], xmm0

; 1653 :                 x2 = _mm_loadu_si128((__m128i *)(ycp +  8));

  001f7	8b 55 e0	 mov	 edx, DWORD PTR _ycp$[ebp]
  001fa	83 c2 10	 add	 edx, 16			; 00000010H
  001fd	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  00200	0f 29 85 a0 fe
	ff ff		 movaps	 XMMWORD PTR $T22[ebp], xmm0
  00207	0f 28 85 a0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T22[ebp]
  0020e	0f 29 85 e0 fe
	ff ff		 movaps	 XMMWORD PTR _x2$[ebp], xmm0

; 1654 :                 x3 = _mm_loadu_si128((__m128i *)(ycp + 16));

  00215	8b 45 e0	 mov	 eax, DWORD PTR _ycp$[ebp]
  00218	83 c0 20	 add	 eax, 32			; 00000020H
  0021b	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  0021e	0f 29 85 90 fe
	ff ff		 movaps	 XMMWORD PTR $T21[ebp], xmm0
  00225	0f 28 85 90 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T21[ebp]
  0022c	0f 29 85 c0 fe
	ff ff		 movaps	 XMMWORD PTR _x3$[ebp], xmm0

; 1655 :                 _mm_prefetch((const char *)ycpw, _MM_HINT_T1);

  00233	8b 4d dc	 mov	 ecx, DWORD PTR _ycpw$[ebp]
  00236	89 8d 4c fd ff
	ff		 mov	 DWORD PTR tv183[ebp], ecx
  0023c	8b 95 4c fd ff
	ff		 mov	 edx, DWORD PTR tv183[ebp]
  00242	0f 18 12	 prefetcht1 BYTE PTR [edx]

; 1656 :                 gather_y_uv_from_yc48(x1, x2, x3);

  00245	0f 28 85 c0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _x3$[ebp]
  0024c	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR _x2$[ebp]
  00252	50		 push	 eax
  00253	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR _x1$[ebp]
  00259	51		 push	 ecx
  0025a	e8 00 00 00 00	 call	 ?gather_y_uv_from_yc48@@YAXAAT__m128i@@0T1@@Z ; gather_y_uv_from_yc48
  0025f	83 c4 08	 add	 esp, 8

; 1657 :                 x0 = x2;

  00262	0f 28 85 e0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _x2$[ebp]
  00269	0f 29 85 20 ff
	ff ff		 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1658 :                 _mm_store_switch_si128((__m128i *)(Y + x), convert_y_range_from_yc48(x1, xC_Y_L_MA_16, Y_L_RSH_16, xC_YCC, xC_pw_one));

  00270	33 d2		 xor	 edx, edx
  00272	74 52		 je	 SHORT $LN12@convert_yc
  00274	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR ?Array_Y_L_MA_16@@3QBFB
  0027b	0f 29 85 80 fe
	ff ff		 movaps	 XMMWORD PTR $T20[ebp], xmm0
  00282	8d 45 c0	 lea	 eax, DWORD PTR _xC_pw_one$[ebp]
  00285	50		 push	 eax
  00286	8d 4d 80	 lea	 ecx, DWORD PTR _xC_YCC$[ebp]
  00289	51		 push	 ecx
  0028a	6a 04		 push	 4
  0028c	8d 95 80 fe ff
	ff		 lea	 edx, DWORD PTR $T20[ebp]
  00292	52		 push	 edx
  00293	0f 28 85 00 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$[ebp]
  0029a	e8 00 00 00 00	 call	 ?convert_y_range_from_yc48@@YA?AT__m128i@@T1@ABT1@H11@Z ; convert_y_range_from_yc48
  0029f	83 c4 10	 add	 esp, 16			; 00000010H
  002a2	0f 29 85 70 fe
	ff ff		 movaps	 XMMWORD PTR $T19[ebp], xmm0
  002a9	0f 28 85 70 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T19[ebp]
  002b0	8b 45 f8	 mov	 eax, DWORD PTR _x$[ebp]
  002b3	8b 4d d8	 mov	 ecx, DWORD PTR _Y$[ebp]
  002b6	0f 11 04 41	 movups	 XMMWORD PTR [ecx+eax*2], xmm0
  002ba	c7 85 48 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv214[ebp], 0
  002c4	eb 50		 jmp	 SHORT $LN13@convert_yc
$LN12@convert_yc:
  002c6	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR ?Array_Y_L_MA_16@@3QBFB
  002cd	0f 29 85 60 fe
	ff ff		 movaps	 XMMWORD PTR $T18[ebp], xmm0
  002d4	8d 55 c0	 lea	 edx, DWORD PTR _xC_pw_one$[ebp]
  002d7	52		 push	 edx
  002d8	8d 45 80	 lea	 eax, DWORD PTR _xC_YCC$[ebp]
  002db	50		 push	 eax
  002dc	6a 04		 push	 4
  002de	8d 8d 60 fe ff
	ff		 lea	 ecx, DWORD PTR $T18[ebp]
  002e4	51		 push	 ecx
  002e5	0f 28 85 00 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$[ebp]
  002ec	e8 00 00 00 00	 call	 ?convert_y_range_from_yc48@@YA?AT__m128i@@T1@ABT1@H11@Z ; convert_y_range_from_yc48
  002f1	83 c4 10	 add	 esp, 16			; 00000010H
  002f4	0f 29 85 50 fe
	ff ff		 movaps	 XMMWORD PTR $T17[ebp], xmm0
  002fb	0f 10 85 50 fe
	ff ff		 movups	 xmm0, XMMWORD PTR $T17[ebp]
  00302	8b 55 f8	 mov	 edx, DWORD PTR _x$[ebp]
  00305	8b 45 d8	 mov	 eax, DWORD PTR _Y$[ebp]
  00308	0f 11 04 50	 movups	 XMMWORD PTR [eax+edx*2], xmm0
  0030c	c7 85 48 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv214[ebp], 0
$LN13@convert_yc:

; 1659 : 
; 1660 :                 x1 = _mm_loadu_si128((__m128i *)(ycpw +  0));

  00316	8b 4d dc	 mov	 ecx, DWORD PTR _ycpw$[ebp]
  00319	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  0031c	0f 29 85 40 fe
	ff ff		 movaps	 XMMWORD PTR $T16[ebp], xmm0
  00323	0f 28 85 40 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T16[ebp]
  0032a	0f 29 85 00 ff
	ff ff		 movaps	 XMMWORD PTR _x1$[ebp], xmm0

; 1661 :                 x2 = _mm_loadu_si128((__m128i *)(ycpw +  8));

  00331	8b 55 dc	 mov	 edx, DWORD PTR _ycpw$[ebp]
  00334	83 c2 10	 add	 edx, 16			; 00000010H
  00337	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  0033a	0f 29 85 30 fe
	ff ff		 movaps	 XMMWORD PTR $T15[ebp], xmm0
  00341	0f 28 85 30 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T15[ebp]
  00348	0f 29 85 e0 fe
	ff ff		 movaps	 XMMWORD PTR _x2$[ebp], xmm0

; 1662 :                 x3 = _mm_loadu_si128((__m128i *)(ycpw + 16));

  0034f	8b 45 dc	 mov	 eax, DWORD PTR _ycpw$[ebp]
  00352	83 c0 20	 add	 eax, 32			; 00000020H
  00355	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00358	0f 29 85 20 fe
	ff ff		 movaps	 XMMWORD PTR $T14[ebp], xmm0
  0035f	0f 28 85 20 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T14[ebp]
  00366	0f 29 85 c0 fe
	ff ff		 movaps	 XMMWORD PTR _x3$[ebp], xmm0

; 1663 :                 gather_y_uv_from_yc48(x1, x2, x3);

  0036d	0f 28 85 c0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _x3$[ebp]
  00374	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR _x2$[ebp]
  0037a	51		 push	 ecx
  0037b	8d 95 00 ff ff
	ff		 lea	 edx, DWORD PTR _x1$[ebp]
  00381	52		 push	 edx
  00382	e8 00 00 00 00	 call	 ?gather_y_uv_from_yc48@@YAXAAT__m128i@@0T1@@Z ; gather_y_uv_from_yc48
  00387	83 c4 08	 add	 esp, 8

; 1664 :                 _mm_store_switch_si128((__m128i *)(Y + x + dst_y_pitch*2), convert_y_range_from_yc48(x1, xC_Y_L_MA_16, Y_L_RSH_16, xC_YCC, xC_pw_one));

  0038a	33 c0		 xor	 eax, eax
  0038c	74 5d		 je	 SHORT $LN14@convert_yc
  0038e	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR ?Array_Y_L_MA_16@@3QBFB
  00395	0f 29 85 10 fe
	ff ff		 movaps	 XMMWORD PTR $T13[ebp], xmm0
  0039c	8d 4d c0	 lea	 ecx, DWORD PTR _xC_pw_one$[ebp]
  0039f	51		 push	 ecx
  003a0	8d 55 80	 lea	 edx, DWORD PTR _xC_YCC$[ebp]
  003a3	52		 push	 edx
  003a4	6a 04		 push	 4
  003a6	8d 85 10 fe ff
	ff		 lea	 eax, DWORD PTR $T13[ebp]
  003ac	50		 push	 eax
  003ad	0f 28 85 00 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$[ebp]
  003b4	e8 00 00 00 00	 call	 ?convert_y_range_from_yc48@@YA?AT__m128i@@T1@ABT1@H11@Z ; convert_y_range_from_yc48
  003b9	83 c4 10	 add	 esp, 16			; 00000010H
  003bc	0f 29 85 00 fe
	ff ff		 movaps	 XMMWORD PTR $T12[ebp], xmm0
  003c3	0f 28 85 00 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T12[ebp]
  003ca	8b 4d f8	 mov	 ecx, DWORD PTR _x$[ebp]
  003cd	8b 55 d8	 mov	 edx, DWORD PTR _Y$[ebp]
  003d0	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  003d3	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  003d9	d1 e1		 shl	 ecx, 1
  003db	0f 11 04 48	 movups	 XMMWORD PTR [eax+ecx*2], xmm0
  003df	c7 85 44 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv259[ebp], 0
  003e9	eb 5b		 jmp	 SHORT $LN15@convert_yc
$LN14@convert_yc:
  003eb	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR ?Array_Y_L_MA_16@@3QBFB
  003f2	0f 29 85 f0 fd
	ff ff		 movaps	 XMMWORD PTR $T11[ebp], xmm0
  003f9	8d 55 c0	 lea	 edx, DWORD PTR _xC_pw_one$[ebp]
  003fc	52		 push	 edx
  003fd	8d 45 80	 lea	 eax, DWORD PTR _xC_YCC$[ebp]
  00400	50		 push	 eax
  00401	6a 04		 push	 4
  00403	8d 8d f0 fd ff
	ff		 lea	 ecx, DWORD PTR $T11[ebp]
  00409	51		 push	 ecx
  0040a	0f 28 85 00 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$[ebp]
  00411	e8 00 00 00 00	 call	 ?convert_y_range_from_yc48@@YA?AT__m128i@@T1@ABT1@H11@Z ; convert_y_range_from_yc48
  00416	83 c4 10	 add	 esp, 16			; 00000010H
  00419	0f 29 85 e0 fd
	ff ff		 movaps	 XMMWORD PTR $T10[ebp], xmm0
  00420	0f 10 85 e0 fd
	ff ff		 movups	 xmm0, XMMWORD PTR $T10[ebp]
  00427	8b 55 f8	 mov	 edx, DWORD PTR _x$[ebp]
  0042a	8b 45 d8	 mov	 eax, DWORD PTR _Y$[ebp]
  0042d	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00430	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  00436	d1 e2		 shl	 edx, 1
  00438	0f 11 04 51	 movups	 XMMWORD PTR [ecx+edx*2], xmm0
  0043c	c7 85 44 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv259[ebp], 0
$LN15@convert_yc:

; 1665 : 
; 1666 :                 _mm_store_switch_si128((__m128i *)(C + x), convert_uv_range_from_yc48_420i(x0, x2, _mm_set1_epi16(UV_OFFSET_x1), xC_UV_L_MA_16_420I(i), xC_UV_L_MA_16_420I((i+1)&0x01), UV_L_RSH_16_420I, xC_YCC, xC_pw_one));

  00446	33 c0		 xor	 eax, eax
  00448	0f 84 9c 00 00
	00		 je	 $LN16@convert_yc
  0044e	8b 4d f0	 mov	 ecx, DWORD PTR _i$[ebp]
  00451	83 c1 01	 add	 ecx, 1
  00454	83 e1 01	 and	 ecx, 1
  00457	c1 e1 05	 shl	 ecx, 5
  0045a	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?Array_UV_L_MA_16_420I@@3QAY0BA@$$CBFA
  00460	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00463	0f 29 85 b0 fd
	ff ff		 movaps	 XMMWORD PTR $T7[ebp], xmm0
  0046a	8b 55 f0	 mov	 edx, DWORD PTR _i$[ebp]
  0046d	c1 e2 05	 shl	 edx, 5
  00470	81 c2 00 00 00
	00		 add	 edx, OFFSET ?Array_UV_L_MA_16_420I@@3QAY0BA@$$CBFA
  00476	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  00479	0f 29 85 c0 fd
	ff ff		 movaps	 XMMWORD PTR $T8[ebp], xmm0
  00480	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@08000800080008000800080008000800
  00487	0f 29 85 d0 fd
	ff ff		 movaps	 XMMWORD PTR $T9[ebp], xmm0
  0048e	8d 45 c0	 lea	 eax, DWORD PTR _xC_pw_one$[ebp]
  00491	50		 push	 eax
  00492	8d 4d 80	 lea	 ecx, DWORD PTR _xC_YCC$[ebp]
  00495	51		 push	 ecx
  00496	6a 02		 push	 2
  00498	8d 95 b0 fd ff
	ff		 lea	 edx, DWORD PTR $T7[ebp]
  0049e	52		 push	 edx
  0049f	8d 85 c0 fd ff
	ff		 lea	 eax, DWORD PTR $T8[ebp]
  004a5	50		 push	 eax
  004a6	8d 8d d0 fd ff
	ff		 lea	 ecx, DWORD PTR $T9[ebp]
  004ac	51		 push	 ecx
  004ad	0f 28 8d e0 fe
	ff ff		 movaps	 xmm1, XMMWORD PTR _x2$[ebp]
  004b4	0f 28 85 20 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  004bb	e8 00 00 00 00	 call	 ?convert_uv_range_from_yc48_420i@@YA?AT__m128i@@T1@0ABT1@11H11@Z ; convert_uv_range_from_yc48_420i
  004c0	83 c4 18	 add	 esp, 24			; 00000018H
  004c3	0f 29 85 a0 fd
	ff ff		 movaps	 XMMWORD PTR $T6[ebp], xmm0
  004ca	0f 28 85 a0 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T6[ebp]
  004d1	8b 55 f8	 mov	 edx, DWORD PTR _x$[ebp]
  004d4	8b 45 d4	 mov	 eax, DWORD PTR _C$[ebp]
  004d7	0f 11 04 50	 movups	 XMMWORD PTR [eax+edx*2], xmm0
  004db	c7 85 40 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv315[ebp], 0
  004e5	e9 97 00 00 00	 jmp	 $LN17@convert_yc
$LN16@convert_yc:
  004ea	8b 4d f0	 mov	 ecx, DWORD PTR _i$[ebp]
  004ed	83 c1 01	 add	 ecx, 1
  004f0	83 e1 01	 and	 ecx, 1
  004f3	c1 e1 05	 shl	 ecx, 5
  004f6	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?Array_UV_L_MA_16_420I@@3QAY0BA@$$CBFA
  004fc	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  004ff	0f 29 85 70 fd
	ff ff		 movaps	 XMMWORD PTR $T3[ebp], xmm0
  00506	8b 55 f0	 mov	 edx, DWORD PTR _i$[ebp]
  00509	c1 e2 05	 shl	 edx, 5
  0050c	81 c2 00 00 00
	00		 add	 edx, OFFSET ?Array_UV_L_MA_16_420I@@3QAY0BA@$$CBFA
  00512	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  00515	0f 29 85 80 fd
	ff ff		 movaps	 XMMWORD PTR $T4[ebp], xmm0
  0051c	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@08000800080008000800080008000800
  00523	0f 29 85 90 fd
	ff ff		 movaps	 XMMWORD PTR $T5[ebp], xmm0
  0052a	8d 45 c0	 lea	 eax, DWORD PTR _xC_pw_one$[ebp]
  0052d	50		 push	 eax
  0052e	8d 4d 80	 lea	 ecx, DWORD PTR _xC_YCC$[ebp]
  00531	51		 push	 ecx
  00532	6a 02		 push	 2
  00534	8d 95 70 fd ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  0053a	52		 push	 edx
  0053b	8d 85 80 fd ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  00541	50		 push	 eax
  00542	8d 8d 90 fd ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  00548	51		 push	 ecx
  00549	0f 28 8d e0 fe
	ff ff		 movaps	 xmm1, XMMWORD PTR _x2$[ebp]
  00550	0f 28 85 20 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  00557	e8 00 00 00 00	 call	 ?convert_uv_range_from_yc48_420i@@YA?AT__m128i@@T1@0ABT1@11H11@Z ; convert_uv_range_from_yc48_420i
  0055c	83 c4 18	 add	 esp, 24			; 00000018H
  0055f	0f 29 85 60 fd
	ff ff		 movaps	 XMMWORD PTR $T2[ebp], xmm0
  00566	0f 10 85 60 fd
	ff ff		 movups	 xmm0, XMMWORD PTR $T2[ebp]
  0056d	8b 55 f8	 mov	 edx, DWORD PTR _x$[ebp]
  00570	8b 45 d4	 mov	 eax, DWORD PTR _C$[ebp]
  00573	0f 11 04 50	 movups	 XMMWORD PTR [eax+edx*2], xmm0
  00577	c7 85 40 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv315[ebp], 0
$LN17@convert_yc:

; 1667 :             }

  00581	e9 2f fc ff ff	 jmp	 $LN8@convert_yc
$LN9@convert_yc:

; 1668 :         }

  00586	e9 b3 fb ff ff	 jmp	 $LN5@convert_yc
$LN6@convert_yc:

; 1669 :     }

  0058b	e9 87 fb ff ff	 jmp	 $LN2@convert_yc
$LN1@convert_yc:

; 1670 : }

  00590	52		 push	 edx
  00591	8b cd		 mov	 ecx, ebp
  00593	50		 push	 eax
  00594	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN24@convert_yc
  0059a	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0059f	58		 pop	 eax
  005a0	5a		 pop	 edx
  005a1	5f		 pop	 edi
  005a2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005a5	33 cd		 xor	 ecx, ebp
  005a7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005ac	8b e5		 mov	 esp, ebp
  005ae	5d		 pop	 ebp
  005af	8b e3		 mov	 esp, ebx
  005b1	5b		 pop	 ebx
  005b2	c3		 ret	 0
  005b3	90		 npad	 1
$LN24@convert_yc:
  005b4	05 00 00 00	 DD	 5
  005b8	00 00 00 00	 DD	 $LN23@convert_yc
$LN23@convert_yc:
  005bc	c0 ff ff ff	 DD	 -64			; ffffffc0H
  005c0	10 00 00 00	 DD	 16			; 00000010H
  005c4	00 00 00 00	 DD	 $LN18@convert_yc
  005c8	80 ff ff ff	 DD	 -128			; ffffff80H
  005cc	10 00 00 00	 DD	 16			; 00000010H
  005d0	00 00 00 00	 DD	 $LN19@convert_yc
  005d4	4c ff ff ff	 DD	 -180			; ffffff4cH
  005d8	0c 00 00 00	 DD	 12			; 0000000cH
  005dc	00 00 00 00	 DD	 $LN20@convert_yc
  005e0	00 ff ff ff	 DD	 -256			; ffffff00H
  005e4	10 00 00 00	 DD	 16			; 00000010H
  005e8	00 00 00 00	 DD	 $LN21@convert_yc
  005ec	e0 fe ff ff	 DD	 -288			; fffffee0H
  005f0	10 00 00 00	 DD	 16			; 00000010H
  005f4	00 00 00 00	 DD	 $LN22@convert_yc
$LN22@convert_yc:
  005f8	78		 DB	 120			; 00000078H
  005f9	32		 DB	 50			; 00000032H
  005fa	00		 DB	 0
$LN21@convert_yc:
  005fb	78		 DB	 120			; 00000078H
  005fc	31		 DB	 49			; 00000031H
  005fd	00		 DB	 0
$LN20@convert_yc:
  005fe	79		 DB	 121			; 00000079H
  005ff	5f		 DB	 95			; 0000005fH
  00600	72		 DB	 114			; 00000072H
  00601	61		 DB	 97			; 00000061H
  00602	6e		 DB	 110			; 0000006eH
  00603	67		 DB	 103			; 00000067H
  00604	65		 DB	 101			; 00000065H
  00605	00		 DB	 0
$LN19@convert_yc:
  00606	78		 DB	 120			; 00000078H
  00607	43		 DB	 67			; 00000043H
  00608	5f		 DB	 95			; 0000005fH
  00609	59		 DB	 89			; 00000059H
  0060a	43		 DB	 67			; 00000043H
  0060b	43		 DB	 67			; 00000043H
  0060c	00		 DB	 0
$LN18@convert_yc:
  0060d	78		 DB	 120			; 00000078H
  0060e	43		 DB	 67			; 00000043H
  0060f	5f		 DB	 95			; 0000005fH
  00610	70		 DB	 112			; 00000070H
  00611	77		 DB	 119			; 00000077H
  00612	5f		 DB	 95			; 0000005fH
  00613	6f		 DB	 111			; 0000006fH
  00614	6e		 DB	 110			; 0000006eH
  00615	65		 DB	 101			; 00000065H
  00616	00		 DB	 0
??$convert_yc48_to_p010_i_simd@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yc48_to_p010_i_simd<0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yc48_to_p010_i_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yc48_to_p010_i_avx

; 84   : void convert_yc48_to_p010_i_avx(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 85   :     convert_yc48_to_p010_i_simd<false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yc48_to_p010_i_simd@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yc48_to_p010_i_simd<0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 86   : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yc48_to_p010_i_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yc48_to_p010_i_avx
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_rgb32r_to_rgb32_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_rgb32r_to_rgb32_avx

; 80   : void convert_rgb32r_to_rgb32_avx(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 81   :     convert_rgb32r_to_rgb32_simd(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ?convert_rgb32r_to_rgb32_simd@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_rgb32r_to_rgb32_simd
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 82   : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_rgb32r_to_rgb32_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_rgb32r_to_rgb32_avx
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
;	COMDAT ??$convert_rgb32_to_rgb32_simd@$0BN@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
_TEXT	SEGMENT
tv133 = -356						; size = 4
$T1 = -352						; size = 12
$T2 = -336						; size = 16
$T3 = -320						; size = 16
_x0$4 = -304						; size = 16
$T5 = -288						; size = 16
_src0$6 = -272						; size = 16
_x_offest$7 = -244					; size = 4
$T8 = -240						; size = 16
$T9 = -224						; size = 16
_x0$10 = -208						; size = 16
$T11 = -192						; size = 16
_src0$12 = -176						; size = 16
_x$13 = -152						; size = 4
_ptr_src$14 = -148					; size = 4
_ptr_dst$15 = -144					; size = 4
_y$16 = -140						; size = 4
_mask$17 = -136						; size = 4
_MASK_GBR4_TO_RGB4$18 = -128				; size = 16
_MASK_BGR4_TO_RGB4$19 = -96				; size = 16
_y$20 = -68						; size = 4
_x_width$ = -64						; size = 4
_dstLine$ = -60						; size = 4
_srcLine$ = -56						; size = 4
$T21 = -52						; size = 12
_y_range$ = -36						; size = 12
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_rgb32_to_rgb32_simd@$0BN@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_rgb32_to_rgb32_simd<29>, COMDAT

; 829  : void convert_rgb32_to_rgb32_simd(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 70 01 00
	00		 sub	 esp, 368		; 00000170H
  0001c	57		 push	 edi
  0001d	8d bd 90 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-368]
  00023	b9 5c 00 00 00	 mov	 ecx, 92			; 0000005cH
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 830  :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 831  :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 832  :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 833  :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 834  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  0007c	8b 53 2c	 mov	 edx, DWORD PTR _thread_n$[ebx]
  0007f	52		 push	 edx
  00080	8b 43 28	 mov	 eax, DWORD PTR _thread_id$[ebx]
  00083	50		 push	 eax
  00084	8b 4b 20	 mov	 ecx, DWORD PTR _height$[ebx]
  00087	2b 4d ec	 sub	 ecx, DWORD PTR _crop_bottom$[ebp]
  0008a	51		 push	 ecx
  0008b	8b 55 f4	 mov	 edx, DWORD PTR _crop_up$[ebp]
  0008e	52		 push	 edx
  0008f	8d 85 a0 fe ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  00095	50		 push	 eax
  00096	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  0009b	83 c4 14	 add	 esp, 20			; 00000014H
  0009e	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a0	89 4d cc	 mov	 DWORD PTR $T21[ebp], ecx
  000a3	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a6	89 55 d0	 mov	 DWORD PTR $T21[ebp+4], edx
  000a9	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000ac	89 45 d4	 mov	 DWORD PTR $T21[ebp+8], eax
  000af	8b 4d cc	 mov	 ecx, DWORD PTR $T21[ebp]
  000b2	89 4d dc	 mov	 DWORD PTR _y_range$[ebp], ecx
  000b5	8b 55 d0	 mov	 edx, DWORD PTR $T21[ebp+4]
  000b8	89 55 e0	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000bb	8b 45 d4	 mov	 eax, DWORD PTR $T21[ebp+8]
  000be	89 45 e4	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 835  :     uint8_t *srcLine = (uint8_t *)src[0] + src_y_pitch_byte * y_range.start_src + crop_left * 4;

  000c1	b9 04 00 00 00	 mov	 ecx, 4
  000c6	6b d1 00	 imul	 edx, ecx, 0
  000c9	8b 43 14	 mov	 eax, DWORD PTR _src_y_pitch_byte$[ebx]
  000cc	0f af 45 dc	 imul	 eax, DWORD PTR _y_range$[ebp]
  000d0	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  000d3	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  000d6	03 d0		 add	 edx, eax
  000d8	8b 45 f8	 mov	 eax, DWORD PTR _crop_left$[ebp]
  000db	8d 0c 82	 lea	 ecx, DWORD PTR [edx+eax*4]
  000de	89 4d c8	 mov	 DWORD PTR _srcLine$[ebp], ecx

; 836  :     uint8_t *dstLine = (uint8_t *)dst[0] + dst_y_pitch_byte * y_range.start_dst;

  000e1	ba 04 00 00 00	 mov	 edx, 4
  000e6	6b c2 00	 imul	 eax, edx, 0
  000e9	8b 4b 1c	 mov	 ecx, DWORD PTR _dst_y_pitch_byte$[ebx]
  000ec	0f af 4d e0	 imul	 ecx, DWORD PTR _y_range$[ebp+4]
  000f0	8b 53 08	 mov	 edx, DWORD PTR _dst$[ebx]
  000f3	03 0c 02	 add	 ecx, DWORD PTR [edx+eax]
  000f6	89 4d c4	 mov	 DWORD PTR _dstLine$[ebp], ecx

; 837  :     const int x_width = width - crop_right - crop_left;

  000f9	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  000fc	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  000ff	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  00102	89 45 c0	 mov	 DWORD PTR _x_width$[ebp], eax

; 838  :     if (csp_from == RGY_CSP_RGB24) {

  00105	33 c9		 xor	 ecx, ecx
  00107	74 4a		 je	 SHORT $LN13@convert_rg

; 839  :     for (int y = 0; y < y_range.len; y++, dstLine += dst_y_pitch_byte, srcLine += src_y_pitch_byte) {

  00109	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _y$20[ebp], 0
  00110	eb 1b		 jmp	 SHORT $LN4@convert_rg
$LN2@convert_rg:
  00112	8b 55 bc	 mov	 edx, DWORD PTR _y$20[ebp]
  00115	83 c2 01	 add	 edx, 1
  00118	89 55 bc	 mov	 DWORD PTR _y$20[ebp], edx
  0011b	8b 45 c4	 mov	 eax, DWORD PTR _dstLine$[ebp]
  0011e	03 43 1c	 add	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  00121	89 45 c4	 mov	 DWORD PTR _dstLine$[ebp], eax
  00124	8b 4d c8	 mov	 ecx, DWORD PTR _srcLine$[ebp]
  00127	03 4b 14	 add	 ecx, DWORD PTR _src_y_pitch_byte$[ebx]
  0012a	89 4d c8	 mov	 DWORD PTR _srcLine$[ebp], ecx
$LN4@convert_rg:
  0012d	8b 55 bc	 mov	 edx, DWORD PTR _y$20[ebp]
  00130	3b 55 e4	 cmp	 edx, DWORD PTR _y_range$[ebp+8]
  00133	7d 19		 jge	 SHORT $LN3@convert_rg

; 840  :         memcpy_sse(dstLine, srcLine, x_width * 4);

  00135	8b 45 c0	 mov	 eax, DWORD PTR _x_width$[ebp]
  00138	c1 e0 02	 shl	 eax, 2
  0013b	50		 push	 eax
  0013c	8b 4d c8	 mov	 ecx, DWORD PTR _srcLine$[ebp]
  0013f	51		 push	 ecx
  00140	8b 55 c4	 mov	 edx, DWORD PTR _dstLine$[ebp]
  00143	52		 push	 edx
  00144	e8 00 00 00 00	 call	 ?memcpy_sse@@YAXPAEPBEH@Z ; memcpy_sse
  00149	83 c4 0c	 add	 esp, 12			; 0000000cH

; 841  :     }

  0014c	eb c4		 jmp	 SHORT $LN2@convert_rg
$LN3@convert_rg:

; 842  :     } else {

  0014e	e9 60 02 00 00	 jmp	 $LN1@convert_rg
$LN13@convert_rg:

; 843  : #if USE_SSSE3
; 844  :         static_assert(csp_from == RGY_CSP_BGR32 || csp_from == RGY_CSP_RGB32, "invalid csp");
; 845  :         alignas(16) const char MASK_BGR4_TO_RGB4[] = { 2, 1, 0, 3, 6, 5, 4, 7, 10, 9, 8, 11, 14, 13, 12, 15 };

  00153	c6 45 a0 02	 mov	 BYTE PTR _MASK_BGR4_TO_RGB4$19[ebp], 2
  00157	c6 45 a1 01	 mov	 BYTE PTR _MASK_BGR4_TO_RGB4$19[ebp+1], 1
  0015b	c6 45 a2 00	 mov	 BYTE PTR _MASK_BGR4_TO_RGB4$19[ebp+2], 0
  0015f	c6 45 a3 03	 mov	 BYTE PTR _MASK_BGR4_TO_RGB4$19[ebp+3], 3
  00163	c6 45 a4 06	 mov	 BYTE PTR _MASK_BGR4_TO_RGB4$19[ebp+4], 6
  00167	c6 45 a5 05	 mov	 BYTE PTR _MASK_BGR4_TO_RGB4$19[ebp+5], 5
  0016b	c6 45 a6 04	 mov	 BYTE PTR _MASK_BGR4_TO_RGB4$19[ebp+6], 4
  0016f	c6 45 a7 07	 mov	 BYTE PTR _MASK_BGR4_TO_RGB4$19[ebp+7], 7
  00173	c6 45 a8 0a	 mov	 BYTE PTR _MASK_BGR4_TO_RGB4$19[ebp+8], 10 ; 0000000aH
  00177	c6 45 a9 09	 mov	 BYTE PTR _MASK_BGR4_TO_RGB4$19[ebp+9], 9
  0017b	c6 45 aa 08	 mov	 BYTE PTR _MASK_BGR4_TO_RGB4$19[ebp+10], 8
  0017f	c6 45 ab 0b	 mov	 BYTE PTR _MASK_BGR4_TO_RGB4$19[ebp+11], 11 ; 0000000bH
  00183	c6 45 ac 0e	 mov	 BYTE PTR _MASK_BGR4_TO_RGB4$19[ebp+12], 14 ; 0000000eH
  00187	c6 45 ad 0d	 mov	 BYTE PTR _MASK_BGR4_TO_RGB4$19[ebp+13], 13 ; 0000000dH
  0018b	c6 45 ae 0c	 mov	 BYTE PTR _MASK_BGR4_TO_RGB4$19[ebp+14], 12 ; 0000000cH
  0018f	c6 45 af 0f	 mov	 BYTE PTR _MASK_BGR4_TO_RGB4$19[ebp+15], 15 ; 0000000fH

; 846  :         alignas(16) const char MASK_GBR4_TO_RGB4[] = { 2, 0, 1, 3, 6, 4, 5, 7, 10, 8, 9, 11, 14, 12, 13, 15 };

  00193	c6 45 80 02	 mov	 BYTE PTR _MASK_GBR4_TO_RGB4$18[ebp], 2
  00197	c6 45 81 00	 mov	 BYTE PTR _MASK_GBR4_TO_RGB4$18[ebp+1], 0
  0019b	c6 45 82 01	 mov	 BYTE PTR _MASK_GBR4_TO_RGB4$18[ebp+2], 1
  0019f	c6 45 83 03	 mov	 BYTE PTR _MASK_GBR4_TO_RGB4$18[ebp+3], 3
  001a3	c6 45 84 06	 mov	 BYTE PTR _MASK_GBR4_TO_RGB4$18[ebp+4], 6
  001a7	c6 45 85 04	 mov	 BYTE PTR _MASK_GBR4_TO_RGB4$18[ebp+5], 4
  001ab	c6 45 86 05	 mov	 BYTE PTR _MASK_GBR4_TO_RGB4$18[ebp+6], 5
  001af	c6 45 87 07	 mov	 BYTE PTR _MASK_GBR4_TO_RGB4$18[ebp+7], 7
  001b3	c6 45 88 0a	 mov	 BYTE PTR _MASK_GBR4_TO_RGB4$18[ebp+8], 10 ; 0000000aH
  001b7	c6 45 89 08	 mov	 BYTE PTR _MASK_GBR4_TO_RGB4$18[ebp+9], 8
  001bb	c6 45 8a 09	 mov	 BYTE PTR _MASK_GBR4_TO_RGB4$18[ebp+10], 9
  001bf	c6 45 8b 0b	 mov	 BYTE PTR _MASK_GBR4_TO_RGB4$18[ebp+11], 11 ; 0000000bH
  001c3	c6 45 8c 0e	 mov	 BYTE PTR _MASK_GBR4_TO_RGB4$18[ebp+12], 14 ; 0000000eH
  001c7	c6 45 8d 0c	 mov	 BYTE PTR _MASK_GBR4_TO_RGB4$18[ebp+13], 12 ; 0000000cH
  001cb	c6 45 8e 0d	 mov	 BYTE PTR _MASK_GBR4_TO_RGB4$18[ebp+14], 13 ; 0000000dH
  001cf	c6 45 8f 0f	 mov	 BYTE PTR _MASK_GBR4_TO_RGB4$18[ebp+15], 15 ; 0000000fH

; 847  :         const char *mask = nullptr;

  001d3	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _mask$17[ebp], 0

; 848  :         switch (csp_from) {

  001dd	c7 85 9c fe ff
	ff 1d 00 00 00	 mov	 DWORD PTR tv133[ebp], 29 ; 0000001dH

; 849  :         //case RGY_CSP_GBR32: mask = MASK_GBR4_TO_RGB4; break;
; 850  :         case RGY_CSP_BGR32:
; 851  :         default:            mask = MASK_BGR4_TO_RGB4; break;

  001e7	8d 45 a0	 lea	 eax, DWORD PTR _MASK_BGR4_TO_RGB4$19[ebp]
  001ea	89 85 78 ff ff
	ff		 mov	 DWORD PTR _mask$17[ebp], eax

; 852  :         }
; 853  :         for (int y = 0; y < y_range.len; y++, dstLine += dst_y_pitch_byte, srcLine += src_y_pitch_byte) {

  001f0	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _y$16[ebp], 0
  001fa	eb 21		 jmp	 SHORT $LN9@convert_rg
$LN7@convert_rg:
  001fc	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _y$16[ebp]
  00202	83 c1 01	 add	 ecx, 1
  00205	89 8d 74 ff ff
	ff		 mov	 DWORD PTR _y$16[ebp], ecx
  0020b	8b 55 c4	 mov	 edx, DWORD PTR _dstLine$[ebp]
  0020e	03 53 1c	 add	 edx, DWORD PTR _dst_y_pitch_byte$[ebx]
  00211	89 55 c4	 mov	 DWORD PTR _dstLine$[ebp], edx
  00214	8b 45 c8	 mov	 eax, DWORD PTR _srcLine$[ebp]
  00217	03 43 14	 add	 eax, DWORD PTR _src_y_pitch_byte$[ebx]
  0021a	89 45 c8	 mov	 DWORD PTR _srcLine$[ebp], eax
$LN9@convert_rg:
  0021d	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _y$16[ebp]
  00223	3b 4d e4	 cmp	 ecx, DWORD PTR _y_range$[ebp+8]
  00226	0f 8d 87 01 00
	00		 jge	 $LN1@convert_rg

; 854  :             uint8_t *ptr_dst = dstLine;

  0022c	8b 55 c4	 mov	 edx, DWORD PTR _dstLine$[ebp]
  0022f	89 95 70 ff ff
	ff		 mov	 DWORD PTR _ptr_dst$15[ebp], edx

; 855  :             uint8_t *ptr_src = srcLine;

  00235	8b 45 c8	 mov	 eax, DWORD PTR _srcLine$[ebp]
  00238	89 85 6c ff ff
	ff		 mov	 DWORD PTR _ptr_src$14[ebp], eax

; 856  :             for (int x = 0; x < x_width - 4; x += 4, ptr_dst += 16, ptr_src += 16) {

  0023e	c7 85 68 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _x$13[ebp], 0
  00248	eb 2d		 jmp	 SHORT $LN12@convert_rg
$LN10@convert_rg:
  0024a	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR _x$13[ebp]
  00250	83 c1 04	 add	 ecx, 4
  00253	89 8d 68 ff ff
	ff		 mov	 DWORD PTR _x$13[ebp], ecx
  00259	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR _ptr_dst$15[ebp]
  0025f	83 c2 10	 add	 edx, 16			; 00000010H
  00262	89 95 70 ff ff
	ff		 mov	 DWORD PTR _ptr_dst$15[ebp], edx
  00268	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _ptr_src$14[ebp]
  0026e	83 c0 10	 add	 eax, 16			; 00000010H
  00271	89 85 6c ff ff
	ff		 mov	 DWORD PTR _ptr_src$14[ebp], eax
$LN12@convert_rg:
  00277	8b 4d c0	 mov	 ecx, DWORD PTR _x_width$[ebp]
  0027a	83 e9 04	 sub	 ecx, 4
  0027d	39 8d 68 ff ff
	ff		 cmp	 DWORD PTR _x$13[ebp], ecx
  00283	7d 68		 jge	 SHORT $LN11@convert_rg

; 857  :                 __m128i src0 = _mm_loadu_si128((const __m128i *)(ptr_src +  0));

  00285	8b 95 6c ff ff
	ff		 mov	 edx, DWORD PTR _ptr_src$14[ebp]
  0028b	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  0028e	0f 29 85 40 ff
	ff ff		 movaps	 XMMWORD PTR $T11[ebp], xmm0
  00295	0f 28 85 40 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T11[ebp]
  0029c	0f 29 85 50 ff
	ff ff		 movaps	 XMMWORD PTR _src0$12[ebp], xmm0

; 858  :                 __m128i x0 = _mm_shuffle_epi8(src0, _mm_load_si128((__m128i *)(mask +  0)));

  002a3	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _mask$17[ebp]
  002a9	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  002ac	0f 29 85 20 ff
	ff ff		 movaps	 XMMWORD PTR $T9[ebp], xmm0
  002b3	0f 28 85 50 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _src0$12[ebp]
  002ba	66 0f 38 00 85
	20 ff ff ff	 pshufb	 xmm0, XMMWORD PTR $T9[ebp]
  002c3	0f 29 85 10 ff
	ff ff		 movaps	 XMMWORD PTR $T8[ebp], xmm0
  002ca	0f 28 85 10 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T8[ebp]
  002d1	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR _x0$10[ebp], xmm0

; 859  :                 _mm_storeu_si128((__m128i *)(ptr_dst +  0), x0);

  002d8	0f 10 85 30 ff
	ff ff		 movups	 xmm0, XMMWORD PTR _x0$10[ebp]
  002df	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _ptr_dst$15[ebp]
  002e5	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 860  :             }

  002e8	e9 5d ff ff ff	 jmp	 $LN10@convert_rg
$LN11@convert_rg:

; 861  :             if (x_width % 4) {

  002ed	8b 55 c0	 mov	 edx, DWORD PTR _x_width$[ebp]
  002f0	81 e2 03 00 00
	80		 and	 edx, -2147483645	; 80000003H
  002f6	79 05		 jns	 SHORT $LN23@convert_rg
  002f8	4a		 dec	 edx
  002f9	83 ca fc	 or	 edx, -4			; fffffffcH
  002fc	42		 inc	 edx
$LN23@convert_rg:
  002fd	85 d2		 test	 edx, edx
  002ff	74 4a		 je	 SHORT $LN16@convert_rg

; 862  :                 int x_offest = 4 - (x_width % 4);

  00301	8b 45 c0	 mov	 eax, DWORD PTR _x_width$[ebp]
  00304	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  00309	79 05		 jns	 SHORT $LN24@convert_rg
  0030b	48		 dec	 eax
  0030c	83 c8 fc	 or	 eax, -4			; fffffffcH
  0030f	40		 inc	 eax
$LN24@convert_rg:
  00310	b9 04 00 00 00	 mov	 ecx, 4
  00315	2b c8		 sub	 ecx, eax
  00317	89 8d 0c ff ff
	ff		 mov	 DWORD PTR _x_offest$7[ebp], ecx

; 863  :                 ptr_dst -= x_offest * 4;

  0031d	8b 95 0c ff ff
	ff		 mov	 edx, DWORD PTR _x_offest$7[ebp]
  00323	c1 e2 02	 shl	 edx, 2
  00326	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _ptr_dst$15[ebp]
  0032c	2b c2		 sub	 eax, edx
  0032e	89 85 70 ff ff
	ff		 mov	 DWORD PTR _ptr_dst$15[ebp], eax

; 864  :                 ptr_src -= x_offest * 4;

  00334	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR _x_offest$7[ebp]
  0033a	c1 e1 02	 shl	 ecx, 2
  0033d	8b 95 6c ff ff
	ff		 mov	 edx, DWORD PTR _ptr_src$14[ebp]
  00343	2b d1		 sub	 edx, ecx
  00345	89 95 6c ff ff
	ff		 mov	 DWORD PTR _ptr_src$14[ebp], edx
$LN16@convert_rg:

; 865  :             }
; 866  :             __m128i src0 = _mm_loadu_si128((const __m128i *)(ptr_src +  0));

  0034b	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _ptr_src$14[ebp]
  00351	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00354	0f 29 85 e0 fe
	ff ff		 movaps	 XMMWORD PTR $T5[ebp], xmm0
  0035b	0f 28 85 e0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T5[ebp]
  00362	0f 29 85 f0 fe
	ff ff		 movaps	 XMMWORD PTR _src0$6[ebp], xmm0

; 867  :             __m128i x0 = _mm_shuffle_epi8(src0, _mm_load_si128((__m128i *)(mask +  0)));

  00369	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _mask$17[ebp]
  0036f	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00372	0f 29 85 c0 fe
	ff ff		 movaps	 XMMWORD PTR $T3[ebp], xmm0
  00379	0f 28 85 f0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _src0$6[ebp]
  00380	66 0f 38 00 85
	c0 fe ff ff	 pshufb	 xmm0, XMMWORD PTR $T3[ebp]
  00389	0f 29 85 b0 fe
	ff ff		 movaps	 XMMWORD PTR $T2[ebp], xmm0
  00390	0f 28 85 b0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T2[ebp]
  00397	0f 29 85 d0 fe
	ff ff		 movaps	 XMMWORD PTR _x0$4[ebp], xmm0

; 868  :             _mm_storeu_si128((__m128i *)(ptr_dst +  0), x0);

  0039e	0f 10 85 d0 fe
	ff ff		 movups	 xmm0, XMMWORD PTR _x0$4[ebp]
  003a5	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR _ptr_dst$15[ebp]
  003ab	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 869  :         }

  003ae	e9 49 fe ff ff	 jmp	 $LN7@convert_rg
$LN1@convert_rg:

; 870  : #else
; 871  :         static_assert(csp_from == RGY_CSP_RGB32, "invalid csp");
; 872  : #endif
; 873  :     }
; 874  : }

  003b3	52		 push	 edx
  003b4	8b cd		 mov	 ecx, ebp
  003b6	50		 push	 eax
  003b7	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN22@convert_rg
  003bd	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  003c2	58		 pop	 eax
  003c3	5a		 pop	 edx
  003c4	5f		 pop	 edi
  003c5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003c8	33 cd		 xor	 ecx, ebp
  003ca	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003cf	8b e5		 mov	 esp, ebp
  003d1	5d		 pop	 ebp
  003d2	8b e3		 mov	 esp, ebx
  003d4	5b		 pop	 ebx
  003d5	c3		 ret	 0
  003d6	66 90		 npad	 2
$LN22@convert_rg:
  003d8	03 00 00 00	 DD	 3
  003dc	00 00 00 00	 DD	 $LN21@convert_rg
$LN21@convert_rg:
  003e0	dc ff ff ff	 DD	 -36			; ffffffdcH
  003e4	0c 00 00 00	 DD	 12			; 0000000cH
  003e8	00 00 00 00	 DD	 $LN18@convert_rg
  003ec	a0 ff ff ff	 DD	 -96			; ffffffa0H
  003f0	10 00 00 00	 DD	 16			; 00000010H
  003f4	00 00 00 00	 DD	 $LN19@convert_rg
  003f8	80 ff ff ff	 DD	 -128			; ffffff80H
  003fc	10 00 00 00	 DD	 16			; 00000010H
  00400	00 00 00 00	 DD	 $LN20@convert_rg
$LN20@convert_rg:
  00404	4d		 DB	 77			; 0000004dH
  00405	41		 DB	 65			; 00000041H
  00406	53		 DB	 83			; 00000053H
  00407	4b		 DB	 75			; 0000004bH
  00408	5f		 DB	 95			; 0000005fH
  00409	47		 DB	 71			; 00000047H
  0040a	42		 DB	 66			; 00000042H
  0040b	52		 DB	 82			; 00000052H
  0040c	34		 DB	 52			; 00000034H
  0040d	5f		 DB	 95			; 0000005fH
  0040e	54		 DB	 84			; 00000054H
  0040f	4f		 DB	 79			; 0000004fH
  00410	5f		 DB	 95			; 0000005fH
  00411	52		 DB	 82			; 00000052H
  00412	47		 DB	 71			; 00000047H
  00413	42		 DB	 66			; 00000042H
  00414	34		 DB	 52			; 00000034H
  00415	00		 DB	 0
$LN19@convert_rg:
  00416	4d		 DB	 77			; 0000004dH
  00417	41		 DB	 65			; 00000041H
  00418	53		 DB	 83			; 00000053H
  00419	4b		 DB	 75			; 0000004bH
  0041a	5f		 DB	 95			; 0000005fH
  0041b	42		 DB	 66			; 00000042H
  0041c	47		 DB	 71			; 00000047H
  0041d	52		 DB	 82			; 00000052H
  0041e	34		 DB	 52			; 00000034H
  0041f	5f		 DB	 95			; 0000005fH
  00420	54		 DB	 84			; 00000054H
  00421	4f		 DB	 79			; 0000004fH
  00422	5f		 DB	 95			; 0000005fH
  00423	52		 DB	 82			; 00000052H
  00424	47		 DB	 71			; 00000047H
  00425	42		 DB	 66			; 00000042H
  00426	34		 DB	 52			; 00000034H
  00427	00		 DB	 0
$LN18@convert_rg:
  00428	79		 DB	 121			; 00000079H
  00429	5f		 DB	 95			; 0000005fH
  0042a	72		 DB	 114			; 00000072H
  0042b	61		 DB	 97			; 00000061H
  0042c	6e		 DB	 110			; 0000006eH
  0042d	67		 DB	 103			; 00000067H
  0042e	65		 DB	 101			; 00000065H
  0042f	00		 DB	 0
??$convert_rgb32_to_rgb32_simd@$0BN@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_rgb32_to_rgb32_simd<29>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_rgb32_to_rgb32_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_rgb32_to_rgb32_avx

; 76   : void convert_rgb32_to_rgb32_avx(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 77   :     convert_rgb32_to_rgb32_simd<RGY_CSP_RGB32>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_rgb32_to_rgb32_simd@$0BN@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_rgb32_to_rgb32_simd<29>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 78   : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_rgb32_to_rgb32_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_rgb32_to_rgb32_avx
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
tv273 = -624						; size = 4
tv250 = -620						; size = 4
tv207 = -616						; size = 4
tv144 = -612						; size = 4
$T1 = -608						; size = 12
$T2 = -592						; size = 16
$T3 = -576						; size = 16
$T4 = -560						; size = 16
$T5 = -544						; size = 16
$T6 = -528						; size = 16
$T7 = -512						; size = 16
$T8 = -496						; size = 16
$T9 = -480						; size = 16
$T10 = -464						; size = 16
$T11 = -448						; size = 16
$T12 = -432						; size = 16
$T13 = -416						; size = 16
$T14 = -400						; size = 16
$T15 = -384						; size = 16
$T16 = -368						; size = 16
$T17 = -352						; size = 16
$T18 = -336						; size = 16
_x3$ = -320						; size = 16
_x2$ = -288						; size = 16
_x1$ = -256						; size = 16
_x0$ = -224						; size = 16
_dst_y_pitch$ = -196					; size = 4
$T19 = -192						; size = 16
_xC_YCC$ = -160						; size = 16
$T20 = -128						; size = 16
_xC_pw_one$ = -96					; size = 16
_C$ = -72						; size = 4
_Y$ = -68						; size = 4
_ycpw$ = -64						; size = 4
_ycp$ = -60						; size = 4
_pixel$ = -56						; size = 4
_dst_C$ = -52						; size = 4
_dst_Y$ = -48						; size = 4
$T21 = -44						; size = 12
_y_range$ = -28						; size = 12
_y$ = -12						; size = 4
_x$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yc48_to_p010_simd@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yc48_to_p010_simd<0>

; 1591 : static __forceinline void convert_yc48_to_p010_simd(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 70 02 00
	00		 sub	 esp, 624		; 00000270H
  0001c	57		 push	 edi
  0001d	8d bd 90 fd ff
	ff		 lea	 edi, DWORD PTR [ebp-624]
  00023	b9 9c 00 00 00	 mov	 ecx, 156		; 0000009cH
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1592 :     int x, y;
; 1593 :     const auto y_range = thread_y_range(0, height, thread_id, thread_n);

  00039	8b 43 2c	 mov	 eax, DWORD PTR _thread_n$[ebx]
  0003c	50		 push	 eax
  0003d	8b 4b 28	 mov	 ecx, DWORD PTR _thread_id$[ebx]
  00040	51		 push	 ecx
  00041	8b 53 20	 mov	 edx, DWORD PTR _height$[ebx]
  00044	52		 push	 edx
  00045	6a 00		 push	 0
  00047	8d 85 a0 fd ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00053	83 c4 14	 add	 esp, 20			; 00000014H
  00056	8b 08		 mov	 ecx, DWORD PTR [eax]
  00058	89 4d d4	 mov	 DWORD PTR $T21[ebp], ecx
  0005b	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0005e	89 55 d8	 mov	 DWORD PTR $T21[ebp+4], edx
  00061	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00064	89 45 dc	 mov	 DWORD PTR $T21[ebp+8], eax
  00067	8b 4d d4	 mov	 ecx, DWORD PTR $T21[ebp]
  0006a	89 4d e4	 mov	 DWORD PTR _y_range$[ebp], ecx
  0006d	8b 55 d8	 mov	 edx, DWORD PTR $T21[ebp+4]
  00070	89 55 e8	 mov	 DWORD PTR _y_range$[ebp+4], edx
  00073	8b 45 dc	 mov	 eax, DWORD PTR $T21[ebp+8]
  00076	89 45 ec	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 1594 :     short *dst_Y = (short *)dst[0];

  00079	b9 04 00 00 00	 mov	 ecx, 4
  0007e	6b d1 00	 imul	 edx, ecx, 0
  00081	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  00084	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00087	89 4d d0	 mov	 DWORD PTR _dst_Y$[ebp], ecx

; 1595 :     short *dst_C = (short *)dst[1];

  0008a	ba 04 00 00 00	 mov	 edx, 4
  0008f	c1 e2 00	 shl	 edx, 0
  00092	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  00095	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00098	89 4d cc	 mov	 DWORD PTR _dst_C$[ebp], ecx

; 1596 :     const void  *pixel = src[0];

  0009b	ba 04 00 00 00	 mov	 edx, 4
  000a0	6b c2 00	 imul	 eax, edx, 0
  000a3	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  000a6	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  000a9	89 55 c8	 mov	 DWORD PTR _pixel$[ebp], edx

; 1597 :     const short *ycp, *ycpw;
; 1598 :     short *Y = NULL, *C = NULL;

  000ac	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _Y$[ebp], 0
  000b3	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _C$[ebp], 0

; 1599 :     const __m128i xC_pw_one = _mm_set1_epi16(1);

  000ba	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@00010001000100010001000100010001
  000c1	0f 29 45 80	 movaps	 XMMWORD PTR $T20[ebp], xmm0
  000c5	0f 28 45 80	 movaps	 xmm0, XMMWORD PTR $T20[ebp]
  000c9	0f 29 45 a0	 movaps	 XMMWORD PTR _xC_pw_one$[ebp], xmm0

; 1600 :     const __m128i xC_YCC = _mm_set1_epi32(1<<LSFT_YCC_16);

  000cd	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@00001000000010000000100000001000
  000d4	0f 29 85 40 ff
	ff ff		 movaps	 XMMWORD PTR $T19[ebp], xmm0
  000db	0f 28 85 40 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T19[ebp]
  000e2	0f 29 85 60 ff
	ff ff		 movaps	 XMMWORD PTR _xC_YCC$[ebp], xmm0

; 1601 :     const int dst_y_pitch = dst_y_pitch_byte >> 1;

  000e9	8b 43 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  000ec	d1 f8		 sar	 eax, 1
  000ee	89 85 3c ff ff
	ff		 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 1602 :     __m128i x0, x1, x2, x3;
; 1603 :     for (y = y_range.start_src; y < (y_range.start_src + y_range.len); y += 2) {

  000f4	8b 4d e4	 mov	 ecx, DWORD PTR _y_range$[ebp]
  000f7	89 4d f4	 mov	 DWORD PTR _y$[ebp], ecx
  000fa	eb 09		 jmp	 SHORT $LN4@convert_yc
$LN2@convert_yc:
  000fc	8b 55 f4	 mov	 edx, DWORD PTR _y$[ebp]
  000ff	83 c2 02	 add	 edx, 2
  00102	89 55 f4	 mov	 DWORD PTR _y$[ebp], edx
$LN4@convert_yc:
  00105	8b 45 e4	 mov	 eax, DWORD PTR _y_range$[ebp]
  00108	03 45 ec	 add	 eax, DWORD PTR _y_range$[ebp+8]
  0010b	39 45 f4	 cmp	 DWORD PTR _y$[ebp], eax
  0010e	0f 8d 95 03 00
	00		 jge	 $LN1@convert_yc

; 1604 :         ycp = (short*)pixel + width * y * 3;

  00114	8b 4b 10	 mov	 ecx, DWORD PTR _width$[ebx]
  00117	0f af 4d f4	 imul	 ecx, DWORD PTR _y$[ebp]
  0011b	6b d1 03	 imul	 edx, ecx, 3
  0011e	8b 45 c8	 mov	 eax, DWORD PTR _pixel$[ebp]
  00121	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00124	89 4d c4	 mov	 DWORD PTR _ycp$[ebp], ecx

; 1605 :         ycpw= ycp + width*3;

  00127	6b 53 10 03	 imul	 edx, DWORD PTR _width$[ebx], 3
  0012b	8b 45 c4	 mov	 eax, DWORD PTR _ycp$[ebp]
  0012e	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00131	89 4d c0	 mov	 DWORD PTR _ycpw$[ebp], ecx

; 1606 :         Y   = dst_Y + dst_y_pitch * y;

  00134	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  0013a	0f af 55 f4	 imul	 edx, DWORD PTR _y$[ebp]
  0013e	8b 45 d0	 mov	 eax, DWORD PTR _dst_Y$[ebp]
  00141	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00144	89 4d bc	 mov	 DWORD PTR _Y$[ebp], ecx

; 1607 :         C   = dst_C + dst_y_pitch * y / 2;

  00147	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  0014d	0f af 45 f4	 imul	 eax, DWORD PTR _y$[ebp]
  00151	99		 cdq
  00152	2b c2		 sub	 eax, edx
  00154	d1 f8		 sar	 eax, 1
  00156	8b 55 cc	 mov	 edx, DWORD PTR _dst_C$[ebp]
  00159	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  0015c	89 45 b8	 mov	 DWORD PTR _C$[ebp], eax

; 1608 :         for (x = 0; x < width; x += 8, ycp += 24, ycpw += 24) {

  0015f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _x$[ebp], 0
  00166	eb 1b		 jmp	 SHORT $LN7@convert_yc
$LN5@convert_yc:
  00168	8b 4d f8	 mov	 ecx, DWORD PTR _x$[ebp]
  0016b	83 c1 08	 add	 ecx, 8
  0016e	89 4d f8	 mov	 DWORD PTR _x$[ebp], ecx
  00171	8b 55 c4	 mov	 edx, DWORD PTR _ycp$[ebp]
  00174	83 c2 30	 add	 edx, 48			; 00000030H
  00177	89 55 c4	 mov	 DWORD PTR _ycp$[ebp], edx
  0017a	8b 45 c0	 mov	 eax, DWORD PTR _ycpw$[ebp]
  0017d	83 c0 30	 add	 eax, 48			; 00000030H
  00180	89 45 c0	 mov	 DWORD PTR _ycpw$[ebp], eax
$LN7@convert_yc:
  00183	8b 4d f8	 mov	 ecx, DWORD PTR _x$[ebp]
  00186	3b 4b 10	 cmp	 ecx, DWORD PTR _width$[ebx]
  00189	0f 8d 15 03 00
	00		 jge	 $LN6@convert_yc

; 1609 :             x1 = _mm_loadu_si128((__m128i *)(ycp +  0));

  0018f	8b 55 c4	 mov	 edx, DWORD PTR _ycp$[ebp]
  00192	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  00195	0f 29 85 b0 fe
	ff ff		 movaps	 XMMWORD PTR $T18[ebp], xmm0
  0019c	0f 28 85 b0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T18[ebp]
  001a3	0f 29 85 00 ff
	ff ff		 movaps	 XMMWORD PTR _x1$[ebp], xmm0

; 1610 :             x2 = _mm_loadu_si128((__m128i *)(ycp +  8));

  001aa	8b 45 c4	 mov	 eax, DWORD PTR _ycp$[ebp]
  001ad	83 c0 10	 add	 eax, 16			; 00000010H
  001b0	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  001b3	0f 29 85 a0 fe
	ff ff		 movaps	 XMMWORD PTR $T17[ebp], xmm0
  001ba	0f 28 85 a0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T17[ebp]
  001c1	0f 29 85 e0 fe
	ff ff		 movaps	 XMMWORD PTR _x2$[ebp], xmm0

; 1611 :             x3 = _mm_loadu_si128((__m128i *)(ycp + 16));

  001c8	8b 4d c4	 mov	 ecx, DWORD PTR _ycp$[ebp]
  001cb	83 c1 20	 add	 ecx, 32			; 00000020H
  001ce	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  001d1	0f 29 85 90 fe
	ff ff		 movaps	 XMMWORD PTR $T16[ebp], xmm0
  001d8	0f 28 85 90 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T16[ebp]
  001df	0f 29 85 c0 fe
	ff ff		 movaps	 XMMWORD PTR _x3$[ebp], xmm0

; 1612 :             _mm_prefetch((const char *)ycpw, _MM_HINT_T1);

  001e6	8b 55 c0	 mov	 edx, DWORD PTR _ycpw$[ebp]
  001e9	89 95 9c fd ff
	ff		 mov	 DWORD PTR tv144[ebp], edx
  001ef	8b 85 9c fd ff
	ff		 mov	 eax, DWORD PTR tv144[ebp]
  001f5	0f 18 10	 prefetcht1 BYTE PTR [eax]

; 1613 :             gather_y_uv_from_yc48(x1, x2, x3);

  001f8	0f 28 85 c0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _x3$[ebp]
  001ff	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR _x2$[ebp]
  00205	51		 push	 ecx
  00206	8d 95 00 ff ff
	ff		 lea	 edx, DWORD PTR _x1$[ebp]
  0020c	52		 push	 edx
  0020d	e8 00 00 00 00	 call	 ?gather_y_uv_from_yc48@@YAXAAT__m128i@@0T1@@Z ; gather_y_uv_from_yc48
  00212	83 c4 08	 add	 esp, 8

; 1614 :             x0 = x2;

  00215	0f 28 85 e0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _x2$[ebp]
  0021c	0f 29 85 20 ff
	ff ff		 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1615 : 
; 1616 :             _mm_store_switch_si128((__m128i *)(Y + x), convert_y_range_from_yc48(x1, xC_Y_L_MA_16, Y_L_RSH_16, xC_YCC, xC_pw_one));

  00223	33 c0		 xor	 eax, eax
  00225	74 55		 je	 SHORT $LN9@convert_yc
  00227	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR ?Array_Y_L_MA_16@@3QBFB
  0022e	0f 29 85 80 fe
	ff ff		 movaps	 XMMWORD PTR $T15[ebp], xmm0
  00235	8d 4d a0	 lea	 ecx, DWORD PTR _xC_pw_one$[ebp]
  00238	51		 push	 ecx
  00239	8d 95 60 ff ff
	ff		 lea	 edx, DWORD PTR _xC_YCC$[ebp]
  0023f	52		 push	 edx
  00240	6a 04		 push	 4
  00242	8d 85 80 fe ff
	ff		 lea	 eax, DWORD PTR $T15[ebp]
  00248	50		 push	 eax
  00249	0f 28 85 00 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$[ebp]
  00250	e8 00 00 00 00	 call	 ?convert_y_range_from_yc48@@YA?AT__m128i@@T1@ABT1@H11@Z ; convert_y_range_from_yc48
  00255	83 c4 10	 add	 esp, 16			; 00000010H
  00258	0f 29 85 70 fe
	ff ff		 movaps	 XMMWORD PTR $T14[ebp], xmm0
  0025f	0f 28 85 70 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T14[ebp]
  00266	8b 4d f8	 mov	 ecx, DWORD PTR _x$[ebp]
  00269	8b 55 bc	 mov	 edx, DWORD PTR _Y$[ebp]
  0026c	0f 11 04 4a	 movups	 XMMWORD PTR [edx+ecx*2], xmm0
  00270	c7 85 98 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv207[ebp], 0
  0027a	eb 53		 jmp	 SHORT $LN10@convert_yc
$LN9@convert_yc:
  0027c	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR ?Array_Y_L_MA_16@@3QBFB
  00283	0f 29 85 60 fe
	ff ff		 movaps	 XMMWORD PTR $T13[ebp], xmm0
  0028a	8d 45 a0	 lea	 eax, DWORD PTR _xC_pw_one$[ebp]
  0028d	50		 push	 eax
  0028e	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR _xC_YCC$[ebp]
  00294	51		 push	 ecx
  00295	6a 04		 push	 4
  00297	8d 95 60 fe ff
	ff		 lea	 edx, DWORD PTR $T13[ebp]
  0029d	52		 push	 edx
  0029e	0f 28 85 00 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$[ebp]
  002a5	e8 00 00 00 00	 call	 ?convert_y_range_from_yc48@@YA?AT__m128i@@T1@ABT1@H11@Z ; convert_y_range_from_yc48
  002aa	83 c4 10	 add	 esp, 16			; 00000010H
  002ad	0f 29 85 50 fe
	ff ff		 movaps	 XMMWORD PTR $T12[ebp], xmm0
  002b4	0f 10 85 50 fe
	ff ff		 movups	 xmm0, XMMWORD PTR $T12[ebp]
  002bb	8b 45 f8	 mov	 eax, DWORD PTR _x$[ebp]
  002be	8b 4d bc	 mov	 ecx, DWORD PTR _Y$[ebp]
  002c1	0f 11 04 41	 movups	 XMMWORD PTR [ecx+eax*2], xmm0
  002c5	c7 85 98 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv207[ebp], 0
$LN10@convert_yc:

; 1617 : 
; 1618 :             x1 = _mm_loadu_si128((__m128i *)(ycpw +  0));

  002cf	8b 55 c0	 mov	 edx, DWORD PTR _ycpw$[ebp]
  002d2	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  002d5	0f 29 85 40 fe
	ff ff		 movaps	 XMMWORD PTR $T11[ebp], xmm0
  002dc	0f 28 85 40 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T11[ebp]
  002e3	0f 29 85 00 ff
	ff ff		 movaps	 XMMWORD PTR _x1$[ebp], xmm0

; 1619 :             x2 = _mm_loadu_si128((__m128i *)(ycpw +  8));

  002ea	8b 45 c0	 mov	 eax, DWORD PTR _ycpw$[ebp]
  002ed	83 c0 10	 add	 eax, 16			; 00000010H
  002f0	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  002f3	0f 29 85 30 fe
	ff ff		 movaps	 XMMWORD PTR $T10[ebp], xmm0
  002fa	0f 28 85 30 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T10[ebp]
  00301	0f 29 85 e0 fe
	ff ff		 movaps	 XMMWORD PTR _x2$[ebp], xmm0

; 1620 :             x3 = _mm_loadu_si128((__m128i *)(ycpw + 16));

  00308	8b 4d c0	 mov	 ecx, DWORD PTR _ycpw$[ebp]
  0030b	83 c1 20	 add	 ecx, 32			; 00000020H
  0030e	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00311	0f 29 85 20 fe
	ff ff		 movaps	 XMMWORD PTR $T9[ebp], xmm0
  00318	0f 28 85 20 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T9[ebp]
  0031f	0f 29 85 c0 fe
	ff ff		 movaps	 XMMWORD PTR _x3$[ebp], xmm0

; 1621 :             gather_y_uv_from_yc48(x1, x2, x3);

  00326	0f 28 85 c0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _x3$[ebp]
  0032d	8d 95 e0 fe ff
	ff		 lea	 edx, DWORD PTR _x2$[ebp]
  00333	52		 push	 edx
  00334	8d 85 00 ff ff
	ff		 lea	 eax, DWORD PTR _x1$[ebp]
  0033a	50		 push	 eax
  0033b	e8 00 00 00 00	 call	 ?gather_y_uv_from_yc48@@YAXAAT__m128i@@0T1@@Z ; gather_y_uv_from_yc48
  00340	83 c4 08	 add	 esp, 8

; 1622 : 
; 1623 :             _mm_store_switch_si128((__m128i *)(Y + x + dst_y_pitch), convert_y_range_from_yc48(x1, xC_Y_L_MA_16, Y_L_RSH_16, xC_YCC, xC_pw_one));

  00343	33 c9		 xor	 ecx, ecx
  00345	74 5e		 je	 SHORT $LN11@convert_yc
  00347	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR ?Array_Y_L_MA_16@@3QBFB
  0034e	0f 29 85 10 fe
	ff ff		 movaps	 XMMWORD PTR $T8[ebp], xmm0
  00355	8d 55 a0	 lea	 edx, DWORD PTR _xC_pw_one$[ebp]
  00358	52		 push	 edx
  00359	8d 85 60 ff ff
	ff		 lea	 eax, DWORD PTR _xC_YCC$[ebp]
  0035f	50		 push	 eax
  00360	6a 04		 push	 4
  00362	8d 8d 10 fe ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp]
  00368	51		 push	 ecx
  00369	0f 28 85 00 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$[ebp]
  00370	e8 00 00 00 00	 call	 ?convert_y_range_from_yc48@@YA?AT__m128i@@T1@ABT1@H11@Z ; convert_y_range_from_yc48
  00375	83 c4 10	 add	 esp, 16			; 00000010H
  00378	0f 29 85 00 fe
	ff ff		 movaps	 XMMWORD PTR $T7[ebp], xmm0
  0037f	0f 28 85 00 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T7[ebp]
  00386	8b 55 f8	 mov	 edx, DWORD PTR _x$[ebp]
  00389	8b 45 bc	 mov	 eax, DWORD PTR _Y$[ebp]
  0038c	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  0038f	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  00395	0f 11 04 51	 movups	 XMMWORD PTR [ecx+edx*2], xmm0
  00399	c7 85 94 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv250[ebp], 0
  003a3	eb 5c		 jmp	 SHORT $LN12@convert_yc
$LN11@convert_yc:
  003a5	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR ?Array_Y_L_MA_16@@3QBFB
  003ac	0f 29 85 f0 fd
	ff ff		 movaps	 XMMWORD PTR $T6[ebp], xmm0
  003b3	8d 45 a0	 lea	 eax, DWORD PTR _xC_pw_one$[ebp]
  003b6	50		 push	 eax
  003b7	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR _xC_YCC$[ebp]
  003bd	51		 push	 ecx
  003be	6a 04		 push	 4
  003c0	8d 95 f0 fd ff
	ff		 lea	 edx, DWORD PTR $T6[ebp]
  003c6	52		 push	 edx
  003c7	0f 28 85 00 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$[ebp]
  003ce	e8 00 00 00 00	 call	 ?convert_y_range_from_yc48@@YA?AT__m128i@@T1@ABT1@H11@Z ; convert_y_range_from_yc48
  003d3	83 c4 10	 add	 esp, 16			; 00000010H
  003d6	0f 29 85 e0 fd
	ff ff		 movaps	 XMMWORD PTR $T5[ebp], xmm0
  003dd	0f 10 85 e0 fd
	ff ff		 movups	 xmm0, XMMWORD PTR $T5[ebp]
  003e4	8b 45 f8	 mov	 eax, DWORD PTR _x$[ebp]
  003e7	8b 4d bc	 mov	 ecx, DWORD PTR _Y$[ebp]
  003ea	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  003ed	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  003f3	0f 11 04 42	 movups	 XMMWORD PTR [edx+eax*2], xmm0
  003f7	c7 85 94 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv250[ebp], 0
$LN12@convert_yc:

; 1624 : 
; 1625 :             x0 = convert_uv_range_from_yc48_yuv420p(x0, x2, _mm_set1_epi16(UV_OFFSET_x2), xC_UV_L_MA_16_420P, UV_L_RSH_16_420P, xC_YCC, xC_pw_one);

  00401	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR ?Array_UV_L_MA_16_420P@@3QBFB
  00408	0f 29 85 c0 fd
	ff ff		 movaps	 XMMWORD PTR $T3[ebp], xmm0
  0040f	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@10001000100010001000100010001000
  00416	0f 29 85 d0 fd
	ff ff		 movaps	 XMMWORD PTR $T4[ebp], xmm0
  0041d	8d 4d a0	 lea	 ecx, DWORD PTR _xC_pw_one$[ebp]
  00420	51		 push	 ecx
  00421	8d 95 60 ff ff
	ff		 lea	 edx, DWORD PTR _xC_YCC$[ebp]
  00427	52		 push	 edx
  00428	6a 01		 push	 1
  0042a	8d 85 c0 fd ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  00430	50		 push	 eax
  00431	8d 8d d0 fd ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  00437	51		 push	 ecx
  00438	0f 28 8d e0 fe
	ff ff		 movaps	 xmm1, XMMWORD PTR _x2$[ebp]
  0043f	0f 28 85 20 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  00446	e8 00 00 00 00	 call	 ?convert_uv_range_from_yc48_yuv420p@@YA?AT__m128i@@T1@0ABT1@1H11@Z ; convert_uv_range_from_yc48_yuv420p
  0044b	83 c4 14	 add	 esp, 20			; 00000014H
  0044e	0f 29 85 b0 fd
	ff ff		 movaps	 XMMWORD PTR $T2[ebp], xmm0
  00455	0f 28 85 b0 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T2[ebp]
  0045c	0f 29 85 20 ff
	ff ff		 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1626 : 
; 1627 :             _mm_store_switch_si128((__m128i *)(C + x), x0);

  00463	33 d2		 xor	 edx, edx
  00465	74 1d		 je	 SHORT $LN13@convert_yc
  00467	0f 28 85 20 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  0046e	8b 45 f8	 mov	 eax, DWORD PTR _x$[ebp]
  00471	8b 4d b8	 mov	 ecx, DWORD PTR _C$[ebp]
  00474	0f 11 04 41	 movups	 XMMWORD PTR [ecx+eax*2], xmm0
  00478	c7 85 90 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv273[ebp], 0
  00482	eb 1b		 jmp	 SHORT $LN14@convert_yc
$LN13@convert_yc:
  00484	0f 10 85 20 ff
	ff ff		 movups	 xmm0, XMMWORD PTR _x0$[ebp]
  0048b	8b 55 f8	 mov	 edx, DWORD PTR _x$[ebp]
  0048e	8b 45 b8	 mov	 eax, DWORD PTR _C$[ebp]
  00491	0f 11 04 50	 movups	 XMMWORD PTR [eax+edx*2], xmm0
  00495	c7 85 90 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv273[ebp], 0
$LN14@convert_yc:

; 1628 :         }

  0049f	e9 c4 fc ff ff	 jmp	 $LN5@convert_yc
$LN6@convert_yc:

; 1629 :     }

  004a4	e9 53 fc ff ff	 jmp	 $LN2@convert_yc
$LN1@convert_yc:

; 1630 : }

  004a9	52		 push	 edx
  004aa	8b cd		 mov	 ecx, ebp
  004ac	50		 push	 eax
  004ad	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN21@convert_yc
  004b3	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  004b8	58		 pop	 eax
  004b9	5a		 pop	 edx
  004ba	5f		 pop	 edi
  004bb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004be	33 cd		 xor	 ecx, ebp
  004c0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004c5	8b e5		 mov	 esp, ebp
  004c7	5d		 pop	 ebp
  004c8	8b e3		 mov	 esp, ebx
  004ca	5b		 pop	 ebx
  004cb	c3		 ret	 0
$LN21@convert_yc:
  004cc	05 00 00 00	 DD	 5
  004d0	00 00 00 00	 DD	 $LN20@convert_yc
$LN20@convert_yc:
  004d4	e4 ff ff ff	 DD	 -28			; ffffffe4H
  004d8	0c 00 00 00	 DD	 12			; 0000000cH
  004dc	00 00 00 00	 DD	 $LN15@convert_yc
  004e0	a0 ff ff ff	 DD	 -96			; ffffffa0H
  004e4	10 00 00 00	 DD	 16			; 00000010H
  004e8	00 00 00 00	 DD	 $LN16@convert_yc
  004ec	60 ff ff ff	 DD	 -160			; ffffff60H
  004f0	10 00 00 00	 DD	 16			; 00000010H
  004f4	00 00 00 00	 DD	 $LN17@convert_yc
  004f8	00 ff ff ff	 DD	 -256			; ffffff00H
  004fc	10 00 00 00	 DD	 16			; 00000010H
  00500	00 00 00 00	 DD	 $LN18@convert_yc
  00504	e0 fe ff ff	 DD	 -288			; fffffee0H
  00508	10 00 00 00	 DD	 16			; 00000010H
  0050c	00 00 00 00	 DD	 $LN19@convert_yc
$LN19@convert_yc:
  00510	78		 DB	 120			; 00000078H
  00511	32		 DB	 50			; 00000032H
  00512	00		 DB	 0
$LN18@convert_yc:
  00513	78		 DB	 120			; 00000078H
  00514	31		 DB	 49			; 00000031H
  00515	00		 DB	 0
$LN17@convert_yc:
  00516	78		 DB	 120			; 00000078H
  00517	43		 DB	 67			; 00000043H
  00518	5f		 DB	 95			; 0000005fH
  00519	59		 DB	 89			; 00000059H
  0051a	43		 DB	 67			; 00000043H
  0051b	43		 DB	 67			; 00000043H
  0051c	00		 DB	 0
$LN16@convert_yc:
  0051d	78		 DB	 120			; 00000078H
  0051e	43		 DB	 67			; 00000043H
  0051f	5f		 DB	 95			; 0000005fH
  00520	70		 DB	 112			; 00000070H
  00521	77		 DB	 119			; 00000077H
  00522	5f		 DB	 95			; 0000005fH
  00523	6f		 DB	 111			; 0000006fH
  00524	6e		 DB	 110			; 0000006eH
  00525	65		 DB	 101			; 00000065H
  00526	00		 DB	 0
$LN15@convert_yc:
  00527	79		 DB	 121			; 00000079H
  00528	5f		 DB	 95			; 0000005fH
  00529	72		 DB	 114			; 00000072H
  0052a	61		 DB	 97			; 00000061H
  0052b	6e		 DB	 110			; 0000006eH
  0052c	67		 DB	 103			; 00000067H
  0052d	65		 DB	 101			; 00000065H
  0052e	00		 DB	 0
??$convert_yc48_to_p010_simd@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yc48_to_p010_simd<0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yc48_to_p010_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yc48_to_p010_avx

; 72   : void convert_yc48_to_p010_avx(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 73   :     convert_yc48_to_p010_simd<false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yc48_to_p010_simd@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yc48_to_p010_simd<0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 74   : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yc48_to_p010_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yc48_to_p010_avx
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_rgb24r_to_rgb32_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_rgb24r_to_rgb32_avx

; 68   : void convert_rgb24r_to_rgb32_avx(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 69   :     convert_rgb24r_to_rgb32_simd(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ?convert_rgb24r_to_rgb32_simd@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_rgb24r_to_rgb32_simd
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 70   : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_rgb24r_to_rgb32_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_rgb24r_to_rgb32_avx
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_rgb24_to_rgb32_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_rgb24_to_rgb32_avx

; 64   : void convert_rgb24_to_rgb32_avx(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 65   :     convert_rgb24_to_rgb32_simd(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ?convert_rgb24_to_rgb32_simd@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_rgb24_to_rgb32_simd
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 66   : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_rgb24_to_rgb32_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_rgb24_to_rgb32_avx
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -752						; size = 12
$T2 = -736						; size = 12
$T3 = -720						; size = 16
$T4 = -704						; size = 16
$T5 = -688						; size = 16
$T6 = -672						; size = 16
$T7 = -656						; size = 16
$T8 = -640						; size = 16
$T9 = -624						; size = 16
$T10 = -608						; size = 16
$T11 = -592						; size = 16
$T12 = -576						; size = 16
$T13 = -560						; size = 16
$T14 = -544						; size = 16
$T15 = -528						; size = 16
$T16 = -512						; size = 16
$T17 = -496						; size = 16
$T18 = -480						; size = 16
$T19 = -464						; size = 16
$T20 = -448						; size = 16
$T21 = -432						; size = 16
$T22 = -416						; size = 16
_x3$23 = -400						; size = 16
_x2$24 = -384						; size = 16
_x1$25 = -368						; size = 16
_x0$26 = -352						; size = 16
_dst_ptr_fin$27 = -324					; size = 4
_dst_ptr$28 = -320					; size = 4
_src_v_ptr$29 = -316					; size = 4
_src_u_ptr$30 = -312					; size = 4
_x_fin$31 = -308					; size = 4
_y$32 = -304						; size = 4
_dstLine$ = -300					; size = 4
_srcVLine$ = -296					; size = 4
_srcULine$ = -292					; size = 4
$T33 = -288						; size = 12
_uv_range$ = -272					; size = 12
$T34 = -256						; size = 16
$T35 = -240						; size = 16
$T36 = -224						; size = 16
$T37 = -208						; size = 16
$T38 = -192						; size = 16
$T39 = -176						; size = 16
$T40 = -160						; size = 16
$T41 = -144						; size = 16
$T42 = -128						; size = 16
_x1$43 = -112						; size = 16
_x0$44 = -96						; size = 16
_src_ptr_fin$45 = -80					; size = 4
_src_ptr$46 = -76					; size = 4
_dst_ptr$47 = -72					; size = 4
_y$48 = -68						; size = 4
_y_width$49 = -64					; size = 4
_dstLine$50 = -60					; size = 4
_srcYLine$51 = -56					; size = 4
$T52 = -52						; size = 12
_y_range$53 = -36					; size = 12
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yv12_to_p010_simd@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_to_p010_simd<0>

; 908  : static void convert_yv12_to_p010_simd(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec f0 02 00
	00		 sub	 esp, 752		; 000002f0H
  0001c	57		 push	 edi
  0001d	8d bd 10 fd ff
	ff		 lea	 edi, DWORD PTR [ebp-752]
  00023	b9 bc 00 00 00	 mov	 ecx, 188		; 000000bcH
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 909  :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 910  :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 911  :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 912  :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 913  :     //Y
; 914  :     if (!uv_only) {

  0007c	ba 01 00 00 00	 mov	 edx, 1
  00081	85 d2		 test	 edx, edx
  00083	0f 84 c6 01 00
	00		 je	 $LN14@convert_yv

; 915  :         const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00089	8b 43 2c	 mov	 eax, DWORD PTR _thread_n$[ebx]
  0008c	50		 push	 eax
  0008d	8b 4b 28	 mov	 ecx, DWORD PTR _thread_id$[ebx]
  00090	51		 push	 ecx
  00091	8b 53 20	 mov	 edx, DWORD PTR _height$[ebx]
  00094	2b 55 ec	 sub	 edx, DWORD PTR _crop_bottom$[ebp]
  00097	52		 push	 edx
  00098	8b 45 f4	 mov	 eax, DWORD PTR _crop_up$[ebp]
  0009b	50		 push	 eax
  0009c	8d 8d 20 fd ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  000a2	51		 push	 ecx
  000a3	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  000a8	83 c4 14	 add	 esp, 20			; 00000014H
  000ab	8b 10		 mov	 edx, DWORD PTR [eax]
  000ad	89 55 cc	 mov	 DWORD PTR $T52[ebp], edx
  000b0	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000b3	89 4d d0	 mov	 DWORD PTR $T52[ebp+4], ecx
  000b6	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000b9	89 55 d4	 mov	 DWORD PTR $T52[ebp+8], edx
  000bc	8b 45 cc	 mov	 eax, DWORD PTR $T52[ebp]
  000bf	89 45 dc	 mov	 DWORD PTR _y_range$53[ebp], eax
  000c2	8b 4d d0	 mov	 ecx, DWORD PTR $T52[ebp+4]
  000c5	89 4d e0	 mov	 DWORD PTR _y_range$53[ebp+4], ecx
  000c8	8b 55 d4	 mov	 edx, DWORD PTR $T52[ebp+8]
  000cb	89 55 e4	 mov	 DWORD PTR _y_range$53[ebp+8], edx

; 916  :         uint8_t *srcYLine = (uint8_t *)src[0] + src_y_pitch_byte * y_range.start_src + crop_left;

  000ce	b8 04 00 00 00	 mov	 eax, 4
  000d3	6b c8 00	 imul	 ecx, eax, 0
  000d6	8b 53 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  000d9	0f af 55 dc	 imul	 edx, DWORD PTR _y_range$53[ebp]
  000dd	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  000e0	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  000e3	03 ca		 add	 ecx, edx
  000e5	03 4d f8	 add	 ecx, DWORD PTR _crop_left$[ebp]
  000e8	89 4d c8	 mov	 DWORD PTR _srcYLine$51[ebp], ecx

; 917  :         uint8_t *dstLine  = (uint8_t *)dst[0] + dst_y_pitch_byte * y_range.start_dst;

  000eb	ba 04 00 00 00	 mov	 edx, 4
  000f0	6b c2 00	 imul	 eax, edx, 0
  000f3	8b 4b 1c	 mov	 ecx, DWORD PTR _dst_y_pitch_byte$[ebx]
  000f6	0f af 4d e0	 imul	 ecx, DWORD PTR _y_range$53[ebp+4]
  000fa	8b 53 08	 mov	 edx, DWORD PTR _dst$[ebx]
  000fd	03 0c 02	 add	 ecx, DWORD PTR [edx+eax]
  00100	89 4d c4	 mov	 DWORD PTR _dstLine$50[ebp], ecx

; 918  :         const int y_width = width - crop_right - crop_left;

  00103	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  00106	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  00109	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  0010c	89 45 c0	 mov	 DWORD PTR _y_width$49[ebp], eax

; 919  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch_byte, dstLine += dst_y_pitch_byte) {

  0010f	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _y$48[ebp], 0
  00116	eb 1b		 jmp	 SHORT $LN4@convert_yv
$LN2@convert_yv:
  00118	8b 4d bc	 mov	 ecx, DWORD PTR _y$48[ebp]
  0011b	83 c1 01	 add	 ecx, 1
  0011e	89 4d bc	 mov	 DWORD PTR _y$48[ebp], ecx
  00121	8b 55 c8	 mov	 edx, DWORD PTR _srcYLine$51[ebp]
  00124	03 53 14	 add	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  00127	89 55 c8	 mov	 DWORD PTR _srcYLine$51[ebp], edx
  0012a	8b 45 c4	 mov	 eax, DWORD PTR _dstLine$50[ebp]
  0012d	03 43 1c	 add	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  00130	89 45 c4	 mov	 DWORD PTR _dstLine$50[ebp], eax
$LN4@convert_yv:
  00133	8b 4d bc	 mov	 ecx, DWORD PTR _y$48[ebp]
  00136	3b 4d e4	 cmp	 ecx, DWORD PTR _y_range$53[ebp+8]
  00139	0f 8d 10 01 00
	00		 jge	 $LN14@convert_yv

; 920  :             uint16_t *dst_ptr = (uint16_t *)dstLine;

  0013f	8b 55 c4	 mov	 edx, DWORD PTR _dstLine$50[ebp]
  00142	89 55 b8	 mov	 DWORD PTR _dst_ptr$47[ebp], edx

; 921  :             uint8_t *src_ptr = srcYLine;

  00145	8b 45 c8	 mov	 eax, DWORD PTR _srcYLine$51[ebp]
  00148	89 45 b4	 mov	 DWORD PTR _src_ptr$46[ebp], eax

; 922  :             uint8_t *src_ptr_fin = src_ptr + y_width;

  0014b	8b 4d b4	 mov	 ecx, DWORD PTR _src_ptr$46[ebp]
  0014e	03 4d c0	 add	 ecx, DWORD PTR _y_width$49[ebp]
  00151	89 4d b0	 mov	 DWORD PTR _src_ptr_fin$45[ebp], ecx

; 923  :             __m128i x0, x1;
; 924  :             for (; src_ptr < src_ptr_fin; dst_ptr += 16, src_ptr += 16) {

  00154	eb 12		 jmp	 SHORT $LN7@convert_yv
$LN5@convert_yv:
  00156	8b 55 b8	 mov	 edx, DWORD PTR _dst_ptr$47[ebp]
  00159	83 c2 20	 add	 edx, 32			; 00000020H
  0015c	89 55 b8	 mov	 DWORD PTR _dst_ptr$47[ebp], edx
  0015f	8b 45 b4	 mov	 eax, DWORD PTR _src_ptr$46[ebp]
  00162	83 c0 10	 add	 eax, 16			; 00000010H
  00165	89 45 b4	 mov	 DWORD PTR _src_ptr$46[ebp], eax
$LN7@convert_yv:
  00168	8b 4d b4	 mov	 ecx, DWORD PTR _src_ptr$46[ebp]
  0016b	3b 4d b0	 cmp	 ecx, DWORD PTR _src_ptr_fin$45[ebp]
  0016e	0f 83 d6 00 00
	00		 jae	 $LN6@convert_yv

; 925  :                 x1 = _mm_loadu_si128((const __m128i *)src_ptr);

  00174	8b 55 b4	 mov	 edx, DWORD PTR _src_ptr$46[ebp]
  00177	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  0017a	0f 29 45 80	 movaps	 XMMWORD PTR $T42[ebp], xmm0
  0017e	0f 28 45 80	 movaps	 xmm0, XMMWORD PTR $T42[ebp]
  00182	0f 29 45 90	 movaps	 XMMWORD PTR _x1$43[ebp], xmm0

; 926  :                 x0 = _mm_unpacklo_epi8(_mm_setzero_si128(), x1);

  00186	0f 57 c0	 xorps	 xmm0, xmm0
  00189	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR $T41[ebp], xmm0
  00190	0f 28 85 70 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T41[ebp]
  00197	66 0f 60 45 90	 punpcklbw xmm0, XMMWORD PTR _x1$43[ebp]
  0019c	0f 29 85 60 ff
	ff ff		 movaps	 XMMWORD PTR $T40[ebp], xmm0
  001a3	0f 28 85 60 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T40[ebp]
  001aa	0f 29 45 a0	 movaps	 XMMWORD PTR _x0$44[ebp], xmm0

; 927  :                 x1 = _mm_unpackhi_epi8(_mm_setzero_si128(), x1);

  001ae	0f 57 c0	 xorps	 xmm0, xmm0
  001b1	0f 29 85 50 ff
	ff ff		 movaps	 XMMWORD PTR $T39[ebp], xmm0
  001b8	0f 28 85 50 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T39[ebp]
  001bf	66 0f 68 45 90	 punpckhbw xmm0, XMMWORD PTR _x1$43[ebp]
  001c4	0f 29 85 40 ff
	ff ff		 movaps	 XMMWORD PTR $T38[ebp], xmm0
  001cb	0f 28 85 40 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T38[ebp]
  001d2	0f 29 45 90	 movaps	 XMMWORD PTR _x1$43[ebp], xmm0

; 928  :                 x0 = _mm_add_epi16(x0, _mm_set1_epi16(2 << 6));

  001d6	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@00800080008000800080008000800080
  001dd	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR $T37[ebp], xmm0
  001e4	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _x0$44[ebp]
  001e8	66 0f fd 85 30
	ff ff ff	 paddw	 xmm0, XMMWORD PTR $T37[ebp]
  001f0	0f 29 85 20 ff
	ff ff		 movaps	 XMMWORD PTR $T36[ebp], xmm0
  001f7	0f 28 85 20 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T36[ebp]
  001fe	0f 29 45 a0	 movaps	 XMMWORD PTR _x0$44[ebp], xmm0

; 929  :                 x1 = _mm_add_epi16(x1, _mm_set1_epi16(2 << 6));

  00202	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@00800080008000800080008000800080
  00209	0f 29 85 10 ff
	ff ff		 movaps	 XMMWORD PTR $T35[ebp], xmm0
  00210	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR _x1$43[ebp]
  00214	66 0f fd 85 10
	ff ff ff	 paddw	 xmm0, XMMWORD PTR $T35[ebp]
  0021c	0f 29 85 00 ff
	ff ff		 movaps	 XMMWORD PTR $T34[ebp], xmm0
  00223	0f 28 85 00 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T34[ebp]
  0022a	0f 29 45 90	 movaps	 XMMWORD PTR _x1$43[ebp], xmm0

; 930  :                 _mm_storeu_si128((__m128i *)(dst_ptr + 0), x0);

  0022e	0f 10 45 a0	 movups	 xmm0, XMMWORD PTR _x0$44[ebp]
  00232	8b 45 b8	 mov	 eax, DWORD PTR _dst_ptr$47[ebp]
  00235	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 931  :                 _mm_storeu_si128((__m128i *)(dst_ptr + 8), x1);

  00238	0f 10 45 90	 movups	 xmm0, XMMWORD PTR _x1$43[ebp]
  0023c	8b 4d b8	 mov	 ecx, DWORD PTR _dst_ptr$47[ebp]
  0023f	83 c1 10	 add	 ecx, 16			; 00000010H
  00242	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 932  :             }

  00245	e9 0c ff ff ff	 jmp	 $LN5@convert_yv
$LN6@convert_yv:

; 933  :         }

  0024a	e9 c9 fe ff ff	 jmp	 $LN2@convert_yv
$LN14@convert_yv:

; 934  :     }
; 935  :     //UV
; 936  :     const auto uv_range = thread_y_range(crop_up >> 1, (height - crop_bottom) >> 1, thread_id, thread_n);

  0024f	8b 53 2c	 mov	 edx, DWORD PTR _thread_n$[ebx]
  00252	52		 push	 edx
  00253	8b 43 28	 mov	 eax, DWORD PTR _thread_id$[ebx]
  00256	50		 push	 eax
  00257	8b 4b 20	 mov	 ecx, DWORD PTR _height$[ebx]
  0025a	2b 4d ec	 sub	 ecx, DWORD PTR _crop_bottom$[ebp]
  0025d	d1 f9		 sar	 ecx, 1
  0025f	51		 push	 ecx
  00260	8b 55 f4	 mov	 edx, DWORD PTR _crop_up$[ebp]
  00263	d1 fa		 sar	 edx, 1
  00265	52		 push	 edx
  00266	8d 85 10 fd ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  0026c	50		 push	 eax
  0026d	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00272	83 c4 14	 add	 esp, 20			; 00000014H
  00275	8b 08		 mov	 ecx, DWORD PTR [eax]
  00277	89 8d e0 fe ff
	ff		 mov	 DWORD PTR $T33[ebp], ecx
  0027d	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00280	89 95 e4 fe ff
	ff		 mov	 DWORD PTR $T33[ebp+4], edx
  00286	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00289	89 85 e8 fe ff
	ff		 mov	 DWORD PTR $T33[ebp+8], eax
  0028f	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR $T33[ebp]
  00295	89 8d f0 fe ff
	ff		 mov	 DWORD PTR _uv_range$[ebp], ecx
  0029b	8b 95 e4 fe ff
	ff		 mov	 edx, DWORD PTR $T33[ebp+4]
  002a1	89 95 f4 fe ff
	ff		 mov	 DWORD PTR _uv_range$[ebp+4], edx
  002a7	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR $T33[ebp+8]
  002ad	89 85 f8 fe ff
	ff		 mov	 DWORD PTR _uv_range$[ebp+8], eax

; 937  :     uint8_t *srcULine = (uint8_t *)src[1] + ((src_uv_pitch_byte * uv_range.start_src) + (crop_left >> 1));

  002b3	b9 04 00 00 00	 mov	 ecx, 4
  002b8	c1 e1 00	 shl	 ecx, 0
  002bb	8b 53 18	 mov	 edx, DWORD PTR _src_uv_pitch_byte$[ebx]
  002be	0f af 95 f0 fe
	ff ff		 imul	 edx, DWORD PTR _uv_range$[ebp]
  002c5	8b 45 f8	 mov	 eax, DWORD PTR _crop_left$[ebp]
  002c8	d1 f8		 sar	 eax, 1
  002ca	03 d0		 add	 edx, eax
  002cc	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  002cf	03 14 08	 add	 edx, DWORD PTR [eax+ecx]
  002d2	89 95 dc fe ff
	ff		 mov	 DWORD PTR _srcULine$[ebp], edx

; 938  :     uint8_t *srcVLine = (uint8_t *)src[2] + ((src_uv_pitch_byte * uv_range.start_src) + (crop_left >> 1));

  002d8	b9 04 00 00 00	 mov	 ecx, 4
  002dd	d1 e1		 shl	 ecx, 1
  002df	8b 53 18	 mov	 edx, DWORD PTR _src_uv_pitch_byte$[ebx]
  002e2	0f af 95 f0 fe
	ff ff		 imul	 edx, DWORD PTR _uv_range$[ebp]
  002e9	8b 45 f8	 mov	 eax, DWORD PTR _crop_left$[ebp]
  002ec	d1 f8		 sar	 eax, 1
  002ee	03 d0		 add	 edx, eax
  002f0	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  002f3	03 14 08	 add	 edx, DWORD PTR [eax+ecx]
  002f6	89 95 d8 fe ff
	ff		 mov	 DWORD PTR _srcVLine$[ebp], edx

; 939  :     uint8_t *dstLine  = (uint8_t *)dst[1] + dst_y_pitch_byte * uv_range.start_dst;

  002fc	b9 04 00 00 00	 mov	 ecx, 4
  00301	c1 e1 00	 shl	 ecx, 0
  00304	8b 53 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebx]
  00307	0f af 95 f4 fe
	ff ff		 imul	 edx, DWORD PTR _uv_range$[ebp+4]
  0030e	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  00311	03 14 08	 add	 edx, DWORD PTR [eax+ecx]
  00314	89 95 d4 fe ff
	ff		 mov	 DWORD PTR _dstLine$[ebp], edx

; 940  :     for (int y = 0; y < uv_range.len; y++, srcULine += src_uv_pitch_byte, srcVLine += src_uv_pitch_byte, dstLine += dst_y_pitch_byte) {

  0031a	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _y$32[ebp], 0
  00324	eb 3c		 jmp	 SHORT $LN10@convert_yv
$LN8@convert_yv:
  00326	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR _y$32[ebp]
  0032c	83 c1 01	 add	 ecx, 1
  0032f	89 8d d0 fe ff
	ff		 mov	 DWORD PTR _y$32[ebp], ecx
  00335	8b 95 dc fe ff
	ff		 mov	 edx, DWORD PTR _srcULine$[ebp]
  0033b	03 53 18	 add	 edx, DWORD PTR _src_uv_pitch_byte$[ebx]
  0033e	89 95 dc fe ff
	ff		 mov	 DWORD PTR _srcULine$[ebp], edx
  00344	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _srcVLine$[ebp]
  0034a	03 43 18	 add	 eax, DWORD PTR _src_uv_pitch_byte$[ebx]
  0034d	89 85 d8 fe ff
	ff		 mov	 DWORD PTR _srcVLine$[ebp], eax
  00353	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR _dstLine$[ebp]
  00359	03 4b 1c	 add	 ecx, DWORD PTR _dst_y_pitch_byte$[ebx]
  0035c	89 8d d4 fe ff
	ff		 mov	 DWORD PTR _dstLine$[ebp], ecx
$LN10@convert_yv:
  00362	8b 95 d0 fe ff
	ff		 mov	 edx, DWORD PTR _y$32[ebp]
  00368	3b 95 f8 fe ff
	ff		 cmp	 edx, DWORD PTR _uv_range$[ebp+8]
  0036e	0f 8d dd 02 00
	00		 jge	 $LN1@convert_yv

; 941  :         const int x_fin = width - crop_right;

  00374	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  00377	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  0037a	89 85 cc fe ff
	ff		 mov	 DWORD PTR _x_fin$31[ebp], eax

; 942  :         uint8_t *src_u_ptr = srcULine;

  00380	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR _srcULine$[ebp]
  00386	89 8d c8 fe ff
	ff		 mov	 DWORD PTR _src_u_ptr$30[ebp], ecx

; 943  :         uint8_t *src_v_ptr = srcVLine;

  0038c	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR _srcVLine$[ebp]
  00392	89 95 c4 fe ff
	ff		 mov	 DWORD PTR _src_v_ptr$29[ebp], edx

; 944  :         uint16_t *dst_ptr = (uint16_t *)dstLine;

  00398	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR _dstLine$[ebp]
  0039e	89 85 c0 fe ff
	ff		 mov	 DWORD PTR _dst_ptr$28[ebp], eax

; 945  :         uint16_t *dst_ptr_fin = dst_ptr + x_fin;

  003a4	8b 8d cc fe ff
	ff		 mov	 ecx, DWORD PTR _x_fin$31[ebp]
  003aa	8b 95 c0 fe ff
	ff		 mov	 edx, DWORD PTR _dst_ptr$28[ebp]
  003b0	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  003b3	89 85 bc fe ff
	ff		 mov	 DWORD PTR _dst_ptr_fin$27[ebp], eax

; 946  :         __m128i x0, x1, x2, x3;
; 947  :         for (; dst_ptr < dst_ptr_fin; src_u_ptr += 16, src_v_ptr += 16, dst_ptr += 32) {

  003b9	eb 2d		 jmp	 SHORT $LN13@convert_yv
$LN11@convert_yv:
  003bb	8b 8d c8 fe ff
	ff		 mov	 ecx, DWORD PTR _src_u_ptr$30[ebp]
  003c1	83 c1 10	 add	 ecx, 16			; 00000010H
  003c4	89 8d c8 fe ff
	ff		 mov	 DWORD PTR _src_u_ptr$30[ebp], ecx
  003ca	8b 95 c4 fe ff
	ff		 mov	 edx, DWORD PTR _src_v_ptr$29[ebp]
  003d0	83 c2 10	 add	 edx, 16			; 00000010H
  003d3	89 95 c4 fe ff
	ff		 mov	 DWORD PTR _src_v_ptr$29[ebp], edx
  003d9	8b 85 c0 fe ff
	ff		 mov	 eax, DWORD PTR _dst_ptr$28[ebp]
  003df	83 c0 40	 add	 eax, 64			; 00000040H
  003e2	89 85 c0 fe ff
	ff		 mov	 DWORD PTR _dst_ptr$28[ebp], eax
$LN13@convert_yv:
  003e8	8b 8d c0 fe ff
	ff		 mov	 ecx, DWORD PTR _dst_ptr$28[ebp]
  003ee	3b 8d bc fe ff
	ff		 cmp	 ecx, DWORD PTR _dst_ptr_fin$27[ebp]
  003f4	0f 83 52 02 00
	00		 jae	 $LN12@convert_yv

; 948  :             x0 = _mm_loadu_si128((const __m128i *)src_u_ptr);

  003fa	8b 95 c8 fe ff
	ff		 mov	 edx, DWORD PTR _src_u_ptr$30[ebp]
  00400	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  00403	0f 29 85 60 fe
	ff ff		 movaps	 XMMWORD PTR $T22[ebp], xmm0
  0040a	0f 28 85 60 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T22[ebp]
  00411	0f 29 85 a0 fe
	ff ff		 movaps	 XMMWORD PTR _x0$26[ebp], xmm0

; 949  :             x2 = _mm_loadu_si128((const __m128i *)src_v_ptr);

  00418	8b 85 c4 fe ff
	ff		 mov	 eax, DWORD PTR _src_v_ptr$29[ebp]
  0041e	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00421	0f 29 85 50 fe
	ff ff		 movaps	 XMMWORD PTR $T21[ebp], xmm0
  00428	0f 28 85 50 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T21[ebp]
  0042f	0f 29 85 80 fe
	ff ff		 movaps	 XMMWORD PTR _x2$24[ebp], xmm0

; 950  :             x1 = _mm_unpacklo_epi8(x0, x2);

  00436	0f 28 85 a0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _x0$26[ebp]
  0043d	66 0f 60 85 80
	fe ff ff	 punpcklbw xmm0, XMMWORD PTR _x2$24[ebp]
  00445	0f 29 85 40 fe
	ff ff		 movaps	 XMMWORD PTR $T20[ebp], xmm0
  0044c	0f 28 85 40 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T20[ebp]
  00453	0f 29 85 90 fe
	ff ff		 movaps	 XMMWORD PTR _x1$25[ebp], xmm0

; 951  :             x3 = _mm_unpackhi_epi8(x0, x2);

  0045a	0f 28 85 a0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _x0$26[ebp]
  00461	66 0f 68 85 80
	fe ff ff	 punpckhbw xmm0, XMMWORD PTR _x2$24[ebp]
  00469	0f 29 85 30 fe
	ff ff		 movaps	 XMMWORD PTR $T19[ebp], xmm0
  00470	0f 28 85 30 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T19[ebp]
  00477	0f 29 85 70 fe
	ff ff		 movaps	 XMMWORD PTR _x3$23[ebp], xmm0

; 952  : 
; 953  :             x0 = _mm_unpacklo_epi8(_mm_setzero_si128(), x1);

  0047e	0f 57 c0	 xorps	 xmm0, xmm0
  00481	0f 29 85 20 fe
	ff ff		 movaps	 XMMWORD PTR $T18[ebp], xmm0
  00488	0f 28 85 20 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T18[ebp]
  0048f	66 0f 60 85 90
	fe ff ff	 punpcklbw xmm0, XMMWORD PTR _x1$25[ebp]
  00497	0f 29 85 10 fe
	ff ff		 movaps	 XMMWORD PTR $T17[ebp], xmm0
  0049e	0f 28 85 10 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T17[ebp]
  004a5	0f 29 85 a0 fe
	ff ff		 movaps	 XMMWORD PTR _x0$26[ebp], xmm0

; 954  :             x1 = _mm_unpackhi_epi8(_mm_setzero_si128(), x1);

  004ac	0f 57 c0	 xorps	 xmm0, xmm0
  004af	0f 29 85 00 fe
	ff ff		 movaps	 XMMWORD PTR $T16[ebp], xmm0
  004b6	0f 28 85 00 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T16[ebp]
  004bd	66 0f 68 85 90
	fe ff ff	 punpckhbw xmm0, XMMWORD PTR _x1$25[ebp]
  004c5	0f 29 85 f0 fd
	ff ff		 movaps	 XMMWORD PTR $T15[ebp], xmm0
  004cc	0f 28 85 f0 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T15[ebp]
  004d3	0f 29 85 90 fe
	ff ff		 movaps	 XMMWORD PTR _x1$25[ebp], xmm0

; 955  :             x0 = _mm_add_epi16(x0, _mm_set1_epi16(2 << 6));

  004da	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@00800080008000800080008000800080
  004e1	0f 29 85 e0 fd
	ff ff		 movaps	 XMMWORD PTR $T14[ebp], xmm0
  004e8	0f 28 85 a0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _x0$26[ebp]
  004ef	66 0f fd 85 e0
	fd ff ff	 paddw	 xmm0, XMMWORD PTR $T14[ebp]
  004f7	0f 29 85 d0 fd
	ff ff		 movaps	 XMMWORD PTR $T13[ebp], xmm0
  004fe	0f 28 85 d0 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T13[ebp]
  00505	0f 29 85 a0 fe
	ff ff		 movaps	 XMMWORD PTR _x0$26[ebp], xmm0

; 956  :             x1 = _mm_add_epi16(x1, _mm_set1_epi16(2 << 6));

  0050c	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@00800080008000800080008000800080
  00513	0f 29 85 c0 fd
	ff ff		 movaps	 XMMWORD PTR $T12[ebp], xmm0
  0051a	0f 28 85 90 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$25[ebp]
  00521	66 0f fd 85 c0
	fd ff ff	 paddw	 xmm0, XMMWORD PTR $T12[ebp]
  00529	0f 29 85 b0 fd
	ff ff		 movaps	 XMMWORD PTR $T11[ebp], xmm0
  00530	0f 28 85 b0 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T11[ebp]
  00537	0f 29 85 90 fe
	ff ff		 movaps	 XMMWORD PTR _x1$25[ebp], xmm0

; 957  : 
; 958  :             x2 = _mm_unpacklo_epi8(_mm_setzero_si128(), x3);

  0053e	0f 57 c0	 xorps	 xmm0, xmm0
  00541	0f 29 85 a0 fd
	ff ff		 movaps	 XMMWORD PTR $T10[ebp], xmm0
  00548	0f 28 85 a0 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T10[ebp]
  0054f	66 0f 60 85 70
	fe ff ff	 punpcklbw xmm0, XMMWORD PTR _x3$23[ebp]
  00557	0f 29 85 90 fd
	ff ff		 movaps	 XMMWORD PTR $T9[ebp], xmm0
  0055e	0f 28 85 90 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T9[ebp]
  00565	0f 29 85 80 fe
	ff ff		 movaps	 XMMWORD PTR _x2$24[ebp], xmm0

; 959  :             x3 = _mm_unpackhi_epi8(_mm_setzero_si128(), x3);

  0056c	0f 57 c0	 xorps	 xmm0, xmm0
  0056f	0f 29 85 80 fd
	ff ff		 movaps	 XMMWORD PTR $T8[ebp], xmm0
  00576	0f 28 85 80 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T8[ebp]
  0057d	66 0f 68 85 70
	fe ff ff	 punpckhbw xmm0, XMMWORD PTR _x3$23[ebp]
  00585	0f 29 85 70 fd
	ff ff		 movaps	 XMMWORD PTR $T7[ebp], xmm0
  0058c	0f 28 85 70 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T7[ebp]
  00593	0f 29 85 70 fe
	ff ff		 movaps	 XMMWORD PTR _x3$23[ebp], xmm0

; 960  :             x2 = _mm_add_epi16(x2, _mm_set1_epi16(2 << 6));

  0059a	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@00800080008000800080008000800080
  005a1	0f 29 85 60 fd
	ff ff		 movaps	 XMMWORD PTR $T6[ebp], xmm0
  005a8	0f 28 85 80 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _x2$24[ebp]
  005af	66 0f fd 85 60
	fd ff ff	 paddw	 xmm0, XMMWORD PTR $T6[ebp]
  005b7	0f 29 85 50 fd
	ff ff		 movaps	 XMMWORD PTR $T5[ebp], xmm0
  005be	0f 28 85 50 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T5[ebp]
  005c5	0f 29 85 80 fe
	ff ff		 movaps	 XMMWORD PTR _x2$24[ebp], xmm0

; 961  :             x3 = _mm_add_epi16(x3, _mm_set1_epi16(2 << 6));

  005cc	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@00800080008000800080008000800080
  005d3	0f 29 85 40 fd
	ff ff		 movaps	 XMMWORD PTR $T4[ebp], xmm0
  005da	0f 28 85 70 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _x3$23[ebp]
  005e1	66 0f fd 85 40
	fd ff ff	 paddw	 xmm0, XMMWORD PTR $T4[ebp]
  005e9	0f 29 85 30 fd
	ff ff		 movaps	 XMMWORD PTR $T3[ebp], xmm0
  005f0	0f 28 85 30 fd
	ff ff		 movaps	 xmm0, XMMWORD PTR $T3[ebp]
  005f7	0f 29 85 70 fe
	ff ff		 movaps	 XMMWORD PTR _x3$23[ebp], xmm0

; 962  : 
; 963  :             _mm_storeu_si128((__m128i *)(dst_ptr +  0), x0);

  005fe	0f 10 85 a0 fe
	ff ff		 movups	 xmm0, XMMWORD PTR _x0$26[ebp]
  00605	8b 8d c0 fe ff
	ff		 mov	 ecx, DWORD PTR _dst_ptr$28[ebp]
  0060b	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 964  :             _mm_storeu_si128((__m128i *)(dst_ptr +  8), x1);

  0060e	0f 10 85 90 fe
	ff ff		 movups	 xmm0, XMMWORD PTR _x1$25[ebp]
  00615	8b 95 c0 fe ff
	ff		 mov	 edx, DWORD PTR _dst_ptr$28[ebp]
  0061b	83 c2 10	 add	 edx, 16			; 00000010H
  0061e	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 965  :             _mm_storeu_si128((__m128i *)(dst_ptr + 16), x2);

  00621	0f 10 85 80 fe
	ff ff		 movups	 xmm0, XMMWORD PTR _x2$24[ebp]
  00628	8b 85 c0 fe ff
	ff		 mov	 eax, DWORD PTR _dst_ptr$28[ebp]
  0062e	83 c0 20	 add	 eax, 32			; 00000020H
  00631	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 966  :             _mm_storeu_si128((__m128i *)(dst_ptr + 24), x3);

  00634	0f 10 85 70 fe
	ff ff		 movups	 xmm0, XMMWORD PTR _x3$23[ebp]
  0063b	8b 8d c0 fe ff
	ff		 mov	 ecx, DWORD PTR _dst_ptr$28[ebp]
  00641	83 c1 30	 add	 ecx, 48			; 00000030H
  00644	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 967  :         }

  00647	e9 6f fd ff ff	 jmp	 $LN11@convert_yv
$LN12@convert_yv:

; 968  :     }

  0064c	e9 d5 fc ff ff	 jmp	 $LN8@convert_yv
$LN1@convert_yv:

; 969  : }

  00651	52		 push	 edx
  00652	8b cd		 mov	 ecx, ebp
  00654	50		 push	 eax
  00655	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN19@convert_yv
  0065b	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00660	58		 pop	 eax
  00661	5a		 pop	 edx
  00662	5f		 pop	 edi
  00663	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00666	33 cd		 xor	 ecx, ebp
  00668	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0066d	8b e5		 mov	 esp, ebp
  0066f	5d		 pop	 ebp
  00670	8b e3		 mov	 esp, ebx
  00672	5b		 pop	 ebx
  00673	c3		 ret	 0
$LN19@convert_yv:
  00674	02 00 00 00	 DD	 2
  00678	00 00 00 00	 DD	 $LN18@convert_yv
$LN18@convert_yv:
  0067c	dc ff ff ff	 DD	 -36			; ffffffdcH
  00680	0c 00 00 00	 DD	 12			; 0000000cH
  00684	00 00 00 00	 DD	 $LN16@convert_yv
  00688	f0 fe ff ff	 DD	 -272			; fffffef0H
  0068c	0c 00 00 00	 DD	 12			; 0000000cH
  00690	00 00 00 00	 DD	 $LN17@convert_yv
$LN17@convert_yv:
  00694	75		 DB	 117			; 00000075H
  00695	76		 DB	 118			; 00000076H
  00696	5f		 DB	 95			; 0000005fH
  00697	72		 DB	 114			; 00000072H
  00698	61		 DB	 97			; 00000061H
  00699	6e		 DB	 110			; 0000006eH
  0069a	67		 DB	 103			; 00000067H
  0069b	65		 DB	 101			; 00000065H
  0069c	00		 DB	 0
$LN16@convert_yv:
  0069d	79		 DB	 121			; 00000079H
  0069e	5f		 DB	 95			; 0000005fH
  0069f	72		 DB	 114			; 00000072H
  006a0	61		 DB	 97			; 00000061H
  006a1	6e		 DB	 110			; 0000006eH
  006a2	67		 DB	 103			; 00000067H
  006a3	65		 DB	 101			; 00000065H
  006a4	00		 DB	 0
??$convert_yv12_to_p010_simd@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_to_p010_simd<0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yv12_to_p010_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_to_p010_avx

; 60   : void convert_yv12_to_p010_avx(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 61   :     convert_yv12_to_p010_simd<false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yv12_to_p010_simd@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_to_p010_simd<0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 62   : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yv12_to_p010_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_to_p010_avx
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -304						; size = 12
$T2 = -288						; size = 12
$T3 = -272						; size = 16
$T4 = -256						; size = 16
$T5 = -240						; size = 16
$T6 = -224						; size = 16
_x$7 = -196						; size = 4
_x2$8 = -192						; size = 16
_x1$9 = -176						; size = 16
_x0$10 = -160						; size = 16
_dst_ptr$11 = -132					; size = 4
_src_v_ptr$12 = -128					; size = 4
_src_u_ptr$13 = -124					; size = 4
_x_fin$14 = -120					; size = 4
_y$15 = -116						; size = 4
_dstLine$ = -112					; size = 4
_srcVLine$ = -108					; size = 4
_srcULine$ = -104					; size = 4
$T16 = -100						; size = 12
_uv_range$ = -84					; size = 12
_y$17 = -68						; size = 4
_y_width$18 = -64					; size = 4
_dstLine$19 = -60					; size = 4
_srcYLine$20 = -56					; size = 4
$T21 = -52						; size = 12
_y_range$22 = -36					; size = 12
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yv12_to_nv12_simd@$00@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_to_nv12_simd<1>

; 284  : static void __forceinline convert_yv12_to_nv12_simd(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 30 01 00
	00		 sub	 esp, 304		; 00000130H
  0001c	57		 push	 edi
  0001d	8d bd d0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-304]
  00023	b9 4c 00 00 00	 mov	 ecx, 76			; 0000004cH
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 285  :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 286  :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 287  :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 288  :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 289  :     //Y
; 290  :     if (!uv_only) {

  0007c	33 d2		 xor	 edx, edx
  0007e	0f 84 c8 00 00
	00		 je	 $LN11@convert_yv

; 291  :         const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00084	8b 43 2c	 mov	 eax, DWORD PTR _thread_n$[ebx]
  00087	50		 push	 eax
  00088	8b 4b 28	 mov	 ecx, DWORD PTR _thread_id$[ebx]
  0008b	51		 push	 ecx
  0008c	8b 53 20	 mov	 edx, DWORD PTR _height$[ebx]
  0008f	2b 55 ec	 sub	 edx, DWORD PTR _crop_bottom$[ebp]
  00092	52		 push	 edx
  00093	8b 45 f4	 mov	 eax, DWORD PTR _crop_up$[ebp]
  00096	50		 push	 eax
  00097	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  0009d	51		 push	 ecx
  0009e	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  000a3	83 c4 14	 add	 esp, 20			; 00000014H
  000a6	8b 10		 mov	 edx, DWORD PTR [eax]
  000a8	89 55 cc	 mov	 DWORD PTR $T21[ebp], edx
  000ab	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ae	89 4d d0	 mov	 DWORD PTR $T21[ebp+4], ecx
  000b1	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000b4	89 55 d4	 mov	 DWORD PTR $T21[ebp+8], edx
  000b7	8b 45 cc	 mov	 eax, DWORD PTR $T21[ebp]
  000ba	89 45 dc	 mov	 DWORD PTR _y_range$22[ebp], eax
  000bd	8b 4d d0	 mov	 ecx, DWORD PTR $T21[ebp+4]
  000c0	89 4d e0	 mov	 DWORD PTR _y_range$22[ebp+4], ecx
  000c3	8b 55 d4	 mov	 edx, DWORD PTR $T21[ebp+8]
  000c6	89 55 e4	 mov	 DWORD PTR _y_range$22[ebp+8], edx

; 292  :         uint8_t *srcYLine = (uint8_t *)src[0] + src_y_pitch_byte * y_range.start_src + crop_left;

  000c9	b8 04 00 00 00	 mov	 eax, 4
  000ce	6b c8 00	 imul	 ecx, eax, 0
  000d1	8b 53 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  000d4	0f af 55 dc	 imul	 edx, DWORD PTR _y_range$22[ebp]
  000d8	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  000db	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  000de	03 ca		 add	 ecx, edx
  000e0	03 4d f8	 add	 ecx, DWORD PTR _crop_left$[ebp]
  000e3	89 4d c8	 mov	 DWORD PTR _srcYLine$20[ebp], ecx

; 293  :         uint8_t *dstLine = (uint8_t *)dst[0] + dst_y_pitch_byte * y_range.start_dst;

  000e6	ba 04 00 00 00	 mov	 edx, 4
  000eb	6b c2 00	 imul	 eax, edx, 0
  000ee	8b 4b 1c	 mov	 ecx, DWORD PTR _dst_y_pitch_byte$[ebx]
  000f1	0f af 4d e0	 imul	 ecx, DWORD PTR _y_range$22[ebp+4]
  000f5	8b 53 08	 mov	 edx, DWORD PTR _dst$[ebx]
  000f8	03 0c 02	 add	 ecx, DWORD PTR [edx+eax]
  000fb	89 4d c4	 mov	 DWORD PTR _dstLine$19[ebp], ecx

; 294  :         const int y_width = width - crop_right - crop_left;

  000fe	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  00101	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  00104	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  00107	89 45 c0	 mov	 DWORD PTR _y_width$18[ebp], eax

; 295  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch_byte, dstLine += dst_y_pitch_byte) {

  0010a	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _y$17[ebp], 0
  00111	eb 1b		 jmp	 SHORT $LN4@convert_yv
$LN2@convert_yv:
  00113	8b 4d bc	 mov	 ecx, DWORD PTR _y$17[ebp]
  00116	83 c1 01	 add	 ecx, 1
  00119	89 4d bc	 mov	 DWORD PTR _y$17[ebp], ecx
  0011c	8b 55 c8	 mov	 edx, DWORD PTR _srcYLine$20[ebp]
  0011f	03 53 14	 add	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  00122	89 55 c8	 mov	 DWORD PTR _srcYLine$20[ebp], edx
  00125	8b 45 c4	 mov	 eax, DWORD PTR _dstLine$19[ebp]
  00128	03 43 1c	 add	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  0012b	89 45 c4	 mov	 DWORD PTR _dstLine$19[ebp], eax
$LN4@convert_yv:
  0012e	8b 4d bc	 mov	 ecx, DWORD PTR _y$17[ebp]
  00131	3b 4d e4	 cmp	 ecx, DWORD PTR _y_range$22[ebp+8]
  00134	7d 16		 jge	 SHORT $LN11@convert_yv

; 296  :             memcpy_sse(dstLine, srcYLine, y_width);

  00136	8b 55 c0	 mov	 edx, DWORD PTR _y_width$18[ebp]
  00139	52		 push	 edx
  0013a	8b 45 c8	 mov	 eax, DWORD PTR _srcYLine$20[ebp]
  0013d	50		 push	 eax
  0013e	8b 4d c4	 mov	 ecx, DWORD PTR _dstLine$19[ebp]
  00141	51		 push	 ecx
  00142	e8 00 00 00 00	 call	 ?memcpy_sse@@YAXPAEPBEH@Z ; memcpy_sse
  00147	83 c4 0c	 add	 esp, 12			; 0000000cH

; 297  :         }

  0014a	eb c7		 jmp	 SHORT $LN2@convert_yv
$LN11@convert_yv:

; 298  :     }
; 299  :     //UV
; 300  :     const auto uv_range = thread_y_range(crop_up >> 1, (height - crop_bottom) >> 1, thread_id, thread_n);

  0014c	8b 53 2c	 mov	 edx, DWORD PTR _thread_n$[ebx]
  0014f	52		 push	 edx
  00150	8b 43 28	 mov	 eax, DWORD PTR _thread_id$[ebx]
  00153	50		 push	 eax
  00154	8b 4b 20	 mov	 ecx, DWORD PTR _height$[ebx]
  00157	2b 4d ec	 sub	 ecx, DWORD PTR _crop_bottom$[ebp]
  0015a	d1 f9		 sar	 ecx, 1
  0015c	51		 push	 ecx
  0015d	8b 55 f4	 mov	 edx, DWORD PTR _crop_up$[ebp]
  00160	d1 fa		 sar	 edx, 1
  00162	52		 push	 edx
  00163	8d 85 d0 fe ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  00169	50		 push	 eax
  0016a	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  0016f	83 c4 14	 add	 esp, 20			; 00000014H
  00172	8b 08		 mov	 ecx, DWORD PTR [eax]
  00174	89 4d 9c	 mov	 DWORD PTR $T16[ebp], ecx
  00177	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0017a	89 55 a0	 mov	 DWORD PTR $T16[ebp+4], edx
  0017d	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00180	89 45 a4	 mov	 DWORD PTR $T16[ebp+8], eax
  00183	8b 4d 9c	 mov	 ecx, DWORD PTR $T16[ebp]
  00186	89 4d ac	 mov	 DWORD PTR _uv_range$[ebp], ecx
  00189	8b 55 a0	 mov	 edx, DWORD PTR $T16[ebp+4]
  0018c	89 55 b0	 mov	 DWORD PTR _uv_range$[ebp+4], edx
  0018f	8b 45 a4	 mov	 eax, DWORD PTR $T16[ebp+8]
  00192	89 45 b4	 mov	 DWORD PTR _uv_range$[ebp+8], eax

; 301  :     uint8_t *srcULine = (uint8_t *)src[1] + ((src_uv_pitch_byte * uv_range.start_src) + (crop_left >> 1));

  00195	b9 04 00 00 00	 mov	 ecx, 4
  0019a	c1 e1 00	 shl	 ecx, 0
  0019d	8b 53 18	 mov	 edx, DWORD PTR _src_uv_pitch_byte$[ebx]
  001a0	0f af 55 ac	 imul	 edx, DWORD PTR _uv_range$[ebp]
  001a4	8b 45 f8	 mov	 eax, DWORD PTR _crop_left$[ebp]
  001a7	d1 f8		 sar	 eax, 1
  001a9	03 d0		 add	 edx, eax
  001ab	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  001ae	03 14 08	 add	 edx, DWORD PTR [eax+ecx]
  001b1	89 55 98	 mov	 DWORD PTR _srcULine$[ebp], edx

; 302  :     uint8_t *srcVLine = (uint8_t *)src[2] + ((src_uv_pitch_byte * uv_range.start_src) + (crop_left >> 1));

  001b4	b9 04 00 00 00	 mov	 ecx, 4
  001b9	d1 e1		 shl	 ecx, 1
  001bb	8b 53 18	 mov	 edx, DWORD PTR _src_uv_pitch_byte$[ebx]
  001be	0f af 55 ac	 imul	 edx, DWORD PTR _uv_range$[ebp]
  001c2	8b 45 f8	 mov	 eax, DWORD PTR _crop_left$[ebp]
  001c5	d1 f8		 sar	 eax, 1
  001c7	03 d0		 add	 edx, eax
  001c9	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  001cc	03 14 08	 add	 edx, DWORD PTR [eax+ecx]
  001cf	89 55 94	 mov	 DWORD PTR _srcVLine$[ebp], edx

; 303  :     uint8_t *dstLine = (uint8_t *)dst[1] + dst_y_pitch_byte * uv_range.start_dst;

  001d2	b9 04 00 00 00	 mov	 ecx, 4
  001d7	c1 e1 00	 shl	 ecx, 0
  001da	8b 53 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebx]
  001dd	0f af 55 b0	 imul	 edx, DWORD PTR _uv_range$[ebp+4]
  001e1	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  001e4	03 14 08	 add	 edx, DWORD PTR [eax+ecx]
  001e7	89 55 90	 mov	 DWORD PTR _dstLine$[ebp], edx

; 304  :     for (int y = 0; y < uv_range.len; y++, srcULine += src_uv_pitch_byte, srcVLine += src_uv_pitch_byte, dstLine += dst_y_pitch_byte) {

  001ea	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR _y$15[ebp], 0
  001f1	eb 24		 jmp	 SHORT $LN7@convert_yv
$LN5@convert_yv:
  001f3	8b 4d 8c	 mov	 ecx, DWORD PTR _y$15[ebp]
  001f6	83 c1 01	 add	 ecx, 1
  001f9	89 4d 8c	 mov	 DWORD PTR _y$15[ebp], ecx
  001fc	8b 55 98	 mov	 edx, DWORD PTR _srcULine$[ebp]
  001ff	03 53 18	 add	 edx, DWORD PTR _src_uv_pitch_byte$[ebx]
  00202	89 55 98	 mov	 DWORD PTR _srcULine$[ebp], edx
  00205	8b 45 94	 mov	 eax, DWORD PTR _srcVLine$[ebp]
  00208	03 43 18	 add	 eax, DWORD PTR _src_uv_pitch_byte$[ebx]
  0020b	89 45 94	 mov	 DWORD PTR _srcVLine$[ebp], eax
  0020e	8b 4d 90	 mov	 ecx, DWORD PTR _dstLine$[ebp]
  00211	03 4b 1c	 add	 ecx, DWORD PTR _dst_y_pitch_byte$[ebx]
  00214	89 4d 90	 mov	 DWORD PTR _dstLine$[ebp], ecx
$LN7@convert_yv:
  00217	8b 55 8c	 mov	 edx, DWORD PTR _y$15[ebp]
  0021a	3b 55 b4	 cmp	 edx, DWORD PTR _uv_range$[ebp+8]
  0021d	0f 8d 13 01 00
	00		 jge	 $LN1@convert_yv

; 305  :         const int x_fin = width - crop_right;

  00223	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  00226	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  00229	89 45 88	 mov	 DWORD PTR _x_fin$14[ebp], eax

; 306  :         uint8_t *src_u_ptr = srcULine;

  0022c	8b 4d 98	 mov	 ecx, DWORD PTR _srcULine$[ebp]
  0022f	89 4d 84	 mov	 DWORD PTR _src_u_ptr$13[ebp], ecx

; 307  :         uint8_t *src_v_ptr = srcVLine;

  00232	8b 55 94	 mov	 edx, DWORD PTR _srcVLine$[ebp]
  00235	89 55 80	 mov	 DWORD PTR _src_v_ptr$12[ebp], edx

; 308  :         uint8_t *dst_ptr = dstLine;

  00238	8b 45 90	 mov	 eax, DWORD PTR _dstLine$[ebp]
  0023b	89 85 7c ff ff
	ff		 mov	 DWORD PTR _dst_ptr$11[ebp], eax

; 309  :         __m128i x0, x1, x2;
; 310  :         for (int x = crop_left; x < x_fin; x += 32, src_u_ptr += 16, src_v_ptr += 16, dst_ptr += 32) {

  00241	8b 4d f8	 mov	 ecx, DWORD PTR _crop_left$[ebp]
  00244	89 8d 3c ff ff
	ff		 mov	 DWORD PTR _x$7[ebp], ecx
  0024a	eb 30		 jmp	 SHORT $LN10@convert_yv
$LN8@convert_yv:
  0024c	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR _x$7[ebp]
  00252	83 c2 20	 add	 edx, 32			; 00000020H
  00255	89 95 3c ff ff
	ff		 mov	 DWORD PTR _x$7[ebp], edx
  0025b	8b 45 84	 mov	 eax, DWORD PTR _src_u_ptr$13[ebp]
  0025e	83 c0 10	 add	 eax, 16			; 00000010H
  00261	89 45 84	 mov	 DWORD PTR _src_u_ptr$13[ebp], eax
  00264	8b 4d 80	 mov	 ecx, DWORD PTR _src_v_ptr$12[ebp]
  00267	83 c1 10	 add	 ecx, 16			; 00000010H
  0026a	89 4d 80	 mov	 DWORD PTR _src_v_ptr$12[ebp], ecx
  0026d	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR _dst_ptr$11[ebp]
  00273	83 c2 20	 add	 edx, 32			; 00000020H
  00276	89 95 7c ff ff
	ff		 mov	 DWORD PTR _dst_ptr$11[ebp], edx
$LN10@convert_yv:
  0027c	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _x$7[ebp]
  00282	3b 45 88	 cmp	 eax, DWORD PTR _x_fin$14[ebp]
  00285	0f 8d a6 00 00
	00		 jge	 $LN9@convert_yv

; 311  :             x0 = _mm_loadu_si128((const __m128i *)src_u_ptr);

  0028b	8b 4d 84	 mov	 ecx, DWORD PTR _src_u_ptr$13[ebp]
  0028e	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00291	0f 29 85 20 ff
	ff ff		 movaps	 XMMWORD PTR $T6[ebp], xmm0
  00298	0f 28 85 20 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T6[ebp]
  0029f	0f 29 85 60 ff
	ff ff		 movaps	 XMMWORD PTR _x0$10[ebp], xmm0

; 312  :             x1 = _mm_loadu_si128((const __m128i *)src_v_ptr);

  002a6	8b 55 80	 mov	 edx, DWORD PTR _src_v_ptr$12[ebp]
  002a9	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  002ac	0f 29 85 10 ff
	ff ff		 movaps	 XMMWORD PTR $T5[ebp], xmm0
  002b3	0f 28 85 10 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T5[ebp]
  002ba	0f 29 85 50 ff
	ff ff		 movaps	 XMMWORD PTR _x1$9[ebp], xmm0

; 313  : 
; 314  :             x2 = _mm_unpackhi_epi8(x0, x1);

  002c1	0f 28 85 60 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x0$10[ebp]
  002c8	66 0f 68 85 50
	ff ff ff	 punpckhbw xmm0, XMMWORD PTR _x1$9[ebp]
  002d0	0f 29 85 00 ff
	ff ff		 movaps	 XMMWORD PTR $T4[ebp], xmm0
  002d7	0f 28 85 00 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T4[ebp]
  002de	0f 29 85 40 ff
	ff ff		 movaps	 XMMWORD PTR _x2$8[ebp], xmm0

; 315  :             x0 = _mm_unpacklo_epi8(x0, x1);

  002e5	0f 28 85 60 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x0$10[ebp]
  002ec	66 0f 60 85 50
	ff ff ff	 punpcklbw xmm0, XMMWORD PTR _x1$9[ebp]
  002f4	0f 29 85 f0 fe
	ff ff		 movaps	 XMMWORD PTR $T3[ebp], xmm0
  002fb	0f 28 85 f0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T3[ebp]
  00302	0f 29 85 60 ff
	ff ff		 movaps	 XMMWORD PTR _x0$10[ebp], xmm0

; 316  : 
; 317  :             _mm_storeu_si128((__m128i *)(dst_ptr +  0), x0);

  00309	0f 10 85 60 ff
	ff ff		 movups	 xmm0, XMMWORD PTR _x0$10[ebp]
  00310	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _dst_ptr$11[ebp]
  00316	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 318  :             _mm_storeu_si128((__m128i *)(dst_ptr + 16), x2);

  00319	0f 10 85 40 ff
	ff ff		 movups	 xmm0, XMMWORD PTR _x2$8[ebp]
  00320	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _dst_ptr$11[ebp]
  00326	83 c1 10	 add	 ecx, 16			; 00000010H
  00329	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 319  :         }

  0032c	e9 1b ff ff ff	 jmp	 $LN8@convert_yv
$LN9@convert_yv:

; 320  :     }

  00331	e9 bd fe ff ff	 jmp	 $LN5@convert_yv
$LN1@convert_yv:

; 321  : }

  00336	52		 push	 edx
  00337	8b cd		 mov	 ecx, ebp
  00339	50		 push	 eax
  0033a	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN16@convert_yv
  00340	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00345	58		 pop	 eax
  00346	5a		 pop	 edx
  00347	5f		 pop	 edi
  00348	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0034b	33 cd		 xor	 ecx, ebp
  0034d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00352	8b e5		 mov	 esp, ebp
  00354	5d		 pop	 ebp
  00355	8b e3		 mov	 esp, ebx
  00357	5b		 pop	 ebx
  00358	c3		 ret	 0
  00359	0f 1f 00	 npad	 3
$LN16@convert_yv:
  0035c	02 00 00 00	 DD	 2
  00360	00 00 00 00	 DD	 $LN15@convert_yv
$LN15@convert_yv:
  00364	dc ff ff ff	 DD	 -36			; ffffffdcH
  00368	0c 00 00 00	 DD	 12			; 0000000cH
  0036c	00 00 00 00	 DD	 $LN13@convert_yv
  00370	ac ff ff ff	 DD	 -84			; ffffffacH
  00374	0c 00 00 00	 DD	 12			; 0000000cH
  00378	00 00 00 00	 DD	 $LN14@convert_yv
$LN14@convert_yv:
  0037c	75		 DB	 117			; 00000075H
  0037d	76		 DB	 118			; 00000076H
  0037e	5f		 DB	 95			; 0000005fH
  0037f	72		 DB	 114			; 00000072H
  00380	61		 DB	 97			; 00000061H
  00381	6e		 DB	 110			; 0000006eH
  00382	67		 DB	 103			; 00000067H
  00383	65		 DB	 101			; 00000065H
  00384	00		 DB	 0
$LN13@convert_yv:
  00385	79		 DB	 121			; 00000079H
  00386	5f		 DB	 95			; 0000005fH
  00387	72		 DB	 114			; 00000072H
  00388	61		 DB	 97			; 00000061H
  00389	6e		 DB	 110			; 0000006eH
  0038a	67		 DB	 103			; 00000067H
  0038b	65		 DB	 101			; 00000065H
  0038c	00		 DB	 0
??$convert_yv12_to_nv12_simd@$00@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_to_nv12_simd<1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_uv_yv12_to_nv12_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_uv_yv12_to_nv12_avx

; 56   : void convert_uv_yv12_to_nv12_avx(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 57   :     convert_yv12_to_nv12_simd<true>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yv12_to_nv12_simd@$00@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_to_nv12_simd<1>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 58   : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_uv_yv12_to_nv12_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_uv_yv12_to_nv12_avx
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -304						; size = 12
$T2 = -288						; size = 12
$T3 = -272						; size = 16
$T4 = -256						; size = 16
$T5 = -240						; size = 16
$T6 = -224						; size = 16
_x$7 = -196						; size = 4
_x2$8 = -192						; size = 16
_x1$9 = -176						; size = 16
_x0$10 = -160						; size = 16
_dst_ptr$11 = -132					; size = 4
_src_v_ptr$12 = -128					; size = 4
_src_u_ptr$13 = -124					; size = 4
_x_fin$14 = -120					; size = 4
_y$15 = -116						; size = 4
_dstLine$ = -112					; size = 4
_srcVLine$ = -108					; size = 4
_srcULine$ = -104					; size = 4
$T16 = -100						; size = 12
_uv_range$ = -84					; size = 12
_y$17 = -68						; size = 4
_y_width$18 = -64					; size = 4
_dstLine$19 = -60					; size = 4
_srcYLine$20 = -56					; size = 4
$T21 = -52						; size = 12
_y_range$22 = -36					; size = 12
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yv12_to_nv12_simd@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_to_nv12_simd<0>

; 284  : static void __forceinline convert_yv12_to_nv12_simd(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 30 01 00
	00		 sub	 esp, 304		; 00000130H
  0001c	57		 push	 edi
  0001d	8d bd d0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-304]
  00023	b9 4c 00 00 00	 mov	 ecx, 76			; 0000004cH
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 285  :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 286  :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 287  :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 288  :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 289  :     //Y
; 290  :     if (!uv_only) {

  0007c	ba 01 00 00 00	 mov	 edx, 1
  00081	85 d2		 test	 edx, edx
  00083	0f 84 c8 00 00
	00		 je	 $LN11@convert_yv

; 291  :         const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00089	8b 43 2c	 mov	 eax, DWORD PTR _thread_n$[ebx]
  0008c	50		 push	 eax
  0008d	8b 4b 28	 mov	 ecx, DWORD PTR _thread_id$[ebx]
  00090	51		 push	 ecx
  00091	8b 53 20	 mov	 edx, DWORD PTR _height$[ebx]
  00094	2b 55 ec	 sub	 edx, DWORD PTR _crop_bottom$[ebp]
  00097	52		 push	 edx
  00098	8b 45 f4	 mov	 eax, DWORD PTR _crop_up$[ebp]
  0009b	50		 push	 eax
  0009c	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  000a2	51		 push	 ecx
  000a3	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  000a8	83 c4 14	 add	 esp, 20			; 00000014H
  000ab	8b 10		 mov	 edx, DWORD PTR [eax]
  000ad	89 55 cc	 mov	 DWORD PTR $T21[ebp], edx
  000b0	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000b3	89 4d d0	 mov	 DWORD PTR $T21[ebp+4], ecx
  000b6	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000b9	89 55 d4	 mov	 DWORD PTR $T21[ebp+8], edx
  000bc	8b 45 cc	 mov	 eax, DWORD PTR $T21[ebp]
  000bf	89 45 dc	 mov	 DWORD PTR _y_range$22[ebp], eax
  000c2	8b 4d d0	 mov	 ecx, DWORD PTR $T21[ebp+4]
  000c5	89 4d e0	 mov	 DWORD PTR _y_range$22[ebp+4], ecx
  000c8	8b 55 d4	 mov	 edx, DWORD PTR $T21[ebp+8]
  000cb	89 55 e4	 mov	 DWORD PTR _y_range$22[ebp+8], edx

; 292  :         uint8_t *srcYLine = (uint8_t *)src[0] + src_y_pitch_byte * y_range.start_src + crop_left;

  000ce	b8 04 00 00 00	 mov	 eax, 4
  000d3	6b c8 00	 imul	 ecx, eax, 0
  000d6	8b 53 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  000d9	0f af 55 dc	 imul	 edx, DWORD PTR _y_range$22[ebp]
  000dd	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  000e0	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  000e3	03 ca		 add	 ecx, edx
  000e5	03 4d f8	 add	 ecx, DWORD PTR _crop_left$[ebp]
  000e8	89 4d c8	 mov	 DWORD PTR _srcYLine$20[ebp], ecx

; 293  :         uint8_t *dstLine = (uint8_t *)dst[0] + dst_y_pitch_byte * y_range.start_dst;

  000eb	ba 04 00 00 00	 mov	 edx, 4
  000f0	6b c2 00	 imul	 eax, edx, 0
  000f3	8b 4b 1c	 mov	 ecx, DWORD PTR _dst_y_pitch_byte$[ebx]
  000f6	0f af 4d e0	 imul	 ecx, DWORD PTR _y_range$22[ebp+4]
  000fa	8b 53 08	 mov	 edx, DWORD PTR _dst$[ebx]
  000fd	03 0c 02	 add	 ecx, DWORD PTR [edx+eax]
  00100	89 4d c4	 mov	 DWORD PTR _dstLine$19[ebp], ecx

; 294  :         const int y_width = width - crop_right - crop_left;

  00103	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  00106	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  00109	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  0010c	89 45 c0	 mov	 DWORD PTR _y_width$18[ebp], eax

; 295  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch_byte, dstLine += dst_y_pitch_byte) {

  0010f	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _y$17[ebp], 0
  00116	eb 1b		 jmp	 SHORT $LN4@convert_yv
$LN2@convert_yv:
  00118	8b 4d bc	 mov	 ecx, DWORD PTR _y$17[ebp]
  0011b	83 c1 01	 add	 ecx, 1
  0011e	89 4d bc	 mov	 DWORD PTR _y$17[ebp], ecx
  00121	8b 55 c8	 mov	 edx, DWORD PTR _srcYLine$20[ebp]
  00124	03 53 14	 add	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  00127	89 55 c8	 mov	 DWORD PTR _srcYLine$20[ebp], edx
  0012a	8b 45 c4	 mov	 eax, DWORD PTR _dstLine$19[ebp]
  0012d	03 43 1c	 add	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  00130	89 45 c4	 mov	 DWORD PTR _dstLine$19[ebp], eax
$LN4@convert_yv:
  00133	8b 4d bc	 mov	 ecx, DWORD PTR _y$17[ebp]
  00136	3b 4d e4	 cmp	 ecx, DWORD PTR _y_range$22[ebp+8]
  00139	7d 16		 jge	 SHORT $LN11@convert_yv

; 296  :             memcpy_sse(dstLine, srcYLine, y_width);

  0013b	8b 55 c0	 mov	 edx, DWORD PTR _y_width$18[ebp]
  0013e	52		 push	 edx
  0013f	8b 45 c8	 mov	 eax, DWORD PTR _srcYLine$20[ebp]
  00142	50		 push	 eax
  00143	8b 4d c4	 mov	 ecx, DWORD PTR _dstLine$19[ebp]
  00146	51		 push	 ecx
  00147	e8 00 00 00 00	 call	 ?memcpy_sse@@YAXPAEPBEH@Z ; memcpy_sse
  0014c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 297  :         }

  0014f	eb c7		 jmp	 SHORT $LN2@convert_yv
$LN11@convert_yv:

; 298  :     }
; 299  :     //UV
; 300  :     const auto uv_range = thread_y_range(crop_up >> 1, (height - crop_bottom) >> 1, thread_id, thread_n);

  00151	8b 53 2c	 mov	 edx, DWORD PTR _thread_n$[ebx]
  00154	52		 push	 edx
  00155	8b 43 28	 mov	 eax, DWORD PTR _thread_id$[ebx]
  00158	50		 push	 eax
  00159	8b 4b 20	 mov	 ecx, DWORD PTR _height$[ebx]
  0015c	2b 4d ec	 sub	 ecx, DWORD PTR _crop_bottom$[ebp]
  0015f	d1 f9		 sar	 ecx, 1
  00161	51		 push	 ecx
  00162	8b 55 f4	 mov	 edx, DWORD PTR _crop_up$[ebp]
  00165	d1 fa		 sar	 edx, 1
  00167	52		 push	 edx
  00168	8d 85 d0 fe ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  0016e	50		 push	 eax
  0016f	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00174	83 c4 14	 add	 esp, 20			; 00000014H
  00177	8b 08		 mov	 ecx, DWORD PTR [eax]
  00179	89 4d 9c	 mov	 DWORD PTR $T16[ebp], ecx
  0017c	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0017f	89 55 a0	 mov	 DWORD PTR $T16[ebp+4], edx
  00182	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00185	89 45 a4	 mov	 DWORD PTR $T16[ebp+8], eax
  00188	8b 4d 9c	 mov	 ecx, DWORD PTR $T16[ebp]
  0018b	89 4d ac	 mov	 DWORD PTR _uv_range$[ebp], ecx
  0018e	8b 55 a0	 mov	 edx, DWORD PTR $T16[ebp+4]
  00191	89 55 b0	 mov	 DWORD PTR _uv_range$[ebp+4], edx
  00194	8b 45 a4	 mov	 eax, DWORD PTR $T16[ebp+8]
  00197	89 45 b4	 mov	 DWORD PTR _uv_range$[ebp+8], eax

; 301  :     uint8_t *srcULine = (uint8_t *)src[1] + ((src_uv_pitch_byte * uv_range.start_src) + (crop_left >> 1));

  0019a	b9 04 00 00 00	 mov	 ecx, 4
  0019f	c1 e1 00	 shl	 ecx, 0
  001a2	8b 53 18	 mov	 edx, DWORD PTR _src_uv_pitch_byte$[ebx]
  001a5	0f af 55 ac	 imul	 edx, DWORD PTR _uv_range$[ebp]
  001a9	8b 45 f8	 mov	 eax, DWORD PTR _crop_left$[ebp]
  001ac	d1 f8		 sar	 eax, 1
  001ae	03 d0		 add	 edx, eax
  001b0	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  001b3	03 14 08	 add	 edx, DWORD PTR [eax+ecx]
  001b6	89 55 98	 mov	 DWORD PTR _srcULine$[ebp], edx

; 302  :     uint8_t *srcVLine = (uint8_t *)src[2] + ((src_uv_pitch_byte * uv_range.start_src) + (crop_left >> 1));

  001b9	b9 04 00 00 00	 mov	 ecx, 4
  001be	d1 e1		 shl	 ecx, 1
  001c0	8b 53 18	 mov	 edx, DWORD PTR _src_uv_pitch_byte$[ebx]
  001c3	0f af 55 ac	 imul	 edx, DWORD PTR _uv_range$[ebp]
  001c7	8b 45 f8	 mov	 eax, DWORD PTR _crop_left$[ebp]
  001ca	d1 f8		 sar	 eax, 1
  001cc	03 d0		 add	 edx, eax
  001ce	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  001d1	03 14 08	 add	 edx, DWORD PTR [eax+ecx]
  001d4	89 55 94	 mov	 DWORD PTR _srcVLine$[ebp], edx

; 303  :     uint8_t *dstLine = (uint8_t *)dst[1] + dst_y_pitch_byte * uv_range.start_dst;

  001d7	b9 04 00 00 00	 mov	 ecx, 4
  001dc	c1 e1 00	 shl	 ecx, 0
  001df	8b 53 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebx]
  001e2	0f af 55 b0	 imul	 edx, DWORD PTR _uv_range$[ebp+4]
  001e6	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  001e9	03 14 08	 add	 edx, DWORD PTR [eax+ecx]
  001ec	89 55 90	 mov	 DWORD PTR _dstLine$[ebp], edx

; 304  :     for (int y = 0; y < uv_range.len; y++, srcULine += src_uv_pitch_byte, srcVLine += src_uv_pitch_byte, dstLine += dst_y_pitch_byte) {

  001ef	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR _y$15[ebp], 0
  001f6	eb 24		 jmp	 SHORT $LN7@convert_yv
$LN5@convert_yv:
  001f8	8b 4d 8c	 mov	 ecx, DWORD PTR _y$15[ebp]
  001fb	83 c1 01	 add	 ecx, 1
  001fe	89 4d 8c	 mov	 DWORD PTR _y$15[ebp], ecx
  00201	8b 55 98	 mov	 edx, DWORD PTR _srcULine$[ebp]
  00204	03 53 18	 add	 edx, DWORD PTR _src_uv_pitch_byte$[ebx]
  00207	89 55 98	 mov	 DWORD PTR _srcULine$[ebp], edx
  0020a	8b 45 94	 mov	 eax, DWORD PTR _srcVLine$[ebp]
  0020d	03 43 18	 add	 eax, DWORD PTR _src_uv_pitch_byte$[ebx]
  00210	89 45 94	 mov	 DWORD PTR _srcVLine$[ebp], eax
  00213	8b 4d 90	 mov	 ecx, DWORD PTR _dstLine$[ebp]
  00216	03 4b 1c	 add	 ecx, DWORD PTR _dst_y_pitch_byte$[ebx]
  00219	89 4d 90	 mov	 DWORD PTR _dstLine$[ebp], ecx
$LN7@convert_yv:
  0021c	8b 55 8c	 mov	 edx, DWORD PTR _y$15[ebp]
  0021f	3b 55 b4	 cmp	 edx, DWORD PTR _uv_range$[ebp+8]
  00222	0f 8d 13 01 00
	00		 jge	 $LN1@convert_yv

; 305  :         const int x_fin = width - crop_right;

  00228	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  0022b	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  0022e	89 45 88	 mov	 DWORD PTR _x_fin$14[ebp], eax

; 306  :         uint8_t *src_u_ptr = srcULine;

  00231	8b 4d 98	 mov	 ecx, DWORD PTR _srcULine$[ebp]
  00234	89 4d 84	 mov	 DWORD PTR _src_u_ptr$13[ebp], ecx

; 307  :         uint8_t *src_v_ptr = srcVLine;

  00237	8b 55 94	 mov	 edx, DWORD PTR _srcVLine$[ebp]
  0023a	89 55 80	 mov	 DWORD PTR _src_v_ptr$12[ebp], edx

; 308  :         uint8_t *dst_ptr = dstLine;

  0023d	8b 45 90	 mov	 eax, DWORD PTR _dstLine$[ebp]
  00240	89 85 7c ff ff
	ff		 mov	 DWORD PTR _dst_ptr$11[ebp], eax

; 309  :         __m128i x0, x1, x2;
; 310  :         for (int x = crop_left; x < x_fin; x += 32, src_u_ptr += 16, src_v_ptr += 16, dst_ptr += 32) {

  00246	8b 4d f8	 mov	 ecx, DWORD PTR _crop_left$[ebp]
  00249	89 8d 3c ff ff
	ff		 mov	 DWORD PTR _x$7[ebp], ecx
  0024f	eb 30		 jmp	 SHORT $LN10@convert_yv
$LN8@convert_yv:
  00251	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR _x$7[ebp]
  00257	83 c2 20	 add	 edx, 32			; 00000020H
  0025a	89 95 3c ff ff
	ff		 mov	 DWORD PTR _x$7[ebp], edx
  00260	8b 45 84	 mov	 eax, DWORD PTR _src_u_ptr$13[ebp]
  00263	83 c0 10	 add	 eax, 16			; 00000010H
  00266	89 45 84	 mov	 DWORD PTR _src_u_ptr$13[ebp], eax
  00269	8b 4d 80	 mov	 ecx, DWORD PTR _src_v_ptr$12[ebp]
  0026c	83 c1 10	 add	 ecx, 16			; 00000010H
  0026f	89 4d 80	 mov	 DWORD PTR _src_v_ptr$12[ebp], ecx
  00272	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR _dst_ptr$11[ebp]
  00278	83 c2 20	 add	 edx, 32			; 00000020H
  0027b	89 95 7c ff ff
	ff		 mov	 DWORD PTR _dst_ptr$11[ebp], edx
$LN10@convert_yv:
  00281	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _x$7[ebp]
  00287	3b 45 88	 cmp	 eax, DWORD PTR _x_fin$14[ebp]
  0028a	0f 8d a6 00 00
	00		 jge	 $LN9@convert_yv

; 311  :             x0 = _mm_loadu_si128((const __m128i *)src_u_ptr);

  00290	8b 4d 84	 mov	 ecx, DWORD PTR _src_u_ptr$13[ebp]
  00293	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00296	0f 29 85 20 ff
	ff ff		 movaps	 XMMWORD PTR $T6[ebp], xmm0
  0029d	0f 28 85 20 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T6[ebp]
  002a4	0f 29 85 60 ff
	ff ff		 movaps	 XMMWORD PTR _x0$10[ebp], xmm0

; 312  :             x1 = _mm_loadu_si128((const __m128i *)src_v_ptr);

  002ab	8b 55 80	 mov	 edx, DWORD PTR _src_v_ptr$12[ebp]
  002ae	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  002b1	0f 29 85 10 ff
	ff ff		 movaps	 XMMWORD PTR $T5[ebp], xmm0
  002b8	0f 28 85 10 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T5[ebp]
  002bf	0f 29 85 50 ff
	ff ff		 movaps	 XMMWORD PTR _x1$9[ebp], xmm0

; 313  : 
; 314  :             x2 = _mm_unpackhi_epi8(x0, x1);

  002c6	0f 28 85 60 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x0$10[ebp]
  002cd	66 0f 68 85 50
	ff ff ff	 punpckhbw xmm0, XMMWORD PTR _x1$9[ebp]
  002d5	0f 29 85 00 ff
	ff ff		 movaps	 XMMWORD PTR $T4[ebp], xmm0
  002dc	0f 28 85 00 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T4[ebp]
  002e3	0f 29 85 40 ff
	ff ff		 movaps	 XMMWORD PTR _x2$8[ebp], xmm0

; 315  :             x0 = _mm_unpacklo_epi8(x0, x1);

  002ea	0f 28 85 60 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x0$10[ebp]
  002f1	66 0f 60 85 50
	ff ff ff	 punpcklbw xmm0, XMMWORD PTR _x1$9[ebp]
  002f9	0f 29 85 f0 fe
	ff ff		 movaps	 XMMWORD PTR $T3[ebp], xmm0
  00300	0f 28 85 f0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T3[ebp]
  00307	0f 29 85 60 ff
	ff ff		 movaps	 XMMWORD PTR _x0$10[ebp], xmm0

; 316  : 
; 317  :             _mm_storeu_si128((__m128i *)(dst_ptr +  0), x0);

  0030e	0f 10 85 60 ff
	ff ff		 movups	 xmm0, XMMWORD PTR _x0$10[ebp]
  00315	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _dst_ptr$11[ebp]
  0031b	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 318  :             _mm_storeu_si128((__m128i *)(dst_ptr + 16), x2);

  0031e	0f 10 85 40 ff
	ff ff		 movups	 xmm0, XMMWORD PTR _x2$8[ebp]
  00325	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _dst_ptr$11[ebp]
  0032b	83 c1 10	 add	 ecx, 16			; 00000010H
  0032e	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 319  :         }

  00331	e9 1b ff ff ff	 jmp	 $LN8@convert_yv
$LN9@convert_yv:

; 320  :     }

  00336	e9 bd fe ff ff	 jmp	 $LN5@convert_yv
$LN1@convert_yv:

; 321  : }

  0033b	52		 push	 edx
  0033c	8b cd		 mov	 ecx, ebp
  0033e	50		 push	 eax
  0033f	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN16@convert_yv
  00345	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0034a	58		 pop	 eax
  0034b	5a		 pop	 edx
  0034c	5f		 pop	 edi
  0034d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00350	33 cd		 xor	 ecx, ebp
  00352	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00357	8b e5		 mov	 esp, ebp
  00359	5d		 pop	 ebp
  0035a	8b e3		 mov	 esp, ebx
  0035c	5b		 pop	 ebx
  0035d	c3		 ret	 0
  0035e	66 90		 npad	 2
$LN16@convert_yv:
  00360	02 00 00 00	 DD	 2
  00364	00 00 00 00	 DD	 $LN15@convert_yv
$LN15@convert_yv:
  00368	dc ff ff ff	 DD	 -36			; ffffffdcH
  0036c	0c 00 00 00	 DD	 12			; 0000000cH
  00370	00 00 00 00	 DD	 $LN13@convert_yv
  00374	ac ff ff ff	 DD	 -84			; ffffffacH
  00378	0c 00 00 00	 DD	 12			; 0000000cH
  0037c	00 00 00 00	 DD	 $LN14@convert_yv
$LN14@convert_yv:
  00380	75		 DB	 117			; 00000075H
  00381	76		 DB	 118			; 00000076H
  00382	5f		 DB	 95			; 0000005fH
  00383	72		 DB	 114			; 00000072H
  00384	61		 DB	 97			; 00000061H
  00385	6e		 DB	 110			; 0000006eH
  00386	67		 DB	 103			; 00000067H
  00387	65		 DB	 101			; 00000065H
  00388	00		 DB	 0
$LN13@convert_yv:
  00389	79		 DB	 121			; 00000079H
  0038a	5f		 DB	 95			; 0000005fH
  0038b	72		 DB	 114			; 00000072H
  0038c	61		 DB	 97			; 00000061H
  0038d	6e		 DB	 110			; 0000006eH
  0038e	67		 DB	 103			; 00000067H
  0038f	65		 DB	 101			; 00000065H
  00390	00		 DB	 0
??$convert_yv12_to_nv12_simd@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_to_nv12_simd<0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yv12_to_nv12_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_to_nv12_avx

; 52   : void convert_yv12_to_nv12_avx(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 53   :     convert_yv12_to_nv12_simd<false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yv12_to_nv12_simd@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_to_nv12_simd<0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 54   : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yv12_to_nv12_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_to_nv12_avx
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuy2_to_nv12_i_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuy2_to_nv12_i_avx

; 48   : void convert_yuy2_to_nv12_i_avx(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 49   :     return convert_yuy2_to_nv12_i_simd(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ?convert_yuy2_to_nv12_i_simd@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuy2_to_nv12_i_simd
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 50   : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yuy2_to_nv12_i_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuy2_to_nv12_i_avx
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuy2_to_nv12_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuy2_to_nv12_avx

; 44   : void convert_yuy2_to_nv12_avx(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 45   :     return convert_yuy2_to_nv12_simd(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ?convert_yuy2_to_nv12_simd@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuy2_to_nv12_simd
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 46   : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yuy2_to_nv12_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuy2_to_nv12_avx
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -224						; size = 16
$T2 = -208						; size = 16
$T3 = -192						; size = 16
$T4 = -176						; size = 16
$T5 = -160						; size = 16
$T6 = -144						; size = 16
$T7 = -128						; size = 16
$T8 = -112						; size = 16
$T9 = -96						; size = 16
$T10 = -80						; size = 16
$T11 = -64						; size = 16
$T12 = -48						; size = 16
_x4$ = -32						; size = 16
_x3$ = -16						; size = 16
_x0$ = 8						; size = 4
_x1$ = 12						; size = 4
_x2$ = 16						; size = 4
?gather_y_u_v_to_yc48@@YAXAAT__m128i@@00@Z PROC		; gather_y_u_v_to_yc48

; 1528 : static __forceinline void gather_y_u_v_to_yc48(__m128i& x0, __m128i& x1, __m128i& x2) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec e0 00 00
	00		 sub	 esp, 224		; 000000e0H
  0001c	57		 push	 edi
  0001d	8d bd 20 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-224]
  00023	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd

; 1529 :     __m128i x3, x4;
; 1530 : #if USE_SSE41
; 1531 :     alignas(16) static const uint8_t shuffle_yc48[16] = {
; 1532 :         0x00, 0x01, 0x06, 0x07, 0x0C, 0x0D, 0x02, 0x03, 0x08, 0x09, 0x0E, 0x0F, 0x04, 0x05, 0x0A, 0x0B
; 1533 :     };
; 1534 :     x4 = _mm_load_si128((__m128i *)shuffle_yc48);

  0002f	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR ?shuffle_yc48@?1??gather_y_u_v_to_yc48@@YAXAAT__m128i@@00@Z@4QBEB
  00036	0f 29 45 d0	 movaps	 XMMWORD PTR $T12[ebp], xmm0
  0003a	0f 28 45 d0	 movaps	 xmm0, XMMWORD PTR $T12[ebp]
  0003e	0f 29 45 e0	 movaps	 XMMWORD PTR _x4$[ebp], xmm0

; 1535 :     x0 = _mm_shuffle_epi8(x0, x4);                          //5,2,7,4,1,6,3,0

  00042	8b 43 08	 mov	 eax, DWORD PTR _x0$[ebx]
  00045	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00048	66 0f 38 00 45
	e0		 pshufb	 xmm0, XMMWORD PTR _x4$[ebp]
  0004e	0f 29 45 c0	 movaps	 XMMWORD PTR $T11[ebp], xmm0
  00052	8b 4b 08	 mov	 ecx, DWORD PTR _x0$[ebx]
  00055	0f 10 45 c0	 movups	 xmm0, XMMWORD PTR $T11[ebp]
  00059	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 1536 :     x1 = _mm_shuffle_epi8(x1, _mm_alignr_epi8(x4, x4, 14)); //2,7,4,1,6,3,0,5

  0005c	0f 28 45 e0	 movaps	 xmm0, XMMWORD PTR _x4$[ebp]
  00060	66 0f 3a 0f 45
	e0 0e		 palignr xmm0, XMMWORD PTR _x4$[ebp], 14 ; 0000000eH
  00067	0f 29 45 b0	 movaps	 XMMWORD PTR $T10[ebp], xmm0
  0006b	8b 53 0c	 mov	 edx, DWORD PTR _x1$[ebx]
  0006e	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  00071	66 0f 38 00 45
	b0		 pshufb	 xmm0, XMMWORD PTR $T10[ebp]
  00077	0f 29 45 a0	 movaps	 XMMWORD PTR $T9[ebp], xmm0
  0007b	8b 43 0c	 mov	 eax, DWORD PTR _x1$[ebx]
  0007e	0f 10 45 a0	 movups	 xmm0, XMMWORD PTR $T9[ebp]
  00082	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 1537 :     x2 = _mm_shuffle_epi8(x2, _mm_alignr_epi8(x4, x4, 12)); //7,4,1,6,3,0,5,2

  00085	0f 28 45 e0	 movaps	 xmm0, XMMWORD PTR _x4$[ebp]
  00089	66 0f 3a 0f 45
	e0 0c		 palignr xmm0, XMMWORD PTR _x4$[ebp], 12 ; 0000000cH
  00090	0f 29 45 90	 movaps	 XMMWORD PTR $T8[ebp], xmm0
  00094	8b 4b 10	 mov	 ecx, DWORD PTR _x2$[ebx]
  00097	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  0009a	66 0f 38 00 45
	90		 pshufb	 xmm0, XMMWORD PTR $T8[ebp]
  000a0	0f 29 45 80	 movaps	 XMMWORD PTR $T7[ebp], xmm0
  000a4	8b 53 10	 mov	 edx, DWORD PTR _x2$[ebx]
  000a7	0f 10 45 80	 movups	 xmm0, XMMWORD PTR $T7[ebp]
  000ab	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 1538 : 
; 1539 :     x3 = _mm_blend_epi16(x0, x1, 0x80 + 0x10 + 0x02);

  000ae	8b 43 0c	 mov	 eax, DWORD PTR _x1$[ebx]
  000b1	8b 4b 08	 mov	 ecx, DWORD PTR _x0$[ebx]
  000b4	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  000b7	66 0f 3a 0e 00
	92		 pblendw xmm0, XMMWORD PTR [eax], 146 ; 00000092H
  000bd	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR $T6[ebp], xmm0
  000c4	0f 28 85 70 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T6[ebp]
  000cb	0f 29 45 f0	 movaps	 XMMWORD PTR _x3$[ebp], xmm0

; 1540 :     x3 = _mm_blend_epi16(x3, x2, 0x20 + 0x04);

  000cf	8b 53 10	 mov	 edx, DWORD PTR _x2$[ebx]
  000d2	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x3$[ebp]
  000d6	66 0f 3a 0e 02
	24		 pblendw xmm0, XMMWORD PTR [edx], 36 ; 00000024H
  000dc	0f 29 85 60 ff
	ff ff		 movaps	 XMMWORD PTR $T5[ebp], xmm0
  000e3	0f 28 85 60 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T5[ebp]
  000ea	0f 29 45 f0	 movaps	 XMMWORD PTR _x3$[ebp], xmm0

; 1541 : 
; 1542 :     x4 = _mm_blend_epi16(x2, x1, 0x20 + 0x04);

  000ee	8b 43 0c	 mov	 eax, DWORD PTR _x1$[ebx]
  000f1	8b 4b 10	 mov	 ecx, DWORD PTR _x2$[ebx]
  000f4	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  000f7	66 0f 3a 0e 00
	24		 pblendw xmm0, XMMWORD PTR [eax], 36 ; 00000024H
  000fd	0f 29 85 50 ff
	ff ff		 movaps	 XMMWORD PTR $T4[ebp], xmm0
  00104	0f 28 85 50 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T4[ebp]
  0010b	0f 29 45 e0	 movaps	 XMMWORD PTR _x4$[ebp], xmm0

; 1543 :     x4 = _mm_blend_epi16(x4, x0, 0x80 + 0x10 + 0x02);

  0010f	8b 53 08	 mov	 edx, DWORD PTR _x0$[ebx]
  00112	0f 28 45 e0	 movaps	 xmm0, XMMWORD PTR _x4$[ebp]
  00116	66 0f 3a 0e 02
	92		 pblendw xmm0, XMMWORD PTR [edx], 146 ; 00000092H
  0011c	0f 29 85 40 ff
	ff ff		 movaps	 XMMWORD PTR $T3[ebp], xmm0
  00123	0f 28 85 40 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T3[ebp]
  0012a	0f 29 45 e0	 movaps	 XMMWORD PTR _x4$[ebp], xmm0

; 1544 : 
; 1545 :     x2 = _mm_blend_epi16(x2, x0, 0x20 + 0x04);

  0012e	8b 43 08	 mov	 eax, DWORD PTR _x0$[ebx]
  00131	8b 4b 10	 mov	 ecx, DWORD PTR _x2$[ebx]
  00134	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00137	66 0f 3a 0e 00
	24		 pblendw xmm0, XMMWORD PTR [eax], 36 ; 00000024H
  0013d	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR $T2[ebp], xmm0
  00144	8b 53 10	 mov	 edx, DWORD PTR _x2$[ebx]
  00147	0f 10 85 30 ff
	ff ff		 movups	 xmm0, XMMWORD PTR $T2[ebp]
  0014e	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 1546 :     x2 = _mm_blend_epi16(x2, x1, 0x40 + 0x08 + 0x01);

  00151	8b 43 0c	 mov	 eax, DWORD PTR _x1$[ebx]
  00154	8b 4b 10	 mov	 ecx, DWORD PTR _x2$[ebx]
  00157	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  0015a	66 0f 3a 0e 00
	49		 pblendw xmm0, XMMWORD PTR [eax], 73 ; 00000049H
  00160	0f 29 85 20 ff
	ff ff		 movaps	 XMMWORD PTR $T1[ebp], xmm0
  00167	8b 53 10	 mov	 edx, DWORD PTR _x2$[ebx]
  0016a	0f 10 85 20 ff
	ff ff		 movups	 xmm0, XMMWORD PTR $T1[ebp]
  00171	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 1547 : 
; 1548 :     x0 = x3;

  00174	8b 43 08	 mov	 eax, DWORD PTR _x0$[ebx]
  00177	0f 10 45 f0	 movups	 xmm0, XMMWORD PTR _x3$[ebp]
  0017b	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 1549 :     x1 = x4;

  0017e	8b 4b 0c	 mov	 ecx, DWORD PTR _x1$[ebx]
  00181	0f 10 45 e0	 movups	 xmm0, XMMWORD PTR _x4$[ebp]
  00185	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 1550 : #else
; 1551 :     x0 = _mm_shufflelo_epi16(x0, _MM_SHUFFLE(3,1,2,0)); // 7,6,5,4,3,1,2,0
; 1552 :     x0 = _mm_shufflehi_epi16(x0, _MM_SHUFFLE(3,1,2,0)); // 7,5,6,4,3,1,2,0
; 1553 :     x0 = _mm_shuffle_epi32(  x0, _MM_SHUFFLE(3,1,2,0)); // 7,5,3,1,6,4,2,0
; 1554 :     x0 = _mm_shufflelo_epi16(x0, _MM_SHUFFLE(3,1,2,0)); // 7,5,3,1,6,2,4,0
; 1555 :     x0 = _mm_shufflehi_epi16(x0, _MM_SHUFFLE(3,1,2,0)); // 7,3,5,1,6,2,4,0
; 1556 : 
; 1557 :     x1 = _mm_shufflelo_epi16(x1, _MM_SHUFFLE(3,1,2,0));
; 1558 :     x1 = _mm_shufflehi_epi16(x1, _MM_SHUFFLE(3,1,2,0));
; 1559 :     x1 = _mm_shuffle_epi32(  x1, _MM_SHUFFLE(3,1,2,0));
; 1560 :     x1 = _mm_shufflelo_epi16(x1, _MM_SHUFFLE(3,1,2,0));
; 1561 :     x1 = _mm_shufflehi_epi16(x1, _MM_SHUFFLE(3,1,2,0));
; 1562 : 
; 1563 :     x2 = _mm_shufflelo_epi16(x2, _MM_SHUFFLE(3,1,2,0));
; 1564 :     x2 = _mm_shufflehi_epi16(x2, _MM_SHUFFLE(3,1,2,0));
; 1565 :     x2 = _mm_shuffle_epi32(  x2, _MM_SHUFFLE(3,1,2,0));
; 1566 :     x2 = _mm_shufflelo_epi16(x2, _MM_SHUFFLE(3,1,2,0));
; 1567 :     x2 = _mm_shufflehi_epi16(x2, _MM_SHUFFLE(3,1,2,0));
; 1568 : 
; 1569 :     x3 = _mm_shuffle_epi32(x0, _MM_SHUFFLE(3,2,3,2));
; 1570 :     x0 = _mm_unpacklo_epi16(x0, x1);
; 1571 :     x1 = _mm_unpackhi_epi16(x1, x2);
; 1572 :     x2 = _mm_unpacklo_epi16(x2, x3);
; 1573 : 
; 1574 :     x3 = _mm_shuffle_epi32(x0, _MM_SHUFFLE(3,2,3,2));
; 1575 :     x0 = _mm_unpacklo_epi32(x0, x2);
; 1576 :     x2 = _mm_unpackhi_epi32(x2, x1);
; 1577 :     x1 = _mm_unpacklo_epi32(x1, x3);
; 1578 : 
; 1579 :     x3 = _mm_shuffle_epi32(x0, _MM_SHUFFLE(3,2,3,2));
; 1580 :     x0 = _mm_unpacklo_epi64(x0, x1);
; 1581 :     x1 = _mm_unpackhi_epi64(x1, x2);
; 1582 :     x2 = _mm_unpacklo_epi64(x2, x3);
; 1583 : 
; 1584 :     x4 = x2;
; 1585 :     x2 = x1;
; 1586 :     x1 = x4;
; 1587 : #endif
; 1588 : }

  00188	5f		 pop	 edi
  00189	8b e5		 mov	 esp, ebp
  0018b	5d		 pop	 ebp
  0018c	8b e3		 mov	 esp, ebx
  0018e	5b		 pop	 ebx
  0018f	c3		 ret	 0
?gather_y_u_v_to_yc48@@YAXAAT__m128i@@00@Z ENDP		; gather_y_u_v_to_yc48
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -320						; size = 16
$T2 = -304						; size = 16
$T3 = -288						; size = 16
$T4 = -272						; size = 16
$T5 = -256						; size = 16
$T6 = -240						; size = 16
$T7 = -224						; size = 16
$T8 = -208						; size = 16
$T9 = -192						; size = 16
$T10 = -176						; size = 16
$T11 = -160						; size = 16
$T12 = -144						; size = 16
$T13 = -128						; size = 16
$T14 = -112						; size = 16
$T15 = -96						; size = 16
$T16 = -80						; size = 16
_MASK_INT$ = -52					; size = 4
_x5$ = -48						; size = 16
_x4$ = -32						; size = 16
_x3$ = -16						; size = 16
_x0$ = 8						; size = 4
_x1$ = 12						; size = 4
_x2$ = 16						; size = 4
?gather_y_u_v_from_yc48@@YAXAAT__m128i@@00@Z PROC	; gather_y_u_v_from_yc48

; 1464 : static __forceinline void gather_y_u_v_from_yc48(__m128i& x0, __m128i& x1, __m128i& x2) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 40 01 00
	00		 sub	 esp, 320		; 00000140H
  0001c	57		 push	 edi
  0001d	8d bd c0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-320]
  00023	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd

; 1465 : #if USE_SSE41
; 1466 :     __m128i x3, x4, x5;
; 1467 :     const int MASK_INT = 0x40 + 0x08 + 0x01;

  0002f	c7 45 cc 49 00
	00 00		 mov	 DWORD PTR _MASK_INT$[ebp], 73 ; 00000049H

; 1468 :     x3 = _mm_blend_epi16(x2, x0, MASK_INT);

  00036	8b 43 08	 mov	 eax, DWORD PTR _x0$[ebx]
  00039	8b 4b 10	 mov	 ecx, DWORD PTR _x2$[ebx]
  0003c	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  0003f	66 0f 3a 0e 00
	49		 pblendw xmm0, XMMWORD PTR [eax], 73 ; 00000049H
  00045	0f 29 45 b0	 movaps	 XMMWORD PTR $T16[ebp], xmm0
  00049	0f 28 45 b0	 movaps	 xmm0, XMMWORD PTR $T16[ebp]
  0004d	0f 29 45 f0	 movaps	 XMMWORD PTR _x3$[ebp], xmm0

; 1469 :     x4 = _mm_blend_epi16(x1, x2, MASK_INT);

  00051	8b 53 10	 mov	 edx, DWORD PTR _x2$[ebx]
  00054	8b 43 0c	 mov	 eax, DWORD PTR _x1$[ebx]
  00057	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  0005a	66 0f 3a 0e 02
	49		 pblendw xmm0, XMMWORD PTR [edx], 73 ; 00000049H
  00060	0f 29 45 a0	 movaps	 XMMWORD PTR $T15[ebp], xmm0
  00064	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR $T15[ebp]
  00068	0f 29 45 e0	 movaps	 XMMWORD PTR _x4$[ebp], xmm0

; 1470 :     x5 = _mm_blend_epi16(x0, x1, MASK_INT);

  0006c	8b 4b 0c	 mov	 ecx, DWORD PTR _x1$[ebx]
  0006f	8b 53 08	 mov	 edx, DWORD PTR _x0$[ebx]
  00072	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  00075	66 0f 3a 0e 01
	49		 pblendw xmm0, XMMWORD PTR [ecx], 73 ; 00000049H
  0007b	0f 29 45 90	 movaps	 XMMWORD PTR $T14[ebp], xmm0
  0007f	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR $T14[ebp]
  00083	0f 29 45 d0	 movaps	 XMMWORD PTR _x5$[ebp], xmm0

; 1471 : 
; 1472 :     x3 = _mm_blend_epi16(x3, x1, MASK_INT<<1);

  00087	8b 43 0c	 mov	 eax, DWORD PTR _x1$[ebx]
  0008a	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x3$[ebp]
  0008e	66 0f 3a 0e 00
	92		 pblendw xmm0, XMMWORD PTR [eax], 146 ; 00000092H
  00094	0f 29 45 80	 movaps	 XMMWORD PTR $T13[ebp], xmm0
  00098	0f 28 45 80	 movaps	 xmm0, XMMWORD PTR $T13[ebp]
  0009c	0f 29 45 f0	 movaps	 XMMWORD PTR _x3$[ebp], xmm0

; 1473 :     x4 = _mm_blend_epi16(x4, x0, MASK_INT<<1);

  000a0	8b 4b 08	 mov	 ecx, DWORD PTR _x0$[ebx]
  000a3	0f 28 45 e0	 movaps	 xmm0, XMMWORD PTR _x4$[ebp]
  000a7	66 0f 3a 0e 01
	92		 pblendw xmm0, XMMWORD PTR [ecx], 146 ; 00000092H
  000ad	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR $T12[ebp], xmm0
  000b4	0f 28 85 70 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T12[ebp]
  000bb	0f 29 45 e0	 movaps	 XMMWORD PTR _x4$[ebp], xmm0

; 1474 :     x5 = _mm_blend_epi16(x5, x2, MASK_INT<<1);

  000bf	8b 53 10	 mov	 edx, DWORD PTR _x2$[ebx]
  000c2	0f 28 45 d0	 movaps	 xmm0, XMMWORD PTR _x5$[ebp]
  000c6	66 0f 3a 0e 02
	92		 pblendw xmm0, XMMWORD PTR [edx], 146 ; 00000092H
  000cc	0f 29 85 60 ff
	ff ff		 movaps	 XMMWORD PTR $T11[ebp], xmm0
  000d3	0f 28 85 60 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T11[ebp]
  000da	0f 29 45 d0	 movaps	 XMMWORD PTR _x5$[ebp], xmm0

; 1475 : 
; 1476 :     x0 = _mm_shuffle_epi8(x3, xC_SUFFLE_YCP_Y);

  000de	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR ?Array_SUFFLE_YCP_Y@@3QBEB
  000e5	0f 29 85 50 ff
	ff ff		 movaps	 XMMWORD PTR $T10[ebp], xmm0
  000ec	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x3$[ebp]
  000f0	66 0f 38 00 85
	50 ff ff ff	 pshufb	 xmm0, XMMWORD PTR $T10[ebp]
  000f9	0f 29 85 40 ff
	ff ff		 movaps	 XMMWORD PTR $T9[ebp], xmm0
  00100	8b 43 08	 mov	 eax, DWORD PTR _x0$[ebx]
  00103	0f 10 85 40 ff
	ff ff		 movups	 xmm0, XMMWORD PTR $T9[ebp]
  0010a	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 1477 :     x1 = _mm_shuffle_epi8(x4, _mm_alignr_epi8_simd(xC_SUFFLE_YCP_Y, xC_SUFFLE_YCP_Y, 6));

  0010d	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR ?Array_SUFFLE_YCP_Y@@3QBEB
  00114	0f 29 85 20 ff
	ff ff		 movaps	 XMMWORD PTR $T7[ebp], xmm0
  0011b	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR ?Array_SUFFLE_YCP_Y@@3QBEB
  00122	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR $T8[ebp], xmm0
  00129	0f 28 85 30 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T8[ebp]
  00130	66 0f 3a 0f 85
	20 ff ff ff 06	 palignr xmm0, XMMWORD PTR $T7[ebp], 6
  0013a	0f 29 85 10 ff
	ff ff		 movaps	 XMMWORD PTR $T6[ebp], xmm0
  00141	0f 28 45 e0	 movaps	 xmm0, XMMWORD PTR _x4$[ebp]
  00145	66 0f 38 00 85
	10 ff ff ff	 pshufb	 xmm0, XMMWORD PTR $T6[ebp]
  0014e	0f 29 85 00 ff
	ff ff		 movaps	 XMMWORD PTR $T5[ebp], xmm0
  00155	8b 4b 0c	 mov	 ecx, DWORD PTR _x1$[ebx]
  00158	0f 10 85 00 ff
	ff ff		 movups	 xmm0, XMMWORD PTR $T5[ebp]
  0015f	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 1478 :     x2 = _mm_shuffle_epi8(x5, _mm_alignr_epi8_simd(xC_SUFFLE_YCP_Y, xC_SUFFLE_YCP_Y, 12));

  00162	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR ?Array_SUFFLE_YCP_Y@@3QBEB
  00169	0f 29 85 e0 fe
	ff ff		 movaps	 XMMWORD PTR $T3[ebp], xmm0
  00170	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR ?Array_SUFFLE_YCP_Y@@3QBEB
  00177	0f 29 85 f0 fe
	ff ff		 movaps	 XMMWORD PTR $T4[ebp], xmm0
  0017e	0f 28 85 f0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T4[ebp]
  00185	66 0f 3a 0f 85
	e0 fe ff ff 0c	 palignr xmm0, XMMWORD PTR $T3[ebp], 12 ; 0000000cH
  0018f	0f 29 85 d0 fe
	ff ff		 movaps	 XMMWORD PTR $T2[ebp], xmm0
  00196	0f 28 45 d0	 movaps	 xmm0, XMMWORD PTR _x5$[ebp]
  0019a	66 0f 38 00 85
	d0 fe ff ff	 pshufb	 xmm0, XMMWORD PTR $T2[ebp]
  001a3	0f 29 85 c0 fe
	ff ff		 movaps	 XMMWORD PTR $T1[ebp], xmm0
  001aa	8b 53 10	 mov	 edx, DWORD PTR _x2$[ebx]
  001ad	0f 10 85 c0 fe
	ff ff		 movups	 xmm0, XMMWORD PTR $T1[ebp]
  001b4	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 1479 : #else
; 1480 :     //code from afs v7.5a+10
; 1481 :     __m128i x5, x6, x7, xMask;
; 1482 :     //select y
; 1483 :     alignas(16) static const uint16_t maskY_select[8] = { 0xffff, 0x0000, 0x0000, 0xffff, 0x0000, 0x0000, 0xffff, 0x0000 };
; 1484 :     xMask = _mm_load_si128((__m128i*)maskY_select);
; 1485 : 
; 1486 :     x5 = select_by_mask(x2, x0, xMask);
; 1487 :     xMask = _mm_slli_si128(xMask, 2);
; 1488 :     x5 = select_by_mask(x5, x1, xMask); //52741630
; 1489 : 
; 1490 :     x6 = _mm_unpacklo_epi16(x5, x5);    //11663300
; 1491 :     x7 = _mm_unpackhi_epi16(x5, x5);    //55227744
; 1492 : 
; 1493 :     alignas(16) static const uint16_t maskY_shuffle[8] = { 0xffff, 0x0000, 0xffff, 0x0000, 0x0000, 0xffff, 0xffff, 0x0000 };
; 1494 :     xMask = _mm_load_si128((__m128i*)maskY_shuffle);
; 1495 :     x5 = select_by_mask(x7, x6, xMask);                 //51627340
; 1496 :     x5 = _mm_shuffle_epi32(x5, _MM_SHUFFLE(1, 2, 3, 0));   //73625140
; 1497 : 
; 1498 :     x5 = _mm_unpacklo_epi16(x5, _mm_srli_si128(x5, 8)); //75316420
; 1499 :     x5 = _mm_unpacklo_epi16(x5, _mm_srli_si128(x5, 8)); //76543210
; 1500 : 
; 1501 :                                                         //select uv
; 1502 :     xMask = _mm_srli_si128(_mm_cmpeq_epi8(xMask, xMask), 8); //0x00000000, 0x00000000, 0xffffffff, 0xffffffff
; 1503 :     x6 = select_by_mask(_mm_srli_si128(x1, 2), _mm_srli_si128(x2, 2), xMask); //x  x v4 u4 v6 u6 x  x
; 1504 :     x7 = select_by_mask(x0, x1, xMask);               //x  x  v1 u1 v3 u3 x  x
; 1505 :     xMask = _mm_slli_si128(xMask, 4);                 //0x00000000, 0xffffffff, 0xffffffff, 0x00000000
; 1506 :     x0 = _mm_alignr_epi8_simd(x1, x0, 2);             //v2 u2  x  x  x  x v0 u0
; 1507 :     x6 = select_by_mask(x0, x6, xMask);               //v2 u2 v4 u4 v6 u6 v0 u0
; 1508 :     x7 = select_by_mask(x2, x7, xMask);               //v7 u7 v1 u1 v3 u3 v5 u5
; 1509 :     x0 = _mm_shuffle_epi32(x6, _MM_SHUFFLE(1, 2, 3, 0)); //v6 u6 v4 u4 v2 u2 v0 u0
; 1510 :     x1 = _mm_shuffle_epi32(x7, _MM_SHUFFLE(3, 0, 1, 2)); //v7 u7 v5 u5 v3 u3 v1 u1
; 1511 : 
; 1512 :     x6 = _mm_unpacklo_epi16(x0, x1); //v3 v2 u3 u2 v1 v0 u1 u0
; 1513 :     x7 = _mm_unpackhi_epi16(x0, x1); //v7 v6 u7 u6 v5 v4 u5 u4
; 1514 : 
; 1515 :     x0 = _mm_unpacklo_epi32(x6, x7); //v5 v4 v1 v0 u5 u4 u1 u0
; 1516 :     x1 = _mm_unpackhi_epi32(x6, x7); //v7 v6 v3 v2 u7 u6 u3 u2
; 1517 : 
; 1518 :     x6 = _mm_unpacklo_epi32(x0, x1); //u7 u6 u5 u4 u3 u2 u1 u0
; 1519 :     x7 = _mm_unpackhi_epi32(x0, x1); //v7 v6 v5 v4 v3 v2 v1 v0
; 1520 : 
; 1521 :     x0 = x5;
; 1522 :     x1 = x6;
; 1523 :     x2 = x7;
; 1524 : #endif //USE_SSE41
; 1525 : }

  001b7	5f		 pop	 edi
  001b8	8b e5		 mov	 esp, ebp
  001ba	5d		 pop	 ebp
  001bb	8b e3		 mov	 esp, ebx
  001bd	5b		 pop	 ebx
  001be	c3		 ret	 0
?gather_y_u_v_from_yc48@@YAXAAT__m128i@@00@Z ENDP	; gather_y_u_v_from_yc48
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -272						; size = 16
$T2 = -256						; size = 16
$T3 = -240						; size = 16
$T4 = -224						; size = 16
$T5 = -208						; size = 16
$T6 = -192						; size = 16
$T7 = -176						; size = 16
$T8 = -160						; size = 16
_x1$ = -144						; size = 16
$T9 = -128						; size = 16
$T10 = -112						; size = 16
_xC_0x8000$ = -96					; size = 16
$T11 = -80						; size = 16
$T12 = -64						; size = 16
$T13 = -48						; size = 16
_xC_coeff$ = -32					; size = 16
_x0$ = -16						; size = 16
?convert_uv_range_to_yc48@@YA?AT__m128i@@T1@@Z PROC	; convert_uv_range_to_yc48
; _x0$ = xmm0

; 1447 : static __forceinline __m128i convert_uv_range_to_yc48(__m128i x0) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 10 01 00
	00		 sub	 esp, 272		; 00000110H
  0001c	57		 push	 edi
  0001d	8d bd f0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-272]
  00023	b9 44 00 00 00	 mov	 ecx, 68			; 00000044H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	0f 29 45 f0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1448 :     //coeff = 4682
; 1449 :     //UV = (( uv - 32768 ) * coef + (1<<15) ) >> 16
; 1450 :     const __m128i xC_coeff = _mm_unpacklo_epi16(_mm_set1_epi16(4682), _mm_set1_epi16(-1));

  00033	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@ffffffffffffffffffffffffffffffff
  0003a	0f 29 45 c0	 movaps	 XMMWORD PTR $T12[ebp], xmm0
  0003e	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@124a124a124a124a124a124a124a124a
  00045	0f 29 45 d0	 movaps	 XMMWORD PTR $T13[ebp], xmm0
  00049	0f 28 45 d0	 movaps	 xmm0, XMMWORD PTR $T13[ebp]
  0004d	66 0f 61 45 c0	 punpcklwd xmm0, XMMWORD PTR $T12[ebp]
  00052	0f 29 45 b0	 movaps	 XMMWORD PTR $T11[ebp], xmm0
  00056	0f 28 45 b0	 movaps	 xmm0, XMMWORD PTR $T11[ebp]
  0005a	0f 29 45 e0	 movaps	 XMMWORD PTR _xC_coeff$[ebp], xmm0

; 1451 :     const __m128i xC_0x8000 = _mm_slli_epi16(_mm_cmpeq_epi32(x0, x0), 15);

  0005e	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  00062	66 0f 76 45 f0	 pcmpeqd xmm0, XMMWORD PTR _x0$[ebp]
  00067	0f 29 45 90	 movaps	 XMMWORD PTR $T10[ebp], xmm0
  0006b	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR $T10[ebp]
  0006f	66 0f 71 f0 0f	 psllw	 xmm0, 15		; 0000000fH
  00074	0f 29 45 80	 movaps	 XMMWORD PTR $T9[ebp], xmm0
  00078	0f 28 45 80	 movaps	 xmm0, XMMWORD PTR $T9[ebp]
  0007c	0f 29 45 a0	 movaps	 XMMWORD PTR _xC_0x8000$[ebp], xmm0

; 1452 :     __m128i x1;
; 1453 :     x0 = _mm_add_epi16(x0, xC_0x8000); // -32768

  00080	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  00084	66 0f fd 45 a0	 paddw	 xmm0, XMMWORD PTR _xC_0x8000$[ebp]
  00089	0f 29 85 60 ff
	ff ff		 movaps	 XMMWORD PTR $T8[ebp], xmm0
  00090	0f 28 85 60 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T8[ebp]
  00097	0f 29 45 f0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1454 :     x1 = _mm_unpackhi_epi16(x0, xC_0x8000);

  0009b	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  0009f	66 0f 69 45 a0	 punpckhwd xmm0, XMMWORD PTR _xC_0x8000$[ebp]
  000a4	0f 29 85 50 ff
	ff ff		 movaps	 XMMWORD PTR $T7[ebp], xmm0
  000ab	0f 28 85 50 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T7[ebp]
  000b2	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR _x1$[ebp], xmm0

; 1455 :     x0 = _mm_unpacklo_epi16(x0, xC_0x8000);

  000b9	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  000bd	66 0f 61 45 a0	 punpcklwd xmm0, XMMWORD PTR _xC_0x8000$[ebp]
  000c2	0f 29 85 40 ff
	ff ff		 movaps	 XMMWORD PTR $T6[ebp], xmm0
  000c9	0f 28 85 40 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T6[ebp]
  000d0	0f 29 45 f0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1456 :     x0 = _mm_madd_epi16(x0, xC_coeff);

  000d4	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  000d8	66 0f f5 45 e0	 pmaddwd xmm0, XMMWORD PTR _xC_coeff$[ebp]
  000dd	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR $T5[ebp], xmm0
  000e4	0f 28 85 30 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T5[ebp]
  000eb	0f 29 45 f0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1457 :     x1 = _mm_madd_epi16(x1, xC_coeff);

  000ef	0f 28 85 70 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$[ebp]
  000f6	66 0f f5 45 e0	 pmaddwd xmm0, XMMWORD PTR _xC_coeff$[ebp]
  000fb	0f 29 85 20 ff
	ff ff		 movaps	 XMMWORD PTR $T4[ebp], xmm0
  00102	0f 28 85 20 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T4[ebp]
  00109	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR _x1$[ebp], xmm0

; 1458 :     x0 = _mm_srai_epi32(x0, 16);

  00110	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  00114	66 0f 72 e0 10	 psrad	 xmm0, 16		; 00000010H
  00119	0f 29 85 10 ff
	ff ff		 movaps	 XMMWORD PTR $T3[ebp], xmm0
  00120	0f 28 85 10 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T3[ebp]
  00127	0f 29 45 f0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1459 :     x1 = _mm_srai_epi32(x1, 16);

  0012b	0f 28 85 70 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$[ebp]
  00132	66 0f 72 e0 10	 psrad	 xmm0, 16		; 00000010H
  00137	0f 29 85 00 ff
	ff ff		 movaps	 XMMWORD PTR $T2[ebp], xmm0
  0013e	0f 28 85 00 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T2[ebp]
  00145	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR _x1$[ebp], xmm0

; 1460 :     x0 = _mm_packs_epi32(x0, x1);

  0014c	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  00150	66 0f 6b 85 70
	ff ff ff	 packssdw xmm0, XMMWORD PTR _x1$[ebp]
  00158	0f 29 85 f0 fe
	ff ff		 movaps	 XMMWORD PTR $T1[ebp], xmm0
  0015f	0f 28 85 f0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T1[ebp]
  00166	0f 29 45 f0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1461 :     return x0;

  0016a	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]

; 1462 : }

  0016e	5f		 pop	 edi
  0016f	8b e5		 mov	 esp, ebp
  00171	5d		 pop	 ebp
  00172	8b e3		 mov	 esp, ebx
  00174	5b		 pop	 ebx
  00175	c3		 ret	 0
?convert_uv_range_to_yc48@@YA?AT__m128i@@T1@@Z ENDP	; convert_uv_range_to_yc48
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -144						; size = 16
$T2 = -128						; size = 16
$T3 = -112						; size = 16
$T4 = -96						; size = 16
$T5 = -80						; size = 16
$T6 = -64						; size = 16
$T7 = -48						; size = 16
_xC_0x8000$ = -32					; size = 16
_x0$ = -16						; size = 16
?convert_y_range_to_yc48@@YA?AT__m128i@@T1@@Z PROC	; convert_y_range_to_yc48
; _x0$ = xmm0

; 1437 : static __forceinline __m128i convert_y_range_to_yc48(__m128i x0) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 90 00 00
	00		 sub	 esp, 144		; 00000090H
  0001c	57		 push	 edi
  0001d	8d bd 70 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-144]
  00023	b9 24 00 00 00	 mov	 ecx, 36			; 00000024H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	0f 29 45 f0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1438 :     //coef = 4788
; 1439 :     //((( y - 32768 ) * coef) >> 16 ) + (coef/2 - 299)
; 1440 :     const __m128i xC_0x8000 = _mm_slli_epi16(_mm_cmpeq_epi32(x0, x0), 15);

  00033	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  00037	66 0f 76 45 f0	 pcmpeqd xmm0, XMMWORD PTR _x0$[ebp]
  0003c	0f 29 45 d0	 movaps	 XMMWORD PTR $T7[ebp], xmm0
  00040	0f 28 45 d0	 movaps	 xmm0, XMMWORD PTR $T7[ebp]
  00044	66 0f 71 f0 0f	 psllw	 xmm0, 15		; 0000000fH
  00049	0f 29 45 c0	 movaps	 XMMWORD PTR $T6[ebp], xmm0
  0004d	0f 28 45 c0	 movaps	 xmm0, XMMWORD PTR $T6[ebp]
  00051	0f 29 45 e0	 movaps	 XMMWORD PTR _xC_0x8000$[ebp], xmm0

; 1441 :     x0 = _mm_add_epi16(x0, xC_0x8000); // -32768

  00055	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  00059	66 0f fd 45 e0	 paddw	 xmm0, XMMWORD PTR _xC_0x8000$[ebp]
  0005e	0f 29 45 b0	 movaps	 XMMWORD PTR $T5[ebp], xmm0
  00062	0f 28 45 b0	 movaps	 xmm0, XMMWORD PTR $T5[ebp]
  00066	0f 29 45 f0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1442 :     x0 = _mm_mulhi_epi16(x0, _mm_set1_epi16(4788));

  0006a	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@12b412b412b412b412b412b412b412b4
  00071	0f 29 45 a0	 movaps	 XMMWORD PTR $T4[ebp], xmm0
  00075	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  00079	66 0f e5 45 a0	 pmulhw	 xmm0, XMMWORD PTR $T4[ebp]
  0007e	0f 29 45 90	 movaps	 XMMWORD PTR $T3[ebp], xmm0
  00082	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR $T3[ebp]
  00086	0f 29 45 f0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1443 :     x0 = _mm_adds_epi16(x0, _mm_set1_epi16(4788/2 - 299));

  0008a	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@082f082f082f082f082f082f082f082f
  00091	0f 29 45 80	 movaps	 XMMWORD PTR $T2[ebp], xmm0
  00095	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  00099	66 0f ed 45 80	 paddsw	 xmm0, XMMWORD PTR $T2[ebp]
  0009e	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR $T1[ebp], xmm0
  000a5	0f 28 85 70 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T1[ebp]
  000ac	0f 29 45 f0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1444 :     return x0;

  000b0	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]

; 1445 : }

  000b4	5f		 pop	 edi
  000b5	8b e5		 mov	 esp, ebp
  000b7	5d		 pop	 ebp
  000b8	8b e3		 mov	 esp, ebx
  000ba	5b		 pop	 ebx
  000bb	c3		 ret	 0
?convert_y_range_to_yc48@@YA?AT__m128i@@T1@@Z ENDP	; convert_y_range_to_yc48
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -368						; size = 16
$T2 = -352						; size = 16
$T3 = -336						; size = 16
$T4 = -320						; size = 16
$T5 = -304						; size = 16
$T6 = -288						; size = 16
$T7 = -272						; size = 16
$T8 = -256						; size = 16
$T9 = -240						; size = 16
$T10 = -224						; size = 16
$T11 = -208						; size = 16
$T12 = -192						; size = 16
$T13 = -176						; size = 16
$T14 = -160						; size = 16
$T15 = -144						; size = 16
$T16 = -128						; size = 16
$T17 = -112						; size = 16
_x7$ = -96						; size = 16
_x6$ = -80						; size = 16
_x3$ = -64						; size = 16
_x2$ = -48						; size = 16
_x1$ = -32						; size = 16
_x0$ = -16						; size = 16
_xC_UV_OFFSET_x1$ = 8					; size = 4
_xC_UV_MA_16_0$ = 12					; size = 4
_xC_UV_MA_16_1$ = 16					; size = 4
_UV_RSH_16$ = 20					; size = 4
_xC_YCC$ = 24						; size = 4
_xC_pw_one$ = 28					; size = 4
?convert_uv_range_from_yc48_420i@@YA?AT__m128i@@T1@0ABT1@11H11@Z PROC ; convert_uv_range_from_yc48_420i
; _x0$ = xmm0
; _x1$ = xmm1

; 1411 : static __forceinline __m128i convert_uv_range_from_yc48_420i(__m128i x0, __m128i x1, const __m128i& xC_UV_OFFSET_x1, const __m128i& xC_UV_MA_16_0, const __m128i& xC_UV_MA_16_1, int UV_RSH_16, const __m128i& xC_YCC, const __m128i& xC_pw_one) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 70 01 00
	00		 sub	 esp, 368		; 00000170H
  0001c	57		 push	 edi
  0001d	8d bd 90 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-368]
  00023	b9 5c 00 00 00	 mov	 ecx, 92			; 0000005cH
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	0f 29 4d e0	 movaps	 XMMWORD PTR _x1$[ebp], xmm1
  00033	0f 29 45 f0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1412 :     __m128i x2, x3, x6, x7;
; 1413 :     x0 = _mm_add_epi16(x0, xC_UV_OFFSET_x1);

  00037	8b 43 08	 mov	 eax, DWORD PTR _xC_UV_OFFSET_x1$[ebx]
  0003a	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  0003e	66 0f fd 00	 paddw	 xmm0, XMMWORD PTR [eax]
  00042	0f 29 45 90	 movaps	 XMMWORD PTR $T17[ebp], xmm0
  00046	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR $T17[ebp]
  0004a	0f 29 45 f0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1414 :     x1 = _mm_add_epi16(x1, xC_UV_OFFSET_x1);

  0004e	8b 4b 08	 mov	 ecx, DWORD PTR _xC_UV_OFFSET_x1$[ebx]
  00051	0f 28 45 e0	 movaps	 xmm0, XMMWORD PTR _x1$[ebp]
  00055	66 0f fd 01	 paddw	 xmm0, XMMWORD PTR [ecx]
  00059	0f 29 45 80	 movaps	 XMMWORD PTR $T16[ebp], xmm0
  0005d	0f 28 45 80	 movaps	 xmm0, XMMWORD PTR $T16[ebp]
  00061	0f 29 45 e0	 movaps	 XMMWORD PTR _x1$[ebp], xmm0

; 1415 : 
; 1416 :     x7 = _mm_unpackhi_epi16(x0, xC_pw_one);

  00065	8b 53 1c	 mov	 edx, DWORD PTR _xC_pw_one$[ebx]
  00068	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  0006c	66 0f 69 02	 punpckhwd xmm0, XMMWORD PTR [edx]
  00070	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR $T15[ebp], xmm0
  00077	0f 28 85 70 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T15[ebp]
  0007e	0f 29 45 a0	 movaps	 XMMWORD PTR _x7$[ebp], xmm0

; 1417 :     x6 = _mm_unpacklo_epi16(x0, xC_pw_one);

  00082	8b 43 1c	 mov	 eax, DWORD PTR _xC_pw_one$[ebx]
  00085	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  00089	66 0f 61 00	 punpcklwd xmm0, XMMWORD PTR [eax]
  0008d	0f 29 85 60 ff
	ff ff		 movaps	 XMMWORD PTR $T14[ebp], xmm0
  00094	0f 28 85 60 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T14[ebp]
  0009b	0f 29 45 b0	 movaps	 XMMWORD PTR _x6$[ebp], xmm0

; 1418 :     x3 = _mm_unpackhi_epi16(x1, xC_pw_one);

  0009f	8b 4b 1c	 mov	 ecx, DWORD PTR _xC_pw_one$[ebx]
  000a2	0f 28 45 e0	 movaps	 xmm0, XMMWORD PTR _x1$[ebp]
  000a6	66 0f 69 01	 punpckhwd xmm0, XMMWORD PTR [ecx]
  000aa	0f 29 85 50 ff
	ff ff		 movaps	 XMMWORD PTR $T13[ebp], xmm0
  000b1	0f 28 85 50 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T13[ebp]
  000b8	0f 29 45 c0	 movaps	 XMMWORD PTR _x3$[ebp], xmm0

; 1419 :     x2 = _mm_unpacklo_epi16(x1, xC_pw_one);

  000bc	8b 53 1c	 mov	 edx, DWORD PTR _xC_pw_one$[ebx]
  000bf	0f 28 45 e0	 movaps	 xmm0, XMMWORD PTR _x1$[ebp]
  000c3	66 0f 61 02	 punpcklwd xmm0, XMMWORD PTR [edx]
  000c7	0f 29 85 40 ff
	ff ff		 movaps	 XMMWORD PTR $T12[ebp], xmm0
  000ce	0f 28 85 40 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T12[ebp]
  000d5	0f 29 45 d0	 movaps	 XMMWORD PTR _x2$[ebp], xmm0

; 1420 : 
; 1421 :     x6 = _mm_madd_epi16(x6, xC_UV_MA_16_0);

  000d9	8b 43 0c	 mov	 eax, DWORD PTR _xC_UV_MA_16_0$[ebx]
  000dc	0f 28 45 b0	 movaps	 xmm0, XMMWORD PTR _x6$[ebp]
  000e0	66 0f f5 00	 pmaddwd xmm0, XMMWORD PTR [eax]
  000e4	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR $T11[ebp], xmm0
  000eb	0f 28 85 30 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T11[ebp]
  000f2	0f 29 45 b0	 movaps	 XMMWORD PTR _x6$[ebp], xmm0

; 1422 :     x7 = _mm_madd_epi16(x7, xC_UV_MA_16_0);

  000f6	8b 4b 0c	 mov	 ecx, DWORD PTR _xC_UV_MA_16_0$[ebx]
  000f9	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _x7$[ebp]
  000fd	66 0f f5 01	 pmaddwd xmm0, XMMWORD PTR [ecx]
  00101	0f 29 85 20 ff
	ff ff		 movaps	 XMMWORD PTR $T10[ebp], xmm0
  00108	0f 28 85 20 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T10[ebp]
  0010f	0f 29 45 a0	 movaps	 XMMWORD PTR _x7$[ebp], xmm0

; 1423 :     x2 = _mm_madd_epi16(x2, xC_UV_MA_16_1);

  00113	8b 53 10	 mov	 edx, DWORD PTR _xC_UV_MA_16_1$[ebx]
  00116	0f 28 45 d0	 movaps	 xmm0, XMMWORD PTR _x2$[ebp]
  0011a	66 0f f5 02	 pmaddwd xmm0, XMMWORD PTR [edx]
  0011e	0f 29 85 10 ff
	ff ff		 movaps	 XMMWORD PTR $T9[ebp], xmm0
  00125	0f 28 85 10 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T9[ebp]
  0012c	0f 29 45 d0	 movaps	 XMMWORD PTR _x2$[ebp], xmm0

; 1424 :     x3 = _mm_madd_epi16(x3, xC_UV_MA_16_1);

  00130	8b 43 10	 mov	 eax, DWORD PTR _xC_UV_MA_16_1$[ebx]
  00133	0f 28 45 c0	 movaps	 xmm0, XMMWORD PTR _x3$[ebp]
  00137	66 0f f5 00	 pmaddwd xmm0, XMMWORD PTR [eax]
  0013b	0f 29 85 00 ff
	ff ff		 movaps	 XMMWORD PTR $T8[ebp], xmm0
  00142	0f 28 85 00 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T8[ebp]
  00149	0f 29 45 c0	 movaps	 XMMWORD PTR _x3$[ebp], xmm0

; 1425 :     x0 = _mm_add_epi32(x6, x2);

  0014d	0f 28 45 b0	 movaps	 xmm0, XMMWORD PTR _x6$[ebp]
  00151	66 0f fe 45 d0	 paddd	 xmm0, XMMWORD PTR _x2$[ebp]
  00156	0f 29 85 f0 fe
	ff ff		 movaps	 XMMWORD PTR $T7[ebp], xmm0
  0015d	0f 28 85 f0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T7[ebp]
  00164	0f 29 45 f0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1426 :     x7 = _mm_add_epi32(x7, x3);

  00168	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _x7$[ebp]
  0016c	66 0f fe 45 c0	 paddd	 xmm0, XMMWORD PTR _x3$[ebp]
  00171	0f 29 85 e0 fe
	ff ff		 movaps	 XMMWORD PTR $T6[ebp], xmm0
  00178	0f 28 85 e0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T6[ebp]
  0017f	0f 29 45 a0	 movaps	 XMMWORD PTR _x7$[ebp], xmm0

; 1427 :     x0 = _mm_srai_epi32(x0, UV_RSH_16);

  00183	8b 4b 14	 mov	 ecx, DWORD PTR _UV_RSH_16$[ebx]
  00186	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  0018a	66 0f 6e c9	 movd	 xmm1, ecx
  0018e	66 0f e2 c1	 psrad	 xmm0, xmm1
  00192	0f 29 85 d0 fe
	ff ff		 movaps	 XMMWORD PTR $T5[ebp], xmm0
  00199	0f 28 85 d0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T5[ebp]
  001a0	0f 29 45 f0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1428 :     x7 = _mm_srai_epi32(x7, UV_RSH_16);

  001a4	8b 53 14	 mov	 edx, DWORD PTR _UV_RSH_16$[ebx]
  001a7	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _x7$[ebp]
  001ab	66 0f 6e ca	 movd	 xmm1, edx
  001af	66 0f e2 c1	 psrad	 xmm0, xmm1
  001b3	0f 29 85 c0 fe
	ff ff		 movaps	 XMMWORD PTR $T4[ebp], xmm0
  001ba	0f 28 85 c0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T4[ebp]
  001c1	0f 29 45 a0	 movaps	 XMMWORD PTR _x7$[ebp], xmm0

; 1429 :     x0 = _mm_add_epi32(x0, xC_YCC);

  001c5	8b 43 18	 mov	 eax, DWORD PTR _xC_YCC$[ebx]
  001c8	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  001cc	66 0f fe 00	 paddd	 xmm0, XMMWORD PTR [eax]
  001d0	0f 29 85 b0 fe
	ff ff		 movaps	 XMMWORD PTR $T3[ebp], xmm0
  001d7	0f 28 85 b0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T3[ebp]
  001de	0f 29 45 f0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1430 :     x7 = _mm_add_epi32(x7, xC_YCC);

  001e2	8b 4b 18	 mov	 ecx, DWORD PTR _xC_YCC$[ebx]
  001e5	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _x7$[ebp]
  001e9	66 0f fe 01	 paddd	 xmm0, XMMWORD PTR [ecx]
  001ed	0f 29 85 a0 fe
	ff ff		 movaps	 XMMWORD PTR $T2[ebp], xmm0
  001f4	0f 28 85 a0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T2[ebp]
  001fb	0f 29 45 a0	 movaps	 XMMWORD PTR _x7$[ebp], xmm0

; 1431 : 
; 1432 :     x0 = _mm_packus_epi32_simd(x0, x7);

  001ff	0f 28 4d a0	 movaps	 xmm1, XMMWORD PTR _x7$[ebp]
  00203	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  00207	e8 00 00 00 00	 call	 ?_mm_packus_epi32_simd@@YA?AT__m128i@@T1@0@Z ; _mm_packus_epi32_simd
  0020c	0f 29 85 90 fe
	ff ff		 movaps	 XMMWORD PTR $T1[ebp], xmm0
  00213	0f 28 85 90 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T1[ebp]
  0021a	0f 29 45 f0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1433 : 
; 1434 :     return x0;

  0021e	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]

; 1435 : }

  00222	5f		 pop	 edi
  00223	8b e5		 mov	 esp, ebp
  00225	5d		 pop	 ebp
  00226	8b e3		 mov	 esp, ebx
  00228	5b		 pop	 ebx
  00229	c3		 ret	 0
?convert_uv_range_from_yc48_420i@@YA?AT__m128i@@T1@0ABT1@11H11@Z ENDP ; convert_uv_range_from_yc48_420i
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -80						; size = 16
$T2 = -64						; size = 16
$T3 = -48						; size = 16
_x1$ = -32						; size = 16
_x0$ = -16						; size = 16
_xC_UV_OFFSET_x2$ = 8					; size = 4
_xC_UV_MA_16$ = 12					; size = 4
_UV_RSH_16$ = 16					; size = 4
_xC_YCC$ = 20						; size = 4
_xC_pw_one$ = 24					; size = 4
?convert_uv_range_from_yc48_yuv420p@@YA?AT__m128i@@T1@0ABT1@1H11@Z PROC ; convert_uv_range_from_yc48_yuv420p
; _x0$ = xmm0
; _x1$ = xmm1

; 1405 : static __forceinline __m128i convert_uv_range_from_yc48_yuv420p(__m128i x0, __m128i x1, const __m128i& xC_UV_OFFSET_x2, const __m128i& xC_UV_MA_16, int UV_RSH_16, const __m128i& xC_YCC, const __m128i& xC_pw_one) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	83 ec 50	 sub	 esp, 80			; 00000050H
  00019	57		 push	 edi
  0001a	8d 7d b0	 lea	 edi, DWORD PTR [ebp-80]
  0001d	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  00022	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00027	f3 ab		 rep stosd
  00029	0f 29 4d e0	 movaps	 XMMWORD PTR _x1$[ebp], xmm1
  0002d	0f 29 45 f0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1406 :     x0 = _mm_add_epi16(x0, x1);

  00031	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  00035	66 0f fd 45 e0	 paddw	 xmm0, XMMWORD PTR _x1$[ebp]
  0003a	0f 29 45 d0	 movaps	 XMMWORD PTR $T3[ebp], xmm0
  0003e	0f 28 45 d0	 movaps	 xmm0, XMMWORD PTR $T3[ebp]
  00042	0f 29 45 f0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1407 :     x0 = _mm_add_epi16(x0, xC_UV_OFFSET_x2);

  00046	8b 43 08	 mov	 eax, DWORD PTR _xC_UV_OFFSET_x2$[ebx]
  00049	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  0004d	66 0f fd 00	 paddw	 xmm0, XMMWORD PTR [eax]
  00051	0f 29 45 c0	 movaps	 XMMWORD PTR $T2[ebp], xmm0
  00055	0f 28 45 c0	 movaps	 xmm0, XMMWORD PTR $T2[ebp]
  00059	0f 29 45 f0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1408 : 
; 1409 :     return convert_uv_range_after_adding_offset(x0, xC_UV_MA_16, UV_RSH_16, xC_YCC, xC_pw_one);

  0005d	8b 4b 18	 mov	 ecx, DWORD PTR _xC_pw_one$[ebx]
  00060	51		 push	 ecx
  00061	8b 53 14	 mov	 edx, DWORD PTR _xC_YCC$[ebx]
  00064	52		 push	 edx
  00065	8b 43 10	 mov	 eax, DWORD PTR _UV_RSH_16$[ebx]
  00068	50		 push	 eax
  00069	8b 4b 0c	 mov	 ecx, DWORD PTR _xC_UV_MA_16$[ebx]
  0006c	51		 push	 ecx
  0006d	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  00071	e8 00 00 00 00	 call	 ?convert_uv_range_after_adding_offset@@YA?AT__m128i@@T1@ABT1@H11@Z ; convert_uv_range_after_adding_offset
  00076	83 c4 10	 add	 esp, 16			; 00000010H
  00079	0f 29 45 b0	 movaps	 XMMWORD PTR $T1[ebp], xmm0
  0007d	0f 28 45 b0	 movaps	 xmm0, XMMWORD PTR $T1[ebp]

; 1410 : }

  00081	5f		 pop	 edi
  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	8b e3		 mov	 esp, ebx
  00087	5b		 pop	 ebx
  00088	c3		 ret	 0
?convert_uv_range_from_yc48_yuv420p@@YA?AT__m128i@@T1@0ABT1@1H11@Z ENDP ; convert_uv_range_from_yc48_yuv420p
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -96						; size = 16
$T2 = -80						; size = 16
_xC_YCC$ = -48						; size = 16
_x0$ = -16						; size = 16
_xC_UV_OFFSET_x1$ = 8					; size = 4
_xC_UV_MA_16$ = 12					; size = 4
_UV_RSH_16$ = 16					; size = 4
_xC_pw_one$ = 20					; size = 4
?convert_uv_range_from_yc48@@YA?AT__m128i@@T1@ABT1@1H01@Z PROC ; convert_uv_range_from_yc48
; _x0$ = xmm0
; _xC_YCC$ = xmm1

; 1400 : static __forceinline __m128i convert_uv_range_from_yc48(__m128i x0, const __m128i& xC_UV_OFFSET_x1, const __m128i& xC_UV_MA_16, int UV_RSH_16, __m128i xC_YCC, const __m128i& xC_pw_one) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	83 ec 60	 sub	 esp, 96			; 00000060H
  00019	57		 push	 edi
  0001a	8d 7d a0	 lea	 edi, DWORD PTR [ebp-96]
  0001d	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  00022	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00027	f3 ab		 rep stosd
  00029	0f 29 4d d0	 movaps	 XMMWORD PTR _xC_YCC$[ebp], xmm1
  0002d	0f 29 45 f0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1401 :     x0 = _mm_add_epi16(x0, xC_UV_OFFSET_x1);

  00031	8b 43 08	 mov	 eax, DWORD PTR _xC_UV_OFFSET_x1$[ebx]
  00034	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  00038	66 0f fd 00	 paddw	 xmm0, XMMWORD PTR [eax]
  0003c	0f 29 45 b0	 movaps	 XMMWORD PTR $T2[ebp], xmm0
  00040	0f 28 45 b0	 movaps	 xmm0, XMMWORD PTR $T2[ebp]
  00044	0f 29 45 f0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1402 : 
; 1403 :     return convert_uv_range_after_adding_offset(x0, xC_UV_MA_16, UV_RSH_16, xC_YCC, xC_pw_one);

  00048	8b 4b 14	 mov	 ecx, DWORD PTR _xC_pw_one$[ebx]
  0004b	51		 push	 ecx
  0004c	8d 55 d0	 lea	 edx, DWORD PTR _xC_YCC$[ebp]
  0004f	52		 push	 edx
  00050	8b 43 10	 mov	 eax, DWORD PTR _UV_RSH_16$[ebx]
  00053	50		 push	 eax
  00054	8b 4b 0c	 mov	 ecx, DWORD PTR _xC_UV_MA_16$[ebx]
  00057	51		 push	 ecx
  00058	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  0005c	e8 00 00 00 00	 call	 ?convert_uv_range_after_adding_offset@@YA?AT__m128i@@T1@ABT1@H11@Z ; convert_uv_range_after_adding_offset
  00061	83 c4 10	 add	 esp, 16			; 00000010H
  00064	0f 29 45 a0	 movaps	 XMMWORD PTR $T1[ebp], xmm0
  00068	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR $T1[ebp]

; 1404 : }

  0006c	52		 push	 edx
  0006d	8b cd		 mov	 ecx, ebp
  0006f	50		 push	 eax
  00070	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@convert_uv
  00076	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0007b	58		 pop	 eax
  0007c	5a		 pop	 edx
  0007d	5f		 pop	 edi
  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	8b e3		 mov	 esp, ebx
  00083	5b		 pop	 ebx
  00084	c3		 ret	 0
  00085	0f 1f 00	 npad	 3
$LN5@convert_uv:
  00088	01 00 00 00	 DD	 1
  0008c	00 00 00 00	 DD	 $LN4@convert_uv
$LN4@convert_uv:
  00090	d0 ff ff ff	 DD	 -48			; ffffffd0H
  00094	10 00 00 00	 DD	 16			; 00000010H
  00098	00 00 00 00	 DD	 $LN3@convert_uv
$LN3@convert_uv:
  0009c	78		 DB	 120			; 00000078H
  0009d	43		 DB	 67			; 00000043H
  0009e	5f		 DB	 95			; 0000005fH
  0009f	59		 DB	 89			; 00000059H
  000a0	43		 DB	 67			; 00000043H
  000a1	43		 DB	 67			; 00000043H
  000a2	00		 DB	 0
?convert_uv_range_from_yc48@@YA?AT__m128i@@T1@ABT1@1H01@Z ENDP ; convert_uv_range_from_yc48
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -176						; size = 16
$T2 = -160						; size = 16
$T3 = -144						; size = 16
$T4 = -128						; size = 16
$T5 = -112						; size = 16
$T6 = -96						; size = 16
$T7 = -80						; size = 16
$T8 = -64						; size = 16
$T9 = -48						; size = 16
_x1$ = -32						; size = 16
_x0$ = -16						; size = 16
_xC_UV_MA_16$ = 8					; size = 4
_UV_RSH_16$ = 12					; size = 4
_xC_YCC$ = 16						; size = 4
_xC_pw_one$ = 20					; size = 4
?convert_uv_range_after_adding_offset@@YA?AT__m128i@@T1@ABT1@H11@Z PROC ; convert_uv_range_after_adding_offset
; _x0$ = xmm0

; 1383 : static __forceinline __m128i convert_uv_range_after_adding_offset(__m128i x0, const __m128i& xC_UV_MA_16, int UV_RSH_16, const __m128i& xC_YCC, const __m128i& xC_pw_one) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec b0 00 00
	00		 sub	 esp, 176		; 000000b0H
  0001c	57		 push	 edi
  0001d	8d bd 50 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-176]
  00023	b9 2c 00 00 00	 mov	 ecx, 44			; 0000002cH
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	0f 29 45 f0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1384 :     __m128i x1;
; 1385 :     x1 = _mm_unpackhi_epi16(x0, xC_pw_one);

  00033	8b 43 14	 mov	 eax, DWORD PTR _xC_pw_one$[ebx]
  00036	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  0003a	66 0f 69 00	 punpckhwd xmm0, XMMWORD PTR [eax]
  0003e	0f 29 45 d0	 movaps	 XMMWORD PTR $T9[ebp], xmm0
  00042	0f 28 45 d0	 movaps	 xmm0, XMMWORD PTR $T9[ebp]
  00046	0f 29 45 e0	 movaps	 XMMWORD PTR _x1$[ebp], xmm0

; 1386 :     x0 = _mm_unpacklo_epi16(x0, xC_pw_one);

  0004a	8b 4b 14	 mov	 ecx, DWORD PTR _xC_pw_one$[ebx]
  0004d	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  00051	66 0f 61 01	 punpcklwd xmm0, XMMWORD PTR [ecx]
  00055	0f 29 45 c0	 movaps	 XMMWORD PTR $T8[ebp], xmm0
  00059	0f 28 45 c0	 movaps	 xmm0, XMMWORD PTR $T8[ebp]
  0005d	0f 29 45 f0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1387 : 
; 1388 :     x0 = _mm_madd_epi16(x0, xC_UV_MA_16);

  00061	8b 53 08	 mov	 edx, DWORD PTR _xC_UV_MA_16$[ebx]
  00064	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  00068	66 0f f5 02	 pmaddwd xmm0, XMMWORD PTR [edx]
  0006c	0f 29 45 b0	 movaps	 XMMWORD PTR $T7[ebp], xmm0
  00070	0f 28 45 b0	 movaps	 xmm0, XMMWORD PTR $T7[ebp]
  00074	0f 29 45 f0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1389 :     x1 = _mm_madd_epi16(x1, xC_UV_MA_16);

  00078	8b 43 08	 mov	 eax, DWORD PTR _xC_UV_MA_16$[ebx]
  0007b	0f 28 45 e0	 movaps	 xmm0, XMMWORD PTR _x1$[ebp]
  0007f	66 0f f5 00	 pmaddwd xmm0, XMMWORD PTR [eax]
  00083	0f 29 45 a0	 movaps	 XMMWORD PTR $T6[ebp], xmm0
  00087	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR $T6[ebp]
  0008b	0f 29 45 e0	 movaps	 XMMWORD PTR _x1$[ebp], xmm0

; 1390 :     x0 = _mm_srai_epi32(x0, UV_RSH_16);

  0008f	8b 4b 0c	 mov	 ecx, DWORD PTR _UV_RSH_16$[ebx]
  00092	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  00096	66 0f 6e c9	 movd	 xmm1, ecx
  0009a	66 0f e2 c1	 psrad	 xmm0, xmm1
  0009e	0f 29 45 90	 movaps	 XMMWORD PTR $T5[ebp], xmm0
  000a2	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR $T5[ebp]
  000a6	0f 29 45 f0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1391 :     x1 = _mm_srai_epi32(x1, UV_RSH_16);

  000aa	8b 53 0c	 mov	 edx, DWORD PTR _UV_RSH_16$[ebx]
  000ad	0f 28 45 e0	 movaps	 xmm0, XMMWORD PTR _x1$[ebp]
  000b1	66 0f 6e ca	 movd	 xmm1, edx
  000b5	66 0f e2 c1	 psrad	 xmm0, xmm1
  000b9	0f 29 45 80	 movaps	 XMMWORD PTR $T4[ebp], xmm0
  000bd	0f 28 45 80	 movaps	 xmm0, XMMWORD PTR $T4[ebp]
  000c1	0f 29 45 e0	 movaps	 XMMWORD PTR _x1$[ebp], xmm0

; 1392 :     x0 = _mm_add_epi32(x0, xC_YCC);

  000c5	8b 43 10	 mov	 eax, DWORD PTR _xC_YCC$[ebx]
  000c8	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  000cc	66 0f fe 00	 paddd	 xmm0, XMMWORD PTR [eax]
  000d0	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR $T3[ebp], xmm0
  000d7	0f 28 85 70 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T3[ebp]
  000de	0f 29 45 f0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1393 :     x1 = _mm_add_epi32(x1, xC_YCC);

  000e2	8b 4b 10	 mov	 ecx, DWORD PTR _xC_YCC$[ebx]
  000e5	0f 28 45 e0	 movaps	 xmm0, XMMWORD PTR _x1$[ebp]
  000e9	66 0f fe 01	 paddd	 xmm0, XMMWORD PTR [ecx]
  000ed	0f 29 85 60 ff
	ff ff		 movaps	 XMMWORD PTR $T2[ebp], xmm0
  000f4	0f 28 85 60 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T2[ebp]
  000fb	0f 29 45 e0	 movaps	 XMMWORD PTR _x1$[ebp], xmm0

; 1394 : 
; 1395 :     x0 = _mm_packus_epi32_simd(x0, x1);

  000ff	0f 28 4d e0	 movaps	 xmm1, XMMWORD PTR _x1$[ebp]
  00103	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  00107	e8 00 00 00 00	 call	 ?_mm_packus_epi32_simd@@YA?AT__m128i@@T1@0@Z ; _mm_packus_epi32_simd
  0010c	0f 29 85 50 ff
	ff ff		 movaps	 XMMWORD PTR $T1[ebp], xmm0
  00113	0f 28 85 50 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T1[ebp]
  0011a	0f 29 45 f0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1396 : 
; 1397 :     return x0;

  0011e	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]

; 1398 : }

  00122	5f		 pop	 edi
  00123	8b e5		 mov	 esp, ebp
  00125	5d		 pop	 ebp
  00126	8b e3		 mov	 esp, ebx
  00128	5b		 pop	 ebx
  00129	c3		 ret	 0
?convert_uv_range_after_adding_offset@@YA?AT__m128i@@T1@ABT1@H11@Z ENDP ; convert_uv_range_after_adding_offset
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -176						; size = 16
$T2 = -160						; size = 16
$T3 = -144						; size = 16
$T4 = -128						; size = 16
$T5 = -112						; size = 16
$T6 = -96						; size = 16
$T7 = -80						; size = 16
$T8 = -64						; size = 16
$T9 = -48						; size = 16
_x7$ = -32						; size = 16
_x0$ = -16						; size = 16
_xC_Y_MA_16$ = 8					; size = 4
_Y_RSH_16$ = 12						; size = 4
_xC_YCC$ = 16						; size = 4
_xC_pw_one$ = 20					; size = 4
?convert_y_range_from_yc48@@YA?AT__m128i@@T1@ABT1@H11@Z PROC ; convert_y_range_from_yc48
; _x0$ = xmm0

; 1366 : static __forceinline __m128i convert_y_range_from_yc48(__m128i x0, const __m128i& xC_Y_MA_16, int Y_RSH_16, const __m128i& xC_YCC, const __m128i& xC_pw_one) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec b0 00 00
	00		 sub	 esp, 176		; 000000b0H
  0001c	57		 push	 edi
  0001d	8d bd 50 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-176]
  00023	b9 2c 00 00 00	 mov	 ecx, 44			; 0000002cH
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	0f 29 45 f0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1367 :     __m128i x7;
; 1368 :     x7 = _mm_unpackhi_epi16(x0, xC_pw_one);

  00033	8b 43 14	 mov	 eax, DWORD PTR _xC_pw_one$[ebx]
  00036	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  0003a	66 0f 69 00	 punpckhwd xmm0, XMMWORD PTR [eax]
  0003e	0f 29 45 d0	 movaps	 XMMWORD PTR $T9[ebp], xmm0
  00042	0f 28 45 d0	 movaps	 xmm0, XMMWORD PTR $T9[ebp]
  00046	0f 29 45 e0	 movaps	 XMMWORD PTR _x7$[ebp], xmm0

; 1369 :     x0 = _mm_unpacklo_epi16(x0, xC_pw_one);

  0004a	8b 4b 14	 mov	 ecx, DWORD PTR _xC_pw_one$[ebx]
  0004d	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  00051	66 0f 61 01	 punpcklwd xmm0, XMMWORD PTR [ecx]
  00055	0f 29 45 c0	 movaps	 XMMWORD PTR $T8[ebp], xmm0
  00059	0f 28 45 c0	 movaps	 xmm0, XMMWORD PTR $T8[ebp]
  0005d	0f 29 45 f0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1370 : 
; 1371 :     x0 = _mm_madd_epi16(x0, xC_Y_MA_16);

  00061	8b 53 08	 mov	 edx, DWORD PTR _xC_Y_MA_16$[ebx]
  00064	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  00068	66 0f f5 02	 pmaddwd xmm0, XMMWORD PTR [edx]
  0006c	0f 29 45 b0	 movaps	 XMMWORD PTR $T7[ebp], xmm0
  00070	0f 28 45 b0	 movaps	 xmm0, XMMWORD PTR $T7[ebp]
  00074	0f 29 45 f0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1372 :     x7 = _mm_madd_epi16(x7, xC_Y_MA_16);

  00078	8b 43 08	 mov	 eax, DWORD PTR _xC_Y_MA_16$[ebx]
  0007b	0f 28 45 e0	 movaps	 xmm0, XMMWORD PTR _x7$[ebp]
  0007f	66 0f f5 00	 pmaddwd xmm0, XMMWORD PTR [eax]
  00083	0f 29 45 a0	 movaps	 XMMWORD PTR $T6[ebp], xmm0
  00087	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR $T6[ebp]
  0008b	0f 29 45 e0	 movaps	 XMMWORD PTR _x7$[ebp], xmm0

; 1373 :     x0 = _mm_srai_epi32(x0, Y_RSH_16);

  0008f	8b 4b 0c	 mov	 ecx, DWORD PTR _Y_RSH_16$[ebx]
  00092	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  00096	66 0f 6e c9	 movd	 xmm1, ecx
  0009a	66 0f e2 c1	 psrad	 xmm0, xmm1
  0009e	0f 29 45 90	 movaps	 XMMWORD PTR $T5[ebp], xmm0
  000a2	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR $T5[ebp]
  000a6	0f 29 45 f0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1374 :     x7 = _mm_srai_epi32(x7, Y_RSH_16);

  000aa	8b 53 0c	 mov	 edx, DWORD PTR _Y_RSH_16$[ebx]
  000ad	0f 28 45 e0	 movaps	 xmm0, XMMWORD PTR _x7$[ebp]
  000b1	66 0f 6e ca	 movd	 xmm1, edx
  000b5	66 0f e2 c1	 psrad	 xmm0, xmm1
  000b9	0f 29 45 80	 movaps	 XMMWORD PTR $T4[ebp], xmm0
  000bd	0f 28 45 80	 movaps	 xmm0, XMMWORD PTR $T4[ebp]
  000c1	0f 29 45 e0	 movaps	 XMMWORD PTR _x7$[ebp], xmm0

; 1375 :     x0 = _mm_add_epi32(x0, xC_YCC);

  000c5	8b 43 10	 mov	 eax, DWORD PTR _xC_YCC$[ebx]
  000c8	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  000cc	66 0f fe 00	 paddd	 xmm0, XMMWORD PTR [eax]
  000d0	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR $T3[ebp], xmm0
  000d7	0f 28 85 70 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T3[ebp]
  000de	0f 29 45 f0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1376 :     x7 = _mm_add_epi32(x7, xC_YCC);

  000e2	8b 4b 10	 mov	 ecx, DWORD PTR _xC_YCC$[ebx]
  000e5	0f 28 45 e0	 movaps	 xmm0, XMMWORD PTR _x7$[ebp]
  000e9	66 0f fe 01	 paddd	 xmm0, XMMWORD PTR [ecx]
  000ed	0f 29 85 60 ff
	ff ff		 movaps	 XMMWORD PTR $T2[ebp], xmm0
  000f4	0f 28 85 60 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T2[ebp]
  000fb	0f 29 45 e0	 movaps	 XMMWORD PTR _x7$[ebp], xmm0

; 1377 : 
; 1378 :     x0 = _mm_packus_epi32_simd(x0, x7);

  000ff	0f 28 4d e0	 movaps	 xmm1, XMMWORD PTR _x7$[ebp]
  00103	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  00107	e8 00 00 00 00	 call	 ?_mm_packus_epi32_simd@@YA?AT__m128i@@T1@0@Z ; _mm_packus_epi32_simd
  0010c	0f 29 85 50 ff
	ff ff		 movaps	 XMMWORD PTR $T1[ebp], xmm0
  00113	0f 28 85 50 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T1[ebp]
  0011a	0f 29 45 f0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 1379 : 
; 1380 :     return x0;

  0011e	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]

; 1381 : }

  00122	5f		 pop	 edi
  00123	8b e5		 mov	 esp, ebp
  00125	5d		 pop	 ebp
  00126	8b e3		 mov	 esp, ebx
  00128	5b		 pop	 ebx
  00129	c3		 ret	 0
?convert_y_range_from_yc48@@YA?AT__m128i@@T1@ABT1@H11@Z ENDP ; convert_y_range_from_yc48
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -176						; size = 16
$T2 = -160						; size = 16
$T3 = -144						; size = 16
$T4 = -128						; size = 16
$T5 = -112						; size = 16
$T6 = -96						; size = 16
$T7 = -80						; size = 16
$T8 = -64						; size = 16
_MASK_INT_UV$ = -40					; size = 4
_MASK_INT_Y$ = -36					; size = 4
_x3$ = -32						; size = 16
_x2$ = -16						; size = 16
_x0$ = 8						; size = 4
_x1$ = 12						; size = 4
?gather_y_uv_from_yc48@@YAXAAT__m128i@@0T1@@Z PROC	; gather_y_uv_from_yc48
; _x2$ = xmm0

; 1331 : static __forceinline void gather_y_uv_from_yc48(__m128i& x0, __m128i& x1, __m128i x2) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec b0 00 00
	00		 sub	 esp, 176		; 000000b0H
  0001c	57		 push	 edi
  0001d	8d bd 50 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-176]
  00023	b9 2c 00 00 00	 mov	 ecx, 44			; 0000002cH
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	0f 29 45 f0	 movaps	 XMMWORD PTR _x2$[ebp], xmm0

; 1332 : #if USE_SSE41
; 1333 :     __m128i x3;
; 1334 :     const int MASK_INT_Y  = 0x80 + 0x10 + 0x02;

  00033	c7 45 dc 92 00
	00 00		 mov	 DWORD PTR _MASK_INT_Y$[ebp], 146 ; 00000092H

; 1335 :     const int MASK_INT_UV = 0x40 + 0x20 + 0x01;

  0003a	c7 45 d8 61 00
	00 00		 mov	 DWORD PTR _MASK_INT_UV$[ebp], 97 ; 00000061H

; 1336 :     x3 = _mm_blend_epi16(x0, x1, MASK_INT_Y);

  00041	8b 43 0c	 mov	 eax, DWORD PTR _x1$[ebx]
  00044	8b 4b 08	 mov	 ecx, DWORD PTR _x0$[ebx]
  00047	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  0004a	66 0f 3a 0e 00
	92		 pblendw xmm0, XMMWORD PTR [eax], 146 ; 00000092H
  00050	0f 29 45 c0	 movaps	 XMMWORD PTR $T8[ebp], xmm0
  00054	0f 28 45 c0	 movaps	 xmm0, XMMWORD PTR $T8[ebp]
  00058	0f 29 45 e0	 movaps	 XMMWORD PTR _x3$[ebp], xmm0

; 1337 :     x3 = _mm_blend_epi16(x3, x2, MASK_INT_Y>>2);

  0005c	0f 28 45 e0	 movaps	 xmm0, XMMWORD PTR _x3$[ebp]
  00060	66 0f 3a 0e 45
	f0 24		 pblendw xmm0, XMMWORD PTR _x2$[ebp], 36 ; 00000024H
  00067	0f 29 45 b0	 movaps	 XMMWORD PTR $T7[ebp], xmm0
  0006b	0f 28 45 b0	 movaps	 xmm0, XMMWORD PTR $T7[ebp]
  0006f	0f 29 45 e0	 movaps	 XMMWORD PTR _x3$[ebp], xmm0

; 1338 : 
; 1339 :     x1 = _mm_blend_epi16(x0, x1, MASK_INT_UV);

  00073	8b 53 0c	 mov	 edx, DWORD PTR _x1$[ebx]
  00076	8b 43 08	 mov	 eax, DWORD PTR _x0$[ebx]
  00079	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  0007c	66 0f 3a 0e 02
	61		 pblendw xmm0, XMMWORD PTR [edx], 97 ; 00000061H
  00082	0f 29 45 a0	 movaps	 XMMWORD PTR $T6[ebp], xmm0
  00086	8b 4b 0c	 mov	 ecx, DWORD PTR _x1$[ebx]
  00089	0f 10 45 a0	 movups	 xmm0, XMMWORD PTR $T6[ebp]
  0008d	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 1340 :     x1 = _mm_blend_epi16(x1, x2, MASK_INT_UV>>2);

  00090	8b 53 0c	 mov	 edx, DWORD PTR _x1$[ebx]
  00093	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  00096	66 0f 3a 0e 45
	f0 18		 pblendw xmm0, XMMWORD PTR _x2$[ebp], 24 ; 00000018H
  0009d	0f 29 45 90	 movaps	 XMMWORD PTR $T5[ebp], xmm0
  000a1	8b 43 0c	 mov	 eax, DWORD PTR _x1$[ebx]
  000a4	0f 10 45 90	 movups	 xmm0, XMMWORD PTR $T5[ebp]
  000a8	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 1341 :     x1 = _mm_alignr_epi8_simd(x1, x1, 2);

  000ab	8b 4b 0c	 mov	 ecx, DWORD PTR _x1$[ebx]
  000ae	8b 53 0c	 mov	 edx, DWORD PTR _x1$[ebx]
  000b1	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  000b4	66 0f 3a 0f 01
	02		 palignr xmm0, XMMWORD PTR [ecx], 2
  000ba	0f 29 45 80	 movaps	 XMMWORD PTR $T4[ebp], xmm0
  000be	8b 43 0c	 mov	 eax, DWORD PTR _x1$[ebx]
  000c1	0f 10 45 80	 movups	 xmm0, XMMWORD PTR $T4[ebp]
  000c5	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 1342 :     x1 = _mm_shuffle_epi32(x1, _MM_SHUFFLE(1,2,3,0));//UV1

  000c8	8b 4b 0c	 mov	 ecx, DWORD PTR _x1$[ebx]
  000cb	66 0f 70 01 6c	 pshufd	 xmm0, XMMWORD PTR [ecx], 108 ; 0000006cH
  000d0	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR $T3[ebp], xmm0
  000d7	8b 53 0c	 mov	 edx, DWORD PTR _x1$[ebx]
  000da	0f 10 85 70 ff
	ff ff		 movups	 xmm0, XMMWORD PTR $T3[ebp]
  000e1	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 1343 : 
; 1344 :     x0 = _mm_shuffle_epi8(x3, xC_SUFFLE_YCP_Y);

  000e4	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR ?Array_SUFFLE_YCP_Y@@3QBEB
  000eb	0f 29 85 60 ff
	ff ff		 movaps	 XMMWORD PTR $T2[ebp], xmm0
  000f2	0f 28 45 e0	 movaps	 xmm0, XMMWORD PTR _x3$[ebp]
  000f6	66 0f 38 00 85
	60 ff ff ff	 pshufb	 xmm0, XMMWORD PTR $T2[ebp]
  000ff	0f 29 85 50 ff
	ff ff		 movaps	 XMMWORD PTR $T1[ebp], xmm0
  00106	8b 43 08	 mov	 eax, DWORD PTR _x0$[ebx]
  00109	0f 10 85 50 ff
	ff ff		 movups	 xmm0, XMMWORD PTR $T1[ebp]
  00110	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 1345 : #else
; 1346 :     __m128i x3;
; 1347 :     x3 = select_by_mask(x0, x1, xC_MASK_YCP2Y(0));
; 1348 :     x3 = select_by_mask(x3, x2, xC_MASK_YCP2Y(1));
; 1349 : 
; 1350 :     x1 = select_by_mask(x0, x1, xC_MASK_YCP2UV(0));
; 1351 :     x1 = select_by_mask(x1, x2, xC_MASK_YCP2UV(1));
; 1352 :     x1 = _mm_alignr_epi8_simd(x1, x1, 2);
; 1353 :     x1 = _mm_shuffle_epi32(x1, _MM_SHUFFLE(1,2,3,0));
; 1354 : #if USE_SSSE3
; 1355 :     x0 = _mm_shuffle_epi8(x3, xC_SUFFLE_YCP_Y);
; 1356 : #else
; 1357 :     x0 = _mm_shuffle_epi32(  x3, _MM_SHUFFLE(3,1,2,0));
; 1358 :     x0 = _mm_shufflehi_epi16(x0, _MM_SHUFFLE(1,2,3,0));
; 1359 :     x0 = _mm_shuffle_epi32(  x0, _MM_SHUFFLE(1,2,3,0));
; 1360 :     x0 = _mm_shufflelo_epi16(x0, _MM_SHUFFLE(1,2,3,0));
; 1361 :     x0 = _mm_shufflehi_epi16(x0, _MM_SHUFFLE(3,0,1,2));
; 1362 : #endif //USE_SSSE3
; 1363 : #endif //USE_SSE41
; 1364 : }

  00113	5f		 pop	 edi
  00114	8b e5		 mov	 esp, ebp
  00116	5d		 pop	 ebp
  00117	8b e3		 mov	 esp, ebx
  00119	5b		 pop	 ebx
  0011a	c3		 ret	 0
?gather_y_uv_from_yc48@@YAXAAT__m128i@@0T1@@Z ENDP	; gather_y_uv_from_yc48
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -80						; size = 12
_y$2 = -68						; size = 4
_y_width$ = -64						; size = 4
_dstLine$ = -60						; size = 4
_srcLine$ = -56						; size = 4
$T3 = -52						; size = 12
_y_range$ = -36						; size = 12
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_rgb32r_to_rgb32_simd@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_rgb32r_to_rgb32_simd

; 876  : static void __forceinline convert_rgb32r_to_rgb32_simd(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	57		 push	 edi
  00007	8d 7d b0	 lea	 edi, DWORD PTR [ebp-80]
  0000a	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  0000f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00014	f3 ab		 rep stosd
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 877  :     const int crop_left   = crop[0];

  00020	b8 04 00 00 00	 mov	 eax, 4
  00025	6b c8 00	 imul	 ecx, eax, 0
  00028	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  0002b	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0002e	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 878  :     const int crop_up     = crop[1];

  00031	b9 04 00 00 00	 mov	 ecx, 4
  00036	c1 e1 00	 shl	 ecx, 0
  00039	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  0003c	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0003f	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 879  :     const int crop_right  = crop[2];

  00042	b9 04 00 00 00	 mov	 ecx, 4
  00047	d1 e1		 shl	 ecx, 1
  00049	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  0004c	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0004f	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 880  :     const int crop_bottom = crop[3];

  00052	b9 04 00 00 00	 mov	 ecx, 4
  00057	6b d1 03	 imul	 edx, ecx, 3
  0005a	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  0005d	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00060	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 881  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00063	8b 55 2c	 mov	 edx, DWORD PTR _thread_n$[ebp]
  00066	52		 push	 edx
  00067	8b 45 28	 mov	 eax, DWORD PTR _thread_id$[ebp]
  0006a	50		 push	 eax
  0006b	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  0006e	2b 4d ec	 sub	 ecx, DWORD PTR _crop_bottom$[ebp]
  00071	51		 push	 ecx
  00072	8b 55 f4	 mov	 edx, DWORD PTR _crop_up$[ebp]
  00075	52		 push	 edx
  00076	8d 45 b0	 lea	 eax, DWORD PTR $T1[ebp]
  00079	50		 push	 eax
  0007a	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  0007f	83 c4 14	 add	 esp, 20			; 00000014H
  00082	8b 08		 mov	 ecx, DWORD PTR [eax]
  00084	89 4d cc	 mov	 DWORD PTR $T3[ebp], ecx
  00087	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0008a	89 55 d0	 mov	 DWORD PTR $T3[ebp+4], edx
  0008d	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00090	89 45 d4	 mov	 DWORD PTR $T3[ebp+8], eax
  00093	8b 4d cc	 mov	 ecx, DWORD PTR $T3[ebp]
  00096	89 4d dc	 mov	 DWORD PTR _y_range$[ebp], ecx
  00099	8b 55 d0	 mov	 edx, DWORD PTR $T3[ebp+4]
  0009c	89 55 e0	 mov	 DWORD PTR _y_range$[ebp+4], edx
  0009f	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp+8]
  000a2	89 45 e4	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 882  :     uint8_t *srcLine = (uint8_t *)src[0] + src_y_pitch_byte * (y_range.start_src + y_range.len - 1) + crop_left * 4;

  000a5	b9 04 00 00 00	 mov	 ecx, 4
  000aa	6b d1 00	 imul	 edx, ecx, 0
  000ad	8b 45 e4	 mov	 eax, DWORD PTR _y_range$[ebp+8]
  000b0	8b 4d dc	 mov	 ecx, DWORD PTR _y_range$[ebp]
  000b3	8d 44 01 ff	 lea	 eax, DWORD PTR [ecx+eax-1]
  000b7	0f af 45 14	 imul	 eax, DWORD PTR _src_y_pitch_byte$[ebp]
  000bb	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  000be	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  000c1	03 d0		 add	 edx, eax
  000c3	8b 45 f8	 mov	 eax, DWORD PTR _crop_left$[ebp]
  000c6	8d 0c 82	 lea	 ecx, DWORD PTR [edx+eax*4]
  000c9	89 4d c8	 mov	 DWORD PTR _srcLine$[ebp], ecx

; 883  :     uint8_t *dstLine = (uint8_t *)dst[0] + dst_y_pitch_byte * (height - (y_range.start_dst + y_range.len));

  000cc	ba 04 00 00 00	 mov	 edx, 4
  000d1	6b c2 00	 imul	 eax, edx, 0
  000d4	8b 4d e0	 mov	 ecx, DWORD PTR _y_range$[ebp+4]
  000d7	03 4d e4	 add	 ecx, DWORD PTR _y_range$[ebp+8]
  000da	8b 55 20	 mov	 edx, DWORD PTR _height$[ebp]
  000dd	2b d1		 sub	 edx, ecx
  000df	0f af 55 1c	 imul	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  000e3	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  000e6	03 14 01	 add	 edx, DWORD PTR [ecx+eax]
  000e9	89 55 c4	 mov	 DWORD PTR _dstLine$[ebp], edx

; 884  :     const int y_width = width - crop_right - crop_left;

  000ec	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  000ef	2b 55 f0	 sub	 edx, DWORD PTR _crop_right$[ebp]
  000f2	2b 55 f8	 sub	 edx, DWORD PTR _crop_left$[ebp]
  000f5	89 55 c0	 mov	 DWORD PTR _y_width$[ebp], edx

; 885  :     for (int y = 0; y < y_range.len; y++, dstLine += dst_y_pitch_byte, srcLine -= src_y_pitch_byte) {

  000f8	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _y$2[ebp], 0
  000ff	eb 1b		 jmp	 SHORT $LN4@convert_rg
$LN2@convert_rg:
  00101	8b 45 bc	 mov	 eax, DWORD PTR _y$2[ebp]
  00104	83 c0 01	 add	 eax, 1
  00107	89 45 bc	 mov	 DWORD PTR _y$2[ebp], eax
  0010a	8b 4d c4	 mov	 ecx, DWORD PTR _dstLine$[ebp]
  0010d	03 4d 1c	 add	 ecx, DWORD PTR _dst_y_pitch_byte$[ebp]
  00110	89 4d c4	 mov	 DWORD PTR _dstLine$[ebp], ecx
  00113	8b 55 c8	 mov	 edx, DWORD PTR _srcLine$[ebp]
  00116	2b 55 14	 sub	 edx, DWORD PTR _src_y_pitch_byte$[ebp]
  00119	89 55 c8	 mov	 DWORD PTR _srcLine$[ebp], edx
$LN4@convert_rg:
  0011c	8b 45 bc	 mov	 eax, DWORD PTR _y$2[ebp]
  0011f	3b 45 e4	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  00122	7d 19		 jge	 SHORT $LN1@convert_rg

; 886  :         memcpy_sse(dstLine, srcLine, y_width * 4);

  00124	8b 4d c0	 mov	 ecx, DWORD PTR _y_width$[ebp]
  00127	c1 e1 02	 shl	 ecx, 2
  0012a	51		 push	 ecx
  0012b	8b 55 c8	 mov	 edx, DWORD PTR _srcLine$[ebp]
  0012e	52		 push	 edx
  0012f	8b 45 c4	 mov	 eax, DWORD PTR _dstLine$[ebp]
  00132	50		 push	 eax
  00133	e8 00 00 00 00	 call	 ?memcpy_sse@@YAXPAEPBEH@Z ; memcpy_sse
  00138	83 c4 0c	 add	 esp, 12			; 0000000cH

; 887  :     }

  0013b	eb c4		 jmp	 SHORT $LN2@convert_rg
$LN1@convert_rg:

; 888  : }

  0013d	52		 push	 edx
  0013e	8b cd		 mov	 ecx, ebp
  00140	50		 push	 eax
  00141	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN8@convert_rg
  00147	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0014c	58		 pop	 eax
  0014d	5a		 pop	 edx
  0014e	5f		 pop	 edi
  0014f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00152	33 cd		 xor	 ecx, ebp
  00154	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00159	83 c4 50	 add	 esp, 80			; 00000050H
  0015c	3b ec		 cmp	 ebp, esp
  0015e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00163	8b e5		 mov	 esp, ebp
  00165	5d		 pop	 ebp
  00166	c3		 ret	 0
  00167	90		 npad	 1
$LN8@convert_rg:
  00168	01 00 00 00	 DD	 1
  0016c	00 00 00 00	 DD	 $LN7@convert_rg
$LN7@convert_rg:
  00170	dc ff ff ff	 DD	 -36			; ffffffdcH
  00174	0c 00 00 00	 DD	 12			; 0000000cH
  00178	00 00 00 00	 DD	 $LN6@convert_rg
$LN6@convert_rg:
  0017c	79		 DB	 121			; 00000079H
  0017d	5f		 DB	 95			; 0000005fH
  0017e	72		 DB	 114			; 00000072H
  0017f	61		 DB	 97			; 00000061H
  00180	6e		 DB	 110			; 0000006eH
  00181	67		 DB	 103			; 00000067H
  00182	65		 DB	 101			; 00000065H
  00183	00		 DB	 0
?convert_rgb32r_to_rgb32_simd@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_rgb32r_to_rgb32_simd
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -400						; size = 12
$T2 = -384						; size = 16
$T3 = -368						; size = 16
$T4 = -352						; size = 16
$T5 = -336						; size = 16
$T6 = -320						; size = 16
$T7 = -304						; size = 16
$T8 = -288						; size = 16
_x3$9 = -272						; size = 16
$T10 = -256						; size = 16
_x2$11 = -240						; size = 16
$T12 = -224						; size = 16
_x1$13 = -208						; size = 16
$T14 = -192						; size = 16
_x0$15 = -176						; size = 16
_x_fin$16 = -148					; size = 4
_x$17 = -144						; size = 4
_ptr_dst$18 = -140					; size = 4
_ptr_src$19 = -136					; size = 4
_y$20 = -132						; size = 4
$T21 = -128						; size = 16
_xMask$ = -112						; size = 16
_MASK_RGB3_TO_RGB4$ = -80				; size = 16
_dstLine$ = -60						; size = 4
_srcLine$ = -56						; size = 4
$T22 = -52						; size = 12
_y_range$ = -36						; size = 12
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_rgb24r_to_rgb32_simd@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_rgb24r_to_rgb32_simd

; 429  : static void __forceinline convert_rgb24r_to_rgb32_simd(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 90 01 00
	00		 sub	 esp, 400		; 00000190H
  0001c	57		 push	 edi
  0001d	8d bd 70 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-400]
  00023	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 430  :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 431  :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 432  :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 433  :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 434  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  0007c	8b 53 2c	 mov	 edx, DWORD PTR _thread_n$[ebx]
  0007f	52		 push	 edx
  00080	8b 43 28	 mov	 eax, DWORD PTR _thread_id$[ebx]
  00083	50		 push	 eax
  00084	8b 4b 20	 mov	 ecx, DWORD PTR _height$[ebx]
  00087	2b 4d ec	 sub	 ecx, DWORD PTR _crop_bottom$[ebp]
  0008a	51		 push	 ecx
  0008b	8b 55 f4	 mov	 edx, DWORD PTR _crop_up$[ebp]
  0008e	52		 push	 edx
  0008f	8d 85 70 fe ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  00095	50		 push	 eax
  00096	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  0009b	83 c4 14	 add	 esp, 20			; 00000014H
  0009e	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a0	89 4d cc	 mov	 DWORD PTR $T22[ebp], ecx
  000a3	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a6	89 55 d0	 mov	 DWORD PTR $T22[ebp+4], edx
  000a9	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000ac	89 45 d4	 mov	 DWORD PTR $T22[ebp+8], eax
  000af	8b 4d cc	 mov	 ecx, DWORD PTR $T22[ebp]
  000b2	89 4d dc	 mov	 DWORD PTR _y_range$[ebp], ecx
  000b5	8b 55 d0	 mov	 edx, DWORD PTR $T22[ebp+4]
  000b8	89 55 e0	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000bb	8b 45 d4	 mov	 eax, DWORD PTR $T22[ebp+8]
  000be	89 45 e4	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 435  :     uint8_t *srcLine = (uint8_t *)src[0] + (src_y_pitch_byte * ((y_range.start_src + y_range.len) - 1)) + crop_left * 3;;

  000c1	b9 04 00 00 00	 mov	 ecx, 4
  000c6	6b d1 00	 imul	 edx, ecx, 0
  000c9	8b 45 e4	 mov	 eax, DWORD PTR _y_range$[ebp+8]
  000cc	8b 4d dc	 mov	 ecx, DWORD PTR _y_range$[ebp]
  000cf	8d 44 01 ff	 lea	 eax, DWORD PTR [ecx+eax-1]
  000d3	0f af 43 14	 imul	 eax, DWORD PTR _src_y_pitch_byte$[ebx]
  000d7	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  000da	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  000dd	03 d0		 add	 edx, eax
  000df	6b 45 f8 03	 imul	 eax, DWORD PTR _crop_left$[ebp], 3
  000e3	03 d0		 add	 edx, eax
  000e5	89 55 c8	 mov	 DWORD PTR _srcLine$[ebp], edx

; 436  :     uint8_t *dstLine = (uint8_t *)dst[0] + (dst_y_pitch_byte * y_range.start_dst);

  000e8	b9 04 00 00 00	 mov	 ecx, 4
  000ed	6b d1 00	 imul	 edx, ecx, 0
  000f0	8b 43 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  000f3	0f af 45 e0	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  000f7	8b 4b 08	 mov	 ecx, DWORD PTR _dst$[ebx]
  000fa	03 04 11	 add	 eax, DWORD PTR [ecx+edx]
  000fd	89 45 c4	 mov	 DWORD PTR _dstLine$[ebp], eax

; 437  :     alignas(16) const char MASK_RGB3_TO_RGB4[] = { 0, 1, 2, -1, 3, 4, 5, -1, 6, 7, 8, -1, 9, 10, 11, -1 };

  00100	c6 45 b0 00	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp], 0
  00104	c6 45 b1 01	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+1], 1
  00108	c6 45 b2 02	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+2], 2
  0010c	c6 45 b3 ff	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+3], -1
  00110	c6 45 b4 03	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+4], 3
  00114	c6 45 b5 04	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+5], 4
  00118	c6 45 b6 05	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+6], 5
  0011c	c6 45 b7 ff	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+7], -1
  00120	c6 45 b8 06	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+8], 6
  00124	c6 45 b9 07	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+9], 7
  00128	c6 45 ba 08	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+10], 8
  0012c	c6 45 bb ff	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+11], -1
  00130	c6 45 bc 09	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+12], 9
  00134	c6 45 bd 0a	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+13], 10 ; 0000000aH
  00138	c6 45 be 0b	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+14], 11 ; 0000000bH
  0013c	c6 45 bf ff	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+15], -1

; 438  :     __m128i xMask = _mm_load_si128((__m128i*)MASK_RGB3_TO_RGB4);

  00140	0f 28 45 b0	 movaps	 xmm0, XMMWORD PTR _MASK_RGB3_TO_RGB4$[ebp]
  00144	0f 29 45 80	 movaps	 XMMWORD PTR $T21[ebp], xmm0
  00148	0f 28 45 80	 movaps	 xmm0, XMMWORD PTR $T21[ebp]
  0014c	0f 29 45 90	 movaps	 XMMWORD PTR _xMask$[ebp], xmm0

; 439  :     for (int y = 0; y  < y_range.len; y++, srcLine -= src_y_pitch_byte, dstLine += dst_y_pitch_byte) {

  00150	c7 85 7c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _y$20[ebp], 0
  0015a	eb 21		 jmp	 SHORT $LN4@convert_rg
$LN2@convert_rg:
  0015c	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR _y$20[ebp]
  00162	83 c2 01	 add	 edx, 1
  00165	89 95 7c ff ff
	ff		 mov	 DWORD PTR _y$20[ebp], edx
  0016b	8b 45 c8	 mov	 eax, DWORD PTR _srcLine$[ebp]
  0016e	2b 43 14	 sub	 eax, DWORD PTR _src_y_pitch_byte$[ebx]
  00171	89 45 c8	 mov	 DWORD PTR _srcLine$[ebp], eax
  00174	8b 4d c4	 mov	 ecx, DWORD PTR _dstLine$[ebp]
  00177	03 4b 1c	 add	 ecx, DWORD PTR _dst_y_pitch_byte$[ebx]
  0017a	89 4d c4	 mov	 DWORD PTR _dstLine$[ebp], ecx
$LN4@convert_rg:
  0017d	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR _y$20[ebp]
  00183	3b 55 e4	 cmp	 edx, DWORD PTR _y_range$[ebp+8]
  00186	0f 8d 87 02 00
	00		 jge	 $LN1@convert_rg

; 440  :         uint8_t *ptr_src = srcLine;

  0018c	8b 45 c8	 mov	 eax, DWORD PTR _srcLine$[ebp]
  0018f	89 85 78 ff ff
	ff		 mov	 DWORD PTR _ptr_src$19[ebp], eax

; 441  :         uint8_t *ptr_dst = dstLine;

  00195	8b 4d c4	 mov	 ecx, DWORD PTR _dstLine$[ebp]
  00198	89 8d 74 ff ff
	ff		 mov	 DWORD PTR _ptr_dst$18[ebp], ecx

; 442  :         int x = 0, x_fin = width - crop_left - crop_right - 16;

  0019e	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _x$17[ebp], 0
  001a8	8b 53 10	 mov	 edx, DWORD PTR _width$[ebx]
  001ab	2b 55 f8	 sub	 edx, DWORD PTR _crop_left$[ebp]
  001ae	2b 55 f0	 sub	 edx, DWORD PTR _crop_right$[ebp]
  001b1	83 ea 10	 sub	 edx, 16			; 00000010H
  001b4	89 95 6c ff ff
	ff		 mov	 DWORD PTR _x_fin$16[ebp], edx

; 443  :         for (; x < x_fin; x += 16, ptr_dst += 64, ptr_src += 48) {

  001ba	eb 2d		 jmp	 SHORT $LN7@convert_rg
$LN5@convert_rg:
  001bc	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _x$17[ebp]
  001c2	83 c0 10	 add	 eax, 16			; 00000010H
  001c5	89 85 70 ff ff
	ff		 mov	 DWORD PTR _x$17[ebp], eax
  001cb	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _ptr_dst$18[ebp]
  001d1	83 c1 40	 add	 ecx, 64			; 00000040H
  001d4	89 8d 74 ff ff
	ff		 mov	 DWORD PTR _ptr_dst$18[ebp], ecx
  001da	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _ptr_src$19[ebp]
  001e0	83 c2 30	 add	 edx, 48			; 00000030H
  001e3	89 95 78 ff ff
	ff		 mov	 DWORD PTR _ptr_src$19[ebp], edx
$LN7@convert_rg:
  001e9	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _x$17[ebp]
  001ef	3b 85 6c ff ff
	ff		 cmp	 eax, DWORD PTR _x_fin$16[ebp]
  001f5	0f 8d a3 01 00
	00		 jge	 $LN6@convert_rg

; 444  :             __m128i x0 = _mm_loadu_si128((__m128i*)(ptr_src +  0));

  001fb	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _ptr_src$19[ebp]
  00201	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00204	0f 29 85 40 ff
	ff ff		 movaps	 XMMWORD PTR $T14[ebp], xmm0
  0020b	0f 28 85 40 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T14[ebp]
  00212	0f 29 85 50 ff
	ff ff		 movaps	 XMMWORD PTR _x0$15[ebp], xmm0

; 445  :             __m128i x1 = _mm_loadu_si128((__m128i*)(ptr_src + 16));

  00219	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _ptr_src$19[ebp]
  0021f	83 c2 10	 add	 edx, 16			; 00000010H
  00222	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  00225	0f 29 85 20 ff
	ff ff		 movaps	 XMMWORD PTR $T12[ebp], xmm0
  0022c	0f 28 85 20 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T12[ebp]
  00233	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR _x1$13[ebp], xmm0

; 446  :             __m128i x2 = _mm_loadu_si128((__m128i*)(ptr_src + 32));

  0023a	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _ptr_src$19[ebp]
  00240	83 c0 20	 add	 eax, 32			; 00000020H
  00243	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00246	0f 29 85 00 ff
	ff ff		 movaps	 XMMWORD PTR $T10[ebp], xmm0
  0024d	0f 28 85 00 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T10[ebp]
  00254	0f 29 85 10 ff
	ff ff		 movaps	 XMMWORD PTR _x2$11[ebp], xmm0

; 447  :             __m128i x3 = _mm_srli_si128(x2, 4);

  0025b	0f 28 85 10 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x2$11[ebp]
  00262	66 0f 73 d8 04	 psrldq	 xmm0, 4
  00267	0f 29 85 e0 fe
	ff ff		 movaps	 XMMWORD PTR $T8[ebp], xmm0
  0026e	0f 28 85 e0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T8[ebp]
  00275	0f 29 85 f0 fe
	ff ff		 movaps	 XMMWORD PTR _x3$9[ebp], xmm0

; 448  :             x3 = _mm_shuffle_epi8(x3, xMask);

  0027c	0f 28 85 f0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _x3$9[ebp]
  00283	66 0f 38 00 45
	90		 pshufb	 xmm0, XMMWORD PTR _xMask$[ebp]
  00289	0f 29 85 d0 fe
	ff ff		 movaps	 XMMWORD PTR $T7[ebp], xmm0
  00290	0f 28 85 d0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T7[ebp]
  00297	0f 29 85 f0 fe
	ff ff		 movaps	 XMMWORD PTR _x3$9[ebp], xmm0

; 449  :             x2 = _mm_alignr_epi8(x2, x1, 8);

  0029e	0f 28 85 10 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x2$11[ebp]
  002a5	66 0f 3a 0f 85
	30 ff ff ff 08	 palignr xmm0, XMMWORD PTR _x1$13[ebp], 8
  002af	0f 29 85 c0 fe
	ff ff		 movaps	 XMMWORD PTR $T6[ebp], xmm0
  002b6	0f 28 85 c0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T6[ebp]
  002bd	0f 29 85 10 ff
	ff ff		 movaps	 XMMWORD PTR _x2$11[ebp], xmm0

; 450  :             x2 = _mm_shuffle_epi8(x2, xMask);

  002c4	0f 28 85 10 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x2$11[ebp]
  002cb	66 0f 38 00 45
	90		 pshufb	 xmm0, XMMWORD PTR _xMask$[ebp]
  002d1	0f 29 85 b0 fe
	ff ff		 movaps	 XMMWORD PTR $T5[ebp], xmm0
  002d8	0f 28 85 b0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T5[ebp]
  002df	0f 29 85 10 ff
	ff ff		 movaps	 XMMWORD PTR _x2$11[ebp], xmm0

; 451  :             x1 = _mm_alignr_epi8(x1, x0, 12);

  002e6	0f 28 85 30 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$13[ebp]
  002ed	66 0f 3a 0f 85
	50 ff ff ff 0c	 palignr xmm0, XMMWORD PTR _x0$15[ebp], 12 ; 0000000cH
  002f7	0f 29 85 a0 fe
	ff ff		 movaps	 XMMWORD PTR $T4[ebp], xmm0
  002fe	0f 28 85 a0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T4[ebp]
  00305	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR _x1$13[ebp], xmm0

; 452  :             x1 = _mm_shuffle_epi8(x1, xMask);

  0030c	0f 28 85 30 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$13[ebp]
  00313	66 0f 38 00 45
	90		 pshufb	 xmm0, XMMWORD PTR _xMask$[ebp]
  00319	0f 29 85 90 fe
	ff ff		 movaps	 XMMWORD PTR $T3[ebp], xmm0
  00320	0f 28 85 90 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T3[ebp]
  00327	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR _x1$13[ebp], xmm0

; 453  :             x0 = _mm_shuffle_epi8(x0, xMask);

  0032e	0f 28 85 50 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x0$15[ebp]
  00335	66 0f 38 00 45
	90		 pshufb	 xmm0, XMMWORD PTR _xMask$[ebp]
  0033b	0f 29 85 80 fe
	ff ff		 movaps	 XMMWORD PTR $T2[ebp], xmm0
  00342	0f 28 85 80 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T2[ebp]
  00349	0f 29 85 50 ff
	ff ff		 movaps	 XMMWORD PTR _x0$15[ebp], xmm0

; 454  :             _mm_storeu_si128((__m128i*)(ptr_dst + 48), x3);

  00350	0f 10 85 f0 fe
	ff ff		 movups	 xmm0, XMMWORD PTR _x3$9[ebp]
  00357	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _ptr_dst$18[ebp]
  0035d	83 c1 30	 add	 ecx, 48			; 00000030H
  00360	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 455  :             _mm_storeu_si128((__m128i*)(ptr_dst + 32), x2);

  00363	0f 10 85 10 ff
	ff ff		 movups	 xmm0, XMMWORD PTR _x2$11[ebp]
  0036a	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _ptr_dst$18[ebp]
  00370	83 c2 20	 add	 edx, 32			; 00000020H
  00373	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 456  :             _mm_storeu_si128((__m128i*)(ptr_dst + 16), x1);

  00376	0f 10 85 30 ff
	ff ff		 movups	 xmm0, XMMWORD PTR _x1$13[ebp]
  0037d	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _ptr_dst$18[ebp]
  00383	83 c0 10	 add	 eax, 16			; 00000010H
  00386	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 457  :             _mm_storeu_si128((__m128i*)(ptr_dst +  0), x0);

  00389	0f 10 85 50 ff
	ff ff		 movups	 xmm0, XMMWORD PTR _x0$15[ebp]
  00390	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _ptr_dst$18[ebp]
  00396	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 458  :         }

  00399	e9 1e fe ff ff	 jmp	 $LN5@convert_rg
$LN6@convert_rg:

; 459  :         x_fin = width - crop_left - crop_right;

  0039e	8b 53 10	 mov	 edx, DWORD PTR _width$[ebx]
  003a1	2b 55 f8	 sub	 edx, DWORD PTR _crop_left$[ebp]
  003a4	2b 55 f0	 sub	 edx, DWORD PTR _crop_right$[ebp]
  003a7	89 95 6c ff ff
	ff		 mov	 DWORD PTR _x_fin$16[ebp], edx

; 460  :         for (; x < x_fin; x++, ptr_dst += 4, ptr_src += 3) {

  003ad	eb 2d		 jmp	 SHORT $LN10@convert_rg
$LN8@convert_rg:
  003af	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _x$17[ebp]
  003b5	83 c0 01	 add	 eax, 1
  003b8	89 85 70 ff ff
	ff		 mov	 DWORD PTR _x$17[ebp], eax
  003be	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _ptr_dst$18[ebp]
  003c4	83 c1 04	 add	 ecx, 4
  003c7	89 8d 74 ff ff
	ff		 mov	 DWORD PTR _ptr_dst$18[ebp], ecx
  003cd	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _ptr_src$19[ebp]
  003d3	83 c2 03	 add	 edx, 3
  003d6	89 95 78 ff ff
	ff		 mov	 DWORD PTR _ptr_src$19[ebp], edx
$LN10@convert_rg:
  003dc	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _x$17[ebp]
  003e2	3b 85 6c ff ff
	ff		 cmp	 eax, DWORD PTR _x_fin$16[ebp]
  003e8	7d 24		 jge	 SHORT $LN9@convert_rg

; 461  :             *(int *)ptr_dst = *(int *)ptr_src;

  003ea	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _ptr_dst$18[ebp]
  003f0	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _ptr_src$19[ebp]
  003f6	8b 02		 mov	 eax, DWORD PTR [edx]
  003f8	89 01		 mov	 DWORD PTR [ecx], eax

; 462  :             ptr_dst[3] = 0;

  003fa	b9 01 00 00 00	 mov	 ecx, 1
  003ff	6b d1 03	 imul	 edx, ecx, 3
  00402	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _ptr_dst$18[ebp]
  00408	c6 04 10 00	 mov	 BYTE PTR [eax+edx], 0

; 463  :         }

  0040c	eb a1		 jmp	 SHORT $LN8@convert_rg
$LN9@convert_rg:

; 464  :     }

  0040e	e9 49 fd ff ff	 jmp	 $LN2@convert_rg
$LN1@convert_rg:

; 465  : }

  00413	52		 push	 edx
  00414	8b cd		 mov	 ecx, ebp
  00416	50		 push	 eax
  00417	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN15@convert_rg
  0041d	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00422	58		 pop	 eax
  00423	5a		 pop	 edx
  00424	5f		 pop	 edi
  00425	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00428	33 cd		 xor	 ecx, ebp
  0042a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0042f	8b e5		 mov	 esp, ebp
  00431	5d		 pop	 ebp
  00432	8b e3		 mov	 esp, ebx
  00434	5b		 pop	 ebx
  00435	c3		 ret	 0
  00436	66 90		 npad	 2
$LN15@convert_rg:
  00438	02 00 00 00	 DD	 2
  0043c	00 00 00 00	 DD	 $LN14@convert_rg
$LN14@convert_rg:
  00440	dc ff ff ff	 DD	 -36			; ffffffdcH
  00444	0c 00 00 00	 DD	 12			; 0000000cH
  00448	00 00 00 00	 DD	 $LN12@convert_rg
  0044c	b0 ff ff ff	 DD	 -80			; ffffffb0H
  00450	10 00 00 00	 DD	 16			; 00000010H
  00454	00 00 00 00	 DD	 $LN13@convert_rg
$LN13@convert_rg:
  00458	4d		 DB	 77			; 0000004dH
  00459	41		 DB	 65			; 00000041H
  0045a	53		 DB	 83			; 00000053H
  0045b	4b		 DB	 75			; 0000004bH
  0045c	5f		 DB	 95			; 0000005fH
  0045d	52		 DB	 82			; 00000052H
  0045e	47		 DB	 71			; 00000047H
  0045f	42		 DB	 66			; 00000042H
  00460	33		 DB	 51			; 00000033H
  00461	5f		 DB	 95			; 0000005fH
  00462	54		 DB	 84			; 00000054H
  00463	4f		 DB	 79			; 0000004fH
  00464	5f		 DB	 95			; 0000005fH
  00465	52		 DB	 82			; 00000052H
  00466	47		 DB	 71			; 00000047H
  00467	42		 DB	 66			; 00000042H
  00468	34		 DB	 52			; 00000034H
  00469	00		 DB	 0
$LN12@convert_rg:
  0046a	79		 DB	 121			; 00000079H
  0046b	5f		 DB	 95			; 0000005fH
  0046c	72		 DB	 114			; 00000072H
  0046d	61		 DB	 97			; 00000061H
  0046e	6e		 DB	 110			; 0000006eH
  0046f	67		 DB	 103			; 00000067H
  00470	65		 DB	 101			; 00000065H
  00471	00		 DB	 0
?convert_rgb24r_to_rgb32_simd@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_rgb24r_to_rgb32_simd
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -400						; size = 12
$T2 = -384						; size = 16
$T3 = -368						; size = 16
$T4 = -352						; size = 16
$T5 = -336						; size = 16
$T6 = -320						; size = 16
$T7 = -304						; size = 16
$T8 = -288						; size = 16
_x3$9 = -272						; size = 16
$T10 = -256						; size = 16
_x2$11 = -240						; size = 16
$T12 = -224						; size = 16
_x1$13 = -208						; size = 16
$T14 = -192						; size = 16
_x0$15 = -176						; size = 16
_x_fin$16 = -148					; size = 4
_x$17 = -144						; size = 4
_ptr_dst$18 = -140					; size = 4
_ptr_src$19 = -136					; size = 4
_y$20 = -132						; size = 4
$T21 = -128						; size = 16
_xMask$ = -112						; size = 16
_MASK_RGB3_TO_RGB4$ = -80				; size = 16
_dstLine$ = -60						; size = 4
_srcLine$ = -56						; size = 4
$T22 = -52						; size = 12
_y_range$ = -36						; size = 12
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_rgb24_to_rgb32_simd@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_rgb24_to_rgb32_simd

; 391  : static void __forceinline convert_rgb24_to_rgb32_simd(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 90 01 00
	00		 sub	 esp, 400		; 00000190H
  0001c	57		 push	 edi
  0001d	8d bd 70 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-400]
  00023	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 392  :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 393  :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 394  :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 395  :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 396  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  0007c	8b 53 2c	 mov	 edx, DWORD PTR _thread_n$[ebx]
  0007f	52		 push	 edx
  00080	8b 43 28	 mov	 eax, DWORD PTR _thread_id$[ebx]
  00083	50		 push	 eax
  00084	8b 4b 20	 mov	 ecx, DWORD PTR _height$[ebx]
  00087	2b 4d ec	 sub	 ecx, DWORD PTR _crop_bottom$[ebp]
  0008a	51		 push	 ecx
  0008b	8b 55 f4	 mov	 edx, DWORD PTR _crop_up$[ebp]
  0008e	52		 push	 edx
  0008f	8d 85 70 fe ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  00095	50		 push	 eax
  00096	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  0009b	83 c4 14	 add	 esp, 20			; 00000014H
  0009e	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a0	89 4d cc	 mov	 DWORD PTR $T22[ebp], ecx
  000a3	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a6	89 55 d0	 mov	 DWORD PTR $T22[ebp+4], edx
  000a9	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000ac	89 45 d4	 mov	 DWORD PTR $T22[ebp+8], eax
  000af	8b 4d cc	 mov	 ecx, DWORD PTR $T22[ebp]
  000b2	89 4d dc	 mov	 DWORD PTR _y_range$[ebp], ecx
  000b5	8b 55 d0	 mov	 edx, DWORD PTR $T22[ebp+4]
  000b8	89 55 e0	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000bb	8b 45 d4	 mov	 eax, DWORD PTR $T22[ebp+8]
  000be	89 45 e4	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 397  :     uint8_t *srcLine = (uint8_t *)src[0] + (src_y_pitch_byte * y_range.start_src) + crop_left * 3;;

  000c1	b9 04 00 00 00	 mov	 ecx, 4
  000c6	6b d1 00	 imul	 edx, ecx, 0
  000c9	8b 43 14	 mov	 eax, DWORD PTR _src_y_pitch_byte$[ebx]
  000cc	0f af 45 dc	 imul	 eax, DWORD PTR _y_range$[ebp]
  000d0	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  000d3	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  000d6	03 d0		 add	 edx, eax
  000d8	6b 45 f8 03	 imul	 eax, DWORD PTR _crop_left$[ebp], 3
  000dc	03 d0		 add	 edx, eax
  000de	89 55 c8	 mov	 DWORD PTR _srcLine$[ebp], edx

; 398  :     uint8_t *dstLine = (uint8_t *)dst[0] + (dst_y_pitch_byte * y_range.start_dst);

  000e1	b9 04 00 00 00	 mov	 ecx, 4
  000e6	6b d1 00	 imul	 edx, ecx, 0
  000e9	8b 43 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  000ec	0f af 45 e0	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  000f0	8b 4b 08	 mov	 ecx, DWORD PTR _dst$[ebx]
  000f3	03 04 11	 add	 eax, DWORD PTR [ecx+edx]
  000f6	89 45 c4	 mov	 DWORD PTR _dstLine$[ebp], eax

; 399  :     alignas(16) const char MASK_RGB3_TO_RGB4[] = { 0, 1, 2, -1, 3, 4, 5, -1, 6, 7, 8, -1, 9, 10, 11, -1 };

  000f9	c6 45 b0 00	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp], 0
  000fd	c6 45 b1 01	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+1], 1
  00101	c6 45 b2 02	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+2], 2
  00105	c6 45 b3 ff	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+3], -1
  00109	c6 45 b4 03	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+4], 3
  0010d	c6 45 b5 04	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+5], 4
  00111	c6 45 b6 05	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+6], 5
  00115	c6 45 b7 ff	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+7], -1
  00119	c6 45 b8 06	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+8], 6
  0011d	c6 45 b9 07	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+9], 7
  00121	c6 45 ba 08	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+10], 8
  00125	c6 45 bb ff	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+11], -1
  00129	c6 45 bc 09	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+12], 9
  0012d	c6 45 bd 0a	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+13], 10 ; 0000000aH
  00131	c6 45 be 0b	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+14], 11 ; 0000000bH
  00135	c6 45 bf ff	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+15], -1

; 400  :     __m128i xMask = _mm_load_si128((__m128i*)MASK_RGB3_TO_RGB4);

  00139	0f 28 45 b0	 movaps	 xmm0, XMMWORD PTR _MASK_RGB3_TO_RGB4$[ebp]
  0013d	0f 29 45 80	 movaps	 XMMWORD PTR $T21[ebp], xmm0
  00141	0f 28 45 80	 movaps	 xmm0, XMMWORD PTR $T21[ebp]
  00145	0f 29 45 90	 movaps	 XMMWORD PTR _xMask$[ebp], xmm0

; 401  :     for (int y = 0; y < y_range.len; y++, srcLine += src_y_pitch_byte, dstLine += dst_y_pitch_byte) {

  00149	c7 85 7c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _y$20[ebp], 0
  00153	eb 21		 jmp	 SHORT $LN4@convert_rg
$LN2@convert_rg:
  00155	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR _y$20[ebp]
  0015b	83 c2 01	 add	 edx, 1
  0015e	89 95 7c ff ff
	ff		 mov	 DWORD PTR _y$20[ebp], edx
  00164	8b 45 c8	 mov	 eax, DWORD PTR _srcLine$[ebp]
  00167	03 43 14	 add	 eax, DWORD PTR _src_y_pitch_byte$[ebx]
  0016a	89 45 c8	 mov	 DWORD PTR _srcLine$[ebp], eax
  0016d	8b 4d c4	 mov	 ecx, DWORD PTR _dstLine$[ebp]
  00170	03 4b 1c	 add	 ecx, DWORD PTR _dst_y_pitch_byte$[ebx]
  00173	89 4d c4	 mov	 DWORD PTR _dstLine$[ebp], ecx
$LN4@convert_rg:
  00176	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR _y$20[ebp]
  0017c	3b 55 e4	 cmp	 edx, DWORD PTR _y_range$[ebp+8]
  0017f	0f 8d 87 02 00
	00		 jge	 $LN1@convert_rg

; 402  :         uint8_t *ptr_src = srcLine;

  00185	8b 45 c8	 mov	 eax, DWORD PTR _srcLine$[ebp]
  00188	89 85 78 ff ff
	ff		 mov	 DWORD PTR _ptr_src$19[ebp], eax

; 403  :         uint8_t *ptr_dst = dstLine;

  0018e	8b 4d c4	 mov	 ecx, DWORD PTR _dstLine$[ebp]
  00191	89 8d 74 ff ff
	ff		 mov	 DWORD PTR _ptr_dst$18[ebp], ecx

; 404  :         int x = 0, x_fin = width - crop_left - crop_right - 16;

  00197	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _x$17[ebp], 0
  001a1	8b 53 10	 mov	 edx, DWORD PTR _width$[ebx]
  001a4	2b 55 f8	 sub	 edx, DWORD PTR _crop_left$[ebp]
  001a7	2b 55 f0	 sub	 edx, DWORD PTR _crop_right$[ebp]
  001aa	83 ea 10	 sub	 edx, 16			; 00000010H
  001ad	89 95 6c ff ff
	ff		 mov	 DWORD PTR _x_fin$16[ebp], edx

; 405  :         for ( ; x < x_fin; x += 16, ptr_dst += 64, ptr_src += 48) {

  001b3	eb 2d		 jmp	 SHORT $LN7@convert_rg
$LN5@convert_rg:
  001b5	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _x$17[ebp]
  001bb	83 c0 10	 add	 eax, 16			; 00000010H
  001be	89 85 70 ff ff
	ff		 mov	 DWORD PTR _x$17[ebp], eax
  001c4	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _ptr_dst$18[ebp]
  001ca	83 c1 40	 add	 ecx, 64			; 00000040H
  001cd	89 8d 74 ff ff
	ff		 mov	 DWORD PTR _ptr_dst$18[ebp], ecx
  001d3	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _ptr_src$19[ebp]
  001d9	83 c2 30	 add	 edx, 48			; 00000030H
  001dc	89 95 78 ff ff
	ff		 mov	 DWORD PTR _ptr_src$19[ebp], edx
$LN7@convert_rg:
  001e2	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _x$17[ebp]
  001e8	3b 85 6c ff ff
	ff		 cmp	 eax, DWORD PTR _x_fin$16[ebp]
  001ee	0f 8d a3 01 00
	00		 jge	 $LN6@convert_rg

; 406  :             __m128i x0 = _mm_loadu_si128((__m128i*)(ptr_src +  0));

  001f4	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _ptr_src$19[ebp]
  001fa	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  001fd	0f 29 85 40 ff
	ff ff		 movaps	 XMMWORD PTR $T14[ebp], xmm0
  00204	0f 28 85 40 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T14[ebp]
  0020b	0f 29 85 50 ff
	ff ff		 movaps	 XMMWORD PTR _x0$15[ebp], xmm0

; 407  :             __m128i x1 = _mm_loadu_si128((__m128i*)(ptr_src + 16));

  00212	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _ptr_src$19[ebp]
  00218	83 c2 10	 add	 edx, 16			; 00000010H
  0021b	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  0021e	0f 29 85 20 ff
	ff ff		 movaps	 XMMWORD PTR $T12[ebp], xmm0
  00225	0f 28 85 20 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T12[ebp]
  0022c	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR _x1$13[ebp], xmm0

; 408  :             __m128i x2 = _mm_loadu_si128((__m128i*)(ptr_src + 32));

  00233	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _ptr_src$19[ebp]
  00239	83 c0 20	 add	 eax, 32			; 00000020H
  0023c	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  0023f	0f 29 85 00 ff
	ff ff		 movaps	 XMMWORD PTR $T10[ebp], xmm0
  00246	0f 28 85 00 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T10[ebp]
  0024d	0f 29 85 10 ff
	ff ff		 movaps	 XMMWORD PTR _x2$11[ebp], xmm0

; 409  :             __m128i x3 = _mm_srli_si128(x2, 4);

  00254	0f 28 85 10 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x2$11[ebp]
  0025b	66 0f 73 d8 04	 psrldq	 xmm0, 4
  00260	0f 29 85 e0 fe
	ff ff		 movaps	 XMMWORD PTR $T8[ebp], xmm0
  00267	0f 28 85 e0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T8[ebp]
  0026e	0f 29 85 f0 fe
	ff ff		 movaps	 XMMWORD PTR _x3$9[ebp], xmm0

; 410  :             x3 = _mm_shuffle_epi8(x3, xMask);

  00275	0f 28 85 f0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _x3$9[ebp]
  0027c	66 0f 38 00 45
	90		 pshufb	 xmm0, XMMWORD PTR _xMask$[ebp]
  00282	0f 29 85 d0 fe
	ff ff		 movaps	 XMMWORD PTR $T7[ebp], xmm0
  00289	0f 28 85 d0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T7[ebp]
  00290	0f 29 85 f0 fe
	ff ff		 movaps	 XMMWORD PTR _x3$9[ebp], xmm0

; 411  :             x2 = _mm_alignr_epi8(x2, x1, 8);

  00297	0f 28 85 10 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x2$11[ebp]
  0029e	66 0f 3a 0f 85
	30 ff ff ff 08	 palignr xmm0, XMMWORD PTR _x1$13[ebp], 8
  002a8	0f 29 85 c0 fe
	ff ff		 movaps	 XMMWORD PTR $T6[ebp], xmm0
  002af	0f 28 85 c0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T6[ebp]
  002b6	0f 29 85 10 ff
	ff ff		 movaps	 XMMWORD PTR _x2$11[ebp], xmm0

; 412  :             x2 = _mm_shuffle_epi8(x2, xMask);

  002bd	0f 28 85 10 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x2$11[ebp]
  002c4	66 0f 38 00 45
	90		 pshufb	 xmm0, XMMWORD PTR _xMask$[ebp]
  002ca	0f 29 85 b0 fe
	ff ff		 movaps	 XMMWORD PTR $T5[ebp], xmm0
  002d1	0f 28 85 b0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T5[ebp]
  002d8	0f 29 85 10 ff
	ff ff		 movaps	 XMMWORD PTR _x2$11[ebp], xmm0

; 413  :             x1 = _mm_alignr_epi8(x1, x0, 12);

  002df	0f 28 85 30 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$13[ebp]
  002e6	66 0f 3a 0f 85
	50 ff ff ff 0c	 palignr xmm0, XMMWORD PTR _x0$15[ebp], 12 ; 0000000cH
  002f0	0f 29 85 a0 fe
	ff ff		 movaps	 XMMWORD PTR $T4[ebp], xmm0
  002f7	0f 28 85 a0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T4[ebp]
  002fe	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR _x1$13[ebp], xmm0

; 414  :             x1 = _mm_shuffle_epi8(x1, xMask);

  00305	0f 28 85 30 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$13[ebp]
  0030c	66 0f 38 00 45
	90		 pshufb	 xmm0, XMMWORD PTR _xMask$[ebp]
  00312	0f 29 85 90 fe
	ff ff		 movaps	 XMMWORD PTR $T3[ebp], xmm0
  00319	0f 28 85 90 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T3[ebp]
  00320	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR _x1$13[ebp], xmm0

; 415  :             x0 = _mm_shuffle_epi8(x0, xMask);

  00327	0f 28 85 50 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x0$15[ebp]
  0032e	66 0f 38 00 45
	90		 pshufb	 xmm0, XMMWORD PTR _xMask$[ebp]
  00334	0f 29 85 80 fe
	ff ff		 movaps	 XMMWORD PTR $T2[ebp], xmm0
  0033b	0f 28 85 80 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T2[ebp]
  00342	0f 29 85 50 ff
	ff ff		 movaps	 XMMWORD PTR _x0$15[ebp], xmm0

; 416  :             _mm_storeu_si128((__m128i*)(ptr_dst + 48), x3);

  00349	0f 10 85 f0 fe
	ff ff		 movups	 xmm0, XMMWORD PTR _x3$9[ebp]
  00350	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _ptr_dst$18[ebp]
  00356	83 c1 30	 add	 ecx, 48			; 00000030H
  00359	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 417  :             _mm_storeu_si128((__m128i*)(ptr_dst + 32), x2);

  0035c	0f 10 85 10 ff
	ff ff		 movups	 xmm0, XMMWORD PTR _x2$11[ebp]
  00363	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _ptr_dst$18[ebp]
  00369	83 c2 20	 add	 edx, 32			; 00000020H
  0036c	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 418  :             _mm_storeu_si128((__m128i*)(ptr_dst + 16), x1);

  0036f	0f 10 85 30 ff
	ff ff		 movups	 xmm0, XMMWORD PTR _x1$13[ebp]
  00376	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _ptr_dst$18[ebp]
  0037c	83 c0 10	 add	 eax, 16			; 00000010H
  0037f	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 419  :             _mm_storeu_si128((__m128i*)(ptr_dst +  0), x0);

  00382	0f 10 85 50 ff
	ff ff		 movups	 xmm0, XMMWORD PTR _x0$15[ebp]
  00389	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _ptr_dst$18[ebp]
  0038f	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 420  :         }

  00392	e9 1e fe ff ff	 jmp	 $LN5@convert_rg
$LN6@convert_rg:

; 421  :         x_fin = width - crop_left - crop_right;

  00397	8b 53 10	 mov	 edx, DWORD PTR _width$[ebx]
  0039a	2b 55 f8	 sub	 edx, DWORD PTR _crop_left$[ebp]
  0039d	2b 55 f0	 sub	 edx, DWORD PTR _crop_right$[ebp]
  003a0	89 95 6c ff ff
	ff		 mov	 DWORD PTR _x_fin$16[ebp], edx

; 422  :         for ( ; x < x_fin; x++, ptr_dst += 4, ptr_src += 3) {

  003a6	eb 2d		 jmp	 SHORT $LN10@convert_rg
$LN8@convert_rg:
  003a8	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _x$17[ebp]
  003ae	83 c0 01	 add	 eax, 1
  003b1	89 85 70 ff ff
	ff		 mov	 DWORD PTR _x$17[ebp], eax
  003b7	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _ptr_dst$18[ebp]
  003bd	83 c1 04	 add	 ecx, 4
  003c0	89 8d 74 ff ff
	ff		 mov	 DWORD PTR _ptr_dst$18[ebp], ecx
  003c6	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _ptr_src$19[ebp]
  003cc	83 c2 03	 add	 edx, 3
  003cf	89 95 78 ff ff
	ff		 mov	 DWORD PTR _ptr_src$19[ebp], edx
$LN10@convert_rg:
  003d5	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _x$17[ebp]
  003db	3b 85 6c ff ff
	ff		 cmp	 eax, DWORD PTR _x_fin$16[ebp]
  003e1	7d 24		 jge	 SHORT $LN9@convert_rg

; 423  :             *(int *)ptr_dst = *(int *)ptr_src;

  003e3	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _ptr_dst$18[ebp]
  003e9	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _ptr_src$19[ebp]
  003ef	8b 02		 mov	 eax, DWORD PTR [edx]
  003f1	89 01		 mov	 DWORD PTR [ecx], eax

; 424  :             ptr_dst[3] = 0;

  003f3	b9 01 00 00 00	 mov	 ecx, 1
  003f8	6b d1 03	 imul	 edx, ecx, 3
  003fb	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _ptr_dst$18[ebp]
  00401	c6 04 10 00	 mov	 BYTE PTR [eax+edx], 0

; 425  :         }

  00405	eb a1		 jmp	 SHORT $LN8@convert_rg
$LN9@convert_rg:

; 426  :     }

  00407	e9 49 fd ff ff	 jmp	 $LN2@convert_rg
$LN1@convert_rg:

; 427  : }

  0040c	52		 push	 edx
  0040d	8b cd		 mov	 ecx, ebp
  0040f	50		 push	 eax
  00410	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN15@convert_rg
  00416	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0041b	58		 pop	 eax
  0041c	5a		 pop	 edx
  0041d	5f		 pop	 edi
  0041e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00421	33 cd		 xor	 ecx, ebp
  00423	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00428	8b e5		 mov	 esp, ebp
  0042a	5d		 pop	 ebp
  0042b	8b e3		 mov	 esp, ebx
  0042d	5b		 pop	 ebx
  0042e	c3		 ret	 0
  0042f	90		 npad	 1
$LN15@convert_rg:
  00430	02 00 00 00	 DD	 2
  00434	00 00 00 00	 DD	 $LN14@convert_rg
$LN14@convert_rg:
  00438	dc ff ff ff	 DD	 -36			; ffffffdcH
  0043c	0c 00 00 00	 DD	 12			; 0000000cH
  00440	00 00 00 00	 DD	 $LN12@convert_rg
  00444	b0 ff ff ff	 DD	 -80			; ffffffb0H
  00448	10 00 00 00	 DD	 16			; 00000010H
  0044c	00 00 00 00	 DD	 $LN13@convert_rg
$LN13@convert_rg:
  00450	4d		 DB	 77			; 0000004dH
  00451	41		 DB	 65			; 00000041H
  00452	53		 DB	 83			; 00000053H
  00453	4b		 DB	 75			; 0000004bH
  00454	5f		 DB	 95			; 0000005fH
  00455	52		 DB	 82			; 00000052H
  00456	47		 DB	 71			; 00000047H
  00457	42		 DB	 66			; 00000042H
  00458	33		 DB	 51			; 00000033H
  00459	5f		 DB	 95			; 0000005fH
  0045a	54		 DB	 84			; 00000054H
  0045b	4f		 DB	 79			; 0000004fH
  0045c	5f		 DB	 95			; 0000005fH
  0045d	52		 DB	 82			; 00000052H
  0045e	47		 DB	 71			; 00000047H
  0045f	42		 DB	 66			; 00000042H
  00460	34		 DB	 52			; 00000034H
  00461	00		 DB	 0
$LN12@convert_rg:
  00462	79		 DB	 121			; 00000079H
  00463	5f		 DB	 95			; 0000005fH
  00464	72		 DB	 114			; 00000072H
  00465	61		 DB	 97			; 00000061H
  00466	6e		 DB	 110			; 0000006eH
  00467	67		 DB	 103			; 00000067H
  00468	65		 DB	 101			; 00000065H
  00469	00		 DB	 0
?convert_rgb24_to_rgb32_simd@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_rgb24_to_rgb32_simd
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -288						; size = 12
$T2 = -272						; size = 16
$T3 = -256						; size = 16
$T4 = -240						; size = 16
$T5 = -224						; size = 16
$T6 = -208						; size = 16
_x$7 = -184						; size = 4
_x_fin$8 = -180						; size = 4
_x3$9 = -176						; size = 16
_x1$10 = -144						; size = 16
_x0$11 = -112						; size = 16
_pw$12 = -80						; size = 4
_p$13 = -76						; size = 4
_i$14 = -72						; size = 4
_y$15 = -68						; size = 4
_dstCLine$ = -64					; size = 4
_dstYLine$ = -60					; size = 4
_srcLine$ = -56						; size = 4
$T16 = -52						; size = 12
_y_range$ = -36						; size = 12
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuy2_to_nv12_i_simd@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuy2_to_nv12_i_simd

; 233  : static void __forceinline convert_yuy2_to_nv12_i_simd(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 20 01 00
	00		 sub	 esp, 288		; 00000120H
  0001c	57		 push	 edi
  0001d	8d bd e0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-288]
  00023	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 234  :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 235  :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 236  :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 237  :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 238  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  0007c	8b 53 2c	 mov	 edx, DWORD PTR _thread_n$[ebx]
  0007f	52		 push	 edx
  00080	8b 43 28	 mov	 eax, DWORD PTR _thread_id$[ebx]
  00083	50		 push	 eax
  00084	8b 4b 20	 mov	 ecx, DWORD PTR _height$[ebx]
  00087	2b 4d ec	 sub	 ecx, DWORD PTR _crop_bottom$[ebp]
  0008a	51		 push	 ecx
  0008b	8b 55 f4	 mov	 edx, DWORD PTR _crop_up$[ebp]
  0008e	52		 push	 edx
  0008f	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  00095	50		 push	 eax
  00096	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  0009b	83 c4 14	 add	 esp, 20			; 00000014H
  0009e	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a0	89 4d cc	 mov	 DWORD PTR $T16[ebp], ecx
  000a3	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a6	89 55 d0	 mov	 DWORD PTR $T16[ebp+4], edx
  000a9	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000ac	89 45 d4	 mov	 DWORD PTR $T16[ebp+8], eax
  000af	8b 4d cc	 mov	 ecx, DWORD PTR $T16[ebp]
  000b2	89 4d dc	 mov	 DWORD PTR _y_range$[ebp], ecx
  000b5	8b 55 d0	 mov	 edx, DWORD PTR $T16[ebp+4]
  000b8	89 55 e0	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000bb	8b 45 d4	 mov	 eax, DWORD PTR $T16[ebp+8]
  000be	89 45 e4	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 239  :     uint8_t *srcLine = (uint8_t *)src[0] + src_y_pitch_byte * y_range.start_src + crop_left;

  000c1	b9 04 00 00 00	 mov	 ecx, 4
  000c6	6b d1 00	 imul	 edx, ecx, 0
  000c9	8b 43 14	 mov	 eax, DWORD PTR _src_y_pitch_byte$[ebx]
  000cc	0f af 45 dc	 imul	 eax, DWORD PTR _y_range$[ebp]
  000d0	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  000d3	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  000d6	03 d0		 add	 edx, eax
  000d8	03 55 f8	 add	 edx, DWORD PTR _crop_left$[ebp]
  000db	89 55 c8	 mov	 DWORD PTR _srcLine$[ebp], edx

; 240  :     uint8_t *dstYLine = (uint8_t *)dst[0] + dst_y_pitch_byte * y_range.start_dst;

  000de	b8 04 00 00 00	 mov	 eax, 4
  000e3	6b c8 00	 imul	 ecx, eax, 0
  000e6	8b 53 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebx]
  000e9	0f af 55 e0	 imul	 edx, DWORD PTR _y_range$[ebp+4]
  000ed	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  000f0	03 14 08	 add	 edx, DWORD PTR [eax+ecx]
  000f3	89 55 c4	 mov	 DWORD PTR _dstYLine$[ebp], edx

; 241  :     uint8_t *dstCLine = (uint8_t *)dst[1] + dst_y_pitch_byte * (y_range.start_dst >> 1);

  000f6	b9 04 00 00 00	 mov	 ecx, 4
  000fb	c1 e1 00	 shl	 ecx, 0
  000fe	8b 55 e0	 mov	 edx, DWORD PTR _y_range$[ebp+4]
  00101	d1 fa		 sar	 edx, 1
  00103	0f af 53 1c	 imul	 edx, DWORD PTR _dst_y_pitch_byte$[ebx]
  00107	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  0010a	03 14 08	 add	 edx, DWORD PTR [eax+ecx]
  0010d	89 55 c0	 mov	 DWORD PTR _dstCLine$[ebp], edx

; 242  :     for (int y = 0; y < y_range.len; y += 4) {

  00110	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _y$15[ebp], 0
  00117	eb 09		 jmp	 SHORT $LN4@convert_yu
$LN2@convert_yu:
  00119	8b 4d bc	 mov	 ecx, DWORD PTR _y$15[ebp]
  0011c	83 c1 04	 add	 ecx, 4
  0011f	89 4d bc	 mov	 DWORD PTR _y$15[ebp], ecx
$LN4@convert_yu:
  00122	8b 55 bc	 mov	 edx, DWORD PTR _y$15[ebp]
  00125	3b 55 e4	 cmp	 edx, DWORD PTR _y_range$[ebp+8]
  00128	0f 8d c0 01 00
	00		 jge	 $LN1@convert_yu

; 243  :         for (int i = 0; i < 2; i++) {

  0012e	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _i$14[ebp], 0
  00135	eb 09		 jmp	 SHORT $LN7@convert_yu
$LN5@convert_yu:
  00137	8b 45 b8	 mov	 eax, DWORD PTR _i$14[ebp]
  0013a	83 c0 01	 add	 eax, 1
  0013d	89 45 b8	 mov	 DWORD PTR _i$14[ebp], eax
$LN7@convert_yu:
  00140	83 7d b8 02	 cmp	 DWORD PTR _i$14[ebp], 2
  00144	0f 8d 87 01 00
	00		 jge	 $LN6@convert_yu

; 244  :             uint8_t *p = srcLine;

  0014a	8b 4d c8	 mov	 ecx, DWORD PTR _srcLine$[ebp]
  0014d	89 4d b4	 mov	 DWORD PTR _p$13[ebp], ecx

; 245  :             uint8_t *pw = p + (src_y_pitch_byte<<1);

  00150	8b 53 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  00153	8b 45 b4	 mov	 eax, DWORD PTR _p$13[ebp]
  00156	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00159	89 4d b0	 mov	 DWORD PTR _pw$12[ebp], ecx

; 246  :             __m128i x0, x1, x3;
; 247  :             const int x_fin = width - crop_right - crop_left;

  0015c	8b 53 10	 mov	 edx, DWORD PTR _width$[ebx]
  0015f	2b 55 f0	 sub	 edx, DWORD PTR _crop_right$[ebp]
  00162	2b 55 f8	 sub	 edx, DWORD PTR _crop_left$[ebp]
  00165	89 95 4c ff ff
	ff		 mov	 DWORD PTR _x_fin$8[ebp], edx

; 248  :             for (int x = 0; x < x_fin; x += 16, p += 32, pw += 32) {

  0016b	c7 85 48 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _x$7[ebp], 0
  00175	eb 21		 jmp	 SHORT $LN10@convert_yu
$LN8@convert_yu:
  00177	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _x$7[ebp]
  0017d	83 c0 10	 add	 eax, 16			; 00000010H
  00180	89 85 48 ff ff
	ff		 mov	 DWORD PTR _x$7[ebp], eax
  00186	8b 4d b4	 mov	 ecx, DWORD PTR _p$13[ebp]
  00189	83 c1 20	 add	 ecx, 32			; 00000020H
  0018c	89 4d b4	 mov	 DWORD PTR _p$13[ebp], ecx
  0018f	8b 55 b0	 mov	 edx, DWORD PTR _pw$12[ebp]
  00192	83 c2 20	 add	 edx, 32			; 00000020H
  00195	89 55 b0	 mov	 DWORD PTR _pw$12[ebp], edx
$LN10@convert_yu:
  00198	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _x$7[ebp]
  0019e	3b 85 4c ff ff
	ff		 cmp	 eax, DWORD PTR _x_fin$8[ebp]
  001a4	0f 8d 07 01 00
	00		 jge	 $LN9@convert_yu

; 249  :                 //-----------    1+i   ---------------
; 250  :                 x0 = _mm_loadu_si128((const __m128i *)(p+ 0));

  001aa	8b 4d b4	 mov	 ecx, DWORD PTR _p$13[ebp]
  001ad	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  001b0	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR $T6[ebp], xmm0
  001b7	0f 28 85 30 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T6[ebp]
  001be	0f 29 45 90	 movaps	 XMMWORD PTR _x0$11[ebp], xmm0

; 251  :                 x1 = _mm_loadu_si128((const __m128i *)(p+16));

  001c2	8b 55 b4	 mov	 edx, DWORD PTR _p$13[ebp]
  001c5	83 c2 10	 add	 edx, 16			; 00000010H
  001c8	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  001cb	0f 29 85 20 ff
	ff ff		 movaps	 XMMWORD PTR $T5[ebp], xmm0
  001d2	0f 28 85 20 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T5[ebp]
  001d9	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR _x1$10[ebp], xmm0

; 252  : 
; 253  :                 separate_low_up(x0, x1);

  001e0	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR _x1$10[ebp]
  001e6	50		 push	 eax
  001e7	8d 4d 90	 lea	 ecx, DWORD PTR _x0$11[ebp]
  001ea	51		 push	 ecx
  001eb	e8 00 00 00 00	 call	 ?separate_low_up@@YAXAAT__m128i@@0@Z ; separate_low_up
  001f0	83 c4 08	 add	 esp, 8

; 254  :                 x3 = x1;

  001f3	0f 28 85 70 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$10[ebp]
  001fa	0f 29 85 50 ff
	ff ff		 movaps	 XMMWORD PTR _x3$9[ebp], xmm0

; 255  : 
; 256  :                 _mm_store_si128((__m128i *)(dstYLine + x), x0);

  00201	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR _x0$11[ebp]
  00205	8b 55 c4	 mov	 edx, DWORD PTR _dstYLine$[ebp]
  00208	03 95 48 ff ff
	ff		 add	 edx, DWORD PTR _x$7[ebp]
  0020e	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 257  :                 //-----------1+i---------------
; 258  : 
; 259  :                 //-----------3+i---------------
; 260  :                 x0 = _mm_loadu_si128((const __m128i *)(pw+ 0));

  00211	8b 45 b0	 mov	 eax, DWORD PTR _pw$12[ebp]
  00214	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00217	0f 29 85 10 ff
	ff ff		 movaps	 XMMWORD PTR $T4[ebp], xmm0
  0021e	0f 28 85 10 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T4[ebp]
  00225	0f 29 45 90	 movaps	 XMMWORD PTR _x0$11[ebp], xmm0

; 261  :                 x1 = _mm_loadu_si128((const __m128i *)(pw+16));

  00229	8b 4d b0	 mov	 ecx, DWORD PTR _pw$12[ebp]
  0022c	83 c1 10	 add	 ecx, 16			; 00000010H
  0022f	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00232	0f 29 85 00 ff
	ff ff		 movaps	 XMMWORD PTR $T3[ebp], xmm0
  00239	0f 28 85 00 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T3[ebp]
  00240	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR _x1$10[ebp], xmm0

; 262  : 
; 263  :                 separate_low_up(x0, x1);

  00247	8d 95 70 ff ff
	ff		 lea	 edx, DWORD PTR _x1$10[ebp]
  0024d	52		 push	 edx
  0024e	8d 45 90	 lea	 eax, DWORD PTR _x0$11[ebp]
  00251	50		 push	 eax
  00252	e8 00 00 00 00	 call	 ?separate_low_up@@YAXAAT__m128i@@0@Z ; separate_low_up
  00257	83 c4 08	 add	 esp, 8

; 264  : 
; 265  :                 _mm_store_si128((__m128i *)(dstYLine + (dst_y_pitch_byte<<1) + x), x0);

  0025a	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR _x0$11[ebp]
  0025e	8b 4b 1c	 mov	 ecx, DWORD PTR _dst_y_pitch_byte$[ebx]
  00261	8b 55 c4	 mov	 edx, DWORD PTR _dstYLine$[ebp]
  00264	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  00267	03 85 48 ff ff
	ff		 add	 eax, DWORD PTR _x$7[ebp]
  0026d	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 266  :                 //-----------3+i---------------
; 267  :                 x0 = yuv422_to_420_i_interpolate(x3, x1, i);

  00270	8b 4d b8	 mov	 ecx, DWORD PTR _i$14[ebp]
  00273	51		 push	 ecx
  00274	0f 28 8d 70 ff
	ff ff		 movaps	 xmm1, XMMWORD PTR _x1$10[ebp]
  0027b	0f 28 85 50 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x3$9[ebp]
  00282	e8 00 00 00 00	 call	 ?yuv422_to_420_i_interpolate@@YA?AT__m128i@@T1@0H@Z ; yuv422_to_420_i_interpolate
  00287	83 c4 04	 add	 esp, 4
  0028a	0f 29 85 f0 fe
	ff ff		 movaps	 XMMWORD PTR $T2[ebp], xmm0
  00291	0f 28 85 f0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T2[ebp]
  00298	0f 29 45 90	 movaps	 XMMWORD PTR _x0$11[ebp], xmm0

; 268  : 
; 269  :                 _mm_store_si128((__m128i *)(dstCLine + x), x0);

  0029c	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR _x0$11[ebp]
  002a0	8b 55 c0	 mov	 edx, DWORD PTR _dstCLine$[ebp]
  002a3	03 95 48 ff ff
	ff		 add	 edx, DWORD PTR _x$7[ebp]
  002a9	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 270  :             }

  002ac	e9 c6 fe ff ff	 jmp	 $LN8@convert_yu
$LN9@convert_yu:

; 271  :             srcLine  += src_y_pitch_byte;

  002b1	8b 45 c8	 mov	 eax, DWORD PTR _srcLine$[ebp]
  002b4	03 43 14	 add	 eax, DWORD PTR _src_y_pitch_byte$[ebx]
  002b7	89 45 c8	 mov	 DWORD PTR _srcLine$[ebp], eax

; 272  :             dstYLine += dst_y_pitch_byte;

  002ba	8b 4d c4	 mov	 ecx, DWORD PTR _dstYLine$[ebp]
  002bd	03 4b 1c	 add	 ecx, DWORD PTR _dst_y_pitch_byte$[ebx]
  002c0	89 4d c4	 mov	 DWORD PTR _dstYLine$[ebp], ecx

; 273  :             dstCLine += dst_y_pitch_byte;

  002c3	8b 55 c0	 mov	 edx, DWORD PTR _dstCLine$[ebp]
  002c6	03 53 1c	 add	 edx, DWORD PTR _dst_y_pitch_byte$[ebx]
  002c9	89 55 c0	 mov	 DWORD PTR _dstCLine$[ebp], edx

; 274  :         }

  002cc	e9 66 fe ff ff	 jmp	 $LN5@convert_yu
$LN6@convert_yu:

; 275  :         srcLine  += src_y_pitch_byte << 1;

  002d1	8b 43 14	 mov	 eax, DWORD PTR _src_y_pitch_byte$[ebx]
  002d4	8b 4d c8	 mov	 ecx, DWORD PTR _srcLine$[ebp]
  002d7	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  002da	89 55 c8	 mov	 DWORD PTR _srcLine$[ebp], edx

; 276  :         dstYLine += dst_y_pitch_byte << 1;

  002dd	8b 43 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  002e0	8b 4d c4	 mov	 ecx, DWORD PTR _dstYLine$[ebp]
  002e3	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  002e6	89 55 c4	 mov	 DWORD PTR _dstYLine$[ebp], edx

; 277  :     }

  002e9	e9 2b fe ff ff	 jmp	 $LN2@convert_yu
$LN1@convert_yu:

; 278  : }

  002ee	52		 push	 edx
  002ef	8b cd		 mov	 ecx, ebp
  002f1	50		 push	 eax
  002f2	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN16@convert_yu
  002f8	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  002fd	58		 pop	 eax
  002fe	5a		 pop	 edx
  002ff	5f		 pop	 edi
  00300	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00303	33 cd		 xor	 ecx, ebp
  00305	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0030a	8b e5		 mov	 esp, ebp
  0030c	5d		 pop	 ebp
  0030d	8b e3		 mov	 esp, ebx
  0030f	5b		 pop	 ebx
  00310	c3		 ret	 0
  00311	0f 1f 00	 npad	 3
$LN16@convert_yu:
  00314	03 00 00 00	 DD	 3
  00318	00 00 00 00	 DD	 $LN15@convert_yu
$LN15@convert_yu:
  0031c	dc ff ff ff	 DD	 -36			; ffffffdcH
  00320	0c 00 00 00	 DD	 12			; 0000000cH
  00324	00 00 00 00	 DD	 $LN12@convert_yu
  00328	90 ff ff ff	 DD	 -112			; ffffff90H
  0032c	10 00 00 00	 DD	 16			; 00000010H
  00330	00 00 00 00	 DD	 $LN13@convert_yu
  00334	70 ff ff ff	 DD	 -144			; ffffff70H
  00338	10 00 00 00	 DD	 16			; 00000010H
  0033c	00 00 00 00	 DD	 $LN14@convert_yu
$LN14@convert_yu:
  00340	78		 DB	 120			; 00000078H
  00341	31		 DB	 49			; 00000031H
  00342	00		 DB	 0
$LN13@convert_yu:
  00343	78		 DB	 120			; 00000078H
  00344	30		 DB	 48			; 00000030H
  00345	00		 DB	 0
$LN12@convert_yu:
  00346	79		 DB	 121			; 00000079H
  00347	5f		 DB	 95			; 0000005fH
  00348	72		 DB	 114			; 00000072H
  00349	61		 DB	 97			; 00000061H
  0034a	6e		 DB	 110			; 0000006eH
  0034b	67		 DB	 103			; 00000067H
  0034c	65		 DB	 101			; 00000065H
  0034d	00		 DB	 0
?convert_yuy2_to_nv12_i_simd@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuy2_to_nv12_i_simd
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -272						; size = 16
$T2 = -256						; size = 16
$T3 = -240						; size = 16
$T4 = -224						; size = 16
$T5 = -208						; size = 16
$T6 = -192						; size = 16
$T7 = -176						; size = 16
$T8 = -160						; size = 16
$T9 = -144						; size = 16
$T10 = -128						; size = 16
$T11 = -112						; size = 16
$T12 = -96						; size = 16
$T13 = -80						; size = 16
_x1$ = -64						; size = 16
_x0$ = -48						; size = 16
_y_down$ = -32						; size = 16
_y_up$ = -16						; size = 16
_i$ = 8							; size = 4
?yuv422_to_420_i_interpolate@@YA?AT__m128i@@T1@0H@Z PROC ; yuv422_to_420_i_interpolate
; _y_up$ = xmm0
; _y_down$ = xmm1

; 205  : static __forceinline __m128i yuv422_to_420_i_interpolate(__m128i y_up, __m128i y_down, int i) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 10 01 00
	00		 sub	 esp, 272		; 00000110H
  0001c	57		 push	 edi
  0001d	8d bd f0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-272]
  00023	b9 44 00 00 00	 mov	 ecx, 68			; 00000044H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	0f 29 4d e0	 movaps	 XMMWORD PTR _y_down$[ebp], xmm1
  00033	0f 29 45 f0	 movaps	 XMMWORD PTR _y_up$[ebp], xmm0

; 206  :     __m128i x0, x1;
; 207  : #if USE_SSSE3
; 208  :     x0 = _mm_unpacklo_epi8(y_down, y_up);

  00037	0f 28 45 e0	 movaps	 xmm0, XMMWORD PTR _y_down$[ebp]
  0003b	66 0f 60 45 f0	 punpcklbw xmm0, XMMWORD PTR _y_up$[ebp]
  00040	0f 29 45 b0	 movaps	 XMMWORD PTR $T13[ebp], xmm0
  00044	0f 28 45 b0	 movaps	 xmm0, XMMWORD PTR $T13[ebp]
  00048	0f 29 45 d0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 209  :     x1 = _mm_unpackhi_epi8(y_down, y_up);

  0004c	0f 28 45 e0	 movaps	 xmm0, XMMWORD PTR _y_down$[ebp]
  00050	66 0f 68 45 f0	 punpckhbw xmm0, XMMWORD PTR _y_up$[ebp]
  00055	0f 29 45 a0	 movaps	 XMMWORD PTR $T12[ebp], xmm0
  00059	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR $T12[ebp]
  0005d	0f 29 45 c0	 movaps	 XMMWORD PTR _x1$[ebp], xmm0

; 210  :     x0 = _mm_maddubs_epi16(x0, xC_INTERLACE_WEIGHT(i));

  00061	8b 43 08	 mov	 eax, DWORD PTR _i$[ebx]
  00064	c1 e0 05	 shl	 eax, 5
  00067	05 00 00 00 00	 add	 eax, OFFSET ?Array_INTERLACE_WEIGHT@@3QAY0CA@$$CBEA
  0006c	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  0006f	0f 29 45 90	 movaps	 XMMWORD PTR $T11[ebp], xmm0
  00073	0f 28 45 d0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  00077	66 0f 38 04 45
	90		 pmaddubsw xmm0, XMMWORD PTR $T11[ebp]
  0007d	0f 29 45 80	 movaps	 XMMWORD PTR $T10[ebp], xmm0
  00081	0f 28 45 80	 movaps	 xmm0, XMMWORD PTR $T10[ebp]
  00085	0f 29 45 d0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 211  :     x1 = _mm_maddubs_epi16(x1, xC_INTERLACE_WEIGHT(i));

  00089	8b 4b 08	 mov	 ecx, DWORD PTR _i$[ebx]
  0008c	c1 e1 05	 shl	 ecx, 5
  0008f	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?Array_INTERLACE_WEIGHT@@3QAY0CA@$$CBEA
  00095	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00098	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR $T9[ebp], xmm0
  0009f	0f 28 45 c0	 movaps	 xmm0, XMMWORD PTR _x1$[ebp]
  000a3	66 0f 38 04 85
	70 ff ff ff	 pmaddubsw xmm0, XMMWORD PTR $T9[ebp]
  000ac	0f 29 85 60 ff
	ff ff		 movaps	 XMMWORD PTR $T8[ebp], xmm0
  000b3	0f 28 85 60 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T8[ebp]
  000ba	0f 29 45 c0	 movaps	 XMMWORD PTR _x1$[ebp], xmm0

; 212  : #else
; 213  :     __m128i x2, x3, xC[2];
; 214  :     xC[0] = y_up;
; 215  :     xC[1] = y_down;
; 216  :     x0 = _mm_unpacklo_epi8(xC[i], _mm_setzero_si128());
; 217  :     x1 = _mm_unpackhi_epi8(xC[i], _mm_setzero_si128());
; 218  :     x0 = _mm_mullo_epi16(x0, _mm_set1_epi16(3));
; 219  :     x1 = _mm_mullo_epi16(x1, _mm_set1_epi16(3));
; 220  :     x2 = _mm_unpacklo_epi8(xC[(i+1)&0x01], _mm_setzero_si128());
; 221  :     x3 = _mm_unpackhi_epi8(xC[(i+1)&0x01], _mm_setzero_si128());
; 222  :     x0 = _mm_add_epi16(x0, x2);
; 223  :     x1 = _mm_add_epi16(x1, x3);
; 224  : #endif
; 225  :     x0 = _mm_add_epi16(x0, _mm_set1_epi16(2));

  000be	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@00020002000200020002000200020002
  000c5	0f 29 85 50 ff
	ff ff		 movaps	 XMMWORD PTR $T7[ebp], xmm0
  000cc	0f 28 45 d0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  000d0	66 0f fd 85 50
	ff ff ff	 paddw	 xmm0, XMMWORD PTR $T7[ebp]
  000d8	0f 29 85 40 ff
	ff ff		 movaps	 XMMWORD PTR $T6[ebp], xmm0
  000df	0f 28 85 40 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T6[ebp]
  000e6	0f 29 45 d0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 226  :     x1 = _mm_add_epi16(x1, _mm_set1_epi16(2));

  000ea	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@00020002000200020002000200020002
  000f1	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR $T5[ebp], xmm0
  000f8	0f 28 45 c0	 movaps	 xmm0, XMMWORD PTR _x1$[ebp]
  000fc	66 0f fd 85 30
	ff ff ff	 paddw	 xmm0, XMMWORD PTR $T5[ebp]
  00104	0f 29 85 20 ff
	ff ff		 movaps	 XMMWORD PTR $T4[ebp], xmm0
  0010b	0f 28 85 20 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T4[ebp]
  00112	0f 29 45 c0	 movaps	 XMMWORD PTR _x1$[ebp], xmm0

; 227  :     x0 = _mm_srai_epi16(x0, 2);

  00116	0f 28 45 d0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  0011a	66 0f 71 e0 02	 psraw	 xmm0, 2
  0011f	0f 29 85 10 ff
	ff ff		 movaps	 XMMWORD PTR $T3[ebp], xmm0
  00126	0f 28 85 10 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T3[ebp]
  0012d	0f 29 45 d0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 228  :     x1 = _mm_srai_epi16(x1, 2);

  00131	0f 28 45 c0	 movaps	 xmm0, XMMWORD PTR _x1$[ebp]
  00135	66 0f 71 e0 02	 psraw	 xmm0, 2
  0013a	0f 29 85 00 ff
	ff ff		 movaps	 XMMWORD PTR $T2[ebp], xmm0
  00141	0f 28 85 00 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T2[ebp]
  00148	0f 29 45 c0	 movaps	 XMMWORD PTR _x1$[ebp], xmm0

; 229  :     x0 = _mm_packus_epi16(x0, x1);

  0014c	0f 28 45 d0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  00150	66 0f 67 45 c0	 packuswb xmm0, XMMWORD PTR _x1$[ebp]
  00155	0f 29 85 f0 fe
	ff ff		 movaps	 XMMWORD PTR $T1[ebp], xmm0
  0015c	0f 28 85 f0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T1[ebp]
  00163	0f 29 45 d0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 230  :     return x0;

  00167	0f 28 45 d0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]

; 231  : }

  0016b	5f		 pop	 edi
  0016c	8b e5		 mov	 esp, ebp
  0016e	5d		 pop	 ebp
  0016f	8b e3		 mov	 esp, ebx
  00171	5b		 pop	 ebx
  00172	c3		 ret	 0
?yuv422_to_420_i_interpolate@@YA?AT__m128i@@T1@0H@Z ENDP ; yuv422_to_420_i_interpolate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -288						; size = 12
$T2 = -272						; size = 16
$T3 = -256						; size = 16
$T4 = -240						; size = 16
$T5 = -224						; size = 16
$T6 = -208						; size = 16
_x$7 = -180						; size = 4
_x3$8 = -176						; size = 16
_x1$9 = -144						; size = 16
_x0$10 = -112						; size = 16
_x_fin$11 = -80						; size = 4
_pw$12 = -76						; size = 4
_p$13 = -72						; size = 4
_y$14 = -68						; size = 4
_dstCLine$ = -64					; size = 4
_dstYLine$ = -60					; size = 4
_srcLine$ = -56						; size = 4
$T15 = -52						; size = 12
_y_range$ = -36						; size = 12
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuy2_to_nv12_simd@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuy2_to_nv12_simd

; 162  : static void __forceinline convert_yuy2_to_nv12_simd(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 20 01 00
	00		 sub	 esp, 288		; 00000120H
  0001c	57		 push	 edi
  0001d	8d bd e0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-288]
  00023	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 163  :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 164  :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 165  :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 166  :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 167  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  0007c	8b 53 2c	 mov	 edx, DWORD PTR _thread_n$[ebx]
  0007f	52		 push	 edx
  00080	8b 43 28	 mov	 eax, DWORD PTR _thread_id$[ebx]
  00083	50		 push	 eax
  00084	8b 4b 20	 mov	 ecx, DWORD PTR _height$[ebx]
  00087	2b 4d ec	 sub	 ecx, DWORD PTR _crop_bottom$[ebp]
  0008a	51		 push	 ecx
  0008b	8b 55 f4	 mov	 edx, DWORD PTR _crop_up$[ebp]
  0008e	52		 push	 edx
  0008f	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  00095	50		 push	 eax
  00096	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  0009b	83 c4 14	 add	 esp, 20			; 00000014H
  0009e	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a0	89 4d cc	 mov	 DWORD PTR $T15[ebp], ecx
  000a3	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a6	89 55 d0	 mov	 DWORD PTR $T15[ebp+4], edx
  000a9	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000ac	89 45 d4	 mov	 DWORD PTR $T15[ebp+8], eax
  000af	8b 4d cc	 mov	 ecx, DWORD PTR $T15[ebp]
  000b2	89 4d dc	 mov	 DWORD PTR _y_range$[ebp], ecx
  000b5	8b 55 d0	 mov	 edx, DWORD PTR $T15[ebp+4]
  000b8	89 55 e0	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000bb	8b 45 d4	 mov	 eax, DWORD PTR $T15[ebp+8]
  000be	89 45 e4	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 168  :     uint8_t *srcLine = (uint8_t *)src[0] + src_y_pitch_byte * y_range.start_src + crop_left;

  000c1	b9 04 00 00 00	 mov	 ecx, 4
  000c6	6b d1 00	 imul	 edx, ecx, 0
  000c9	8b 43 14	 mov	 eax, DWORD PTR _src_y_pitch_byte$[ebx]
  000cc	0f af 45 dc	 imul	 eax, DWORD PTR _y_range$[ebp]
  000d0	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  000d3	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  000d6	03 d0		 add	 edx, eax
  000d8	03 55 f8	 add	 edx, DWORD PTR _crop_left$[ebp]
  000db	89 55 c8	 mov	 DWORD PTR _srcLine$[ebp], edx

; 169  :     uint8_t *dstYLine = (uint8_t *)dst[0] + dst_y_pitch_byte * y_range.start_dst;

  000de	b8 04 00 00 00	 mov	 eax, 4
  000e3	6b c8 00	 imul	 ecx, eax, 0
  000e6	8b 53 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebx]
  000e9	0f af 55 e0	 imul	 edx, DWORD PTR _y_range$[ebp+4]
  000ed	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  000f0	03 14 08	 add	 edx, DWORD PTR [eax+ecx]
  000f3	89 55 c4	 mov	 DWORD PTR _dstYLine$[ebp], edx

; 170  :     uint8_t *dstCLine = (uint8_t *)dst[1] + dst_y_pitch_byte * (y_range.start_dst >> 1);

  000f6	b9 04 00 00 00	 mov	 ecx, 4
  000fb	c1 e1 00	 shl	 ecx, 0
  000fe	8b 55 e0	 mov	 edx, DWORD PTR _y_range$[ebp+4]
  00101	d1 fa		 sar	 edx, 1
  00103	0f af 53 1c	 imul	 edx, DWORD PTR _dst_y_pitch_byte$[ebx]
  00107	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  0010a	03 14 08	 add	 edx, DWORD PTR [eax+ecx]
  0010d	89 55 c0	 mov	 DWORD PTR _dstCLine$[ebp], edx

; 171  :     for (int y = 0; y < y_range.len; y += 2) {

  00110	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _y$14[ebp], 0
  00117	eb 09		 jmp	 SHORT $LN4@convert_yu
$LN2@convert_yu:
  00119	8b 4d bc	 mov	 ecx, DWORD PTR _y$14[ebp]
  0011c	83 c1 02	 add	 ecx, 2
  0011f	89 4d bc	 mov	 DWORD PTR _y$14[ebp], ecx
$LN4@convert_yu:
  00122	8b 55 bc	 mov	 edx, DWORD PTR _y$14[ebp]
  00125	3b 55 e4	 cmp	 edx, DWORD PTR _y_range$[ebp+8]
  00128	0f 8d 7c 01 00
	00		 jge	 $LN1@convert_yu

; 172  :         uint8_t *p = srcLine;

  0012e	8b 45 c8	 mov	 eax, DWORD PTR _srcLine$[ebp]
  00131	89 45 b8	 mov	 DWORD PTR _p$13[ebp], eax

; 173  :         uint8_t *pw = p + src_y_pitch_byte;

  00134	8b 4d b8	 mov	 ecx, DWORD PTR _p$13[ebp]
  00137	03 4b 14	 add	 ecx, DWORD PTR _src_y_pitch_byte$[ebx]
  0013a	89 4d b4	 mov	 DWORD PTR _pw$12[ebp], ecx

; 174  :         const int x_fin = width - crop_right - crop_left;

  0013d	8b 53 10	 mov	 edx, DWORD PTR _width$[ebx]
  00140	2b 55 f0	 sub	 edx, DWORD PTR _crop_right$[ebp]
  00143	2b 55 f8	 sub	 edx, DWORD PTR _crop_left$[ebp]
  00146	89 55 b0	 mov	 DWORD PTR _x_fin$11[ebp], edx

; 175  :         __m128i x0, x1, x3;
; 176  :         for (int x = 0; x < x_fin; x += 16, p += 32, pw += 32) {

  00149	c7 85 4c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _x$7[ebp], 0
  00153	eb 21		 jmp	 SHORT $LN7@convert_yu
$LN5@convert_yu:
  00155	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _x$7[ebp]
  0015b	83 c0 10	 add	 eax, 16			; 00000010H
  0015e	89 85 4c ff ff
	ff		 mov	 DWORD PTR _x$7[ebp], eax
  00164	8b 4d b8	 mov	 ecx, DWORD PTR _p$13[ebp]
  00167	83 c1 20	 add	 ecx, 32			; 00000020H
  0016a	89 4d b8	 mov	 DWORD PTR _p$13[ebp], ecx
  0016d	8b 55 b4	 mov	 edx, DWORD PTR _pw$12[ebp]
  00170	83 c2 20	 add	 edx, 32			; 00000020H
  00173	89 55 b4	 mov	 DWORD PTR _pw$12[ebp], edx
$LN7@convert_yu:
  00176	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _x$7[ebp]
  0017c	3b 45 b0	 cmp	 eax, DWORD PTR _x_fin$11[ebp]
  0017f	0f 8d ff 00 00
	00		 jge	 $LN6@convert_yu

; 177  :             //-----------1---------------
; 178  :             x0 = _mm_loadu_si128((const __m128i *)(p+ 0));

  00185	8b 4d b8	 mov	 ecx, DWORD PTR _p$13[ebp]
  00188	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  0018b	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR $T6[ebp], xmm0
  00192	0f 28 85 30 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T6[ebp]
  00199	0f 29 45 90	 movaps	 XMMWORD PTR _x0$10[ebp], xmm0

; 179  :             x1 = _mm_loadu_si128((const __m128i *)(p+16));

  0019d	8b 55 b8	 mov	 edx, DWORD PTR _p$13[ebp]
  001a0	83 c2 10	 add	 edx, 16			; 00000010H
  001a3	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  001a6	0f 29 85 20 ff
	ff ff		 movaps	 XMMWORD PTR $T5[ebp], xmm0
  001ad	0f 28 85 20 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T5[ebp]
  001b4	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR _x1$9[ebp], xmm0

; 180  : 
; 181  :             separate_low_up(x0, x1);

  001bb	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR _x1$9[ebp]
  001c1	50		 push	 eax
  001c2	8d 4d 90	 lea	 ecx, DWORD PTR _x0$10[ebp]
  001c5	51		 push	 ecx
  001c6	e8 00 00 00 00	 call	 ?separate_low_up@@YAXAAT__m128i@@0@Z ; separate_low_up
  001cb	83 c4 08	 add	 esp, 8

; 182  :             x3 = x1;

  001ce	0f 28 85 70 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$9[ebp]
  001d5	0f 29 85 50 ff
	ff ff		 movaps	 XMMWORD PTR _x3$8[ebp], xmm0

; 183  : 
; 184  :             _mm_store_si128((__m128i *)(dstYLine + x), x0);

  001dc	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR _x0$10[ebp]
  001e0	8b 55 c4	 mov	 edx, DWORD PTR _dstYLine$[ebp]
  001e3	03 95 4c ff ff
	ff		 add	 edx, DWORD PTR _x$7[ebp]
  001e9	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 185  :             //-----------1---------------
; 186  : 
; 187  :             //-----------2---------------
; 188  :             x0 = _mm_loadu_si128((const __m128i *)(pw+ 0));

  001ec	8b 45 b4	 mov	 eax, DWORD PTR _pw$12[ebp]
  001ef	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  001f2	0f 29 85 10 ff
	ff ff		 movaps	 XMMWORD PTR $T4[ebp], xmm0
  001f9	0f 28 85 10 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T4[ebp]
  00200	0f 29 45 90	 movaps	 XMMWORD PTR _x0$10[ebp], xmm0

; 189  :             x1 = _mm_loadu_si128((const __m128i *)(pw+16));

  00204	8b 4d b4	 mov	 ecx, DWORD PTR _pw$12[ebp]
  00207	83 c1 10	 add	 ecx, 16			; 00000010H
  0020a	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  0020d	0f 29 85 00 ff
	ff ff		 movaps	 XMMWORD PTR $T3[ebp], xmm0
  00214	0f 28 85 00 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T3[ebp]
  0021b	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR _x1$9[ebp], xmm0

; 190  : 
; 191  :             separate_low_up(x0, x1);

  00222	8d 95 70 ff ff
	ff		 lea	 edx, DWORD PTR _x1$9[ebp]
  00228	52		 push	 edx
  00229	8d 45 90	 lea	 eax, DWORD PTR _x0$10[ebp]
  0022c	50		 push	 eax
  0022d	e8 00 00 00 00	 call	 ?separate_low_up@@YAXAAT__m128i@@0@Z ; separate_low_up
  00232	83 c4 08	 add	 esp, 8

; 192  : 
; 193  :             _mm_store_si128((__m128i *)(dstYLine + dst_y_pitch_byte + x), x0);

  00235	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR _x0$10[ebp]
  00239	8b 4d c4	 mov	 ecx, DWORD PTR _dstYLine$[ebp]
  0023c	03 4b 1c	 add	 ecx, DWORD PTR _dst_y_pitch_byte$[ebx]
  0023f	03 8d 4c ff ff
	ff		 add	 ecx, DWORD PTR _x$7[ebp]
  00245	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 194  :             //-----------2---------------
; 195  : 
; 196  :             x1 = _mm_avg_epu8(x1, x3);

  00248	0f 28 85 70 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$9[ebp]
  0024f	66 0f e0 85 50
	ff ff ff	 pavgb	 xmm0, XMMWORD PTR _x3$8[ebp]
  00257	0f 29 85 f0 fe
	ff ff		 movaps	 XMMWORD PTR $T2[ebp], xmm0
  0025e	0f 28 85 f0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR $T2[ebp]
  00265	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR _x1$9[ebp], xmm0

; 197  :             _mm_store_si128((__m128i *)(dstCLine + x), x1);

  0026c	0f 28 85 70 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x1$9[ebp]
  00273	8b 55 c0	 mov	 edx, DWORD PTR _dstCLine$[ebp]
  00276	03 95 4c ff ff
	ff		 add	 edx, DWORD PTR _x$7[ebp]
  0027c	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 198  :         }

  0027f	e9 d1 fe ff ff	 jmp	 $LN5@convert_yu
$LN6@convert_yu:

; 199  :         srcLine  += src_y_pitch_byte << 1;

  00284	8b 43 14	 mov	 eax, DWORD PTR _src_y_pitch_byte$[ebx]
  00287	8b 4d c8	 mov	 ecx, DWORD PTR _srcLine$[ebp]
  0028a	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  0028d	89 55 c8	 mov	 DWORD PTR _srcLine$[ebp], edx

; 200  :         dstYLine += dst_y_pitch_byte << 1;

  00290	8b 43 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  00293	8b 4d c4	 mov	 ecx, DWORD PTR _dstYLine$[ebp]
  00296	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00299	89 55 c4	 mov	 DWORD PTR _dstYLine$[ebp], edx

; 201  :         dstCLine += dst_y_pitch_byte;

  0029c	8b 45 c0	 mov	 eax, DWORD PTR _dstCLine$[ebp]
  0029f	03 43 1c	 add	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  002a2	89 45 c0	 mov	 DWORD PTR _dstCLine$[ebp], eax

; 202  :     }

  002a5	e9 6f fe ff ff	 jmp	 $LN2@convert_yu
$LN1@convert_yu:

; 203  : }

  002aa	52		 push	 edx
  002ab	8b cd		 mov	 ecx, ebp
  002ad	50		 push	 eax
  002ae	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN13@convert_yu
  002b4	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  002b9	58		 pop	 eax
  002ba	5a		 pop	 edx
  002bb	5f		 pop	 edi
  002bc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002bf	33 cd		 xor	 ecx, ebp
  002c1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002c6	8b e5		 mov	 esp, ebp
  002c8	5d		 pop	 ebp
  002c9	8b e3		 mov	 esp, ebx
  002cb	5b		 pop	 ebx
  002cc	c3		 ret	 0
  002cd	0f 1f 00	 npad	 3
$LN13@convert_yu:
  002d0	03 00 00 00	 DD	 3
  002d4	00 00 00 00	 DD	 $LN12@convert_yu
$LN12@convert_yu:
  002d8	dc ff ff ff	 DD	 -36			; ffffffdcH
  002dc	0c 00 00 00	 DD	 12			; 0000000cH
  002e0	00 00 00 00	 DD	 $LN9@convert_yu
  002e4	90 ff ff ff	 DD	 -112			; ffffff90H
  002e8	10 00 00 00	 DD	 16			; 00000010H
  002ec	00 00 00 00	 DD	 $LN10@convert_yu
  002f0	70 ff ff ff	 DD	 -144			; ffffff70H
  002f4	10 00 00 00	 DD	 16			; 00000010H
  002f8	00 00 00 00	 DD	 $LN11@convert_yu
$LN11@convert_yu:
  002fc	78		 DB	 120			; 00000078H
  002fd	31		 DB	 49			; 00000031H
  002fe	00		 DB	 0
$LN10@convert_yu:
  002ff	78		 DB	 120			; 00000078H
  00300	30		 DB	 48			; 00000030H
  00301	00		 DB	 0
$LN9@convert_yu:
  00302	79		 DB	 121			; 00000079H
  00303	5f		 DB	 95			; 0000005fH
  00304	72		 DB	 114			; 00000072H
  00305	61		 DB	 97			; 00000061H
  00306	6e		 DB	 110			; 0000006eH
  00307	67		 DB	 103			; 00000067H
  00308	65		 DB	 101			; 00000065H
  00309	00		 DB	 0
?convert_yuy2_to_nv12_simd@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuy2_to_nv12_simd
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -208						; size = 16
$T2 = -192						; size = 16
$T3 = -176						; size = 16
$T4 = -160						; size = 16
$T5 = -144						; size = 16
$T6 = -128						; size = 16
$T7 = -112						; size = 16
$T8 = -96						; size = 16
$T9 = -80						; size = 16
$T10 = -64						; size = 16
_xMaskLowByte$ = -48					; size = 16
_x5$ = -32						; size = 16
_x4$ = -16						; size = 16
_x0_return_lower$ = 8					; size = 4
_x1_return_upper$ = 12					; size = 4
?separate_low_up@@YAXAAT__m128i@@0@Z PROC		; separate_low_up

; 146  : static __forceinline void separate_low_up(__m128i& x0_return_lower, __m128i& x1_return_upper) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  0001c	57		 push	 edi
  0001d	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00023	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd

; 147  :     __m128i x4, x5;
; 148  :     const __m128i xMaskLowByte = _mm_srli_epi16(_mm_cmpeq_epi8(_mm_setzero_si128(), _mm_setzero_si128()), 8);

  0002f	0f 57 c0	 xorps	 xmm0, xmm0
  00032	0f 29 45 b0	 movaps	 XMMWORD PTR $T9[ebp], xmm0
  00036	0f 57 c0	 xorps	 xmm0, xmm0
  00039	0f 29 45 c0	 movaps	 XMMWORD PTR $T10[ebp], xmm0
  0003d	0f 28 45 c0	 movaps	 xmm0, XMMWORD PTR $T10[ebp]
  00041	66 0f 74 45 b0	 pcmpeqb xmm0, XMMWORD PTR $T9[ebp]
  00046	0f 29 45 a0	 movaps	 XMMWORD PTR $T8[ebp], xmm0
  0004a	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR $T8[ebp]
  0004e	66 0f 71 d0 08	 psrlw	 xmm0, 8
  00053	0f 29 45 90	 movaps	 XMMWORD PTR $T7[ebp], xmm0
  00057	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR $T7[ebp]
  0005b	0f 29 45 d0	 movaps	 XMMWORD PTR _xMaskLowByte$[ebp], xmm0

; 149  :     x4 = _mm_srli_epi16(x0_return_lower, 8);

  0005f	8b 43 08	 mov	 eax, DWORD PTR _x0_return_lower$[ebx]
  00062	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00065	66 0f 71 d0 08	 psrlw	 xmm0, 8
  0006a	0f 29 45 80	 movaps	 XMMWORD PTR $T6[ebp], xmm0
  0006e	0f 28 45 80	 movaps	 xmm0, XMMWORD PTR $T6[ebp]
  00072	0f 29 45 f0	 movaps	 XMMWORD PTR _x4$[ebp], xmm0

; 150  :     x5 = _mm_srli_epi16(x1_return_upper, 8);

  00076	8b 4b 0c	 mov	 ecx, DWORD PTR _x1_return_upper$[ebx]
  00079	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  0007c	66 0f 71 d0 08	 psrlw	 xmm0, 8
  00081	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR $T5[ebp], xmm0
  00088	0f 28 85 70 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T5[ebp]
  0008f	0f 29 45 e0	 movaps	 XMMWORD PTR _x5$[ebp], xmm0

; 151  : 
; 152  :     x0_return_lower = _mm_and_si128(x0_return_lower, xMaskLowByte);

  00093	8b 53 08	 mov	 edx, DWORD PTR _x0_return_lower$[ebx]
  00096	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  00099	66 0f db 45 d0	 pand	 xmm0, XMMWORD PTR _xMaskLowByte$[ebp]
  0009e	0f 29 85 60 ff
	ff ff		 movaps	 XMMWORD PTR $T4[ebp], xmm0
  000a5	8b 43 08	 mov	 eax, DWORD PTR _x0_return_lower$[ebx]
  000a8	0f 10 85 60 ff
	ff ff		 movups	 xmm0, XMMWORD PTR $T4[ebp]
  000af	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 153  :     x1_return_upper = _mm_and_si128(x1_return_upper, xMaskLowByte);

  000b2	8b 4b 0c	 mov	 ecx, DWORD PTR _x1_return_upper$[ebx]
  000b5	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  000b8	66 0f db 45 d0	 pand	 xmm0, XMMWORD PTR _xMaskLowByte$[ebp]
  000bd	0f 29 85 50 ff
	ff ff		 movaps	 XMMWORD PTR $T3[ebp], xmm0
  000c4	8b 53 0c	 mov	 edx, DWORD PTR _x1_return_upper$[ebx]
  000c7	0f 10 85 50 ff
	ff ff		 movups	 xmm0, XMMWORD PTR $T3[ebp]
  000ce	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 154  : 
; 155  :     x0_return_lower = _mm_packus_epi16(x0_return_lower, x1_return_upper);

  000d1	8b 43 0c	 mov	 eax, DWORD PTR _x1_return_upper$[ebx]
  000d4	8b 4b 08	 mov	 ecx, DWORD PTR _x0_return_lower$[ebx]
  000d7	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  000da	66 0f 67 00	 packuswb xmm0, XMMWORD PTR [eax]
  000de	0f 29 85 40 ff
	ff ff		 movaps	 XMMWORD PTR $T2[ebp], xmm0
  000e5	8b 53 08	 mov	 edx, DWORD PTR _x0_return_lower$[ebx]
  000e8	0f 10 85 40 ff
	ff ff		 movups	 xmm0, XMMWORD PTR $T2[ebp]
  000ef	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 156  :     x1_return_upper = _mm_packus_epi16(x4, x5);

  000f2	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _x4$[ebp]
  000f6	66 0f 67 45 e0	 packuswb xmm0, XMMWORD PTR _x5$[ebp]
  000fb	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR $T1[ebp], xmm0
  00102	8b 43 0c	 mov	 eax, DWORD PTR _x1_return_upper$[ebx]
  00105	0f 10 85 30 ff
	ff ff		 movups	 xmm0, XMMWORD PTR $T1[ebp]
  0010c	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 157  : }

  0010f	5f		 pop	 edi
  00110	8b e5		 mov	 esp, ebp
  00112	5d		 pop	 ebp
  00113	8b e3		 mov	 esp, ebx
  00115	5b		 pop	 ebx
  00116	c3		 ret	 0
?separate_low_up@@YAXAAT__m128i@@0@Z ENDP		; separate_low_up
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -48						; size = 16
_b$ = -32						; size = 16
_a$ = -16						; size = 16
?_mm_packus_epi32_simd@@YA?AT__m128i@@T1@0@Z PROC	; _mm_packus_epi32_simd
; _a$ = xmm0
; _b$ = xmm1

; 98   : static __forceinline __m128i _mm_packus_epi32_simd(__m128i a, __m128i b) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	83 ec 30	 sub	 esp, 48			; 00000030H
  00019	57		 push	 edi
  0001a	8d 7d d0	 lea	 edi, DWORD PTR [ebp-48]
  0001d	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  00022	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00027	f3 ab		 rep stosd
  00029	0f 29 4d e0	 movaps	 XMMWORD PTR _b$[ebp], xmm1
  0002d	0f 29 45 f0	 movaps	 XMMWORD PTR _a$[ebp], xmm0

; 99   : #if USE_SSE41
; 100  :     return _mm_packus_epi32(a, b);

  00031	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR _a$[ebp]
  00035	66 0f 38 2b 45
	e0		 packusdw xmm0, XMMWORD PTR _b$[ebp]
  0003b	0f 29 45 d0	 movaps	 XMMWORD PTR $T1[ebp], xmm0
  0003f	0f 28 45 d0	 movaps	 xmm0, XMMWORD PTR $T1[ebp]

; 101  : #else
; 102  :     alignas(64) static const uint32_t VAL[2][4] = {
; 103  :         { 0x00008000, 0x00008000, 0x00008000, 0x00008000 },
; 104  :         { 0x80008000, 0x80008000, 0x80008000, 0x80008000 }
; 105  :     };
; 106  : #define LOAD_32BIT_0x8000 _mm_load_si128((__m128i *)VAL[0])
; 107  : #define LOAD_16BIT_0x8000 _mm_load_si128((__m128i *)VAL[1])
; 108  :     a = _mm_sub_epi32(a, LOAD_32BIT_0x8000);
; 109  :     b = _mm_sub_epi32(b, LOAD_32BIT_0x8000);
; 110  :     a = _mm_packs_epi32(a, b);
; 111  :     return _mm_add_epi16(a, LOAD_16BIT_0x8000);
; 112  : #undef LOAD_32BIT_0x8000
; 113  : #undef LOAD_16BIT_0x8000
; 114  : #endif
; 115  : }

  00043	5f		 pop	 edi
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	8b e3		 mov	 esp, ebx
  00049	5b		 pop	 ebx
  0004a	c3		 ret	 0
?_mm_packus_epi32_simd@@YA?AT__m128i@@T1@0@Z ENDP	; _mm_packus_epi32_simd
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_simd.h
_TEXT	SEGMENT
$T1 = -256						; size = 16
$T2 = -240						; size = 16
$T3 = -224						; size = 16
$T4 = -208						; size = 16
_dst_tmp$ = -180					; size = 4
$T5 = -176						; size = 16
$T6 = -160						; size = 16
$T7 = -144						; size = 16
$T8 = -128						; size = 16
$T9 = -112						; size = 16
_start_align_diff$ = -84				; size = 4
_x3$ = -80						; size = 16
_x2$ = -64						; size = 16
_x1$ = -48						; size = 16
_x0$ = -32						; size = 16
_dst_aligned_fin$ = -12					; size = 4
_dst_fin$ = -8						; size = 4
_i$10 = -4						; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_size$ = 16						; size = 4
?memcpy_sse@@YAXPAEPBEH@Z PROC				; memcpy_sse

; 44   : static void __forceinline memcpy_sse(uint8_t *dst, const uint8_t *src, int size) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 00 01 00
	00		 sub	 esp, 256		; 00000100H
  0001c	57		 push	 edi
  0001d	8d bd 00 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-256]
  00023	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd

; 45   :     if (size < 64) {

  0002f	83 7b 10 40	 cmp	 DWORD PTR _size$[ebx], 64 ; 00000040H
  00033	7d 31		 jge	 SHORT $LN8@memcpy_sse

; 46   :         for (int i = 0; i < size; i++)

  00035	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$10[ebp], 0
  0003c	eb 09		 jmp	 SHORT $LN4@memcpy_sse
$LN2@memcpy_sse:
  0003e	8b 45 fc	 mov	 eax, DWORD PTR _i$10[ebp]
  00041	83 c0 01	 add	 eax, 1
  00044	89 45 fc	 mov	 DWORD PTR _i$10[ebp], eax
$LN4@memcpy_sse:
  00047	8b 4d fc	 mov	 ecx, DWORD PTR _i$10[ebp]
  0004a	3b 4b 10	 cmp	 ecx, DWORD PTR _size$[ebx]
  0004d	7d 12		 jge	 SHORT $LN3@memcpy_sse

; 47   :             dst[i] = src[i];

  0004f	8b 53 08	 mov	 edx, DWORD PTR _dst$[ebx]
  00052	03 55 fc	 add	 edx, DWORD PTR _i$10[ebp]
  00055	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  00058	03 45 fc	 add	 eax, DWORD PTR _i$10[ebp]
  0005b	8a 08		 mov	 cl, BYTE PTR [eax]
  0005d	88 0a		 mov	 BYTE PTR [edx], cl
  0005f	eb dd		 jmp	 SHORT $LN2@memcpy_sse
$LN3@memcpy_sse:

; 48   :         return;

  00061	e9 d7 01 00 00	 jmp	 $LN1@memcpy_sse
$LN8@memcpy_sse:

; 49   :     }
; 50   :     uint8_t *dst_fin = dst + size;

  00066	8b 53 08	 mov	 edx, DWORD PTR _dst$[ebx]
  00069	03 53 10	 add	 edx, DWORD PTR _size$[ebx]
  0006c	89 55 f8	 mov	 DWORD PTR _dst_fin$[ebp], edx

; 51   :     uint8_t *dst_aligned_fin = (uint8_t *)(((size_t)(dst_fin + 15) & ~15) - 64);

  0006f	8b 45 f8	 mov	 eax, DWORD PTR _dst_fin$[ebp]
  00072	83 c0 0f	 add	 eax, 15			; 0000000fH
  00075	83 e0 f0	 and	 eax, -16		; fffffff0H
  00078	83 e8 40	 sub	 eax, 64			; 00000040H
  0007b	89 45 f4	 mov	 DWORD PTR _dst_aligned_fin$[ebp], eax

; 52   :     __m128 x0, x1, x2, x3;
; 53   :     const int start_align_diff = (int)((size_t)dst & 15);

  0007e	8b 4b 08	 mov	 ecx, DWORD PTR _dst$[ebx]
  00081	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00084	89 4d ac	 mov	 DWORD PTR _start_align_diff$[ebp], ecx

; 54   :     if (start_align_diff) {

  00087	74 38		 je	 SHORT $LN9@memcpy_sse

; 55   :         x0 = _mm_loadu_ps((float*)src);

  00089	8b 53 0c	 mov	 edx, DWORD PTR _src$[ebx]
  0008c	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  0008f	0f 29 45 90	 movaps	 XMMWORD PTR $T9[ebp], xmm0
  00093	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR $T9[ebp]
  00097	0f 29 45 e0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 56   :         _mm_storeu_ps((float*)dst, x0);

  0009b	0f 10 45 e0	 movups	 xmm0, XMMWORD PTR _x0$[ebp]
  0009f	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  000a2	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 57   :         dst += 16 - start_align_diff;

  000a5	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  000aa	2b 4d ac	 sub	 ecx, DWORD PTR _start_align_diff$[ebp]
  000ad	03 4b 08	 add	 ecx, DWORD PTR _dst$[ebx]
  000b0	89 4b 08	 mov	 DWORD PTR _dst$[ebx], ecx

; 58   :         src += 16 - start_align_diff;

  000b3	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  000b8	2b 55 ac	 sub	 edx, DWORD PTR _start_align_diff$[ebp]
  000bb	03 53 0c	 add	 edx, DWORD PTR _src$[ebx]
  000be	89 53 0c	 mov	 DWORD PTR _src$[ebx], edx
$LN9@memcpy_sse:

; 59   :     }
; 60   :     for ( ; dst < dst_aligned_fin; dst += 64, src += 64) {

  000c1	eb 12		 jmp	 SHORT $LN7@memcpy_sse
$LN5@memcpy_sse:
  000c3	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  000c6	83 c0 40	 add	 eax, 64			; 00000040H
  000c9	89 43 08	 mov	 DWORD PTR _dst$[ebx], eax
  000cc	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  000cf	83 c1 40	 add	 ecx, 64			; 00000040H
  000d2	89 4b 0c	 mov	 DWORD PTR _src$[ebx], ecx
$LN7@memcpy_sse:
  000d5	8b 53 08	 mov	 edx, DWORD PTR _dst$[ebx]
  000d8	3b 55 f4	 cmp	 edx, DWORD PTR _dst_aligned_fin$[ebp]
  000db	0f 83 99 00 00
	00		 jae	 $LN6@memcpy_sse

; 61   :         x0 = _mm_loadu_ps((float*)(src +  0));

  000e1	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  000e4	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  000e7	0f 29 45 80	 movaps	 XMMWORD PTR $T8[ebp], xmm0
  000eb	0f 28 45 80	 movaps	 xmm0, XMMWORD PTR $T8[ebp]
  000ef	0f 29 45 e0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 62   :         x1 = _mm_loadu_ps((float*)(src + 16));

  000f3	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  000f6	83 c1 10	 add	 ecx, 16			; 00000010H
  000f9	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  000fc	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR $T7[ebp], xmm0
  00103	0f 28 85 70 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T7[ebp]
  0010a	0f 29 45 d0	 movaps	 XMMWORD PTR _x1$[ebp], xmm0

; 63   :         x2 = _mm_loadu_ps((float*)(src + 32));

  0010e	8b 53 0c	 mov	 edx, DWORD PTR _src$[ebx]
  00111	83 c2 20	 add	 edx, 32			; 00000020H
  00114	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  00117	0f 29 85 60 ff
	ff ff		 movaps	 XMMWORD PTR $T6[ebp], xmm0
  0011e	0f 28 85 60 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T6[ebp]
  00125	0f 29 45 c0	 movaps	 XMMWORD PTR _x2$[ebp], xmm0

; 64   :         x3 = _mm_loadu_ps((float*)(src + 48));

  00129	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  0012c	83 c0 30	 add	 eax, 48			; 00000030H
  0012f	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00132	0f 29 85 50 ff
	ff ff		 movaps	 XMMWORD PTR $T5[ebp], xmm0
  00139	0f 28 85 50 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T5[ebp]
  00140	0f 29 45 b0	 movaps	 XMMWORD PTR _x3$[ebp], xmm0

; 65   :         _mm_store_ps((float*)(dst +  0), x0);

  00144	0f 28 45 e0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  00148	8b 4b 08	 mov	 ecx, DWORD PTR _dst$[ebx]
  0014b	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 66   :         _mm_store_ps((float*)(dst + 16), x1);

  0014e	0f 28 45 d0	 movaps	 xmm0, XMMWORD PTR _x1$[ebp]
  00152	8b 53 08	 mov	 edx, DWORD PTR _dst$[ebx]
  00155	83 c2 10	 add	 edx, 16			; 00000010H
  00158	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 67   :         _mm_store_ps((float*)(dst + 32), x2);

  0015b	0f 28 45 c0	 movaps	 xmm0, XMMWORD PTR _x2$[ebp]
  0015f	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  00162	83 c0 20	 add	 eax, 32			; 00000020H
  00165	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 68   :         _mm_store_ps((float*)(dst + 48), x3);

  00168	0f 28 45 b0	 movaps	 xmm0, XMMWORD PTR _x3$[ebp]
  0016c	8b 4b 08	 mov	 ecx, DWORD PTR _dst$[ebx]
  0016f	83 c1 30	 add	 ecx, 48			; 00000030H
  00172	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 69   :     }

  00175	e9 49 ff ff ff	 jmp	 $LN5@memcpy_sse
$LN6@memcpy_sse:

; 70   :     uint8_t *dst_tmp = dst_fin - 64;

  0017a	8b 55 f8	 mov	 edx, DWORD PTR _dst_fin$[ebp]
  0017d	83 ea 40	 sub	 edx, 64			; 00000040H
  00180	89 95 4c ff ff
	ff		 mov	 DWORD PTR _dst_tmp$[ebp], edx

; 71   :     src -= (dst - dst_tmp);

  00186	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  00189	2b 85 4c ff ff
	ff		 sub	 eax, DWORD PTR _dst_tmp$[ebp]
  0018f	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  00192	2b c8		 sub	 ecx, eax
  00194	89 4b 0c	 mov	 DWORD PTR _src$[ebx], ecx

; 72   :     x0 = _mm_loadu_ps((float*)(src +  0));

  00197	8b 53 0c	 mov	 edx, DWORD PTR _src$[ebx]
  0019a	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  0019d	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR $T4[ebp], xmm0
  001a4	0f 28 85 30 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T4[ebp]
  001ab	0f 29 45 e0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 73   :     x1 = _mm_loadu_ps((float*)(src + 16));

  001af	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  001b2	83 c0 10	 add	 eax, 16			; 00000010H
  001b5	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  001b8	0f 29 85 20 ff
	ff ff		 movaps	 XMMWORD PTR $T3[ebp], xmm0
  001bf	0f 28 85 20 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T3[ebp]
  001c6	0f 29 45 d0	 movaps	 XMMWORD PTR _x1$[ebp], xmm0

; 74   :     x2 = _mm_loadu_ps((float*)(src + 32));

  001ca	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  001cd	83 c1 20	 add	 ecx, 32			; 00000020H
  001d0	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  001d3	0f 29 85 10 ff
	ff ff		 movaps	 XMMWORD PTR $T2[ebp], xmm0
  001da	0f 28 85 10 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T2[ebp]
  001e1	0f 29 45 c0	 movaps	 XMMWORD PTR _x2$[ebp], xmm0

; 75   :     x3 = _mm_loadu_ps((float*)(src + 48));

  001e5	8b 53 0c	 mov	 edx, DWORD PTR _src$[ebx]
  001e8	83 c2 30	 add	 edx, 48			; 00000030H
  001eb	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  001ee	0f 29 85 00 ff
	ff ff		 movaps	 XMMWORD PTR $T1[ebp], xmm0
  001f5	0f 28 85 00 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T1[ebp]
  001fc	0f 29 45 b0	 movaps	 XMMWORD PTR _x3$[ebp], xmm0

; 76   :     _mm_storeu_ps((float*)(dst_tmp +  0), x0);

  00200	0f 10 45 e0	 movups	 xmm0, XMMWORD PTR _x0$[ebp]
  00204	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _dst_tmp$[ebp]
  0020a	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 77   :     _mm_storeu_ps((float*)(dst_tmp + 16), x1);

  0020d	0f 10 45 d0	 movups	 xmm0, XMMWORD PTR _x1$[ebp]
  00211	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _dst_tmp$[ebp]
  00217	83 c1 10	 add	 ecx, 16			; 00000010H
  0021a	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 78   :     _mm_storeu_ps((float*)(dst_tmp + 32), x2);

  0021d	0f 10 45 c0	 movups	 xmm0, XMMWORD PTR _x2$[ebp]
  00221	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR _dst_tmp$[ebp]
  00227	83 c2 20	 add	 edx, 32			; 00000020H
  0022a	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 79   :     _mm_storeu_ps((float*)(dst_tmp + 48), x3);

  0022d	0f 10 45 b0	 movups	 xmm0, XMMWORD PTR _x3$[ebp]
  00231	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _dst_tmp$[ebp]
  00237	83 c0 30	 add	 eax, 48			; 00000030H
  0023a	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0
$LN1@memcpy_sse:

; 80   : }

  0023d	5f		 pop	 edi
  0023e	8b e5		 mov	 esp, ebp
  00240	5d		 pop	 ebp
  00241	8b e3		 mov	 esp, ebx
  00243	5b		 pop	 ebx
  00244	c3		 ret	 0
?memcpy_sse@@YAXPAEPBEH@Z ENDP				; memcpy_sse
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.h
_TEXT	SEGMENT
_y1$ = -36						; size = 4
_y0$ = -32						; size = 4
_y_range$ = -24						; size = 12
_h$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
$T1 = 8							; size = 4
_y_start$ = 12						; size = 4
_y_end$ = 16						; size = 4
_thread_id$ = 20					; size = 4
_thread_n$ = 24						; size = 4
?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z PROC	; thread_y_range

; 375  : static inline THREAD_Y_RANGE thread_y_range(int y_start, int y_end, int thread_id, int thread_n) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 dc	 mov	 DWORD PTR [ebp-36], eax
  0000e	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  00011	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  00014	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00017	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0001a	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0001d	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00020	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00023	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002b	33 c5		 xor	 eax, ebp
  0002d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 376  :     const int h = y_end - y_start;

  00030	8b 45 10	 mov	 eax, DWORD PTR _y_end$[ebp]
  00033	2b 45 0c	 sub	 eax, DWORD PTR _y_start$[ebp]
  00036	89 45 f8	 mov	 DWORD PTR _h$[ebp], eax

; 377  :     THREAD_Y_RANGE y_range;
; 378  :     int y0 = ((((h *  thread_id)    / thread_n) + 3) & ~3);

  00039	8b 45 f8	 mov	 eax, DWORD PTR _h$[ebp]
  0003c	0f af 45 14	 imul	 eax, DWORD PTR _thread_id$[ebp]
  00040	99		 cdq
  00041	f7 7d 18	 idiv	 DWORD PTR _thread_n$[ebp]
  00044	83 c0 03	 add	 eax, 3
  00047	83 e0 fc	 and	 eax, -4			; fffffffcH
  0004a	89 45 e0	 mov	 DWORD PTR _y0$[ebp], eax

; 379  :     int y1 = ((((h * (thread_id+1)) / thread_n) + 3) & ~3);

  0004d	8b 4d 14	 mov	 ecx, DWORD PTR _thread_id$[ebp]
  00050	83 c1 01	 add	 ecx, 1
  00053	8b c1		 mov	 eax, ecx
  00055	0f af 45 f8	 imul	 eax, DWORD PTR _h$[ebp]
  00059	99		 cdq
  0005a	f7 7d 18	 idiv	 DWORD PTR _thread_n$[ebp]
  0005d	83 c0 03	 add	 eax, 3
  00060	83 e0 fc	 and	 eax, -4			; fffffffcH
  00063	89 45 dc	 mov	 DWORD PTR _y1$[ebp], eax

; 380  :     if (y1 > h) {

  00066	8b 55 dc	 mov	 edx, DWORD PTR _y1$[ebp]
  00069	3b 55 f8	 cmp	 edx, DWORD PTR _h$[ebp]
  0006c	7e 06		 jle	 SHORT $LN2@thread_y_r

; 381  :         y1 = h;

  0006e	8b 45 f8	 mov	 eax, DWORD PTR _h$[ebp]
  00071	89 45 dc	 mov	 DWORD PTR _y1$[ebp], eax
$LN2@thread_y_r:

; 382  :     }
; 383  :     y_range.start_src = y_start + y0;

  00074	8b 4d 0c	 mov	 ecx, DWORD PTR _y_start$[ebp]
  00077	03 4d e0	 add	 ecx, DWORD PTR _y0$[ebp]
  0007a	89 4d e8	 mov	 DWORD PTR _y_range$[ebp], ecx

; 384  :     y_range.start_dst = y0;

  0007d	8b 55 e0	 mov	 edx, DWORD PTR _y0$[ebp]
  00080	89 55 ec	 mov	 DWORD PTR _y_range$[ebp+4], edx

; 385  :     y_range.len = y1 - y0;

  00083	8b 45 dc	 mov	 eax, DWORD PTR _y1$[ebp]
  00086	2b 45 e0	 sub	 eax, DWORD PTR _y0$[ebp]
  00089	89 45 f0	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 386  :     return y_range;

  0008c	8b 4d 08	 mov	 ecx, DWORD PTR $T1[ebp]
  0008f	8b 55 e8	 mov	 edx, DWORD PTR _y_range$[ebp]
  00092	89 11		 mov	 DWORD PTR [ecx], edx
  00094	8b 45 ec	 mov	 eax, DWORD PTR _y_range$[ebp+4]
  00097	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0009a	8b 55 f0	 mov	 edx, DWORD PTR _y_range$[ebp+8]
  0009d	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  000a0	8b 45 08	 mov	 eax, DWORD PTR $T1[ebp]

; 387  : }

  000a3	52		 push	 edx
  000a4	8b cd		 mov	 ecx, ebp
  000a6	50		 push	 eax
  000a7	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN6@thread_y_r
  000ad	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000b2	58		 pop	 eax
  000b3	5a		 pop	 edx
  000b4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b7	33 cd		 xor	 ecx, ebp
  000b9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000be	8b e5		 mov	 esp, ebp
  000c0	5d		 pop	 ebp
  000c1	c3		 ret	 0
  000c2	66 90		 npad	 2
$LN6@thread_y_r:
  000c4	01 00 00 00	 DD	 1
  000c8	00 00 00 00	 DD	 $LN5@thread_y_r
$LN5@thread_y_r:
  000cc	e8 ff ff ff	 DD	 -24			; ffffffe8H
  000d0	0c 00 00 00	 DD	 12			; 0000000cH
  000d4	00 00 00 00	 DD	 $LN4@thread_y_r
$LN4@thread_y_r:
  000d8	79		 DB	 121			; 00000079H
  000d9	5f		 DB	 95			; 0000005fH
  000da	72		 DB	 114			; 00000072H
  000db	61		 DB	 97			; 00000061H
  000dc	6e		 DB	 110			; 0000006eH
  000dd	67		 DB	 103			; 00000067H
  000de	65		 DB	 101			; 00000065H
  000df	00		 DB	 0
?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ENDP	; thread_y_range
_TEXT	ENDS
END
