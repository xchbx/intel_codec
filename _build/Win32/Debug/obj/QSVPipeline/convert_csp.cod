; Listing generated by Microsoft (R) Optimizing Compiler Version 19.23.28106.4 

	TITLE	D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?convert_yuy2_to_nv12@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuy2_to_nv12
EXTRN	?copy_nv12_to_nv12_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; copy_nv12_to_nv12_sse2
EXTRN	?copy_p010_to_p010_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; copy_p010_to_p010_sse2
EXTRN	?copy_nv12_to_nv12_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; copy_nv12_to_nv12_avx2
EXTRN	?copy_p010_to_p010_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; copy_p010_to_p010_avx2
EXTRN	?convert_yuy2_to_nv12_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yuy2_to_nv12_sse2
EXTRN	?convert_yuy2_to_nv12_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yuy2_to_nv12_avx
EXTRN	?convert_yuy2_to_nv12_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yuy2_to_nv12_avx2
EXTRN	?convert_yuy2_to_nv12_i_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yuy2_to_nv12_i_sse2
EXTRN	?convert_yuy2_to_nv12_i_ssse3@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yuy2_to_nv12_i_ssse3
EXTRN	?convert_yuy2_to_nv12_i_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yuy2_to_nv12_i_avx
EXTRN	?convert_yuy2_to_nv12_i_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yuy2_to_nv12_i_avx2
EXTRN	?convert_yv12_to_nv12_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yv12_to_nv12_sse2
EXTRN	?convert_yv12_to_nv12_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yv12_to_nv12_avx
EXTRN	?convert_yv12_to_nv12_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yv12_to_nv12_avx2
EXTRN	?convert_uv_yv12_to_nv12_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_uv_yv12_to_nv12_sse2
EXTRN	?convert_uv_yv12_to_nv12_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_uv_yv12_to_nv12_avx
EXTRN	?convert_uv_yv12_to_nv12_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_uv_yv12_to_nv12_avx2
EXTRN	?convert_rgb24_to_rgb_ssse3@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_rgb24_to_rgb_ssse3
EXTRN	?convert_bgr24_to_rgb_ssse3@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_bgr24_to_rgb_ssse3
EXTRN	?convert_rgb24r_to_rgb_ssse3@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_rgb24r_to_rgb_ssse3
EXTRN	?convert_rgb32_to_rgb_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_rgb32_to_rgb_sse2
EXTRN	?convert_bgr32_to_rgb_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_bgr32_to_rgb_sse2
EXTRN	?convert_rgb32r_to_rgb_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_rgb32r_to_rgb_sse2
EXTRN	?convert_gbr_to_rgb24_ssse3@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_gbr_to_rgb24_ssse3
EXTRN	?convert_gbr_to_rgb32_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_gbr_to_rgb32_sse2
EXTRN	?convert_bgr24_to_rgb24_ssse3@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_bgr24_to_rgb24_ssse3
EXTRN	?convert_bgr32_to_rgb32_ssse3@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_bgr32_to_rgb32_ssse3
EXTRN	?convert_rgb24_to_rgb32_ssse3@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_rgb24_to_rgb32_ssse3
EXTRN	?convert_rgb24r_to_rgb32_ssse3@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_rgb24r_to_rgb32_ssse3
EXTRN	?convert_rgb24_to_rgb32_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_rgb24_to_rgb32_avx
EXTRN	?convert_rgb24r_to_rgb32_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_rgb24r_to_rgb32_avx
EXTRN	?convert_rgb24_to_rgb32_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_rgb24_to_rgb32_avx2
EXTRN	?convert_rgb24r_to_rgb32_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_rgb24r_to_rgb32_avx2
EXTRN	?convert_rgb32_to_rgb32_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_rgb32_to_rgb32_sse2
EXTRN	?convert_rgb32r_to_rgb32_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_rgb32r_to_rgb32_sse2
EXTRN	?convert_rgb32_to_rgb32_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_rgb32_to_rgb32_avx
EXTRN	?convert_rgb32r_to_rgb32_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_rgb32r_to_rgb32_avx
EXTRN	?convert_rgb32_to_rgb32_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_rgb32_to_rgb32_avx2
EXTRN	?convert_rgb32r_to_rgb32_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_rgb32r_to_rgb32_avx2
EXTRN	?convert_rgb24_to_rgb24_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_rgb24_to_rgb24_avx2
EXTRN	?convert_rgb24r_to_rgb24_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_rgb24r_to_rgb24_avx2
EXTRN	?convert_rgb24_to_rgb24_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_rgb24_to_rgb24_sse2
EXTRN	?convert_rgb24r_to_rgb24_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_rgb24r_to_rgb24_sse2
EXTRN	?copy_rgb_to_rgb_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; copy_rgb_to_rgb_sse2
EXTRN	?copy_gbr_to_rgb_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; copy_gbr_to_rgb_sse2
EXTRN	?convert_yv12_to_p010_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yv12_to_p010_avx2
EXTRN	?convert_yv12_to_p010_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yv12_to_p010_avx
EXTRN	?convert_yv12_to_p010_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yv12_to_p010_sse2
EXTRN	?convert_yv12_16_to_nv12_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yv12_16_to_nv12_avx2
EXTRN	?convert_yv12_16_to_nv12_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yv12_16_to_nv12_sse2
EXTRN	?convert_yv12_14_to_nv12_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yv12_14_to_nv12_avx2
EXTRN	?convert_yv12_14_to_nv12_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yv12_14_to_nv12_sse2
EXTRN	?convert_yv12_12_to_nv12_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yv12_12_to_nv12_avx2
EXTRN	?convert_yv12_12_to_nv12_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yv12_12_to_nv12_sse2
EXTRN	?convert_yv12_10_to_nv12_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yv12_10_to_nv12_avx2
EXTRN	?convert_yv12_10_to_nv12_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yv12_10_to_nv12_sse2
EXTRN	?convert_yv12_09_to_nv12_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yv12_09_to_nv12_avx2
EXTRN	?convert_yv12_09_to_nv12_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yv12_09_to_nv12_sse2
EXTRN	?convert_yv12_16_to_p010_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yv12_16_to_p010_avx2
EXTRN	?convert_yv12_16_to_p010_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yv12_16_to_p010_sse2
EXTRN	?convert_yv12_14_to_p010_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yv12_14_to_p010_avx2
EXTRN	?convert_yv12_14_to_p010_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yv12_14_to_p010_sse2
EXTRN	?convert_yv12_12_to_p010_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yv12_12_to_p010_avx2
EXTRN	?convert_yv12_12_to_p010_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yv12_12_to_p010_sse2
EXTRN	?convert_yv12_10_to_p010_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yv12_10_to_p010_avx2
EXTRN	?convert_yv12_10_to_p010_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yv12_10_to_p010_sse2
EXTRN	?convert_yv12_09_to_p010_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yv12_09_to_p010_avx2
EXTRN	?convert_yv12_09_to_p010_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yv12_09_to_p010_sse2
EXTRN	?convert_yuv422_to_nv16_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yuv422_to_nv16_sse2
EXTRN	?convert_yuv422_to_p210_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yuv422_to_p210_sse2
EXTRN	?convert_yuv422_09_to_p210_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yuv422_09_to_p210_sse2
EXTRN	?convert_yuv422_10_to_p210_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yuv422_10_to_p210_sse2
EXTRN	?convert_yuv422_12_to_p210_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yuv422_12_to_p210_sse2
EXTRN	?convert_yuv422_14_to_p210_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yuv422_14_to_p210_sse2
EXTRN	?convert_yuv422_16_to_p210_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yuv422_16_to_p210_sse2
EXTRN	?copy_yuv444_to_yuv444_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; copy_yuv444_to_yuv444_sse2
EXTRN	?copy_yuv444_to_yuv444_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; copy_yuv444_to_yuv444_avx2
EXTRN	?convert_yuv444_16_to_yuv444_16_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yuv444_16_to_yuv444_16_avx2
EXTRN	?convert_yuv444_16_to_yuv444_16_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yuv444_16_to_yuv444_16_sse2
EXTRN	?convert_yuv444_14_to_yuv444_16_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yuv444_14_to_yuv444_16_avx2
EXTRN	?convert_yuv444_14_to_yuv444_16_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yuv444_14_to_yuv444_16_sse2
EXTRN	?convert_yuv444_12_to_yuv444_16_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yuv444_12_to_yuv444_16_avx2
EXTRN	?convert_yuv444_12_to_yuv444_16_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yuv444_12_to_yuv444_16_sse2
EXTRN	?convert_yuv444_10_to_yuv444_16_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yuv444_10_to_yuv444_16_avx2
EXTRN	?convert_yuv444_10_to_yuv444_16_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yuv444_10_to_yuv444_16_sse2
EXTRN	?convert_yuv444_09_to_yuv444_16_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yuv444_09_to_yuv444_16_avx2
EXTRN	?convert_yuv444_09_to_yuv444_16_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yuv444_09_to_yuv444_16_sse2
EXTRN	?convert_yuv444_to_yuv444_16_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yuv444_to_yuv444_16_avx2
EXTRN	?convert_yuv444_to_yuv444_16_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yuv444_to_yuv444_16_sse2
EXTRN	?convert_yuv444_16_to_yuv444_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yuv444_16_to_yuv444_avx2
EXTRN	?convert_yuv444_16_to_yuv444_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yuv444_16_to_yuv444_sse2
EXTRN	?convert_yuv444_14_to_yuv444_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yuv444_14_to_yuv444_avx2
EXTRN	?convert_yuv444_14_to_yuv444_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yuv444_14_to_yuv444_sse2
EXTRN	?convert_yuv444_12_to_yuv444_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yuv444_12_to_yuv444_avx2
EXTRN	?convert_yuv444_12_to_yuv444_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yuv444_12_to_yuv444_sse2
EXTRN	?convert_yuv444_10_to_yuv444_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yuv444_10_to_yuv444_avx2
EXTRN	?convert_yuv444_10_to_yuv444_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yuv444_10_to_yuv444_sse2
EXTRN	?convert_yuv444_09_to_yuv444_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yuv444_09_to_yuv444_avx2
EXTRN	?convert_yuv444_09_to_yuv444_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yuv444_09_to_yuv444_sse2
EXTRN	?convert_yc48_to_yuv444_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yc48_to_yuv444_avx
EXTRN	?convert_yc48_to_yuv444_sse41@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yc48_to_yuv444_sse41
EXTRN	?convert_yc48_to_yuv444_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yc48_to_yuv444_sse2
EXTRN	?convert_yc48_to_p010_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yc48_to_p010_sse2
EXTRN	?convert_yc48_to_p010_i_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yc48_to_p010_i_sse2
EXTRN	?convert_yc48_to_p010_ssse3@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yc48_to_p010_ssse3
EXTRN	?convert_yc48_to_p010_i_ssse3@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yc48_to_p010_i_ssse3
EXTRN	?convert_yc48_to_p010_sse41@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yc48_to_p010_sse41
EXTRN	?convert_yc48_to_p010_i_sse41@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yc48_to_p010_i_sse41
EXTRN	?convert_yc48_to_p010_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yc48_to_p010_avx
EXTRN	?convert_yc48_to_p010_i_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yc48_to_p010_i_avx
EXTRN	?convert_yc48_to_p010_i_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yc48_to_p010_i_avx2
EXTRN	?convert_yc48_to_yuv444_16bit_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yc48_to_yuv444_16bit_avx2
EXTRN	?convert_yc48_to_yuv444_16bit_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yc48_to_yuv444_16bit_avx
EXTRN	?convert_yc48_to_yuv444_16bit_sse41@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yc48_to_yuv444_16bit_sse41
EXTRN	?convert_yc48_to_yuv444_16bit_ssse3@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yc48_to_yuv444_16bit_ssse3
EXTRN	?convert_yc48_to_yuv444_16bit_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yc48_to_yuv444_16bit_sse2
EXTRN	?convert_yuv444_16bit_to_yc48_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yuv444_16bit_to_yc48_avx2
EXTRN	?convert_yuv444_16bit_to_yc48_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yuv444_16bit_to_yc48_avx
EXTRN	?convert_yuv444_16bit_to_yc48_sse41@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yuv444_16bit_to_yc48_sse41
EXTRN	?convert_yuv444_16bit_to_yc48_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z:PROC ; convert_yuv444_16bit_to_yc48_sse2
CONST	SEGMENT
$SG26428 DB	'Invalid', 00H
$SG26429 DB	'nv12', 00H
	ORG $+3
$SG26430 DB	'yv12', 00H
	ORG $+3
$SG26431 DB	'yuy2', 00H
	ORG $+3
$SG26432 DB	'yuv422', 00H
	ORG $+1
$SG26433 DB	'nv16', 00H
	ORG $+3
$SG26434 DB	'yuv444', 00H
	ORG $+1
$SG26435 DB	'yv12(9bit)', 00H
	ORG $+1
$SG26436 DB	'yv12(10bit)', 00H
$SG26437 DB	'yv12(12bit)', 00H
$SG26438 DB	'yv12(14bit)', 00H
$SG26439 DB	'yv12(16bit)', 00H
$SG26440 DB	'p010', 00H
	ORG $+3
$SG26441 DB	'yuv422(9bit)', 00H
	ORG $+3
$SG26442 DB	'yuv422(10bit)', 00H
	ORG $+2
$SG26443 DB	'yuv422(12bit)', 00H
	ORG $+2
$SG26444 DB	'yuv422(14bit)', 00H
	ORG $+2
$SG26445 DB	'yuv422(16bit)', 00H
	ORG $+2
$SG26446 DB	'p210', 00H
	ORG $+3
$SG26447 DB	'yuv444(9bit)', 00H
	ORG $+3
$SG26448 DB	'yuv444(10bit)', 00H
	ORG $+2
$SG26449 DB	'yuv444(12bit)', 00H
	ORG $+2
$SG26450 DB	'yuv444(14bit)', 00H
	ORG $+2
$SG26451 DB	'yuv444(16bit)', 00H
	ORG $+2
$SG26452 DB	'yuva444', 00H
$SG26453 DB	'yuva444(16bit)', 00H
	ORG $+1
$SG26454 DB	'rgb24r', 00H
	ORG $+1
$SG26455 DB	'rgb32r', 00H
	ORG $+1
$SG26456 DB	'rgb24', 00H
	ORG $+2
$SG26457 DB	'rgb32', 00H
	ORG $+2
$SG26458 DB	'bgr24', 00H
	ORG $+2
$SG26459 DB	'bgr32', 00H
	ORG $+2
$SG26460 DB	'rgb', 00H
$SG26461 DB	'rgba', 00H
	ORG $+3
$SG26462 DB	'gbr', 00H
$SG26463 DB	'gbra', 00H
	ORG $+3
$SG26464 DB	'yc48', 00H
	ORG $+3
$SG26465 DB	'y8', 00H
	ORG $+1
$SG26466 DB	'yc16', 00H
	ORG $+3
?funcList@@3QBUConvertCSP@@B DD 01H			; funcList
	DD	01H
	DB	00H
	ORG $+3
	DD	FLAT:?copy_nv12_to_nv12_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?copy_nv12_to_nv12_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	0c0H
	DD	01H
	DD	01H
	DB	00H
	ORG $+3
	DD	FLAT:?copy_nv12_to_nv12_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?copy_nv12_to_nv12_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	01H
	DD	0cH
	DD	0cH
	DB	00H
	ORG $+3
	DD	FLAT:?copy_p010_to_p010_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?copy_p010_to_p010_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	0c0H
	DD	0cH
	DD	0cH
	DB	00H
	ORG $+3
	DD	FLAT:?copy_p010_to_p010_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?copy_p010_to_p010_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	01H
	DD	03H
	DD	01H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yuy2_to_nv12_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yuy2_to_nv12_i_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	0c0H
	DD	03H
	DD	01H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yuy2_to_nv12_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yuy2_to_nv12_i_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	040H
	DD	03H
	DD	01H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yuy2_to_nv12_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yuy2_to_nv12_i_ssse3@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	05H
	DD	03H
	DD	01H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yuy2_to_nv12_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yuy2_to_nv12_i_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	01H
	DD	03H
	DD	01H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yuy2_to_nv12@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yuy2_to_nv12@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	00H
	DD	03H
	DD	06H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yuy2_to_yuv444@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yuy2_to_yuv444@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	00H
	DD	024H
	DD	06H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yc48_to_yuv444_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yc48_to_yuv444_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	040H
	DD	024H
	DD	06H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yc48_to_yuv444_sse41@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yc48_to_yuv444_sse41@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	0dH
	DD	024H
	DD	06H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yc48_to_yuv444_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yc48_to_yuv444_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	01H
	DD	024H
	DD	0cH
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yc48_to_p010_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yc48_to_p010_i_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	0c0H
	DD	024H
	DD	0cH
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yc48_to_p010_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yc48_to_p010_i_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	040H
	DD	024H
	DD	0cH
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yc48_to_p010_sse41@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yc48_to_p010_i_sse41@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	0dH
	DD	024H
	DD	0cH
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yc48_to_p010_ssse3@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yc48_to_p010_i_ssse3@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	05H
	DD	024H
	DD	0cH
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yc48_to_p010_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yc48_to_p010_i_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	01H
	DD	024H
	DD	017H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yc48_to_yuv444_16bit_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yc48_to_yuv444_16bit_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	080H
	DD	024H
	DD	017H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yc48_to_yuv444_16bit_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yc48_to_yuv444_16bit_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	040H
	DD	024H
	DD	017H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yc48_to_yuv444_16bit_sse41@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yc48_to_yuv444_16bit_sse41@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	0dH
	DD	024H
	DD	017H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yc48_to_yuv444_16bit_ssse3@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yc48_to_yuv444_16bit_ssse3@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	05H
	DD	024H
	DD	017H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yc48_to_yuv444_16bit_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yc48_to_yuv444_16bit_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	01H
	DD	017H
	DD	024H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yuv444_16bit_to_yc48_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yuv444_16bit_to_yc48_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	080H
	DD	017H
	DD	024H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yuv444_16bit_to_yc48_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yuv444_16bit_to_yc48_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	040H
	DD	017H
	DD	024H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yuv444_16bit_to_yc48_sse41@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yuv444_16bit_to_yc48_sse41@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	0dH
	DD	017H
	DD	024H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yuv444_16bit_to_yc48_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yuv444_16bit_to_yc48_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	01H
	DD	02H
	DD	01H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yv12_to_nv12_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yv12_to_nv12_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	0c0H
	DD	02H
	DD	01H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yv12_to_nv12_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yv12_to_nv12_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	040H
	DD	02H
	DD	01H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yv12_to_nv12_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yv12_to_nv12_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	01H
	DD	02H
	DD	06H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yv12_p_to_yuv444@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yv12_i_to_yuv444@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	00H
	DD	02H
	DD	01H
	DB	01H
	ORG $+3
	DD	FLAT:?convert_uv_yv12_to_nv12_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_uv_yv12_to_nv12_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	0c0H
	DD	02H
	DD	01H
	DB	01H
	ORG $+3
	DD	FLAT:?convert_uv_yv12_to_nv12_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_uv_yv12_to_nv12_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	040H
	DD	02H
	DD	01H
	DB	01H
	ORG $+3
	DD	FLAT:?convert_uv_yv12_to_nv12_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_uv_yv12_to_nv12_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	01H
	DD	01eH
	DD	01cH
	DB	00H
	ORG $+3
	DD	FLAT:?convert_bgr24_to_rgb24_ssse3@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_bgr24_to_rgb24_ssse3@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	05H
	DD	01fH
	DD	01dH
	DB	00H
	ORG $+3
	DD	FLAT:?convert_bgr32_to_rgb32_ssse3@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_bgr32_to_rgb32_ssse3@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	05H
	DD	01cH
	DD	020H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_rgb24_to_rgb_ssse3@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_rgb24_to_rgb_ssse3@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	05H
	DD	01eH
	DD	020H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_bgr24_to_rgb_ssse3@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_bgr24_to_rgb_ssse3@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	05H
	DD	01aH
	DD	020H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_rgb24r_to_rgb_ssse3@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_rgb24r_to_rgb_ssse3@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	05H
	DD	01dH
	DD	020H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_rgb32_to_rgb_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_rgb32_to_rgb_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	01H
	DD	01fH
	DD	020H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_bgr32_to_rgb_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_bgr32_to_rgb_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	01H
	DD	01bH
	DD	020H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_rgb32r_to_rgb_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_rgb32r_to_rgb_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	01H
	DD	022H
	DD	01cH
	DB	00H
	ORG $+3
	DD	FLAT:?convert_gbr_to_rgb24_ssse3@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_gbr_to_rgb24_ssse3@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	05H
	DD	023H
	DD	01cH
	DB	00H
	ORG $+3
	DD	FLAT:?convert_gbr_to_rgb24_ssse3@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_gbr_to_rgb24_ssse3@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	05H
	DD	022H
	DD	01dH
	DB	00H
	ORG $+3
	DD	FLAT:?convert_gbr_to_rgb32_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_gbr_to_rgb32_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	01H
	DD	023H
	DD	01dH
	DB	00H
	ORG $+3
	DD	FLAT:?convert_gbr_to_rgb32_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_gbr_to_rgb32_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	01H
	DD	020H
	DD	020H
	DB	00H
	ORG $+3
	DD	FLAT:?copy_rgb_to_rgb_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?copy_rgb_to_rgb_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	01H
	DD	022H
	DD	020H
	DB	00H
	ORG $+3
	DD	FLAT:?copy_gbr_to_rgb_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?copy_gbr_to_rgb_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	01H
	DD	01cH
	DD	01dH
	DB	00H
	ORG $+3
	DD	FLAT:?convert_rgb24_to_rgb32_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_rgb24_to_rgb32_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	0c0H
	DD	01aH
	DD	01dH
	DB	00H
	ORG $+3
	DD	FLAT:?convert_rgb24r_to_rgb32_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_rgb24r_to_rgb32_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	0c0H
	DD	01cH
	DD	01dH
	DB	00H
	ORG $+3
	DD	FLAT:?convert_rgb24_to_rgb32_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_rgb24_to_rgb32_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	040H
	DD	01aH
	DD	01dH
	DB	00H
	ORG $+3
	DD	FLAT:?convert_rgb24r_to_rgb32_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_rgb24r_to_rgb32_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	040H
	DD	01cH
	DD	01dH
	DB	00H
	ORG $+3
	DD	FLAT:?convert_rgb24_to_rgb32_ssse3@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_rgb24_to_rgb32_ssse3@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	05H
	DD	01aH
	DD	01dH
	DB	00H
	ORG $+3
	DD	FLAT:?convert_rgb24r_to_rgb32_ssse3@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_rgb24r_to_rgb32_ssse3@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	05H
	DD	01dH
	DD	01dH
	DB	00H
	ORG $+3
	DD	FLAT:?convert_rgb32_to_rgb32_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_rgb32_to_rgb32_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	0c0H
	DD	01bH
	DD	01dH
	DB	00H
	ORG $+3
	DD	FLAT:?convert_rgb32r_to_rgb32_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_rgb32r_to_rgb32_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	0c0H
	DD	01dH
	DD	01dH
	DB	00H
	ORG $+3
	DD	FLAT:?convert_rgb32_to_rgb32_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_rgb32_to_rgb32_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	040H
	DD	01bH
	DD	01dH
	DB	00H
	ORG $+3
	DD	FLAT:?convert_rgb32r_to_rgb32_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_rgb32r_to_rgb32_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	040H
	DD	01dH
	DD	01dH
	DB	00H
	ORG $+3
	DD	FLAT:?convert_rgb32_to_rgb32_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_rgb32_to_rgb32_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	01H
	DD	01bH
	DD	01dH
	DB	00H
	ORG $+3
	DD	FLAT:?convert_rgb32r_to_rgb32_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_rgb32r_to_rgb32_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	01H
	DD	01cH
	DD	01cH
	DB	00H
	ORG $+3
	DD	FLAT:?convert_rgb24_to_rgb24_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_rgb24_to_rgb24_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	0c0H
	DD	01aH
	DD	01cH
	DB	00H
	ORG $+3
	DD	FLAT:?convert_rgb24r_to_rgb24_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_rgb24r_to_rgb24_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	0c0H
	DD	01cH
	DD	01cH
	DB	00H
	ORG $+3
	DD	FLAT:?convert_rgb24_to_rgb24_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_rgb24_to_rgb24_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	01H
	DD	01aH
	DD	01cH
	DB	00H
	ORG $+3
	DD	FLAT:?convert_rgb24r_to_rgb24_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_rgb24r_to_rgb24_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	01H
	DD	02H
	DD	0cH
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yv12_to_p010_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yv12_to_p010_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	0c0H
	DD	02H
	DD	0cH
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yv12_to_p010_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yv12_to_p010_avx@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	040H
	DD	02H
	DD	0cH
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yv12_to_p010_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yv12_to_p010_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	01H
	DD	02H
	DD	0cH
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yv12_to_p010@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yv12_to_p010@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	00H
	DD	02H
	DD	017H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yv12_p_to_yuv444_16bit@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yv12_i_to_yuv444_16bit@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	00H
	DD	0bH
	DD	01H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yv12_16_to_nv12_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yv12_16_to_nv12_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	0c0H
	DD	0bH
	DD	01H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yv12_16_to_nv12_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yv12_16_to_nv12_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	01H
	DD	0aH
	DD	01H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yv12_14_to_nv12_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yv12_14_to_nv12_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	0c0H
	DD	0aH
	DD	01H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yv12_14_to_nv12_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yv12_14_to_nv12_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	01H
	DD	09H
	DD	01H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yv12_12_to_nv12_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yv12_12_to_nv12_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	0c0H
	DD	09H
	DD	01H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yv12_12_to_nv12_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yv12_12_to_nv12_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	01H
	DD	08H
	DD	01H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yv12_10_to_nv12_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yv12_10_to_nv12_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	0c0H
	DD	08H
	DD	01H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yv12_10_to_nv12_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yv12_10_to_nv12_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	01H
	DD	07H
	DD	01H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yv12_09_to_nv12_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yv12_09_to_nv12_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	0c0H
	DD	07H
	DD	01H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yv12_09_to_nv12_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yv12_09_to_nv12_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	01H
	DD	0bH
	DD	0cH
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yv12_16_to_p010_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yv12_16_to_p010_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	0c0H
	DD	0bH
	DD	0cH
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yv12_16_to_p010_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yv12_16_to_p010_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	01H
	DD	0aH
	DD	0cH
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yv12_14_to_p010_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yv12_14_to_p010_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	0c0H
	DD	0aH
	DD	0cH
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yv12_14_to_p010_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yv12_14_to_p010_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	01H
	DD	09H
	DD	0cH
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yv12_12_to_p010_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yv12_12_to_p010_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	0c0H
	DD	09H
	DD	0cH
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yv12_12_to_p010_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yv12_12_to_p010_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	01H
	DD	08H
	DD	0cH
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yv12_10_to_p010_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yv12_10_to_p010_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	0c0H
	DD	08H
	DD	0cH
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yv12_10_to_p010_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yv12_10_to_p010_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	01H
	DD	07H
	DD	0cH
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yv12_09_to_p010_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yv12_09_to_p010_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	0c0H
	DD	07H
	DD	0cH
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yv12_09_to_p010_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yv12_09_to_p010_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	01H
	DD	0bH
	DD	06H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yv12_16_p_to_yuv444@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yv12_16_i_to_yuv444@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	00H
	DD	0aH
	DD	06H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yv12_14_p_to_yuv444@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yv12_14_i_to_yuv444@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	00H
	DD	09H
	DD	06H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yv12_12_p_to_yuv444@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yv12_12_i_to_yuv444@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	00H
	DD	08H
	DD	06H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yv12_10_p_to_yuv444@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yv12_10_i_to_yuv444@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	00H
	DD	07H
	DD	06H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yv12_09_p_to_yuv444@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yv12_09_i_to_yuv444@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	00H
	DD	0bH
	DD	017H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yv12_16_p_to_yuv444_16bit@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yv12_16_i_to_yuv444_16bit@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	00H
	DD	0aH
	DD	017H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yv12_14_p_to_yuv444_16bit@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yv12_14_i_to_yuv444_16bit@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	00H
	DD	09H
	DD	017H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yv12_12_p_to_yuv444_16bit@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yv12_12_i_to_yuv444_16bit@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	00H
	DD	08H
	DD	017H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yv12_10_p_to_yuv444_16bit@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yv12_10_i_to_yuv444_16bit@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	00H
	DD	07H
	DD	017H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yv12_09_p_to_yuv444_16bit@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yv12_09_i_to_yuv444_16bit@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	00H
	DD	04H
	DD	06H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yuv422_to_yuv444@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yuv422_to_yuv444@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	00H
	DD	04H
	DD	05H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yuv422_to_nv16_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yuv422_to_nv16_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	01H
	DD	04H
	DD	012H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yuv422_to_p210_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yuv422_to_p210_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	01H
	DD	011H
	DD	012H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yuv422_16_to_p210_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yuv422_16_to_p210_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	01H
	DD	010H
	DD	012H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yuv422_14_to_p210_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yuv422_14_to_p210_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	01H
	DD	0fH
	DD	012H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yuv422_12_to_p210_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yuv422_12_to_p210_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	01H
	DD	0eH
	DD	012H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yuv422_10_to_p210_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yuv422_10_to_p210_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	01H
	DD	0dH
	DD	012H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yuv422_09_to_p210_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yuv422_09_to_p210_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	01H
	DD	06H
	DD	01H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yuv444_to_nv12_p@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yuv444_to_nv12_i@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	00H
	DD	06H
	DD	0cH
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yuv444_to_p010_p@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yuv444_to_p010_i@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	00H
	DD	06H
	DD	06H
	DB	00H
	ORG $+3
	DD	FLAT:?copy_yuv444_to_yuv444_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?copy_yuv444_to_yuv444_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	0c0H
	DD	06H
	DD	06H
	DB	00H
	ORG $+3
	DD	FLAT:?copy_yuv444_to_yuv444_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?copy_yuv444_to_yuv444_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	01H
	DD	017H
	DD	01H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yuv444_16_to_nv12_p@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yuv444_16_to_nv12_i@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	00H
	DD	016H
	DD	01H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yuv444_14_to_nv12_p@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yuv444_14_to_nv12_i@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	00H
	DD	015H
	DD	01H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yuv444_12_to_nv12_p@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yuv444_12_to_nv12_i@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	00H
	DD	014H
	DD	01H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yuv444_10_to_nv12_p@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yuv444_10_to_nv12_i@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	00H
	DD	013H
	DD	01H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yuv444_09_to_nv12_p@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yuv444_09_to_nv12_i@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	00H
	DD	017H
	DD	0cH
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yuv444_16_to_p010_p@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yuv444_16_to_p010_i@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	00H
	DD	016H
	DD	0cH
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yuv444_14_to_p010_p@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yuv444_14_to_p010_i@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	00H
	DD	015H
	DD	0cH
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yuv444_12_to_p010_p@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yuv444_12_to_p010_i@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	00H
	DD	014H
	DD	0cH
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yuv444_10_to_p010_p@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yuv444_10_to_p010_i@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	00H
	DD	013H
	DD	0cH
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yuv444_09_to_p010_p@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yuv444_09_to_p010_i@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	00H
	DD	017H
	DD	017H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yuv444_16_to_yuv444_16_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yuv444_16_to_yuv444_16_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	0c0H
	DD	017H
	DD	017H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yuv444_16_to_yuv444_16_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yuv444_16_to_yuv444_16_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	01H
	DD	016H
	DD	017H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yuv444_14_to_yuv444_16_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yuv444_14_to_yuv444_16_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	0c0H
	DD	016H
	DD	017H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yuv444_14_to_yuv444_16_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yuv444_14_to_yuv444_16_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	01H
	DD	015H
	DD	017H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yuv444_12_to_yuv444_16_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yuv444_12_to_yuv444_16_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	0c0H
	DD	015H
	DD	017H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yuv444_12_to_yuv444_16_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yuv444_12_to_yuv444_16_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	01H
	DD	014H
	DD	017H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yuv444_10_to_yuv444_16_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yuv444_10_to_yuv444_16_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	0c0H
	DD	014H
	DD	017H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yuv444_10_to_yuv444_16_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yuv444_10_to_yuv444_16_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	01H
	DD	013H
	DD	017H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yuv444_09_to_yuv444_16_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yuv444_09_to_yuv444_16_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	0c0H
	DD	013H
	DD	017H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yuv444_09_to_yuv444_16_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yuv444_09_to_yuv444_16_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	01H
	DD	06H
	DD	017H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yuv444_to_yuv444_16_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yuv444_to_yuv444_16_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	0c0H
	DD	06H
	DD	017H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yuv444_to_yuv444_16_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yuv444_to_yuv444_16_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	01H
	DD	017H
	DD	06H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yuv444_16_to_yuv444_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yuv444_16_to_yuv444_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	0c0H
	DD	017H
	DD	06H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yuv444_16_to_yuv444_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yuv444_16_to_yuv444_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	01H
	DD	016H
	DD	06H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yuv444_14_to_yuv444_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yuv444_14_to_yuv444_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	0c0H
	DD	016H
	DD	06H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yuv444_14_to_yuv444_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yuv444_14_to_yuv444_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	01H
	DD	015H
	DD	06H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yuv444_12_to_yuv444_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yuv444_12_to_yuv444_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	0c0H
	DD	015H
	DD	06H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yuv444_12_to_yuv444_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yuv444_12_to_yuv444_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	01H
	DD	014H
	DD	06H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yuv444_10_to_yuv444_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yuv444_10_to_yuv444_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	0c0H
	DD	014H
	DD	06H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yuv444_10_to_yuv444_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yuv444_10_to_yuv444_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	01H
	DD	013H
	DD	06H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yuv444_09_to_yuv444_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yuv444_09_to_yuv444_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	0c0H
	DD	013H
	DD	06H
	DB	00H
	ORG $+3
	DD	FLAT:?convert_yuv444_09_to_yuv444_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	FLAT:?convert_yuv444_09_to_yuv444_sse2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
	DD	01H
$SG78320 DB	'invalid argument', 00H
	ORG $+3
$SG78321 DB	'%s', 00H
	ORG $+1
$SG78322 DB	'C:\Program Files (x86)\Microsoft Visual Studio\2019\Comm'
	DB	'unity\VC\Tools\MSVC\14.23.28105\include\xmemory', 00H
$SG78323 DB	'C', 00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H
	DB	'g', 00H, 'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'F', 00H, 'i'
	DB	00H, 'l', 00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H
	DB	'8', 00H, '6', 00H, ')', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c'
	DB	00H, 'r', 00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H
	DB	' ', 00H, 'V', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l'
	DB	00H, ' ', 00H, 'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H
	DB	'o', 00H, '\', 00H, '2', 00H, '0', 00H, '1', 00H, '9', 00H, '\'
	DB	00H, 'C', 00H, 'o', 00H, 'm', 00H, 'm', 00H, 'u', 00H, 'n', 00H
	DB	'i', 00H, 't', 00H, 'y', 00H, '\', 00H, 'V', 00H, 'C', 00H, '\'
	DB	00H, 'T', 00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '\', 00H
	DB	'M', 00H, 'S', 00H, 'V', 00H, 'C', 00H, '\', 00H, '1', 00H, '4'
	DB	00H, '.', 00H, '2', 00H, '3', 00H, '.', 00H, '2', 00H, '8', 00H
	DB	'1', 00H, '0', 00H, '5', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c'
	DB	00H, 'l', 00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H
	DB	'm', 00H, 'e', 00H, 'm', 00H, 'o', 00H, 'r', 00H, 'y', 00H, 00H
	DB	00H
$SG78324 DB	's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H
	DB	'A', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a', 00H, 't'
	DB	00H, 'e', 00H, '_', 00H, 'm', 00H, 'a', 00H, 'n', 00H, 'u', 00H
	DB	'a', 00H, 'l', 00H, 'l', 00H, 'y', 00H, '_', 00H, 'v', 00H, 'e'
	DB	00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'a', 00H
	DB	'l', 00H, 'i', 00H, 'g', 00H, 'n', 00H, 'e', 00H, 'd', 00H, 00H
	DB	00H
	ORG $+2
$SG78325 DB	'"', 00H, 'i', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H
	DB	'i', 00H, 'd', 00H, ' ', 00H, 'a', 00H, 'r', 00H, 'g', 00H, 'u'
	DB	00H, 'm', 00H, 'e', 00H, 'n', 00H, 't', 00H, '"', 00H, 00H, 00H
	ORG $+2
$SG70199 DB	'AVX2', 00H
	ORG $+3
$SG70200 DB	'AVX', 00H
$SG70201 DB	'SSE4.2', 00H
	ORG $+1
$SG70202 DB	'SSE4.1', 00H
	ORG $+1
$SG70203 DB	'SSSE3', 00H
	ORG $+2
$SG70204 DB	'SSE2', 00H
	ORG $+3
$SG70206 DB	'-', 00H
CONST	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	?max@?$numeric_limits@H@std@@SAHXZ		; std::numeric_limits<int>::max
PUBLIC	??0exception@std@@QAE@QBDH@Z			; std::exception::exception
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@AAE@QBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	??$_Convert_size@I@std@@YAII@Z			; std::_Convert_size<unsigned int>
PUBLIC	??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z ; std::_Container_proxy::_Container_proxy
PUBLIC	??0_Container_base12@std@@QAE@XZ		; std::_Container_base12::_Container_base12
PUBLIC	?_Orphan_all@_Container_base12@std@@QAEXXZ	; std::_Container_base12::_Orphan_all
PUBLIC	?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ ; std::_Basic_container_proxy_ptr12::_Release
PUBLIC	?get_convert_csp_func@@YAPBUConvertCSP@@W4RGY_CSP@@0_NI@Z ; get_convert_csp_func
PUBLIC	?get_simd_str@@YAPBDI@Z				; get_simd_str
PUBLIC	?convert_yuy2_to_nv12_i@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuy2_to_nv12_i
PUBLIC	??0?$allocator@U?$pair@IPBD@std@@@std@@QAE@XZ	; std::allocator<std::pair<unsigned int,char const *> >::allocator<std::pair<unsigned int,char const *> >
PUBLIC	?deallocate@?$allocator@U?$pair@IPBD@std@@@std@@QAEXQAU?$pair@IPBD@2@I@Z ; std::allocator<std::pair<unsigned int,char const *> >::deallocate
PUBLIC	?allocate@?$allocator@U?$pair@IPBD@std@@@std@@QAEPAU?$pair@IPBD@2@I@Z ; std::allocator<std::pair<unsigned int,char const *> >::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@U?$pair@IPBD@std@@@std@@@std@@SAIABV?$allocator@U?$pair@IPBD@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::pair<unsigned int,char const *> > >::max_size
PUBLIC	??0?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@QAE@V?$initializer_list@U?$pair@IPBD@std@@@1@ABV?$allocator@U?$pair@IPBD@std@@@1@@Z ; std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > >::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > >
PUBLIC	??1?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@QAE@XZ ; std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > >::~vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > >
PUBLIC	?_Unchecked_begin@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@QAEPAU?$pair@IPBD@2@XZ ; std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@QAEPAU?$pair@IPBD@2@XZ ; std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > >::_Unchecked_end
PUBLIC	?max_size@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > >::max_size
PUBLIC	?_Destroy@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@AAEXPAU?$pair@IPBD@2@0@Z ; std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > >::_Destroy
PUBLIC	?_Buy_raw@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@AAEXI@Z ; std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > >::_Buy_raw
PUBLIC	?_Buy_nonzero@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@AAEXI@Z ; std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > >::_Buy_nonzero
PUBLIC	?_Tidy@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@AAEXXZ ; std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > >::_Tidy
PUBLIC	?_Xlength@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@CAXXZ ; std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > >::_Xlength
PUBLIC	?_Getal@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@AAEAAV?$allocator@U?$pair@IPBD@std@@@2@XZ ; std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > >::_Getal
PUBLIC	?_Getal@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@ABEABV?$allocator@U?$pair@IPBD@std@@@2@XZ ; std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > >::_Getal
PUBLIC	??0?$_Vector_val@U?$_Simple_types@U?$pair@IPBD@std@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<std::pair<unsigned int,char const *> > >::_Vector_val<std::_Simple_types<std::pair<unsigned int,char const *> > >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$pair@IPBD@std@@@std@@V?$_Vector_val@U?$_Simple_types@U?$pair@IPBD@std@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$pair@IPBD@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::pair<unsigned int,char const *> >,std::_Vector_val<std::_Simple_types<std::pair<unsigned int,char const *> > >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$pair@IPBD@std@@@std@@V?$_Vector_val@U?$_Simple_types@U?$pair@IPBD@std@@@std@@@2@$00@std@@QBEABV?$allocator@U?$pair@IPBD@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::pair<unsigned int,char const *> >,std::_Vector_val<std::_Simple_types<std::pair<unsigned int,char const *> > >,1>::_Get_first
PUBLIC	??0?$initializer_list@U?$pair@IPBD@std@@@std@@QAE@PBU?$pair@IPBD@1@0@Z ; std::initializer_list<std::pair<unsigned int,char const *> >::initializer_list<std::pair<unsigned int,char const *> >
PUBLIC	?begin@?$initializer_list@U?$pair@IPBD@std@@@std@@QBEPBU?$pair@IPBD@2@XZ ; std::initializer_list<std::pair<unsigned int,char const *> >::begin
PUBLIC	?end@?$initializer_list@U?$pair@IPBD@std@@@std@@QBEPBU?$pair@IPBD@2@XZ ; std::initializer_list<std::pair<unsigned int,char const *> >::end
PUBLIC	??$?0W4<unnamed-enum-NONE>@@AAY04$$CBD$0A@@?$pair@IPBD@std@@QAE@$$QAW4<unnamed-enum-NONE>@@AAY04$$CBD@Z ; std::pair<unsigned int,char const *>::pair<unsigned int,char const *><enum <unnamed-enum-NONE>,char const (&)[5],0>
PUBLIC	??$?0W4<unnamed-enum-NONE>@@AAY03$$CBD$0A@@?$pair@IPBD@std@@QAE@$$QAW4<unnamed-enum-NONE>@@AAY03$$CBD@Z ; std::pair<unsigned int,char const *>::pair<unsigned int,char const *><enum <unnamed-enum-NONE>,char const (&)[4],0>
PUBLIC	??$?0W4<unnamed-enum-NONE>@@AAY06$$CBD$0A@@?$pair@IPBD@std@@QAE@$$QAW4<unnamed-enum-NONE>@@AAY06$$CBD@Z ; std::pair<unsigned int,char const *>::pair<unsigned int,char const *><enum <unnamed-enum-NONE>,char const (&)[7],0>
PUBLIC	??$?0W4<unnamed-enum-NONE>@@AAY05$$CBD$0A@@?$pair@IPBD@std@@QAE@$$QAW4<unnamed-enum-NONE>@@AAY05$$CBD@Z ; std::pair<unsigned int,char const *>::pair<unsigned int,char const *><enum <unnamed-enum-NONE>,char const (&)[6],0>
PUBLIC	?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
PUBLIC	??$?0U?$pair@IPBD@std@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@U?$pair@IPBD@std@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::pair<unsigned int,char const *> >
PUBLIC	??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z ; std::exchange<std::_Container_proxy *,std::nullptr_t>
PUBLIC	??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
PUBLIC	??$?0ABV?$allocator@U?$pair@IPBD@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$pair@IPBD@std@@@std@@V?$_Vector_val@U?$_Simple_types@U?$pair@IPBD@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@U?$pair@IPBD@std@@@1@@Z ; std::_Compressed_pair<std::allocator<std::pair<unsigned int,char const *> >,std::_Vector_val<std::_Simple_types<std::pair<unsigned int,char const *> > >,1>::_Compressed_pair<std::allocator<std::pair<unsigned int,char const *> >,std::_Vector_val<std::_Simple_types<std::pair<unsigned int,char const *> > >,1><std::allocator<std::pair<unsigned int,char const *> > const &>
PUBLIC	??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
PUBLIC	??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
PUBLIC	??$_Range_construct_or_tidy@PBU?$pair@IPBD@std@@@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@AAEXPBU?$pair@IPBD@1@0Uforward_iterator_tag@1@@Z ; std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > >::_Range_construct_or_tidy<std::pair<unsigned int,char const *> const *>
PUBLIC	??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ; std::_Unfancy<std::_Container_proxy>
PUBLIC	??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z ; std::addressof<std::_Container_base12>
PUBLIC	??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
PUBLIC	??$_Get_size_of_n@$07@std@@YAII@Z		; std::_Get_size_of_n<8>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$_Destroy_range@V?$allocator@U?$pair@IPBD@std@@@std@@@std@@YAXPAU?$pair@IPBD@0@QAU10@AAV?$allocator@U?$pair@IPBD@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::pair<unsigned int,char const *> > >
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$max@H@std@@YAABHABH0@Z			; std::max<int>
PUBLIC	??$forward@W4<unnamed-enum-NONE>@@@std@@YA$$QAW4<unnamed-enum-NONE>@@AAW41@@Z ; std::forward<enum <unnamed-enum-NONE> >
PUBLIC	??$forward@AAY04$$CBD@std@@YAAAY04$$CBDAAY04$$CBD@Z ; std::forward<char const (&)[5]>
PUBLIC	??$forward@AAY03$$CBD@std@@YAAAY03$$CBDAAY03$$CBD@Z ; std::forward<char const (&)[4]>
PUBLIC	??$forward@AAY06$$CBD@std@@YAAAY06$$CBDAAY06$$CBD@Z ; std::forward<char const (&)[7]>
PUBLIC	??$forward@AAY05$$CBD@std@@YAAAY05$$CBDAAY05$$CBD@Z ; std::forward<char const (&)[6]>
PUBLIC	??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
PUBLIC	??$forward@ABV?$allocator@U?$pair@IPBD@std@@@std@@@std@@YAABV?$allocator@U?$pair@IPBD@std@@@0@ABV10@@Z ; std::forward<std::allocator<std::pair<unsigned int,char const *> > const &>
PUBLIC	??$distance@PBU?$pair@IPBD@std@@@std@@YAHPBU?$pair@IPBD@0@0@Z ; std::distance<std::pair<unsigned int,char const *> const *>
PUBLIC	??1?$_Tidy_guard@V?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > > >::~_Tidy_guard<std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > > >
PUBLIC	??$_Ucopy@PBU?$pair@IPBD@std@@@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@AAEPAU?$pair@IPBD@1@PBU21@0PAU21@@Z ; std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > >::_Ucopy<std::pair<unsigned int,char const *> const *>
PUBLIC	??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z ; std::addressof<std::_Container_proxy>
PUBLIC	??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z ; std::forward<std::_Container_base12 *>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??$_Min_value@I@std@@YAABIABI0@Z		; std::_Min_value<unsigned int>
PUBLIC	?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
PUBLIC	??$_Uninitialized_copy@PBU?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@YAPAU?$pair@IPBD@0@QBU10@0PAU10@AAV?$allocator@U?$pair@IPBD@std@@@0@@Z ; std::_Uninitialized_copy<std::pair<unsigned int,char const *> const *,std::allocator<std::pair<unsigned int,char const *> > >
PUBLIC	??$_Get_unwrapped@$$CBU?$pair@IPBD@std@@@std@@YAPBU?$pair@IPBD@0@QBU10@@Z ; std::_Get_unwrapped<std::pair<unsigned int,char const *> const >
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@U?$pair@IPBD@std@@@std@@@std@@QAE@PAU?$pair@IPBD@1@AAV?$allocator@U?$pair@IPBD@std@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::pair<unsigned int,char const *> > >::_Uninitialized_backout_al<std::allocator<std::pair<unsigned int,char const *> > >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@U?$pair@IPBD@std@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<std::pair<unsigned int,char const *> > >::~_Uninitialized_backout_al<std::allocator<std::pair<unsigned int,char const *> > >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@U?$pair@IPBD@std@@@std@@@std@@QAEPAU?$pair@IPBD@2@XZ ; std::_Uninitialized_backout_al<std::allocator<std::pair<unsigned int,char const *> > >::_Release
PUBLIC	??$_Emplace_back@ABU?$pair@IPBD@std@@@?$_Uninitialized_backout_al@V?$allocator@U?$pair@IPBD@std@@@std@@@std@@QAEXABU?$pair@IPBD@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::pair<unsigned int,char const *> > >::_Emplace_back<std::pair<unsigned int,char const *> const &>
PUBLIC	??$_Unfancy@U?$pair@IPBD@std@@@std@@YAPAU?$pair@IPBD@0@PAU10@@Z ; std::_Unfancy<std::pair<unsigned int,char const *> >
PUBLIC	??$forward@ABU?$pair@IPBD@std@@@std@@YAABU?$pair@IPBD@0@ABU10@@Z ; std::forward<std::pair<unsigned int,char const *> const &>
PUBLIC	??$construct@U?$pair@IPBD@std@@ABU12@@?$_Default_allocator_traits@V?$allocator@U?$pair@IPBD@std@@@std@@@std@@SAXAAV?$allocator@U?$pair@IPBD@std@@@1@QAU?$pair@IPBD@1@ABU31@@Z ; std::_Default_allocator_traits<std::allocator<std::pair<unsigned int,char const *> > >::construct<std::pair<unsigned int,char const *>,std::pair<unsigned int,char const *> const &>
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_0BB@FCMFBGOM@invalid?5argument@		; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_0GI@FJIKDGOA@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ ; `string'
PUBLIC	??_C@_1NA@CDBIFGMM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@ ; `string'
PUBLIC	??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@ ; `string'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long@	; `string'
PUBLIC	??_C@_0BD@FEEMDEPI@invalid?5comparator@		; `string'
PUBLIC	??_C@_0GK@EEDLHHLD@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ ; `string'
PUBLIC	??_C@_1NE@BOCHNKFM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_1BC@ICCOKLEG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAm?$AAa?$AAx@ ; `string'
PUBLIC	??_C@_1CK@NDNHPKPI@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAc?$AAo?$AAm?$AAp?$AAa?$AAr@ ; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	__Init_thread_header:PROC
EXTRN	__Init_thread_abort:PROC
EXTRN	__Init_thread_footer:PROC
EXTRN	__imp___invalid_parameter:PROC
EXTRN	__imp___CrtDbgReport:PROC
EXTRN	__imp_??0_Lockit@std@@QAE@H@Z:PROC
EXTRN	__imp_??1_Lockit@std@@QAE@XZ:PROC
EXTRN	_memcpy:PROC
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?get_availableSIMD@@YAIXZ:PROC			; get_availableSIMD
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__Init_thread_epoch:DWORD
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
EXTRN	__tls_array:DWORD
EXTRN	__tls_index:DWORD
;	COMDAT ?simd_str_list@?1??get_simd_str@@YAPBDI@Z@4V?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@A
_BSS	SEGMENT
?simd_str_list@?1??get_simd_str@@YAPBDI@Z@4V?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@A DB 010H DUP (?) ; `get_simd_str'::`2'::simd_str_list
_BSS	ENDS
;	COMDAT ?$TSS0@?1??get_simd_str@@YAPBDI@Z@4HA
_BSS	SEGMENT
?$TSS0@?1??get_simd_str@@YAPBDI@Z@4HA DD 01H DUP (?)	; TSS0<`template-parameter-2',et_simd_str,int, ?? &>
_BSS	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_1CK@NDNHPKPI@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAc?$AAo?$AAm?$AAp?$AAa?$AAr@
CONST	SEGMENT
??_C@_1CK@NDNHPKPI@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAc?$AAo?$AAm?$AAp?$AAa?$AAr@ DB '"'
	DB	00H, 'i', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H
	DB	'd', 00H, ' ', 00H, 'c', 00H, 'o', 00H, 'm', 00H, 'p', 00H, 'a'
	DB	00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '"', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@ICCOKLEG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAm?$AAa?$AAx@
CONST	SEGMENT
??_C@_1BC@ICCOKLEG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAm?$AAa?$AAx@ DB 's', 00H
	DB	't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'm', 00H, 'a', 00H, 'x'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1NE@BOCHNKFM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
CONST	SEGMENT
??_C@_1NE@BOCHNKFM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ DB 'C'
	DB	00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'F', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'V', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	'\', 00H, '2', 00H, '0', 00H, '1', 00H, '9', 00H, '\', 00H, 'C'
	DB	00H, 'o', 00H, 'm', 00H, 'm', 00H, 'u', 00H, 'n', 00H, 'i', 00H
	DB	't', 00H, 'y', 00H, '\', 00H, 'V', 00H, 'C', 00H, '\', 00H, 'T'
	DB	00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '\', 00H, 'M', 00H
	DB	'S', 00H, 'V', 00H, 'C', 00H, '\', 00H, '1', 00H, '4', 00H, '.'
	DB	00H, '2', 00H, '3', 00H, '.', 00H, '2', 00H, '8', 00H, '1', 00H
	DB	'0', 00H, '5', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l'
	DB	00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'a', 00H, 'l', 00H
	DB	'g', 00H, 'o', 00H, 'r', 00H, 'i', 00H, 't', 00H, 'h', 00H, 'm'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0GK@EEDLHHLD@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
CONST	SEGMENT
??_C@_0GK@EEDLHHLD@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ DB 'C:\Pro'
	DB	'gram Files (x86)\Microsoft Visual Studio\2019\Community\VC\To'
	DB	'ols\MSVC\14.23.28105\include\algorithm', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FEEMDEPI@invalid?5comparator@
CONST	SEGMENT
??_C@_0BD@FEEMDEPI@invalid?5comparator@ DB 'invalid comparator', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long@ DB 'vector<T> too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
CONST	SEGMENT
??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@ DB '"'
	DB	00H, 'i', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H
	DB	'd', 00H, ' ', 00H, 'a', 00H, 'r', 00H, 'g', 00H, 'u', 00H, 'm'
	DB	00H, 'e', 00H, 'n', 00H, 't', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@
CONST	SEGMENT
??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'A', 00H
	DB	'd', 00H, 'j', 00H, 'u', 00H, 's', 00H, 't', 00H, '_', 00H, 'm'
	DB	00H, 'a', 00H, 'n', 00H, 'u', 00H, 'a', 00H, 'l', 00H, 'l', 00H
	DB	'y', 00H, '_', 00H, 'v', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o'
	DB	00H, 'r', 00H, '_', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'g', 00H
	DB	'n', 00H, 'e', 00H, 'd', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1NA@CDBIFGMM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
CONST	SEGMENT
??_C@_1NA@CDBIFGMM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ DB 'C'
	DB	00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'F', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'V', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	'\', 00H, '2', 00H, '0', 00H, '1', 00H, '9', 00H, '\', 00H, 'C'
	DB	00H, 'o', 00H, 'm', 00H, 'm', 00H, 'u', 00H, 'n', 00H, 'i', 00H
	DB	't', 00H, 'y', 00H, '\', 00H, 'V', 00H, 'C', 00H, '\', 00H, 'T'
	DB	00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '\', 00H, 'M', 00H
	DB	'S', 00H, 'V', 00H, 'C', 00H, '\', 00H, '1', 00H, '4', 00H, '.'
	DB	00H, '2', 00H, '3', 00H, '.', 00H, '2', 00H, '8', 00H, '1', 00H
	DB	'0', 00H, '5', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l'
	DB	00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H, 'm', 00H
	DB	'e', 00H, 'm', 00H, 'o', 00H, 'r', 00H, 'y', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GI@FJIKDGOA@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
CONST	SEGMENT
??_C@_0GI@FJIKDGOA@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ DB 'C:\Pro'
	DB	'gram Files (x86)\Microsoft Visual Studio\2019\Community\VC\To'
	DB	'ols\MSVC\14.23.28105\include\xmemory', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FCMFBGOM@invalid?5argument@
CONST	SEGMENT
??_C@_0BB@FCMFBGOM@invalid?5argument@ DB 'invalid argument', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Uninitialized_copy@PBU?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@YAPAU?$pair@IPBD@0@QBU10@0PAU10@AAV?$allocator@U?$pair@IPBD@std@@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninitialized_copy@PBU?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@YAPAU?$pair@IPBD@0@QBU10@0PAU10@AAV?$allocator@U?$pair@IPBD@std@@@0@@Z$0
__ehfuncinfo$??$_Uninitialized_copy@PBU?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@YAPAU?$pair@IPBD@0@QBU10@0PAU10@AAV?$allocator@U?$pair@IPBD@std@@@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Uninitialized_copy@PBU?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@YAPAU?$pair@IPBD@0@QBU10@0PAU10@AAV?$allocator@U?$pair@IPBD@std@@@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$max@H@std@@YAABHABH0@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Range_construct_or_tidy@PBU?$pair@IPBD@std@@@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@AAEXPBU?$pair@IPBD@1@0Uforward_iterator_tag@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Range_construct_or_tidy@PBU?$pair@IPBD@std@@@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@AAEXPBU?$pair@IPBD@1@0Uforward_iterator_tag@1@@Z$0
__ehfuncinfo$??$_Range_construct_or_tidy@PBU?$pair@IPBD@std@@@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@AAEXPBU?$pair@IPBD@1@0Uforward_iterator_tag@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Range_construct_or_tidy@PBU?$pair@IPBD@std@@@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@AAEXPBU?$pair@IPBD@1@0Uforward_iterator_tag@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Tidy@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@AAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@QAE@V?$initializer_list@U?$pair@IPBD@std@@@1@ABV?$allocator@U?$pair@IPBD@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@QAE@V?$initializer_list@U?$pair@IPBD@std@@@1@ABV?$allocator@U?$pair@IPBD@std@@@1@@Z$0
__ehfuncinfo$??0?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@QAE@V?$initializer_list@U?$pair@IPBD@std@@@1@ABV?$allocator@U?$pair@IPBD@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@QAE@V?$initializer_list@U?$pair@IPBD@std@@@1@ABV?$allocator@U?$pair@IPBD@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
xdata$x	SEGMENT
__unwindtable$?get_simd_str@@YAPBDI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?get_simd_str@@YAPBDI@Z$0
__ehfuncinfo$?get_simd_str@@YAPBDI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?get_simd_str@@YAPBDI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0
__ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0bad_array_new_length@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0bad_array_new_length@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0bad_array_new_length@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0bad_array_new_length@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1bad_array_new_length@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1bad_array_new_length@std@@UAE@XZ$0
__ehfuncinfo$??1bad_array_new_length@std@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1bad_array_new_length@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0bad_array_new_length@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0bad_array_new_length@std@@QAE@XZ$0
__ehfuncinfo$??0bad_array_new_length@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0bad_array_new_length@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0bad_alloc@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0bad_alloc@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0bad_alloc@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0bad_alloc@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1bad_alloc@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1bad_alloc@std@@UAE@XZ$0
__ehfuncinfo$??1bad_alloc@std@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1bad_alloc@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0bad_alloc@std@@AAE@QBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0bad_alloc@std@@AAE@QBD@Z$0
__ehfuncinfo$??0bad_alloc@std@@AAE@QBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0bad_alloc@std@@AAE@QBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1exception@std@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0exception@std@@QAE@ABV01@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ??$construct@U?$pair@IPBD@std@@ABU12@@?$_Default_allocator_traits@V?$allocator@U?$pair@IPBD@std@@@std@@@std@@SAXAAV?$allocator@U?$pair@IPBD@std@@@1@QAU?$pair@IPBD@1@ABU31@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@U?$pair@IPBD@std@@ABU12@@?$_Default_allocator_traits@V?$allocator@U?$pair@IPBD@std@@@std@@@std@@SAXAAV?$allocator@U?$pair@IPBD@std@@@1@QAU?$pair@IPBD@1@ABU31@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::pair<unsigned int,char const *> > >::construct<std::pair<unsigned int,char const *>,std::pair<unsigned int,char const *> const &>, COMDAT

; 757  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 758  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  0000b	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000e	50		 push	 eax
  0000f	6a 08		 push	 8
  00011	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00016	83 c4 08	 add	 esp, 8
  00019	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  0001c	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ??$forward@ABU?$pair@IPBD@std@@@std@@YAABU?$pair@IPBD@0@ABU10@@Z ; std::forward<std::pair<unsigned int,char const *> const &>
  00025	83 c4 04	 add	 esp, 4
  00028	8b 10		 mov	 edx, DWORD PTR [eax]
  0002a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002d	8b 4d fc	 mov	 ecx, DWORD PTR $T1[ebp]
  00030	89 11		 mov	 DWORD PTR [ecx], edx
  00032	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 759  :     }

  00035	83 c4 04	 add	 esp, 4
  00038	3b ec		 cmp	 ebp, esp
  0003a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
??$construct@U?$pair@IPBD@std@@ABU12@@?$_Default_allocator_traits@V?$allocator@U?$pair@IPBD@std@@@std@@@std@@SAXAAV?$allocator@U?$pair@IPBD@std@@@1@QAU?$pair@IPBD@1@ABU31@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::pair<unsigned int,char const *> > >::construct<std::pair<unsigned int,char const *>,std::pair<unsigned int,char const *> const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\type_traits
;	COMDAT ??$forward@ABU?$pair@IPBD@std@@@std@@YAABU?$pair@IPBD@0@ABU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABU?$pair@IPBD@std@@@std@@YAABU?$pair@IPBD@0@ABU10@@Z PROC ; std::forward<std::pair<unsigned int,char const *> const &>, COMDAT

; 1420 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1421 :     return static_cast<_Ty&&>(_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1422 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABU?$pair@IPBD@std@@@std@@YAABU?$pair@IPBD@0@ABU10@@Z ENDP ; std::forward<std::pair<unsigned int,char const *> const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstddef
;	COMDAT ??$_Unfancy@U?$pair@IPBD@std@@@std@@YAPAU?$pair@IPBD@0@PAU10@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@U?$pair@IPBD@std@@@std@@YAPAU?$pair@IPBD@0@PAU10@@Z PROC ; std::_Unfancy<std::pair<unsigned int,char const *> >, COMDAT

; 293  : _Ty* _Unfancy(_Ty* _Ptr) { // do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 294  :     return _Ptr;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 295  : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unfancy@U?$pair@IPBD@std@@@std@@YAPAU?$pair@IPBD@0@PAU10@@Z ENDP ; std::_Unfancy<std::pair<unsigned int,char const *> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ??$_Emplace_back@ABU?$pair@IPBD@std@@@?$_Uninitialized_backout_al@V?$allocator@U?$pair@IPBD@std@@@std@@@std@@QAEXABU?$pair@IPBD@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@ABU?$pair@IPBD@std@@@?$_Uninitialized_backout_al@V?$allocator@U?$pair@IPBD@std@@@std@@@std@@QAEXABU?$pair@IPBD@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<std::pair<unsigned int,char const *> > >::_Emplace_back<std::pair<unsigned int,char const *> const &>, COMDAT
; _this$ = ecx

; 1580 :     void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1581 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

  0000e	8b 45 08	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$forward@ABU?$pair@IPBD@std@@@std@@YAABU?$pair@IPBD@0@ABU10@@Z ; std::forward<std::pair<unsigned int,char const *> const &>
  00017	83 c4 04	 add	 esp, 4
  0001a	50		 push	 eax
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00021	52		 push	 edx
  00022	e8 00 00 00 00	 call	 ??$_Unfancy@U?$pair@IPBD@std@@@std@@YAPAU?$pair@IPBD@0@PAU10@@Z ; std::_Unfancy<std::pair<unsigned int,char const *> >
  00027	83 c4 04	 add	 esp, 4
  0002a	50		 push	 eax
  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00031	51		 push	 ecx
  00032	e8 00 00 00 00	 call	 ??$construct@U?$pair@IPBD@std@@ABU12@@?$_Default_allocator_traits@V?$allocator@U?$pair@IPBD@std@@@std@@@std@@SAXAAV?$allocator@U?$pair@IPBD@std@@@1@QAU?$pair@IPBD@1@ABU31@@Z ; std::_Default_allocator_traits<std::allocator<std::pair<unsigned int,char const *> > >::construct<std::pair<unsigned int,char const *>,std::pair<unsigned int,char const *> const &>
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1582 :         ++_Last;

  0003a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00040	83 c0 08	 add	 eax, 8
  00043	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1583 :     }

  00049	83 c4 04	 add	 esp, 4
  0004c	3b ec		 cmp	 ebp, esp
  0004e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c2 04 00	 ret	 4
??$_Emplace_back@ABU?$pair@IPBD@std@@@?$_Uninitialized_backout_al@V?$allocator@U?$pair@IPBD@std@@@std@@@std@@QAEXABU?$pair@IPBD@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<std::pair<unsigned int,char const *> > >::_Emplace_back<std::pair<unsigned int,char const *> const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@U?$pair@IPBD@std@@@std@@@std@@QAEPAU?$pair@IPBD@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Release@?$_Uninitialized_backout_al@V?$allocator@U?$pair@IPBD@std@@@std@@@std@@QAEPAU?$pair@IPBD@2@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<std::pair<unsigned int,char const *> > >::_Release, COMDAT
; _this$ = ecx

; 1585 :     pointer _Release() { // suppress any exception handling backout and return _Last

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1586 :         _First = _Last;

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00017	89 10		 mov	 DWORD PTR [eax], edx

; 1587 :         return _Last;

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 1588 :     }

  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
?_Release@?$_Uninitialized_backout_al@V?$allocator@U?$pair@IPBD@std@@@std@@@std@@QAEPAU?$pair@IPBD@2@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<std::pair<unsigned int,char const *> > >::_Release
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@U?$pair@IPBD@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Uninitialized_backout_al@V?$allocator@U?$pair@IPBD@std@@@std@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<std::pair<unsigned int,char const *> > >::~_Uninitialized_backout_al<std::allocator<std::pair<unsigned int,char const *> > >, COMDAT
; _this$ = ecx

; 1575 :     ~_Uninitialized_backout_al() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1576 :         _Destroy_range(_First, _Last, _Al);

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00014	51		 push	 ecx
  00015	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00018	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0001b	50		 push	 eax
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00021	52		 push	 edx
  00022	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@U?$pair@IPBD@std@@@std@@@std@@YAXPAU?$pair@IPBD@0@QAU10@AAV?$allocator@U?$pair@IPBD@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::pair<unsigned int,char const *> > >
  00027	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1577 :     }

  0002a	83 c4 04	 add	 esp, 4
  0002d	3b ec		 cmp	 ebp, esp
  0002f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
??1?$_Uninitialized_backout_al@V?$allocator@U?$pair@IPBD@std@@@std@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<std::pair<unsigned int,char const *> > >::~_Uninitialized_backout_al<std::allocator<std::pair<unsigned int,char const *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@U?$pair@IPBD@std@@@std@@@std@@QAE@PAU?$pair@IPBD@1@AAV?$allocator@U?$pair@IPBD@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$allocator@U?$pair@IPBD@std@@@std@@@std@@QAE@PAU?$pair@IPBD@1@AAV?$allocator@U?$pair@IPBD@std@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<std::pair<unsigned int,char const *> > >::_Uninitialized_backout_al<std::allocator<std::pair<unsigned int,char const *> > >, COMDAT
; _this$ = ecx

; 1570 :     _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 4d 08	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00014	89 08		 mov	 DWORD PTR [eax], ecx
  00016	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00019	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  0001c	89 42 04	 mov	 DWORD PTR [edx+4], eax
  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	8b 55 0c	 mov	 edx, DWORD PTR __Al_$[ebp]
  00025	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c2 08 00	 ret	 8
??0?$_Uninitialized_backout_al@V?$allocator@U?$pair@IPBD@std@@@std@@@std@@QAE@PAU?$pair@IPBD@1@AAV?$allocator@U?$pair@IPBD@std@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<std::pair<unsigned int,char const *> > >::_Uninitialized_backout_al<std::allocator<std::pair<unsigned int,char const *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xutility
;	COMDAT ??$_Get_unwrapped@$$CBU?$pair@IPBD@std@@@std@@YAPBU?$pair@IPBD@0@QBU10@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Get_unwrapped@$$CBU?$pair@IPBD@std@@@std@@YAPBU?$pair@IPBD@0@QBU10@@Z PROC ; std::_Get_unwrapped<std::pair<unsigned int,char const *> const >, COMDAT

; 275  : _NODISCARD constexpr _Ty* _Get_unwrapped(_Ty* const _Ptr) { // special case already-unwrapped pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 276  :     return _Ptr;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 277  : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Get_unwrapped@$$CBU?$pair@IPBD@std@@@std@@YAPBU?$pair@IPBD@0@QBU10@@Z ENDP ; std::_Get_unwrapped<std::pair<unsigned int,char const *> const >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PBU?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@YAPAU?$pair@IPBD@0@QBU10@0PAU10@AAV?$allocator@U?$pair@IPBD@std@@@0@@Z
_TEXT	SEGMENT
__Backout$2 = -36					; size = 12
__ULast$ = -20						; size = 4
__UFirst$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PBU?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@YAPAU?$pair@IPBD@0@QBU10@0PAU10@AAV?$allocator@U?$pair@IPBD@std@@@0@@Z PROC ; std::_Uninitialized_copy<std::pair<unsigned int,char const *> const *,std::allocator<std::pair<unsigned int,char const *> > >, COMDAT

; 1600 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninitialized_copy@PBU?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@YAPAU?$pair@IPBD@0@QBU10@0PAU10@AAV?$allocator@U?$pair@IPBD@std@@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	89 45 d8	 mov	 DWORD PTR [ebp-40], eax
  0001c	89 45 dc	 mov	 DWORD PTR [ebp-36], eax
  0001f	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  00022	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  00025	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00028	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0002b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 1601 :     // copy [_First, _Last) to raw _Dest, using _Al
; 1602 :     // note: only called internally from elsewhere in the STL
; 1603 :     using _Ptrval = typename _Alloc::value_type*;
; 1604 : 
; 1605 :     auto _UFirst      = _Get_unwrapped(_First);

  0003f	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 ??$_Get_unwrapped@$$CBU?$pair@IPBD@std@@@std@@YAPBU?$pair@IPBD@0@QBU10@@Z ; std::_Get_unwrapped<std::pair<unsigned int,char const *> const >
  00048	83 c4 04	 add	 esp, 4
  0004b	89 45 f0	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1606 :     const auto _ULast = _Get_unwrapped(_Last);

  0004e	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00051	51		 push	 ecx
  00052	e8 00 00 00 00	 call	 ??$_Get_unwrapped@$$CBU?$pair@IPBD@std@@@std@@YAPBU?$pair@IPBD@0@QBU10@@Z ; std::_Get_unwrapped<std::pair<unsigned int,char const *> const >
  00057	83 c4 04	 add	 esp, 4
  0005a	89 45 ec	 mov	 DWORD PTR __ULast$[ebp], eax

; 1607 : 
; 1608 :     if constexpr (conjunction_v<bool_constant<_Ptr_copy_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1609 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>) {
; 1610 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1611 :         _Dest += _ULast - _UFirst;
; 1612 :         (void) _Al;
; 1613 :     } else {
; 1614 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};

  0005d	8b 55 14	 mov	 edx, DWORD PTR __Al$[ebp]
  00060	52		 push	 edx
  00061	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00064	50		 push	 eax
  00065	8d 4d dc	 lea	 ecx, DWORD PTR __Backout$2[ebp]
  00068	e8 00 00 00 00	 call	 ??0?$_Uninitialized_backout_al@V?$allocator@U?$pair@IPBD@std@@@std@@@std@@QAE@PAU?$pair@IPBD@1@AAV?$allocator@U?$pair@IPBD@std@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::pair<unsigned int,char const *> > >::_Uninitialized_backout_al<std::allocator<std::pair<unsigned int,char const *> > >
  0006d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1615 :         for (; _UFirst != _ULast; ++_UFirst) {

  00074	eb 09		 jmp	 SHORT $LN4@Uninitiali
$LN2@Uninitiali:
  00076	8b 4d f0	 mov	 ecx, DWORD PTR __UFirst$[ebp]
  00079	83 c1 08	 add	 ecx, 8
  0007c	89 4d f0	 mov	 DWORD PTR __UFirst$[ebp], ecx
$LN4@Uninitiali:
  0007f	8b 55 f0	 mov	 edx, DWORD PTR __UFirst$[ebp]
  00082	3b 55 ec	 cmp	 edx, DWORD PTR __ULast$[ebp]
  00085	74 0e		 je	 SHORT $LN3@Uninitiali

; 1616 :             _Backout._Emplace_back(*_UFirst);

  00087	8b 45 f0	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0008a	50		 push	 eax
  0008b	8d 4d dc	 lea	 ecx, DWORD PTR __Backout$2[ebp]
  0008e	e8 00 00 00 00	 call	 ??$_Emplace_back@ABU?$pair@IPBD@std@@@?$_Uninitialized_backout_al@V?$allocator@U?$pair@IPBD@std@@@std@@@std@@QAEXABU?$pair@IPBD@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::pair<unsigned int,char const *> > >::_Emplace_back<std::pair<unsigned int,char const *> const &>

; 1617 :         }

  00093	eb e1		 jmp	 SHORT $LN2@Uninitiali
$LN3@Uninitiali:

; 1618 : 
; 1619 :         _Dest = _Backout._Release();

  00095	8d 4d dc	 lea	 ecx, DWORD PTR __Backout$2[ebp]
  00098	e8 00 00 00 00	 call	 ?_Release@?$_Uninitialized_backout_al@V?$allocator@U?$pair@IPBD@std@@@std@@@std@@QAEPAU?$pair@IPBD@2@XZ ; std::_Uninitialized_backout_al<std::allocator<std::pair<unsigned int,char const *> > >::_Release
  0009d	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax

; 1620 :     }

  000a0	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000a7	8d 4d dc	 lea	 ecx, DWORD PTR __Backout$2[ebp]
  000aa	e8 00 00 00 00	 call	 ??1?$_Uninitialized_backout_al@V?$allocator@U?$pair@IPBD@std@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<std::pair<unsigned int,char const *> > >::~_Uninitialized_backout_al<std::allocator<std::pair<unsigned int,char const *> > >

; 1621 : 
; 1622 :     return _Dest;

  000af	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]

; 1623 : }

  000b2	52		 push	 edx
  000b3	8b cd		 mov	 ecx, ebp
  000b5	50		 push	 eax
  000b6	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN10@Uninitiali
  000bc	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000c1	58		 pop	 eax
  000c2	5a		 pop	 edx
  000c3	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c6	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000cd	59		 pop	 ecx
  000ce	83 c4 28	 add	 esp, 40			; 00000028H
  000d1	3b ec		 cmp	 ebp, esp
  000d3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d8	8b e5		 mov	 esp, ebp
  000da	5d		 pop	 ebp
  000db	c3		 ret	 0
$LN10@Uninitiali:
  000dc	01 00 00 00	 DD	 1
  000e0	00 00 00 00	 DD	 $LN9@Uninitiali
$LN9@Uninitiali:
  000e4	dc ff ff ff	 DD	 -36			; ffffffdcH
  000e8	0c 00 00 00	 DD	 12			; 0000000cH
  000ec	00 00 00 00	 DD	 $LN7@Uninitiali
$LN7@Uninitiali:
  000f0	5f		 DB	 95			; 0000005fH
  000f1	42		 DB	 66			; 00000042H
  000f2	61		 DB	 97			; 00000061H
  000f3	63		 DB	 99			; 00000063H
  000f4	6b		 DB	 107			; 0000006bH
  000f5	6f		 DB	 111			; 0000006fH
  000f6	75		 DB	 117			; 00000075H
  000f7	74		 DB	 116			; 00000074H
  000f8	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninitialized_copy@PBU?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@YAPAU?$pair@IPBD@0@QBU10@0PAU10@AAV?$allocator@U?$pair@IPBD@std@@@0@@Z$0:
  00000	8d 4d dc	 lea	 ecx, DWORD PTR __Backout$2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Uninitialized_backout_al@V?$allocator@U?$pair@IPBD@std@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<std::pair<unsigned int,char const *> > >::~_Uninitialized_backout_al<std::allocator<std::pair<unsigned int,char const *> > >
__ehhandler$??$_Uninitialized_copy@PBU?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@YAPAU?$pair@IPBD@0@QBU10@0PAU10@AAV?$allocator@U?$pair@IPBD@std@@@0@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninitialized_copy@PBU?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@YAPAU?$pair@IPBD@0@QBU10@0PAU10@AAV?$allocator@U?$pair@IPBD@std@@@0@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninitialized_copy@PBU?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@YAPAU?$pair@IPBD@0@QBU10@0PAU10@AAV?$allocator@U?$pair@IPBD@std@@@0@@Z ENDP ; std::_Uninitialized_copy<std::pair<unsigned int,char const *> const *,std::allocator<std::pair<unsigned int,char const *> > >
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__Count$ = 16						; size = 4
?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate, COMDAT

; 751  :     static void deallocate(_Alloc&, const pointer _Ptr, const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 752  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 753  :         _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00003	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	c1 e0 03	 shl	 eax, 3
  00009	50		 push	 eax
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000d	51		 push	 ecx
  0000e	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00013	83 c4 08	 add	 esp, 8

; 754  :     }

  00016	3b ec		 cmp	 ebp, esp
  00018	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\utility
;	COMDAT ??$_Min_value@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
tv65 = -8						; size = 4
$T1 = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Min_value@I@std@@YAABIABI0@Z PROC			; std::_Min_value<unsigned int>, COMDAT

; 25   :     _NOEXCEPT_COND(noexcept(_Right < _Left)) { // return smaller of _Left and _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 26   :     return _Right < _Left ? _Right : _Left;

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00017	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0001a	8b 10		 mov	 edx, DWORD PTR [eax]
  0001c	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0001e	73 08		 jae	 SHORT $LN3@Min_value
  00020	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00023	89 45 f8	 mov	 DWORD PTR tv65[ebp], eax
  00026	eb 06		 jmp	 SHORT $LN4@Min_value
$LN3@Min_value:
  00028	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0002b	89 4d f8	 mov	 DWORD PTR tv65[ebp], ecx
$LN4@Min_value:
  0002e	8b 55 f8	 mov	 edx, DWORD PTR tv65[ebp]
  00031	89 55 fc	 mov	 DWORD PTR $T1[ebp], edx
  00034	8b 45 fc	 mov	 eax, DWORD PTR $T1[ebp]

; 27   : }

  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
??$_Min_value@I@std@@YAABIABI0@Z ENDP			; std::_Min_value<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Ptr$ = -12						; size = 4
__Ptr_container$ = -8					; size = 4
__Block_size$ = -4					; size = 4
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 83   : _DECLSPEC_ALLOCATOR void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000e	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00015	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 84   :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 85   :     const size_t _Block_size = _Non_user_size + _Bytes;

  0001c	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  0001f	83 c0 27	 add	 eax, 39			; 00000027H
  00022	89 45 fc	 mov	 DWORD PTR __Block_size$[ebp], eax

; 86   :     if (_Block_size <= _Bytes) {

  00025	8b 4d fc	 mov	 ecx, DWORD PTR __Block_size$[ebp]
  00028	3b 4d 08	 cmp	 ecx, DWORD PTR __Bytes$[ebp]
  0002b	77 05		 ja	 SHORT $LN8@Allocate_m

; 87   :         _Throw_bad_array_new_length(); // add overflow

  0002d	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN8@Allocate_m:

; 88   :     }
; 89   : 
; 90   :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00032	8b 55 fc	 mov	 edx, DWORD PTR __Block_size$[ebp]
  00035	52		 push	 edx
  00036	e8 00 00 00 00	 call	 ?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
  0003b	83 c4 04	 add	 esp, 4
  0003e	89 45 f8	 mov	 DWORD PTR __Ptr_container$[ebp], eax
$LN4@Allocate_m:

; 91   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00041	83 7d f8 00	 cmp	 DWORD PTR __Ptr_container$[ebp], 0
  00045	74 02		 je	 SHORT $LN7@Allocate_m
  00047	eb 56		 jmp	 SHORT $LN2@Allocate_m
$LN7@Allocate_m:
  00049	8b f4		 mov	 esi, esp
  0004b	68 00 00 00 00	 push	 OFFSET $SG78320
  00050	68 00 00 00 00	 push	 OFFSET $SG78321
  00055	6a 00		 push	 0
  00057	6a 5b		 push	 91			; 0000005bH
  00059	68 00 00 00 00	 push	 OFFSET $SG78322
  0005e	6a 02		 push	 2
  00060	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  00066	83 c4 18	 add	 esp, 24			; 00000018H
  00069	3b f4		 cmp	 esi, esp
  0006b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00070	83 f8 01	 cmp	 eax, 1
  00073	75 01		 jne	 SHORT $LN12@Allocate_m
  00075	cc		 int	 3
$LN12@Allocate_m:
  00076	8b f4		 mov	 esi, esp
  00078	6a 00		 push	 0
  0007a	6a 5b		 push	 91			; 0000005bH
  0007c	68 00 00 00 00	 push	 OFFSET $SG78323
  00081	68 00 00 00 00	 push	 OFFSET $SG78324
  00086	68 00 00 00 00	 push	 OFFSET $SG78325
  0008b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  00091	83 c4 14	 add	 esp, 20			; 00000014H
  00094	3b f4		 cmp	 esi, esp
  00096	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009b	33 c9		 xor	 ecx, ecx
  0009d	75 aa		 jne	 SHORT $LN7@Allocate_m
$LN2@Allocate_m:
  0009f	33 d2		 xor	 edx, edx
  000a1	75 9e		 jne	 SHORT $LN4@Allocate_m

; 92   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  000a3	8b 45 f8	 mov	 eax, DWORD PTR __Ptr_container$[ebp]
  000a6	83 c0 27	 add	 eax, 39			; 00000027H
  000a9	83 e0 e0	 and	 eax, -32		; ffffffe0H
  000ac	89 45 f4	 mov	 DWORD PTR __Ptr$[ebp], eax

; 93   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  000af	b9 04 00 00 00	 mov	 ecx, 4
  000b4	6b d1 ff	 imul	 edx, ecx, -1
  000b7	8b 45 f4	 mov	 eax, DWORD PTR __Ptr$[ebp]
  000ba	8b 4d f8	 mov	 ecx, DWORD PTR __Ptr_container$[ebp]
  000bd	89 0c 10	 mov	 DWORD PTR [eax+edx], ecx

; 94   : 
; 95   : #ifdef _DEBUG
; 96   :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;

  000c0	ba 04 00 00 00	 mov	 edx, 4
  000c5	6b c2 fe	 imul	 eax, edx, -2
  000c8	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  000cb	c7 04 01 fa fa
	fa fa		 mov	 DWORD PTR [ecx+eax], -84215046 ; fafafafaH

; 97   : #endif // _DEBUG
; 98   :     return _Ptr;

  000d2	8b 45 f4	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN11@Allocate_m:

; 99   : }

  000d5	5e		 pop	 esi
  000d6	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d9	3b ec		 cmp	 ebp, esp
  000db	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e0	8b e5		 mov	 esp, ebp
  000e2	5d		 pop	 ebp
  000e3	c3		 ret	 0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\type_traits
;	COMDAT ??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z PROC ; std::forward<std::_Container_base12 *>, COMDAT

; 1420 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1421 :     return static_cast<_Ty&&>(_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1422 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z ENDP ; std::forward<std::_Container_base12 *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstddef
;	COMDAT ??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z PROC ; std::addressof<std::_Container_proxy>, COMDAT

; 279  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept { // return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  :     return __builtin_addressof(_Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 281  : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z ENDP ; std::addressof<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\vector
;	COMDAT ??$_Ucopy@PBU?$pair@IPBD@std@@@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@AAEPAU?$pair@IPBD@1@PBU21@0PAU21@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Ucopy@PBU?$pair@IPBD@std@@@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@AAEPAU?$pair@IPBD@1@PBU21@0PAU21@@Z PROC ; std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > >::_Ucopy<std::pair<unsigned int,char const *> const *>, COMDAT
; _this$ = ecx

; 1543 :     pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Dest) { // copy [_First, _Last) to raw _Dest, using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1544 :         return _Uninitialized_copy(_First, _Last, _Dest, _Getal());

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Getal@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@AAEAAV?$allocator@U?$pair@IPBD@std@@@2@XZ ; std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > >::_Getal
  00016	50		 push	 eax
  00017	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0001a	50		 push	 eax
  0001b	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0001e	51		 push	 ecx
  0001f	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00022	52		 push	 edx
  00023	e8 00 00 00 00	 call	 ??$_Uninitialized_copy@PBU?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@YAPAU?$pair@IPBD@0@QBU10@0PAU10@AAV?$allocator@U?$pair@IPBD@std@@@0@@Z ; std::_Uninitialized_copy<std::pair<unsigned int,char const *> const *,std::allocator<std::pair<unsigned int,char const *> > >
  00028	83 c4 10	 add	 esp, 16			; 00000010H

; 1545 :     }

  0002b	83 c4 04	 add	 esp, 4
  0002e	3b ec		 cmp	 ebp, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@PBU?$pair@IPBD@std@@@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@AAEPAU?$pair@IPBD@1@PBU21@0PAU21@@Z ENDP ; std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > >::_Ucopy<std::pair<unsigned int,char const *> const *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xutility
;	COMDAT ??1?$_Tidy_guard@V?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Tidy_guard@V?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@@std@@QAE@XZ PROC ; std::_Tidy_guard<std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > > >::~_Tidy_guard<std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > > >, COMDAT
; _this$ = ecx

; 3526 :     ~_Tidy_guard() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3527 :         if (_Target) {

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	83 38 00	 cmp	 DWORD PTR [eax], 0
  00014	74 0a		 je	 SHORT $LN1@Tidy_guard

; 3528 :             _Target->_Tidy();

  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0001b	e8 00 00 00 00	 call	 ?_Tidy@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@AAEXXZ ; std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > >::_Tidy
$LN1@Tidy_guard:

; 3529 :         }
; 3530 :     }

  00020	83 c4 04	 add	 esp, 4
  00023	3b ec		 cmp	 ebp, esp
  00025	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
??1?$_Tidy_guard@V?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@@std@@QAE@XZ ENDP ; std::_Tidy_guard<std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > > >::~_Tidy_guard<std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xutility
;	COMDAT ??$distance@PBU?$pair@IPBD@std@@@std@@YAHPBU?$pair@IPBD@0@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$distance@PBU?$pair@IPBD@std@@@std@@YAHPBU?$pair@IPBD@0@0@Z PROC ; std::distance<std::pair<unsigned int,char const *> const *>, COMDAT

; 781  : _NODISCARD _CONSTEXPR17 _Iter_diff_t<_InIt> distance(_InIt _First, _InIt _Last) { // return distance between iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 782  :     if constexpr (_Is_random_iter_v<_InIt>) {
; 783  :         return _Last - _First; // assume the iterator will do debug checking

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00006	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  00009	c1 f8 03	 sar	 eax, 3

; 784  :     } else {
; 785  :         _Adl_verify_range(_First, _Last);
; 786  :         auto _UFirst             = _Get_unwrapped(_First);
; 787  :         const auto _ULast        = _Get_unwrapped(_Last);
; 788  :         _Iter_diff_t<_InIt> _Off = 0;
; 789  :         for (; _UFirst != _ULast; ++_UFirst) {
; 790  :             ++_Off;
; 791  :         }
; 792  : 
; 793  :         return _Off;
; 794  :     }
; 795  : }

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??$distance@PBU?$pair@IPBD@std@@@std@@YAHPBU?$pair@IPBD@0@0@Z ENDP ; std::distance<std::pair<unsigned int,char const *> const *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\type_traits
;	COMDAT ??$forward@ABV?$allocator@U?$pair@IPBD@std@@@std@@@std@@YAABV?$allocator@U?$pair@IPBD@std@@@0@ABV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABV?$allocator@U?$pair@IPBD@std@@@std@@@std@@YAABV?$allocator@U?$pair@IPBD@std@@@0@ABV10@@Z PROC ; std::forward<std::allocator<std::pair<unsigned int,char const *> > const &>, COMDAT

; 1420 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1421 :     return static_cast<_Ty&&>(_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1422 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABV?$allocator@U?$pair@IPBD@std@@@std@@@std@@YAABV?$allocator@U?$pair@IPBD@std@@@0@ABV10@@Z ENDP ; std::forward<std::allocator<std::pair<unsigned int,char const *> > const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z PROC ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >, COMDAT

; 1081 : void _Deallocate_plain(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 1082 :     // deallocate a plain pointer using an allocator
; 1083 :     using _Alloc_traits = allocator_traits<_Alloc>;
; 1084 :     if constexpr (is_same_v<_Alloc_ptr_t<_Alloc>, typename _Alloc::value_type*>) {
; 1085 :         _Alloc_traits::deallocate(_Al, _Ptr, 1);

  00022	6a 01		 push	 1
  00024	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00027	50		 push	 eax
  00028	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  0002b	51		 push	 ecx
  0002c	e8 00 00 00 00	 call	 ?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1086 :     } else {
; 1087 :         using _Ptr_traits = pointer_traits<_Alloc_ptr_t<_Alloc>>;
; 1088 :         _Alloc_traits::deallocate(_Al, _Ptr_traits::pointer_to(*_Ptr), 1);
; 1089 :     }
; 1090 : }

  00034	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00037	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0003e	59		 pop	 ecx
  0003f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00042	3b ec		 cmp	 ebp, esp
  00044	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ENDP ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\type_traits
;	COMDAT ??$forward@AAY05$$CBD@std@@YAAAY05$$CBDAAY05$$CBD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAY05$$CBD@std@@YAAAY05$$CBDAAY05$$CBD@Z PROC ; std::forward<char const (&)[6]>, COMDAT

; 1420 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1421 :     return static_cast<_Ty&&>(_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1422 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAY05$$CBD@std@@YAAAY05$$CBDAAY05$$CBD@Z ENDP ; std::forward<char const (&)[6]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\type_traits
;	COMDAT ??$forward@AAY06$$CBD@std@@YAAAY06$$CBDAAY06$$CBD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAY06$$CBD@std@@YAAAY06$$CBDAAY06$$CBD@Z PROC ; std::forward<char const (&)[7]>, COMDAT

; 1420 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1421 :     return static_cast<_Ty&&>(_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1422 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAY06$$CBD@std@@YAAAY06$$CBDAAY06$$CBD@Z ENDP ; std::forward<char const (&)[7]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\type_traits
;	COMDAT ??$forward@AAY03$$CBD@std@@YAAAY03$$CBDAAY03$$CBD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAY03$$CBD@std@@YAAAY03$$CBDAAY03$$CBD@Z PROC ; std::forward<char const (&)[4]>, COMDAT

; 1420 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1421 :     return static_cast<_Ty&&>(_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1422 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAY03$$CBD@std@@YAAAY03$$CBDAAY03$$CBD@Z ENDP ; std::forward<char const (&)[4]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\type_traits
;	COMDAT ??$forward@AAY04$$CBD@std@@YAAAY04$$CBDAAY04$$CBD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAY04$$CBD@std@@YAAAY04$$CBDAAY04$$CBD@Z PROC ; std::forward<char const (&)[5]>, COMDAT

; 1420 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1421 :     return static_cast<_Ty&&>(_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1422 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAY04$$CBD@std@@YAAAY04$$CBDAAY04$$CBD@Z ENDP ; std::forward<char const (&)[5]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\type_traits
;	COMDAT ??$forward@W4<unnamed-enum-NONE>@@@std@@YA$$QAW4<unnamed-enum-NONE>@@AAW41@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@W4<unnamed-enum-NONE>@@@std@@YA$$QAW4<unnamed-enum-NONE>@@AAW41@@Z PROC ; std::forward<enum <unnamed-enum-NONE> >, COMDAT

; 1420 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1421 :     return static_cast<_Ty&&>(_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1422 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@W4<unnamed-enum-NONE>@@@std@@YA$$QAW4<unnamed-enum-NONE>@@AAW41@@Z ENDP ; std::forward<enum <unnamed-enum-NONE> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\algorithm
;	COMDAT ??$max@H@std@@YAABHABH0@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$max@H@std@@YAABHABH0@Z PROC				; std::max<int>, COMDAT

; 4454 :     const _Ty& _Left, const _Ty& _Right) _NOEXCEPT_COND(noexcept(_Left < _Right)) { // strengthened

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$max@H@std@@YAABHABH0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 4455 :     // return larger of _Left and _Right
; 4456 :     if (_Left < _Right) {

  00023	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00026	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00029	8b 10		 mov	 edx, DWORD PTR [eax]
  0002b	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0002d	7d 73		 jge	 SHORT $LN8@max
$LN4@max:

; 4457 :         _STL_ASSERT(!(_Right < _Left), "invalid comparator");

  0002f	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00032	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  00035	8b 10		 mov	 edx, DWORD PTR [eax]
  00037	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00039	7c 02		 jl	 SHORT $LN7@max
  0003b	eb 5c		 jmp	 SHORT $LN2@max
$LN7@max:
  0003d	8b f4		 mov	 esi, esp
  0003f	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@FEEMDEPI@invalid?5comparator@
  00044	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  00049	6a 00		 push	 0
  0004b	68 69 11 00 00	 push	 4457			; 00001169H
  00050	68 00 00 00 00	 push	 OFFSET ??_C@_0GK@EEDLHHLD@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
  00055	6a 02		 push	 2
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  0005d	83 c4 18	 add	 esp, 24			; 00000018H
  00060	3b f4		 cmp	 esi, esp
  00062	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00067	83 f8 01	 cmp	 eax, 1
  0006a	75 01		 jne	 SHORT $LN12@max
  0006c	cc		 int	 3
$LN12@max:
  0006d	8b f4		 mov	 esi, esp
  0006f	6a 00		 push	 0
  00071	68 69 11 00 00	 push	 4457			; 00001169H
  00076	68 00 00 00 00	 push	 OFFSET ??_C@_1NE@BOCHNKFM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  0007b	68 00 00 00 00	 push	 OFFSET ??_C@_1BC@ICCOKLEG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAm?$AAa?$AAx@
  00080	68 00 00 00 00	 push	 OFFSET ??_C@_1CK@NDNHPKPI@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAc?$AAo?$AAm?$AAp?$AAa?$AAr@
  00085	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  0008b	83 c4 14	 add	 esp, 20			; 00000014H
  0008e	3b f4		 cmp	 esi, esp
  00090	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00095	33 c9		 xor	 ecx, ecx
  00097	75 a4		 jne	 SHORT $LN7@max
$LN2@max:
  00099	33 d2		 xor	 edx, edx
  0009b	75 92		 jne	 SHORT $LN4@max

; 4458 :         return _Right;

  0009d	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  000a0	eb 03		 jmp	 SHORT $LN1@max
$LN8@max:

; 4459 :     }
; 4460 : 
; 4461 :     return _Left;

  000a2	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
$LN1@max:

; 4462 : }

  000a5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000af	59		 pop	 ecx
  000b0	5e		 pop	 esi
  000b1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b4	3b ec		 cmp	 ebp, esp
  000b6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000bb	8b e5		 mov	 esp, ebp
  000bd	5d		 pop	 ebp
  000be	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$max@H@std@@YAABHABH0@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$max@H@std@@YAABHABH0@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$max@H@std@@YAABHABH0@Z ENDP				; std::max<int>
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 183  : void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 184  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 185  : #if defined(_M_IX86) || defined(_M_X64)
; 186  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00022	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  00029	72 10		 jb	 SHORT $LN2@Deallocate

; 187  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);

  0002b	8d 45 0c	 lea	 eax, DWORD PTR __Bytes$[ebp]
  0002e	50		 push	 eax
  0002f	8d 4d 08	 lea	 ecx, DWORD PTR __Ptr$[ebp]
  00032	51		 push	 ecx
  00033	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
  00038	83 c4 08	 add	 esp, 8
$LN2@Deallocate:

; 188  :     }
; 189  : #endif // defined(_M_IX86) || defined(_M_X64)
; 190  : 
; 191  :     ::operator delete(_Ptr, _Bytes);

  0003b	8b 55 0c	 mov	 edx, DWORD PTR __Bytes$[ebp]
  0003e	52		 push	 edx
  0003f	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00048	83 c4 08	 add	 esp, 8

; 192  : }

  0004b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00055	59		 pop	 ecx
  00056	83 c4 0c	 add	 esp, 12			; 0000000cH
  00059	3b ec		 cmp	 ebp, esp
  0005b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@U?$pair@IPBD@std@@@std@@@std@@YAXPAU?$pair@IPBD@0@QAU10@AAV?$allocator@U?$pair@IPBD@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@U?$pair@IPBD@std@@@std@@@std@@YAXPAU?$pair@IPBD@0@QAU10@AAV?$allocator@U?$pair@IPBD@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<std::pair<unsigned int,char const *> > >, COMDAT

; 1027 : void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1028 :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 1029 :     using _Ty = typename _Alloc::value_type;
; 1030 :     if
; 1031 :         _CONSTEXPR_IF(conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 1032 :             (void) _First;
; 1033 :             (void) _Last;
; 1034 :             (void) _Al;
; 1035 :         }
; 1036 :     else {
; 1037 :         for (; _First != _Last; ++_First) {
; 1038 :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 1039 :         }
; 1040 :     }
; 1041 : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@U?$pair@IPBD@std@@@std@@@std@@YAXPAU?$pair@IPBD@0@QAU10@AAV?$allocator@U?$pair@IPBD@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::pair<unsigned int,char const *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 167  : _DECLSPEC_ALLOCATOR void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 168  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 169  : #if defined(_M_IX86) || defined(_M_X64)
; 170  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00003	81 7d 08 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  0000a	72 0e		 jb	 SHORT $LN2@Allocate

; 171  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00015	83 c4 04	 add	 esp, 4
  00018	eb 16		 jmp	 SHORT $LN1@Allocate
$LN2@Allocate:

; 172  :     }
; 173  : #endif // defined(_M_IX86) || defined(_M_X64)
; 174  : 
; 175  :     if (_Bytes != 0) {

  0001a	83 7d 08 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  0001e	74 0e		 je	 SHORT $LN3@Allocate

; 176  :         return _Traits::_Allocate(_Bytes);

  00020	8b 4d 08	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
  00029	83 c4 04	 add	 esp, 4
  0002c	eb 02		 jmp	 SHORT $LN1@Allocate
$LN3@Allocate:

; 177  :     }
; 178  : 
; 179  :     return nullptr;

  0002e	33 c0		 xor	 eax, eax
$LN1@Allocate:

; 180  : }

  00030	3b ec		 cmp	 ebp, esp
  00032	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ??$_Get_size_of_n@$07@std@@YAII@Z
_TEXT	SEGMENT
__Max_possible$1 = -8					; size = 4
__Overflow_is_possible$ = -1				; size = 1
__Count$ = 8						; size = 4
??$_Get_size_of_n@$07@std@@YAII@Z PROC			; std::_Get_size_of_n<8>, COMDAT

; 24   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 25   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00014	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$[ebp], 1

; 26   : 
; 27   :     if
; 28   :         _CONSTEXPR_IF(_Overflow_is_possible) {
; 29   :             constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  00018	c7 45 f8 ff ff
	ff 1f		 mov	 DWORD PTR __Max_possible$1[ebp], 536870911 ; 1fffffffH

; 30   :             if (_Count > _Max_possible) {

  0001f	81 7d 08 ff ff
	ff 1f		 cmp	 DWORD PTR __Count$[ebp], 536870911 ; 1fffffffH
  00026	76 05		 jbe	 SHORT $LN2@Get_size_o

; 31   :                 _Throw_bad_array_new_length(); // multiply overflow

  00028	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN2@Get_size_o:

; 32   :             }
; 33   :         }
; 34   : 
; 35   :     return _Count * _Ty_size;

  0002d	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00030	c1 e0 03	 shl	 eax, 3
$LN3@Get_size_o:

; 36   : }

  00033	83 c4 08	 add	 esp, 8
  00036	3b ec		 cmp	 ebp, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
??$_Get_size_of_n@$07@std@@YAII@Z ENDP			; std::_Get_size_of_n<8>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z PROC ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>, COMDAT

; 198  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) _NOEXCEPT_COND(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 199  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  0000b	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z ; std::addressof<std::_Container_proxy>
  00014	83 c4 04	 add	 esp, 4
  00017	50		 push	 eax
  00018	6a 08		 push	 8
  0001a	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  0001f	83 c4 08	 add	 esp, 8
  00022	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00028	51		 push	 ecx
  00029	e8 00 00 00 00	 call	 ??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z ; std::forward<std::_Container_base12 *>
  0002e	83 c4 04	 add	 esp, 4
  00031	8b 10		 mov	 edx, DWORD PTR [eax]
  00033	52		 push	 edx
  00034	8b 4d fc	 mov	 ecx, DWORD PTR $T1[ebp]
  00037	e8 00 00 00 00	 call	 ??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z ; std::_Container_proxy::_Container_proxy

; 200  :         _Ty(_STD forward<_Types>(_Args)...);
; 201  : }

  0003c	83 c4 04	 add	 esp, 4
  0003f	3b ec		 cmp	 ebp, esp
  00041	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z ENDP ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstddef
;	COMDAT ??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z PROC ; std::addressof<std::_Container_base12>, COMDAT

; 279  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept { // return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  :     return __builtin_addressof(_Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 281  : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z ENDP ; std::addressof<std::_Container_base12>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstddef
;	COMDAT ??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z PROC ; std::_Unfancy<std::_Container_proxy>, COMDAT

; 293  : _Ty* _Unfancy(_Ty* _Ptr) { // do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 294  :     return _Ptr;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 295  : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ENDP ; std::_Unfancy<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\vector
;	COMDAT ??$_Range_construct_or_tidy@PBU?$pair@IPBD@std@@@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@AAEXPBU?$pair@IPBD@1@0Uforward_iterator_tag@1@@Z
_TEXT	SEGMENT
__My_data$2 = -36					; size = 4
__Guard$3 = -28						; size = 4
__Count$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Range_construct_or_tidy@PBU?$pair@IPBD@std@@@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@AAEXPBU?$pair@IPBD@1@0Uforward_iterator_tag@1@@Z PROC ; std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > >::_Range_construct_or_tidy<std::pair<unsigned int,char const *> const *>, COMDAT
; _this$ = ecx

; 435  :     void _Range_construct_or_tidy(_Iter _First, _Iter _Last, forward_iterator_tag) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Range_construct_or_tidy@PBU?$pair@IPBD@std@@@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@AAEXPBU?$pair@IPBD@1@0Uforward_iterator_tag@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	89 45 dc	 mov	 DWORD PTR [ebp-36], eax
  0001c	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  0001f	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  00022	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00025	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00028	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	50		 push	 eax
  00033	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00036	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003c	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 436  :         // initialize with forward range [_First, _Last)
; 437  :         const auto _Count = _Convert_size<size_type>(static_cast<size_t>(_STD distance(_First, _Last)));

  0003f	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00042	50		 push	 eax
  00043	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00046	51		 push	 ecx
  00047	e8 00 00 00 00	 call	 ??$distance@PBU?$pair@IPBD@std@@@std@@YAHPBU?$pair@IPBD@0@0@Z ; std::distance<std::pair<unsigned int,char const *> const *>
  0004c	83 c4 08	 add	 esp, 8
  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 ??$_Convert_size@I@std@@YAII@Z ; std::_Convert_size<unsigned int>
  00055	83 c4 04	 add	 esp, 4
  00058	89 45 ec	 mov	 DWORD PTR __Count$[ebp], eax

; 438  :         if (_Count != 0) {

  0005b	83 7d ec 00	 cmp	 DWORD PTR __Count$[ebp], 0
  0005f	74 52		 je	 SHORT $LN1@Range_cons

; 439  :             _Buy_nonzero(_Count);

  00061	8b 55 ec	 mov	 edx, DWORD PTR __Count$[ebp]
  00064	52		 push	 edx
  00065	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00068	e8 00 00 00 00	 call	 ?_Buy_nonzero@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@AAEXI@Z ; std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > >::_Buy_nonzero

; 440  :             _Tidy_guard<vector> _Guard{this};

  0006d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00070	89 45 e4	 mov	 DWORD PTR __Guard$3[ebp], eax
  00073	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 441  :             auto& _My_data   = _Mypair._Myval2;

  0007a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0007d	89 4d dc	 mov	 DWORD PTR __My_data$2[ebp], ecx

; 442  :             _My_data._Mylast = _Ucopy(_First, _Last, _My_data._Myfirst);

  00080	8b 55 dc	 mov	 edx, DWORD PTR __My_data$2[ebp]
  00083	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00086	50		 push	 eax
  00087	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0008a	51		 push	 ecx
  0008b	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0008e	52		 push	 edx
  0008f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00092	e8 00 00 00 00	 call	 ??$_Ucopy@PBU?$pair@IPBD@std@@@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@AAEPAU?$pair@IPBD@1@PBU21@0PAU21@@Z ; std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > >::_Ucopy<std::pair<unsigned int,char const *> const *>
  00097	8b 4d dc	 mov	 ecx, DWORD PTR __My_data$2[ebp]
  0009a	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 443  :             _Guard._Target   = nullptr;

  0009d	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR __Guard$3[ebp], 0

; 444  :         }

  000a4	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000ab	8d 4d e4	 lea	 ecx, DWORD PTR __Guard$3[ebp]
  000ae	e8 00 00 00 00	 call	 ??1?$_Tidy_guard@V?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > > >::~_Tidy_guard<std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > > >
$LN1@Range_cons:

; 445  :     }

  000b3	52		 push	 edx
  000b4	8b cd		 mov	 ecx, ebp
  000b6	50		 push	 eax
  000b7	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN8@Range_cons
  000bd	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000c2	58		 pop	 eax
  000c3	5a		 pop	 edx
  000c4	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ce	59		 pop	 ecx
  000cf	83 c4 24	 add	 esp, 36			; 00000024H
  000d2	3b ec		 cmp	 ebp, esp
  000d4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d9	8b e5		 mov	 esp, ebp
  000db	5d		 pop	 ebp
  000dc	c2 0c 00	 ret	 12			; 0000000cH
  000df	90		 npad	 1
$LN8@Range_cons:
  000e0	01 00 00 00	 DD	 1
  000e4	00 00 00 00	 DD	 $LN7@Range_cons
$LN7@Range_cons:
  000e8	e4 ff ff ff	 DD	 -28			; ffffffe4H
  000ec	04 00 00 00	 DD	 4
  000f0	00 00 00 00	 DD	 $LN5@Range_cons
$LN5@Range_cons:
  000f4	5f		 DB	 95			; 0000005fH
  000f5	47		 DB	 71			; 00000047H
  000f6	75		 DB	 117			; 00000075H
  000f7	61		 DB	 97			; 00000061H
  000f8	72		 DB	 114			; 00000072H
  000f9	64		 DB	 100			; 00000064H
  000fa	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Range_construct_or_tidy@PBU?$pair@IPBD@std@@@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@AAEXPBU?$pair@IPBD@1@0Uforward_iterator_tag@1@@Z$0:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR __Guard$3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tidy_guard@V?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > > >::~_Tidy_guard<std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > > >
__ehhandler$??$_Range_construct_or_tidy@PBU?$pair@IPBD@std@@@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@AAEXPBU?$pair@IPBD@1@0Uforward_iterator_tag@1@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Range_construct_or_tidy@PBU?$pair@IPBD@std@@@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@AAEXPBU?$pair@IPBD@1@0Uforward_iterator_tag@1@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Range_construct_or_tidy@PBU?$pair@IPBD@std@@@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@AAEXPBU?$pair@IPBD@1@0Uforward_iterator_tag@1@@Z ENDP ; std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > >::_Range_construct_or_tidy<std::pair<unsigned int,char const *> const *>
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ PROC ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >, COMDAT
; _this$ = ecx

; 1382 :     ~_Container_proxy_ptr12() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1383 :         if (_Ptr) {

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	83 38 00	 cmp	 DWORD PTR [eax], 0
  00014	74 15		 je	 SHORT $LN1@Container_

; 1384 :             _Delete_plain_internal(_Al, _Ptr);

  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001b	52		 push	 edx
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00022	51		 push	 ecx
  00023	e8 00 00 00 00	 call	 ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
  00028	83 c4 08	 add	 esp, 8
$LN1@Container_:

; 1385 :         }
; 1386 :     }

  0002b	83 c4 04	 add	 esp, 4
  0002e	3b ec		 cmp	 ebp, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ENDP ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
__Al_$ = 8						; size = 4
__Mycont$ = 12						; size = 4
??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z PROC ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >, COMDAT
; _this$ = ecx

; 1368 :     _Container_proxy_ptr12(_Alloc& _Al_, _Container_base12& _Mycont)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1369 :         : _Al(_Al_) { // create a new _Container_proxy pointing at _Mycont

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Al_$[ebp]
  0001d	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1370 :         _Ptr = _Unfancy(_Al_.allocate(1));

  00020	6a 01		 push	 1
  00022	8b 4d 08	 mov	 ecx, DWORD PTR __Al_$[ebp]
  00025	e8 00 00 00 00	 call	 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ; std::_Unfancy<std::_Container_proxy>
  00030	83 c4 04	 add	 esp, 4
  00033	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00036	89 02		 mov	 DWORD PTR [edx], eax

; 1371 :         _Construct_in_place(*_Ptr, _STD addressof(_Mycont));

  00038	8b 45 0c	 mov	 eax, DWORD PTR __Mycont$[ebp]
  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 ??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z ; std::addressof<std::_Container_base12>
  00041	83 c4 04	 add	 esp, 4
  00044	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
  00047	8d 4d f8	 lea	 ecx, DWORD PTR $T1[ebp]
  0004a	51		 push	 ecx
  0004b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0004e	8b 02		 mov	 eax, DWORD PTR [edx]
  00050	50		 push	 eax
  00051	e8 00 00 00 00	 call	 ??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
  00056	83 c4 08	 add	 esp, 8

; 1372 :         _Mycont._Myproxy = _Ptr;

  00059	8b 4d 0c	 mov	 ecx, DWORD PTR __Mycont$[ebp]
  0005c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0005f	8b 02		 mov	 eax, DWORD PTR [edx]
  00061	89 01		 mov	 DWORD PTR [ecx], eax

; 1373 :     }

  00063	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00066	83 c4 08	 add	 esp, 8
  00069	3b ec		 cmp	 ebp, esp
  0006b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c2 08 00	 ret	 8
??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z ENDP ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ??$?0ABV?$allocator@U?$pair@IPBD@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$pair@IPBD@std@@@std@@V?$_Vector_val@U?$_Simple_types@U?$pair@IPBD@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@U?$pair@IPBD@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0ABV?$allocator@U?$pair@IPBD@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$pair@IPBD@std@@@std@@V?$_Vector_val@U?$_Simple_types@U?$pair@IPBD@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@U?$pair@IPBD@std@@@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::pair<unsigned int,char const *> >,std::_Vector_val<std::_Simple_types<std::pair<unsigned int,char const *> > >,1>::_Compressed_pair<std::allocator<std::pair<unsigned int,char const *> >,std::_Vector_val<std::_Simple_types<std::pair<unsigned int,char const *> > >,1><std::allocator<std::pair<unsigned int,char const *> > const &>, COMDAT
; _this$ = ecx

; 1418 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 0c	 mov	 eax, DWORD PTR __Val1$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$forward@ABV?$allocator@U?$pair@IPBD@std@@@std@@@std@@YAABV?$allocator@U?$pair@IPBD@std@@@0@ABV10@@Z ; std::forward<std::allocator<std::pair<unsigned int,char const *> > const &>
  00017	83 c4 04	 add	 esp, 4
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@U?$pair@IPBD@std@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<std::pair<unsigned int,char const *> > >::_Vector_val<std::_Simple_types<std::pair<unsigned int,char const *> > >
  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	83 c4 04	 add	 esp, 4
  00028	3b ec		 cmp	 ebp, esp
  0002a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 08 00	 ret	 8
??$?0ABV?$allocator@U?$pair@IPBD@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$pair@IPBD@std@@@std@@V?$_Vector_val@U?$_Simple_types@U?$pair@IPBD@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@U?$pair@IPBD@std@@@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::pair<unsigned int,char const *> >,std::_Vector_val<std::_Simple_types<std::pair<unsigned int,char const *> > >,1>::_Compressed_pair<std::allocator<std::pair<unsigned int,char const *> >,std::_Vector_val<std::_Simple_types<std::pair<unsigned int,char const *> > >,1><std::allocator<std::pair<unsigned int,char const *> > const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z PROC ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >, COMDAT

; 1109 : void _Delete_plain_internal(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1110 :     // destroy *_Ptr in place, then deallocate _Ptr using _Al; used for internal container types the user didn't name
; 1111 :     using _Ty = typename _Alloc::value_type;
; 1112 :     _Ptr->~_Ty();
; 1113 :     _Deallocate_plain(_Al, _Ptr);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  0000a	51		 push	 ecx
  0000b	e8 00 00 00 00	 call	 ??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
  00010	83 c4 08	 add	 esp, 8

; 1114 : }

  00013	3b ec		 cmp	 ebp, esp
  00015	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ENDP ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\utility
;	COMDAT ??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z
_TEXT	SEGMENT
__Old_val$ = -4						; size = 4
__Val$ = 8						; size = 4
__New_val$ = 12						; size = 4
??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z PROC ; std::exchange<std::_Container_proxy *,std::nullptr_t>, COMDAT

; 526  : _Ty exchange(_Ty& _Val, _Other&& _New_val) { // assign _New_val to _Val, return previous _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 527  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  0000b	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0000e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00010	89 4d fc	 mov	 DWORD PTR __Old_val$[ebp], ecx

; 528  :     _Val         = static_cast<_Other&&>(_New_val);

  00013	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  00016	8b 45 0c	 mov	 eax, DWORD PTR __New_val$[ebp]
  00019	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001b	89 0a		 mov	 DWORD PTR [edx], ecx

; 529  :     return _Old_val;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR __Old_val$[ebp]

; 530  : }

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z ENDP ; std::exchange<std::_Container_proxy *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ??$?0U?$pair@IPBD@std@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@U?$pair@IPBD@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0U?$pair@IPBD@std@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@U?$pair@IPBD@std@@@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::pair<unsigned int,char const *> >, COMDAT
; _this$ = ecx

; 863  :     constexpr allocator(const allocator<_Other>&) noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
??$?0U?$pair@IPBD@std@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@U?$pair@IPBD@std@@@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::pair<unsigned int,char const *> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z PROC ; std::allocator<std::_Container_proxy>::allocate, COMDAT
; _this$ = ecx

; 870  :     _NODISCARD _DECLSPEC_ALLOCATOR _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 871  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$_Get_size_of_n@$07@std@@YAII@Z ; std::_Get_size_of_n<8>
  00017	83 c4 04	 add	 esp, 4
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00020	83 c4 04	 add	 esp, 4

; 872  :     }

  00023	83 c4 04	 add	 esp, 4
  00026	3b ec		 cmp	 ebp, esp
  00028	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ENDP ; std::allocator<std::_Container_proxy>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??__Fsimd_str_list@?1??get_simd_str@@YAPBDI@Z@YAXXZ
text$yd	SEGMENT
??__Fsimd_str_list@?1??get_simd_str@@YAPBDI@Z@YAXXZ PROC ; `get_simd_str'::`2'::`dynamic atexit destructor for 'simd_str_list'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?simd_str_list@?1??get_simd_str@@YAPBDI@Z@4V?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@A
  00008	e8 00 00 00 00	 call	 ??1?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@QAE@XZ ; std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > >::~vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > >
  0000d	3b ec		 cmp	 ebp, esp
  0000f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??__Fsimd_str_list@?1??get_simd_str@@YAPBDI@Z@YAXXZ ENDP ; `get_simd_str'::`2'::`dynamic atexit destructor for 'simd_str_list''
text$yd	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\utility
;	COMDAT ??$?0W4<unnamed-enum-NONE>@@AAY05$$CBD$0A@@?$pair@IPBD@std@@QAE@$$QAW4<unnamed-enum-NONE>@@AAY05$$CBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0W4<unnamed-enum-NONE>@@AAY05$$CBD$0A@@?$pair@IPBD@std@@QAE@$$QAW4<unnamed-enum-NONE>@@AAY05$$CBD@Z PROC ; std::pair<unsigned int,char const *>::pair<unsigned int,char const *><enum <unnamed-enum-NONE>,char const (&)[6],0>, COMDAT
; _this$ = ecx

; 127  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$forward@W4<unnamed-enum-NONE>@@@std@@YA$$QAW4<unnamed-enum-NONE>@@AAW41@@Z ; std::forward<enum <unnamed-enum-NONE> >
  00017	83 c4 04	 add	 esp, 4
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	8b 10		 mov	 edx, DWORD PTR [eax]
  0001f	89 11		 mov	 DWORD PTR [ecx], edx
  00021	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??$forward@AAY05$$CBD@std@@YAAAY05$$CBDAAY05$$CBD@Z ; std::forward<char const (&)[6]>
  0002a	83 c4 04	 add	 esp, 4
  0002d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00033	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00036	83 c4 04	 add	 esp, 4
  00039	3b ec		 cmp	 ebp, esp
  0003b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 08 00	 ret	 8
??$?0W4<unnamed-enum-NONE>@@AAY05$$CBD$0A@@?$pair@IPBD@std@@QAE@$$QAW4<unnamed-enum-NONE>@@AAY05$$CBD@Z ENDP ; std::pair<unsigned int,char const *>::pair<unsigned int,char const *><enum <unnamed-enum-NONE>,char const (&)[6],0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\utility
;	COMDAT ??$?0W4<unnamed-enum-NONE>@@AAY06$$CBD$0A@@?$pair@IPBD@std@@QAE@$$QAW4<unnamed-enum-NONE>@@AAY06$$CBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0W4<unnamed-enum-NONE>@@AAY06$$CBD$0A@@?$pair@IPBD@std@@QAE@$$QAW4<unnamed-enum-NONE>@@AAY06$$CBD@Z PROC ; std::pair<unsigned int,char const *>::pair<unsigned int,char const *><enum <unnamed-enum-NONE>,char const (&)[7],0>, COMDAT
; _this$ = ecx

; 127  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$forward@W4<unnamed-enum-NONE>@@@std@@YA$$QAW4<unnamed-enum-NONE>@@AAW41@@Z ; std::forward<enum <unnamed-enum-NONE> >
  00017	83 c4 04	 add	 esp, 4
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	8b 10		 mov	 edx, DWORD PTR [eax]
  0001f	89 11		 mov	 DWORD PTR [ecx], edx
  00021	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??$forward@AAY06$$CBD@std@@YAAAY06$$CBDAAY06$$CBD@Z ; std::forward<char const (&)[7]>
  0002a	83 c4 04	 add	 esp, 4
  0002d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00033	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00036	83 c4 04	 add	 esp, 4
  00039	3b ec		 cmp	 ebp, esp
  0003b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 08 00	 ret	 8
??$?0W4<unnamed-enum-NONE>@@AAY06$$CBD$0A@@?$pair@IPBD@std@@QAE@$$QAW4<unnamed-enum-NONE>@@AAY06$$CBD@Z ENDP ; std::pair<unsigned int,char const *>::pair<unsigned int,char const *><enum <unnamed-enum-NONE>,char const (&)[7],0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\utility
;	COMDAT ??$?0W4<unnamed-enum-NONE>@@AAY03$$CBD$0A@@?$pair@IPBD@std@@QAE@$$QAW4<unnamed-enum-NONE>@@AAY03$$CBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0W4<unnamed-enum-NONE>@@AAY03$$CBD$0A@@?$pair@IPBD@std@@QAE@$$QAW4<unnamed-enum-NONE>@@AAY03$$CBD@Z PROC ; std::pair<unsigned int,char const *>::pair<unsigned int,char const *><enum <unnamed-enum-NONE>,char const (&)[4],0>, COMDAT
; _this$ = ecx

; 127  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$forward@W4<unnamed-enum-NONE>@@@std@@YA$$QAW4<unnamed-enum-NONE>@@AAW41@@Z ; std::forward<enum <unnamed-enum-NONE> >
  00017	83 c4 04	 add	 esp, 4
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	8b 10		 mov	 edx, DWORD PTR [eax]
  0001f	89 11		 mov	 DWORD PTR [ecx], edx
  00021	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??$forward@AAY03$$CBD@std@@YAAAY03$$CBDAAY03$$CBD@Z ; std::forward<char const (&)[4]>
  0002a	83 c4 04	 add	 esp, 4
  0002d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00033	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00036	83 c4 04	 add	 esp, 4
  00039	3b ec		 cmp	 ebp, esp
  0003b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 08 00	 ret	 8
??$?0W4<unnamed-enum-NONE>@@AAY03$$CBD$0A@@?$pair@IPBD@std@@QAE@$$QAW4<unnamed-enum-NONE>@@AAY03$$CBD@Z ENDP ; std::pair<unsigned int,char const *>::pair<unsigned int,char const *><enum <unnamed-enum-NONE>,char const (&)[4],0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\utility
;	COMDAT ??$?0W4<unnamed-enum-NONE>@@AAY04$$CBD$0A@@?$pair@IPBD@std@@QAE@$$QAW4<unnamed-enum-NONE>@@AAY04$$CBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0W4<unnamed-enum-NONE>@@AAY04$$CBD$0A@@?$pair@IPBD@std@@QAE@$$QAW4<unnamed-enum-NONE>@@AAY04$$CBD@Z PROC ; std::pair<unsigned int,char const *>::pair<unsigned int,char const *><enum <unnamed-enum-NONE>,char const (&)[5],0>, COMDAT
; _this$ = ecx

; 127  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$forward@W4<unnamed-enum-NONE>@@@std@@YA$$QAW4<unnamed-enum-NONE>@@AAW41@@Z ; std::forward<enum <unnamed-enum-NONE> >
  00017	83 c4 04	 add	 esp, 4
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	8b 10		 mov	 edx, DWORD PTR [eax]
  0001f	89 11		 mov	 DWORD PTR [ecx], edx
  00021	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??$forward@AAY04$$CBD@std@@YAAAY04$$CBDAAY04$$CBD@Z ; std::forward<char const (&)[5]>
  0002a	83 c4 04	 add	 esp, 4
  0002d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00033	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00036	83 c4 04	 add	 esp, 4
  00039	3b ec		 cmp	 ebp, esp
  0003b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 08 00	 ret	 8
??$?0W4<unnamed-enum-NONE>@@AAY04$$CBD$0A@@?$pair@IPBD@std@@QAE@$$QAW4<unnamed-enum-NONE>@@AAY04$$CBD@Z ENDP ; std::pair<unsigned int,char const *>::pair<unsigned int,char const *><enum <unnamed-enum-NONE>,char const (&)[5],0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\initializer_list
;	COMDAT ?end@?$initializer_list@U?$pair@IPBD@std@@@std@@QBEPBU?$pair@IPBD@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?end@?$initializer_list@U?$pair@IPBD@std@@@std@@QBEPBU?$pair@IPBD@2@XZ PROC ; std::initializer_list<std::pair<unsigned int,char const *> >::end, COMDAT
; _this$ = ecx

; 38   :     _NODISCARD constexpr const _Elem* end() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 39   :         return _Last;

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 40   :     }

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?end@?$initializer_list@U?$pair@IPBD@std@@@std@@QBEPBU?$pair@IPBD@2@XZ ENDP ; std::initializer_list<std::pair<unsigned int,char const *> >::end
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\initializer_list
;	COMDAT ?begin@?$initializer_list@U?$pair@IPBD@std@@@std@@QBEPBU?$pair@IPBD@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?begin@?$initializer_list@U?$pair@IPBD@std@@@std@@QBEPBU?$pair@IPBD@2@XZ PROC ; std::initializer_list<std::pair<unsigned int,char const *> >::begin, COMDAT
; _this$ = ecx

; 34   :     _NODISCARD constexpr const _Elem* begin() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 35   :         return _First;

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 00		 mov	 eax, DWORD PTR [eax]

; 36   :     }

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?begin@?$initializer_list@U?$pair@IPBD@std@@@std@@QBEPBU?$pair@IPBD@2@XZ ENDP ; std::initializer_list<std::pair<unsigned int,char const *> >::begin
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\initializer_list
;	COMDAT ??0?$initializer_list@U?$pair@IPBD@std@@@std@@QAE@PBU?$pair@IPBD@1@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First_arg$ = 8					; size = 4
__Last_arg$ = 12					; size = 4
??0?$initializer_list@U?$pair@IPBD@std@@@std@@QAE@PBU?$pair@IPBD@1@0@Z PROC ; std::initializer_list<std::pair<unsigned int,char const *> >::initializer_list<std::pair<unsigned int,char const *> >, COMDAT
; _this$ = ecx

; 32   :         : _First(_First_arg), _Last(_Last_arg) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 4d 08	 mov	 ecx, DWORD PTR __First_arg$[ebp]
  00014	89 08		 mov	 DWORD PTR [eax], ecx
  00016	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00019	8b 45 0c	 mov	 eax, DWORD PTR __Last_arg$[ebp]
  0001c	89 42 04	 mov	 DWORD PTR [edx+4], eax
  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0?$initializer_list@U?$pair@IPBD@std@@@std@@QAE@PBU?$pair@IPBD@1@0@Z ENDP ; std::initializer_list<std::pair<unsigned int,char const *> >::initializer_list<std::pair<unsigned int,char const *> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$pair@IPBD@std@@@std@@V?$_Vector_val@U?$_Simple_types@U?$pair@IPBD@std@@@std@@@2@$00@std@@QBEABV?$allocator@U?$pair@IPBD@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@U?$pair@IPBD@std@@@std@@V?$_Vector_val@U?$_Simple_types@U?$pair@IPBD@std@@@std@@@2@$00@std@@QBEABV?$allocator@U?$pair@IPBD@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::pair<unsigned int,char const *> >,std::_Vector_val<std::_Simple_types<std::pair<unsigned int,char const *> > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1424 :     const _Ty1& _Get_first() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1425 :         return *this;

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1426 :     }

  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$pair@IPBD@std@@@std@@V?$_Vector_val@U?$_Simple_types@U?$pair@IPBD@std@@@std@@@2@$00@std@@QBEABV?$allocator@U?$pair@IPBD@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::pair<unsigned int,char const *> >,std::_Vector_val<std::_Simple_types<std::pair<unsigned int,char const *> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$pair@IPBD@std@@@std@@V?$_Vector_val@U?$_Simple_types@U?$pair@IPBD@std@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$pair@IPBD@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@U?$pair@IPBD@std@@@std@@V?$_Vector_val@U?$_Simple_types@U?$pair@IPBD@std@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$pair@IPBD@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::pair<unsigned int,char const *> >,std::_Vector_val<std::_Simple_types<std::pair<unsigned int,char const *> > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1420 :     _Ty1& _Get_first() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1421 :         return *this;

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1422 :     }

  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$pair@IPBD@std@@@std@@V?$_Vector_val@U?$_Simple_types@U?$pair@IPBD@std@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$pair@IPBD@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::pair<unsigned int,char const *> >,std::_Vector_val<std::_Simple_types<std::pair<unsigned int,char const *> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@U?$pair@IPBD@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Vector_val@U?$_Simple_types@U?$pair@IPBD@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<std::pair<unsigned int,char const *> > >::_Vector_val<std::_Simple_types<std::pair<unsigned int,char const *> > >, COMDAT
; _this$ = ecx

; 314  :     _Vector_val() : _Myfirst(), _Mylast(), _Myend() { // initialize values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12
  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  0002a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002d	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0

; 315  :     }

  00034	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00037	83 c4 04	 add	 esp, 4
  0003a	3b ec		 cmp	 ebp, esp
  0003c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@U?$pair@IPBD@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<std::pair<unsigned int,char const *> > >::_Vector_val<std::_Simple_types<std::pair<unsigned int,char const *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\vector
;	COMDAT ?_Getal@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@ABEABV?$allocator@U?$pair@IPBD@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@ABEABV?$allocator@U?$pair@IPBD@std@@@2@XZ PROC ; std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > >::_Getal, COMDAT
; _this$ = ecx

; 1692 :     const _Alty& _Getal() const noexcept { // return const reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1693 :         return _Mypair._Get_first();

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@U?$pair@IPBD@std@@@std@@V?$_Vector_val@U?$_Simple_types@U?$pair@IPBD@std@@@std@@@2@$00@std@@QBEABV?$allocator@U?$pair@IPBD@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::pair<unsigned int,char const *> >,std::_Vector_val<std::_Simple_types<std::pair<unsigned int,char const *> > >,1>::_Get_first

; 1694 :     }

  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
?_Getal@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@ABEABV?$allocator@U?$pair@IPBD@std@@@2@XZ ENDP ; std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\vector
;	COMDAT ?_Getal@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@AAEAAV?$allocator@U?$pair@IPBD@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@AAEAAV?$allocator@U?$pair@IPBD@std@@@2@XZ PROC ; std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > >::_Getal, COMDAT
; _this$ = ecx

; 1688 :     _Alty& _Getal() noexcept { // return reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1689 :         return _Mypair._Get_first();

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@U?$pair@IPBD@std@@@std@@V?$_Vector_val@U?$_Simple_types@U?$pair@IPBD@std@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$pair@IPBD@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::pair<unsigned int,char const *> >,std::_Vector_val<std::_Simple_types<std::pair<unsigned int,char const *> > >,1>::_Get_first

; 1690 :     }

  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
?_Getal@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@AAEAAV?$allocator@U?$pair@IPBD@std@@@2@XZ ENDP ; std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\vector
;	COMDAT ?_Xlength@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@CAXXZ PROC ; std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > >::_Xlength, COMDAT

; 1660 :     [[noreturn]] static void _Xlength() { // report a length_error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1661 :         _Xlength_error("vector<T> too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1662 :     }

  0000d	3b ec		 cmp	 ebp, esp
  0000f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Xlength@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@CAXXZ ENDP ; std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\vector
;	COMDAT ?_Tidy@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@AAEXXZ
_TEXT	SEGMENT
__Myend$ = -32						; size = 4
__Mylast$ = -28						; size = 4
__Myfirst$ = -24					; size = 4
__My_data$ = -20					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?_Tidy@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@AAEXXZ PROC ; std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > >::_Tidy, COMDAT
; _this$ = ecx

; 1642 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Tidy@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@AAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  0001c	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  0001f	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00022	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00025	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002d	33 c5		 xor	 eax, ebp
  0002f	50		 push	 eax
  00030	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00033	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00039	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1643 :         auto& _My_data    = _Mypair._Myval2;

  0003c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0003f	89 45 ec	 mov	 DWORD PTR __My_data$[ebp], eax

; 1644 :         pointer& _Myfirst = _My_data._Myfirst;

  00042	8b 4d ec	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00045	83 c1 04	 add	 ecx, 4
  00048	89 4d e8	 mov	 DWORD PTR __Myfirst$[ebp], ecx

; 1645 :         pointer& _Mylast  = _My_data._Mylast;

  0004b	8b 55 ec	 mov	 edx, DWORD PTR __My_data$[ebp]
  0004e	83 c2 08	 add	 edx, 8
  00051	89 55 e4	 mov	 DWORD PTR __Mylast$[ebp], edx

; 1646 :         pointer& _Myend   = _My_data._Myend;

  00054	8b 45 ec	 mov	 eax, DWORD PTR __My_data$[ebp]
  00057	83 c0 0c	 add	 eax, 12			; 0000000cH
  0005a	89 45 e0	 mov	 DWORD PTR __Myend$[ebp], eax

; 1647 : 
; 1648 :         _My_data._Orphan_all();

  0005d	8b 4d ec	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00060	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 1649 : 
; 1650 :         if (_Myfirst) { // destroy and deallocate old array

  00065	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00068	83 39 00	 cmp	 DWORD PTR [ecx], 0
  0006b	74 52		 je	 SHORT $LN1@Tidy

; 1651 :             _Destroy(_Myfirst, _Mylast);

  0006d	8b 55 e4	 mov	 edx, DWORD PTR __Mylast$[ebp]
  00070	8b 02		 mov	 eax, DWORD PTR [edx]
  00072	50		 push	 eax
  00073	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00076	8b 11		 mov	 edx, DWORD PTR [ecx]
  00078	52		 push	 edx
  00079	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0007c	e8 00 00 00 00	 call	 ?_Destroy@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@AAEXPAU?$pair@IPBD@2@0@Z ; std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > >::_Destroy

; 1652 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00081	8b 45 e0	 mov	 eax, DWORD PTR __Myend$[ebp]
  00084	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00087	8b 10		 mov	 edx, DWORD PTR [eax]
  00089	2b 11		 sub	 edx, DWORD PTR [ecx]
  0008b	c1 fa 03	 sar	 edx, 3
  0008e	52		 push	 edx
  0008f	8b 45 e8	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00092	8b 08		 mov	 ecx, DWORD PTR [eax]
  00094	51		 push	 ecx
  00095	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00098	e8 00 00 00 00	 call	 ?_Getal@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@AAEAAV?$allocator@U?$pair@IPBD@std@@@2@XZ ; std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > >::_Getal
  0009d	8b c8		 mov	 ecx, eax
  0009f	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U?$pair@IPBD@std@@@std@@QAEXQAU?$pair@IPBD@2@I@Z ; std::allocator<std::pair<unsigned int,char const *> >::deallocate

; 1653 : 
; 1654 :             _Myfirst = pointer();

  000a4	8b 55 e8	 mov	 edx, DWORD PTR __Myfirst$[ebp]
  000a7	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 1655 :             _Mylast  = pointer();

  000ad	8b 45 e4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  000b0	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1656 :             _Myend   = pointer();

  000b6	8b 4d e0	 mov	 ecx, DWORD PTR __Myend$[ebp]
  000b9	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
$LN1@Tidy:

; 1657 :         }
; 1658 :     }

  000bf	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000c9	59		 pop	 ecx
  000ca	83 c4 20	 add	 esp, 32			; 00000020H
  000cd	3b ec		 cmp	 ebp, esp
  000cf	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d4	8b e5		 mov	 esp, ebp
  000d6	5d		 pop	 ebp
  000d7	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Tidy@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@AAEXXZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Tidy@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@AAEXXZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Tidy@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@AAEXXZ ENDP ; std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > >::_Tidy
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\vector
;	COMDAT ?_Buy_nonzero@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@AAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Newcapacity$ = 8					; size = 4
?_Buy_nonzero@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@AAEXI@Z PROC ; std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > >::_Buy_nonzero, COMDAT
; _this$ = ecx

; 1605 :     void _Buy_nonzero(const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1606 :         // allocate array with _Newcapacity elements
; 1607 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1608 :         auto& _My_data    = _Mypair._Myval2;
; 1609 :         pointer& _Myfirst = _My_data._Myfirst;
; 1610 :         pointer& _Mylast  = _My_data._Mylast;
; 1611 :         pointer& _Myend   = _My_data._Myend;
; 1612 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 1613 :         _STL_INTERNAL_CHECK(0 < _Newcapacity);
; 1614 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 1615 : 
; 1616 :         if (_Newcapacity > max_size()) {

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?max_size@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > >::max_size
  00016	39 45 08	 cmp	 DWORD PTR __Newcapacity$[ebp], eax
  00019	76 05		 jbe	 SHORT $LN2@Buy_nonzer

; 1617 :             _Xlength();

  0001b	e8 00 00 00 00	 call	 ?_Xlength@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@CAXXZ ; std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > >::_Xlength
$LN2@Buy_nonzer:

; 1618 :         }
; 1619 : 
; 1620 :         _Buy_raw(_Newcapacity);

  00020	8b 45 08	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  00023	50		 push	 eax
  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ?_Buy_raw@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@AAEXI@Z ; std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > >::_Buy_raw
$LN3@Buy_nonzer:

; 1621 :     }

  0002c	83 c4 04	 add	 esp, 4
  0002f	3b ec		 cmp	 ebp, esp
  00031	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c2 04 00	 ret	 4
?_Buy_nonzero@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@AAEXI@Z ENDP ; std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > >::_Buy_nonzero
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\vector
;	COMDAT ?_Buy_raw@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@AAEXI@Z
_TEXT	SEGMENT
__Newvec$ = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
__Myfirst$ = -12					; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
__Newcapacity$ = 8					; size = 4
?_Buy_raw@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@AAEXI@Z PROC ; std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > >::_Buy_raw, COMDAT
; _this$ = ecx

; 1589 :     void _Buy_raw(const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  0000e	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00011	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00014	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00017	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  0001a	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  0001d	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1590 :         // allocate array with _Newcapacity elements
; 1591 :         auto& _My_data    = _Mypair._Myval2;

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1592 :         pointer& _Myfirst = _My_data._Myfirst;

  00026	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00029	83 c1 04	 add	 ecx, 4
  0002c	89 4d f4	 mov	 DWORD PTR __Myfirst$[ebp], ecx

; 1593 :         pointer& _Mylast  = _My_data._Mylast;

  0002f	8b 55 f8	 mov	 edx, DWORD PTR __My_data$[ebp]
  00032	83 c2 08	 add	 edx, 8
  00035	89 55 f0	 mov	 DWORD PTR __Mylast$[ebp], edx

; 1594 :         pointer& _Myend   = _My_data._Myend;

  00038	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  0003b	83 c0 0c	 add	 eax, 12			; 0000000cH
  0003e	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1595 : 
; 1596 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 1597 :         _STL_INTERNAL_CHECK(0 < _Newcapacity && _Newcapacity <= max_size());
; 1598 : 
; 1599 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

  00041	8b 4d 08	 mov	 ecx, DWORD PTR __Newcapacity$[ebp]
  00044	51		 push	 ecx
  00045	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	e8 00 00 00 00	 call	 ?_Getal@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@AAEAAV?$allocator@U?$pair@IPBD@std@@@2@XZ ; std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > >::_Getal
  0004d	8b c8		 mov	 ecx, eax
  0004f	e8 00 00 00 00	 call	 ?allocate@?$allocator@U?$pair@IPBD@std@@@std@@QAEPAU?$pair@IPBD@2@I@Z ; std::allocator<std::pair<unsigned int,char const *> >::allocate
  00054	89 45 e8	 mov	 DWORD PTR __Newvec$[ebp], eax

; 1600 :         _Myfirst           = _Newvec;

  00057	8b 55 f4	 mov	 edx, DWORD PTR __Myfirst$[ebp]
  0005a	8b 45 e8	 mov	 eax, DWORD PTR __Newvec$[ebp]
  0005d	89 02		 mov	 DWORD PTR [edx], eax

; 1601 :         _Mylast            = _Newvec;

  0005f	8b 4d f0	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  00062	8b 55 e8	 mov	 edx, DWORD PTR __Newvec$[ebp]
  00065	89 11		 mov	 DWORD PTR [ecx], edx

; 1602 :         _Myend             = _Newvec + _Newcapacity;

  00067	8b 45 08	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  0006a	8b 4d e8	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0006d	8d 14 c1	 lea	 edx, DWORD PTR [ecx+eax*8]
  00070	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  00073	89 10		 mov	 DWORD PTR [eax], edx

; 1603 :     }

  00075	83 c4 18	 add	 esp, 24			; 00000018H
  00078	3b ec		 cmp	 ebp, esp
  0007a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c2 04 00	 ret	 4
?_Buy_raw@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@AAEXI@Z ENDP ; std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > >::_Buy_raw
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\vector
;	COMDAT ?_Destroy@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@AAEXPAU?$pair@IPBD@2@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@AAEXPAU?$pair@IPBD@2@0@Z PROC ; std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > >::_Destroy, COMDAT
; _this$ = ecx

; 1567 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1568 :         _Destroy_range(_First, _Last, _Getal());

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Getal@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@AAEAAV?$allocator@U?$pair@IPBD@std@@@2@XZ ; std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > >::_Getal
  00016	50		 push	 eax
  00017	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0001a	50		 push	 eax
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@U?$pair@IPBD@std@@@std@@@std@@YAXPAU?$pair@IPBD@0@QAU10@AAV?$allocator@U?$pair@IPBD@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::pair<unsigned int,char const *> > >
  00024	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1569 :     }

  00027	83 c4 04	 add	 esp, 4
  0002a	3b ec		 cmp	 ebp, esp
  0002c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c2 08 00	 ret	 8
?_Destroy@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@AAEXPAU?$pair@IPBD@2@0@Z ENDP ; std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\vector
;	COMDAT ?max_size@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > >::max_size, COMDAT
; _this$ = ecx

; 1441 :     _NODISCARD size_type max_size() const noexcept { // return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1442 :         return _Min_value(

  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	e8 00 00 00 00	 call	 ?_Getal@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@ABEABV?$allocator@U?$pair@IPBD@std@@@2@XZ ; std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > >::_Getal
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ?max_size@?$_Default_allocator_traits@V?$allocator@U?$pair@IPBD@std@@@std@@@std@@SAIABV?$allocator@U?$pair@IPBD@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::pair<unsigned int,char const *> > >::max_size
  0002c	83 c4 04	 add	 esp, 4
  0002f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
  00032	e8 00 00 00 00	 call	 ?max@?$numeric_limits@H@std@@SAHXZ ; std::numeric_limits<int>::max
  00037	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
  0003a	8d 45 f8	 lea	 eax, DWORD PTR $T2[ebp]
  0003d	50		 push	 eax
  0003e	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00041	51		 push	 ecx
  00042	e8 00 00 00 00	 call	 ??$_Min_value@I@std@@YAABIABI0@Z ; std::_Min_value<unsigned int>
  00047	83 c4 08	 add	 esp, 8
  0004a	8b 00		 mov	 eax, DWORD PTR [eax]

; 1443 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1444 :     }

  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004f	3b ec		 cmp	 ebp, esp
  00051	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
?max_size@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\vector
;	COMDAT ?_Unchecked_end@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@QAEPAU?$pair@IPBD@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Unchecked_end@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@QAEPAU?$pair@IPBD@2@XZ PROC ; std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > >::_Unchecked_end, COMDAT
; _this$ = ecx

; 1423 :     pointer _Unchecked_end() noexcept { // return pointer for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1424 :         return _Mypair._Myval2._Mylast;

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 1425 :     }

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?_Unchecked_end@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@QAEPAU?$pair@IPBD@2@XZ ENDP ; std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\vector
;	COMDAT ?_Unchecked_begin@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@QAEPAU?$pair@IPBD@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Unchecked_begin@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@QAEPAU?$pair@IPBD@2@XZ PROC ; std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > >::_Unchecked_begin, COMDAT
; _this$ = ecx

; 1415 :     pointer _Unchecked_begin() noexcept { // return pointer for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1416 :         return _Mypair._Myval2._Myfirst;

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 1417 :     }

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?_Unchecked_begin@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@QAEPAU?$pair@IPBD@2@XZ ENDP ; std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\vector
;	COMDAT ??1?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
$T2 = -36						; size = 4
_$S1$ = -25						; size = 1
__Alproxy$ = -20					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > >::~vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > >, COMDAT
; _this$ = ecx

; 623  :     ~vector() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	89 45 dc	 mov	 DWORD PTR [ebp-36], eax
  0001c	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  0001f	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  00022	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00025	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00028	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	50		 push	 eax
  00033	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00036	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003c	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 624  :         _Tidy();

  0003f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e8 00 00 00 00	 call	 ?_Tidy@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@AAEXXZ ; std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > >::_Tidy

; 625  : #if _ITERATOR_DEBUG_LEVEL != 0
; 626  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  00047	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	e8 00 00 00 00	 call	 ?_Getal@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@AAEAAV?$allocator@U?$pair@IPBD@std@@@2@XZ ; std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > >::_Getal
  0004f	50		 push	 eax
  00050	8d 4d e7	 lea	 ecx, DWORD PTR _$S1$[ebp]
  00053	e8 00 00 00 00	 call	 ??$?0U?$pair@IPBD@std@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@U?$pair@IPBD@std@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::pair<unsigned int,char const *> >
  00058	8d 45 e7	 lea	 eax, DWORD PTR _$S1$[ebp]
  0005b	89 45 ec	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 627  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));

  0005e	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  00065	8d 4d dc	 lea	 ecx, DWORD PTR $T2[ebp]
  00068	51		 push	 ecx
  00069	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0006c	52		 push	 edx
  0006d	e8 00 00 00 00	 call	 ??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z ; std::exchange<std::_Container_proxy *,std::nullptr_t>
  00072	83 c4 08	 add	 esp, 8
  00075	50		 push	 eax
  00076	8b 45 ec	 mov	 eax, DWORD PTR __Alproxy$[ebp]
  00079	50		 push	 eax
  0007a	e8 00 00 00 00	 call	 ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
  0007f	83 c4 08	 add	 esp, 8

; 628  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 629  :     }

  00082	52		 push	 edx
  00083	8b cd		 mov	 ecx, ebp
  00085	50		 push	 eax
  00086	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN6@vector
  0008c	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00091	58		 pop	 eax
  00092	5a		 pop	 edx
  00093	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00096	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0009d	59		 pop	 ecx
  0009e	83 c4 24	 add	 esp, 36			; 00000024H
  000a1	3b ec		 cmp	 ebp, esp
  000a3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a8	8b e5		 mov	 esp, ebp
  000aa	5d		 pop	 ebp
  000ab	c3		 ret	 0
$LN6@vector:
  000ac	01 00 00 00	 DD	 1
  000b0	00 00 00 00	 DD	 $LN5@vector
$LN5@vector:
  000b4	e7 ff ff ff	 DD	 -25			; ffffffe7H
  000b8	01 00 00 00	 DD	 1
  000bc	00 00 00 00	 DD	 $LN3@vector
$LN3@vector:
  000c0	24		 DB	 36			; 00000024H
  000c1	53		 DB	 83			; 00000053H
  000c2	31		 DB	 49			; 00000031H
  000c3	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > >::~vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > >
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\vector
;	COMDAT ??0?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@QAE@V?$initializer_list@U?$pair@IPBD@std@@@1@ABV?$allocator@U?$pair@IPBD@std@@@1@@Z
_TEXT	SEGMENT
$T2 = -51						; size = 1
$T3 = -49						; size = 1
__Proxy$ = -44						; size = 8
_$S2$ = -25						; size = 1
__Alproxy$ = -20					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ilist$ = 8						; size = 8
__Al$ = 16						; size = 4
??0?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@QAE@V?$initializer_list@U?$pair@IPBD@std@@@1@ABV?$allocator@U?$pair@IPBD@std@@@1@@Z PROC ; std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > >::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > >, COMDAT
; _this$ = ecx

; 458  :     vector(initializer_list<_Ty> _Ilist, const _Alloc& _Al = _Alloc())

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@QAE@V?$initializer_list@U?$pair@IPBD@std@@@1@ABV?$allocator@U?$pair@IPBD@std@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 28	 sub	 esp, 40			; 00000028H
  00014	57		 push	 edi
  00015	51		 push	 ecx
  00016	8d 7d cc	 lea	 edi, DWORD PTR [ebp-52]
  00019	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  0001e	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00023	f3 ab		 rep stosd
  00025	59		 pop	 ecx
  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002b	33 c5		 xor	 eax, ebp
  0002d	50		 push	 eax
  0002e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00031	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00037	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 459  :         : _Mypair(_One_then_variadic_args_t(), _Al) { // construct from initializer_list, optional allocator

  0003a	8b 45 10	 mov	 eax, DWORD PTR __Al$[ebp]
  0003d	50		 push	 eax
  0003e	0f b6 4d cf	 movzx	 ecx, BYTE PTR $T3[ebp]
  00042	51		 push	 ecx
  00043	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	e8 00 00 00 00	 call	 ??$?0ABV?$allocator@U?$pair@IPBD@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$pair@IPBD@std@@@std@@V?$_Vector_val@U?$_Simple_types@U?$pair@IPBD@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@U?$pair@IPBD@std@@@1@@Z ; std::_Compressed_pair<std::allocator<std::pair<unsigned int,char const *> >,std::_Vector_val<std::_Simple_types<std::pair<unsigned int,char const *> > >,1>::_Compressed_pair<std::allocator<std::pair<unsigned int,char const *> >,std::_Vector_val<std::_Simple_types<std::pair<unsigned int,char const *> > >,1><std::allocator<std::pair<unsigned int,char const *> > const &>

; 460  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  0004b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	e8 00 00 00 00	 call	 ?_Getal@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@AAEAAV?$allocator@U?$pair@IPBD@std@@@2@XZ ; std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > >::_Getal
  00053	50		 push	 eax
  00054	8d 4d e7	 lea	 ecx, DWORD PTR _$S2$[ebp]
  00057	e8 00 00 00 00	 call	 ??$?0U?$pair@IPBD@std@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@U?$pair@IPBD@std@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::pair<unsigned int,char const *> >
  0005c	8d 55 e7	 lea	 edx, DWORD PTR _$S2$[ebp]
  0005f	89 55 ec	 mov	 DWORD PTR __Alproxy$[ebp], edx

; 461  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);

  00062	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00065	50		 push	 eax
  00066	8b 4d ec	 mov	 ecx, DWORD PTR __Alproxy$[ebp]
  00069	51		 push	 ecx
  0006a	8d 4d d4	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  0006d	e8 00 00 00 00	 call	 ??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  00072	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 462  :         _Range_construct_or_tidy(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});

  00079	0f b6 55 cd	 movzx	 edx, BYTE PTR $T2[ebp]
  0007d	52		 push	 edx
  0007e	8d 4d 08	 lea	 ecx, DWORD PTR __Ilist$[ebp]
  00081	e8 00 00 00 00	 call	 ?end@?$initializer_list@U?$pair@IPBD@std@@@std@@QBEPBU?$pair@IPBD@2@XZ ; std::initializer_list<std::pair<unsigned int,char const *> >::end
  00086	50		 push	 eax
  00087	8d 4d 08	 lea	 ecx, DWORD PTR __Ilist$[ebp]
  0008a	e8 00 00 00 00	 call	 ?begin@?$initializer_list@U?$pair@IPBD@std@@@std@@QBEPBU?$pair@IPBD@2@XZ ; std::initializer_list<std::pair<unsigned int,char const *> >::begin
  0008f	50		 push	 eax
  00090	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00093	e8 00 00 00 00	 call	 ??$_Range_construct_or_tidy@PBU?$pair@IPBD@std@@@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@AAEXPBU?$pair@IPBD@1@0Uforward_iterator_tag@1@@Z ; std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > >::_Range_construct_or_tidy<std::pair<unsigned int,char const *> const *>

; 463  :         _Proxy._Release();

  00098	8d 4d d4	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  0009b	e8 00 00 00 00	 call	 ?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ ; std::_Basic_container_proxy_ptr12::_Release

; 464  :     }

  000a0	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000a7	8d 4d d4	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  000aa	e8 00 00 00 00	 call	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  000af	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000b2	52		 push	 edx
  000b3	8b cd		 mov	 ecx, ebp
  000b5	50		 push	 eax
  000b6	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN8@vector
  000bc	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000c1	58		 pop	 eax
  000c2	5a		 pop	 edx
  000c3	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c6	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000cd	59		 pop	 ecx
  000ce	5f		 pop	 edi
  000cf	83 c4 34	 add	 esp, 52			; 00000034H
  000d2	3b ec		 cmp	 ebp, esp
  000d4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d9	8b e5		 mov	 esp, ebp
  000db	5d		 pop	 ebp
  000dc	c2 0c 00	 ret	 12			; 0000000cH
  000df	90		 npad	 1
$LN8@vector:
  000e0	02 00 00 00	 DD	 2
  000e4	00 00 00 00	 DD	 $LN7@vector
$LN7@vector:
  000e8	e7 ff ff ff	 DD	 -25			; ffffffe7H
  000ec	01 00 00 00	 DD	 1
  000f0	00 00 00 00	 DD	 $LN4@vector
  000f4	d4 ff ff ff	 DD	 -44			; ffffffd4H
  000f8	08 00 00 00	 DD	 8
  000fc	00 00 00 00	 DD	 $LN5@vector
$LN5@vector:
  00100	5f		 DB	 95			; 0000005fH
  00101	50		 DB	 80			; 00000050H
  00102	72		 DB	 114			; 00000072H
  00103	6f		 DB	 111			; 0000006fH
  00104	78		 DB	 120			; 00000078H
  00105	79		 DB	 121			; 00000079H
  00106	00		 DB	 0
$LN4@vector:
  00107	24		 DB	 36			; 00000024H
  00108	53		 DB	 83			; 00000053H
  00109	32		 DB	 50			; 00000032H
  0010a	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@QAE@V?$initializer_list@U?$pair@IPBD@std@@@1@ABV?$allocator@U?$pair@IPBD@std@@@1@@Z$0:
  00000	8d 4d d4	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
__ehhandler$??0?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@QAE@V?$initializer_list@U?$pair@IPBD@std@@@1@ABV?$allocator@U?$pair@IPBD@std@@@1@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a d0	 mov	 ecx, DWORD PTR [edx-48]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@QAE@V?$initializer_list@U?$pair@IPBD@std@@@1@ABV?$allocator@U?$pair@IPBD@std@@@1@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@QAE@V?$initializer_list@U?$pair@IPBD@std@@@1@ABV?$allocator@U?$pair@IPBD@std@@@1@@Z ENDP ; std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > >::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > >
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@U?$pair@IPBD@std@@@std@@@std@@SAIABV?$allocator@U?$pair@IPBD@std@@@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?max_size@?$_Default_allocator_traits@V?$allocator@U?$pair@IPBD@std@@@std@@@std@@SAIABV?$allocator@U?$pair@IPBD@std@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::pair<unsigned int,char const *> > >::max_size, COMDAT

; 766  :     _NODISCARD static size_type max_size(const _Alloc&) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 767  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00003	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 768  :     }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@U?$pair@IPBD@std@@@std@@@std@@SAIABV?$allocator@U?$pair@IPBD@std@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::pair<unsigned int,char const *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ?allocate@?$allocator@U?$pair@IPBD@std@@@std@@QAEPAU?$pair@IPBD@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U?$pair@IPBD@std@@@std@@QAEPAU?$pair@IPBD@2@I@Z PROC ; std::allocator<std::pair<unsigned int,char const *> >::allocate, COMDAT
; _this$ = ecx

; 870  :     _NODISCARD _DECLSPEC_ALLOCATOR _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 871  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$_Get_size_of_n@$07@std@@YAII@Z ; std::_Get_size_of_n<8>
  00017	83 c4 04	 add	 esp, 4
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00020	83 c4 04	 add	 esp, 4

; 872  :     }

  00023	83 c4 04	 add	 esp, 4
  00026	3b ec		 cmp	 ebp, esp
  00028	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
?allocate@?$allocator@U?$pair@IPBD@std@@@std@@QAEPAU?$pair@IPBD@2@I@Z ENDP ; std::allocator<std::pair<unsigned int,char const *> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ?deallocate@?$allocator@U?$pair@IPBD@std@@@std@@QAEXQAU?$pair@IPBD@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@U?$pair@IPBD@std@@@std@@QAEXQAU?$pair@IPBD@2@I@Z PROC ; std::allocator<std::pair<unsigned int,char const *> >::deallocate, COMDAT
; _this$ = ecx

; 865  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 866  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 867  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000e	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00011	c1 e0 03	 shl	 eax, 3
  00014	50		 push	 eax
  00015	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00018	51		 push	 ecx
  00019	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0001e	83 c4 08	 add	 esp, 8

; 868  :     }

  00021	83 c4 04	 add	 esp, 4
  00024	3b ec		 cmp	 ebp, esp
  00026	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c2 08 00	 ret	 8
?deallocate@?$allocator@U?$pair@IPBD@std@@@std@@QAEXQAU?$pair@IPBD@2@I@Z ENDP ; std::allocator<std::pair<unsigned int,char const *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@IPBD@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@U?$pair@IPBD@std@@@std@@QAE@XZ PROC	; std::allocator<std::pair<unsigned int,char const *> >::allocator<std::pair<unsigned int,char const *> >, COMDAT
; _this$ = ecx

; 859  :     constexpr allocator() noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??0?$allocator@U?$pair@IPBD@std@@@std@@QAE@XZ ENDP	; std::allocator<std::pair<unsigned int,char const *> >::allocator<std::pair<unsigned int,char const *> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
$T1 = -172						; size = 12
$T2 = -160						; size = 12
_x$3 = -148						; size = 4
_dst_ptr$4 = -144					; size = 4
_src_v_ptr$5 = -140					; size = 4
_src_u_ptr$6 = -136					; size = 4
_x_fin$7 = -132						; size = 4
_y$8 = -128						; size = 4
_uv_fin$ = -124						; size = 4
_dstLine$ = -120					; size = 4
_srcVLine$ = -116					; size = 4
_srcULine$ = -112					; size = 4
$T9 = -108						; size = 12
_uv_range$ = -92					; size = 12
_x$10 = -76						; size = 4
_dst_ptr$11 = -72					; size = 4
_y$12 = -68						; size = 4
_y_width$13 = -64					; size = 4
_dstLine$14 = -60					; size = 4
_srcYLine$15 = -56					; size = 4
$T16 = -52						; size = 12
_y_range$17 = -36					; size = 12
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yv12_to_p010_c@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_to_p010_c<0>

; 874  : static void convert_yv12_to_p010_c(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec ac 00 00
	00		 sub	 esp, 172		; 000000acH
  00009	57		 push	 edi
  0000a	8d bd 54 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-172]
  00010	b9 2b 00 00 00	 mov	 ecx, 43			; 0000002bH
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 875  :     const int crop_left   = crop[0];

  00026	b8 04 00 00 00	 mov	 eax, 4
  0002b	6b c8 00	 imul	 ecx, eax, 0
  0002e	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00031	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00034	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 876  :     const int crop_up     = crop[1];

  00037	b9 04 00 00 00	 mov	 ecx, 4
  0003c	c1 e1 00	 shl	 ecx, 0
  0003f	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00042	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00045	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 877  :     const int crop_right  = crop[2];

  00048	b9 04 00 00 00	 mov	 ecx, 4
  0004d	d1 e1		 shl	 ecx, 1
  0004f	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00052	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00055	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 878  :     const int crop_bottom = crop[3];

  00058	b9 04 00 00 00	 mov	 ecx, 4
  0005d	6b d1 03	 imul	 edx, ecx, 3
  00060	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00063	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00066	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 879  :     //Y
; 880  :     if (!uv_only) {

  00069	ba 01 00 00 00	 mov	 edx, 1
  0006e	85 d2		 test	 edx, edx
  00070	0f 84 f1 00 00
	00		 je	 $LN14@convert_yv

; 881  :         const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00076	8b 45 2c	 mov	 eax, DWORD PTR _thread_n$[ebp]
  00079	50		 push	 eax
  0007a	8b 4d 28	 mov	 ecx, DWORD PTR _thread_id$[ebp]
  0007d	51		 push	 ecx
  0007e	8b 55 20	 mov	 edx, DWORD PTR _height$[ebp]
  00081	2b 55 ec	 sub	 edx, DWORD PTR _crop_bottom$[ebp]
  00084	52		 push	 edx
  00085	8b 45 f4	 mov	 eax, DWORD PTR _crop_up$[ebp]
  00088	50		 push	 eax
  00089	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  0008f	51		 push	 ecx
  00090	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00095	83 c4 14	 add	 esp, 20			; 00000014H
  00098	8b 10		 mov	 edx, DWORD PTR [eax]
  0009a	89 55 cc	 mov	 DWORD PTR $T16[ebp], edx
  0009d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000a0	89 4d d0	 mov	 DWORD PTR $T16[ebp+4], ecx
  000a3	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000a6	89 55 d4	 mov	 DWORD PTR $T16[ebp+8], edx
  000a9	8b 45 cc	 mov	 eax, DWORD PTR $T16[ebp]
  000ac	89 45 dc	 mov	 DWORD PTR _y_range$17[ebp], eax
  000af	8b 4d d0	 mov	 ecx, DWORD PTR $T16[ebp+4]
  000b2	89 4d e0	 mov	 DWORD PTR _y_range$17[ebp+4], ecx
  000b5	8b 55 d4	 mov	 edx, DWORD PTR $T16[ebp+8]
  000b8	89 55 e4	 mov	 DWORD PTR _y_range$17[ebp+8], edx

; 882  :         uint8_t *srcYLine = (uint8_t *)src[0] + src_y_pitch_byte * y_range.start_src + crop_left;

  000bb	b8 04 00 00 00	 mov	 eax, 4
  000c0	6b c8 00	 imul	 ecx, eax, 0
  000c3	8b 55 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebp]
  000c6	0f af 55 dc	 imul	 edx, DWORD PTR _y_range$17[ebp]
  000ca	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  000cd	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  000d0	03 ca		 add	 ecx, edx
  000d2	03 4d f8	 add	 ecx, DWORD PTR _crop_left$[ebp]
  000d5	89 4d c8	 mov	 DWORD PTR _srcYLine$15[ebp], ecx

; 883  :         uint8_t *dstLine  = (uint8_t *)dst[0] + dst_y_pitch_byte * y_range.start_dst;

  000d8	ba 04 00 00 00	 mov	 edx, 4
  000dd	6b c2 00	 imul	 eax, edx, 0
  000e0	8b 4d 1c	 mov	 ecx, DWORD PTR _dst_y_pitch_byte$[ebp]
  000e3	0f af 4d e0	 imul	 ecx, DWORD PTR _y_range$17[ebp+4]
  000e7	8b 55 08	 mov	 edx, DWORD PTR _dst$[ebp]
  000ea	03 0c 02	 add	 ecx, DWORD PTR [edx+eax]
  000ed	89 4d c4	 mov	 DWORD PTR _dstLine$14[ebp], ecx

; 884  :         const int y_width = width - crop_right - crop_left;

  000f0	8b 45 10	 mov	 eax, DWORD PTR _width$[ebp]
  000f3	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  000f6	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  000f9	89 45 c0	 mov	 DWORD PTR _y_width$13[ebp], eax

; 885  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch_byte, dstLine += dst_y_pitch_byte) {

  000fc	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _y$12[ebp], 0
  00103	eb 1b		 jmp	 SHORT $LN4@convert_yv
$LN2@convert_yv:
  00105	8b 4d bc	 mov	 ecx, DWORD PTR _y$12[ebp]
  00108	83 c1 01	 add	 ecx, 1
  0010b	89 4d bc	 mov	 DWORD PTR _y$12[ebp], ecx
  0010e	8b 55 c8	 mov	 edx, DWORD PTR _srcYLine$15[ebp]
  00111	03 55 14	 add	 edx, DWORD PTR _src_y_pitch_byte$[ebp]
  00114	89 55 c8	 mov	 DWORD PTR _srcYLine$15[ebp], edx
  00117	8b 45 c4	 mov	 eax, DWORD PTR _dstLine$14[ebp]
  0011a	03 45 1c	 add	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  0011d	89 45 c4	 mov	 DWORD PTR _dstLine$14[ebp], eax
$LN4@convert_yv:
  00120	8b 4d bc	 mov	 ecx, DWORD PTR _y$12[ebp]
  00123	3b 4d e4	 cmp	 ecx, DWORD PTR _y_range$17[ebp+8]
  00126	7d 3f		 jge	 SHORT $LN14@convert_yv

; 886  :             uint16_t *dst_ptr = (uint16_t *)dstLine;

  00128	8b 55 c4	 mov	 edx, DWORD PTR _dstLine$14[ebp]
  0012b	89 55 b8	 mov	 DWORD PTR _dst_ptr$11[ebp], edx

; 887  :             for (int x = 0; x < y_width; x++) {

  0012e	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _x$10[ebp], 0
  00135	eb 09		 jmp	 SHORT $LN7@convert_yv
$LN5@convert_yv:
  00137	8b 45 b4	 mov	 eax, DWORD PTR _x$10[ebp]
  0013a	83 c0 01	 add	 eax, 1
  0013d	89 45 b4	 mov	 DWORD PTR _x$10[ebp], eax
$LN7@convert_yv:
  00140	8b 4d b4	 mov	 ecx, DWORD PTR _x$10[ebp]
  00143	3b 4d c0	 cmp	 ecx, DWORD PTR _y_width$13[ebp]
  00146	7d 1d		 jge	 SHORT $LN6@convert_yv

; 888  :                 dst_ptr[x] = (uint16_t)((((uint32_t)srcYLine[x]) << 8) + (2 << 6));

  00148	8b 55 c8	 mov	 edx, DWORD PTR _srcYLine$15[ebp]
  0014b	03 55 b4	 add	 edx, DWORD PTR _x$10[ebp]
  0014e	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00151	c1 e0 08	 shl	 eax, 8
  00154	05 80 00 00 00	 add	 eax, 128		; 00000080H
  00159	8b 4d b4	 mov	 ecx, DWORD PTR _x$10[ebp]
  0015c	8b 55 b8	 mov	 edx, DWORD PTR _dst_ptr$11[ebp]
  0015f	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax

; 889  :             }

  00163	eb d2		 jmp	 SHORT $LN5@convert_yv
$LN6@convert_yv:

; 890  :         }

  00165	eb 9e		 jmp	 SHORT $LN2@convert_yv
$LN14@convert_yv:

; 891  :     }
; 892  :     //UV
; 893  :     const auto uv_range = thread_y_range(crop_up >> 1, (height - crop_bottom) >> 1, thread_id, thread_n);

  00167	8b 45 2c	 mov	 eax, DWORD PTR _thread_n$[ebp]
  0016a	50		 push	 eax
  0016b	8b 4d 28	 mov	 ecx, DWORD PTR _thread_id$[ebp]
  0016e	51		 push	 ecx
  0016f	8b 55 20	 mov	 edx, DWORD PTR _height$[ebp]
  00172	2b 55 ec	 sub	 edx, DWORD PTR _crop_bottom$[ebp]
  00175	d1 fa		 sar	 edx, 1
  00177	52		 push	 edx
  00178	8b 45 f4	 mov	 eax, DWORD PTR _crop_up$[ebp]
  0017b	d1 f8		 sar	 eax, 1
  0017d	50		 push	 eax
  0017e	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  00184	51		 push	 ecx
  00185	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  0018a	83 c4 14	 add	 esp, 20			; 00000014H
  0018d	8b 10		 mov	 edx, DWORD PTR [eax]
  0018f	89 55 94	 mov	 DWORD PTR $T9[ebp], edx
  00192	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00195	89 4d 98	 mov	 DWORD PTR $T9[ebp+4], ecx
  00198	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0019b	89 55 9c	 mov	 DWORD PTR $T9[ebp+8], edx
  0019e	8b 45 94	 mov	 eax, DWORD PTR $T9[ebp]
  001a1	89 45 a4	 mov	 DWORD PTR _uv_range$[ebp], eax
  001a4	8b 4d 98	 mov	 ecx, DWORD PTR $T9[ebp+4]
  001a7	89 4d a8	 mov	 DWORD PTR _uv_range$[ebp+4], ecx
  001aa	8b 55 9c	 mov	 edx, DWORD PTR $T9[ebp+8]
  001ad	89 55 ac	 mov	 DWORD PTR _uv_range$[ebp+8], edx

; 894  :     uint8_t *srcULine = (uint8_t *)src[1] + ((src_uv_pitch_byte * uv_range.start_src) + (crop_left >> 1));

  001b0	b8 04 00 00 00	 mov	 eax, 4
  001b5	c1 e0 00	 shl	 eax, 0
  001b8	8b 4d 18	 mov	 ecx, DWORD PTR _src_uv_pitch_byte$[ebp]
  001bb	0f af 4d a4	 imul	 ecx, DWORD PTR _uv_range$[ebp]
  001bf	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  001c2	d1 fa		 sar	 edx, 1
  001c4	03 ca		 add	 ecx, edx
  001c6	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  001c9	03 0c 02	 add	 ecx, DWORD PTR [edx+eax]
  001cc	89 4d 90	 mov	 DWORD PTR _srcULine$[ebp], ecx

; 895  :     uint8_t *srcVLine = (uint8_t *)src[2] + ((src_uv_pitch_byte * uv_range.start_src) + (crop_left >> 1));

  001cf	b8 04 00 00 00	 mov	 eax, 4
  001d4	d1 e0		 shl	 eax, 1
  001d6	8b 4d 18	 mov	 ecx, DWORD PTR _src_uv_pitch_byte$[ebp]
  001d9	0f af 4d a4	 imul	 ecx, DWORD PTR _uv_range$[ebp]
  001dd	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  001e0	d1 fa		 sar	 edx, 1
  001e2	03 ca		 add	 ecx, edx
  001e4	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  001e7	03 0c 02	 add	 ecx, DWORD PTR [edx+eax]
  001ea	89 4d 8c	 mov	 DWORD PTR _srcVLine$[ebp], ecx

; 896  :     uint8_t *dstLine  = (uint8_t *)dst[1] + dst_y_pitch_byte * uv_range.start_dst;

  001ed	b8 04 00 00 00	 mov	 eax, 4
  001f2	c1 e0 00	 shl	 eax, 0
  001f5	8b 4d 1c	 mov	 ecx, DWORD PTR _dst_y_pitch_byte$[ebp]
  001f8	0f af 4d a8	 imul	 ecx, DWORD PTR _uv_range$[ebp+4]
  001fc	8b 55 08	 mov	 edx, DWORD PTR _dst$[ebp]
  001ff	03 0c 02	 add	 ecx, DWORD PTR [edx+eax]
  00202	89 4d 88	 mov	 DWORD PTR _dstLine$[ebp], ecx

; 897  :     const int uv_fin = (height - crop_bottom) >> 1;

  00205	8b 45 20	 mov	 eax, DWORD PTR _height$[ebp]
  00208	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  0020b	d1 f8		 sar	 eax, 1
  0020d	89 45 84	 mov	 DWORD PTR _uv_fin$[ebp], eax

; 898  :     for (int y = 0; y < uv_range.len; y++, srcULine += src_uv_pitch_byte, srcVLine += src_uv_pitch_byte, dstLine += dst_y_pitch_byte) {

  00210	c7 45 80 00 00
	00 00		 mov	 DWORD PTR _y$8[ebp], 0
  00217	eb 24		 jmp	 SHORT $LN10@convert_yv
$LN8@convert_yv:
  00219	8b 4d 80	 mov	 ecx, DWORD PTR _y$8[ebp]
  0021c	83 c1 01	 add	 ecx, 1
  0021f	89 4d 80	 mov	 DWORD PTR _y$8[ebp], ecx
  00222	8b 55 90	 mov	 edx, DWORD PTR _srcULine$[ebp]
  00225	03 55 18	 add	 edx, DWORD PTR _src_uv_pitch_byte$[ebp]
  00228	89 55 90	 mov	 DWORD PTR _srcULine$[ebp], edx
  0022b	8b 45 8c	 mov	 eax, DWORD PTR _srcVLine$[ebp]
  0022e	03 45 18	 add	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  00231	89 45 8c	 mov	 DWORD PTR _srcVLine$[ebp], eax
  00234	8b 4d 88	 mov	 ecx, DWORD PTR _dstLine$[ebp]
  00237	03 4d 1c	 add	 ecx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0023a	89 4d 88	 mov	 DWORD PTR _dstLine$[ebp], ecx
$LN10@convert_yv:
  0023d	8b 55 80	 mov	 edx, DWORD PTR _y$8[ebp]
  00240	3b 55 ac	 cmp	 edx, DWORD PTR _uv_range$[ebp+8]
  00243	0f 8d df 00 00
	00		 jge	 $LN1@convert_yv

; 899  :         const int x_fin = width - crop_right;

  00249	8b 45 10	 mov	 eax, DWORD PTR _width$[ebp]
  0024c	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  0024f	89 85 7c ff ff
	ff		 mov	 DWORD PTR _x_fin$7[ebp], eax

; 900  :         uint8_t *src_u_ptr = srcULine;

  00255	8b 4d 90	 mov	 ecx, DWORD PTR _srcULine$[ebp]
  00258	89 8d 78 ff ff
	ff		 mov	 DWORD PTR _src_u_ptr$6[ebp], ecx

; 901  :         uint8_t *src_v_ptr = srcVLine;

  0025e	8b 55 8c	 mov	 edx, DWORD PTR _srcVLine$[ebp]
  00261	89 95 74 ff ff
	ff		 mov	 DWORD PTR _src_v_ptr$5[ebp], edx

; 902  :         uint16_t *dst_ptr = (uint16_t *)dstLine;

  00267	8b 45 88	 mov	 eax, DWORD PTR _dstLine$[ebp]
  0026a	89 85 70 ff ff
	ff		 mov	 DWORD PTR _dst_ptr$4[ebp], eax

; 903  :         for (int x = crop_left; x < x_fin; x += 2, src_u_ptr++, src_v_ptr++, dst_ptr += 2) {

  00270	8b 4d f8	 mov	 ecx, DWORD PTR _crop_left$[ebp]
  00273	89 8d 6c ff ff
	ff		 mov	 DWORD PTR _x$3[ebp], ecx
  00279	eb 3c		 jmp	 SHORT $LN13@convert_yv
$LN11@convert_yv:
  0027b	8b 95 6c ff ff
	ff		 mov	 edx, DWORD PTR _x$3[ebp]
  00281	83 c2 02	 add	 edx, 2
  00284	89 95 6c ff ff
	ff		 mov	 DWORD PTR _x$3[ebp], edx
  0028a	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _src_u_ptr$6[ebp]
  00290	83 c0 01	 add	 eax, 1
  00293	89 85 78 ff ff
	ff		 mov	 DWORD PTR _src_u_ptr$6[ebp], eax
  00299	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _src_v_ptr$5[ebp]
  0029f	83 c1 01	 add	 ecx, 1
  002a2	89 8d 74 ff ff
	ff		 mov	 DWORD PTR _src_v_ptr$5[ebp], ecx
  002a8	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR _dst_ptr$4[ebp]
  002ae	83 c2 04	 add	 edx, 4
  002b1	89 95 70 ff ff
	ff		 mov	 DWORD PTR _dst_ptr$4[ebp], edx
$LN13@convert_yv:
  002b7	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _x$3[ebp]
  002bd	3b 85 7c ff ff
	ff		 cmp	 eax, DWORD PTR _x_fin$7[ebp]
  002c3	7d 5e		 jge	 SHORT $LN12@convert_yv

; 904  :             dst_ptr[0] = (uint16_t)((((uint32_t)src_u_ptr[0]) << 8) + (2<<6));

  002c5	b9 01 00 00 00	 mov	 ecx, 1
  002ca	6b d1 00	 imul	 edx, ecx, 0
  002cd	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _src_u_ptr$6[ebp]
  002d3	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  002d7	c1 e1 08	 shl	 ecx, 8
  002da	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  002e0	ba 02 00 00 00	 mov	 edx, 2
  002e5	6b c2 00	 imul	 eax, edx, 0
  002e8	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR _dst_ptr$4[ebp]
  002ee	66 89 0c 02	 mov	 WORD PTR [edx+eax], cx

; 905  :             dst_ptr[1] = (uint16_t)((((uint32_t)src_v_ptr[0]) << 8) + (2<<6));

  002f2	b8 01 00 00 00	 mov	 eax, 1
  002f7	6b c8 00	 imul	 ecx, eax, 0
  002fa	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _src_v_ptr$5[ebp]
  00300	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  00304	c1 e0 08	 shl	 eax, 8
  00307	05 80 00 00 00	 add	 eax, 128		; 00000080H
  0030c	b9 02 00 00 00	 mov	 ecx, 2
  00311	c1 e1 00	 shl	 ecx, 0
  00314	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR _dst_ptr$4[ebp]
  0031a	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax

; 906  :         }

  0031e	e9 58 ff ff ff	 jmp	 $LN11@convert_yv
$LN12@convert_yv:

; 907  :     }

  00323	e9 f1 fe ff ff	 jmp	 $LN8@convert_yv
$LN1@convert_yv:

; 908  : }

  00328	52		 push	 edx
  00329	8b cd		 mov	 ecx, ebp
  0032b	50		 push	 eax
  0032c	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN19@convert_yv
  00332	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00337	58		 pop	 eax
  00338	5a		 pop	 edx
  00339	5f		 pop	 edi
  0033a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0033d	33 cd		 xor	 ecx, ebp
  0033f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00344	81 c4 ac 00 00
	00		 add	 esp, 172		; 000000acH
  0034a	3b ec		 cmp	 ebp, esp
  0034c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00351	8b e5		 mov	 esp, ebp
  00353	5d		 pop	 ebp
  00354	c3		 ret	 0
  00355	0f 1f 00	 npad	 3
$LN19@convert_yv:
  00358	02 00 00 00	 DD	 2
  0035c	00 00 00 00	 DD	 $LN18@convert_yv
$LN18@convert_yv:
  00360	dc ff ff ff	 DD	 -36			; ffffffdcH
  00364	0c 00 00 00	 DD	 12			; 0000000cH
  00368	00 00 00 00	 DD	 $LN16@convert_yv
  0036c	a4 ff ff ff	 DD	 -92			; ffffffa4H
  00370	0c 00 00 00	 DD	 12			; 0000000cH
  00374	00 00 00 00	 DD	 $LN17@convert_yv
$LN17@convert_yv:
  00378	75		 DB	 117			; 00000075H
  00379	76		 DB	 118			; 00000076H
  0037a	5f		 DB	 95			; 0000005fH
  0037b	72		 DB	 114			; 00000072H
  0037c	61		 DB	 97			; 00000061H
  0037d	6e		 DB	 110			; 0000006eH
  0037e	67		 DB	 103			; 00000067H
  0037f	65		 DB	 101			; 00000065H
  00380	00		 DB	 0
$LN16@convert_yv:
  00381	79		 DB	 121			; 00000079H
  00382	5f		 DB	 95			; 0000005fH
  00383	72		 DB	 114			; 00000072H
  00384	61		 DB	 97			; 00000061H
  00385	6e		 DB	 110			; 0000006eH
  00386	67		 DB	 103			; 00000067H
  00387	65		 DB	 101			; 00000065H
  00388	00		 DB	 0
??$convert_yv12_to_p010_c@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_to_p010_c<0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yv12_to_p010@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC	; convert_yv12_to_p010

; 910  : static void convert_yv12_to_p010(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 911  :     convert_yv12_to_p010_c<false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yv12_to_p010_c@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_to_p010_c<0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 912  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yv12_to_p010@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP	; convert_yv12_to_p010
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
tv302 = -280						; size = 4
tv240 = -276						; size = 4
tv241 = -272						; size = 4
tv235 = -268						; size = 4
tv232 = -264						; size = 4
tv229 = -260						; size = 4
tv227 = -256						; size = 4
$T1 = -252						; size = 4
$T2 = -248						; size = 4
$T3 = -244						; size = 4
$T4 = -240						; size = 4
$T5 = -236						; size = 12
_cy3x1$6 = -224						; size = 4
_cy2x1$7 = -220						; size = 4
_cy1x1$8 = -216						; size = 4
_cy0x1$9 = -212						; size = 4
_sy5x1$10 = -208					; size = 4
_sy4x1$11 = -204					; size = 4
_sy3x1$12 = -200					; size = 4
_sy2x1$13 = -196					; size = 4
_sy1x1$14 = -192					; size = 4
_sy0x1$15 = -188					; size = 4
_cxplus$16 = -184					; size = 4
_x$17 = -180						; size = 4
_cy3x0$18 = -176					; size = 4
_cy2x0$19 = -172					; size = 4
_cy1x0$20 = -168					; size = 4
_cy0x0$21 = -164					; size = 4
_sy5x0$22 = -160					; size = 4
_sy4x0$23 = -156					; size = 4
_sy3x0$24 = -152					; size = 4
_sy2x0$25 = -148					; size = 4
_sy1x0$26 = -144					; size = 4
_sy0x0$27 = -140					; size = 4
_y_p3$28 = -136						; size = 4
_y_p2$29 = -132						; size = 4
_y_p1$30 = -128						; size = 4
_y_m1$31 = -124						; size = 4
_y_m2$32 = -120						; size = 4
_x_fin$33 = -116					; size = 4
_srcP$34 = -112						; size = 4
_dstC$35 = -108						; size = 4
_y$36 = -104						; size = 4
_dstLine$37 = -100					; size = 4
_srcCLine$38 = -96					; size = 4
_ic$39 = -92						; size = 4
_src_uv_pitch$ = -88					; size = 4
_uv_fin$ = -84						; size = 4
_x$40 = -80						; size = 4
_y$41 = -76						; size = 4
_y_width$42 = -72					; size = 4
_dstLine$43 = -68					; size = 4
_srcYLine$44 = -64					; size = 4
$T45 = -60						; size = 12
_y_range$ = -44						; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yv12_i_to_yuv444_c@G$08G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_i_to_yuv444_c<unsigned short,9,unsigned short,16,0>

; 683  : static void __forceinline convert_yv12_i_to_yuv444_c(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8d bd e8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-280]
  00011	b9 46 00 00 00	 mov	 ecx, 70			; 00000046H
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 684  :     static_assert((sizeof(Tin)  == 1 && in_bit_depth  == 8) || (sizeof(Tin)  == 2 && 8 < in_bit_depth  && in_bit_depth  <= 16), "invalid input bit depth.");
; 685  :     static_assert((sizeof(Tout) == 1 && out_bit_depth == 8) || (sizeof(Tout) == 2 && 8 < out_bit_depth && out_bit_depth <= 16), "invalid output bit depth.");
; 686  :     const int crop_left   = crop[0];

  00027	b8 04 00 00 00	 mov	 eax, 4
  0002c	6b c8 00	 imul	 ecx, eax, 0
  0002f	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00032	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00035	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 687  :     const int crop_up     = crop[1];

  00038	b9 04 00 00 00	 mov	 ecx, 4
  0003d	c1 e1 00	 shl	 ecx, 0
  00040	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00043	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00046	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 688  :     const int crop_right  = crop[2];

  00049	b9 04 00 00 00	 mov	 ecx, 4
  0004e	d1 e1		 shl	 ecx, 1
  00050	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00053	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00056	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 689  :     const int crop_bottom = crop[3];

  00059	b9 04 00 00 00	 mov	 ecx, 4
  0005e	6b d1 03	 imul	 edx, ecx, 3
  00061	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00064	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00067	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 690  :     const int src_y_pitch = src_y_pitch_byte / sizeof(Tin);

  0006a	8b 55 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebp]
  0006d	d1 ea		 shr	 edx, 1
  0006f	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 691  :     const int dst_y_pitch = dst_y_pitch_byte / sizeof(Tout);

  00072	8b 45 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  00075	d1 e8		 shr	 eax, 1
  00077	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 692  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  0007a	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0007d	51		 push	 ecx
  0007e	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  00081	52		 push	 edx
  00082	8b 45 20	 mov	 eax, DWORD PTR _height$[ebp]
  00085	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  00088	50		 push	 eax
  00089	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  0008c	51		 push	 ecx
  0008d	8d 95 14 ff ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  00093	52		 push	 edx
  00094	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00099	83 c4 14	 add	 esp, 20			; 00000014H
  0009c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009e	89 4d c4	 mov	 DWORD PTR $T45[ebp], ecx
  000a1	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a4	89 55 c8	 mov	 DWORD PTR $T45[ebp+4], edx
  000a7	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000aa	89 45 cc	 mov	 DWORD PTR $T45[ebp+8], eax
  000ad	8b 4d c4	 mov	 ecx, DWORD PTR $T45[ebp]
  000b0	89 4d d4	 mov	 DWORD PTR _y_range$[ebp], ecx
  000b3	8b 55 c8	 mov	 edx, DWORD PTR $T45[ebp+4]
  000b6	89 55 d8	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000b9	8b 45 cc	 mov	 eax, DWORD PTR $T45[ebp+8]
  000bc	89 45 dc	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 693  :     //Y
; 694  :     if (!uv_only) {

  000bf	b9 01 00 00 00	 mov	 ecx, 1
  000c4	85 c9		 test	 ecx, ecx
  000c6	0f 84 6e 01 00
	00		 je	 $LN17@convert_yv

; 695  :         Tin *srcYLine = (Tin *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000cc	ba 04 00 00 00	 mov	 edx, 4
  000d1	6b c2 00	 imul	 eax, edx, 0
  000d4	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  000d7	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  000db	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  000de	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  000e1	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  000e4	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  000e7	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  000ea	89 45 c0	 mov	 DWORD PTR _srcYLine$44[ebp], eax

; 696  :         Tout *dstLine = (Tout *)dst[0] + dst_y_pitch * y_range.start_dst;

  000ed	b9 04 00 00 00	 mov	 ecx, 4
  000f2	6b d1 00	 imul	 edx, ecx, 0
  000f5	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  000f8	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  000fc	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  000ff	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  00102	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  00105	89 45 bc	 mov	 DWORD PTR _dstLine$43[ebp], eax

; 697  :         const int y_width = width - crop_right - crop_left;

  00108	8b 4d 10	 mov	 ecx, DWORD PTR _width$[ebp]
  0010b	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  0010e	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  00111	89 4d b8	 mov	 DWORD PTR _y_width$42[ebp], ecx

; 698  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  00114	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _y$41[ebp], 0
  0011b	eb 21		 jmp	 SHORT $LN4@convert_yv
$LN2@convert_yv:
  0011d	8b 55 b4	 mov	 edx, DWORD PTR _y$41[ebp]
  00120	83 c2 01	 add	 edx, 1
  00123	89 55 b4	 mov	 DWORD PTR _y$41[ebp], edx
  00126	8b 45 e8	 mov	 eax, DWORD PTR _src_y_pitch$[ebp]
  00129	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$44[ebp]
  0012c	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  0012f	89 55 c0	 mov	 DWORD PTR _srcYLine$44[ebp], edx
  00132	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  00135	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$43[ebp]
  00138	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  0013b	89 55 bc	 mov	 DWORD PTR _dstLine$43[ebp], edx
$LN4@convert_yv:
  0013e	8b 45 b4	 mov	 eax, DWORD PTR _y$41[ebp]
  00141	3b 45 dc	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  00144	0f 8d f0 00 00
	00		 jge	 $LN17@convert_yv

; 699  :             if (in_bit_depth == out_bit_depth) {

  0014a	33 c9		 xor	 ecx, ecx
  0014c	74 1b		 je	 SHORT $LN18@convert_yv

; 700  :                 memcpy(dstLine, srcYLine, y_width * sizeof(Tin));

  0014e	8b 55 b8	 mov	 edx, DWORD PTR _y_width$42[ebp]
  00151	d1 e2		 shl	 edx, 1
  00153	52		 push	 edx
  00154	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$44[ebp]
  00157	50		 push	 eax
  00158	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$43[ebp]
  0015b	51		 push	 ecx
  0015c	e8 00 00 00 00	 call	 _memcpy
  00161	83 c4 0c	 add	 esp, 12			; 0000000cH

; 701  :             } else {

  00164	e9 cc 00 00 00	 jmp	 $LN19@convert_yv
$LN18@convert_yv:

; 702  :                 for (int x = 0; x < y_width; x++) {

  00169	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _x$40[ebp], 0
  00170	eb 09		 jmp	 SHORT $LN7@convert_yv
$LN5@convert_yv:
  00172	8b 55 b0	 mov	 edx, DWORD PTR _x$40[ebp]
  00175	83 c2 01	 add	 edx, 1
  00178	89 55 b0	 mov	 DWORD PTR _x$40[ebp], edx
$LN7@convert_yv:
  0017b	8b 45 b0	 mov	 eax, DWORD PTR _x$40[ebp]
  0017e	3b 45 b8	 cmp	 eax, DWORD PTR _y_width$42[ebp]
  00181	0f 8d ae 00 00
	00		 jge	 $LN19@convert_yv

; 703  :                     if (out_bit_depth > in_bit_depth) {

  00187	b9 01 00 00 00	 mov	 ecx, 1
  0018c	85 c9		 test	 ecx, ecx
  0018e	74 44		 je	 SHORT $LN20@convert_yv

; 704  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) << std::max(out_bit_depth - in_bit_depth, 0));

  00190	c7 85 10 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], 0
  0019a	c7 85 0c ff ff
	ff 07 00 00 00	 mov	 DWORD PTR $T3[ebp], 7
  001a4	8b 55 b0	 mov	 edx, DWORD PTR _x$40[ebp]
  001a7	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$44[ebp]
  001aa	0f b7 34 50	 movzx	 esi, WORD PTR [eax+edx*2]
  001ae	8d 8d 10 ff ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  001b4	51		 push	 ecx
  001b5	8d 95 0c ff ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  001bb	52		 push	 edx
  001bc	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  001c1	83 c4 08	 add	 esp, 8
  001c4	8b 08		 mov	 ecx, DWORD PTR [eax]
  001c6	d3 e6		 shl	 esi, cl
  001c8	8b 45 b0	 mov	 eax, DWORD PTR _x$40[ebp]
  001cb	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$43[ebp]
  001ce	66 89 34 41	 mov	 WORD PTR [ecx+eax*2], si
  001d2	eb 5c		 jmp	 SHORT $LN21@convert_yv
$LN20@convert_yv:

; 705  :                     } else if (out_bit_depth < in_bit_depth) {

  001d4	33 d2		 xor	 edx, edx
  001d6	74 44		 je	 SHORT $LN22@convert_yv

; 706  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) >> std::max(in_bit_depth - out_bit_depth, 0));

  001d8	c7 85 08 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], 0
  001e2	c7 85 04 ff ff
	ff f9 ff ff ff	 mov	 DWORD PTR $T1[ebp], -7	; fffffff9H
  001ec	8b 45 b0	 mov	 eax, DWORD PTR _x$40[ebp]
  001ef	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$44[ebp]
  001f2	0f b7 34 41	 movzx	 esi, WORD PTR [ecx+eax*2]
  001f6	8d 95 08 ff ff
	ff		 lea	 edx, DWORD PTR $T2[ebp]
  001fc	52		 push	 edx
  001fd	8d 85 04 ff ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  00203	50		 push	 eax
  00204	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  00209	83 c4 08	 add	 esp, 8
  0020c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0020e	d3 fe		 sar	 esi, cl
  00210	8b 4d b0	 mov	 ecx, DWORD PTR _x$40[ebp]
  00213	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$43[ebp]
  00216	66 89 34 4a	 mov	 WORD PTR [edx+ecx*2], si

; 707  :                     } else {

  0021a	eb 14		 jmp	 SHORT $LN21@convert_yv
$LN22@convert_yv:

; 708  :                         dstLine[x] = (Tout)srcYLine[x];

  0021c	8b 45 b0	 mov	 eax, DWORD PTR _x$40[ebp]
  0021f	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$43[ebp]
  00222	8b 55 b0	 mov	 edx, DWORD PTR _x$40[ebp]
  00225	8b 75 c0	 mov	 esi, DWORD PTR _srcYLine$44[ebp]
  00228	66 8b 14 56	 mov	 dx, WORD PTR [esi+edx*2]
  0022c	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx
$LN21@convert_yv:

; 709  :                     }
; 710  :                 }

  00230	e9 3d ff ff ff	 jmp	 $LN5@convert_yv
$LN19@convert_yv:

; 711  :             }
; 712  :         }

  00235	e9 e3 fe ff ff	 jmp	 $LN2@convert_yv
$LN17@convert_yv:

; 713  :     }
; 714  :     //UV
; 715  :     const int uv_fin = height - crop_bottom;

  0023a	8b 45 20	 mov	 eax, DWORD PTR _height$[ebp]
  0023d	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  00240	89 45 ac	 mov	 DWORD PTR _uv_fin$[ebp], eax

; 716  :     const int src_uv_pitch = src_uv_pitch_byte / sizeof(Tin);

  00243	8b 4d 18	 mov	 ecx, DWORD PTR _src_uv_pitch_byte$[ebp]
  00246	d1 e9		 shr	 ecx, 1
  00248	89 4d a8	 mov	 DWORD PTR _src_uv_pitch$[ebp], ecx

; 717  :     for (int ic = 1; ic < 3; ic++) {

  0024b	c7 45 a4 01 00
	00 00		 mov	 DWORD PTR _ic$39[ebp], 1
  00252	eb 09		 jmp	 SHORT $LN10@convert_yv
$LN8@convert_yv:
  00254	8b 55 a4	 mov	 edx, DWORD PTR _ic$39[ebp]
  00257	83 c2 01	 add	 edx, 1
  0025a	89 55 a4	 mov	 DWORD PTR _ic$39[ebp], edx
$LN10@convert_yv:
  0025d	83 7d a4 03	 cmp	 DWORD PTR _ic$39[ebp], 3
  00261	0f 8d c4 05 00
	00		 jge	 $LN1@convert_yv

; 718  :         Tin *srcCLine = (Tin *)src[ic] + (((src_uv_pitch * y_range.start_src) + crop_left) >> 1);

  00267	8b 45 a8	 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  0026a	0f af 45 d4	 imul	 eax, DWORD PTR _y_range$[ebp]
  0026e	03 45 f8	 add	 eax, DWORD PTR _crop_left$[ebp]
  00271	d1 f8		 sar	 eax, 1
  00273	8b 4d a4	 mov	 ecx, DWORD PTR _ic$39[ebp]
  00276	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  00279	8b 0c 8a	 mov	 ecx, DWORD PTR [edx+ecx*4]
  0027c	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  0027f	89 55 a0	 mov	 DWORD PTR _srcCLine$38[ebp], edx

; 719  :         Tout *dstLine = (Tout *)dst[ic] + dst_y_pitch * y_range.start_dst;

  00282	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  00285	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  00289	8b 4d a4	 mov	 ecx, DWORD PTR _ic$39[ebp]
  0028c	8b 55 08	 mov	 edx, DWORD PTR _dst$[ebp]
  0028f	8b 0c 8a	 mov	 ecx, DWORD PTR [edx+ecx*4]
  00292	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00295	89 55 9c	 mov	 DWORD PTR _dstLine$37[ebp], edx

; 720  :         for (int y = 0; y < y_range.len; y += 4, srcCLine += src_uv_pitch * 2, dstLine += dst_y_pitch * 4) {

  00298	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _y$36[ebp], 0
  0029f	eb 26		 jmp	 SHORT $LN13@convert_yv
$LN11@convert_yv:
  002a1	8b 45 98	 mov	 eax, DWORD PTR _y$36[ebp]
  002a4	83 c0 04	 add	 eax, 4
  002a7	89 45 98	 mov	 DWORD PTR _y$36[ebp], eax
  002aa	8b 4d a8	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  002ad	d1 e1		 shl	 ecx, 1
  002af	8b 55 a0	 mov	 edx, DWORD PTR _srcCLine$38[ebp]
  002b2	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  002b5	89 45 a0	 mov	 DWORD PTR _srcCLine$38[ebp], eax
  002b8	8b 4d e4	 mov	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  002bb	c1 e1 02	 shl	 ecx, 2
  002be	8b 55 9c	 mov	 edx, DWORD PTR _dstLine$37[ebp]
  002c1	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  002c4	89 45 9c	 mov	 DWORD PTR _dstLine$37[ebp], eax
$LN13@convert_yv:
  002c7	8b 4d 98	 mov	 ecx, DWORD PTR _y$36[ebp]
  002ca	3b 4d dc	 cmp	 ecx, DWORD PTR _y_range$[ebp+8]
  002cd	0f 8d 53 05 00
	00		 jge	 $LN12@convert_yv

; 721  :             Tout *dstC = dstLine;

  002d3	8b 55 9c	 mov	 edx, DWORD PTR _dstLine$37[ebp]
  002d6	89 55 94	 mov	 DWORD PTR _dstC$35[ebp], edx

; 722  :             Tin *srcP = srcCLine;

  002d9	8b 45 a0	 mov	 eax, DWORD PTR _srcCLine$38[ebp]
  002dc	89 45 90	 mov	 DWORD PTR _srcP$34[ebp], eax

; 723  :             const int x_fin = width - crop_right - crop_left;

  002df	8b 4d 10	 mov	 ecx, DWORD PTR _width$[ebp]
  002e2	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  002e5	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  002e8	89 4d 8c	 mov	 DWORD PTR _x_fin$33[ebp], ecx

; 724  : 
; 725  :             int y_m2 = (y >= 4) ? -2 : 0;

  002eb	83 7d 98 04	 cmp	 DWORD PTR _y$36[ebp], 4
  002ef	7c 0c		 jl	 SHORT $LN31@convert_yv
  002f1	c7 85 00 ff ff
	ff fe ff ff ff	 mov	 DWORD PTR tv227[ebp], -2 ; fffffffeH
  002fb	eb 0a		 jmp	 SHORT $LN32@convert_yv
$LN31@convert_yv:
  002fd	c7 85 00 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv227[ebp], 0
$LN32@convert_yv:
  00307	8b 95 00 ff ff
	ff		 mov	 edx, DWORD PTR tv227[ebp]
  0030d	89 55 88	 mov	 DWORD PTR _y_m2$32[ebp], edx

; 726  :             int y_m1 = (y >= 2) ? -1 : 1;

  00310	83 7d 98 02	 cmp	 DWORD PTR _y$36[ebp], 2
  00314	7c 0c		 jl	 SHORT $LN33@convert_yv
  00316	c7 85 fc fe ff
	ff ff ff ff ff	 mov	 DWORD PTR tv229[ebp], -1
  00320	eb 0a		 jmp	 SHORT $LN34@convert_yv
$LN33@convert_yv:
  00322	c7 85 fc fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv229[ebp], 1
$LN34@convert_yv:
  0032c	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR tv229[ebp]
  00332	89 45 84	 mov	 DWORD PTR _y_m1$31[ebp], eax

; 727  :             int y_p1 = (y < uv_fin - 2) ? 1 : -1;

  00335	8b 4d ac	 mov	 ecx, DWORD PTR _uv_fin$[ebp]
  00338	83 e9 02	 sub	 ecx, 2
  0033b	39 4d 98	 cmp	 DWORD PTR _y$36[ebp], ecx
  0033e	7d 0c		 jge	 SHORT $LN35@convert_yv
  00340	c7 85 f8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv232[ebp], 1
  0034a	eb 0a		 jmp	 SHORT $LN36@convert_yv
$LN35@convert_yv:
  0034c	c7 85 f8 fe ff
	ff ff ff ff ff	 mov	 DWORD PTR tv232[ebp], -1
$LN36@convert_yv:
  00356	8b 95 f8 fe ff
	ff		 mov	 edx, DWORD PTR tv232[ebp]
  0035c	89 55 80	 mov	 DWORD PTR _y_p1$30[ebp], edx

; 728  :             int y_p2 = (y < uv_fin - 4) ? 2 :  0;

  0035f	8b 45 ac	 mov	 eax, DWORD PTR _uv_fin$[ebp]
  00362	83 e8 04	 sub	 eax, 4
  00365	39 45 98	 cmp	 DWORD PTR _y$36[ebp], eax
  00368	7d 0c		 jge	 SHORT $LN37@convert_yv
  0036a	c7 85 f4 fe ff
	ff 02 00 00 00	 mov	 DWORD PTR tv235[ebp], 2
  00374	eb 0a		 jmp	 SHORT $LN38@convert_yv
$LN37@convert_yv:
  00376	c7 85 f4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv235[ebp], 0
$LN38@convert_yv:
  00380	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR tv235[ebp]
  00386	89 8d 7c ff ff
	ff		 mov	 DWORD PTR _y_p2$29[ebp], ecx

; 729  :             int y_p3 = (y < uv_fin - 6) ? 3 : ((y < uv_fin - 2) ? 1 : -1);

  0038c	8b 55 ac	 mov	 edx, DWORD PTR _uv_fin$[ebp]
  0038f	83 ea 06	 sub	 edx, 6
  00392	39 55 98	 cmp	 DWORD PTR _y$36[ebp], edx
  00395	7d 0c		 jge	 SHORT $LN41@convert_yv
  00397	c7 85 f0 fe ff
	ff 03 00 00 00	 mov	 DWORD PTR tv241[ebp], 3
  003a1	eb 2d		 jmp	 SHORT $LN42@convert_yv
$LN41@convert_yv:
  003a3	8b 45 ac	 mov	 eax, DWORD PTR _uv_fin$[ebp]
  003a6	83 e8 02	 sub	 eax, 2
  003a9	39 45 98	 cmp	 DWORD PTR _y$36[ebp], eax
  003ac	7d 0c		 jge	 SHORT $LN39@convert_yv
  003ae	c7 85 ec fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv240[ebp], 1
  003b8	eb 0a		 jmp	 SHORT $LN40@convert_yv
$LN39@convert_yv:
  003ba	c7 85 ec fe ff
	ff ff ff ff ff	 mov	 DWORD PTR tv240[ebp], -1
$LN40@convert_yv:
  003c4	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR tv240[ebp]
  003ca	89 8d f0 fe ff
	ff		 mov	 DWORD PTR tv241[ebp], ecx
$LN42@convert_yv:
  003d0	8b 95 f0 fe ff
	ff		 mov	 edx, DWORD PTR tv241[ebp]
  003d6	89 95 78 ff ff
	ff		 mov	 DWORD PTR _y_p3$28[ebp], edx

; 730  : 
; 731  :             int sy0x0 = srcP[y_m2*src_uv_pitch + 0];

  003dc	8b 45 88	 mov	 eax, DWORD PTR _y_m2$32[ebp]
  003df	0f af 45 a8	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp]
  003e3	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  003e6	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  003ea	89 95 74 ff ff
	ff		 mov	 DWORD PTR _sy0x0$27[ebp], edx

; 732  :             int sy1x0 = srcP[y_m1*src_uv_pitch + 0];

  003f0	8b 45 84	 mov	 eax, DWORD PTR _y_m1$31[ebp]
  003f3	0f af 45 a8	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp]
  003f7	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  003fa	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  003fe	89 95 70 ff ff
	ff		 mov	 DWORD PTR _sy1x0$26[ebp], edx

; 733  :             int sy2x0 = srcP[   0*src_uv_pitch + 0];

  00404	6b 45 a8 00	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp], 0
  00408	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  0040b	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  0040f	89 95 6c ff ff
	ff		 mov	 DWORD PTR _sy2x0$25[ebp], edx

; 734  :             int sy3x0 = srcP[y_p1*src_uv_pitch + 0];

  00415	8b 45 80	 mov	 eax, DWORD PTR _y_p1$30[ebp]
  00418	0f af 45 a8	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp]
  0041c	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  0041f	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  00423	89 95 68 ff ff
	ff		 mov	 DWORD PTR _sy3x0$24[ebp], edx

; 735  :             int sy4x0 = srcP[y_p2*src_uv_pitch + 0];

  00429	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _y_p2$29[ebp]
  0042f	0f af 45 a8	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp]
  00433	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  00436	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  0043a	89 95 64 ff ff
	ff		 mov	 DWORD PTR _sy4x0$23[ebp], edx

; 736  :             int sy5x0 = srcP[y_p3*src_uv_pitch + 0];

  00440	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _y_p3$28[ebp]
  00446	0f af 45 a8	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp]
  0044a	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  0044d	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  00451	89 95 60 ff ff
	ff		 mov	 DWORD PTR _sy5x0$22[ebp], edx

; 737  : 
; 738  :             int cy0x0 = (sy0x0 * 1 + sy2x0 * 7 + 4);

  00457	6b 85 6c ff ff
	ff 07		 imul	 eax, DWORD PTR _sy2x0$25[ebp], 7
  0045e	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _sy0x0$27[ebp]
  00464	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00468	89 95 5c ff ff
	ff		 mov	 DWORD PTR _cy0x0$21[ebp], edx

; 739  :             int cy1x0 = (sy1x0 * 3 + sy3x0 * 5 + 4);

  0046e	6b 85 70 ff ff
	ff 03		 imul	 eax, DWORD PTR _sy1x0$26[ebp], 3
  00475	6b 8d 68 ff ff
	ff 05		 imul	 ecx, DWORD PTR _sy3x0$24[ebp], 5
  0047c	8d 54 08 04	 lea	 edx, DWORD PTR [eax+ecx+4]
  00480	89 95 58 ff ff
	ff		 mov	 DWORD PTR _cy1x0$20[ebp], edx

; 740  :             int cy2x0 = (sy2x0 * 5 + sy4x0 * 3 + 4);

  00486	6b 85 6c ff ff
	ff 05		 imul	 eax, DWORD PTR _sy2x0$25[ebp], 5
  0048d	6b 8d 64 ff ff
	ff 03		 imul	 ecx, DWORD PTR _sy4x0$23[ebp], 3
  00494	8d 54 08 04	 lea	 edx, DWORD PTR [eax+ecx+4]
  00498	89 95 54 ff ff
	ff		 mov	 DWORD PTR _cy2x0$19[ebp], edx

; 741  :             int cy3x0 = (sy3x0 * 7 + sy5x0 * 1 + 4);

  0049e	6b 85 68 ff ff
	ff 07		 imul	 eax, DWORD PTR _sy3x0$24[ebp], 7
  004a5	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _sy5x0$22[ebp]
  004ab	8d 54 08 04	 lea	 edx, DWORD PTR [eax+ecx+4]
  004af	89 95 50 ff ff
	ff		 mov	 DWORD PTR _cy3x0$18[ebp], edx

; 742  :             CHANGE_BIT_DEPTH_4(cy0x0, cy1x0, cy2x0, cy3x0, 3);

  004b5	b8 01 00 00 00	 mov	 eax, 1
  004ba	85 c0		 test	 eax, eax
  004bc	74 3e		 je	 SHORT $LN24@convert_yv
  004be	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _cy0x0$21[ebp]
  004c4	c1 e1 04	 shl	 ecx, 4
  004c7	89 8d 5c ff ff
	ff		 mov	 DWORD PTR _cy0x0$21[ebp], ecx
  004cd	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x0$20[ebp]
  004d3	c1 e2 04	 shl	 edx, 4
  004d6	89 95 58 ff ff
	ff		 mov	 DWORD PTR _cy1x0$20[ebp], edx
  004dc	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR _cy2x0$19[ebp]
  004e2	c1 e0 04	 shl	 eax, 4
  004e5	89 85 54 ff ff
	ff		 mov	 DWORD PTR _cy2x0$19[ebp], eax
  004eb	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x0$18[ebp]
  004f1	c1 e1 04	 shl	 ecx, 4
  004f4	89 8d 50 ff ff
	ff		 mov	 DWORD PTR _cy3x0$18[ebp], ecx
  004fa	eb 40		 jmp	 SHORT $LN25@convert_yv
$LN24@convert_yv:
  004fc	33 d2		 xor	 edx, edx
  004fe	74 3c		 je	 SHORT $LN25@convert_yv
  00500	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _cy0x0$21[ebp]
  00506	c1 f8 fc	 sar	 eax, -4			; fffffffcH
  00509	89 85 5c ff ff
	ff		 mov	 DWORD PTR _cy0x0$21[ebp], eax
  0050f	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x0$20[ebp]
  00515	c1 f9 fc	 sar	 ecx, -4			; fffffffcH
  00518	89 8d 58 ff ff
	ff		 mov	 DWORD PTR _cy1x0$20[ebp], ecx
  0051e	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR _cy2x0$19[ebp]
  00524	c1 fa fc	 sar	 edx, -4			; fffffffcH
  00527	89 95 54 ff ff
	ff		 mov	 DWORD PTR _cy2x0$19[ebp], edx
  0052d	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$18[ebp]
  00533	c1 f8 fc	 sar	 eax, -4			; fffffffcH
  00536	89 85 50 ff ff
	ff		 mov	 DWORD PTR _cy3x0$18[ebp], eax
$LN25@convert_yv:

; 743  : 
; 744  :             for (int x = 0; x < x_fin; x += 2, dstC += 2, srcP++) {

  0053c	c7 85 4c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _x$17[ebp], 0
  00546	eb 21		 jmp	 SHORT $LN16@convert_yv
$LN14@convert_yv:
  00548	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _x$17[ebp]
  0054e	83 c1 02	 add	 ecx, 2
  00551	89 8d 4c ff ff
	ff		 mov	 DWORD PTR _x$17[ebp], ecx
  00557	8b 55 94	 mov	 edx, DWORD PTR _dstC$35[ebp]
  0055a	83 c2 04	 add	 edx, 4
  0055d	89 55 94	 mov	 DWORD PTR _dstC$35[ebp], edx
  00560	8b 45 90	 mov	 eax, DWORD PTR _srcP$34[ebp]
  00563	83 c0 02	 add	 eax, 2
  00566	89 45 90	 mov	 DWORD PTR _srcP$34[ebp], eax
$LN16@convert_yv:
  00569	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _x$17[ebp]
  0056f	3b 4d 8c	 cmp	 ecx, DWORD PTR _x_fin$33[ebp]
  00572	0f 8d a9 02 00
	00		 jge	 $LN15@convert_yv

; 745  :                 int cxplus = (x + 2 < x_fin);

  00578	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR _x$17[ebp]
  0057e	83 c2 02	 add	 edx, 2
  00581	3b 55 8c	 cmp	 edx, DWORD PTR _x_fin$33[ebp]
  00584	7d 0c		 jge	 SHORT $LN43@convert_yv
  00586	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv302[ebp], 1
  00590	eb 0a		 jmp	 SHORT $LN44@convert_yv
$LN43@convert_yv:
  00592	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv302[ebp], 0
$LN44@convert_yv:
  0059c	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv302[ebp]
  005a2	89 85 48 ff ff
	ff		 mov	 DWORD PTR _cxplus$16[ebp], eax

; 746  :                 int sy0x1 = srcP[y_m2*src_uv_pitch + cxplus];

  005a8	8b 4d 88	 mov	 ecx, DWORD PTR _y_m2$32[ebp]
  005ab	0f af 4d a8	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  005af	03 8d 48 ff ff
	ff		 add	 ecx, DWORD PTR _cxplus$16[ebp]
  005b5	8b 55 90	 mov	 edx, DWORD PTR _srcP$34[ebp]
  005b8	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  005bc	89 85 44 ff ff
	ff		 mov	 DWORD PTR _sy0x1$15[ebp], eax

; 747  :                 int sy1x1 = srcP[y_m1*src_uv_pitch + cxplus];

  005c2	8b 4d 84	 mov	 ecx, DWORD PTR _y_m1$31[ebp]
  005c5	0f af 4d a8	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  005c9	03 8d 48 ff ff
	ff		 add	 ecx, DWORD PTR _cxplus$16[ebp]
  005cf	8b 55 90	 mov	 edx, DWORD PTR _srcP$34[ebp]
  005d2	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  005d6	89 85 40 ff ff
	ff		 mov	 DWORD PTR _sy1x1$14[ebp], eax

; 748  :                 int sy2x1 = srcP[   0*src_uv_pitch + cxplus];

  005dc	6b 4d a8 00	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 0
  005e0	03 8d 48 ff ff
	ff		 add	 ecx, DWORD PTR _cxplus$16[ebp]
  005e6	8b 55 90	 mov	 edx, DWORD PTR _srcP$34[ebp]
  005e9	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  005ed	89 85 3c ff ff
	ff		 mov	 DWORD PTR _sy2x1$13[ebp], eax

; 749  :                 int sy3x1 = srcP[y_p1*src_uv_pitch + cxplus];

  005f3	8b 4d 80	 mov	 ecx, DWORD PTR _y_p1$30[ebp]
  005f6	0f af 4d a8	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  005fa	03 8d 48 ff ff
	ff		 add	 ecx, DWORD PTR _cxplus$16[ebp]
  00600	8b 55 90	 mov	 edx, DWORD PTR _srcP$34[ebp]
  00603	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00607	89 85 38 ff ff
	ff		 mov	 DWORD PTR _sy3x1$12[ebp], eax

; 750  :                 int sy4x1 = srcP[y_p2*src_uv_pitch + cxplus];

  0060d	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _y_p2$29[ebp]
  00613	0f af 4d a8	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00617	03 8d 48 ff ff
	ff		 add	 ecx, DWORD PTR _cxplus$16[ebp]
  0061d	8b 55 90	 mov	 edx, DWORD PTR _srcP$34[ebp]
  00620	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00624	89 85 34 ff ff
	ff		 mov	 DWORD PTR _sy4x1$11[ebp], eax

; 751  :                 int sy5x1 = srcP[y_p3*src_uv_pitch + cxplus];

  0062a	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _y_p3$28[ebp]
  00630	0f af 4d a8	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00634	03 8d 48 ff ff
	ff		 add	 ecx, DWORD PTR _cxplus$16[ebp]
  0063a	8b 55 90	 mov	 edx, DWORD PTR _srcP$34[ebp]
  0063d	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00641	89 85 30 ff ff
	ff		 mov	 DWORD PTR _sy5x1$10[ebp], eax

; 752  : 
; 753  :                 int cy0x1 = (sy0x1 * 1 + sy2x1 * 7 + 4);

  00647	6b 8d 3c ff ff
	ff 07		 imul	 ecx, DWORD PTR _sy2x1$13[ebp], 7
  0064e	8b 95 44 ff ff
	ff		 mov	 edx, DWORD PTR _sy0x1$15[ebp]
  00654	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  00658	89 85 2c ff ff
	ff		 mov	 DWORD PTR _cy0x1$9[ebp], eax

; 754  :                 int cy1x1 = (sy1x1 * 3 + sy3x1 * 5 + 4);

  0065e	6b 8d 40 ff ff
	ff 03		 imul	 ecx, DWORD PTR _sy1x1$14[ebp], 3
  00665	6b 95 38 ff ff
	ff 05		 imul	 edx, DWORD PTR _sy3x1$12[ebp], 5
  0066c	8d 44 11 04	 lea	 eax, DWORD PTR [ecx+edx+4]
  00670	89 85 28 ff ff
	ff		 mov	 DWORD PTR _cy1x1$8[ebp], eax

; 755  :                 int cy2x1 = (sy2x1 * 5 + sy4x1 * 3 + 4);

  00676	6b 8d 3c ff ff
	ff 05		 imul	 ecx, DWORD PTR _sy2x1$13[ebp], 5
  0067d	6b 95 34 ff ff
	ff 03		 imul	 edx, DWORD PTR _sy4x1$11[ebp], 3
  00684	8d 44 11 04	 lea	 eax, DWORD PTR [ecx+edx+4]
  00688	89 85 24 ff ff
	ff		 mov	 DWORD PTR _cy2x1$7[ebp], eax

; 756  :                 int cy3x1 = (sy3x1 * 7 + sy5x1 * 1 + 4);

  0068e	6b 8d 38 ff ff
	ff 07		 imul	 ecx, DWORD PTR _sy3x1$12[ebp], 7
  00695	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR _sy5x1$10[ebp]
  0069b	8d 44 11 04	 lea	 eax, DWORD PTR [ecx+edx+4]
  0069f	89 85 20 ff ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], eax

; 757  :                 CHANGE_BIT_DEPTH_4(cy0x1, cy1x1, cy2x1, cy3x1, 3);

  006a5	b9 01 00 00 00	 mov	 ecx, 1
  006aa	85 c9		 test	 ecx, ecx
  006ac	74 3e		 je	 SHORT $LN27@convert_yv
  006ae	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR _cy0x1$9[ebp]
  006b4	c1 e2 04	 shl	 edx, 4
  006b7	89 95 2c ff ff
	ff		 mov	 DWORD PTR _cy0x1$9[ebp], edx
  006bd	8b 85 28 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x1$8[ebp]
  006c3	c1 e0 04	 shl	 eax, 4
  006c6	89 85 28 ff ff
	ff		 mov	 DWORD PTR _cy1x1$8[ebp], eax
  006cc	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR _cy2x1$7[ebp]
  006d2	c1 e1 04	 shl	 ecx, 4
  006d5	89 8d 24 ff ff
	ff		 mov	 DWORD PTR _cy2x1$7[ebp], ecx
  006db	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR _cy3x1$6[ebp]
  006e1	c1 e2 04	 shl	 edx, 4
  006e4	89 95 20 ff ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], edx
  006ea	eb 40		 jmp	 SHORT $LN28@convert_yv
$LN27@convert_yv:
  006ec	33 c0		 xor	 eax, eax
  006ee	74 3c		 je	 SHORT $LN28@convert_yv
  006f0	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR _cy0x1$9[ebp]
  006f6	c1 f9 fc	 sar	 ecx, -4			; fffffffcH
  006f9	89 8d 2c ff ff
	ff		 mov	 DWORD PTR _cy0x1$9[ebp], ecx
  006ff	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x1$8[ebp]
  00705	c1 fa fc	 sar	 edx, -4			; fffffffcH
  00708	89 95 28 ff ff
	ff		 mov	 DWORD PTR _cy1x1$8[ebp], edx
  0070e	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _cy2x1$7[ebp]
  00714	c1 f8 fc	 sar	 eax, -4			; fffffffcH
  00717	89 85 24 ff ff
	ff		 mov	 DWORD PTR _cy2x1$7[ebp], eax
  0071d	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x1$6[ebp]
  00723	c1 f9 fc	 sar	 ecx, -4			; fffffffcH
  00726	89 8d 20 ff ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], ecx
$LN28@convert_yv:

; 758  : 
; 759  :                 dstC[0*dst_y_pitch   + 0] = (Tout)cy0x0;

  0072c	6b 55 e4 00	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 0
  00730	8b 45 94	 mov	 eax, DWORD PTR _dstC$35[ebp]
  00733	66 8b 8d 5c ff
	ff ff		 mov	 cx, WORD PTR _cy0x0$21[ebp]
  0073a	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx

; 760  :                 dstC[0*dst_y_pitch   + 1] = (Tout)((cy0x0 + cy0x1 + 1) >> 1);

  0073e	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR _cy0x1$9[ebp]
  00744	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _cy0x0$21[ebp]
  0074a	8d 4c 10 01	 lea	 ecx, DWORD PTR [eax+edx+1]
  0074e	d1 f9		 sar	 ecx, 1
  00750	6b 55 e4 00	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 0
  00754	8b 45 94	 mov	 eax, DWORD PTR _dstC$35[ebp]
  00757	66 89 4c 50 02	 mov	 WORD PTR [eax+edx*2+2], cx

; 761  :                 dstC[1*dst_y_pitch   + 0] = (Tout)cy1x0;

  0075c	8b 4d e4	 mov	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  0075f	8b 55 94	 mov	 edx, DWORD PTR _dstC$35[ebp]
  00762	66 8b 85 58 ff
	ff ff		 mov	 ax, WORD PTR _cy1x0$20[ebp]
  00769	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax

; 762  :                 dstC[1*dst_y_pitch   + 1] = (Tout)((cy1x0 + cy1x1 + 1) >> 1);

  0076d	8b 8d 28 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x1$8[ebp]
  00773	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x0$20[ebp]
  00779	8d 44 0a 01	 lea	 eax, DWORD PTR [edx+ecx+1]
  0077d	d1 f8		 sar	 eax, 1
  0077f	8b 4d e4	 mov	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  00782	8b 55 94	 mov	 edx, DWORD PTR _dstC$35[ebp]
  00785	66 89 44 4a 02	 mov	 WORD PTR [edx+ecx*2+2], ax

; 763  :                 dstC[2*dst_y_pitch   + 0] = (Tout)cy2x0;

  0078a	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  0078d	d1 e0		 shl	 eax, 1
  0078f	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$35[ebp]
  00792	66 8b 95 54 ff
	ff ff		 mov	 dx, WORD PTR _cy2x0$19[ebp]
  00799	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx

; 764  :                 dstC[2*dst_y_pitch   + 1] = (Tout)((cy2x0 + cy2x1 + 1) >> 1);

  0079d	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _cy2x1$7[ebp]
  007a3	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _cy2x0$19[ebp]
  007a9	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  007ad	d1 fa		 sar	 edx, 1
  007af	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  007b2	d1 e0		 shl	 eax, 1
  007b4	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$35[ebp]
  007b7	66 89 54 41 02	 mov	 WORD PTR [ecx+eax*2+2], dx

; 765  :                 dstC[3*dst_y_pitch   + 0] = (Tout)cy3x0;

  007bc	6b 55 e4 03	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 3
  007c0	8b 45 94	 mov	 eax, DWORD PTR _dstC$35[ebp]
  007c3	66 8b 8d 50 ff
	ff ff		 mov	 cx, WORD PTR _cy3x0$18[ebp]
  007ca	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx

; 766  :                 dstC[3*dst_y_pitch   + 1] = (Tout)((cy3x0 + cy3x1 + 1) >> 1);

  007ce	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR _cy3x1$6[ebp]
  007d4	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$18[ebp]
  007da	8d 4c 10 01	 lea	 ecx, DWORD PTR [eax+edx+1]
  007de	d1 f9		 sar	 ecx, 1
  007e0	6b 55 e4 03	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 3
  007e4	8b 45 94	 mov	 eax, DWORD PTR _dstC$35[ebp]
  007e7	66 89 4c 50 02	 mov	 WORD PTR [eax+edx*2+2], cx

; 767  : 
; 768  :                 cy0x0 = cy0x1;

  007ec	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR _cy0x1$9[ebp]
  007f2	89 8d 5c ff ff
	ff		 mov	 DWORD PTR _cy0x0$21[ebp], ecx

; 769  :                 cy1x0 = cy1x1;

  007f8	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x1$8[ebp]
  007fe	89 95 58 ff ff
	ff		 mov	 DWORD PTR _cy1x0$20[ebp], edx

; 770  :                 cy2x0 = cy2x1;

  00804	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _cy2x1$7[ebp]
  0080a	89 85 54 ff ff
	ff		 mov	 DWORD PTR _cy2x0$19[ebp], eax

; 771  :                 cy3x0 = cy3x1;

  00810	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x1$6[ebp]
  00816	89 8d 50 ff ff
	ff		 mov	 DWORD PTR _cy3x0$18[ebp], ecx

; 772  :             }

  0081c	e9 27 fd ff ff	 jmp	 $LN14@convert_yv
$LN15@convert_yv:

; 773  :         }

  00821	e9 7b fa ff ff	 jmp	 $LN11@convert_yv
$LN12@convert_yv:

; 774  :     }

  00826	e9 29 fa ff ff	 jmp	 $LN8@convert_yv
$LN1@convert_yv:

; 775  : }

  0082b	52		 push	 edx
  0082c	8b cd		 mov	 ecx, ebp
  0082e	50		 push	 eax
  0082f	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN47@convert_yv
  00835	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0083a	58		 pop	 eax
  0083b	5a		 pop	 edx
  0083c	5f		 pop	 edi
  0083d	5e		 pop	 esi
  0083e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00841	33 cd		 xor	 ecx, ebp
  00843	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00848	81 c4 18 01 00
	00		 add	 esp, 280		; 00000118H
  0084e	3b ec		 cmp	 ebp, esp
  00850	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00855	8b e5		 mov	 esp, ebp
  00857	5d		 pop	 ebp
  00858	c3		 ret	 0
  00859	0f 1f 00	 npad	 3
$LN47@convert_yv:
  0085c	01 00 00 00	 DD	 1
  00860	00 00 00 00	 DD	 $LN46@convert_yv
$LN46@convert_yv:
  00864	d4 ff ff ff	 DD	 -44			; ffffffd4H
  00868	0c 00 00 00	 DD	 12			; 0000000cH
  0086c	00 00 00 00	 DD	 $LN45@convert_yv
$LN45@convert_yv:
  00870	79		 DB	 121			; 00000079H
  00871	5f		 DB	 95			; 0000005fH
  00872	72		 DB	 114			; 00000072H
  00873	61		 DB	 97			; 00000061H
  00874	6e		 DB	 110			; 0000006eH
  00875	67		 DB	 103			; 00000067H
  00876	65		 DB	 101			; 00000065H
  00877	00		 DB	 0
??$convert_yv12_i_to_yuv444_c@G$08G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_i_to_yuv444_c<unsigned short,9,unsigned short,16,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yv12_09_i_to_yuv444_16bit@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_09_i_to_yuv444_16bit

; 869  : static void convert_yv12_09_i_to_yuv444_16bit(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 870  :     convert_yv12_i_to_yuv444_c<uint16_t, 9, uint16_t, 16, false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yv12_i_to_yuv444_c@G$08G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_i_to_yuv444_c<unsigned short,9,unsigned short,16,0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 871  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yv12_09_i_to_yuv444_16bit@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_09_i_to_yuv444_16bit
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
tv432 = -300						; size = 4
tv317 = -296						; size = 4
tv232 = -292						; size = 4
$T1 = -288						; size = 4
$T2 = -284						; size = 4
$T3 = -280						; size = 4
$T4 = -276						; size = 4
$T5 = -272						; size = 12
_cy3x1$6 = -260						; size = 4
_cy1x1$7 = -256						; size = 4
_cy3x0$8 = -252						; size = 4
_cy1x0$9 = -248						; size = 4
_cy4x1$10 = -244					; size = 4
_cy2x1$11 = -240					; size = 4
_cy0x1$12 = -236					; size = 4
_cy4x0$13 = -232					; size = 4
_cy2x0$14 = -228					; size = 4
_cy0x0$15 = -224					; size = 4
_cxplus$16 = -220					; size = 4
_x$17 = -216						; size = 4
_cy3x1$18 = -212					; size = 4
_cy1x1$19 = -208					; size = 4
_cy3x0$20 = -204					; size = 4
_cy1x0$21 = -200					; size = 4
_cy4x1$22 = -196					; size = 4
_cy2x1$23 = -192					; size = 4
_cy0x1$24 = -188					; size = 4
_cy4x0$25 = -184					; size = 4
_cy2x0$26 = -180					; size = 4
_cy0x0$27 = -176					; size = 4
_cxplus$28 = -172					; size = 4
_x$29 = -168						; size = 4
_cy3x1$30 = -164					; size = 4
_cy1x1$31 = -160					; size = 4
_cy3x0$32 = -156					; size = 4
_cy1x0$33 = -152					; size = 4
_cy4x1$34 = -148					; size = 4
_cy2x1$35 = -144					; size = 4
_cy0x1$36 = -140					; size = 4
_cy4x0$37 = -136					; size = 4
_cy2x0$38 = -132					; size = 4
_cy0x0$39 = -128					; size = 4
_cxplus$40 = -124					; size = 4
_x$41 = -120						; size = 4
_x_fin$42 = -116					; size = 4
_srcP$43 = -112						; size = 4
_dstC$44 = -108						; size = 4
_y$45 = -104						; size = 4
_dstLine$46 = -100					; size = 4
_srcCLine$47 = -96					; size = 4
_ic$48 = -92						; size = 4
_src_uv_pitch$ = -88					; size = 4
_x$49 = -84						; size = 4
_y$50 = -80						; size = 4
_y_width$51 = -76					; size = 4
_y_fin$52 = -72						; size = 4
_dstLine$53 = -68					; size = 4
_srcYLine$54 = -64					; size = 4
$T55 = -60						; size = 12
_y_range$ = -44						; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yv12_p_to_yuv444_c@G$08G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_p_to_yuv444_c<unsigned short,9,unsigned short,16,0>

; 573  : static void __forceinline convert_yv12_p_to_yuv444_c(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 2c 01 00
	00		 sub	 esp, 300		; 0000012cH
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8d bd d4 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-300]
  00011	b9 4b 00 00 00	 mov	 ecx, 75			; 0000004bH
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 574  :     static_assert((sizeof(Tin)  == 1 && in_bit_depth  == 8) || (sizeof(Tin)  == 2 && 8 < in_bit_depth  && in_bit_depth  <= 16), "invalid input bit depth.");
; 575  :     static_assert((sizeof(Tout) == 1 && out_bit_depth == 8) || (sizeof(Tout) == 2 && 8 < out_bit_depth && out_bit_depth <= 16), "invalid output bit depth.");
; 576  :     const int crop_left   = crop[0];

  00027	b8 04 00 00 00	 mov	 eax, 4
  0002c	6b c8 00	 imul	 ecx, eax, 0
  0002f	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00032	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00035	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 577  :     const int crop_up     = crop[1];

  00038	b9 04 00 00 00	 mov	 ecx, 4
  0003d	c1 e1 00	 shl	 ecx, 0
  00040	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00043	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00046	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 578  :     const int crop_right  = crop[2];

  00049	b9 04 00 00 00	 mov	 ecx, 4
  0004e	d1 e1		 shl	 ecx, 1
  00050	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00053	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00056	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 579  :     const int crop_bottom = crop[3];

  00059	b9 04 00 00 00	 mov	 ecx, 4
  0005e	6b d1 03	 imul	 edx, ecx, 3
  00061	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00064	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00067	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 580  :     const int src_y_pitch = src_y_pitch_byte / sizeof(Tin);

  0006a	8b 55 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebp]
  0006d	d1 ea		 shr	 edx, 1
  0006f	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 581  :     const int dst_y_pitch = dst_y_pitch_byte / sizeof(Tout);

  00072	8b 45 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  00075	d1 e8		 shr	 eax, 1
  00077	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 582  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  0007a	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0007d	51		 push	 ecx
  0007e	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  00081	52		 push	 edx
  00082	8b 45 20	 mov	 eax, DWORD PTR _height$[ebp]
  00085	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  00088	50		 push	 eax
  00089	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  0008c	51		 push	 ecx
  0008d	8d 95 f0 fe ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  00093	52		 push	 edx
  00094	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00099	83 c4 14	 add	 esp, 20			; 00000014H
  0009c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009e	89 4d c4	 mov	 DWORD PTR $T55[ebp], ecx
  000a1	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a4	89 55 c8	 mov	 DWORD PTR $T55[ebp+4], edx
  000a7	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000aa	89 45 cc	 mov	 DWORD PTR $T55[ebp+8], eax
  000ad	8b 4d c4	 mov	 ecx, DWORD PTR $T55[ebp]
  000b0	89 4d d4	 mov	 DWORD PTR _y_range$[ebp], ecx
  000b3	8b 55 c8	 mov	 edx, DWORD PTR $T55[ebp+4]
  000b6	89 55 d8	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000b9	8b 45 cc	 mov	 eax, DWORD PTR $T55[ebp+8]
  000bc	89 45 dc	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 583  :     //Y
; 584  :     if (!uv_only) {

  000bf	b9 01 00 00 00	 mov	 ecx, 1
  000c4	85 c9		 test	 ecx, ecx
  000c6	0f 84 77 01 00
	00		 je	 $LN23@convert_yv

; 585  :         Tin *srcYLine = (Tin *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000cc	ba 04 00 00 00	 mov	 edx, 4
  000d1	6b c2 00	 imul	 eax, edx, 0
  000d4	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  000d7	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  000db	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  000de	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  000e1	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  000e4	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  000e7	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  000ea	89 45 c0	 mov	 DWORD PTR _srcYLine$54[ebp], eax

; 586  :         Tout *dstLine = (Tout *)dst[0] + dst_y_pitch * y_range.start_dst;

  000ed	b9 04 00 00 00	 mov	 ecx, 4
  000f2	6b d1 00	 imul	 edx, ecx, 0
  000f5	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  000f8	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  000fc	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  000ff	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  00102	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  00105	89 45 bc	 mov	 DWORD PTR _dstLine$53[ebp], eax

; 587  :         const int y_fin = height - crop_bottom;

  00108	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  0010b	2b 4d ec	 sub	 ecx, DWORD PTR _crop_bottom$[ebp]
  0010e	89 4d b8	 mov	 DWORD PTR _y_fin$52[ebp], ecx

; 588  :         const int y_width = width - crop_right - crop_left;

  00111	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00114	2b 55 f0	 sub	 edx, DWORD PTR _crop_right$[ebp]
  00117	2b 55 f8	 sub	 edx, DWORD PTR _crop_left$[ebp]
  0011a	89 55 b4	 mov	 DWORD PTR _y_width$51[ebp], edx

; 589  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  0011d	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _y$50[ebp], 0
  00124	eb 21		 jmp	 SHORT $LN4@convert_yv
$LN2@convert_yv:
  00126	8b 45 b0	 mov	 eax, DWORD PTR _y$50[ebp]
  00129	83 c0 01	 add	 eax, 1
  0012c	89 45 b0	 mov	 DWORD PTR _y$50[ebp], eax
  0012f	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  00132	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$54[ebp]
  00135	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  00138	89 45 c0	 mov	 DWORD PTR _srcYLine$54[ebp], eax
  0013b	8b 4d e4	 mov	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  0013e	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$53[ebp]
  00141	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  00144	89 45 bc	 mov	 DWORD PTR _dstLine$53[ebp], eax
$LN4@convert_yv:
  00147	8b 4d b0	 mov	 ecx, DWORD PTR _y$50[ebp]
  0014a	3b 4d dc	 cmp	 ecx, DWORD PTR _y_range$[ebp+8]
  0014d	0f 8d f0 00 00
	00		 jge	 $LN23@convert_yv

; 590  :             if (in_bit_depth == out_bit_depth && sizeof(Tin) == sizeof(Tout)) {

  00153	33 d2		 xor	 edx, edx
  00155	74 1b		 je	 SHORT $LN24@convert_yv

; 591  :                 memcpy(dstLine, srcYLine, y_width * sizeof(Tin));

  00157	8b 45 b4	 mov	 eax, DWORD PTR _y_width$51[ebp]
  0015a	d1 e0		 shl	 eax, 1
  0015c	50		 push	 eax
  0015d	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$54[ebp]
  00160	51		 push	 ecx
  00161	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$53[ebp]
  00164	52		 push	 edx
  00165	e8 00 00 00 00	 call	 _memcpy
  0016a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 592  :             } else {

  0016d	e9 cc 00 00 00	 jmp	 $LN25@convert_yv
$LN24@convert_yv:

; 593  :                 for (int x = 0; x < y_width; x++) {

  00172	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR _x$49[ebp], 0
  00179	eb 09		 jmp	 SHORT $LN7@convert_yv
$LN5@convert_yv:
  0017b	8b 45 ac	 mov	 eax, DWORD PTR _x$49[ebp]
  0017e	83 c0 01	 add	 eax, 1
  00181	89 45 ac	 mov	 DWORD PTR _x$49[ebp], eax
$LN7@convert_yv:
  00184	8b 4d ac	 mov	 ecx, DWORD PTR _x$49[ebp]
  00187	3b 4d b4	 cmp	 ecx, DWORD PTR _y_width$51[ebp]
  0018a	0f 8d ae 00 00
	00		 jge	 $LN25@convert_yv

; 594  :                     if (out_bit_depth > in_bit_depth) {

  00190	ba 01 00 00 00	 mov	 edx, 1
  00195	85 d2		 test	 edx, edx
  00197	74 44		 je	 SHORT $LN26@convert_yv

; 595  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) << std::max(out_bit_depth - in_bit_depth, 0));

  00199	c7 85 ec fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], 0
  001a3	c7 85 e8 fe ff
	ff 07 00 00 00	 mov	 DWORD PTR $T3[ebp], 7
  001ad	8b 45 ac	 mov	 eax, DWORD PTR _x$49[ebp]
  001b0	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$54[ebp]
  001b3	0f b7 34 41	 movzx	 esi, WORD PTR [ecx+eax*2]
  001b7	8d 95 ec fe ff
	ff		 lea	 edx, DWORD PTR $T4[ebp]
  001bd	52		 push	 edx
  001be	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  001c4	50		 push	 eax
  001c5	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  001ca	83 c4 08	 add	 esp, 8
  001cd	8b 08		 mov	 ecx, DWORD PTR [eax]
  001cf	d3 e6		 shl	 esi, cl
  001d1	8b 4d ac	 mov	 ecx, DWORD PTR _x$49[ebp]
  001d4	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$53[ebp]
  001d7	66 89 34 4a	 mov	 WORD PTR [edx+ecx*2], si
  001db	eb 5c		 jmp	 SHORT $LN27@convert_yv
$LN26@convert_yv:

; 596  :                     } else if (out_bit_depth < in_bit_depth) {

  001dd	33 c0		 xor	 eax, eax
  001df	74 44		 je	 SHORT $LN28@convert_yv

; 597  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) >> std::max(in_bit_depth - out_bit_depth, 0));

  001e1	c7 85 e4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], 0
  001eb	c7 85 e0 fe ff
	ff f9 ff ff ff	 mov	 DWORD PTR $T1[ebp], -7	; fffffff9H
  001f5	8b 4d ac	 mov	 ecx, DWORD PTR _x$49[ebp]
  001f8	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$54[ebp]
  001fb	0f b7 34 4a	 movzx	 esi, WORD PTR [edx+ecx*2]
  001ff	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  00205	50		 push	 eax
  00206	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  0020c	51		 push	 ecx
  0020d	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  00212	83 c4 08	 add	 esp, 8
  00215	8b 08		 mov	 ecx, DWORD PTR [eax]
  00217	d3 fe		 sar	 esi, cl
  00219	8b 55 ac	 mov	 edx, DWORD PTR _x$49[ebp]
  0021c	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$53[ebp]
  0021f	66 89 34 50	 mov	 WORD PTR [eax+edx*2], si

; 598  :                     } else {

  00223	eb 14		 jmp	 SHORT $LN27@convert_yv
$LN28@convert_yv:

; 599  :                         dstLine[x] = (Tout)srcYLine[x];

  00225	8b 4d ac	 mov	 ecx, DWORD PTR _x$49[ebp]
  00228	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$53[ebp]
  0022b	8b 45 ac	 mov	 eax, DWORD PTR _x$49[ebp]
  0022e	8b 75 c0	 mov	 esi, DWORD PTR _srcYLine$54[ebp]
  00231	66 8b 04 46	 mov	 ax, WORD PTR [esi+eax*2]
  00235	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax
$LN27@convert_yv:

; 600  :                     }
; 601  :                 }

  00239	e9 3d ff ff ff	 jmp	 $LN5@convert_yv
$LN25@convert_yv:

; 602  :             }
; 603  :         }

  0023e	e9 e3 fe ff ff	 jmp	 $LN2@convert_yv
$LN23@convert_yv:

; 604  :     }
; 605  :     //UV
; 606  :     const int src_uv_pitch = src_uv_pitch_byte / sizeof(Tin);

  00243	8b 4d 18	 mov	 ecx, DWORD PTR _src_uv_pitch_byte$[ebp]
  00246	d1 e9		 shr	 ecx, 1
  00248	89 4d a8	 mov	 DWORD PTR _src_uv_pitch$[ebp], ecx

; 607  :     for (int ic = 1; ic < 3; ic++) {

  0024b	c7 45 a4 01 00
	00 00		 mov	 DWORD PTR _ic$48[ebp], 1
  00252	eb 09		 jmp	 SHORT $LN10@convert_yv
$LN8@convert_yv:
  00254	8b 55 a4	 mov	 edx, DWORD PTR _ic$48[ebp]
  00257	83 c2 01	 add	 edx, 1
  0025a	89 55 a4	 mov	 DWORD PTR _ic$48[ebp], edx
$LN10@convert_yv:
  0025d	83 7d a4 03	 cmp	 DWORD PTR _ic$48[ebp], 3
  00261	0f 8d 07 07 00
	00		 jge	 $LN1@convert_yv

; 608  :         Tin *srcCLine = (Tin *)src[ic] + (((src_uv_pitch * y_range.start_src) + crop_left) >> 1);

  00267	8b 45 a8	 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  0026a	0f af 45 d4	 imul	 eax, DWORD PTR _y_range$[ebp]
  0026e	03 45 f8	 add	 eax, DWORD PTR _crop_left$[ebp]
  00271	d1 f8		 sar	 eax, 1
  00273	8b 4d a4	 mov	 ecx, DWORD PTR _ic$48[ebp]
  00276	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  00279	8b 0c 8a	 mov	 ecx, DWORD PTR [edx+ecx*4]
  0027c	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  0027f	89 55 a0	 mov	 DWORD PTR _srcCLine$47[ebp], edx

; 609  :         Tout *dstLine = (Tout *)dst[ic] + dst_y_pitch * y_range.start_dst;

  00282	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  00285	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  00289	8b 4d a4	 mov	 ecx, DWORD PTR _ic$48[ebp]
  0028c	8b 55 08	 mov	 edx, DWORD PTR _dst$[ebp]
  0028f	8b 0c 8a	 mov	 ecx, DWORD PTR [edx+ecx*4]
  00292	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00295	89 55 9c	 mov	 DWORD PTR _dstLine$46[ebp], edx

; 610  :         for (int y = 0; y < y_range.len; y += 2, srcCLine += src_uv_pitch, dstLine += dst_y_pitch * 2) {

  00298	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _y$45[ebp], 0
  0029f	eb 23		 jmp	 SHORT $LN13@convert_yv
$LN11@convert_yv:
  002a1	8b 45 98	 mov	 eax, DWORD PTR _y$45[ebp]
  002a4	83 c0 02	 add	 eax, 2
  002a7	89 45 98	 mov	 DWORD PTR _y$45[ebp], eax
  002aa	8b 4d a8	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  002ad	8b 55 a0	 mov	 edx, DWORD PTR _srcCLine$47[ebp]
  002b0	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  002b3	89 45 a0	 mov	 DWORD PTR _srcCLine$47[ebp], eax
  002b6	8b 4d e4	 mov	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  002b9	d1 e1		 shl	 ecx, 1
  002bb	8b 55 9c	 mov	 edx, DWORD PTR _dstLine$46[ebp]
  002be	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  002c1	89 45 9c	 mov	 DWORD PTR _dstLine$46[ebp], eax
$LN13@convert_yv:
  002c4	8b 4d 98	 mov	 ecx, DWORD PTR _y$45[ebp]
  002c7	3b 4d dc	 cmp	 ecx, DWORD PTR _y_range$[ebp+8]
  002ca	0f 8d 99 06 00
	00		 jge	 $LN12@convert_yv

; 611  :             Tout *dstC = dstLine;

  002d0	8b 55 9c	 mov	 edx, DWORD PTR _dstLine$46[ebp]
  002d3	89 55 94	 mov	 DWORD PTR _dstC$44[ebp], edx

; 612  :             Tin *srcP = srcCLine;

  002d6	8b 45 a0	 mov	 eax, DWORD PTR _srcCLine$47[ebp]
  002d9	89 45 90	 mov	 DWORD PTR _srcP$43[ebp], eax

; 613  :             const int x_fin = width - crop_right - crop_left;

  002dc	8b 4d 10	 mov	 ecx, DWORD PTR _width$[ebp]
  002df	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  002e2	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  002e5	89 4d 8c	 mov	 DWORD PTR _x_fin$42[ebp], ecx

; 614  :             if (y == 0) {

  002e8	83 7d 98 00	 cmp	 DWORD PTR _y$45[ebp], 0
  002ec	0f 85 0c 02 00
	00		 jne	 $LN30@convert_yv

; 615  :                 for (int x = 0; x < x_fin; x += 2, dstC += 2, srcP++) {

  002f2	c7 45 88 00 00
	00 00		 mov	 DWORD PTR _x$41[ebp], 0
  002f9	eb 1b		 jmp	 SHORT $LN16@convert_yv
$LN14@convert_yv:
  002fb	8b 55 88	 mov	 edx, DWORD PTR _x$41[ebp]
  002fe	83 c2 02	 add	 edx, 2
  00301	89 55 88	 mov	 DWORD PTR _x$41[ebp], edx
  00304	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  00307	83 c0 04	 add	 eax, 4
  0030a	89 45 94	 mov	 DWORD PTR _dstC$44[ebp], eax
  0030d	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$43[ebp]
  00310	83 c1 02	 add	 ecx, 2
  00313	89 4d 90	 mov	 DWORD PTR _srcP$43[ebp], ecx
$LN16@convert_yv:
  00316	8b 55 88	 mov	 edx, DWORD PTR _x$41[ebp]
  00319	3b 55 8c	 cmp	 edx, DWORD PTR _x_fin$42[ebp]
  0031c	0f 8d d7 01 00
	00		 jge	 $LN15@convert_yv

; 616  :                     int cxplus = (x + 2 < x_fin);

  00322	8b 45 88	 mov	 eax, DWORD PTR _x$41[ebp]
  00325	83 c0 02	 add	 eax, 2
  00328	3b 45 8c	 cmp	 eax, DWORD PTR _x_fin$42[ebp]
  0032b	7d 0c		 jge	 SHORT $LN44@convert_yv
  0032d	c7 85 dc fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv232[ebp], 1
  00337	eb 0a		 jmp	 SHORT $LN45@convert_yv
$LN44@convert_yv:
  00339	c7 85 dc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv232[ebp], 0
$LN45@convert_yv:
  00343	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR tv232[ebp]
  00349	89 4d 84	 mov	 DWORD PTR _cxplus$40[ebp], ecx

; 617  :                     int cy0x0 = srcP[ 0*src_uv_pitch + 0];

  0034c	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  00350	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  00353	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  00357	89 4d 80	 mov	 DWORD PTR _cy0x0$39[ebp], ecx

; 618  :                     int cy2x0 = srcP[ 0*src_uv_pitch + 0];

  0035a	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  0035e	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  00361	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  00365	89 8d 7c ff ff
	ff		 mov	 DWORD PTR _cy2x0$38[ebp], ecx

; 619  :                     int cy4x0 = srcP[ 1*src_uv_pitch + 0];

  0036b	8b 55 a8	 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  0036e	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  00371	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  00375	89 8d 78 ff ff
	ff		 mov	 DWORD PTR _cy4x0$37[ebp], ecx

; 620  :                     int cy0x1 = srcP[ 0*src_uv_pitch + cxplus];

  0037b	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  0037f	03 55 84	 add	 edx, DWORD PTR _cxplus$40[ebp]
  00382	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  00385	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  00389	89 8d 74 ff ff
	ff		 mov	 DWORD PTR _cy0x1$36[ebp], ecx

; 621  :                     int cy2x1 = srcP[ 0*src_uv_pitch + cxplus];

  0038f	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  00393	03 55 84	 add	 edx, DWORD PTR _cxplus$40[ebp]
  00396	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  00399	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  0039d	89 8d 70 ff ff
	ff		 mov	 DWORD PTR _cy2x1$35[ebp], ecx

; 622  :                     int cy4x1 = srcP[ 1*src_uv_pitch + cxplus];

  003a3	8b 55 84	 mov	 edx, DWORD PTR _cxplus$40[ebp]
  003a6	03 55 a8	 add	 edx, DWORD PTR _src_uv_pitch$[ebp]
  003a9	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  003ac	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  003b0	89 8d 6c ff ff
	ff		 mov	 DWORD PTR _cy4x1$34[ebp], ecx

; 623  : 
; 624  :                     int cy1x0 = (cy0x0 * 1 + cy2x0 * 3 + 2);

  003b6	6b 95 7c ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x0$38[ebp], 3
  003bd	8b 45 80	 mov	 eax, DWORD PTR _cy0x0$39[ebp]
  003c0	8d 4c 10 02	 lea	 ecx, DWORD PTR [eax+edx+2]
  003c4	89 8d 68 ff ff
	ff		 mov	 DWORD PTR _cy1x0$33[ebp], ecx

; 625  :                     int cy3x0 = (cy2x0 * 3 + cy4x0 * 1 + 2);

  003ca	6b 95 7c ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x0$38[ebp], 3
  003d1	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _cy4x0$37[ebp]
  003d7	8d 4c 02 02	 lea	 ecx, DWORD PTR [edx+eax+2]
  003db	89 8d 64 ff ff
	ff		 mov	 DWORD PTR _cy3x0$32[ebp], ecx

; 626  :                     int cy1x1 = (cy0x1 * 1 + cy2x1 * 3 + 2);

  003e1	6b 95 70 ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x1$35[ebp], 3
  003e8	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _cy0x1$36[ebp]
  003ee	8d 4c 10 02	 lea	 ecx, DWORD PTR [eax+edx+2]
  003f2	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _cy1x1$31[ebp], ecx

; 627  :                     int cy3x1 = (cy2x1 * 3 + cy4x1 * 1 + 2);

  003f8	6b 95 70 ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x1$35[ebp], 3
  003ff	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _cy4x1$34[ebp]
  00405	8d 4c 02 02	 lea	 ecx, DWORD PTR [edx+eax+2]
  00409	89 8d 5c ff ff
	ff		 mov	 DWORD PTR _cy3x1$30[ebp], ecx

; 628  :                     CHANGE_BIT_DEPTH_4(cy1x0, cy3x0, cy1x1, cy3x1, 2);

  0040f	ba 01 00 00 00	 mov	 edx, 1
  00414	85 d2		 test	 edx, edx
  00416	74 3e		 je	 SHORT $LN32@convert_yv
  00418	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x0$33[ebp]
  0041e	c1 e0 05	 shl	 eax, 5
  00421	89 85 68 ff ff
	ff		 mov	 DWORD PTR _cy1x0$33[ebp], eax
  00427	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x0$32[ebp]
  0042d	c1 e1 05	 shl	 ecx, 5
  00430	89 8d 64 ff ff
	ff		 mov	 DWORD PTR _cy3x0$32[ebp], ecx
  00436	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x1$31[ebp]
  0043c	c1 e2 05	 shl	 edx, 5
  0043f	89 95 60 ff ff
	ff		 mov	 DWORD PTR _cy1x1$31[ebp], edx
  00445	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _cy3x1$30[ebp]
  0044b	c1 e0 05	 shl	 eax, 5
  0044e	89 85 5c ff ff
	ff		 mov	 DWORD PTR _cy3x1$30[ebp], eax
  00454	eb 40		 jmp	 SHORT $LN33@convert_yv
$LN32@convert_yv:
  00456	33 c9		 xor	 ecx, ecx
  00458	74 3c		 je	 SHORT $LN33@convert_yv
  0045a	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x0$33[ebp]
  00460	c1 fa fb	 sar	 edx, -5			; fffffffbH
  00463	89 95 68 ff ff
	ff		 mov	 DWORD PTR _cy1x0$33[ebp], edx
  00469	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$32[ebp]
  0046f	c1 f8 fb	 sar	 eax, -5			; fffffffbH
  00472	89 85 64 ff ff
	ff		 mov	 DWORD PTR _cy3x0$32[ebp], eax
  00478	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x1$31[ebp]
  0047e	c1 f9 fb	 sar	 ecx, -5			; fffffffbH
  00481	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _cy1x1$31[ebp], ecx
  00487	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR _cy3x1$30[ebp]
  0048d	c1 fa fb	 sar	 edx, -5			; fffffffbH
  00490	89 95 5c ff ff
	ff		 mov	 DWORD PTR _cy3x1$30[ebp], edx
$LN33@convert_yv:

; 629  : 
; 630  :                     dstC[0*dst_y_pitch   + 0] = (Tout)cy1x0;

  00496	6b 45 e4 00	 imul	 eax, DWORD PTR _dst_y_pitch$[ebp], 0
  0049a	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$44[ebp]
  0049d	66 8b 95 68 ff
	ff ff		 mov	 dx, WORD PTR _cy1x0$33[ebp]
  004a4	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx

; 631  :                     dstC[0*dst_y_pitch   + 1] = (Tout)((cy1x0 + cy1x1 + 1) >> 1);

  004a8	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x1$31[ebp]
  004ae	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x0$33[ebp]
  004b4	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  004b8	d1 fa		 sar	 edx, 1
  004ba	6b 45 e4 00	 imul	 eax, DWORD PTR _dst_y_pitch$[ebp], 0
  004be	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$44[ebp]
  004c1	66 89 54 41 02	 mov	 WORD PTR [ecx+eax*2+2], dx

; 632  :                     dstC[1*dst_y_pitch   + 0] = (Tout)cy3x0;

  004c6	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  004c9	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  004cc	66 8b 8d 64 ff
	ff ff		 mov	 cx, WORD PTR _cy3x0$32[ebp]
  004d3	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx

; 633  :                     dstC[1*dst_y_pitch   + 1] = (Tout)((cy3x0 + cy3x1 + 1) >> 1);

  004d7	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR _cy3x1$30[ebp]
  004dd	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$32[ebp]
  004e3	8d 4c 10 01	 lea	 ecx, DWORD PTR [eax+edx+1]
  004e7	d1 f9		 sar	 ecx, 1
  004e9	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  004ec	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  004ef	66 89 4c 50 02	 mov	 WORD PTR [eax+edx*2+2], cx

; 634  :                 }

  004f4	e9 02 fe ff ff	 jmp	 $LN14@convert_yv
$LN15@convert_yv:

; 635  :             } else if (y >= height-2) {

  004f9	e9 66 04 00 00	 jmp	 $LN31@convert_yv
$LN30@convert_yv:
  004fe	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00501	83 e9 02	 sub	 ecx, 2
  00504	39 4d 98	 cmp	 DWORD PTR _y$45[ebp], ecx
  00507	0f 8c 2f 02 00
	00		 jl	 $LN35@convert_yv

; 636  :                 for (int x = 0; x < x_fin; x += 2, dstC += 2, srcP++) {

  0050d	c7 85 58 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _x$29[ebp], 0
  00517	eb 21		 jmp	 SHORT $LN19@convert_yv
$LN17@convert_yv:
  00519	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _x$29[ebp]
  0051f	83 c2 02	 add	 edx, 2
  00522	89 95 58 ff ff
	ff		 mov	 DWORD PTR _x$29[ebp], edx
  00528	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  0052b	83 c0 04	 add	 eax, 4
  0052e	89 45 94	 mov	 DWORD PTR _dstC$44[ebp], eax
  00531	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$43[ebp]
  00534	83 c1 02	 add	 ecx, 2
  00537	89 4d 90	 mov	 DWORD PTR _srcP$43[ebp], ecx
$LN19@convert_yv:
  0053a	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _x$29[ebp]
  00540	3b 55 8c	 cmp	 edx, DWORD PTR _x_fin$42[ebp]
  00543	0f 8d ee 01 00
	00		 jge	 $LN18@convert_yv

; 637  :                     int cxplus = (x + 2 < x_fin);

  00549	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _x$29[ebp]
  0054f	83 c0 02	 add	 eax, 2
  00552	3b 45 8c	 cmp	 eax, DWORD PTR _x_fin$42[ebp]
  00555	7d 0c		 jge	 SHORT $LN46@convert_yv
  00557	c7 85 d8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv317[ebp], 1
  00561	eb 0a		 jmp	 SHORT $LN47@convert_yv
$LN46@convert_yv:
  00563	c7 85 d8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv317[ebp], 0
$LN47@convert_yv:
  0056d	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR tv317[ebp]
  00573	89 8d 54 ff ff
	ff		 mov	 DWORD PTR _cxplus$28[ebp], ecx

; 638  :                     int cy0x0 = srcP[-1*src_uv_pitch + 0];

  00579	6b 55 a8 ff	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], -1
  0057d	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  00580	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  00584	89 8d 50 ff ff
	ff		 mov	 DWORD PTR _cy0x0$27[ebp], ecx

; 639  :                     int cy2x0 = srcP[ 0*src_uv_pitch + 0];

  0058a	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  0058e	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  00591	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  00595	89 8d 4c ff ff
	ff		 mov	 DWORD PTR _cy2x0$26[ebp], ecx

; 640  :                     int cy4x0 = srcP[ 0*src_uv_pitch + 0];

  0059b	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  0059f	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  005a2	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  005a6	89 8d 48 ff ff
	ff		 mov	 DWORD PTR _cy4x0$25[ebp], ecx

; 641  :                     int cy0x1 = srcP[-1*src_uv_pitch + cxplus];

  005ac	6b 55 a8 ff	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], -1
  005b0	03 95 54 ff ff
	ff		 add	 edx, DWORD PTR _cxplus$28[ebp]
  005b6	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  005b9	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  005bd	89 8d 44 ff ff
	ff		 mov	 DWORD PTR _cy0x1$24[ebp], ecx

; 642  :                     int cy2x1 = srcP[ 0*src_uv_pitch + cxplus];

  005c3	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  005c7	03 95 54 ff ff
	ff		 add	 edx, DWORD PTR _cxplus$28[ebp]
  005cd	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  005d0	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  005d4	89 8d 40 ff ff
	ff		 mov	 DWORD PTR _cy2x1$23[ebp], ecx

; 643  :                     int cy4x1 = srcP[ 0*src_uv_pitch + cxplus];

  005da	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  005de	03 95 54 ff ff
	ff		 add	 edx, DWORD PTR _cxplus$28[ebp]
  005e4	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  005e7	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  005eb	89 8d 3c ff ff
	ff		 mov	 DWORD PTR _cy4x1$22[ebp], ecx

; 644  : 
; 645  :                     int cy1x0 = (cy0x0 * 1 + cy2x0 * 3 + 2);

  005f1	6b 95 4c ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x0$26[ebp], 3
  005f8	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _cy0x0$27[ebp]
  005fe	8d 4c 10 02	 lea	 ecx, DWORD PTR [eax+edx+2]
  00602	89 8d 38 ff ff
	ff		 mov	 DWORD PTR _cy1x0$21[ebp], ecx

; 646  :                     int cy3x0 = (cy2x0 * 3 + cy4x0 * 1 + 2);

  00608	6b 95 4c ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x0$26[ebp], 3
  0060f	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _cy4x0$25[ebp]
  00615	8d 4c 02 02	 lea	 ecx, DWORD PTR [edx+eax+2]
  00619	89 8d 34 ff ff
	ff		 mov	 DWORD PTR _cy3x0$20[ebp], ecx

; 647  :                     int cy1x1 = (cy0x1 * 1 + cy2x1 * 3 + 2);

  0061f	6b 95 40 ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x1$23[ebp], 3
  00626	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _cy0x1$24[ebp]
  0062c	8d 4c 10 02	 lea	 ecx, DWORD PTR [eax+edx+2]
  00630	89 8d 30 ff ff
	ff		 mov	 DWORD PTR _cy1x1$19[ebp], ecx

; 648  :                     int cy3x1 = (cy2x1 * 3 + cy4x1 * 1 + 2);

  00636	6b 95 40 ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x1$23[ebp], 3
  0063d	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _cy4x1$22[ebp]
  00643	8d 4c 02 02	 lea	 ecx, DWORD PTR [edx+eax+2]
  00647	89 8d 2c ff ff
	ff		 mov	 DWORD PTR _cy3x1$18[ebp], ecx

; 649  :                     CHANGE_BIT_DEPTH_4(cy1x0, cy3x0, cy1x1, cy3x1, 2);

  0064d	ba 01 00 00 00	 mov	 edx, 1
  00652	85 d2		 test	 edx, edx
  00654	74 3e		 je	 SHORT $LN37@convert_yv
  00656	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x0$21[ebp]
  0065c	c1 e0 05	 shl	 eax, 5
  0065f	89 85 38 ff ff
	ff		 mov	 DWORD PTR _cy1x0$21[ebp], eax
  00665	8b 8d 34 ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x0$20[ebp]
  0066b	c1 e1 05	 shl	 ecx, 5
  0066e	89 8d 34 ff ff
	ff		 mov	 DWORD PTR _cy3x0$20[ebp], ecx
  00674	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x1$19[ebp]
  0067a	c1 e2 05	 shl	 edx, 5
  0067d	89 95 30 ff ff
	ff		 mov	 DWORD PTR _cy1x1$19[ebp], edx
  00683	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR _cy3x1$18[ebp]
  00689	c1 e0 05	 shl	 eax, 5
  0068c	89 85 2c ff ff
	ff		 mov	 DWORD PTR _cy3x1$18[ebp], eax
  00692	eb 40		 jmp	 SHORT $LN38@convert_yv
$LN37@convert_yv:
  00694	33 c9		 xor	 ecx, ecx
  00696	74 3c		 je	 SHORT $LN38@convert_yv
  00698	8b 95 38 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x0$21[ebp]
  0069e	c1 fa fb	 sar	 edx, -5			; fffffffbH
  006a1	89 95 38 ff ff
	ff		 mov	 DWORD PTR _cy1x0$21[ebp], edx
  006a7	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$20[ebp]
  006ad	c1 f8 fb	 sar	 eax, -5			; fffffffbH
  006b0	89 85 34 ff ff
	ff		 mov	 DWORD PTR _cy3x0$20[ebp], eax
  006b6	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x1$19[ebp]
  006bc	c1 f9 fb	 sar	 ecx, -5			; fffffffbH
  006bf	89 8d 30 ff ff
	ff		 mov	 DWORD PTR _cy1x1$19[ebp], ecx
  006c5	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR _cy3x1$18[ebp]
  006cb	c1 fa fb	 sar	 edx, -5			; fffffffbH
  006ce	89 95 2c ff ff
	ff		 mov	 DWORD PTR _cy3x1$18[ebp], edx
$LN38@convert_yv:

; 650  : 
; 651  :                     dstC[0*dst_y_pitch   + 0] = (Tout)cy1x0;

  006d4	6b 45 e4 00	 imul	 eax, DWORD PTR _dst_y_pitch$[ebp], 0
  006d8	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$44[ebp]
  006db	66 8b 95 38 ff
	ff ff		 mov	 dx, WORD PTR _cy1x0$21[ebp]
  006e2	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx

; 652  :                     dstC[0*dst_y_pitch   + 1] = (Tout)((cy1x0 + cy1x1 + 1) >> 1);

  006e6	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x1$19[ebp]
  006ec	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x0$21[ebp]
  006f2	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  006f6	d1 fa		 sar	 edx, 1
  006f8	6b 45 e4 00	 imul	 eax, DWORD PTR _dst_y_pitch$[ebp], 0
  006fc	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$44[ebp]
  006ff	66 89 54 41 02	 mov	 WORD PTR [ecx+eax*2+2], dx

; 653  :                     dstC[1*dst_y_pitch   + 0] = (Tout)cy3x0;

  00704	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  00707	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  0070a	66 8b 8d 34 ff
	ff ff		 mov	 cx, WORD PTR _cy3x0$20[ebp]
  00711	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx

; 654  :                     dstC[1*dst_y_pitch   + 1] = (Tout)((cy3x0 + cy3x1 + 1) >> 1);

  00715	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR _cy3x1$18[ebp]
  0071b	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$20[ebp]
  00721	8d 4c 10 01	 lea	 ecx, DWORD PTR [eax+edx+1]
  00725	d1 f9		 sar	 ecx, 1
  00727	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  0072a	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  0072d	66 89 4c 50 02	 mov	 WORD PTR [eax+edx*2+2], cx

; 655  :                 }

  00732	e9 e2 fd ff ff	 jmp	 $LN17@convert_yv
$LN18@convert_yv:

; 656  :             } else {

  00737	e9 28 02 00 00	 jmp	 $LN31@convert_yv
$LN35@convert_yv:

; 657  :                 for (int x = 0; x < x_fin; x += 2, dstC += 2, srcP++) {

  0073c	c7 85 28 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _x$17[ebp], 0
  00746	eb 21		 jmp	 SHORT $LN22@convert_yv
$LN20@convert_yv:
  00748	8b 8d 28 ff ff
	ff		 mov	 ecx, DWORD PTR _x$17[ebp]
  0074e	83 c1 02	 add	 ecx, 2
  00751	89 8d 28 ff ff
	ff		 mov	 DWORD PTR _x$17[ebp], ecx
  00757	8b 55 94	 mov	 edx, DWORD PTR _dstC$44[ebp]
  0075a	83 c2 04	 add	 edx, 4
  0075d	89 55 94	 mov	 DWORD PTR _dstC$44[ebp], edx
  00760	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  00763	83 c0 02	 add	 eax, 2
  00766	89 45 90	 mov	 DWORD PTR _srcP$43[ebp], eax
$LN22@convert_yv:
  00769	8b 8d 28 ff ff
	ff		 mov	 ecx, DWORD PTR _x$17[ebp]
  0076f	3b 4d 8c	 cmp	 ecx, DWORD PTR _x_fin$42[ebp]
  00772	0f 8d ec 01 00
	00		 jge	 $LN31@convert_yv

; 658  :                     int cxplus = (x + 2 < x_fin);

  00778	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR _x$17[ebp]
  0077e	83 c2 02	 add	 edx, 2
  00781	3b 55 8c	 cmp	 edx, DWORD PTR _x_fin$42[ebp]
  00784	7d 0c		 jge	 SHORT $LN48@convert_yv
  00786	c7 85 d4 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv432[ebp], 1
  00790	eb 0a		 jmp	 SHORT $LN49@convert_yv
$LN48@convert_yv:
  00792	c7 85 d4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv432[ebp], 0
$LN49@convert_yv:
  0079c	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR tv432[ebp]
  007a2	89 85 24 ff ff
	ff		 mov	 DWORD PTR _cxplus$16[ebp], eax

; 659  :                     int cy0x0 = srcP[-1*src_uv_pitch + 0];

  007a8	6b 4d a8 ff	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], -1
  007ac	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  007af	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  007b3	89 85 20 ff ff
	ff		 mov	 DWORD PTR _cy0x0$15[ebp], eax

; 660  :                     int cy2x0 = srcP[ 0*src_uv_pitch + 0];

  007b9	6b 4d a8 00	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 0
  007bd	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  007c0	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  007c4	89 85 1c ff ff
	ff		 mov	 DWORD PTR _cy2x0$14[ebp], eax

; 661  :                     int cy4x0 = srcP[ 1*src_uv_pitch + 0];

  007ca	8b 4d a8	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  007cd	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  007d0	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  007d4	89 85 18 ff ff
	ff		 mov	 DWORD PTR _cy4x0$13[ebp], eax

; 662  :                     int cy0x1 = srcP[-1*src_uv_pitch + cxplus];

  007da	6b 4d a8 ff	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], -1
  007de	03 8d 24 ff ff
	ff		 add	 ecx, DWORD PTR _cxplus$16[ebp]
  007e4	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  007e7	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  007eb	89 85 14 ff ff
	ff		 mov	 DWORD PTR _cy0x1$12[ebp], eax

; 663  :                     int cy2x1 = srcP[ 0*src_uv_pitch + cxplus];

  007f1	6b 4d a8 00	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 0
  007f5	03 8d 24 ff ff
	ff		 add	 ecx, DWORD PTR _cxplus$16[ebp]
  007fb	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  007fe	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00802	89 85 10 ff ff
	ff		 mov	 DWORD PTR _cy2x1$11[ebp], eax

; 664  :                     int cy4x1 = srcP[ 1*src_uv_pitch + cxplus];

  00808	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR _cxplus$16[ebp]
  0080e	03 4d a8	 add	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00811	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  00814	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00818	89 85 0c ff ff
	ff		 mov	 DWORD PTR _cy4x1$10[ebp], eax

; 665  : 
; 666  :                     int cy1x0 = (cy0x0 * 1 + cy2x0 * 3 + 2);

  0081e	6b 8d 1c ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy2x0$14[ebp], 3
  00825	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR _cy0x0$15[ebp]
  0082b	8d 44 0a 02	 lea	 eax, DWORD PTR [edx+ecx+2]
  0082f	89 85 08 ff ff
	ff		 mov	 DWORD PTR _cy1x0$9[ebp], eax

; 667  :                     int cy3x0 = (cy2x0 * 3 + cy4x0 * 1 + 2);

  00835	6b 8d 1c ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy2x0$14[ebp], 3
  0083c	8b 95 18 ff ff
	ff		 mov	 edx, DWORD PTR _cy4x0$13[ebp]
  00842	8d 44 11 02	 lea	 eax, DWORD PTR [ecx+edx+2]
  00846	89 85 04 ff ff
	ff		 mov	 DWORD PTR _cy3x0$8[ebp], eax

; 668  :                     int cy1x1 = (cy0x1 * 1 + cy2x1 * 3 + 2);

  0084c	6b 8d 10 ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy2x1$11[ebp], 3
  00853	8b 95 14 ff ff
	ff		 mov	 edx, DWORD PTR _cy0x1$12[ebp]
  00859	8d 44 0a 02	 lea	 eax, DWORD PTR [edx+ecx+2]
  0085d	89 85 00 ff ff
	ff		 mov	 DWORD PTR _cy1x1$7[ebp], eax

; 669  :                     int cy3x1 = (cy2x1 * 3 + cy4x1 * 1 + 2);

  00863	6b 8d 10 ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy2x1$11[ebp], 3
  0086a	8b 95 0c ff ff
	ff		 mov	 edx, DWORD PTR _cy4x1$10[ebp]
  00870	8d 44 11 02	 lea	 eax, DWORD PTR [ecx+edx+2]
  00874	89 85 fc fe ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], eax

; 670  :                     CHANGE_BIT_DEPTH_4(cy1x0, cy3x0, cy1x1, cy3x1, 2);

  0087a	b9 01 00 00 00	 mov	 ecx, 1
  0087f	85 c9		 test	 ecx, ecx
  00881	74 3e		 je	 SHORT $LN40@convert_yv
  00883	8b 95 08 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x0$9[ebp]
  00889	c1 e2 05	 shl	 edx, 5
  0088c	89 95 08 ff ff
	ff		 mov	 DWORD PTR _cy1x0$9[ebp], edx
  00892	8b 85 04 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$8[ebp]
  00898	c1 e0 05	 shl	 eax, 5
  0089b	89 85 04 ff ff
	ff		 mov	 DWORD PTR _cy3x0$8[ebp], eax
  008a1	8b 8d 00 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x1$7[ebp]
  008a7	c1 e1 05	 shl	 ecx, 5
  008aa	89 8d 00 ff ff
	ff		 mov	 DWORD PTR _cy1x1$7[ebp], ecx
  008b0	8b 95 fc fe ff
	ff		 mov	 edx, DWORD PTR _cy3x1$6[ebp]
  008b6	c1 e2 05	 shl	 edx, 5
  008b9	89 95 fc fe ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], edx
  008bf	eb 40		 jmp	 SHORT $LN41@convert_yv
$LN40@convert_yv:
  008c1	33 c0		 xor	 eax, eax
  008c3	74 3c		 je	 SHORT $LN41@convert_yv
  008c5	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x0$9[ebp]
  008cb	c1 f9 fb	 sar	 ecx, -5			; fffffffbH
  008ce	89 8d 08 ff ff
	ff		 mov	 DWORD PTR _cy1x0$9[ebp], ecx
  008d4	8b 95 04 ff ff
	ff		 mov	 edx, DWORD PTR _cy3x0$8[ebp]
  008da	c1 fa fb	 sar	 edx, -5			; fffffffbH
  008dd	89 95 04 ff ff
	ff		 mov	 DWORD PTR _cy3x0$8[ebp], edx
  008e3	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x1$7[ebp]
  008e9	c1 f8 fb	 sar	 eax, -5			; fffffffbH
  008ec	89 85 00 ff ff
	ff		 mov	 DWORD PTR _cy1x1$7[ebp], eax
  008f2	8b 8d fc fe ff
	ff		 mov	 ecx, DWORD PTR _cy3x1$6[ebp]
  008f8	c1 f9 fb	 sar	 ecx, -5			; fffffffbH
  008fb	89 8d fc fe ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], ecx
$LN41@convert_yv:

; 671  : 
; 672  :                     dstC[0*dst_y_pitch   + 0] = (Tout)cy1x0;

  00901	6b 55 e4 00	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 0
  00905	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  00908	66 8b 8d 08 ff
	ff ff		 mov	 cx, WORD PTR _cy1x0$9[ebp]
  0090f	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx

; 673  :                     dstC[0*dst_y_pitch   + 1] = (Tout)((cy1x0 + cy1x1 + 1) >> 1);

  00913	8b 95 00 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x1$7[ebp]
  00919	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x0$9[ebp]
  0091f	8d 4c 10 01	 lea	 ecx, DWORD PTR [eax+edx+1]
  00923	d1 f9		 sar	 ecx, 1
  00925	6b 55 e4 00	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 0
  00929	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  0092c	66 89 4c 50 02	 mov	 WORD PTR [eax+edx*2+2], cx

; 674  :                     dstC[1*dst_y_pitch   + 0] = (Tout)cy3x0;

  00931	8b 4d e4	 mov	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  00934	8b 55 94	 mov	 edx, DWORD PTR _dstC$44[ebp]
  00937	66 8b 85 04 ff
	ff ff		 mov	 ax, WORD PTR _cy3x0$8[ebp]
  0093e	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax

; 675  :                     dstC[1*dst_y_pitch   + 1] = (Tout)((cy3x0 + cy3x1 + 1) >> 1);

  00942	8b 8d fc fe ff
	ff		 mov	 ecx, DWORD PTR _cy3x1$6[ebp]
  00948	8b 95 04 ff ff
	ff		 mov	 edx, DWORD PTR _cy3x0$8[ebp]
  0094e	8d 44 0a 01	 lea	 eax, DWORD PTR [edx+ecx+1]
  00952	d1 f8		 sar	 eax, 1
  00954	8b 4d e4	 mov	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  00957	8b 55 94	 mov	 edx, DWORD PTR _dstC$44[ebp]
  0095a	66 89 44 4a 02	 mov	 WORD PTR [edx+ecx*2+2], ax

; 676  :                 }

  0095f	e9 e4 fd ff ff	 jmp	 $LN20@convert_yv
$LN31@convert_yv:

; 677  :             }
; 678  :         }

  00964	e9 38 f9 ff ff	 jmp	 $LN11@convert_yv
$LN12@convert_yv:

; 679  :     }

  00969	e9 e6 f8 ff ff	 jmp	 $LN8@convert_yv
$LN1@convert_yv:

; 680  : }

  0096e	52		 push	 edx
  0096f	8b cd		 mov	 ecx, ebp
  00971	50		 push	 eax
  00972	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN52@convert_yv
  00978	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0097d	58		 pop	 eax
  0097e	5a		 pop	 edx
  0097f	5f		 pop	 edi
  00980	5e		 pop	 esi
  00981	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00984	33 cd		 xor	 ecx, ebp
  00986	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0098b	81 c4 2c 01 00
	00		 add	 esp, 300		; 0000012cH
  00991	3b ec		 cmp	 ebp, esp
  00993	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00998	8b e5		 mov	 esp, ebp
  0099a	5d		 pop	 ebp
  0099b	c3		 ret	 0
$LN52@convert_yv:
  0099c	01 00 00 00	 DD	 1
  009a0	00 00 00 00	 DD	 $LN51@convert_yv
$LN51@convert_yv:
  009a4	d4 ff ff ff	 DD	 -44			; ffffffd4H
  009a8	0c 00 00 00	 DD	 12			; 0000000cH
  009ac	00 00 00 00	 DD	 $LN50@convert_yv
$LN50@convert_yv:
  009b0	79		 DB	 121			; 00000079H
  009b1	5f		 DB	 95			; 0000005fH
  009b2	72		 DB	 114			; 00000072H
  009b3	61		 DB	 97			; 00000061H
  009b4	6e		 DB	 110			; 0000006eH
  009b5	67		 DB	 103			; 00000067H
  009b6	65		 DB	 101			; 00000065H
  009b7	00		 DB	 0
??$convert_yv12_p_to_yuv444_c@G$08G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_p_to_yuv444_c<unsigned short,9,unsigned short,16,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yv12_09_p_to_yuv444_16bit@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_09_p_to_yuv444_16bit

; 865  : static void convert_yv12_09_p_to_yuv444_16bit(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 866  :     convert_yv12_p_to_yuv444_c<uint16_t, 9, uint16_t, 16, false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yv12_p_to_yuv444_c@G$08G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_p_to_yuv444_c<unsigned short,9,unsigned short,16,0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 867  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yv12_09_p_to_yuv444_16bit@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_09_p_to_yuv444_16bit
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
tv302 = -280						; size = 4
tv240 = -276						; size = 4
tv241 = -272						; size = 4
tv235 = -268						; size = 4
tv232 = -264						; size = 4
tv229 = -260						; size = 4
tv227 = -256						; size = 4
$T1 = -252						; size = 4
$T2 = -248						; size = 4
$T3 = -244						; size = 4
$T4 = -240						; size = 4
$T5 = -236						; size = 12
_cy3x1$6 = -224						; size = 4
_cy2x1$7 = -220						; size = 4
_cy1x1$8 = -216						; size = 4
_cy0x1$9 = -212						; size = 4
_sy5x1$10 = -208					; size = 4
_sy4x1$11 = -204					; size = 4
_sy3x1$12 = -200					; size = 4
_sy2x1$13 = -196					; size = 4
_sy1x1$14 = -192					; size = 4
_sy0x1$15 = -188					; size = 4
_cxplus$16 = -184					; size = 4
_x$17 = -180						; size = 4
_cy3x0$18 = -176					; size = 4
_cy2x0$19 = -172					; size = 4
_cy1x0$20 = -168					; size = 4
_cy0x0$21 = -164					; size = 4
_sy5x0$22 = -160					; size = 4
_sy4x0$23 = -156					; size = 4
_sy3x0$24 = -152					; size = 4
_sy2x0$25 = -148					; size = 4
_sy1x0$26 = -144					; size = 4
_sy0x0$27 = -140					; size = 4
_y_p3$28 = -136						; size = 4
_y_p2$29 = -132						; size = 4
_y_p1$30 = -128						; size = 4
_y_m1$31 = -124						; size = 4
_y_m2$32 = -120						; size = 4
_x_fin$33 = -116					; size = 4
_srcP$34 = -112						; size = 4
_dstC$35 = -108						; size = 4
_y$36 = -104						; size = 4
_dstLine$37 = -100					; size = 4
_srcCLine$38 = -96					; size = 4
_ic$39 = -92						; size = 4
_src_uv_pitch$ = -88					; size = 4
_uv_fin$ = -84						; size = 4
_x$40 = -80						; size = 4
_y$41 = -76						; size = 4
_y_width$42 = -72					; size = 4
_dstLine$43 = -68					; size = 4
_srcYLine$44 = -64					; size = 4
$T45 = -60						; size = 12
_y_range$ = -44						; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yv12_i_to_yuv444_c@G$09G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_i_to_yuv444_c<unsigned short,10,unsigned short,16,0>

; 683  : static void __forceinline convert_yv12_i_to_yuv444_c(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8d bd e8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-280]
  00011	b9 46 00 00 00	 mov	 ecx, 70			; 00000046H
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 684  :     static_assert((sizeof(Tin)  == 1 && in_bit_depth  == 8) || (sizeof(Tin)  == 2 && 8 < in_bit_depth  && in_bit_depth  <= 16), "invalid input bit depth.");
; 685  :     static_assert((sizeof(Tout) == 1 && out_bit_depth == 8) || (sizeof(Tout) == 2 && 8 < out_bit_depth && out_bit_depth <= 16), "invalid output bit depth.");
; 686  :     const int crop_left   = crop[0];

  00027	b8 04 00 00 00	 mov	 eax, 4
  0002c	6b c8 00	 imul	 ecx, eax, 0
  0002f	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00032	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00035	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 687  :     const int crop_up     = crop[1];

  00038	b9 04 00 00 00	 mov	 ecx, 4
  0003d	c1 e1 00	 shl	 ecx, 0
  00040	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00043	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00046	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 688  :     const int crop_right  = crop[2];

  00049	b9 04 00 00 00	 mov	 ecx, 4
  0004e	d1 e1		 shl	 ecx, 1
  00050	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00053	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00056	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 689  :     const int crop_bottom = crop[3];

  00059	b9 04 00 00 00	 mov	 ecx, 4
  0005e	6b d1 03	 imul	 edx, ecx, 3
  00061	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00064	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00067	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 690  :     const int src_y_pitch = src_y_pitch_byte / sizeof(Tin);

  0006a	8b 55 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebp]
  0006d	d1 ea		 shr	 edx, 1
  0006f	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 691  :     const int dst_y_pitch = dst_y_pitch_byte / sizeof(Tout);

  00072	8b 45 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  00075	d1 e8		 shr	 eax, 1
  00077	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 692  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  0007a	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0007d	51		 push	 ecx
  0007e	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  00081	52		 push	 edx
  00082	8b 45 20	 mov	 eax, DWORD PTR _height$[ebp]
  00085	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  00088	50		 push	 eax
  00089	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  0008c	51		 push	 ecx
  0008d	8d 95 14 ff ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  00093	52		 push	 edx
  00094	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00099	83 c4 14	 add	 esp, 20			; 00000014H
  0009c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009e	89 4d c4	 mov	 DWORD PTR $T45[ebp], ecx
  000a1	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a4	89 55 c8	 mov	 DWORD PTR $T45[ebp+4], edx
  000a7	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000aa	89 45 cc	 mov	 DWORD PTR $T45[ebp+8], eax
  000ad	8b 4d c4	 mov	 ecx, DWORD PTR $T45[ebp]
  000b0	89 4d d4	 mov	 DWORD PTR _y_range$[ebp], ecx
  000b3	8b 55 c8	 mov	 edx, DWORD PTR $T45[ebp+4]
  000b6	89 55 d8	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000b9	8b 45 cc	 mov	 eax, DWORD PTR $T45[ebp+8]
  000bc	89 45 dc	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 693  :     //Y
; 694  :     if (!uv_only) {

  000bf	b9 01 00 00 00	 mov	 ecx, 1
  000c4	85 c9		 test	 ecx, ecx
  000c6	0f 84 6e 01 00
	00		 je	 $LN17@convert_yv

; 695  :         Tin *srcYLine = (Tin *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000cc	ba 04 00 00 00	 mov	 edx, 4
  000d1	6b c2 00	 imul	 eax, edx, 0
  000d4	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  000d7	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  000db	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  000de	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  000e1	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  000e4	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  000e7	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  000ea	89 45 c0	 mov	 DWORD PTR _srcYLine$44[ebp], eax

; 696  :         Tout *dstLine = (Tout *)dst[0] + dst_y_pitch * y_range.start_dst;

  000ed	b9 04 00 00 00	 mov	 ecx, 4
  000f2	6b d1 00	 imul	 edx, ecx, 0
  000f5	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  000f8	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  000fc	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  000ff	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  00102	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  00105	89 45 bc	 mov	 DWORD PTR _dstLine$43[ebp], eax

; 697  :         const int y_width = width - crop_right - crop_left;

  00108	8b 4d 10	 mov	 ecx, DWORD PTR _width$[ebp]
  0010b	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  0010e	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  00111	89 4d b8	 mov	 DWORD PTR _y_width$42[ebp], ecx

; 698  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  00114	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _y$41[ebp], 0
  0011b	eb 21		 jmp	 SHORT $LN4@convert_yv
$LN2@convert_yv:
  0011d	8b 55 b4	 mov	 edx, DWORD PTR _y$41[ebp]
  00120	83 c2 01	 add	 edx, 1
  00123	89 55 b4	 mov	 DWORD PTR _y$41[ebp], edx
  00126	8b 45 e8	 mov	 eax, DWORD PTR _src_y_pitch$[ebp]
  00129	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$44[ebp]
  0012c	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  0012f	89 55 c0	 mov	 DWORD PTR _srcYLine$44[ebp], edx
  00132	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  00135	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$43[ebp]
  00138	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  0013b	89 55 bc	 mov	 DWORD PTR _dstLine$43[ebp], edx
$LN4@convert_yv:
  0013e	8b 45 b4	 mov	 eax, DWORD PTR _y$41[ebp]
  00141	3b 45 dc	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  00144	0f 8d f0 00 00
	00		 jge	 $LN17@convert_yv

; 699  :             if (in_bit_depth == out_bit_depth) {

  0014a	33 c9		 xor	 ecx, ecx
  0014c	74 1b		 je	 SHORT $LN18@convert_yv

; 700  :                 memcpy(dstLine, srcYLine, y_width * sizeof(Tin));

  0014e	8b 55 b8	 mov	 edx, DWORD PTR _y_width$42[ebp]
  00151	d1 e2		 shl	 edx, 1
  00153	52		 push	 edx
  00154	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$44[ebp]
  00157	50		 push	 eax
  00158	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$43[ebp]
  0015b	51		 push	 ecx
  0015c	e8 00 00 00 00	 call	 _memcpy
  00161	83 c4 0c	 add	 esp, 12			; 0000000cH

; 701  :             } else {

  00164	e9 cc 00 00 00	 jmp	 $LN19@convert_yv
$LN18@convert_yv:

; 702  :                 for (int x = 0; x < y_width; x++) {

  00169	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _x$40[ebp], 0
  00170	eb 09		 jmp	 SHORT $LN7@convert_yv
$LN5@convert_yv:
  00172	8b 55 b0	 mov	 edx, DWORD PTR _x$40[ebp]
  00175	83 c2 01	 add	 edx, 1
  00178	89 55 b0	 mov	 DWORD PTR _x$40[ebp], edx
$LN7@convert_yv:
  0017b	8b 45 b0	 mov	 eax, DWORD PTR _x$40[ebp]
  0017e	3b 45 b8	 cmp	 eax, DWORD PTR _y_width$42[ebp]
  00181	0f 8d ae 00 00
	00		 jge	 $LN19@convert_yv

; 703  :                     if (out_bit_depth > in_bit_depth) {

  00187	b9 01 00 00 00	 mov	 ecx, 1
  0018c	85 c9		 test	 ecx, ecx
  0018e	74 44		 je	 SHORT $LN20@convert_yv

; 704  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) << std::max(out_bit_depth - in_bit_depth, 0));

  00190	c7 85 10 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], 0
  0019a	c7 85 0c ff ff
	ff 06 00 00 00	 mov	 DWORD PTR $T3[ebp], 6
  001a4	8b 55 b0	 mov	 edx, DWORD PTR _x$40[ebp]
  001a7	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$44[ebp]
  001aa	0f b7 34 50	 movzx	 esi, WORD PTR [eax+edx*2]
  001ae	8d 8d 10 ff ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  001b4	51		 push	 ecx
  001b5	8d 95 0c ff ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  001bb	52		 push	 edx
  001bc	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  001c1	83 c4 08	 add	 esp, 8
  001c4	8b 08		 mov	 ecx, DWORD PTR [eax]
  001c6	d3 e6		 shl	 esi, cl
  001c8	8b 45 b0	 mov	 eax, DWORD PTR _x$40[ebp]
  001cb	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$43[ebp]
  001ce	66 89 34 41	 mov	 WORD PTR [ecx+eax*2], si
  001d2	eb 5c		 jmp	 SHORT $LN21@convert_yv
$LN20@convert_yv:

; 705  :                     } else if (out_bit_depth < in_bit_depth) {

  001d4	33 d2		 xor	 edx, edx
  001d6	74 44		 je	 SHORT $LN22@convert_yv

; 706  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) >> std::max(in_bit_depth - out_bit_depth, 0));

  001d8	c7 85 08 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], 0
  001e2	c7 85 04 ff ff
	ff fa ff ff ff	 mov	 DWORD PTR $T1[ebp], -6	; fffffffaH
  001ec	8b 45 b0	 mov	 eax, DWORD PTR _x$40[ebp]
  001ef	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$44[ebp]
  001f2	0f b7 34 41	 movzx	 esi, WORD PTR [ecx+eax*2]
  001f6	8d 95 08 ff ff
	ff		 lea	 edx, DWORD PTR $T2[ebp]
  001fc	52		 push	 edx
  001fd	8d 85 04 ff ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  00203	50		 push	 eax
  00204	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  00209	83 c4 08	 add	 esp, 8
  0020c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0020e	d3 fe		 sar	 esi, cl
  00210	8b 4d b0	 mov	 ecx, DWORD PTR _x$40[ebp]
  00213	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$43[ebp]
  00216	66 89 34 4a	 mov	 WORD PTR [edx+ecx*2], si

; 707  :                     } else {

  0021a	eb 14		 jmp	 SHORT $LN21@convert_yv
$LN22@convert_yv:

; 708  :                         dstLine[x] = (Tout)srcYLine[x];

  0021c	8b 45 b0	 mov	 eax, DWORD PTR _x$40[ebp]
  0021f	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$43[ebp]
  00222	8b 55 b0	 mov	 edx, DWORD PTR _x$40[ebp]
  00225	8b 75 c0	 mov	 esi, DWORD PTR _srcYLine$44[ebp]
  00228	66 8b 14 56	 mov	 dx, WORD PTR [esi+edx*2]
  0022c	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx
$LN21@convert_yv:

; 709  :                     }
; 710  :                 }

  00230	e9 3d ff ff ff	 jmp	 $LN5@convert_yv
$LN19@convert_yv:

; 711  :             }
; 712  :         }

  00235	e9 e3 fe ff ff	 jmp	 $LN2@convert_yv
$LN17@convert_yv:

; 713  :     }
; 714  :     //UV
; 715  :     const int uv_fin = height - crop_bottom;

  0023a	8b 45 20	 mov	 eax, DWORD PTR _height$[ebp]
  0023d	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  00240	89 45 ac	 mov	 DWORD PTR _uv_fin$[ebp], eax

; 716  :     const int src_uv_pitch = src_uv_pitch_byte / sizeof(Tin);

  00243	8b 4d 18	 mov	 ecx, DWORD PTR _src_uv_pitch_byte$[ebp]
  00246	d1 e9		 shr	 ecx, 1
  00248	89 4d a8	 mov	 DWORD PTR _src_uv_pitch$[ebp], ecx

; 717  :     for (int ic = 1; ic < 3; ic++) {

  0024b	c7 45 a4 01 00
	00 00		 mov	 DWORD PTR _ic$39[ebp], 1
  00252	eb 09		 jmp	 SHORT $LN10@convert_yv
$LN8@convert_yv:
  00254	8b 55 a4	 mov	 edx, DWORD PTR _ic$39[ebp]
  00257	83 c2 01	 add	 edx, 1
  0025a	89 55 a4	 mov	 DWORD PTR _ic$39[ebp], edx
$LN10@convert_yv:
  0025d	83 7d a4 03	 cmp	 DWORD PTR _ic$39[ebp], 3
  00261	0f 8d c4 05 00
	00		 jge	 $LN1@convert_yv

; 718  :         Tin *srcCLine = (Tin *)src[ic] + (((src_uv_pitch * y_range.start_src) + crop_left) >> 1);

  00267	8b 45 a8	 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  0026a	0f af 45 d4	 imul	 eax, DWORD PTR _y_range$[ebp]
  0026e	03 45 f8	 add	 eax, DWORD PTR _crop_left$[ebp]
  00271	d1 f8		 sar	 eax, 1
  00273	8b 4d a4	 mov	 ecx, DWORD PTR _ic$39[ebp]
  00276	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  00279	8b 0c 8a	 mov	 ecx, DWORD PTR [edx+ecx*4]
  0027c	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  0027f	89 55 a0	 mov	 DWORD PTR _srcCLine$38[ebp], edx

; 719  :         Tout *dstLine = (Tout *)dst[ic] + dst_y_pitch * y_range.start_dst;

  00282	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  00285	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  00289	8b 4d a4	 mov	 ecx, DWORD PTR _ic$39[ebp]
  0028c	8b 55 08	 mov	 edx, DWORD PTR _dst$[ebp]
  0028f	8b 0c 8a	 mov	 ecx, DWORD PTR [edx+ecx*4]
  00292	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00295	89 55 9c	 mov	 DWORD PTR _dstLine$37[ebp], edx

; 720  :         for (int y = 0; y < y_range.len; y += 4, srcCLine += src_uv_pitch * 2, dstLine += dst_y_pitch * 4) {

  00298	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _y$36[ebp], 0
  0029f	eb 26		 jmp	 SHORT $LN13@convert_yv
$LN11@convert_yv:
  002a1	8b 45 98	 mov	 eax, DWORD PTR _y$36[ebp]
  002a4	83 c0 04	 add	 eax, 4
  002a7	89 45 98	 mov	 DWORD PTR _y$36[ebp], eax
  002aa	8b 4d a8	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  002ad	d1 e1		 shl	 ecx, 1
  002af	8b 55 a0	 mov	 edx, DWORD PTR _srcCLine$38[ebp]
  002b2	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  002b5	89 45 a0	 mov	 DWORD PTR _srcCLine$38[ebp], eax
  002b8	8b 4d e4	 mov	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  002bb	c1 e1 02	 shl	 ecx, 2
  002be	8b 55 9c	 mov	 edx, DWORD PTR _dstLine$37[ebp]
  002c1	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  002c4	89 45 9c	 mov	 DWORD PTR _dstLine$37[ebp], eax
$LN13@convert_yv:
  002c7	8b 4d 98	 mov	 ecx, DWORD PTR _y$36[ebp]
  002ca	3b 4d dc	 cmp	 ecx, DWORD PTR _y_range$[ebp+8]
  002cd	0f 8d 53 05 00
	00		 jge	 $LN12@convert_yv

; 721  :             Tout *dstC = dstLine;

  002d3	8b 55 9c	 mov	 edx, DWORD PTR _dstLine$37[ebp]
  002d6	89 55 94	 mov	 DWORD PTR _dstC$35[ebp], edx

; 722  :             Tin *srcP = srcCLine;

  002d9	8b 45 a0	 mov	 eax, DWORD PTR _srcCLine$38[ebp]
  002dc	89 45 90	 mov	 DWORD PTR _srcP$34[ebp], eax

; 723  :             const int x_fin = width - crop_right - crop_left;

  002df	8b 4d 10	 mov	 ecx, DWORD PTR _width$[ebp]
  002e2	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  002e5	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  002e8	89 4d 8c	 mov	 DWORD PTR _x_fin$33[ebp], ecx

; 724  : 
; 725  :             int y_m2 = (y >= 4) ? -2 : 0;

  002eb	83 7d 98 04	 cmp	 DWORD PTR _y$36[ebp], 4
  002ef	7c 0c		 jl	 SHORT $LN31@convert_yv
  002f1	c7 85 00 ff ff
	ff fe ff ff ff	 mov	 DWORD PTR tv227[ebp], -2 ; fffffffeH
  002fb	eb 0a		 jmp	 SHORT $LN32@convert_yv
$LN31@convert_yv:
  002fd	c7 85 00 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv227[ebp], 0
$LN32@convert_yv:
  00307	8b 95 00 ff ff
	ff		 mov	 edx, DWORD PTR tv227[ebp]
  0030d	89 55 88	 mov	 DWORD PTR _y_m2$32[ebp], edx

; 726  :             int y_m1 = (y >= 2) ? -1 : 1;

  00310	83 7d 98 02	 cmp	 DWORD PTR _y$36[ebp], 2
  00314	7c 0c		 jl	 SHORT $LN33@convert_yv
  00316	c7 85 fc fe ff
	ff ff ff ff ff	 mov	 DWORD PTR tv229[ebp], -1
  00320	eb 0a		 jmp	 SHORT $LN34@convert_yv
$LN33@convert_yv:
  00322	c7 85 fc fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv229[ebp], 1
$LN34@convert_yv:
  0032c	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR tv229[ebp]
  00332	89 45 84	 mov	 DWORD PTR _y_m1$31[ebp], eax

; 727  :             int y_p1 = (y < uv_fin - 2) ? 1 : -1;

  00335	8b 4d ac	 mov	 ecx, DWORD PTR _uv_fin$[ebp]
  00338	83 e9 02	 sub	 ecx, 2
  0033b	39 4d 98	 cmp	 DWORD PTR _y$36[ebp], ecx
  0033e	7d 0c		 jge	 SHORT $LN35@convert_yv
  00340	c7 85 f8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv232[ebp], 1
  0034a	eb 0a		 jmp	 SHORT $LN36@convert_yv
$LN35@convert_yv:
  0034c	c7 85 f8 fe ff
	ff ff ff ff ff	 mov	 DWORD PTR tv232[ebp], -1
$LN36@convert_yv:
  00356	8b 95 f8 fe ff
	ff		 mov	 edx, DWORD PTR tv232[ebp]
  0035c	89 55 80	 mov	 DWORD PTR _y_p1$30[ebp], edx

; 728  :             int y_p2 = (y < uv_fin - 4) ? 2 :  0;

  0035f	8b 45 ac	 mov	 eax, DWORD PTR _uv_fin$[ebp]
  00362	83 e8 04	 sub	 eax, 4
  00365	39 45 98	 cmp	 DWORD PTR _y$36[ebp], eax
  00368	7d 0c		 jge	 SHORT $LN37@convert_yv
  0036a	c7 85 f4 fe ff
	ff 02 00 00 00	 mov	 DWORD PTR tv235[ebp], 2
  00374	eb 0a		 jmp	 SHORT $LN38@convert_yv
$LN37@convert_yv:
  00376	c7 85 f4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv235[ebp], 0
$LN38@convert_yv:
  00380	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR tv235[ebp]
  00386	89 8d 7c ff ff
	ff		 mov	 DWORD PTR _y_p2$29[ebp], ecx

; 729  :             int y_p3 = (y < uv_fin - 6) ? 3 : ((y < uv_fin - 2) ? 1 : -1);

  0038c	8b 55 ac	 mov	 edx, DWORD PTR _uv_fin$[ebp]
  0038f	83 ea 06	 sub	 edx, 6
  00392	39 55 98	 cmp	 DWORD PTR _y$36[ebp], edx
  00395	7d 0c		 jge	 SHORT $LN41@convert_yv
  00397	c7 85 f0 fe ff
	ff 03 00 00 00	 mov	 DWORD PTR tv241[ebp], 3
  003a1	eb 2d		 jmp	 SHORT $LN42@convert_yv
$LN41@convert_yv:
  003a3	8b 45 ac	 mov	 eax, DWORD PTR _uv_fin$[ebp]
  003a6	83 e8 02	 sub	 eax, 2
  003a9	39 45 98	 cmp	 DWORD PTR _y$36[ebp], eax
  003ac	7d 0c		 jge	 SHORT $LN39@convert_yv
  003ae	c7 85 ec fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv240[ebp], 1
  003b8	eb 0a		 jmp	 SHORT $LN40@convert_yv
$LN39@convert_yv:
  003ba	c7 85 ec fe ff
	ff ff ff ff ff	 mov	 DWORD PTR tv240[ebp], -1
$LN40@convert_yv:
  003c4	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR tv240[ebp]
  003ca	89 8d f0 fe ff
	ff		 mov	 DWORD PTR tv241[ebp], ecx
$LN42@convert_yv:
  003d0	8b 95 f0 fe ff
	ff		 mov	 edx, DWORD PTR tv241[ebp]
  003d6	89 95 78 ff ff
	ff		 mov	 DWORD PTR _y_p3$28[ebp], edx

; 730  : 
; 731  :             int sy0x0 = srcP[y_m2*src_uv_pitch + 0];

  003dc	8b 45 88	 mov	 eax, DWORD PTR _y_m2$32[ebp]
  003df	0f af 45 a8	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp]
  003e3	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  003e6	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  003ea	89 95 74 ff ff
	ff		 mov	 DWORD PTR _sy0x0$27[ebp], edx

; 732  :             int sy1x0 = srcP[y_m1*src_uv_pitch + 0];

  003f0	8b 45 84	 mov	 eax, DWORD PTR _y_m1$31[ebp]
  003f3	0f af 45 a8	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp]
  003f7	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  003fa	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  003fe	89 95 70 ff ff
	ff		 mov	 DWORD PTR _sy1x0$26[ebp], edx

; 733  :             int sy2x0 = srcP[   0*src_uv_pitch + 0];

  00404	6b 45 a8 00	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp], 0
  00408	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  0040b	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  0040f	89 95 6c ff ff
	ff		 mov	 DWORD PTR _sy2x0$25[ebp], edx

; 734  :             int sy3x0 = srcP[y_p1*src_uv_pitch + 0];

  00415	8b 45 80	 mov	 eax, DWORD PTR _y_p1$30[ebp]
  00418	0f af 45 a8	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp]
  0041c	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  0041f	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  00423	89 95 68 ff ff
	ff		 mov	 DWORD PTR _sy3x0$24[ebp], edx

; 735  :             int sy4x0 = srcP[y_p2*src_uv_pitch + 0];

  00429	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _y_p2$29[ebp]
  0042f	0f af 45 a8	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp]
  00433	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  00436	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  0043a	89 95 64 ff ff
	ff		 mov	 DWORD PTR _sy4x0$23[ebp], edx

; 736  :             int sy5x0 = srcP[y_p3*src_uv_pitch + 0];

  00440	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _y_p3$28[ebp]
  00446	0f af 45 a8	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp]
  0044a	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  0044d	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  00451	89 95 60 ff ff
	ff		 mov	 DWORD PTR _sy5x0$22[ebp], edx

; 737  : 
; 738  :             int cy0x0 = (sy0x0 * 1 + sy2x0 * 7 + 4);

  00457	6b 85 6c ff ff
	ff 07		 imul	 eax, DWORD PTR _sy2x0$25[ebp], 7
  0045e	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _sy0x0$27[ebp]
  00464	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00468	89 95 5c ff ff
	ff		 mov	 DWORD PTR _cy0x0$21[ebp], edx

; 739  :             int cy1x0 = (sy1x0 * 3 + sy3x0 * 5 + 4);

  0046e	6b 85 70 ff ff
	ff 03		 imul	 eax, DWORD PTR _sy1x0$26[ebp], 3
  00475	6b 8d 68 ff ff
	ff 05		 imul	 ecx, DWORD PTR _sy3x0$24[ebp], 5
  0047c	8d 54 08 04	 lea	 edx, DWORD PTR [eax+ecx+4]
  00480	89 95 58 ff ff
	ff		 mov	 DWORD PTR _cy1x0$20[ebp], edx

; 740  :             int cy2x0 = (sy2x0 * 5 + sy4x0 * 3 + 4);

  00486	6b 85 6c ff ff
	ff 05		 imul	 eax, DWORD PTR _sy2x0$25[ebp], 5
  0048d	6b 8d 64 ff ff
	ff 03		 imul	 ecx, DWORD PTR _sy4x0$23[ebp], 3
  00494	8d 54 08 04	 lea	 edx, DWORD PTR [eax+ecx+4]
  00498	89 95 54 ff ff
	ff		 mov	 DWORD PTR _cy2x0$19[ebp], edx

; 741  :             int cy3x0 = (sy3x0 * 7 + sy5x0 * 1 + 4);

  0049e	6b 85 68 ff ff
	ff 07		 imul	 eax, DWORD PTR _sy3x0$24[ebp], 7
  004a5	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _sy5x0$22[ebp]
  004ab	8d 54 08 04	 lea	 edx, DWORD PTR [eax+ecx+4]
  004af	89 95 50 ff ff
	ff		 mov	 DWORD PTR _cy3x0$18[ebp], edx

; 742  :             CHANGE_BIT_DEPTH_4(cy0x0, cy1x0, cy2x0, cy3x0, 3);

  004b5	b8 01 00 00 00	 mov	 eax, 1
  004ba	85 c0		 test	 eax, eax
  004bc	74 3e		 je	 SHORT $LN24@convert_yv
  004be	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _cy0x0$21[ebp]
  004c4	c1 e1 03	 shl	 ecx, 3
  004c7	89 8d 5c ff ff
	ff		 mov	 DWORD PTR _cy0x0$21[ebp], ecx
  004cd	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x0$20[ebp]
  004d3	c1 e2 03	 shl	 edx, 3
  004d6	89 95 58 ff ff
	ff		 mov	 DWORD PTR _cy1x0$20[ebp], edx
  004dc	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR _cy2x0$19[ebp]
  004e2	c1 e0 03	 shl	 eax, 3
  004e5	89 85 54 ff ff
	ff		 mov	 DWORD PTR _cy2x0$19[ebp], eax
  004eb	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x0$18[ebp]
  004f1	c1 e1 03	 shl	 ecx, 3
  004f4	89 8d 50 ff ff
	ff		 mov	 DWORD PTR _cy3x0$18[ebp], ecx
  004fa	eb 40		 jmp	 SHORT $LN25@convert_yv
$LN24@convert_yv:
  004fc	33 d2		 xor	 edx, edx
  004fe	74 3c		 je	 SHORT $LN25@convert_yv
  00500	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _cy0x0$21[ebp]
  00506	c1 f8 fd	 sar	 eax, -3			; fffffffdH
  00509	89 85 5c ff ff
	ff		 mov	 DWORD PTR _cy0x0$21[ebp], eax
  0050f	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x0$20[ebp]
  00515	c1 f9 fd	 sar	 ecx, -3			; fffffffdH
  00518	89 8d 58 ff ff
	ff		 mov	 DWORD PTR _cy1x0$20[ebp], ecx
  0051e	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR _cy2x0$19[ebp]
  00524	c1 fa fd	 sar	 edx, -3			; fffffffdH
  00527	89 95 54 ff ff
	ff		 mov	 DWORD PTR _cy2x0$19[ebp], edx
  0052d	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$18[ebp]
  00533	c1 f8 fd	 sar	 eax, -3			; fffffffdH
  00536	89 85 50 ff ff
	ff		 mov	 DWORD PTR _cy3x0$18[ebp], eax
$LN25@convert_yv:

; 743  : 
; 744  :             for (int x = 0; x < x_fin; x += 2, dstC += 2, srcP++) {

  0053c	c7 85 4c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _x$17[ebp], 0
  00546	eb 21		 jmp	 SHORT $LN16@convert_yv
$LN14@convert_yv:
  00548	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _x$17[ebp]
  0054e	83 c1 02	 add	 ecx, 2
  00551	89 8d 4c ff ff
	ff		 mov	 DWORD PTR _x$17[ebp], ecx
  00557	8b 55 94	 mov	 edx, DWORD PTR _dstC$35[ebp]
  0055a	83 c2 04	 add	 edx, 4
  0055d	89 55 94	 mov	 DWORD PTR _dstC$35[ebp], edx
  00560	8b 45 90	 mov	 eax, DWORD PTR _srcP$34[ebp]
  00563	83 c0 02	 add	 eax, 2
  00566	89 45 90	 mov	 DWORD PTR _srcP$34[ebp], eax
$LN16@convert_yv:
  00569	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _x$17[ebp]
  0056f	3b 4d 8c	 cmp	 ecx, DWORD PTR _x_fin$33[ebp]
  00572	0f 8d a9 02 00
	00		 jge	 $LN15@convert_yv

; 745  :                 int cxplus = (x + 2 < x_fin);

  00578	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR _x$17[ebp]
  0057e	83 c2 02	 add	 edx, 2
  00581	3b 55 8c	 cmp	 edx, DWORD PTR _x_fin$33[ebp]
  00584	7d 0c		 jge	 SHORT $LN43@convert_yv
  00586	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv302[ebp], 1
  00590	eb 0a		 jmp	 SHORT $LN44@convert_yv
$LN43@convert_yv:
  00592	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv302[ebp], 0
$LN44@convert_yv:
  0059c	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv302[ebp]
  005a2	89 85 48 ff ff
	ff		 mov	 DWORD PTR _cxplus$16[ebp], eax

; 746  :                 int sy0x1 = srcP[y_m2*src_uv_pitch + cxplus];

  005a8	8b 4d 88	 mov	 ecx, DWORD PTR _y_m2$32[ebp]
  005ab	0f af 4d a8	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  005af	03 8d 48 ff ff
	ff		 add	 ecx, DWORD PTR _cxplus$16[ebp]
  005b5	8b 55 90	 mov	 edx, DWORD PTR _srcP$34[ebp]
  005b8	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  005bc	89 85 44 ff ff
	ff		 mov	 DWORD PTR _sy0x1$15[ebp], eax

; 747  :                 int sy1x1 = srcP[y_m1*src_uv_pitch + cxplus];

  005c2	8b 4d 84	 mov	 ecx, DWORD PTR _y_m1$31[ebp]
  005c5	0f af 4d a8	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  005c9	03 8d 48 ff ff
	ff		 add	 ecx, DWORD PTR _cxplus$16[ebp]
  005cf	8b 55 90	 mov	 edx, DWORD PTR _srcP$34[ebp]
  005d2	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  005d6	89 85 40 ff ff
	ff		 mov	 DWORD PTR _sy1x1$14[ebp], eax

; 748  :                 int sy2x1 = srcP[   0*src_uv_pitch + cxplus];

  005dc	6b 4d a8 00	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 0
  005e0	03 8d 48 ff ff
	ff		 add	 ecx, DWORD PTR _cxplus$16[ebp]
  005e6	8b 55 90	 mov	 edx, DWORD PTR _srcP$34[ebp]
  005e9	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  005ed	89 85 3c ff ff
	ff		 mov	 DWORD PTR _sy2x1$13[ebp], eax

; 749  :                 int sy3x1 = srcP[y_p1*src_uv_pitch + cxplus];

  005f3	8b 4d 80	 mov	 ecx, DWORD PTR _y_p1$30[ebp]
  005f6	0f af 4d a8	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  005fa	03 8d 48 ff ff
	ff		 add	 ecx, DWORD PTR _cxplus$16[ebp]
  00600	8b 55 90	 mov	 edx, DWORD PTR _srcP$34[ebp]
  00603	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00607	89 85 38 ff ff
	ff		 mov	 DWORD PTR _sy3x1$12[ebp], eax

; 750  :                 int sy4x1 = srcP[y_p2*src_uv_pitch + cxplus];

  0060d	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _y_p2$29[ebp]
  00613	0f af 4d a8	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00617	03 8d 48 ff ff
	ff		 add	 ecx, DWORD PTR _cxplus$16[ebp]
  0061d	8b 55 90	 mov	 edx, DWORD PTR _srcP$34[ebp]
  00620	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00624	89 85 34 ff ff
	ff		 mov	 DWORD PTR _sy4x1$11[ebp], eax

; 751  :                 int sy5x1 = srcP[y_p3*src_uv_pitch + cxplus];

  0062a	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _y_p3$28[ebp]
  00630	0f af 4d a8	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00634	03 8d 48 ff ff
	ff		 add	 ecx, DWORD PTR _cxplus$16[ebp]
  0063a	8b 55 90	 mov	 edx, DWORD PTR _srcP$34[ebp]
  0063d	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00641	89 85 30 ff ff
	ff		 mov	 DWORD PTR _sy5x1$10[ebp], eax

; 752  : 
; 753  :                 int cy0x1 = (sy0x1 * 1 + sy2x1 * 7 + 4);

  00647	6b 8d 3c ff ff
	ff 07		 imul	 ecx, DWORD PTR _sy2x1$13[ebp], 7
  0064e	8b 95 44 ff ff
	ff		 mov	 edx, DWORD PTR _sy0x1$15[ebp]
  00654	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  00658	89 85 2c ff ff
	ff		 mov	 DWORD PTR _cy0x1$9[ebp], eax

; 754  :                 int cy1x1 = (sy1x1 * 3 + sy3x1 * 5 + 4);

  0065e	6b 8d 40 ff ff
	ff 03		 imul	 ecx, DWORD PTR _sy1x1$14[ebp], 3
  00665	6b 95 38 ff ff
	ff 05		 imul	 edx, DWORD PTR _sy3x1$12[ebp], 5
  0066c	8d 44 11 04	 lea	 eax, DWORD PTR [ecx+edx+4]
  00670	89 85 28 ff ff
	ff		 mov	 DWORD PTR _cy1x1$8[ebp], eax

; 755  :                 int cy2x1 = (sy2x1 * 5 + sy4x1 * 3 + 4);

  00676	6b 8d 3c ff ff
	ff 05		 imul	 ecx, DWORD PTR _sy2x1$13[ebp], 5
  0067d	6b 95 34 ff ff
	ff 03		 imul	 edx, DWORD PTR _sy4x1$11[ebp], 3
  00684	8d 44 11 04	 lea	 eax, DWORD PTR [ecx+edx+4]
  00688	89 85 24 ff ff
	ff		 mov	 DWORD PTR _cy2x1$7[ebp], eax

; 756  :                 int cy3x1 = (sy3x1 * 7 + sy5x1 * 1 + 4);

  0068e	6b 8d 38 ff ff
	ff 07		 imul	 ecx, DWORD PTR _sy3x1$12[ebp], 7
  00695	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR _sy5x1$10[ebp]
  0069b	8d 44 11 04	 lea	 eax, DWORD PTR [ecx+edx+4]
  0069f	89 85 20 ff ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], eax

; 757  :                 CHANGE_BIT_DEPTH_4(cy0x1, cy1x1, cy2x1, cy3x1, 3);

  006a5	b9 01 00 00 00	 mov	 ecx, 1
  006aa	85 c9		 test	 ecx, ecx
  006ac	74 3e		 je	 SHORT $LN27@convert_yv
  006ae	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR _cy0x1$9[ebp]
  006b4	c1 e2 03	 shl	 edx, 3
  006b7	89 95 2c ff ff
	ff		 mov	 DWORD PTR _cy0x1$9[ebp], edx
  006bd	8b 85 28 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x1$8[ebp]
  006c3	c1 e0 03	 shl	 eax, 3
  006c6	89 85 28 ff ff
	ff		 mov	 DWORD PTR _cy1x1$8[ebp], eax
  006cc	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR _cy2x1$7[ebp]
  006d2	c1 e1 03	 shl	 ecx, 3
  006d5	89 8d 24 ff ff
	ff		 mov	 DWORD PTR _cy2x1$7[ebp], ecx
  006db	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR _cy3x1$6[ebp]
  006e1	c1 e2 03	 shl	 edx, 3
  006e4	89 95 20 ff ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], edx
  006ea	eb 40		 jmp	 SHORT $LN28@convert_yv
$LN27@convert_yv:
  006ec	33 c0		 xor	 eax, eax
  006ee	74 3c		 je	 SHORT $LN28@convert_yv
  006f0	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR _cy0x1$9[ebp]
  006f6	c1 f9 fd	 sar	 ecx, -3			; fffffffdH
  006f9	89 8d 2c ff ff
	ff		 mov	 DWORD PTR _cy0x1$9[ebp], ecx
  006ff	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x1$8[ebp]
  00705	c1 fa fd	 sar	 edx, -3			; fffffffdH
  00708	89 95 28 ff ff
	ff		 mov	 DWORD PTR _cy1x1$8[ebp], edx
  0070e	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _cy2x1$7[ebp]
  00714	c1 f8 fd	 sar	 eax, -3			; fffffffdH
  00717	89 85 24 ff ff
	ff		 mov	 DWORD PTR _cy2x1$7[ebp], eax
  0071d	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x1$6[ebp]
  00723	c1 f9 fd	 sar	 ecx, -3			; fffffffdH
  00726	89 8d 20 ff ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], ecx
$LN28@convert_yv:

; 758  : 
; 759  :                 dstC[0*dst_y_pitch   + 0] = (Tout)cy0x0;

  0072c	6b 55 e4 00	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 0
  00730	8b 45 94	 mov	 eax, DWORD PTR _dstC$35[ebp]
  00733	66 8b 8d 5c ff
	ff ff		 mov	 cx, WORD PTR _cy0x0$21[ebp]
  0073a	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx

; 760  :                 dstC[0*dst_y_pitch   + 1] = (Tout)((cy0x0 + cy0x1 + 1) >> 1);

  0073e	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR _cy0x1$9[ebp]
  00744	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _cy0x0$21[ebp]
  0074a	8d 4c 10 01	 lea	 ecx, DWORD PTR [eax+edx+1]
  0074e	d1 f9		 sar	 ecx, 1
  00750	6b 55 e4 00	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 0
  00754	8b 45 94	 mov	 eax, DWORD PTR _dstC$35[ebp]
  00757	66 89 4c 50 02	 mov	 WORD PTR [eax+edx*2+2], cx

; 761  :                 dstC[1*dst_y_pitch   + 0] = (Tout)cy1x0;

  0075c	8b 4d e4	 mov	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  0075f	8b 55 94	 mov	 edx, DWORD PTR _dstC$35[ebp]
  00762	66 8b 85 58 ff
	ff ff		 mov	 ax, WORD PTR _cy1x0$20[ebp]
  00769	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax

; 762  :                 dstC[1*dst_y_pitch   + 1] = (Tout)((cy1x0 + cy1x1 + 1) >> 1);

  0076d	8b 8d 28 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x1$8[ebp]
  00773	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x0$20[ebp]
  00779	8d 44 0a 01	 lea	 eax, DWORD PTR [edx+ecx+1]
  0077d	d1 f8		 sar	 eax, 1
  0077f	8b 4d e4	 mov	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  00782	8b 55 94	 mov	 edx, DWORD PTR _dstC$35[ebp]
  00785	66 89 44 4a 02	 mov	 WORD PTR [edx+ecx*2+2], ax

; 763  :                 dstC[2*dst_y_pitch   + 0] = (Tout)cy2x0;

  0078a	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  0078d	d1 e0		 shl	 eax, 1
  0078f	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$35[ebp]
  00792	66 8b 95 54 ff
	ff ff		 mov	 dx, WORD PTR _cy2x0$19[ebp]
  00799	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx

; 764  :                 dstC[2*dst_y_pitch   + 1] = (Tout)((cy2x0 + cy2x1 + 1) >> 1);

  0079d	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _cy2x1$7[ebp]
  007a3	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _cy2x0$19[ebp]
  007a9	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  007ad	d1 fa		 sar	 edx, 1
  007af	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  007b2	d1 e0		 shl	 eax, 1
  007b4	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$35[ebp]
  007b7	66 89 54 41 02	 mov	 WORD PTR [ecx+eax*2+2], dx

; 765  :                 dstC[3*dst_y_pitch   + 0] = (Tout)cy3x0;

  007bc	6b 55 e4 03	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 3
  007c0	8b 45 94	 mov	 eax, DWORD PTR _dstC$35[ebp]
  007c3	66 8b 8d 50 ff
	ff ff		 mov	 cx, WORD PTR _cy3x0$18[ebp]
  007ca	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx

; 766  :                 dstC[3*dst_y_pitch   + 1] = (Tout)((cy3x0 + cy3x1 + 1) >> 1);

  007ce	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR _cy3x1$6[ebp]
  007d4	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$18[ebp]
  007da	8d 4c 10 01	 lea	 ecx, DWORD PTR [eax+edx+1]
  007de	d1 f9		 sar	 ecx, 1
  007e0	6b 55 e4 03	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 3
  007e4	8b 45 94	 mov	 eax, DWORD PTR _dstC$35[ebp]
  007e7	66 89 4c 50 02	 mov	 WORD PTR [eax+edx*2+2], cx

; 767  : 
; 768  :                 cy0x0 = cy0x1;

  007ec	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR _cy0x1$9[ebp]
  007f2	89 8d 5c ff ff
	ff		 mov	 DWORD PTR _cy0x0$21[ebp], ecx

; 769  :                 cy1x0 = cy1x1;

  007f8	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x1$8[ebp]
  007fe	89 95 58 ff ff
	ff		 mov	 DWORD PTR _cy1x0$20[ebp], edx

; 770  :                 cy2x0 = cy2x1;

  00804	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _cy2x1$7[ebp]
  0080a	89 85 54 ff ff
	ff		 mov	 DWORD PTR _cy2x0$19[ebp], eax

; 771  :                 cy3x0 = cy3x1;

  00810	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x1$6[ebp]
  00816	89 8d 50 ff ff
	ff		 mov	 DWORD PTR _cy3x0$18[ebp], ecx

; 772  :             }

  0081c	e9 27 fd ff ff	 jmp	 $LN14@convert_yv
$LN15@convert_yv:

; 773  :         }

  00821	e9 7b fa ff ff	 jmp	 $LN11@convert_yv
$LN12@convert_yv:

; 774  :     }

  00826	e9 29 fa ff ff	 jmp	 $LN8@convert_yv
$LN1@convert_yv:

; 775  : }

  0082b	52		 push	 edx
  0082c	8b cd		 mov	 ecx, ebp
  0082e	50		 push	 eax
  0082f	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN47@convert_yv
  00835	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0083a	58		 pop	 eax
  0083b	5a		 pop	 edx
  0083c	5f		 pop	 edi
  0083d	5e		 pop	 esi
  0083e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00841	33 cd		 xor	 ecx, ebp
  00843	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00848	81 c4 18 01 00
	00		 add	 esp, 280		; 00000118H
  0084e	3b ec		 cmp	 ebp, esp
  00850	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00855	8b e5		 mov	 esp, ebp
  00857	5d		 pop	 ebp
  00858	c3		 ret	 0
  00859	0f 1f 00	 npad	 3
$LN47@convert_yv:
  0085c	01 00 00 00	 DD	 1
  00860	00 00 00 00	 DD	 $LN46@convert_yv
$LN46@convert_yv:
  00864	d4 ff ff ff	 DD	 -44			; ffffffd4H
  00868	0c 00 00 00	 DD	 12			; 0000000cH
  0086c	00 00 00 00	 DD	 $LN45@convert_yv
$LN45@convert_yv:
  00870	79		 DB	 121			; 00000079H
  00871	5f		 DB	 95			; 0000005fH
  00872	72		 DB	 114			; 00000072H
  00873	61		 DB	 97			; 00000061H
  00874	6e		 DB	 110			; 0000006eH
  00875	67		 DB	 103			; 00000067H
  00876	65		 DB	 101			; 00000065H
  00877	00		 DB	 0
??$convert_yv12_i_to_yuv444_c@G$09G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_i_to_yuv444_c<unsigned short,10,unsigned short,16,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yv12_10_i_to_yuv444_16bit@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_10_i_to_yuv444_16bit

; 861  : static void convert_yv12_10_i_to_yuv444_16bit(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 862  :     convert_yv12_i_to_yuv444_c<uint16_t, 10, uint16_t, 16, false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yv12_i_to_yuv444_c@G$09G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_i_to_yuv444_c<unsigned short,10,unsigned short,16,0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 863  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yv12_10_i_to_yuv444_16bit@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_10_i_to_yuv444_16bit
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
tv432 = -300						; size = 4
tv317 = -296						; size = 4
tv232 = -292						; size = 4
$T1 = -288						; size = 4
$T2 = -284						; size = 4
$T3 = -280						; size = 4
$T4 = -276						; size = 4
$T5 = -272						; size = 12
_cy3x1$6 = -260						; size = 4
_cy1x1$7 = -256						; size = 4
_cy3x0$8 = -252						; size = 4
_cy1x0$9 = -248						; size = 4
_cy4x1$10 = -244					; size = 4
_cy2x1$11 = -240					; size = 4
_cy0x1$12 = -236					; size = 4
_cy4x0$13 = -232					; size = 4
_cy2x0$14 = -228					; size = 4
_cy0x0$15 = -224					; size = 4
_cxplus$16 = -220					; size = 4
_x$17 = -216						; size = 4
_cy3x1$18 = -212					; size = 4
_cy1x1$19 = -208					; size = 4
_cy3x0$20 = -204					; size = 4
_cy1x0$21 = -200					; size = 4
_cy4x1$22 = -196					; size = 4
_cy2x1$23 = -192					; size = 4
_cy0x1$24 = -188					; size = 4
_cy4x0$25 = -184					; size = 4
_cy2x0$26 = -180					; size = 4
_cy0x0$27 = -176					; size = 4
_cxplus$28 = -172					; size = 4
_x$29 = -168						; size = 4
_cy3x1$30 = -164					; size = 4
_cy1x1$31 = -160					; size = 4
_cy3x0$32 = -156					; size = 4
_cy1x0$33 = -152					; size = 4
_cy4x1$34 = -148					; size = 4
_cy2x1$35 = -144					; size = 4
_cy0x1$36 = -140					; size = 4
_cy4x0$37 = -136					; size = 4
_cy2x0$38 = -132					; size = 4
_cy0x0$39 = -128					; size = 4
_cxplus$40 = -124					; size = 4
_x$41 = -120						; size = 4
_x_fin$42 = -116					; size = 4
_srcP$43 = -112						; size = 4
_dstC$44 = -108						; size = 4
_y$45 = -104						; size = 4
_dstLine$46 = -100					; size = 4
_srcCLine$47 = -96					; size = 4
_ic$48 = -92						; size = 4
_src_uv_pitch$ = -88					; size = 4
_x$49 = -84						; size = 4
_y$50 = -80						; size = 4
_y_width$51 = -76					; size = 4
_y_fin$52 = -72						; size = 4
_dstLine$53 = -68					; size = 4
_srcYLine$54 = -64					; size = 4
$T55 = -60						; size = 12
_y_range$ = -44						; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yv12_p_to_yuv444_c@G$09G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_p_to_yuv444_c<unsigned short,10,unsigned short,16,0>

; 573  : static void __forceinline convert_yv12_p_to_yuv444_c(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 2c 01 00
	00		 sub	 esp, 300		; 0000012cH
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8d bd d4 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-300]
  00011	b9 4b 00 00 00	 mov	 ecx, 75			; 0000004bH
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 574  :     static_assert((sizeof(Tin)  == 1 && in_bit_depth  == 8) || (sizeof(Tin)  == 2 && 8 < in_bit_depth  && in_bit_depth  <= 16), "invalid input bit depth.");
; 575  :     static_assert((sizeof(Tout) == 1 && out_bit_depth == 8) || (sizeof(Tout) == 2 && 8 < out_bit_depth && out_bit_depth <= 16), "invalid output bit depth.");
; 576  :     const int crop_left   = crop[0];

  00027	b8 04 00 00 00	 mov	 eax, 4
  0002c	6b c8 00	 imul	 ecx, eax, 0
  0002f	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00032	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00035	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 577  :     const int crop_up     = crop[1];

  00038	b9 04 00 00 00	 mov	 ecx, 4
  0003d	c1 e1 00	 shl	 ecx, 0
  00040	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00043	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00046	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 578  :     const int crop_right  = crop[2];

  00049	b9 04 00 00 00	 mov	 ecx, 4
  0004e	d1 e1		 shl	 ecx, 1
  00050	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00053	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00056	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 579  :     const int crop_bottom = crop[3];

  00059	b9 04 00 00 00	 mov	 ecx, 4
  0005e	6b d1 03	 imul	 edx, ecx, 3
  00061	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00064	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00067	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 580  :     const int src_y_pitch = src_y_pitch_byte / sizeof(Tin);

  0006a	8b 55 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebp]
  0006d	d1 ea		 shr	 edx, 1
  0006f	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 581  :     const int dst_y_pitch = dst_y_pitch_byte / sizeof(Tout);

  00072	8b 45 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  00075	d1 e8		 shr	 eax, 1
  00077	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 582  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  0007a	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0007d	51		 push	 ecx
  0007e	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  00081	52		 push	 edx
  00082	8b 45 20	 mov	 eax, DWORD PTR _height$[ebp]
  00085	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  00088	50		 push	 eax
  00089	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  0008c	51		 push	 ecx
  0008d	8d 95 f0 fe ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  00093	52		 push	 edx
  00094	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00099	83 c4 14	 add	 esp, 20			; 00000014H
  0009c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009e	89 4d c4	 mov	 DWORD PTR $T55[ebp], ecx
  000a1	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a4	89 55 c8	 mov	 DWORD PTR $T55[ebp+4], edx
  000a7	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000aa	89 45 cc	 mov	 DWORD PTR $T55[ebp+8], eax
  000ad	8b 4d c4	 mov	 ecx, DWORD PTR $T55[ebp]
  000b0	89 4d d4	 mov	 DWORD PTR _y_range$[ebp], ecx
  000b3	8b 55 c8	 mov	 edx, DWORD PTR $T55[ebp+4]
  000b6	89 55 d8	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000b9	8b 45 cc	 mov	 eax, DWORD PTR $T55[ebp+8]
  000bc	89 45 dc	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 583  :     //Y
; 584  :     if (!uv_only) {

  000bf	b9 01 00 00 00	 mov	 ecx, 1
  000c4	85 c9		 test	 ecx, ecx
  000c6	0f 84 77 01 00
	00		 je	 $LN23@convert_yv

; 585  :         Tin *srcYLine = (Tin *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000cc	ba 04 00 00 00	 mov	 edx, 4
  000d1	6b c2 00	 imul	 eax, edx, 0
  000d4	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  000d7	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  000db	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  000de	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  000e1	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  000e4	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  000e7	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  000ea	89 45 c0	 mov	 DWORD PTR _srcYLine$54[ebp], eax

; 586  :         Tout *dstLine = (Tout *)dst[0] + dst_y_pitch * y_range.start_dst;

  000ed	b9 04 00 00 00	 mov	 ecx, 4
  000f2	6b d1 00	 imul	 edx, ecx, 0
  000f5	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  000f8	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  000fc	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  000ff	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  00102	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  00105	89 45 bc	 mov	 DWORD PTR _dstLine$53[ebp], eax

; 587  :         const int y_fin = height - crop_bottom;

  00108	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  0010b	2b 4d ec	 sub	 ecx, DWORD PTR _crop_bottom$[ebp]
  0010e	89 4d b8	 mov	 DWORD PTR _y_fin$52[ebp], ecx

; 588  :         const int y_width = width - crop_right - crop_left;

  00111	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00114	2b 55 f0	 sub	 edx, DWORD PTR _crop_right$[ebp]
  00117	2b 55 f8	 sub	 edx, DWORD PTR _crop_left$[ebp]
  0011a	89 55 b4	 mov	 DWORD PTR _y_width$51[ebp], edx

; 589  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  0011d	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _y$50[ebp], 0
  00124	eb 21		 jmp	 SHORT $LN4@convert_yv
$LN2@convert_yv:
  00126	8b 45 b0	 mov	 eax, DWORD PTR _y$50[ebp]
  00129	83 c0 01	 add	 eax, 1
  0012c	89 45 b0	 mov	 DWORD PTR _y$50[ebp], eax
  0012f	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  00132	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$54[ebp]
  00135	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  00138	89 45 c0	 mov	 DWORD PTR _srcYLine$54[ebp], eax
  0013b	8b 4d e4	 mov	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  0013e	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$53[ebp]
  00141	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  00144	89 45 bc	 mov	 DWORD PTR _dstLine$53[ebp], eax
$LN4@convert_yv:
  00147	8b 4d b0	 mov	 ecx, DWORD PTR _y$50[ebp]
  0014a	3b 4d dc	 cmp	 ecx, DWORD PTR _y_range$[ebp+8]
  0014d	0f 8d f0 00 00
	00		 jge	 $LN23@convert_yv

; 590  :             if (in_bit_depth == out_bit_depth && sizeof(Tin) == sizeof(Tout)) {

  00153	33 d2		 xor	 edx, edx
  00155	74 1b		 je	 SHORT $LN24@convert_yv

; 591  :                 memcpy(dstLine, srcYLine, y_width * sizeof(Tin));

  00157	8b 45 b4	 mov	 eax, DWORD PTR _y_width$51[ebp]
  0015a	d1 e0		 shl	 eax, 1
  0015c	50		 push	 eax
  0015d	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$54[ebp]
  00160	51		 push	 ecx
  00161	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$53[ebp]
  00164	52		 push	 edx
  00165	e8 00 00 00 00	 call	 _memcpy
  0016a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 592  :             } else {

  0016d	e9 cc 00 00 00	 jmp	 $LN25@convert_yv
$LN24@convert_yv:

; 593  :                 for (int x = 0; x < y_width; x++) {

  00172	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR _x$49[ebp], 0
  00179	eb 09		 jmp	 SHORT $LN7@convert_yv
$LN5@convert_yv:
  0017b	8b 45 ac	 mov	 eax, DWORD PTR _x$49[ebp]
  0017e	83 c0 01	 add	 eax, 1
  00181	89 45 ac	 mov	 DWORD PTR _x$49[ebp], eax
$LN7@convert_yv:
  00184	8b 4d ac	 mov	 ecx, DWORD PTR _x$49[ebp]
  00187	3b 4d b4	 cmp	 ecx, DWORD PTR _y_width$51[ebp]
  0018a	0f 8d ae 00 00
	00		 jge	 $LN25@convert_yv

; 594  :                     if (out_bit_depth > in_bit_depth) {

  00190	ba 01 00 00 00	 mov	 edx, 1
  00195	85 d2		 test	 edx, edx
  00197	74 44		 je	 SHORT $LN26@convert_yv

; 595  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) << std::max(out_bit_depth - in_bit_depth, 0));

  00199	c7 85 ec fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], 0
  001a3	c7 85 e8 fe ff
	ff 06 00 00 00	 mov	 DWORD PTR $T3[ebp], 6
  001ad	8b 45 ac	 mov	 eax, DWORD PTR _x$49[ebp]
  001b0	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$54[ebp]
  001b3	0f b7 34 41	 movzx	 esi, WORD PTR [ecx+eax*2]
  001b7	8d 95 ec fe ff
	ff		 lea	 edx, DWORD PTR $T4[ebp]
  001bd	52		 push	 edx
  001be	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  001c4	50		 push	 eax
  001c5	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  001ca	83 c4 08	 add	 esp, 8
  001cd	8b 08		 mov	 ecx, DWORD PTR [eax]
  001cf	d3 e6		 shl	 esi, cl
  001d1	8b 4d ac	 mov	 ecx, DWORD PTR _x$49[ebp]
  001d4	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$53[ebp]
  001d7	66 89 34 4a	 mov	 WORD PTR [edx+ecx*2], si
  001db	eb 5c		 jmp	 SHORT $LN27@convert_yv
$LN26@convert_yv:

; 596  :                     } else if (out_bit_depth < in_bit_depth) {

  001dd	33 c0		 xor	 eax, eax
  001df	74 44		 je	 SHORT $LN28@convert_yv

; 597  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) >> std::max(in_bit_depth - out_bit_depth, 0));

  001e1	c7 85 e4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], 0
  001eb	c7 85 e0 fe ff
	ff fa ff ff ff	 mov	 DWORD PTR $T1[ebp], -6	; fffffffaH
  001f5	8b 4d ac	 mov	 ecx, DWORD PTR _x$49[ebp]
  001f8	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$54[ebp]
  001fb	0f b7 34 4a	 movzx	 esi, WORD PTR [edx+ecx*2]
  001ff	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  00205	50		 push	 eax
  00206	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  0020c	51		 push	 ecx
  0020d	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  00212	83 c4 08	 add	 esp, 8
  00215	8b 08		 mov	 ecx, DWORD PTR [eax]
  00217	d3 fe		 sar	 esi, cl
  00219	8b 55 ac	 mov	 edx, DWORD PTR _x$49[ebp]
  0021c	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$53[ebp]
  0021f	66 89 34 50	 mov	 WORD PTR [eax+edx*2], si

; 598  :                     } else {

  00223	eb 14		 jmp	 SHORT $LN27@convert_yv
$LN28@convert_yv:

; 599  :                         dstLine[x] = (Tout)srcYLine[x];

  00225	8b 4d ac	 mov	 ecx, DWORD PTR _x$49[ebp]
  00228	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$53[ebp]
  0022b	8b 45 ac	 mov	 eax, DWORD PTR _x$49[ebp]
  0022e	8b 75 c0	 mov	 esi, DWORD PTR _srcYLine$54[ebp]
  00231	66 8b 04 46	 mov	 ax, WORD PTR [esi+eax*2]
  00235	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax
$LN27@convert_yv:

; 600  :                     }
; 601  :                 }

  00239	e9 3d ff ff ff	 jmp	 $LN5@convert_yv
$LN25@convert_yv:

; 602  :             }
; 603  :         }

  0023e	e9 e3 fe ff ff	 jmp	 $LN2@convert_yv
$LN23@convert_yv:

; 604  :     }
; 605  :     //UV
; 606  :     const int src_uv_pitch = src_uv_pitch_byte / sizeof(Tin);

  00243	8b 4d 18	 mov	 ecx, DWORD PTR _src_uv_pitch_byte$[ebp]
  00246	d1 e9		 shr	 ecx, 1
  00248	89 4d a8	 mov	 DWORD PTR _src_uv_pitch$[ebp], ecx

; 607  :     for (int ic = 1; ic < 3; ic++) {

  0024b	c7 45 a4 01 00
	00 00		 mov	 DWORD PTR _ic$48[ebp], 1
  00252	eb 09		 jmp	 SHORT $LN10@convert_yv
$LN8@convert_yv:
  00254	8b 55 a4	 mov	 edx, DWORD PTR _ic$48[ebp]
  00257	83 c2 01	 add	 edx, 1
  0025a	89 55 a4	 mov	 DWORD PTR _ic$48[ebp], edx
$LN10@convert_yv:
  0025d	83 7d a4 03	 cmp	 DWORD PTR _ic$48[ebp], 3
  00261	0f 8d 07 07 00
	00		 jge	 $LN1@convert_yv

; 608  :         Tin *srcCLine = (Tin *)src[ic] + (((src_uv_pitch * y_range.start_src) + crop_left) >> 1);

  00267	8b 45 a8	 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  0026a	0f af 45 d4	 imul	 eax, DWORD PTR _y_range$[ebp]
  0026e	03 45 f8	 add	 eax, DWORD PTR _crop_left$[ebp]
  00271	d1 f8		 sar	 eax, 1
  00273	8b 4d a4	 mov	 ecx, DWORD PTR _ic$48[ebp]
  00276	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  00279	8b 0c 8a	 mov	 ecx, DWORD PTR [edx+ecx*4]
  0027c	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  0027f	89 55 a0	 mov	 DWORD PTR _srcCLine$47[ebp], edx

; 609  :         Tout *dstLine = (Tout *)dst[ic] + dst_y_pitch * y_range.start_dst;

  00282	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  00285	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  00289	8b 4d a4	 mov	 ecx, DWORD PTR _ic$48[ebp]
  0028c	8b 55 08	 mov	 edx, DWORD PTR _dst$[ebp]
  0028f	8b 0c 8a	 mov	 ecx, DWORD PTR [edx+ecx*4]
  00292	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00295	89 55 9c	 mov	 DWORD PTR _dstLine$46[ebp], edx

; 610  :         for (int y = 0; y < y_range.len; y += 2, srcCLine += src_uv_pitch, dstLine += dst_y_pitch * 2) {

  00298	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _y$45[ebp], 0
  0029f	eb 23		 jmp	 SHORT $LN13@convert_yv
$LN11@convert_yv:
  002a1	8b 45 98	 mov	 eax, DWORD PTR _y$45[ebp]
  002a4	83 c0 02	 add	 eax, 2
  002a7	89 45 98	 mov	 DWORD PTR _y$45[ebp], eax
  002aa	8b 4d a8	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  002ad	8b 55 a0	 mov	 edx, DWORD PTR _srcCLine$47[ebp]
  002b0	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  002b3	89 45 a0	 mov	 DWORD PTR _srcCLine$47[ebp], eax
  002b6	8b 4d e4	 mov	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  002b9	d1 e1		 shl	 ecx, 1
  002bb	8b 55 9c	 mov	 edx, DWORD PTR _dstLine$46[ebp]
  002be	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  002c1	89 45 9c	 mov	 DWORD PTR _dstLine$46[ebp], eax
$LN13@convert_yv:
  002c4	8b 4d 98	 mov	 ecx, DWORD PTR _y$45[ebp]
  002c7	3b 4d dc	 cmp	 ecx, DWORD PTR _y_range$[ebp+8]
  002ca	0f 8d 99 06 00
	00		 jge	 $LN12@convert_yv

; 611  :             Tout *dstC = dstLine;

  002d0	8b 55 9c	 mov	 edx, DWORD PTR _dstLine$46[ebp]
  002d3	89 55 94	 mov	 DWORD PTR _dstC$44[ebp], edx

; 612  :             Tin *srcP = srcCLine;

  002d6	8b 45 a0	 mov	 eax, DWORD PTR _srcCLine$47[ebp]
  002d9	89 45 90	 mov	 DWORD PTR _srcP$43[ebp], eax

; 613  :             const int x_fin = width - crop_right - crop_left;

  002dc	8b 4d 10	 mov	 ecx, DWORD PTR _width$[ebp]
  002df	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  002e2	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  002e5	89 4d 8c	 mov	 DWORD PTR _x_fin$42[ebp], ecx

; 614  :             if (y == 0) {

  002e8	83 7d 98 00	 cmp	 DWORD PTR _y$45[ebp], 0
  002ec	0f 85 0c 02 00
	00		 jne	 $LN30@convert_yv

; 615  :                 for (int x = 0; x < x_fin; x += 2, dstC += 2, srcP++) {

  002f2	c7 45 88 00 00
	00 00		 mov	 DWORD PTR _x$41[ebp], 0
  002f9	eb 1b		 jmp	 SHORT $LN16@convert_yv
$LN14@convert_yv:
  002fb	8b 55 88	 mov	 edx, DWORD PTR _x$41[ebp]
  002fe	83 c2 02	 add	 edx, 2
  00301	89 55 88	 mov	 DWORD PTR _x$41[ebp], edx
  00304	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  00307	83 c0 04	 add	 eax, 4
  0030a	89 45 94	 mov	 DWORD PTR _dstC$44[ebp], eax
  0030d	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$43[ebp]
  00310	83 c1 02	 add	 ecx, 2
  00313	89 4d 90	 mov	 DWORD PTR _srcP$43[ebp], ecx
$LN16@convert_yv:
  00316	8b 55 88	 mov	 edx, DWORD PTR _x$41[ebp]
  00319	3b 55 8c	 cmp	 edx, DWORD PTR _x_fin$42[ebp]
  0031c	0f 8d d7 01 00
	00		 jge	 $LN15@convert_yv

; 616  :                     int cxplus = (x + 2 < x_fin);

  00322	8b 45 88	 mov	 eax, DWORD PTR _x$41[ebp]
  00325	83 c0 02	 add	 eax, 2
  00328	3b 45 8c	 cmp	 eax, DWORD PTR _x_fin$42[ebp]
  0032b	7d 0c		 jge	 SHORT $LN44@convert_yv
  0032d	c7 85 dc fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv232[ebp], 1
  00337	eb 0a		 jmp	 SHORT $LN45@convert_yv
$LN44@convert_yv:
  00339	c7 85 dc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv232[ebp], 0
$LN45@convert_yv:
  00343	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR tv232[ebp]
  00349	89 4d 84	 mov	 DWORD PTR _cxplus$40[ebp], ecx

; 617  :                     int cy0x0 = srcP[ 0*src_uv_pitch + 0];

  0034c	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  00350	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  00353	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  00357	89 4d 80	 mov	 DWORD PTR _cy0x0$39[ebp], ecx

; 618  :                     int cy2x0 = srcP[ 0*src_uv_pitch + 0];

  0035a	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  0035e	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  00361	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  00365	89 8d 7c ff ff
	ff		 mov	 DWORD PTR _cy2x0$38[ebp], ecx

; 619  :                     int cy4x0 = srcP[ 1*src_uv_pitch + 0];

  0036b	8b 55 a8	 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  0036e	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  00371	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  00375	89 8d 78 ff ff
	ff		 mov	 DWORD PTR _cy4x0$37[ebp], ecx

; 620  :                     int cy0x1 = srcP[ 0*src_uv_pitch + cxplus];

  0037b	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  0037f	03 55 84	 add	 edx, DWORD PTR _cxplus$40[ebp]
  00382	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  00385	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  00389	89 8d 74 ff ff
	ff		 mov	 DWORD PTR _cy0x1$36[ebp], ecx

; 621  :                     int cy2x1 = srcP[ 0*src_uv_pitch + cxplus];

  0038f	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  00393	03 55 84	 add	 edx, DWORD PTR _cxplus$40[ebp]
  00396	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  00399	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  0039d	89 8d 70 ff ff
	ff		 mov	 DWORD PTR _cy2x1$35[ebp], ecx

; 622  :                     int cy4x1 = srcP[ 1*src_uv_pitch + cxplus];

  003a3	8b 55 84	 mov	 edx, DWORD PTR _cxplus$40[ebp]
  003a6	03 55 a8	 add	 edx, DWORD PTR _src_uv_pitch$[ebp]
  003a9	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  003ac	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  003b0	89 8d 6c ff ff
	ff		 mov	 DWORD PTR _cy4x1$34[ebp], ecx

; 623  : 
; 624  :                     int cy1x0 = (cy0x0 * 1 + cy2x0 * 3 + 2);

  003b6	6b 95 7c ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x0$38[ebp], 3
  003bd	8b 45 80	 mov	 eax, DWORD PTR _cy0x0$39[ebp]
  003c0	8d 4c 10 02	 lea	 ecx, DWORD PTR [eax+edx+2]
  003c4	89 8d 68 ff ff
	ff		 mov	 DWORD PTR _cy1x0$33[ebp], ecx

; 625  :                     int cy3x0 = (cy2x0 * 3 + cy4x0 * 1 + 2);

  003ca	6b 95 7c ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x0$38[ebp], 3
  003d1	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _cy4x0$37[ebp]
  003d7	8d 4c 02 02	 lea	 ecx, DWORD PTR [edx+eax+2]
  003db	89 8d 64 ff ff
	ff		 mov	 DWORD PTR _cy3x0$32[ebp], ecx

; 626  :                     int cy1x1 = (cy0x1 * 1 + cy2x1 * 3 + 2);

  003e1	6b 95 70 ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x1$35[ebp], 3
  003e8	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _cy0x1$36[ebp]
  003ee	8d 4c 10 02	 lea	 ecx, DWORD PTR [eax+edx+2]
  003f2	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _cy1x1$31[ebp], ecx

; 627  :                     int cy3x1 = (cy2x1 * 3 + cy4x1 * 1 + 2);

  003f8	6b 95 70 ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x1$35[ebp], 3
  003ff	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _cy4x1$34[ebp]
  00405	8d 4c 02 02	 lea	 ecx, DWORD PTR [edx+eax+2]
  00409	89 8d 5c ff ff
	ff		 mov	 DWORD PTR _cy3x1$30[ebp], ecx

; 628  :                     CHANGE_BIT_DEPTH_4(cy1x0, cy3x0, cy1x1, cy3x1, 2);

  0040f	ba 01 00 00 00	 mov	 edx, 1
  00414	85 d2		 test	 edx, edx
  00416	74 3e		 je	 SHORT $LN32@convert_yv
  00418	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x0$33[ebp]
  0041e	c1 e0 04	 shl	 eax, 4
  00421	89 85 68 ff ff
	ff		 mov	 DWORD PTR _cy1x0$33[ebp], eax
  00427	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x0$32[ebp]
  0042d	c1 e1 04	 shl	 ecx, 4
  00430	89 8d 64 ff ff
	ff		 mov	 DWORD PTR _cy3x0$32[ebp], ecx
  00436	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x1$31[ebp]
  0043c	c1 e2 04	 shl	 edx, 4
  0043f	89 95 60 ff ff
	ff		 mov	 DWORD PTR _cy1x1$31[ebp], edx
  00445	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _cy3x1$30[ebp]
  0044b	c1 e0 04	 shl	 eax, 4
  0044e	89 85 5c ff ff
	ff		 mov	 DWORD PTR _cy3x1$30[ebp], eax
  00454	eb 40		 jmp	 SHORT $LN33@convert_yv
$LN32@convert_yv:
  00456	33 c9		 xor	 ecx, ecx
  00458	74 3c		 je	 SHORT $LN33@convert_yv
  0045a	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x0$33[ebp]
  00460	c1 fa fc	 sar	 edx, -4			; fffffffcH
  00463	89 95 68 ff ff
	ff		 mov	 DWORD PTR _cy1x0$33[ebp], edx
  00469	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$32[ebp]
  0046f	c1 f8 fc	 sar	 eax, -4			; fffffffcH
  00472	89 85 64 ff ff
	ff		 mov	 DWORD PTR _cy3x0$32[ebp], eax
  00478	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x1$31[ebp]
  0047e	c1 f9 fc	 sar	 ecx, -4			; fffffffcH
  00481	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _cy1x1$31[ebp], ecx
  00487	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR _cy3x1$30[ebp]
  0048d	c1 fa fc	 sar	 edx, -4			; fffffffcH
  00490	89 95 5c ff ff
	ff		 mov	 DWORD PTR _cy3x1$30[ebp], edx
$LN33@convert_yv:

; 629  : 
; 630  :                     dstC[0*dst_y_pitch   + 0] = (Tout)cy1x0;

  00496	6b 45 e4 00	 imul	 eax, DWORD PTR _dst_y_pitch$[ebp], 0
  0049a	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$44[ebp]
  0049d	66 8b 95 68 ff
	ff ff		 mov	 dx, WORD PTR _cy1x0$33[ebp]
  004a4	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx

; 631  :                     dstC[0*dst_y_pitch   + 1] = (Tout)((cy1x0 + cy1x1 + 1) >> 1);

  004a8	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x1$31[ebp]
  004ae	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x0$33[ebp]
  004b4	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  004b8	d1 fa		 sar	 edx, 1
  004ba	6b 45 e4 00	 imul	 eax, DWORD PTR _dst_y_pitch$[ebp], 0
  004be	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$44[ebp]
  004c1	66 89 54 41 02	 mov	 WORD PTR [ecx+eax*2+2], dx

; 632  :                     dstC[1*dst_y_pitch   + 0] = (Tout)cy3x0;

  004c6	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  004c9	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  004cc	66 8b 8d 64 ff
	ff ff		 mov	 cx, WORD PTR _cy3x0$32[ebp]
  004d3	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx

; 633  :                     dstC[1*dst_y_pitch   + 1] = (Tout)((cy3x0 + cy3x1 + 1) >> 1);

  004d7	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR _cy3x1$30[ebp]
  004dd	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$32[ebp]
  004e3	8d 4c 10 01	 lea	 ecx, DWORD PTR [eax+edx+1]
  004e7	d1 f9		 sar	 ecx, 1
  004e9	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  004ec	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  004ef	66 89 4c 50 02	 mov	 WORD PTR [eax+edx*2+2], cx

; 634  :                 }

  004f4	e9 02 fe ff ff	 jmp	 $LN14@convert_yv
$LN15@convert_yv:

; 635  :             } else if (y >= height-2) {

  004f9	e9 66 04 00 00	 jmp	 $LN31@convert_yv
$LN30@convert_yv:
  004fe	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00501	83 e9 02	 sub	 ecx, 2
  00504	39 4d 98	 cmp	 DWORD PTR _y$45[ebp], ecx
  00507	0f 8c 2f 02 00
	00		 jl	 $LN35@convert_yv

; 636  :                 for (int x = 0; x < x_fin; x += 2, dstC += 2, srcP++) {

  0050d	c7 85 58 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _x$29[ebp], 0
  00517	eb 21		 jmp	 SHORT $LN19@convert_yv
$LN17@convert_yv:
  00519	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _x$29[ebp]
  0051f	83 c2 02	 add	 edx, 2
  00522	89 95 58 ff ff
	ff		 mov	 DWORD PTR _x$29[ebp], edx
  00528	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  0052b	83 c0 04	 add	 eax, 4
  0052e	89 45 94	 mov	 DWORD PTR _dstC$44[ebp], eax
  00531	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$43[ebp]
  00534	83 c1 02	 add	 ecx, 2
  00537	89 4d 90	 mov	 DWORD PTR _srcP$43[ebp], ecx
$LN19@convert_yv:
  0053a	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _x$29[ebp]
  00540	3b 55 8c	 cmp	 edx, DWORD PTR _x_fin$42[ebp]
  00543	0f 8d ee 01 00
	00		 jge	 $LN18@convert_yv

; 637  :                     int cxplus = (x + 2 < x_fin);

  00549	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _x$29[ebp]
  0054f	83 c0 02	 add	 eax, 2
  00552	3b 45 8c	 cmp	 eax, DWORD PTR _x_fin$42[ebp]
  00555	7d 0c		 jge	 SHORT $LN46@convert_yv
  00557	c7 85 d8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv317[ebp], 1
  00561	eb 0a		 jmp	 SHORT $LN47@convert_yv
$LN46@convert_yv:
  00563	c7 85 d8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv317[ebp], 0
$LN47@convert_yv:
  0056d	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR tv317[ebp]
  00573	89 8d 54 ff ff
	ff		 mov	 DWORD PTR _cxplus$28[ebp], ecx

; 638  :                     int cy0x0 = srcP[-1*src_uv_pitch + 0];

  00579	6b 55 a8 ff	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], -1
  0057d	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  00580	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  00584	89 8d 50 ff ff
	ff		 mov	 DWORD PTR _cy0x0$27[ebp], ecx

; 639  :                     int cy2x0 = srcP[ 0*src_uv_pitch + 0];

  0058a	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  0058e	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  00591	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  00595	89 8d 4c ff ff
	ff		 mov	 DWORD PTR _cy2x0$26[ebp], ecx

; 640  :                     int cy4x0 = srcP[ 0*src_uv_pitch + 0];

  0059b	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  0059f	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  005a2	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  005a6	89 8d 48 ff ff
	ff		 mov	 DWORD PTR _cy4x0$25[ebp], ecx

; 641  :                     int cy0x1 = srcP[-1*src_uv_pitch + cxplus];

  005ac	6b 55 a8 ff	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], -1
  005b0	03 95 54 ff ff
	ff		 add	 edx, DWORD PTR _cxplus$28[ebp]
  005b6	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  005b9	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  005bd	89 8d 44 ff ff
	ff		 mov	 DWORD PTR _cy0x1$24[ebp], ecx

; 642  :                     int cy2x1 = srcP[ 0*src_uv_pitch + cxplus];

  005c3	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  005c7	03 95 54 ff ff
	ff		 add	 edx, DWORD PTR _cxplus$28[ebp]
  005cd	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  005d0	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  005d4	89 8d 40 ff ff
	ff		 mov	 DWORD PTR _cy2x1$23[ebp], ecx

; 643  :                     int cy4x1 = srcP[ 0*src_uv_pitch + cxplus];

  005da	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  005de	03 95 54 ff ff
	ff		 add	 edx, DWORD PTR _cxplus$28[ebp]
  005e4	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  005e7	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  005eb	89 8d 3c ff ff
	ff		 mov	 DWORD PTR _cy4x1$22[ebp], ecx

; 644  : 
; 645  :                     int cy1x0 = (cy0x0 * 1 + cy2x0 * 3 + 2);

  005f1	6b 95 4c ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x0$26[ebp], 3
  005f8	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _cy0x0$27[ebp]
  005fe	8d 4c 10 02	 lea	 ecx, DWORD PTR [eax+edx+2]
  00602	89 8d 38 ff ff
	ff		 mov	 DWORD PTR _cy1x0$21[ebp], ecx

; 646  :                     int cy3x0 = (cy2x0 * 3 + cy4x0 * 1 + 2);

  00608	6b 95 4c ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x0$26[ebp], 3
  0060f	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _cy4x0$25[ebp]
  00615	8d 4c 02 02	 lea	 ecx, DWORD PTR [edx+eax+2]
  00619	89 8d 34 ff ff
	ff		 mov	 DWORD PTR _cy3x0$20[ebp], ecx

; 647  :                     int cy1x1 = (cy0x1 * 1 + cy2x1 * 3 + 2);

  0061f	6b 95 40 ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x1$23[ebp], 3
  00626	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _cy0x1$24[ebp]
  0062c	8d 4c 10 02	 lea	 ecx, DWORD PTR [eax+edx+2]
  00630	89 8d 30 ff ff
	ff		 mov	 DWORD PTR _cy1x1$19[ebp], ecx

; 648  :                     int cy3x1 = (cy2x1 * 3 + cy4x1 * 1 + 2);

  00636	6b 95 40 ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x1$23[ebp], 3
  0063d	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _cy4x1$22[ebp]
  00643	8d 4c 02 02	 lea	 ecx, DWORD PTR [edx+eax+2]
  00647	89 8d 2c ff ff
	ff		 mov	 DWORD PTR _cy3x1$18[ebp], ecx

; 649  :                     CHANGE_BIT_DEPTH_4(cy1x0, cy3x0, cy1x1, cy3x1, 2);

  0064d	ba 01 00 00 00	 mov	 edx, 1
  00652	85 d2		 test	 edx, edx
  00654	74 3e		 je	 SHORT $LN37@convert_yv
  00656	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x0$21[ebp]
  0065c	c1 e0 04	 shl	 eax, 4
  0065f	89 85 38 ff ff
	ff		 mov	 DWORD PTR _cy1x0$21[ebp], eax
  00665	8b 8d 34 ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x0$20[ebp]
  0066b	c1 e1 04	 shl	 ecx, 4
  0066e	89 8d 34 ff ff
	ff		 mov	 DWORD PTR _cy3x0$20[ebp], ecx
  00674	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x1$19[ebp]
  0067a	c1 e2 04	 shl	 edx, 4
  0067d	89 95 30 ff ff
	ff		 mov	 DWORD PTR _cy1x1$19[ebp], edx
  00683	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR _cy3x1$18[ebp]
  00689	c1 e0 04	 shl	 eax, 4
  0068c	89 85 2c ff ff
	ff		 mov	 DWORD PTR _cy3x1$18[ebp], eax
  00692	eb 40		 jmp	 SHORT $LN38@convert_yv
$LN37@convert_yv:
  00694	33 c9		 xor	 ecx, ecx
  00696	74 3c		 je	 SHORT $LN38@convert_yv
  00698	8b 95 38 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x0$21[ebp]
  0069e	c1 fa fc	 sar	 edx, -4			; fffffffcH
  006a1	89 95 38 ff ff
	ff		 mov	 DWORD PTR _cy1x0$21[ebp], edx
  006a7	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$20[ebp]
  006ad	c1 f8 fc	 sar	 eax, -4			; fffffffcH
  006b0	89 85 34 ff ff
	ff		 mov	 DWORD PTR _cy3x0$20[ebp], eax
  006b6	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x1$19[ebp]
  006bc	c1 f9 fc	 sar	 ecx, -4			; fffffffcH
  006bf	89 8d 30 ff ff
	ff		 mov	 DWORD PTR _cy1x1$19[ebp], ecx
  006c5	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR _cy3x1$18[ebp]
  006cb	c1 fa fc	 sar	 edx, -4			; fffffffcH
  006ce	89 95 2c ff ff
	ff		 mov	 DWORD PTR _cy3x1$18[ebp], edx
$LN38@convert_yv:

; 650  : 
; 651  :                     dstC[0*dst_y_pitch   + 0] = (Tout)cy1x0;

  006d4	6b 45 e4 00	 imul	 eax, DWORD PTR _dst_y_pitch$[ebp], 0
  006d8	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$44[ebp]
  006db	66 8b 95 38 ff
	ff ff		 mov	 dx, WORD PTR _cy1x0$21[ebp]
  006e2	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx

; 652  :                     dstC[0*dst_y_pitch   + 1] = (Tout)((cy1x0 + cy1x1 + 1) >> 1);

  006e6	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x1$19[ebp]
  006ec	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x0$21[ebp]
  006f2	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  006f6	d1 fa		 sar	 edx, 1
  006f8	6b 45 e4 00	 imul	 eax, DWORD PTR _dst_y_pitch$[ebp], 0
  006fc	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$44[ebp]
  006ff	66 89 54 41 02	 mov	 WORD PTR [ecx+eax*2+2], dx

; 653  :                     dstC[1*dst_y_pitch   + 0] = (Tout)cy3x0;

  00704	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  00707	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  0070a	66 8b 8d 34 ff
	ff ff		 mov	 cx, WORD PTR _cy3x0$20[ebp]
  00711	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx

; 654  :                     dstC[1*dst_y_pitch   + 1] = (Tout)((cy3x0 + cy3x1 + 1) >> 1);

  00715	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR _cy3x1$18[ebp]
  0071b	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$20[ebp]
  00721	8d 4c 10 01	 lea	 ecx, DWORD PTR [eax+edx+1]
  00725	d1 f9		 sar	 ecx, 1
  00727	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  0072a	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  0072d	66 89 4c 50 02	 mov	 WORD PTR [eax+edx*2+2], cx

; 655  :                 }

  00732	e9 e2 fd ff ff	 jmp	 $LN17@convert_yv
$LN18@convert_yv:

; 656  :             } else {

  00737	e9 28 02 00 00	 jmp	 $LN31@convert_yv
$LN35@convert_yv:

; 657  :                 for (int x = 0; x < x_fin; x += 2, dstC += 2, srcP++) {

  0073c	c7 85 28 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _x$17[ebp], 0
  00746	eb 21		 jmp	 SHORT $LN22@convert_yv
$LN20@convert_yv:
  00748	8b 8d 28 ff ff
	ff		 mov	 ecx, DWORD PTR _x$17[ebp]
  0074e	83 c1 02	 add	 ecx, 2
  00751	89 8d 28 ff ff
	ff		 mov	 DWORD PTR _x$17[ebp], ecx
  00757	8b 55 94	 mov	 edx, DWORD PTR _dstC$44[ebp]
  0075a	83 c2 04	 add	 edx, 4
  0075d	89 55 94	 mov	 DWORD PTR _dstC$44[ebp], edx
  00760	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  00763	83 c0 02	 add	 eax, 2
  00766	89 45 90	 mov	 DWORD PTR _srcP$43[ebp], eax
$LN22@convert_yv:
  00769	8b 8d 28 ff ff
	ff		 mov	 ecx, DWORD PTR _x$17[ebp]
  0076f	3b 4d 8c	 cmp	 ecx, DWORD PTR _x_fin$42[ebp]
  00772	0f 8d ec 01 00
	00		 jge	 $LN31@convert_yv

; 658  :                     int cxplus = (x + 2 < x_fin);

  00778	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR _x$17[ebp]
  0077e	83 c2 02	 add	 edx, 2
  00781	3b 55 8c	 cmp	 edx, DWORD PTR _x_fin$42[ebp]
  00784	7d 0c		 jge	 SHORT $LN48@convert_yv
  00786	c7 85 d4 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv432[ebp], 1
  00790	eb 0a		 jmp	 SHORT $LN49@convert_yv
$LN48@convert_yv:
  00792	c7 85 d4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv432[ebp], 0
$LN49@convert_yv:
  0079c	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR tv432[ebp]
  007a2	89 85 24 ff ff
	ff		 mov	 DWORD PTR _cxplus$16[ebp], eax

; 659  :                     int cy0x0 = srcP[-1*src_uv_pitch + 0];

  007a8	6b 4d a8 ff	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], -1
  007ac	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  007af	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  007b3	89 85 20 ff ff
	ff		 mov	 DWORD PTR _cy0x0$15[ebp], eax

; 660  :                     int cy2x0 = srcP[ 0*src_uv_pitch + 0];

  007b9	6b 4d a8 00	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 0
  007bd	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  007c0	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  007c4	89 85 1c ff ff
	ff		 mov	 DWORD PTR _cy2x0$14[ebp], eax

; 661  :                     int cy4x0 = srcP[ 1*src_uv_pitch + 0];

  007ca	8b 4d a8	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  007cd	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  007d0	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  007d4	89 85 18 ff ff
	ff		 mov	 DWORD PTR _cy4x0$13[ebp], eax

; 662  :                     int cy0x1 = srcP[-1*src_uv_pitch + cxplus];

  007da	6b 4d a8 ff	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], -1
  007de	03 8d 24 ff ff
	ff		 add	 ecx, DWORD PTR _cxplus$16[ebp]
  007e4	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  007e7	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  007eb	89 85 14 ff ff
	ff		 mov	 DWORD PTR _cy0x1$12[ebp], eax

; 663  :                     int cy2x1 = srcP[ 0*src_uv_pitch + cxplus];

  007f1	6b 4d a8 00	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 0
  007f5	03 8d 24 ff ff
	ff		 add	 ecx, DWORD PTR _cxplus$16[ebp]
  007fb	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  007fe	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00802	89 85 10 ff ff
	ff		 mov	 DWORD PTR _cy2x1$11[ebp], eax

; 664  :                     int cy4x1 = srcP[ 1*src_uv_pitch + cxplus];

  00808	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR _cxplus$16[ebp]
  0080e	03 4d a8	 add	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00811	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  00814	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00818	89 85 0c ff ff
	ff		 mov	 DWORD PTR _cy4x1$10[ebp], eax

; 665  : 
; 666  :                     int cy1x0 = (cy0x0 * 1 + cy2x0 * 3 + 2);

  0081e	6b 8d 1c ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy2x0$14[ebp], 3
  00825	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR _cy0x0$15[ebp]
  0082b	8d 44 0a 02	 lea	 eax, DWORD PTR [edx+ecx+2]
  0082f	89 85 08 ff ff
	ff		 mov	 DWORD PTR _cy1x0$9[ebp], eax

; 667  :                     int cy3x0 = (cy2x0 * 3 + cy4x0 * 1 + 2);

  00835	6b 8d 1c ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy2x0$14[ebp], 3
  0083c	8b 95 18 ff ff
	ff		 mov	 edx, DWORD PTR _cy4x0$13[ebp]
  00842	8d 44 11 02	 lea	 eax, DWORD PTR [ecx+edx+2]
  00846	89 85 04 ff ff
	ff		 mov	 DWORD PTR _cy3x0$8[ebp], eax

; 668  :                     int cy1x1 = (cy0x1 * 1 + cy2x1 * 3 + 2);

  0084c	6b 8d 10 ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy2x1$11[ebp], 3
  00853	8b 95 14 ff ff
	ff		 mov	 edx, DWORD PTR _cy0x1$12[ebp]
  00859	8d 44 0a 02	 lea	 eax, DWORD PTR [edx+ecx+2]
  0085d	89 85 00 ff ff
	ff		 mov	 DWORD PTR _cy1x1$7[ebp], eax

; 669  :                     int cy3x1 = (cy2x1 * 3 + cy4x1 * 1 + 2);

  00863	6b 8d 10 ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy2x1$11[ebp], 3
  0086a	8b 95 0c ff ff
	ff		 mov	 edx, DWORD PTR _cy4x1$10[ebp]
  00870	8d 44 11 02	 lea	 eax, DWORD PTR [ecx+edx+2]
  00874	89 85 fc fe ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], eax

; 670  :                     CHANGE_BIT_DEPTH_4(cy1x0, cy3x0, cy1x1, cy3x1, 2);

  0087a	b9 01 00 00 00	 mov	 ecx, 1
  0087f	85 c9		 test	 ecx, ecx
  00881	74 3e		 je	 SHORT $LN40@convert_yv
  00883	8b 95 08 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x0$9[ebp]
  00889	c1 e2 04	 shl	 edx, 4
  0088c	89 95 08 ff ff
	ff		 mov	 DWORD PTR _cy1x0$9[ebp], edx
  00892	8b 85 04 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$8[ebp]
  00898	c1 e0 04	 shl	 eax, 4
  0089b	89 85 04 ff ff
	ff		 mov	 DWORD PTR _cy3x0$8[ebp], eax
  008a1	8b 8d 00 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x1$7[ebp]
  008a7	c1 e1 04	 shl	 ecx, 4
  008aa	89 8d 00 ff ff
	ff		 mov	 DWORD PTR _cy1x1$7[ebp], ecx
  008b0	8b 95 fc fe ff
	ff		 mov	 edx, DWORD PTR _cy3x1$6[ebp]
  008b6	c1 e2 04	 shl	 edx, 4
  008b9	89 95 fc fe ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], edx
  008bf	eb 40		 jmp	 SHORT $LN41@convert_yv
$LN40@convert_yv:
  008c1	33 c0		 xor	 eax, eax
  008c3	74 3c		 je	 SHORT $LN41@convert_yv
  008c5	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x0$9[ebp]
  008cb	c1 f9 fc	 sar	 ecx, -4			; fffffffcH
  008ce	89 8d 08 ff ff
	ff		 mov	 DWORD PTR _cy1x0$9[ebp], ecx
  008d4	8b 95 04 ff ff
	ff		 mov	 edx, DWORD PTR _cy3x0$8[ebp]
  008da	c1 fa fc	 sar	 edx, -4			; fffffffcH
  008dd	89 95 04 ff ff
	ff		 mov	 DWORD PTR _cy3x0$8[ebp], edx
  008e3	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x1$7[ebp]
  008e9	c1 f8 fc	 sar	 eax, -4			; fffffffcH
  008ec	89 85 00 ff ff
	ff		 mov	 DWORD PTR _cy1x1$7[ebp], eax
  008f2	8b 8d fc fe ff
	ff		 mov	 ecx, DWORD PTR _cy3x1$6[ebp]
  008f8	c1 f9 fc	 sar	 ecx, -4			; fffffffcH
  008fb	89 8d fc fe ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], ecx
$LN41@convert_yv:

; 671  : 
; 672  :                     dstC[0*dst_y_pitch   + 0] = (Tout)cy1x0;

  00901	6b 55 e4 00	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 0
  00905	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  00908	66 8b 8d 08 ff
	ff ff		 mov	 cx, WORD PTR _cy1x0$9[ebp]
  0090f	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx

; 673  :                     dstC[0*dst_y_pitch   + 1] = (Tout)((cy1x0 + cy1x1 + 1) >> 1);

  00913	8b 95 00 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x1$7[ebp]
  00919	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x0$9[ebp]
  0091f	8d 4c 10 01	 lea	 ecx, DWORD PTR [eax+edx+1]
  00923	d1 f9		 sar	 ecx, 1
  00925	6b 55 e4 00	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 0
  00929	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  0092c	66 89 4c 50 02	 mov	 WORD PTR [eax+edx*2+2], cx

; 674  :                     dstC[1*dst_y_pitch   + 0] = (Tout)cy3x0;

  00931	8b 4d e4	 mov	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  00934	8b 55 94	 mov	 edx, DWORD PTR _dstC$44[ebp]
  00937	66 8b 85 04 ff
	ff ff		 mov	 ax, WORD PTR _cy3x0$8[ebp]
  0093e	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax

; 675  :                     dstC[1*dst_y_pitch   + 1] = (Tout)((cy3x0 + cy3x1 + 1) >> 1);

  00942	8b 8d fc fe ff
	ff		 mov	 ecx, DWORD PTR _cy3x1$6[ebp]
  00948	8b 95 04 ff ff
	ff		 mov	 edx, DWORD PTR _cy3x0$8[ebp]
  0094e	8d 44 0a 01	 lea	 eax, DWORD PTR [edx+ecx+1]
  00952	d1 f8		 sar	 eax, 1
  00954	8b 4d e4	 mov	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  00957	8b 55 94	 mov	 edx, DWORD PTR _dstC$44[ebp]
  0095a	66 89 44 4a 02	 mov	 WORD PTR [edx+ecx*2+2], ax

; 676  :                 }

  0095f	e9 e4 fd ff ff	 jmp	 $LN20@convert_yv
$LN31@convert_yv:

; 677  :             }
; 678  :         }

  00964	e9 38 f9 ff ff	 jmp	 $LN11@convert_yv
$LN12@convert_yv:

; 679  :     }

  00969	e9 e6 f8 ff ff	 jmp	 $LN8@convert_yv
$LN1@convert_yv:

; 680  : }

  0096e	52		 push	 edx
  0096f	8b cd		 mov	 ecx, ebp
  00971	50		 push	 eax
  00972	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN52@convert_yv
  00978	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0097d	58		 pop	 eax
  0097e	5a		 pop	 edx
  0097f	5f		 pop	 edi
  00980	5e		 pop	 esi
  00981	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00984	33 cd		 xor	 ecx, ebp
  00986	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0098b	81 c4 2c 01 00
	00		 add	 esp, 300		; 0000012cH
  00991	3b ec		 cmp	 ebp, esp
  00993	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00998	8b e5		 mov	 esp, ebp
  0099a	5d		 pop	 ebp
  0099b	c3		 ret	 0
$LN52@convert_yv:
  0099c	01 00 00 00	 DD	 1
  009a0	00 00 00 00	 DD	 $LN51@convert_yv
$LN51@convert_yv:
  009a4	d4 ff ff ff	 DD	 -44			; ffffffd4H
  009a8	0c 00 00 00	 DD	 12			; 0000000cH
  009ac	00 00 00 00	 DD	 $LN50@convert_yv
$LN50@convert_yv:
  009b0	79		 DB	 121			; 00000079H
  009b1	5f		 DB	 95			; 0000005fH
  009b2	72		 DB	 114			; 00000072H
  009b3	61		 DB	 97			; 00000061H
  009b4	6e		 DB	 110			; 0000006eH
  009b5	67		 DB	 103			; 00000067H
  009b6	65		 DB	 101			; 00000065H
  009b7	00		 DB	 0
??$convert_yv12_p_to_yuv444_c@G$09G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_p_to_yuv444_c<unsigned short,10,unsigned short,16,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yv12_10_p_to_yuv444_16bit@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_10_p_to_yuv444_16bit

; 857  : static void convert_yv12_10_p_to_yuv444_16bit(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 858  :     convert_yv12_p_to_yuv444_c<uint16_t, 10, uint16_t, 16, false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yv12_p_to_yuv444_c@G$09G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_p_to_yuv444_c<unsigned short,10,unsigned short,16,0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 859  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yv12_10_p_to_yuv444_16bit@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_10_p_to_yuv444_16bit
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
tv302 = -280						; size = 4
tv240 = -276						; size = 4
tv241 = -272						; size = 4
tv235 = -268						; size = 4
tv232 = -264						; size = 4
tv229 = -260						; size = 4
tv227 = -256						; size = 4
$T1 = -252						; size = 4
$T2 = -248						; size = 4
$T3 = -244						; size = 4
$T4 = -240						; size = 4
$T5 = -236						; size = 12
_cy3x1$6 = -224						; size = 4
_cy2x1$7 = -220						; size = 4
_cy1x1$8 = -216						; size = 4
_cy0x1$9 = -212						; size = 4
_sy5x1$10 = -208					; size = 4
_sy4x1$11 = -204					; size = 4
_sy3x1$12 = -200					; size = 4
_sy2x1$13 = -196					; size = 4
_sy1x1$14 = -192					; size = 4
_sy0x1$15 = -188					; size = 4
_cxplus$16 = -184					; size = 4
_x$17 = -180						; size = 4
_cy3x0$18 = -176					; size = 4
_cy2x0$19 = -172					; size = 4
_cy1x0$20 = -168					; size = 4
_cy0x0$21 = -164					; size = 4
_sy5x0$22 = -160					; size = 4
_sy4x0$23 = -156					; size = 4
_sy3x0$24 = -152					; size = 4
_sy2x0$25 = -148					; size = 4
_sy1x0$26 = -144					; size = 4
_sy0x0$27 = -140					; size = 4
_y_p3$28 = -136						; size = 4
_y_p2$29 = -132						; size = 4
_y_p1$30 = -128						; size = 4
_y_m1$31 = -124						; size = 4
_y_m2$32 = -120						; size = 4
_x_fin$33 = -116					; size = 4
_srcP$34 = -112						; size = 4
_dstC$35 = -108						; size = 4
_y$36 = -104						; size = 4
_dstLine$37 = -100					; size = 4
_srcCLine$38 = -96					; size = 4
_ic$39 = -92						; size = 4
_src_uv_pitch$ = -88					; size = 4
_uv_fin$ = -84						; size = 4
_x$40 = -80						; size = 4
_y$41 = -76						; size = 4
_y_width$42 = -72					; size = 4
_dstLine$43 = -68					; size = 4
_srcYLine$44 = -64					; size = 4
$T45 = -60						; size = 12
_y_range$ = -44						; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yv12_i_to_yuv444_c@G$0M@G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_i_to_yuv444_c<unsigned short,12,unsigned short,16,0>

; 683  : static void __forceinline convert_yv12_i_to_yuv444_c(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8d bd e8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-280]
  00011	b9 46 00 00 00	 mov	 ecx, 70			; 00000046H
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 684  :     static_assert((sizeof(Tin)  == 1 && in_bit_depth  == 8) || (sizeof(Tin)  == 2 && 8 < in_bit_depth  && in_bit_depth  <= 16), "invalid input bit depth.");
; 685  :     static_assert((sizeof(Tout) == 1 && out_bit_depth == 8) || (sizeof(Tout) == 2 && 8 < out_bit_depth && out_bit_depth <= 16), "invalid output bit depth.");
; 686  :     const int crop_left   = crop[0];

  00027	b8 04 00 00 00	 mov	 eax, 4
  0002c	6b c8 00	 imul	 ecx, eax, 0
  0002f	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00032	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00035	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 687  :     const int crop_up     = crop[1];

  00038	b9 04 00 00 00	 mov	 ecx, 4
  0003d	c1 e1 00	 shl	 ecx, 0
  00040	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00043	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00046	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 688  :     const int crop_right  = crop[2];

  00049	b9 04 00 00 00	 mov	 ecx, 4
  0004e	d1 e1		 shl	 ecx, 1
  00050	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00053	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00056	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 689  :     const int crop_bottom = crop[3];

  00059	b9 04 00 00 00	 mov	 ecx, 4
  0005e	6b d1 03	 imul	 edx, ecx, 3
  00061	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00064	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00067	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 690  :     const int src_y_pitch = src_y_pitch_byte / sizeof(Tin);

  0006a	8b 55 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebp]
  0006d	d1 ea		 shr	 edx, 1
  0006f	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 691  :     const int dst_y_pitch = dst_y_pitch_byte / sizeof(Tout);

  00072	8b 45 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  00075	d1 e8		 shr	 eax, 1
  00077	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 692  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  0007a	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0007d	51		 push	 ecx
  0007e	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  00081	52		 push	 edx
  00082	8b 45 20	 mov	 eax, DWORD PTR _height$[ebp]
  00085	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  00088	50		 push	 eax
  00089	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  0008c	51		 push	 ecx
  0008d	8d 95 14 ff ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  00093	52		 push	 edx
  00094	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00099	83 c4 14	 add	 esp, 20			; 00000014H
  0009c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009e	89 4d c4	 mov	 DWORD PTR $T45[ebp], ecx
  000a1	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a4	89 55 c8	 mov	 DWORD PTR $T45[ebp+4], edx
  000a7	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000aa	89 45 cc	 mov	 DWORD PTR $T45[ebp+8], eax
  000ad	8b 4d c4	 mov	 ecx, DWORD PTR $T45[ebp]
  000b0	89 4d d4	 mov	 DWORD PTR _y_range$[ebp], ecx
  000b3	8b 55 c8	 mov	 edx, DWORD PTR $T45[ebp+4]
  000b6	89 55 d8	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000b9	8b 45 cc	 mov	 eax, DWORD PTR $T45[ebp+8]
  000bc	89 45 dc	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 693  :     //Y
; 694  :     if (!uv_only) {

  000bf	b9 01 00 00 00	 mov	 ecx, 1
  000c4	85 c9		 test	 ecx, ecx
  000c6	0f 84 6e 01 00
	00		 je	 $LN17@convert_yv

; 695  :         Tin *srcYLine = (Tin *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000cc	ba 04 00 00 00	 mov	 edx, 4
  000d1	6b c2 00	 imul	 eax, edx, 0
  000d4	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  000d7	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  000db	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  000de	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  000e1	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  000e4	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  000e7	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  000ea	89 45 c0	 mov	 DWORD PTR _srcYLine$44[ebp], eax

; 696  :         Tout *dstLine = (Tout *)dst[0] + dst_y_pitch * y_range.start_dst;

  000ed	b9 04 00 00 00	 mov	 ecx, 4
  000f2	6b d1 00	 imul	 edx, ecx, 0
  000f5	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  000f8	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  000fc	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  000ff	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  00102	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  00105	89 45 bc	 mov	 DWORD PTR _dstLine$43[ebp], eax

; 697  :         const int y_width = width - crop_right - crop_left;

  00108	8b 4d 10	 mov	 ecx, DWORD PTR _width$[ebp]
  0010b	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  0010e	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  00111	89 4d b8	 mov	 DWORD PTR _y_width$42[ebp], ecx

; 698  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  00114	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _y$41[ebp], 0
  0011b	eb 21		 jmp	 SHORT $LN4@convert_yv
$LN2@convert_yv:
  0011d	8b 55 b4	 mov	 edx, DWORD PTR _y$41[ebp]
  00120	83 c2 01	 add	 edx, 1
  00123	89 55 b4	 mov	 DWORD PTR _y$41[ebp], edx
  00126	8b 45 e8	 mov	 eax, DWORD PTR _src_y_pitch$[ebp]
  00129	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$44[ebp]
  0012c	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  0012f	89 55 c0	 mov	 DWORD PTR _srcYLine$44[ebp], edx
  00132	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  00135	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$43[ebp]
  00138	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  0013b	89 55 bc	 mov	 DWORD PTR _dstLine$43[ebp], edx
$LN4@convert_yv:
  0013e	8b 45 b4	 mov	 eax, DWORD PTR _y$41[ebp]
  00141	3b 45 dc	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  00144	0f 8d f0 00 00
	00		 jge	 $LN17@convert_yv

; 699  :             if (in_bit_depth == out_bit_depth) {

  0014a	33 c9		 xor	 ecx, ecx
  0014c	74 1b		 je	 SHORT $LN18@convert_yv

; 700  :                 memcpy(dstLine, srcYLine, y_width * sizeof(Tin));

  0014e	8b 55 b8	 mov	 edx, DWORD PTR _y_width$42[ebp]
  00151	d1 e2		 shl	 edx, 1
  00153	52		 push	 edx
  00154	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$44[ebp]
  00157	50		 push	 eax
  00158	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$43[ebp]
  0015b	51		 push	 ecx
  0015c	e8 00 00 00 00	 call	 _memcpy
  00161	83 c4 0c	 add	 esp, 12			; 0000000cH

; 701  :             } else {

  00164	e9 cc 00 00 00	 jmp	 $LN19@convert_yv
$LN18@convert_yv:

; 702  :                 for (int x = 0; x < y_width; x++) {

  00169	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _x$40[ebp], 0
  00170	eb 09		 jmp	 SHORT $LN7@convert_yv
$LN5@convert_yv:
  00172	8b 55 b0	 mov	 edx, DWORD PTR _x$40[ebp]
  00175	83 c2 01	 add	 edx, 1
  00178	89 55 b0	 mov	 DWORD PTR _x$40[ebp], edx
$LN7@convert_yv:
  0017b	8b 45 b0	 mov	 eax, DWORD PTR _x$40[ebp]
  0017e	3b 45 b8	 cmp	 eax, DWORD PTR _y_width$42[ebp]
  00181	0f 8d ae 00 00
	00		 jge	 $LN19@convert_yv

; 703  :                     if (out_bit_depth > in_bit_depth) {

  00187	b9 01 00 00 00	 mov	 ecx, 1
  0018c	85 c9		 test	 ecx, ecx
  0018e	74 44		 je	 SHORT $LN20@convert_yv

; 704  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) << std::max(out_bit_depth - in_bit_depth, 0));

  00190	c7 85 10 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], 0
  0019a	c7 85 0c ff ff
	ff 04 00 00 00	 mov	 DWORD PTR $T3[ebp], 4
  001a4	8b 55 b0	 mov	 edx, DWORD PTR _x$40[ebp]
  001a7	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$44[ebp]
  001aa	0f b7 34 50	 movzx	 esi, WORD PTR [eax+edx*2]
  001ae	8d 8d 10 ff ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  001b4	51		 push	 ecx
  001b5	8d 95 0c ff ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  001bb	52		 push	 edx
  001bc	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  001c1	83 c4 08	 add	 esp, 8
  001c4	8b 08		 mov	 ecx, DWORD PTR [eax]
  001c6	d3 e6		 shl	 esi, cl
  001c8	8b 45 b0	 mov	 eax, DWORD PTR _x$40[ebp]
  001cb	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$43[ebp]
  001ce	66 89 34 41	 mov	 WORD PTR [ecx+eax*2], si
  001d2	eb 5c		 jmp	 SHORT $LN21@convert_yv
$LN20@convert_yv:

; 705  :                     } else if (out_bit_depth < in_bit_depth) {

  001d4	33 d2		 xor	 edx, edx
  001d6	74 44		 je	 SHORT $LN22@convert_yv

; 706  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) >> std::max(in_bit_depth - out_bit_depth, 0));

  001d8	c7 85 08 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], 0
  001e2	c7 85 04 ff ff
	ff fc ff ff ff	 mov	 DWORD PTR $T1[ebp], -4	; fffffffcH
  001ec	8b 45 b0	 mov	 eax, DWORD PTR _x$40[ebp]
  001ef	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$44[ebp]
  001f2	0f b7 34 41	 movzx	 esi, WORD PTR [ecx+eax*2]
  001f6	8d 95 08 ff ff
	ff		 lea	 edx, DWORD PTR $T2[ebp]
  001fc	52		 push	 edx
  001fd	8d 85 04 ff ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  00203	50		 push	 eax
  00204	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  00209	83 c4 08	 add	 esp, 8
  0020c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0020e	d3 fe		 sar	 esi, cl
  00210	8b 4d b0	 mov	 ecx, DWORD PTR _x$40[ebp]
  00213	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$43[ebp]
  00216	66 89 34 4a	 mov	 WORD PTR [edx+ecx*2], si

; 707  :                     } else {

  0021a	eb 14		 jmp	 SHORT $LN21@convert_yv
$LN22@convert_yv:

; 708  :                         dstLine[x] = (Tout)srcYLine[x];

  0021c	8b 45 b0	 mov	 eax, DWORD PTR _x$40[ebp]
  0021f	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$43[ebp]
  00222	8b 55 b0	 mov	 edx, DWORD PTR _x$40[ebp]
  00225	8b 75 c0	 mov	 esi, DWORD PTR _srcYLine$44[ebp]
  00228	66 8b 14 56	 mov	 dx, WORD PTR [esi+edx*2]
  0022c	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx
$LN21@convert_yv:

; 709  :                     }
; 710  :                 }

  00230	e9 3d ff ff ff	 jmp	 $LN5@convert_yv
$LN19@convert_yv:

; 711  :             }
; 712  :         }

  00235	e9 e3 fe ff ff	 jmp	 $LN2@convert_yv
$LN17@convert_yv:

; 713  :     }
; 714  :     //UV
; 715  :     const int uv_fin = height - crop_bottom;

  0023a	8b 45 20	 mov	 eax, DWORD PTR _height$[ebp]
  0023d	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  00240	89 45 ac	 mov	 DWORD PTR _uv_fin$[ebp], eax

; 716  :     const int src_uv_pitch = src_uv_pitch_byte / sizeof(Tin);

  00243	8b 4d 18	 mov	 ecx, DWORD PTR _src_uv_pitch_byte$[ebp]
  00246	d1 e9		 shr	 ecx, 1
  00248	89 4d a8	 mov	 DWORD PTR _src_uv_pitch$[ebp], ecx

; 717  :     for (int ic = 1; ic < 3; ic++) {

  0024b	c7 45 a4 01 00
	00 00		 mov	 DWORD PTR _ic$39[ebp], 1
  00252	eb 09		 jmp	 SHORT $LN10@convert_yv
$LN8@convert_yv:
  00254	8b 55 a4	 mov	 edx, DWORD PTR _ic$39[ebp]
  00257	83 c2 01	 add	 edx, 1
  0025a	89 55 a4	 mov	 DWORD PTR _ic$39[ebp], edx
$LN10@convert_yv:
  0025d	83 7d a4 03	 cmp	 DWORD PTR _ic$39[ebp], 3
  00261	0f 8d bc 05 00
	00		 jge	 $LN1@convert_yv

; 718  :         Tin *srcCLine = (Tin *)src[ic] + (((src_uv_pitch * y_range.start_src) + crop_left) >> 1);

  00267	8b 45 a8	 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  0026a	0f af 45 d4	 imul	 eax, DWORD PTR _y_range$[ebp]
  0026e	03 45 f8	 add	 eax, DWORD PTR _crop_left$[ebp]
  00271	d1 f8		 sar	 eax, 1
  00273	8b 4d a4	 mov	 ecx, DWORD PTR _ic$39[ebp]
  00276	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  00279	8b 0c 8a	 mov	 ecx, DWORD PTR [edx+ecx*4]
  0027c	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  0027f	89 55 a0	 mov	 DWORD PTR _srcCLine$38[ebp], edx

; 719  :         Tout *dstLine = (Tout *)dst[ic] + dst_y_pitch * y_range.start_dst;

  00282	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  00285	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  00289	8b 4d a4	 mov	 ecx, DWORD PTR _ic$39[ebp]
  0028c	8b 55 08	 mov	 edx, DWORD PTR _dst$[ebp]
  0028f	8b 0c 8a	 mov	 ecx, DWORD PTR [edx+ecx*4]
  00292	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00295	89 55 9c	 mov	 DWORD PTR _dstLine$37[ebp], edx

; 720  :         for (int y = 0; y < y_range.len; y += 4, srcCLine += src_uv_pitch * 2, dstLine += dst_y_pitch * 4) {

  00298	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _y$36[ebp], 0
  0029f	eb 26		 jmp	 SHORT $LN13@convert_yv
$LN11@convert_yv:
  002a1	8b 45 98	 mov	 eax, DWORD PTR _y$36[ebp]
  002a4	83 c0 04	 add	 eax, 4
  002a7	89 45 98	 mov	 DWORD PTR _y$36[ebp], eax
  002aa	8b 4d a8	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  002ad	d1 e1		 shl	 ecx, 1
  002af	8b 55 a0	 mov	 edx, DWORD PTR _srcCLine$38[ebp]
  002b2	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  002b5	89 45 a0	 mov	 DWORD PTR _srcCLine$38[ebp], eax
  002b8	8b 4d e4	 mov	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  002bb	c1 e1 02	 shl	 ecx, 2
  002be	8b 55 9c	 mov	 edx, DWORD PTR _dstLine$37[ebp]
  002c1	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  002c4	89 45 9c	 mov	 DWORD PTR _dstLine$37[ebp], eax
$LN13@convert_yv:
  002c7	8b 4d 98	 mov	 ecx, DWORD PTR _y$36[ebp]
  002ca	3b 4d dc	 cmp	 ecx, DWORD PTR _y_range$[ebp+8]
  002cd	0f 8d 4b 05 00
	00		 jge	 $LN12@convert_yv

; 721  :             Tout *dstC = dstLine;

  002d3	8b 55 9c	 mov	 edx, DWORD PTR _dstLine$37[ebp]
  002d6	89 55 94	 mov	 DWORD PTR _dstC$35[ebp], edx

; 722  :             Tin *srcP = srcCLine;

  002d9	8b 45 a0	 mov	 eax, DWORD PTR _srcCLine$38[ebp]
  002dc	89 45 90	 mov	 DWORD PTR _srcP$34[ebp], eax

; 723  :             const int x_fin = width - crop_right - crop_left;

  002df	8b 4d 10	 mov	 ecx, DWORD PTR _width$[ebp]
  002e2	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  002e5	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  002e8	89 4d 8c	 mov	 DWORD PTR _x_fin$33[ebp], ecx

; 724  : 
; 725  :             int y_m2 = (y >= 4) ? -2 : 0;

  002eb	83 7d 98 04	 cmp	 DWORD PTR _y$36[ebp], 4
  002ef	7c 0c		 jl	 SHORT $LN31@convert_yv
  002f1	c7 85 00 ff ff
	ff fe ff ff ff	 mov	 DWORD PTR tv227[ebp], -2 ; fffffffeH
  002fb	eb 0a		 jmp	 SHORT $LN32@convert_yv
$LN31@convert_yv:
  002fd	c7 85 00 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv227[ebp], 0
$LN32@convert_yv:
  00307	8b 95 00 ff ff
	ff		 mov	 edx, DWORD PTR tv227[ebp]
  0030d	89 55 88	 mov	 DWORD PTR _y_m2$32[ebp], edx

; 726  :             int y_m1 = (y >= 2) ? -1 : 1;

  00310	83 7d 98 02	 cmp	 DWORD PTR _y$36[ebp], 2
  00314	7c 0c		 jl	 SHORT $LN33@convert_yv
  00316	c7 85 fc fe ff
	ff ff ff ff ff	 mov	 DWORD PTR tv229[ebp], -1
  00320	eb 0a		 jmp	 SHORT $LN34@convert_yv
$LN33@convert_yv:
  00322	c7 85 fc fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv229[ebp], 1
$LN34@convert_yv:
  0032c	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR tv229[ebp]
  00332	89 45 84	 mov	 DWORD PTR _y_m1$31[ebp], eax

; 727  :             int y_p1 = (y < uv_fin - 2) ? 1 : -1;

  00335	8b 4d ac	 mov	 ecx, DWORD PTR _uv_fin$[ebp]
  00338	83 e9 02	 sub	 ecx, 2
  0033b	39 4d 98	 cmp	 DWORD PTR _y$36[ebp], ecx
  0033e	7d 0c		 jge	 SHORT $LN35@convert_yv
  00340	c7 85 f8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv232[ebp], 1
  0034a	eb 0a		 jmp	 SHORT $LN36@convert_yv
$LN35@convert_yv:
  0034c	c7 85 f8 fe ff
	ff ff ff ff ff	 mov	 DWORD PTR tv232[ebp], -1
$LN36@convert_yv:
  00356	8b 95 f8 fe ff
	ff		 mov	 edx, DWORD PTR tv232[ebp]
  0035c	89 55 80	 mov	 DWORD PTR _y_p1$30[ebp], edx

; 728  :             int y_p2 = (y < uv_fin - 4) ? 2 :  0;

  0035f	8b 45 ac	 mov	 eax, DWORD PTR _uv_fin$[ebp]
  00362	83 e8 04	 sub	 eax, 4
  00365	39 45 98	 cmp	 DWORD PTR _y$36[ebp], eax
  00368	7d 0c		 jge	 SHORT $LN37@convert_yv
  0036a	c7 85 f4 fe ff
	ff 02 00 00 00	 mov	 DWORD PTR tv235[ebp], 2
  00374	eb 0a		 jmp	 SHORT $LN38@convert_yv
$LN37@convert_yv:
  00376	c7 85 f4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv235[ebp], 0
$LN38@convert_yv:
  00380	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR tv235[ebp]
  00386	89 8d 7c ff ff
	ff		 mov	 DWORD PTR _y_p2$29[ebp], ecx

; 729  :             int y_p3 = (y < uv_fin - 6) ? 3 : ((y < uv_fin - 2) ? 1 : -1);

  0038c	8b 55 ac	 mov	 edx, DWORD PTR _uv_fin$[ebp]
  0038f	83 ea 06	 sub	 edx, 6
  00392	39 55 98	 cmp	 DWORD PTR _y$36[ebp], edx
  00395	7d 0c		 jge	 SHORT $LN41@convert_yv
  00397	c7 85 f0 fe ff
	ff 03 00 00 00	 mov	 DWORD PTR tv241[ebp], 3
  003a1	eb 2d		 jmp	 SHORT $LN42@convert_yv
$LN41@convert_yv:
  003a3	8b 45 ac	 mov	 eax, DWORD PTR _uv_fin$[ebp]
  003a6	83 e8 02	 sub	 eax, 2
  003a9	39 45 98	 cmp	 DWORD PTR _y$36[ebp], eax
  003ac	7d 0c		 jge	 SHORT $LN39@convert_yv
  003ae	c7 85 ec fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv240[ebp], 1
  003b8	eb 0a		 jmp	 SHORT $LN40@convert_yv
$LN39@convert_yv:
  003ba	c7 85 ec fe ff
	ff ff ff ff ff	 mov	 DWORD PTR tv240[ebp], -1
$LN40@convert_yv:
  003c4	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR tv240[ebp]
  003ca	89 8d f0 fe ff
	ff		 mov	 DWORD PTR tv241[ebp], ecx
$LN42@convert_yv:
  003d0	8b 95 f0 fe ff
	ff		 mov	 edx, DWORD PTR tv241[ebp]
  003d6	89 95 78 ff ff
	ff		 mov	 DWORD PTR _y_p3$28[ebp], edx

; 730  : 
; 731  :             int sy0x0 = srcP[y_m2*src_uv_pitch + 0];

  003dc	8b 45 88	 mov	 eax, DWORD PTR _y_m2$32[ebp]
  003df	0f af 45 a8	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp]
  003e3	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  003e6	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  003ea	89 95 74 ff ff
	ff		 mov	 DWORD PTR _sy0x0$27[ebp], edx

; 732  :             int sy1x0 = srcP[y_m1*src_uv_pitch + 0];

  003f0	8b 45 84	 mov	 eax, DWORD PTR _y_m1$31[ebp]
  003f3	0f af 45 a8	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp]
  003f7	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  003fa	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  003fe	89 95 70 ff ff
	ff		 mov	 DWORD PTR _sy1x0$26[ebp], edx

; 733  :             int sy2x0 = srcP[   0*src_uv_pitch + 0];

  00404	6b 45 a8 00	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp], 0
  00408	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  0040b	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  0040f	89 95 6c ff ff
	ff		 mov	 DWORD PTR _sy2x0$25[ebp], edx

; 734  :             int sy3x0 = srcP[y_p1*src_uv_pitch + 0];

  00415	8b 45 80	 mov	 eax, DWORD PTR _y_p1$30[ebp]
  00418	0f af 45 a8	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp]
  0041c	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  0041f	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  00423	89 95 68 ff ff
	ff		 mov	 DWORD PTR _sy3x0$24[ebp], edx

; 735  :             int sy4x0 = srcP[y_p2*src_uv_pitch + 0];

  00429	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _y_p2$29[ebp]
  0042f	0f af 45 a8	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp]
  00433	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  00436	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  0043a	89 95 64 ff ff
	ff		 mov	 DWORD PTR _sy4x0$23[ebp], edx

; 736  :             int sy5x0 = srcP[y_p3*src_uv_pitch + 0];

  00440	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _y_p3$28[ebp]
  00446	0f af 45 a8	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp]
  0044a	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  0044d	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  00451	89 95 60 ff ff
	ff		 mov	 DWORD PTR _sy5x0$22[ebp], edx

; 737  : 
; 738  :             int cy0x0 = (sy0x0 * 1 + sy2x0 * 7 + 4);

  00457	6b 85 6c ff ff
	ff 07		 imul	 eax, DWORD PTR _sy2x0$25[ebp], 7
  0045e	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _sy0x0$27[ebp]
  00464	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00468	89 95 5c ff ff
	ff		 mov	 DWORD PTR _cy0x0$21[ebp], edx

; 739  :             int cy1x0 = (sy1x0 * 3 + sy3x0 * 5 + 4);

  0046e	6b 85 70 ff ff
	ff 03		 imul	 eax, DWORD PTR _sy1x0$26[ebp], 3
  00475	6b 8d 68 ff ff
	ff 05		 imul	 ecx, DWORD PTR _sy3x0$24[ebp], 5
  0047c	8d 54 08 04	 lea	 edx, DWORD PTR [eax+ecx+4]
  00480	89 95 58 ff ff
	ff		 mov	 DWORD PTR _cy1x0$20[ebp], edx

; 740  :             int cy2x0 = (sy2x0 * 5 + sy4x0 * 3 + 4);

  00486	6b 85 6c ff ff
	ff 05		 imul	 eax, DWORD PTR _sy2x0$25[ebp], 5
  0048d	6b 8d 64 ff ff
	ff 03		 imul	 ecx, DWORD PTR _sy4x0$23[ebp], 3
  00494	8d 54 08 04	 lea	 edx, DWORD PTR [eax+ecx+4]
  00498	89 95 54 ff ff
	ff		 mov	 DWORD PTR _cy2x0$19[ebp], edx

; 741  :             int cy3x0 = (sy3x0 * 7 + sy5x0 * 1 + 4);

  0049e	6b 85 68 ff ff
	ff 07		 imul	 eax, DWORD PTR _sy3x0$24[ebp], 7
  004a5	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _sy5x0$22[ebp]
  004ab	8d 54 08 04	 lea	 edx, DWORD PTR [eax+ecx+4]
  004af	89 95 50 ff ff
	ff		 mov	 DWORD PTR _cy3x0$18[ebp], edx

; 742  :             CHANGE_BIT_DEPTH_4(cy0x0, cy1x0, cy2x0, cy3x0, 3);

  004b5	b8 01 00 00 00	 mov	 eax, 1
  004ba	85 c0		 test	 eax, eax
  004bc	74 3a		 je	 SHORT $LN24@convert_yv
  004be	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _cy0x0$21[ebp]
  004c4	d1 e1		 shl	 ecx, 1
  004c6	89 8d 5c ff ff
	ff		 mov	 DWORD PTR _cy0x0$21[ebp], ecx
  004cc	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x0$20[ebp]
  004d2	d1 e2		 shl	 edx, 1
  004d4	89 95 58 ff ff
	ff		 mov	 DWORD PTR _cy1x0$20[ebp], edx
  004da	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR _cy2x0$19[ebp]
  004e0	d1 e0		 shl	 eax, 1
  004e2	89 85 54 ff ff
	ff		 mov	 DWORD PTR _cy2x0$19[ebp], eax
  004e8	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x0$18[ebp]
  004ee	d1 e1		 shl	 ecx, 1
  004f0	89 8d 50 ff ff
	ff		 mov	 DWORD PTR _cy3x0$18[ebp], ecx
  004f6	eb 40		 jmp	 SHORT $LN25@convert_yv
$LN24@convert_yv:
  004f8	33 d2		 xor	 edx, edx
  004fa	74 3c		 je	 SHORT $LN25@convert_yv
  004fc	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _cy0x0$21[ebp]
  00502	c1 f8 ff	 sar	 eax, -1
  00505	89 85 5c ff ff
	ff		 mov	 DWORD PTR _cy0x0$21[ebp], eax
  0050b	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x0$20[ebp]
  00511	c1 f9 ff	 sar	 ecx, -1
  00514	89 8d 58 ff ff
	ff		 mov	 DWORD PTR _cy1x0$20[ebp], ecx
  0051a	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR _cy2x0$19[ebp]
  00520	c1 fa ff	 sar	 edx, -1
  00523	89 95 54 ff ff
	ff		 mov	 DWORD PTR _cy2x0$19[ebp], edx
  00529	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$18[ebp]
  0052f	c1 f8 ff	 sar	 eax, -1
  00532	89 85 50 ff ff
	ff		 mov	 DWORD PTR _cy3x0$18[ebp], eax
$LN25@convert_yv:

; 743  : 
; 744  :             for (int x = 0; x < x_fin; x += 2, dstC += 2, srcP++) {

  00538	c7 85 4c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _x$17[ebp], 0
  00542	eb 21		 jmp	 SHORT $LN16@convert_yv
$LN14@convert_yv:
  00544	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _x$17[ebp]
  0054a	83 c1 02	 add	 ecx, 2
  0054d	89 8d 4c ff ff
	ff		 mov	 DWORD PTR _x$17[ebp], ecx
  00553	8b 55 94	 mov	 edx, DWORD PTR _dstC$35[ebp]
  00556	83 c2 04	 add	 edx, 4
  00559	89 55 94	 mov	 DWORD PTR _dstC$35[ebp], edx
  0055c	8b 45 90	 mov	 eax, DWORD PTR _srcP$34[ebp]
  0055f	83 c0 02	 add	 eax, 2
  00562	89 45 90	 mov	 DWORD PTR _srcP$34[ebp], eax
$LN16@convert_yv:
  00565	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _x$17[ebp]
  0056b	3b 4d 8c	 cmp	 ecx, DWORD PTR _x_fin$33[ebp]
  0056e	0f 8d a5 02 00
	00		 jge	 $LN15@convert_yv

; 745  :                 int cxplus = (x + 2 < x_fin);

  00574	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR _x$17[ebp]
  0057a	83 c2 02	 add	 edx, 2
  0057d	3b 55 8c	 cmp	 edx, DWORD PTR _x_fin$33[ebp]
  00580	7d 0c		 jge	 SHORT $LN43@convert_yv
  00582	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv302[ebp], 1
  0058c	eb 0a		 jmp	 SHORT $LN44@convert_yv
$LN43@convert_yv:
  0058e	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv302[ebp], 0
$LN44@convert_yv:
  00598	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv302[ebp]
  0059e	89 85 48 ff ff
	ff		 mov	 DWORD PTR _cxplus$16[ebp], eax

; 746  :                 int sy0x1 = srcP[y_m2*src_uv_pitch + cxplus];

  005a4	8b 4d 88	 mov	 ecx, DWORD PTR _y_m2$32[ebp]
  005a7	0f af 4d a8	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  005ab	03 8d 48 ff ff
	ff		 add	 ecx, DWORD PTR _cxplus$16[ebp]
  005b1	8b 55 90	 mov	 edx, DWORD PTR _srcP$34[ebp]
  005b4	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  005b8	89 85 44 ff ff
	ff		 mov	 DWORD PTR _sy0x1$15[ebp], eax

; 747  :                 int sy1x1 = srcP[y_m1*src_uv_pitch + cxplus];

  005be	8b 4d 84	 mov	 ecx, DWORD PTR _y_m1$31[ebp]
  005c1	0f af 4d a8	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  005c5	03 8d 48 ff ff
	ff		 add	 ecx, DWORD PTR _cxplus$16[ebp]
  005cb	8b 55 90	 mov	 edx, DWORD PTR _srcP$34[ebp]
  005ce	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  005d2	89 85 40 ff ff
	ff		 mov	 DWORD PTR _sy1x1$14[ebp], eax

; 748  :                 int sy2x1 = srcP[   0*src_uv_pitch + cxplus];

  005d8	6b 4d a8 00	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 0
  005dc	03 8d 48 ff ff
	ff		 add	 ecx, DWORD PTR _cxplus$16[ebp]
  005e2	8b 55 90	 mov	 edx, DWORD PTR _srcP$34[ebp]
  005e5	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  005e9	89 85 3c ff ff
	ff		 mov	 DWORD PTR _sy2x1$13[ebp], eax

; 749  :                 int sy3x1 = srcP[y_p1*src_uv_pitch + cxplus];

  005ef	8b 4d 80	 mov	 ecx, DWORD PTR _y_p1$30[ebp]
  005f2	0f af 4d a8	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  005f6	03 8d 48 ff ff
	ff		 add	 ecx, DWORD PTR _cxplus$16[ebp]
  005fc	8b 55 90	 mov	 edx, DWORD PTR _srcP$34[ebp]
  005ff	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00603	89 85 38 ff ff
	ff		 mov	 DWORD PTR _sy3x1$12[ebp], eax

; 750  :                 int sy4x1 = srcP[y_p2*src_uv_pitch + cxplus];

  00609	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _y_p2$29[ebp]
  0060f	0f af 4d a8	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00613	03 8d 48 ff ff
	ff		 add	 ecx, DWORD PTR _cxplus$16[ebp]
  00619	8b 55 90	 mov	 edx, DWORD PTR _srcP$34[ebp]
  0061c	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00620	89 85 34 ff ff
	ff		 mov	 DWORD PTR _sy4x1$11[ebp], eax

; 751  :                 int sy5x1 = srcP[y_p3*src_uv_pitch + cxplus];

  00626	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _y_p3$28[ebp]
  0062c	0f af 4d a8	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00630	03 8d 48 ff ff
	ff		 add	 ecx, DWORD PTR _cxplus$16[ebp]
  00636	8b 55 90	 mov	 edx, DWORD PTR _srcP$34[ebp]
  00639	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  0063d	89 85 30 ff ff
	ff		 mov	 DWORD PTR _sy5x1$10[ebp], eax

; 752  : 
; 753  :                 int cy0x1 = (sy0x1 * 1 + sy2x1 * 7 + 4);

  00643	6b 8d 3c ff ff
	ff 07		 imul	 ecx, DWORD PTR _sy2x1$13[ebp], 7
  0064a	8b 95 44 ff ff
	ff		 mov	 edx, DWORD PTR _sy0x1$15[ebp]
  00650	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  00654	89 85 2c ff ff
	ff		 mov	 DWORD PTR _cy0x1$9[ebp], eax

; 754  :                 int cy1x1 = (sy1x1 * 3 + sy3x1 * 5 + 4);

  0065a	6b 8d 40 ff ff
	ff 03		 imul	 ecx, DWORD PTR _sy1x1$14[ebp], 3
  00661	6b 95 38 ff ff
	ff 05		 imul	 edx, DWORD PTR _sy3x1$12[ebp], 5
  00668	8d 44 11 04	 lea	 eax, DWORD PTR [ecx+edx+4]
  0066c	89 85 28 ff ff
	ff		 mov	 DWORD PTR _cy1x1$8[ebp], eax

; 755  :                 int cy2x1 = (sy2x1 * 5 + sy4x1 * 3 + 4);

  00672	6b 8d 3c ff ff
	ff 05		 imul	 ecx, DWORD PTR _sy2x1$13[ebp], 5
  00679	6b 95 34 ff ff
	ff 03		 imul	 edx, DWORD PTR _sy4x1$11[ebp], 3
  00680	8d 44 11 04	 lea	 eax, DWORD PTR [ecx+edx+4]
  00684	89 85 24 ff ff
	ff		 mov	 DWORD PTR _cy2x1$7[ebp], eax

; 756  :                 int cy3x1 = (sy3x1 * 7 + sy5x1 * 1 + 4);

  0068a	6b 8d 38 ff ff
	ff 07		 imul	 ecx, DWORD PTR _sy3x1$12[ebp], 7
  00691	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR _sy5x1$10[ebp]
  00697	8d 44 11 04	 lea	 eax, DWORD PTR [ecx+edx+4]
  0069b	89 85 20 ff ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], eax

; 757  :                 CHANGE_BIT_DEPTH_4(cy0x1, cy1x1, cy2x1, cy3x1, 3);

  006a1	b9 01 00 00 00	 mov	 ecx, 1
  006a6	85 c9		 test	 ecx, ecx
  006a8	74 3a		 je	 SHORT $LN27@convert_yv
  006aa	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR _cy0x1$9[ebp]
  006b0	d1 e2		 shl	 edx, 1
  006b2	89 95 2c ff ff
	ff		 mov	 DWORD PTR _cy0x1$9[ebp], edx
  006b8	8b 85 28 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x1$8[ebp]
  006be	d1 e0		 shl	 eax, 1
  006c0	89 85 28 ff ff
	ff		 mov	 DWORD PTR _cy1x1$8[ebp], eax
  006c6	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR _cy2x1$7[ebp]
  006cc	d1 e1		 shl	 ecx, 1
  006ce	89 8d 24 ff ff
	ff		 mov	 DWORD PTR _cy2x1$7[ebp], ecx
  006d4	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR _cy3x1$6[ebp]
  006da	d1 e2		 shl	 edx, 1
  006dc	89 95 20 ff ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], edx
  006e2	eb 40		 jmp	 SHORT $LN28@convert_yv
$LN27@convert_yv:
  006e4	33 c0		 xor	 eax, eax
  006e6	74 3c		 je	 SHORT $LN28@convert_yv
  006e8	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR _cy0x1$9[ebp]
  006ee	c1 f9 ff	 sar	 ecx, -1
  006f1	89 8d 2c ff ff
	ff		 mov	 DWORD PTR _cy0x1$9[ebp], ecx
  006f7	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x1$8[ebp]
  006fd	c1 fa ff	 sar	 edx, -1
  00700	89 95 28 ff ff
	ff		 mov	 DWORD PTR _cy1x1$8[ebp], edx
  00706	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _cy2x1$7[ebp]
  0070c	c1 f8 ff	 sar	 eax, -1
  0070f	89 85 24 ff ff
	ff		 mov	 DWORD PTR _cy2x1$7[ebp], eax
  00715	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x1$6[ebp]
  0071b	c1 f9 ff	 sar	 ecx, -1
  0071e	89 8d 20 ff ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], ecx
$LN28@convert_yv:

; 758  : 
; 759  :                 dstC[0*dst_y_pitch   + 0] = (Tout)cy0x0;

  00724	6b 55 e4 00	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 0
  00728	8b 45 94	 mov	 eax, DWORD PTR _dstC$35[ebp]
  0072b	66 8b 8d 5c ff
	ff ff		 mov	 cx, WORD PTR _cy0x0$21[ebp]
  00732	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx

; 760  :                 dstC[0*dst_y_pitch   + 1] = (Tout)((cy0x0 + cy0x1 + 1) >> 1);

  00736	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR _cy0x1$9[ebp]
  0073c	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _cy0x0$21[ebp]
  00742	8d 4c 10 01	 lea	 ecx, DWORD PTR [eax+edx+1]
  00746	d1 f9		 sar	 ecx, 1
  00748	6b 55 e4 00	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 0
  0074c	8b 45 94	 mov	 eax, DWORD PTR _dstC$35[ebp]
  0074f	66 89 4c 50 02	 mov	 WORD PTR [eax+edx*2+2], cx

; 761  :                 dstC[1*dst_y_pitch   + 0] = (Tout)cy1x0;

  00754	8b 4d e4	 mov	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  00757	8b 55 94	 mov	 edx, DWORD PTR _dstC$35[ebp]
  0075a	66 8b 85 58 ff
	ff ff		 mov	 ax, WORD PTR _cy1x0$20[ebp]
  00761	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax

; 762  :                 dstC[1*dst_y_pitch   + 1] = (Tout)((cy1x0 + cy1x1 + 1) >> 1);

  00765	8b 8d 28 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x1$8[ebp]
  0076b	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x0$20[ebp]
  00771	8d 44 0a 01	 lea	 eax, DWORD PTR [edx+ecx+1]
  00775	d1 f8		 sar	 eax, 1
  00777	8b 4d e4	 mov	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  0077a	8b 55 94	 mov	 edx, DWORD PTR _dstC$35[ebp]
  0077d	66 89 44 4a 02	 mov	 WORD PTR [edx+ecx*2+2], ax

; 763  :                 dstC[2*dst_y_pitch   + 0] = (Tout)cy2x0;

  00782	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  00785	d1 e0		 shl	 eax, 1
  00787	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$35[ebp]
  0078a	66 8b 95 54 ff
	ff ff		 mov	 dx, WORD PTR _cy2x0$19[ebp]
  00791	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx

; 764  :                 dstC[2*dst_y_pitch   + 1] = (Tout)((cy2x0 + cy2x1 + 1) >> 1);

  00795	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _cy2x1$7[ebp]
  0079b	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _cy2x0$19[ebp]
  007a1	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  007a5	d1 fa		 sar	 edx, 1
  007a7	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  007aa	d1 e0		 shl	 eax, 1
  007ac	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$35[ebp]
  007af	66 89 54 41 02	 mov	 WORD PTR [ecx+eax*2+2], dx

; 765  :                 dstC[3*dst_y_pitch   + 0] = (Tout)cy3x0;

  007b4	6b 55 e4 03	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 3
  007b8	8b 45 94	 mov	 eax, DWORD PTR _dstC$35[ebp]
  007bb	66 8b 8d 50 ff
	ff ff		 mov	 cx, WORD PTR _cy3x0$18[ebp]
  007c2	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx

; 766  :                 dstC[3*dst_y_pitch   + 1] = (Tout)((cy3x0 + cy3x1 + 1) >> 1);

  007c6	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR _cy3x1$6[ebp]
  007cc	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$18[ebp]
  007d2	8d 4c 10 01	 lea	 ecx, DWORD PTR [eax+edx+1]
  007d6	d1 f9		 sar	 ecx, 1
  007d8	6b 55 e4 03	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 3
  007dc	8b 45 94	 mov	 eax, DWORD PTR _dstC$35[ebp]
  007df	66 89 4c 50 02	 mov	 WORD PTR [eax+edx*2+2], cx

; 767  : 
; 768  :                 cy0x0 = cy0x1;

  007e4	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR _cy0x1$9[ebp]
  007ea	89 8d 5c ff ff
	ff		 mov	 DWORD PTR _cy0x0$21[ebp], ecx

; 769  :                 cy1x0 = cy1x1;

  007f0	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x1$8[ebp]
  007f6	89 95 58 ff ff
	ff		 mov	 DWORD PTR _cy1x0$20[ebp], edx

; 770  :                 cy2x0 = cy2x1;

  007fc	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _cy2x1$7[ebp]
  00802	89 85 54 ff ff
	ff		 mov	 DWORD PTR _cy2x0$19[ebp], eax

; 771  :                 cy3x0 = cy3x1;

  00808	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x1$6[ebp]
  0080e	89 8d 50 ff ff
	ff		 mov	 DWORD PTR _cy3x0$18[ebp], ecx

; 772  :             }

  00814	e9 2b fd ff ff	 jmp	 $LN14@convert_yv
$LN15@convert_yv:

; 773  :         }

  00819	e9 83 fa ff ff	 jmp	 $LN11@convert_yv
$LN12@convert_yv:

; 774  :     }

  0081e	e9 31 fa ff ff	 jmp	 $LN8@convert_yv
$LN1@convert_yv:

; 775  : }

  00823	52		 push	 edx
  00824	8b cd		 mov	 ecx, ebp
  00826	50		 push	 eax
  00827	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN47@convert_yv
  0082d	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00832	58		 pop	 eax
  00833	5a		 pop	 edx
  00834	5f		 pop	 edi
  00835	5e		 pop	 esi
  00836	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00839	33 cd		 xor	 ecx, ebp
  0083b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00840	81 c4 18 01 00
	00		 add	 esp, 280		; 00000118H
  00846	3b ec		 cmp	 ebp, esp
  00848	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0084d	8b e5		 mov	 esp, ebp
  0084f	5d		 pop	 ebp
  00850	c3		 ret	 0
  00851	0f 1f 00	 npad	 3
$LN47@convert_yv:
  00854	01 00 00 00	 DD	 1
  00858	00 00 00 00	 DD	 $LN46@convert_yv
$LN46@convert_yv:
  0085c	d4 ff ff ff	 DD	 -44			; ffffffd4H
  00860	0c 00 00 00	 DD	 12			; 0000000cH
  00864	00 00 00 00	 DD	 $LN45@convert_yv
$LN45@convert_yv:
  00868	79		 DB	 121			; 00000079H
  00869	5f		 DB	 95			; 0000005fH
  0086a	72		 DB	 114			; 00000072H
  0086b	61		 DB	 97			; 00000061H
  0086c	6e		 DB	 110			; 0000006eH
  0086d	67		 DB	 103			; 00000067H
  0086e	65		 DB	 101			; 00000065H
  0086f	00		 DB	 0
??$convert_yv12_i_to_yuv444_c@G$0M@G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_i_to_yuv444_c<unsigned short,12,unsigned short,16,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yv12_12_i_to_yuv444_16bit@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_12_i_to_yuv444_16bit

; 853  : static void convert_yv12_12_i_to_yuv444_16bit(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 854  :     convert_yv12_i_to_yuv444_c<uint16_t, 12, uint16_t, 16, false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yv12_i_to_yuv444_c@G$0M@G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_i_to_yuv444_c<unsigned short,12,unsigned short,16,0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 855  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yv12_12_i_to_yuv444_16bit@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_12_i_to_yuv444_16bit
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
tv432 = -300						; size = 4
tv317 = -296						; size = 4
tv232 = -292						; size = 4
$T1 = -288						; size = 4
$T2 = -284						; size = 4
$T3 = -280						; size = 4
$T4 = -276						; size = 4
$T5 = -272						; size = 12
_cy3x1$6 = -260						; size = 4
_cy1x1$7 = -256						; size = 4
_cy3x0$8 = -252						; size = 4
_cy1x0$9 = -248						; size = 4
_cy4x1$10 = -244					; size = 4
_cy2x1$11 = -240					; size = 4
_cy0x1$12 = -236					; size = 4
_cy4x0$13 = -232					; size = 4
_cy2x0$14 = -228					; size = 4
_cy0x0$15 = -224					; size = 4
_cxplus$16 = -220					; size = 4
_x$17 = -216						; size = 4
_cy3x1$18 = -212					; size = 4
_cy1x1$19 = -208					; size = 4
_cy3x0$20 = -204					; size = 4
_cy1x0$21 = -200					; size = 4
_cy4x1$22 = -196					; size = 4
_cy2x1$23 = -192					; size = 4
_cy0x1$24 = -188					; size = 4
_cy4x0$25 = -184					; size = 4
_cy2x0$26 = -180					; size = 4
_cy0x0$27 = -176					; size = 4
_cxplus$28 = -172					; size = 4
_x$29 = -168						; size = 4
_cy3x1$30 = -164					; size = 4
_cy1x1$31 = -160					; size = 4
_cy3x0$32 = -156					; size = 4
_cy1x0$33 = -152					; size = 4
_cy4x1$34 = -148					; size = 4
_cy2x1$35 = -144					; size = 4
_cy0x1$36 = -140					; size = 4
_cy4x0$37 = -136					; size = 4
_cy2x0$38 = -132					; size = 4
_cy0x0$39 = -128					; size = 4
_cxplus$40 = -124					; size = 4
_x$41 = -120						; size = 4
_x_fin$42 = -116					; size = 4
_srcP$43 = -112						; size = 4
_dstC$44 = -108						; size = 4
_y$45 = -104						; size = 4
_dstLine$46 = -100					; size = 4
_srcCLine$47 = -96					; size = 4
_ic$48 = -92						; size = 4
_src_uv_pitch$ = -88					; size = 4
_x$49 = -84						; size = 4
_y$50 = -80						; size = 4
_y_width$51 = -76					; size = 4
_y_fin$52 = -72						; size = 4
_dstLine$53 = -68					; size = 4
_srcYLine$54 = -64					; size = 4
$T55 = -60						; size = 12
_y_range$ = -44						; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yv12_p_to_yuv444_c@G$0M@G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_p_to_yuv444_c<unsigned short,12,unsigned short,16,0>

; 573  : static void __forceinline convert_yv12_p_to_yuv444_c(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 2c 01 00
	00		 sub	 esp, 300		; 0000012cH
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8d bd d4 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-300]
  00011	b9 4b 00 00 00	 mov	 ecx, 75			; 0000004bH
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 574  :     static_assert((sizeof(Tin)  == 1 && in_bit_depth  == 8) || (sizeof(Tin)  == 2 && 8 < in_bit_depth  && in_bit_depth  <= 16), "invalid input bit depth.");
; 575  :     static_assert((sizeof(Tout) == 1 && out_bit_depth == 8) || (sizeof(Tout) == 2 && 8 < out_bit_depth && out_bit_depth <= 16), "invalid output bit depth.");
; 576  :     const int crop_left   = crop[0];

  00027	b8 04 00 00 00	 mov	 eax, 4
  0002c	6b c8 00	 imul	 ecx, eax, 0
  0002f	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00032	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00035	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 577  :     const int crop_up     = crop[1];

  00038	b9 04 00 00 00	 mov	 ecx, 4
  0003d	c1 e1 00	 shl	 ecx, 0
  00040	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00043	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00046	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 578  :     const int crop_right  = crop[2];

  00049	b9 04 00 00 00	 mov	 ecx, 4
  0004e	d1 e1		 shl	 ecx, 1
  00050	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00053	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00056	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 579  :     const int crop_bottom = crop[3];

  00059	b9 04 00 00 00	 mov	 ecx, 4
  0005e	6b d1 03	 imul	 edx, ecx, 3
  00061	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00064	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00067	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 580  :     const int src_y_pitch = src_y_pitch_byte / sizeof(Tin);

  0006a	8b 55 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebp]
  0006d	d1 ea		 shr	 edx, 1
  0006f	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 581  :     const int dst_y_pitch = dst_y_pitch_byte / sizeof(Tout);

  00072	8b 45 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  00075	d1 e8		 shr	 eax, 1
  00077	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 582  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  0007a	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0007d	51		 push	 ecx
  0007e	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  00081	52		 push	 edx
  00082	8b 45 20	 mov	 eax, DWORD PTR _height$[ebp]
  00085	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  00088	50		 push	 eax
  00089	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  0008c	51		 push	 ecx
  0008d	8d 95 f0 fe ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  00093	52		 push	 edx
  00094	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00099	83 c4 14	 add	 esp, 20			; 00000014H
  0009c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009e	89 4d c4	 mov	 DWORD PTR $T55[ebp], ecx
  000a1	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a4	89 55 c8	 mov	 DWORD PTR $T55[ebp+4], edx
  000a7	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000aa	89 45 cc	 mov	 DWORD PTR $T55[ebp+8], eax
  000ad	8b 4d c4	 mov	 ecx, DWORD PTR $T55[ebp]
  000b0	89 4d d4	 mov	 DWORD PTR _y_range$[ebp], ecx
  000b3	8b 55 c8	 mov	 edx, DWORD PTR $T55[ebp+4]
  000b6	89 55 d8	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000b9	8b 45 cc	 mov	 eax, DWORD PTR $T55[ebp+8]
  000bc	89 45 dc	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 583  :     //Y
; 584  :     if (!uv_only) {

  000bf	b9 01 00 00 00	 mov	 ecx, 1
  000c4	85 c9		 test	 ecx, ecx
  000c6	0f 84 77 01 00
	00		 je	 $LN23@convert_yv

; 585  :         Tin *srcYLine = (Tin *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000cc	ba 04 00 00 00	 mov	 edx, 4
  000d1	6b c2 00	 imul	 eax, edx, 0
  000d4	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  000d7	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  000db	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  000de	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  000e1	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  000e4	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  000e7	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  000ea	89 45 c0	 mov	 DWORD PTR _srcYLine$54[ebp], eax

; 586  :         Tout *dstLine = (Tout *)dst[0] + dst_y_pitch * y_range.start_dst;

  000ed	b9 04 00 00 00	 mov	 ecx, 4
  000f2	6b d1 00	 imul	 edx, ecx, 0
  000f5	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  000f8	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  000fc	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  000ff	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  00102	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  00105	89 45 bc	 mov	 DWORD PTR _dstLine$53[ebp], eax

; 587  :         const int y_fin = height - crop_bottom;

  00108	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  0010b	2b 4d ec	 sub	 ecx, DWORD PTR _crop_bottom$[ebp]
  0010e	89 4d b8	 mov	 DWORD PTR _y_fin$52[ebp], ecx

; 588  :         const int y_width = width - crop_right - crop_left;

  00111	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00114	2b 55 f0	 sub	 edx, DWORD PTR _crop_right$[ebp]
  00117	2b 55 f8	 sub	 edx, DWORD PTR _crop_left$[ebp]
  0011a	89 55 b4	 mov	 DWORD PTR _y_width$51[ebp], edx

; 589  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  0011d	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _y$50[ebp], 0
  00124	eb 21		 jmp	 SHORT $LN4@convert_yv
$LN2@convert_yv:
  00126	8b 45 b0	 mov	 eax, DWORD PTR _y$50[ebp]
  00129	83 c0 01	 add	 eax, 1
  0012c	89 45 b0	 mov	 DWORD PTR _y$50[ebp], eax
  0012f	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  00132	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$54[ebp]
  00135	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  00138	89 45 c0	 mov	 DWORD PTR _srcYLine$54[ebp], eax
  0013b	8b 4d e4	 mov	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  0013e	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$53[ebp]
  00141	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  00144	89 45 bc	 mov	 DWORD PTR _dstLine$53[ebp], eax
$LN4@convert_yv:
  00147	8b 4d b0	 mov	 ecx, DWORD PTR _y$50[ebp]
  0014a	3b 4d dc	 cmp	 ecx, DWORD PTR _y_range$[ebp+8]
  0014d	0f 8d f0 00 00
	00		 jge	 $LN23@convert_yv

; 590  :             if (in_bit_depth == out_bit_depth && sizeof(Tin) == sizeof(Tout)) {

  00153	33 d2		 xor	 edx, edx
  00155	74 1b		 je	 SHORT $LN24@convert_yv

; 591  :                 memcpy(dstLine, srcYLine, y_width * sizeof(Tin));

  00157	8b 45 b4	 mov	 eax, DWORD PTR _y_width$51[ebp]
  0015a	d1 e0		 shl	 eax, 1
  0015c	50		 push	 eax
  0015d	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$54[ebp]
  00160	51		 push	 ecx
  00161	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$53[ebp]
  00164	52		 push	 edx
  00165	e8 00 00 00 00	 call	 _memcpy
  0016a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 592  :             } else {

  0016d	e9 cc 00 00 00	 jmp	 $LN25@convert_yv
$LN24@convert_yv:

; 593  :                 for (int x = 0; x < y_width; x++) {

  00172	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR _x$49[ebp], 0
  00179	eb 09		 jmp	 SHORT $LN7@convert_yv
$LN5@convert_yv:
  0017b	8b 45 ac	 mov	 eax, DWORD PTR _x$49[ebp]
  0017e	83 c0 01	 add	 eax, 1
  00181	89 45 ac	 mov	 DWORD PTR _x$49[ebp], eax
$LN7@convert_yv:
  00184	8b 4d ac	 mov	 ecx, DWORD PTR _x$49[ebp]
  00187	3b 4d b4	 cmp	 ecx, DWORD PTR _y_width$51[ebp]
  0018a	0f 8d ae 00 00
	00		 jge	 $LN25@convert_yv

; 594  :                     if (out_bit_depth > in_bit_depth) {

  00190	ba 01 00 00 00	 mov	 edx, 1
  00195	85 d2		 test	 edx, edx
  00197	74 44		 je	 SHORT $LN26@convert_yv

; 595  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) << std::max(out_bit_depth - in_bit_depth, 0));

  00199	c7 85 ec fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], 0
  001a3	c7 85 e8 fe ff
	ff 04 00 00 00	 mov	 DWORD PTR $T3[ebp], 4
  001ad	8b 45 ac	 mov	 eax, DWORD PTR _x$49[ebp]
  001b0	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$54[ebp]
  001b3	0f b7 34 41	 movzx	 esi, WORD PTR [ecx+eax*2]
  001b7	8d 95 ec fe ff
	ff		 lea	 edx, DWORD PTR $T4[ebp]
  001bd	52		 push	 edx
  001be	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  001c4	50		 push	 eax
  001c5	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  001ca	83 c4 08	 add	 esp, 8
  001cd	8b 08		 mov	 ecx, DWORD PTR [eax]
  001cf	d3 e6		 shl	 esi, cl
  001d1	8b 4d ac	 mov	 ecx, DWORD PTR _x$49[ebp]
  001d4	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$53[ebp]
  001d7	66 89 34 4a	 mov	 WORD PTR [edx+ecx*2], si
  001db	eb 5c		 jmp	 SHORT $LN27@convert_yv
$LN26@convert_yv:

; 596  :                     } else if (out_bit_depth < in_bit_depth) {

  001dd	33 c0		 xor	 eax, eax
  001df	74 44		 je	 SHORT $LN28@convert_yv

; 597  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) >> std::max(in_bit_depth - out_bit_depth, 0));

  001e1	c7 85 e4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], 0
  001eb	c7 85 e0 fe ff
	ff fc ff ff ff	 mov	 DWORD PTR $T1[ebp], -4	; fffffffcH
  001f5	8b 4d ac	 mov	 ecx, DWORD PTR _x$49[ebp]
  001f8	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$54[ebp]
  001fb	0f b7 34 4a	 movzx	 esi, WORD PTR [edx+ecx*2]
  001ff	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  00205	50		 push	 eax
  00206	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  0020c	51		 push	 ecx
  0020d	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  00212	83 c4 08	 add	 esp, 8
  00215	8b 08		 mov	 ecx, DWORD PTR [eax]
  00217	d3 fe		 sar	 esi, cl
  00219	8b 55 ac	 mov	 edx, DWORD PTR _x$49[ebp]
  0021c	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$53[ebp]
  0021f	66 89 34 50	 mov	 WORD PTR [eax+edx*2], si

; 598  :                     } else {

  00223	eb 14		 jmp	 SHORT $LN27@convert_yv
$LN28@convert_yv:

; 599  :                         dstLine[x] = (Tout)srcYLine[x];

  00225	8b 4d ac	 mov	 ecx, DWORD PTR _x$49[ebp]
  00228	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$53[ebp]
  0022b	8b 45 ac	 mov	 eax, DWORD PTR _x$49[ebp]
  0022e	8b 75 c0	 mov	 esi, DWORD PTR _srcYLine$54[ebp]
  00231	66 8b 04 46	 mov	 ax, WORD PTR [esi+eax*2]
  00235	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax
$LN27@convert_yv:

; 600  :                     }
; 601  :                 }

  00239	e9 3d ff ff ff	 jmp	 $LN5@convert_yv
$LN25@convert_yv:

; 602  :             }
; 603  :         }

  0023e	e9 e3 fe ff ff	 jmp	 $LN2@convert_yv
$LN23@convert_yv:

; 604  :     }
; 605  :     //UV
; 606  :     const int src_uv_pitch = src_uv_pitch_byte / sizeof(Tin);

  00243	8b 4d 18	 mov	 ecx, DWORD PTR _src_uv_pitch_byte$[ebp]
  00246	d1 e9		 shr	 ecx, 1
  00248	89 4d a8	 mov	 DWORD PTR _src_uv_pitch$[ebp], ecx

; 607  :     for (int ic = 1; ic < 3; ic++) {

  0024b	c7 45 a4 01 00
	00 00		 mov	 DWORD PTR _ic$48[ebp], 1
  00252	eb 09		 jmp	 SHORT $LN10@convert_yv
$LN8@convert_yv:
  00254	8b 55 a4	 mov	 edx, DWORD PTR _ic$48[ebp]
  00257	83 c2 01	 add	 edx, 1
  0025a	89 55 a4	 mov	 DWORD PTR _ic$48[ebp], edx
$LN10@convert_yv:
  0025d	83 7d a4 03	 cmp	 DWORD PTR _ic$48[ebp], 3
  00261	0f 8d 07 07 00
	00		 jge	 $LN1@convert_yv

; 608  :         Tin *srcCLine = (Tin *)src[ic] + (((src_uv_pitch * y_range.start_src) + crop_left) >> 1);

  00267	8b 45 a8	 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  0026a	0f af 45 d4	 imul	 eax, DWORD PTR _y_range$[ebp]
  0026e	03 45 f8	 add	 eax, DWORD PTR _crop_left$[ebp]
  00271	d1 f8		 sar	 eax, 1
  00273	8b 4d a4	 mov	 ecx, DWORD PTR _ic$48[ebp]
  00276	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  00279	8b 0c 8a	 mov	 ecx, DWORD PTR [edx+ecx*4]
  0027c	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  0027f	89 55 a0	 mov	 DWORD PTR _srcCLine$47[ebp], edx

; 609  :         Tout *dstLine = (Tout *)dst[ic] + dst_y_pitch * y_range.start_dst;

  00282	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  00285	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  00289	8b 4d a4	 mov	 ecx, DWORD PTR _ic$48[ebp]
  0028c	8b 55 08	 mov	 edx, DWORD PTR _dst$[ebp]
  0028f	8b 0c 8a	 mov	 ecx, DWORD PTR [edx+ecx*4]
  00292	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00295	89 55 9c	 mov	 DWORD PTR _dstLine$46[ebp], edx

; 610  :         for (int y = 0; y < y_range.len; y += 2, srcCLine += src_uv_pitch, dstLine += dst_y_pitch * 2) {

  00298	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _y$45[ebp], 0
  0029f	eb 23		 jmp	 SHORT $LN13@convert_yv
$LN11@convert_yv:
  002a1	8b 45 98	 mov	 eax, DWORD PTR _y$45[ebp]
  002a4	83 c0 02	 add	 eax, 2
  002a7	89 45 98	 mov	 DWORD PTR _y$45[ebp], eax
  002aa	8b 4d a8	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  002ad	8b 55 a0	 mov	 edx, DWORD PTR _srcCLine$47[ebp]
  002b0	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  002b3	89 45 a0	 mov	 DWORD PTR _srcCLine$47[ebp], eax
  002b6	8b 4d e4	 mov	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  002b9	d1 e1		 shl	 ecx, 1
  002bb	8b 55 9c	 mov	 edx, DWORD PTR _dstLine$46[ebp]
  002be	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  002c1	89 45 9c	 mov	 DWORD PTR _dstLine$46[ebp], eax
$LN13@convert_yv:
  002c4	8b 4d 98	 mov	 ecx, DWORD PTR _y$45[ebp]
  002c7	3b 4d dc	 cmp	 ecx, DWORD PTR _y_range$[ebp+8]
  002ca	0f 8d 99 06 00
	00		 jge	 $LN12@convert_yv

; 611  :             Tout *dstC = dstLine;

  002d0	8b 55 9c	 mov	 edx, DWORD PTR _dstLine$46[ebp]
  002d3	89 55 94	 mov	 DWORD PTR _dstC$44[ebp], edx

; 612  :             Tin *srcP = srcCLine;

  002d6	8b 45 a0	 mov	 eax, DWORD PTR _srcCLine$47[ebp]
  002d9	89 45 90	 mov	 DWORD PTR _srcP$43[ebp], eax

; 613  :             const int x_fin = width - crop_right - crop_left;

  002dc	8b 4d 10	 mov	 ecx, DWORD PTR _width$[ebp]
  002df	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  002e2	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  002e5	89 4d 8c	 mov	 DWORD PTR _x_fin$42[ebp], ecx

; 614  :             if (y == 0) {

  002e8	83 7d 98 00	 cmp	 DWORD PTR _y$45[ebp], 0
  002ec	0f 85 0c 02 00
	00		 jne	 $LN30@convert_yv

; 615  :                 for (int x = 0; x < x_fin; x += 2, dstC += 2, srcP++) {

  002f2	c7 45 88 00 00
	00 00		 mov	 DWORD PTR _x$41[ebp], 0
  002f9	eb 1b		 jmp	 SHORT $LN16@convert_yv
$LN14@convert_yv:
  002fb	8b 55 88	 mov	 edx, DWORD PTR _x$41[ebp]
  002fe	83 c2 02	 add	 edx, 2
  00301	89 55 88	 mov	 DWORD PTR _x$41[ebp], edx
  00304	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  00307	83 c0 04	 add	 eax, 4
  0030a	89 45 94	 mov	 DWORD PTR _dstC$44[ebp], eax
  0030d	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$43[ebp]
  00310	83 c1 02	 add	 ecx, 2
  00313	89 4d 90	 mov	 DWORD PTR _srcP$43[ebp], ecx
$LN16@convert_yv:
  00316	8b 55 88	 mov	 edx, DWORD PTR _x$41[ebp]
  00319	3b 55 8c	 cmp	 edx, DWORD PTR _x_fin$42[ebp]
  0031c	0f 8d d7 01 00
	00		 jge	 $LN15@convert_yv

; 616  :                     int cxplus = (x + 2 < x_fin);

  00322	8b 45 88	 mov	 eax, DWORD PTR _x$41[ebp]
  00325	83 c0 02	 add	 eax, 2
  00328	3b 45 8c	 cmp	 eax, DWORD PTR _x_fin$42[ebp]
  0032b	7d 0c		 jge	 SHORT $LN44@convert_yv
  0032d	c7 85 dc fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv232[ebp], 1
  00337	eb 0a		 jmp	 SHORT $LN45@convert_yv
$LN44@convert_yv:
  00339	c7 85 dc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv232[ebp], 0
$LN45@convert_yv:
  00343	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR tv232[ebp]
  00349	89 4d 84	 mov	 DWORD PTR _cxplus$40[ebp], ecx

; 617  :                     int cy0x0 = srcP[ 0*src_uv_pitch + 0];

  0034c	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  00350	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  00353	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  00357	89 4d 80	 mov	 DWORD PTR _cy0x0$39[ebp], ecx

; 618  :                     int cy2x0 = srcP[ 0*src_uv_pitch + 0];

  0035a	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  0035e	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  00361	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  00365	89 8d 7c ff ff
	ff		 mov	 DWORD PTR _cy2x0$38[ebp], ecx

; 619  :                     int cy4x0 = srcP[ 1*src_uv_pitch + 0];

  0036b	8b 55 a8	 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  0036e	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  00371	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  00375	89 8d 78 ff ff
	ff		 mov	 DWORD PTR _cy4x0$37[ebp], ecx

; 620  :                     int cy0x1 = srcP[ 0*src_uv_pitch + cxplus];

  0037b	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  0037f	03 55 84	 add	 edx, DWORD PTR _cxplus$40[ebp]
  00382	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  00385	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  00389	89 8d 74 ff ff
	ff		 mov	 DWORD PTR _cy0x1$36[ebp], ecx

; 621  :                     int cy2x1 = srcP[ 0*src_uv_pitch + cxplus];

  0038f	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  00393	03 55 84	 add	 edx, DWORD PTR _cxplus$40[ebp]
  00396	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  00399	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  0039d	89 8d 70 ff ff
	ff		 mov	 DWORD PTR _cy2x1$35[ebp], ecx

; 622  :                     int cy4x1 = srcP[ 1*src_uv_pitch + cxplus];

  003a3	8b 55 84	 mov	 edx, DWORD PTR _cxplus$40[ebp]
  003a6	03 55 a8	 add	 edx, DWORD PTR _src_uv_pitch$[ebp]
  003a9	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  003ac	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  003b0	89 8d 6c ff ff
	ff		 mov	 DWORD PTR _cy4x1$34[ebp], ecx

; 623  : 
; 624  :                     int cy1x0 = (cy0x0 * 1 + cy2x0 * 3 + 2);

  003b6	6b 95 7c ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x0$38[ebp], 3
  003bd	8b 45 80	 mov	 eax, DWORD PTR _cy0x0$39[ebp]
  003c0	8d 4c 10 02	 lea	 ecx, DWORD PTR [eax+edx+2]
  003c4	89 8d 68 ff ff
	ff		 mov	 DWORD PTR _cy1x0$33[ebp], ecx

; 625  :                     int cy3x0 = (cy2x0 * 3 + cy4x0 * 1 + 2);

  003ca	6b 95 7c ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x0$38[ebp], 3
  003d1	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _cy4x0$37[ebp]
  003d7	8d 4c 02 02	 lea	 ecx, DWORD PTR [edx+eax+2]
  003db	89 8d 64 ff ff
	ff		 mov	 DWORD PTR _cy3x0$32[ebp], ecx

; 626  :                     int cy1x1 = (cy0x1 * 1 + cy2x1 * 3 + 2);

  003e1	6b 95 70 ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x1$35[ebp], 3
  003e8	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _cy0x1$36[ebp]
  003ee	8d 4c 10 02	 lea	 ecx, DWORD PTR [eax+edx+2]
  003f2	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _cy1x1$31[ebp], ecx

; 627  :                     int cy3x1 = (cy2x1 * 3 + cy4x1 * 1 + 2);

  003f8	6b 95 70 ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x1$35[ebp], 3
  003ff	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _cy4x1$34[ebp]
  00405	8d 4c 02 02	 lea	 ecx, DWORD PTR [edx+eax+2]
  00409	89 8d 5c ff ff
	ff		 mov	 DWORD PTR _cy3x1$30[ebp], ecx

; 628  :                     CHANGE_BIT_DEPTH_4(cy1x0, cy3x0, cy1x1, cy3x1, 2);

  0040f	ba 01 00 00 00	 mov	 edx, 1
  00414	85 d2		 test	 edx, edx
  00416	74 3e		 je	 SHORT $LN32@convert_yv
  00418	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x0$33[ebp]
  0041e	c1 e0 02	 shl	 eax, 2
  00421	89 85 68 ff ff
	ff		 mov	 DWORD PTR _cy1x0$33[ebp], eax
  00427	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x0$32[ebp]
  0042d	c1 e1 02	 shl	 ecx, 2
  00430	89 8d 64 ff ff
	ff		 mov	 DWORD PTR _cy3x0$32[ebp], ecx
  00436	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x1$31[ebp]
  0043c	c1 e2 02	 shl	 edx, 2
  0043f	89 95 60 ff ff
	ff		 mov	 DWORD PTR _cy1x1$31[ebp], edx
  00445	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _cy3x1$30[ebp]
  0044b	c1 e0 02	 shl	 eax, 2
  0044e	89 85 5c ff ff
	ff		 mov	 DWORD PTR _cy3x1$30[ebp], eax
  00454	eb 40		 jmp	 SHORT $LN33@convert_yv
$LN32@convert_yv:
  00456	33 c9		 xor	 ecx, ecx
  00458	74 3c		 je	 SHORT $LN33@convert_yv
  0045a	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x0$33[ebp]
  00460	c1 fa fe	 sar	 edx, -2			; fffffffeH
  00463	89 95 68 ff ff
	ff		 mov	 DWORD PTR _cy1x0$33[ebp], edx
  00469	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$32[ebp]
  0046f	c1 f8 fe	 sar	 eax, -2			; fffffffeH
  00472	89 85 64 ff ff
	ff		 mov	 DWORD PTR _cy3x0$32[ebp], eax
  00478	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x1$31[ebp]
  0047e	c1 f9 fe	 sar	 ecx, -2			; fffffffeH
  00481	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _cy1x1$31[ebp], ecx
  00487	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR _cy3x1$30[ebp]
  0048d	c1 fa fe	 sar	 edx, -2			; fffffffeH
  00490	89 95 5c ff ff
	ff		 mov	 DWORD PTR _cy3x1$30[ebp], edx
$LN33@convert_yv:

; 629  : 
; 630  :                     dstC[0*dst_y_pitch   + 0] = (Tout)cy1x0;

  00496	6b 45 e4 00	 imul	 eax, DWORD PTR _dst_y_pitch$[ebp], 0
  0049a	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$44[ebp]
  0049d	66 8b 95 68 ff
	ff ff		 mov	 dx, WORD PTR _cy1x0$33[ebp]
  004a4	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx

; 631  :                     dstC[0*dst_y_pitch   + 1] = (Tout)((cy1x0 + cy1x1 + 1) >> 1);

  004a8	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x1$31[ebp]
  004ae	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x0$33[ebp]
  004b4	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  004b8	d1 fa		 sar	 edx, 1
  004ba	6b 45 e4 00	 imul	 eax, DWORD PTR _dst_y_pitch$[ebp], 0
  004be	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$44[ebp]
  004c1	66 89 54 41 02	 mov	 WORD PTR [ecx+eax*2+2], dx

; 632  :                     dstC[1*dst_y_pitch   + 0] = (Tout)cy3x0;

  004c6	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  004c9	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  004cc	66 8b 8d 64 ff
	ff ff		 mov	 cx, WORD PTR _cy3x0$32[ebp]
  004d3	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx

; 633  :                     dstC[1*dst_y_pitch   + 1] = (Tout)((cy3x0 + cy3x1 + 1) >> 1);

  004d7	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR _cy3x1$30[ebp]
  004dd	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$32[ebp]
  004e3	8d 4c 10 01	 lea	 ecx, DWORD PTR [eax+edx+1]
  004e7	d1 f9		 sar	 ecx, 1
  004e9	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  004ec	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  004ef	66 89 4c 50 02	 mov	 WORD PTR [eax+edx*2+2], cx

; 634  :                 }

  004f4	e9 02 fe ff ff	 jmp	 $LN14@convert_yv
$LN15@convert_yv:

; 635  :             } else if (y >= height-2) {

  004f9	e9 66 04 00 00	 jmp	 $LN31@convert_yv
$LN30@convert_yv:
  004fe	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00501	83 e9 02	 sub	 ecx, 2
  00504	39 4d 98	 cmp	 DWORD PTR _y$45[ebp], ecx
  00507	0f 8c 2f 02 00
	00		 jl	 $LN35@convert_yv

; 636  :                 for (int x = 0; x < x_fin; x += 2, dstC += 2, srcP++) {

  0050d	c7 85 58 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _x$29[ebp], 0
  00517	eb 21		 jmp	 SHORT $LN19@convert_yv
$LN17@convert_yv:
  00519	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _x$29[ebp]
  0051f	83 c2 02	 add	 edx, 2
  00522	89 95 58 ff ff
	ff		 mov	 DWORD PTR _x$29[ebp], edx
  00528	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  0052b	83 c0 04	 add	 eax, 4
  0052e	89 45 94	 mov	 DWORD PTR _dstC$44[ebp], eax
  00531	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$43[ebp]
  00534	83 c1 02	 add	 ecx, 2
  00537	89 4d 90	 mov	 DWORD PTR _srcP$43[ebp], ecx
$LN19@convert_yv:
  0053a	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _x$29[ebp]
  00540	3b 55 8c	 cmp	 edx, DWORD PTR _x_fin$42[ebp]
  00543	0f 8d ee 01 00
	00		 jge	 $LN18@convert_yv

; 637  :                     int cxplus = (x + 2 < x_fin);

  00549	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _x$29[ebp]
  0054f	83 c0 02	 add	 eax, 2
  00552	3b 45 8c	 cmp	 eax, DWORD PTR _x_fin$42[ebp]
  00555	7d 0c		 jge	 SHORT $LN46@convert_yv
  00557	c7 85 d8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv317[ebp], 1
  00561	eb 0a		 jmp	 SHORT $LN47@convert_yv
$LN46@convert_yv:
  00563	c7 85 d8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv317[ebp], 0
$LN47@convert_yv:
  0056d	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR tv317[ebp]
  00573	89 8d 54 ff ff
	ff		 mov	 DWORD PTR _cxplus$28[ebp], ecx

; 638  :                     int cy0x0 = srcP[-1*src_uv_pitch + 0];

  00579	6b 55 a8 ff	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], -1
  0057d	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  00580	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  00584	89 8d 50 ff ff
	ff		 mov	 DWORD PTR _cy0x0$27[ebp], ecx

; 639  :                     int cy2x0 = srcP[ 0*src_uv_pitch + 0];

  0058a	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  0058e	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  00591	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  00595	89 8d 4c ff ff
	ff		 mov	 DWORD PTR _cy2x0$26[ebp], ecx

; 640  :                     int cy4x0 = srcP[ 0*src_uv_pitch + 0];

  0059b	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  0059f	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  005a2	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  005a6	89 8d 48 ff ff
	ff		 mov	 DWORD PTR _cy4x0$25[ebp], ecx

; 641  :                     int cy0x1 = srcP[-1*src_uv_pitch + cxplus];

  005ac	6b 55 a8 ff	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], -1
  005b0	03 95 54 ff ff
	ff		 add	 edx, DWORD PTR _cxplus$28[ebp]
  005b6	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  005b9	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  005bd	89 8d 44 ff ff
	ff		 mov	 DWORD PTR _cy0x1$24[ebp], ecx

; 642  :                     int cy2x1 = srcP[ 0*src_uv_pitch + cxplus];

  005c3	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  005c7	03 95 54 ff ff
	ff		 add	 edx, DWORD PTR _cxplus$28[ebp]
  005cd	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  005d0	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  005d4	89 8d 40 ff ff
	ff		 mov	 DWORD PTR _cy2x1$23[ebp], ecx

; 643  :                     int cy4x1 = srcP[ 0*src_uv_pitch + cxplus];

  005da	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  005de	03 95 54 ff ff
	ff		 add	 edx, DWORD PTR _cxplus$28[ebp]
  005e4	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  005e7	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  005eb	89 8d 3c ff ff
	ff		 mov	 DWORD PTR _cy4x1$22[ebp], ecx

; 644  : 
; 645  :                     int cy1x0 = (cy0x0 * 1 + cy2x0 * 3 + 2);

  005f1	6b 95 4c ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x0$26[ebp], 3
  005f8	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _cy0x0$27[ebp]
  005fe	8d 4c 10 02	 lea	 ecx, DWORD PTR [eax+edx+2]
  00602	89 8d 38 ff ff
	ff		 mov	 DWORD PTR _cy1x0$21[ebp], ecx

; 646  :                     int cy3x0 = (cy2x0 * 3 + cy4x0 * 1 + 2);

  00608	6b 95 4c ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x0$26[ebp], 3
  0060f	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _cy4x0$25[ebp]
  00615	8d 4c 02 02	 lea	 ecx, DWORD PTR [edx+eax+2]
  00619	89 8d 34 ff ff
	ff		 mov	 DWORD PTR _cy3x0$20[ebp], ecx

; 647  :                     int cy1x1 = (cy0x1 * 1 + cy2x1 * 3 + 2);

  0061f	6b 95 40 ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x1$23[ebp], 3
  00626	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _cy0x1$24[ebp]
  0062c	8d 4c 10 02	 lea	 ecx, DWORD PTR [eax+edx+2]
  00630	89 8d 30 ff ff
	ff		 mov	 DWORD PTR _cy1x1$19[ebp], ecx

; 648  :                     int cy3x1 = (cy2x1 * 3 + cy4x1 * 1 + 2);

  00636	6b 95 40 ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x1$23[ebp], 3
  0063d	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _cy4x1$22[ebp]
  00643	8d 4c 02 02	 lea	 ecx, DWORD PTR [edx+eax+2]
  00647	89 8d 2c ff ff
	ff		 mov	 DWORD PTR _cy3x1$18[ebp], ecx

; 649  :                     CHANGE_BIT_DEPTH_4(cy1x0, cy3x0, cy1x1, cy3x1, 2);

  0064d	ba 01 00 00 00	 mov	 edx, 1
  00652	85 d2		 test	 edx, edx
  00654	74 3e		 je	 SHORT $LN37@convert_yv
  00656	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x0$21[ebp]
  0065c	c1 e0 02	 shl	 eax, 2
  0065f	89 85 38 ff ff
	ff		 mov	 DWORD PTR _cy1x0$21[ebp], eax
  00665	8b 8d 34 ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x0$20[ebp]
  0066b	c1 e1 02	 shl	 ecx, 2
  0066e	89 8d 34 ff ff
	ff		 mov	 DWORD PTR _cy3x0$20[ebp], ecx
  00674	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x1$19[ebp]
  0067a	c1 e2 02	 shl	 edx, 2
  0067d	89 95 30 ff ff
	ff		 mov	 DWORD PTR _cy1x1$19[ebp], edx
  00683	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR _cy3x1$18[ebp]
  00689	c1 e0 02	 shl	 eax, 2
  0068c	89 85 2c ff ff
	ff		 mov	 DWORD PTR _cy3x1$18[ebp], eax
  00692	eb 40		 jmp	 SHORT $LN38@convert_yv
$LN37@convert_yv:
  00694	33 c9		 xor	 ecx, ecx
  00696	74 3c		 je	 SHORT $LN38@convert_yv
  00698	8b 95 38 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x0$21[ebp]
  0069e	c1 fa fe	 sar	 edx, -2			; fffffffeH
  006a1	89 95 38 ff ff
	ff		 mov	 DWORD PTR _cy1x0$21[ebp], edx
  006a7	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$20[ebp]
  006ad	c1 f8 fe	 sar	 eax, -2			; fffffffeH
  006b0	89 85 34 ff ff
	ff		 mov	 DWORD PTR _cy3x0$20[ebp], eax
  006b6	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x1$19[ebp]
  006bc	c1 f9 fe	 sar	 ecx, -2			; fffffffeH
  006bf	89 8d 30 ff ff
	ff		 mov	 DWORD PTR _cy1x1$19[ebp], ecx
  006c5	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR _cy3x1$18[ebp]
  006cb	c1 fa fe	 sar	 edx, -2			; fffffffeH
  006ce	89 95 2c ff ff
	ff		 mov	 DWORD PTR _cy3x1$18[ebp], edx
$LN38@convert_yv:

; 650  : 
; 651  :                     dstC[0*dst_y_pitch   + 0] = (Tout)cy1x0;

  006d4	6b 45 e4 00	 imul	 eax, DWORD PTR _dst_y_pitch$[ebp], 0
  006d8	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$44[ebp]
  006db	66 8b 95 38 ff
	ff ff		 mov	 dx, WORD PTR _cy1x0$21[ebp]
  006e2	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx

; 652  :                     dstC[0*dst_y_pitch   + 1] = (Tout)((cy1x0 + cy1x1 + 1) >> 1);

  006e6	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x1$19[ebp]
  006ec	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x0$21[ebp]
  006f2	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  006f6	d1 fa		 sar	 edx, 1
  006f8	6b 45 e4 00	 imul	 eax, DWORD PTR _dst_y_pitch$[ebp], 0
  006fc	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$44[ebp]
  006ff	66 89 54 41 02	 mov	 WORD PTR [ecx+eax*2+2], dx

; 653  :                     dstC[1*dst_y_pitch   + 0] = (Tout)cy3x0;

  00704	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  00707	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  0070a	66 8b 8d 34 ff
	ff ff		 mov	 cx, WORD PTR _cy3x0$20[ebp]
  00711	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx

; 654  :                     dstC[1*dst_y_pitch   + 1] = (Tout)((cy3x0 + cy3x1 + 1) >> 1);

  00715	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR _cy3x1$18[ebp]
  0071b	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$20[ebp]
  00721	8d 4c 10 01	 lea	 ecx, DWORD PTR [eax+edx+1]
  00725	d1 f9		 sar	 ecx, 1
  00727	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  0072a	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  0072d	66 89 4c 50 02	 mov	 WORD PTR [eax+edx*2+2], cx

; 655  :                 }

  00732	e9 e2 fd ff ff	 jmp	 $LN17@convert_yv
$LN18@convert_yv:

; 656  :             } else {

  00737	e9 28 02 00 00	 jmp	 $LN31@convert_yv
$LN35@convert_yv:

; 657  :                 for (int x = 0; x < x_fin; x += 2, dstC += 2, srcP++) {

  0073c	c7 85 28 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _x$17[ebp], 0
  00746	eb 21		 jmp	 SHORT $LN22@convert_yv
$LN20@convert_yv:
  00748	8b 8d 28 ff ff
	ff		 mov	 ecx, DWORD PTR _x$17[ebp]
  0074e	83 c1 02	 add	 ecx, 2
  00751	89 8d 28 ff ff
	ff		 mov	 DWORD PTR _x$17[ebp], ecx
  00757	8b 55 94	 mov	 edx, DWORD PTR _dstC$44[ebp]
  0075a	83 c2 04	 add	 edx, 4
  0075d	89 55 94	 mov	 DWORD PTR _dstC$44[ebp], edx
  00760	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  00763	83 c0 02	 add	 eax, 2
  00766	89 45 90	 mov	 DWORD PTR _srcP$43[ebp], eax
$LN22@convert_yv:
  00769	8b 8d 28 ff ff
	ff		 mov	 ecx, DWORD PTR _x$17[ebp]
  0076f	3b 4d 8c	 cmp	 ecx, DWORD PTR _x_fin$42[ebp]
  00772	0f 8d ec 01 00
	00		 jge	 $LN31@convert_yv

; 658  :                     int cxplus = (x + 2 < x_fin);

  00778	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR _x$17[ebp]
  0077e	83 c2 02	 add	 edx, 2
  00781	3b 55 8c	 cmp	 edx, DWORD PTR _x_fin$42[ebp]
  00784	7d 0c		 jge	 SHORT $LN48@convert_yv
  00786	c7 85 d4 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv432[ebp], 1
  00790	eb 0a		 jmp	 SHORT $LN49@convert_yv
$LN48@convert_yv:
  00792	c7 85 d4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv432[ebp], 0
$LN49@convert_yv:
  0079c	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR tv432[ebp]
  007a2	89 85 24 ff ff
	ff		 mov	 DWORD PTR _cxplus$16[ebp], eax

; 659  :                     int cy0x0 = srcP[-1*src_uv_pitch + 0];

  007a8	6b 4d a8 ff	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], -1
  007ac	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  007af	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  007b3	89 85 20 ff ff
	ff		 mov	 DWORD PTR _cy0x0$15[ebp], eax

; 660  :                     int cy2x0 = srcP[ 0*src_uv_pitch + 0];

  007b9	6b 4d a8 00	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 0
  007bd	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  007c0	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  007c4	89 85 1c ff ff
	ff		 mov	 DWORD PTR _cy2x0$14[ebp], eax

; 661  :                     int cy4x0 = srcP[ 1*src_uv_pitch + 0];

  007ca	8b 4d a8	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  007cd	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  007d0	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  007d4	89 85 18 ff ff
	ff		 mov	 DWORD PTR _cy4x0$13[ebp], eax

; 662  :                     int cy0x1 = srcP[-1*src_uv_pitch + cxplus];

  007da	6b 4d a8 ff	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], -1
  007de	03 8d 24 ff ff
	ff		 add	 ecx, DWORD PTR _cxplus$16[ebp]
  007e4	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  007e7	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  007eb	89 85 14 ff ff
	ff		 mov	 DWORD PTR _cy0x1$12[ebp], eax

; 663  :                     int cy2x1 = srcP[ 0*src_uv_pitch + cxplus];

  007f1	6b 4d a8 00	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 0
  007f5	03 8d 24 ff ff
	ff		 add	 ecx, DWORD PTR _cxplus$16[ebp]
  007fb	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  007fe	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00802	89 85 10 ff ff
	ff		 mov	 DWORD PTR _cy2x1$11[ebp], eax

; 664  :                     int cy4x1 = srcP[ 1*src_uv_pitch + cxplus];

  00808	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR _cxplus$16[ebp]
  0080e	03 4d a8	 add	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00811	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  00814	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00818	89 85 0c ff ff
	ff		 mov	 DWORD PTR _cy4x1$10[ebp], eax

; 665  : 
; 666  :                     int cy1x0 = (cy0x0 * 1 + cy2x0 * 3 + 2);

  0081e	6b 8d 1c ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy2x0$14[ebp], 3
  00825	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR _cy0x0$15[ebp]
  0082b	8d 44 0a 02	 lea	 eax, DWORD PTR [edx+ecx+2]
  0082f	89 85 08 ff ff
	ff		 mov	 DWORD PTR _cy1x0$9[ebp], eax

; 667  :                     int cy3x0 = (cy2x0 * 3 + cy4x0 * 1 + 2);

  00835	6b 8d 1c ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy2x0$14[ebp], 3
  0083c	8b 95 18 ff ff
	ff		 mov	 edx, DWORD PTR _cy4x0$13[ebp]
  00842	8d 44 11 02	 lea	 eax, DWORD PTR [ecx+edx+2]
  00846	89 85 04 ff ff
	ff		 mov	 DWORD PTR _cy3x0$8[ebp], eax

; 668  :                     int cy1x1 = (cy0x1 * 1 + cy2x1 * 3 + 2);

  0084c	6b 8d 10 ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy2x1$11[ebp], 3
  00853	8b 95 14 ff ff
	ff		 mov	 edx, DWORD PTR _cy0x1$12[ebp]
  00859	8d 44 0a 02	 lea	 eax, DWORD PTR [edx+ecx+2]
  0085d	89 85 00 ff ff
	ff		 mov	 DWORD PTR _cy1x1$7[ebp], eax

; 669  :                     int cy3x1 = (cy2x1 * 3 + cy4x1 * 1 + 2);

  00863	6b 8d 10 ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy2x1$11[ebp], 3
  0086a	8b 95 0c ff ff
	ff		 mov	 edx, DWORD PTR _cy4x1$10[ebp]
  00870	8d 44 11 02	 lea	 eax, DWORD PTR [ecx+edx+2]
  00874	89 85 fc fe ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], eax

; 670  :                     CHANGE_BIT_DEPTH_4(cy1x0, cy3x0, cy1x1, cy3x1, 2);

  0087a	b9 01 00 00 00	 mov	 ecx, 1
  0087f	85 c9		 test	 ecx, ecx
  00881	74 3e		 je	 SHORT $LN40@convert_yv
  00883	8b 95 08 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x0$9[ebp]
  00889	c1 e2 02	 shl	 edx, 2
  0088c	89 95 08 ff ff
	ff		 mov	 DWORD PTR _cy1x0$9[ebp], edx
  00892	8b 85 04 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$8[ebp]
  00898	c1 e0 02	 shl	 eax, 2
  0089b	89 85 04 ff ff
	ff		 mov	 DWORD PTR _cy3x0$8[ebp], eax
  008a1	8b 8d 00 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x1$7[ebp]
  008a7	c1 e1 02	 shl	 ecx, 2
  008aa	89 8d 00 ff ff
	ff		 mov	 DWORD PTR _cy1x1$7[ebp], ecx
  008b0	8b 95 fc fe ff
	ff		 mov	 edx, DWORD PTR _cy3x1$6[ebp]
  008b6	c1 e2 02	 shl	 edx, 2
  008b9	89 95 fc fe ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], edx
  008bf	eb 40		 jmp	 SHORT $LN41@convert_yv
$LN40@convert_yv:
  008c1	33 c0		 xor	 eax, eax
  008c3	74 3c		 je	 SHORT $LN41@convert_yv
  008c5	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x0$9[ebp]
  008cb	c1 f9 fe	 sar	 ecx, -2			; fffffffeH
  008ce	89 8d 08 ff ff
	ff		 mov	 DWORD PTR _cy1x0$9[ebp], ecx
  008d4	8b 95 04 ff ff
	ff		 mov	 edx, DWORD PTR _cy3x0$8[ebp]
  008da	c1 fa fe	 sar	 edx, -2			; fffffffeH
  008dd	89 95 04 ff ff
	ff		 mov	 DWORD PTR _cy3x0$8[ebp], edx
  008e3	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x1$7[ebp]
  008e9	c1 f8 fe	 sar	 eax, -2			; fffffffeH
  008ec	89 85 00 ff ff
	ff		 mov	 DWORD PTR _cy1x1$7[ebp], eax
  008f2	8b 8d fc fe ff
	ff		 mov	 ecx, DWORD PTR _cy3x1$6[ebp]
  008f8	c1 f9 fe	 sar	 ecx, -2			; fffffffeH
  008fb	89 8d fc fe ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], ecx
$LN41@convert_yv:

; 671  : 
; 672  :                     dstC[0*dst_y_pitch   + 0] = (Tout)cy1x0;

  00901	6b 55 e4 00	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 0
  00905	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  00908	66 8b 8d 08 ff
	ff ff		 mov	 cx, WORD PTR _cy1x0$9[ebp]
  0090f	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx

; 673  :                     dstC[0*dst_y_pitch   + 1] = (Tout)((cy1x0 + cy1x1 + 1) >> 1);

  00913	8b 95 00 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x1$7[ebp]
  00919	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x0$9[ebp]
  0091f	8d 4c 10 01	 lea	 ecx, DWORD PTR [eax+edx+1]
  00923	d1 f9		 sar	 ecx, 1
  00925	6b 55 e4 00	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 0
  00929	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  0092c	66 89 4c 50 02	 mov	 WORD PTR [eax+edx*2+2], cx

; 674  :                     dstC[1*dst_y_pitch   + 0] = (Tout)cy3x0;

  00931	8b 4d e4	 mov	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  00934	8b 55 94	 mov	 edx, DWORD PTR _dstC$44[ebp]
  00937	66 8b 85 04 ff
	ff ff		 mov	 ax, WORD PTR _cy3x0$8[ebp]
  0093e	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax

; 675  :                     dstC[1*dst_y_pitch   + 1] = (Tout)((cy3x0 + cy3x1 + 1) >> 1);

  00942	8b 8d fc fe ff
	ff		 mov	 ecx, DWORD PTR _cy3x1$6[ebp]
  00948	8b 95 04 ff ff
	ff		 mov	 edx, DWORD PTR _cy3x0$8[ebp]
  0094e	8d 44 0a 01	 lea	 eax, DWORD PTR [edx+ecx+1]
  00952	d1 f8		 sar	 eax, 1
  00954	8b 4d e4	 mov	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  00957	8b 55 94	 mov	 edx, DWORD PTR _dstC$44[ebp]
  0095a	66 89 44 4a 02	 mov	 WORD PTR [edx+ecx*2+2], ax

; 676  :                 }

  0095f	e9 e4 fd ff ff	 jmp	 $LN20@convert_yv
$LN31@convert_yv:

; 677  :             }
; 678  :         }

  00964	e9 38 f9 ff ff	 jmp	 $LN11@convert_yv
$LN12@convert_yv:

; 679  :     }

  00969	e9 e6 f8 ff ff	 jmp	 $LN8@convert_yv
$LN1@convert_yv:

; 680  : }

  0096e	52		 push	 edx
  0096f	8b cd		 mov	 ecx, ebp
  00971	50		 push	 eax
  00972	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN52@convert_yv
  00978	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0097d	58		 pop	 eax
  0097e	5a		 pop	 edx
  0097f	5f		 pop	 edi
  00980	5e		 pop	 esi
  00981	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00984	33 cd		 xor	 ecx, ebp
  00986	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0098b	81 c4 2c 01 00
	00		 add	 esp, 300		; 0000012cH
  00991	3b ec		 cmp	 ebp, esp
  00993	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00998	8b e5		 mov	 esp, ebp
  0099a	5d		 pop	 ebp
  0099b	c3		 ret	 0
$LN52@convert_yv:
  0099c	01 00 00 00	 DD	 1
  009a0	00 00 00 00	 DD	 $LN51@convert_yv
$LN51@convert_yv:
  009a4	d4 ff ff ff	 DD	 -44			; ffffffd4H
  009a8	0c 00 00 00	 DD	 12			; 0000000cH
  009ac	00 00 00 00	 DD	 $LN50@convert_yv
$LN50@convert_yv:
  009b0	79		 DB	 121			; 00000079H
  009b1	5f		 DB	 95			; 0000005fH
  009b2	72		 DB	 114			; 00000072H
  009b3	61		 DB	 97			; 00000061H
  009b4	6e		 DB	 110			; 0000006eH
  009b5	67		 DB	 103			; 00000067H
  009b6	65		 DB	 101			; 00000065H
  009b7	00		 DB	 0
??$convert_yv12_p_to_yuv444_c@G$0M@G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_p_to_yuv444_c<unsigned short,12,unsigned short,16,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yv12_12_p_to_yuv444_16bit@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_12_p_to_yuv444_16bit

; 849  : static void convert_yv12_12_p_to_yuv444_16bit(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 850  :     convert_yv12_p_to_yuv444_c<uint16_t, 12, uint16_t, 16, false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yv12_p_to_yuv444_c@G$0M@G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_p_to_yuv444_c<unsigned short,12,unsigned short,16,0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 851  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yv12_12_p_to_yuv444_16bit@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_12_p_to_yuv444_16bit
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
tv302 = -280						; size = 4
tv240 = -276						; size = 4
tv241 = -272						; size = 4
tv235 = -268						; size = 4
tv232 = -264						; size = 4
tv229 = -260						; size = 4
tv227 = -256						; size = 4
$T1 = -252						; size = 4
$T2 = -248						; size = 4
$T3 = -244						; size = 4
$T4 = -240						; size = 4
$T5 = -236						; size = 12
_cy3x1$6 = -224						; size = 4
_cy2x1$7 = -220						; size = 4
_cy1x1$8 = -216						; size = 4
_cy0x1$9 = -212						; size = 4
_sy5x1$10 = -208					; size = 4
_sy4x1$11 = -204					; size = 4
_sy3x1$12 = -200					; size = 4
_sy2x1$13 = -196					; size = 4
_sy1x1$14 = -192					; size = 4
_sy0x1$15 = -188					; size = 4
_cxplus$16 = -184					; size = 4
_x$17 = -180						; size = 4
_cy3x0$18 = -176					; size = 4
_cy2x0$19 = -172					; size = 4
_cy1x0$20 = -168					; size = 4
_cy0x0$21 = -164					; size = 4
_sy5x0$22 = -160					; size = 4
_sy4x0$23 = -156					; size = 4
_sy3x0$24 = -152					; size = 4
_sy2x0$25 = -148					; size = 4
_sy1x0$26 = -144					; size = 4
_sy0x0$27 = -140					; size = 4
_y_p3$28 = -136						; size = 4
_y_p2$29 = -132						; size = 4
_y_p1$30 = -128						; size = 4
_y_m1$31 = -124						; size = 4
_y_m2$32 = -120						; size = 4
_x_fin$33 = -116					; size = 4
_srcP$34 = -112						; size = 4
_dstC$35 = -108						; size = 4
_y$36 = -104						; size = 4
_dstLine$37 = -100					; size = 4
_srcCLine$38 = -96					; size = 4
_ic$39 = -92						; size = 4
_src_uv_pitch$ = -88					; size = 4
_uv_fin$ = -84						; size = 4
_x$40 = -80						; size = 4
_y$41 = -76						; size = 4
_y_width$42 = -72					; size = 4
_dstLine$43 = -68					; size = 4
_srcYLine$44 = -64					; size = 4
$T45 = -60						; size = 12
_y_range$ = -44						; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yv12_i_to_yuv444_c@G$0O@G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_i_to_yuv444_c<unsigned short,14,unsigned short,16,0>

; 683  : static void __forceinline convert_yv12_i_to_yuv444_c(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8d bd e8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-280]
  00011	b9 46 00 00 00	 mov	 ecx, 70			; 00000046H
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 684  :     static_assert((sizeof(Tin)  == 1 && in_bit_depth  == 8) || (sizeof(Tin)  == 2 && 8 < in_bit_depth  && in_bit_depth  <= 16), "invalid input bit depth.");
; 685  :     static_assert((sizeof(Tout) == 1 && out_bit_depth == 8) || (sizeof(Tout) == 2 && 8 < out_bit_depth && out_bit_depth <= 16), "invalid output bit depth.");
; 686  :     const int crop_left   = crop[0];

  00027	b8 04 00 00 00	 mov	 eax, 4
  0002c	6b c8 00	 imul	 ecx, eax, 0
  0002f	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00032	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00035	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 687  :     const int crop_up     = crop[1];

  00038	b9 04 00 00 00	 mov	 ecx, 4
  0003d	c1 e1 00	 shl	 ecx, 0
  00040	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00043	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00046	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 688  :     const int crop_right  = crop[2];

  00049	b9 04 00 00 00	 mov	 ecx, 4
  0004e	d1 e1		 shl	 ecx, 1
  00050	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00053	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00056	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 689  :     const int crop_bottom = crop[3];

  00059	b9 04 00 00 00	 mov	 ecx, 4
  0005e	6b d1 03	 imul	 edx, ecx, 3
  00061	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00064	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00067	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 690  :     const int src_y_pitch = src_y_pitch_byte / sizeof(Tin);

  0006a	8b 55 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebp]
  0006d	d1 ea		 shr	 edx, 1
  0006f	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 691  :     const int dst_y_pitch = dst_y_pitch_byte / sizeof(Tout);

  00072	8b 45 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  00075	d1 e8		 shr	 eax, 1
  00077	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 692  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  0007a	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0007d	51		 push	 ecx
  0007e	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  00081	52		 push	 edx
  00082	8b 45 20	 mov	 eax, DWORD PTR _height$[ebp]
  00085	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  00088	50		 push	 eax
  00089	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  0008c	51		 push	 ecx
  0008d	8d 95 14 ff ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  00093	52		 push	 edx
  00094	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00099	83 c4 14	 add	 esp, 20			; 00000014H
  0009c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009e	89 4d c4	 mov	 DWORD PTR $T45[ebp], ecx
  000a1	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a4	89 55 c8	 mov	 DWORD PTR $T45[ebp+4], edx
  000a7	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000aa	89 45 cc	 mov	 DWORD PTR $T45[ebp+8], eax
  000ad	8b 4d c4	 mov	 ecx, DWORD PTR $T45[ebp]
  000b0	89 4d d4	 mov	 DWORD PTR _y_range$[ebp], ecx
  000b3	8b 55 c8	 mov	 edx, DWORD PTR $T45[ebp+4]
  000b6	89 55 d8	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000b9	8b 45 cc	 mov	 eax, DWORD PTR $T45[ebp+8]
  000bc	89 45 dc	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 693  :     //Y
; 694  :     if (!uv_only) {

  000bf	b9 01 00 00 00	 mov	 ecx, 1
  000c4	85 c9		 test	 ecx, ecx
  000c6	0f 84 6e 01 00
	00		 je	 $LN17@convert_yv

; 695  :         Tin *srcYLine = (Tin *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000cc	ba 04 00 00 00	 mov	 edx, 4
  000d1	6b c2 00	 imul	 eax, edx, 0
  000d4	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  000d7	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  000db	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  000de	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  000e1	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  000e4	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  000e7	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  000ea	89 45 c0	 mov	 DWORD PTR _srcYLine$44[ebp], eax

; 696  :         Tout *dstLine = (Tout *)dst[0] + dst_y_pitch * y_range.start_dst;

  000ed	b9 04 00 00 00	 mov	 ecx, 4
  000f2	6b d1 00	 imul	 edx, ecx, 0
  000f5	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  000f8	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  000fc	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  000ff	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  00102	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  00105	89 45 bc	 mov	 DWORD PTR _dstLine$43[ebp], eax

; 697  :         const int y_width = width - crop_right - crop_left;

  00108	8b 4d 10	 mov	 ecx, DWORD PTR _width$[ebp]
  0010b	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  0010e	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  00111	89 4d b8	 mov	 DWORD PTR _y_width$42[ebp], ecx

; 698  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  00114	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _y$41[ebp], 0
  0011b	eb 21		 jmp	 SHORT $LN4@convert_yv
$LN2@convert_yv:
  0011d	8b 55 b4	 mov	 edx, DWORD PTR _y$41[ebp]
  00120	83 c2 01	 add	 edx, 1
  00123	89 55 b4	 mov	 DWORD PTR _y$41[ebp], edx
  00126	8b 45 e8	 mov	 eax, DWORD PTR _src_y_pitch$[ebp]
  00129	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$44[ebp]
  0012c	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  0012f	89 55 c0	 mov	 DWORD PTR _srcYLine$44[ebp], edx
  00132	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  00135	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$43[ebp]
  00138	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  0013b	89 55 bc	 mov	 DWORD PTR _dstLine$43[ebp], edx
$LN4@convert_yv:
  0013e	8b 45 b4	 mov	 eax, DWORD PTR _y$41[ebp]
  00141	3b 45 dc	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  00144	0f 8d f0 00 00
	00		 jge	 $LN17@convert_yv

; 699  :             if (in_bit_depth == out_bit_depth) {

  0014a	33 c9		 xor	 ecx, ecx
  0014c	74 1b		 je	 SHORT $LN18@convert_yv

; 700  :                 memcpy(dstLine, srcYLine, y_width * sizeof(Tin));

  0014e	8b 55 b8	 mov	 edx, DWORD PTR _y_width$42[ebp]
  00151	d1 e2		 shl	 edx, 1
  00153	52		 push	 edx
  00154	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$44[ebp]
  00157	50		 push	 eax
  00158	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$43[ebp]
  0015b	51		 push	 ecx
  0015c	e8 00 00 00 00	 call	 _memcpy
  00161	83 c4 0c	 add	 esp, 12			; 0000000cH

; 701  :             } else {

  00164	e9 cc 00 00 00	 jmp	 $LN19@convert_yv
$LN18@convert_yv:

; 702  :                 for (int x = 0; x < y_width; x++) {

  00169	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _x$40[ebp], 0
  00170	eb 09		 jmp	 SHORT $LN7@convert_yv
$LN5@convert_yv:
  00172	8b 55 b0	 mov	 edx, DWORD PTR _x$40[ebp]
  00175	83 c2 01	 add	 edx, 1
  00178	89 55 b0	 mov	 DWORD PTR _x$40[ebp], edx
$LN7@convert_yv:
  0017b	8b 45 b0	 mov	 eax, DWORD PTR _x$40[ebp]
  0017e	3b 45 b8	 cmp	 eax, DWORD PTR _y_width$42[ebp]
  00181	0f 8d ae 00 00
	00		 jge	 $LN19@convert_yv

; 703  :                     if (out_bit_depth > in_bit_depth) {

  00187	b9 01 00 00 00	 mov	 ecx, 1
  0018c	85 c9		 test	 ecx, ecx
  0018e	74 44		 je	 SHORT $LN20@convert_yv

; 704  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) << std::max(out_bit_depth - in_bit_depth, 0));

  00190	c7 85 10 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], 0
  0019a	c7 85 0c ff ff
	ff 02 00 00 00	 mov	 DWORD PTR $T3[ebp], 2
  001a4	8b 55 b0	 mov	 edx, DWORD PTR _x$40[ebp]
  001a7	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$44[ebp]
  001aa	0f b7 34 50	 movzx	 esi, WORD PTR [eax+edx*2]
  001ae	8d 8d 10 ff ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  001b4	51		 push	 ecx
  001b5	8d 95 0c ff ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  001bb	52		 push	 edx
  001bc	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  001c1	83 c4 08	 add	 esp, 8
  001c4	8b 08		 mov	 ecx, DWORD PTR [eax]
  001c6	d3 e6		 shl	 esi, cl
  001c8	8b 45 b0	 mov	 eax, DWORD PTR _x$40[ebp]
  001cb	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$43[ebp]
  001ce	66 89 34 41	 mov	 WORD PTR [ecx+eax*2], si
  001d2	eb 5c		 jmp	 SHORT $LN21@convert_yv
$LN20@convert_yv:

; 705  :                     } else if (out_bit_depth < in_bit_depth) {

  001d4	33 d2		 xor	 edx, edx
  001d6	74 44		 je	 SHORT $LN22@convert_yv

; 706  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) >> std::max(in_bit_depth - out_bit_depth, 0));

  001d8	c7 85 08 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], 0
  001e2	c7 85 04 ff ff
	ff fe ff ff ff	 mov	 DWORD PTR $T1[ebp], -2	; fffffffeH
  001ec	8b 45 b0	 mov	 eax, DWORD PTR _x$40[ebp]
  001ef	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$44[ebp]
  001f2	0f b7 34 41	 movzx	 esi, WORD PTR [ecx+eax*2]
  001f6	8d 95 08 ff ff
	ff		 lea	 edx, DWORD PTR $T2[ebp]
  001fc	52		 push	 edx
  001fd	8d 85 04 ff ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  00203	50		 push	 eax
  00204	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  00209	83 c4 08	 add	 esp, 8
  0020c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0020e	d3 fe		 sar	 esi, cl
  00210	8b 4d b0	 mov	 ecx, DWORD PTR _x$40[ebp]
  00213	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$43[ebp]
  00216	66 89 34 4a	 mov	 WORD PTR [edx+ecx*2], si

; 707  :                     } else {

  0021a	eb 14		 jmp	 SHORT $LN21@convert_yv
$LN22@convert_yv:

; 708  :                         dstLine[x] = (Tout)srcYLine[x];

  0021c	8b 45 b0	 mov	 eax, DWORD PTR _x$40[ebp]
  0021f	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$43[ebp]
  00222	8b 55 b0	 mov	 edx, DWORD PTR _x$40[ebp]
  00225	8b 75 c0	 mov	 esi, DWORD PTR _srcYLine$44[ebp]
  00228	66 8b 14 56	 mov	 dx, WORD PTR [esi+edx*2]
  0022c	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx
$LN21@convert_yv:

; 709  :                     }
; 710  :                 }

  00230	e9 3d ff ff ff	 jmp	 $LN5@convert_yv
$LN19@convert_yv:

; 711  :             }
; 712  :         }

  00235	e9 e3 fe ff ff	 jmp	 $LN2@convert_yv
$LN17@convert_yv:

; 713  :     }
; 714  :     //UV
; 715  :     const int uv_fin = height - crop_bottom;

  0023a	8b 45 20	 mov	 eax, DWORD PTR _height$[ebp]
  0023d	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  00240	89 45 ac	 mov	 DWORD PTR _uv_fin$[ebp], eax

; 716  :     const int src_uv_pitch = src_uv_pitch_byte / sizeof(Tin);

  00243	8b 4d 18	 mov	 ecx, DWORD PTR _src_uv_pitch_byte$[ebp]
  00246	d1 e9		 shr	 ecx, 1
  00248	89 4d a8	 mov	 DWORD PTR _src_uv_pitch$[ebp], ecx

; 717  :     for (int ic = 1; ic < 3; ic++) {

  0024b	c7 45 a4 01 00
	00 00		 mov	 DWORD PTR _ic$39[ebp], 1
  00252	eb 09		 jmp	 SHORT $LN10@convert_yv
$LN8@convert_yv:
  00254	8b 55 a4	 mov	 edx, DWORD PTR _ic$39[ebp]
  00257	83 c2 01	 add	 edx, 1
  0025a	89 55 a4	 mov	 DWORD PTR _ic$39[ebp], edx
$LN10@convert_yv:
  0025d	83 7d a4 03	 cmp	 DWORD PTR _ic$39[ebp], 3
  00261	0f 8d bc 05 00
	00		 jge	 $LN1@convert_yv

; 718  :         Tin *srcCLine = (Tin *)src[ic] + (((src_uv_pitch * y_range.start_src) + crop_left) >> 1);

  00267	8b 45 a8	 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  0026a	0f af 45 d4	 imul	 eax, DWORD PTR _y_range$[ebp]
  0026e	03 45 f8	 add	 eax, DWORD PTR _crop_left$[ebp]
  00271	d1 f8		 sar	 eax, 1
  00273	8b 4d a4	 mov	 ecx, DWORD PTR _ic$39[ebp]
  00276	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  00279	8b 0c 8a	 mov	 ecx, DWORD PTR [edx+ecx*4]
  0027c	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  0027f	89 55 a0	 mov	 DWORD PTR _srcCLine$38[ebp], edx

; 719  :         Tout *dstLine = (Tout *)dst[ic] + dst_y_pitch * y_range.start_dst;

  00282	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  00285	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  00289	8b 4d a4	 mov	 ecx, DWORD PTR _ic$39[ebp]
  0028c	8b 55 08	 mov	 edx, DWORD PTR _dst$[ebp]
  0028f	8b 0c 8a	 mov	 ecx, DWORD PTR [edx+ecx*4]
  00292	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00295	89 55 9c	 mov	 DWORD PTR _dstLine$37[ebp], edx

; 720  :         for (int y = 0; y < y_range.len; y += 4, srcCLine += src_uv_pitch * 2, dstLine += dst_y_pitch * 4) {

  00298	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _y$36[ebp], 0
  0029f	eb 26		 jmp	 SHORT $LN13@convert_yv
$LN11@convert_yv:
  002a1	8b 45 98	 mov	 eax, DWORD PTR _y$36[ebp]
  002a4	83 c0 04	 add	 eax, 4
  002a7	89 45 98	 mov	 DWORD PTR _y$36[ebp], eax
  002aa	8b 4d a8	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  002ad	d1 e1		 shl	 ecx, 1
  002af	8b 55 a0	 mov	 edx, DWORD PTR _srcCLine$38[ebp]
  002b2	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  002b5	89 45 a0	 mov	 DWORD PTR _srcCLine$38[ebp], eax
  002b8	8b 4d e4	 mov	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  002bb	c1 e1 02	 shl	 ecx, 2
  002be	8b 55 9c	 mov	 edx, DWORD PTR _dstLine$37[ebp]
  002c1	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  002c4	89 45 9c	 mov	 DWORD PTR _dstLine$37[ebp], eax
$LN13@convert_yv:
  002c7	8b 4d 98	 mov	 ecx, DWORD PTR _y$36[ebp]
  002ca	3b 4d dc	 cmp	 ecx, DWORD PTR _y_range$[ebp+8]
  002cd	0f 8d 4b 05 00
	00		 jge	 $LN12@convert_yv

; 721  :             Tout *dstC = dstLine;

  002d3	8b 55 9c	 mov	 edx, DWORD PTR _dstLine$37[ebp]
  002d6	89 55 94	 mov	 DWORD PTR _dstC$35[ebp], edx

; 722  :             Tin *srcP = srcCLine;

  002d9	8b 45 a0	 mov	 eax, DWORD PTR _srcCLine$38[ebp]
  002dc	89 45 90	 mov	 DWORD PTR _srcP$34[ebp], eax

; 723  :             const int x_fin = width - crop_right - crop_left;

  002df	8b 4d 10	 mov	 ecx, DWORD PTR _width$[ebp]
  002e2	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  002e5	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  002e8	89 4d 8c	 mov	 DWORD PTR _x_fin$33[ebp], ecx

; 724  : 
; 725  :             int y_m2 = (y >= 4) ? -2 : 0;

  002eb	83 7d 98 04	 cmp	 DWORD PTR _y$36[ebp], 4
  002ef	7c 0c		 jl	 SHORT $LN31@convert_yv
  002f1	c7 85 00 ff ff
	ff fe ff ff ff	 mov	 DWORD PTR tv227[ebp], -2 ; fffffffeH
  002fb	eb 0a		 jmp	 SHORT $LN32@convert_yv
$LN31@convert_yv:
  002fd	c7 85 00 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv227[ebp], 0
$LN32@convert_yv:
  00307	8b 95 00 ff ff
	ff		 mov	 edx, DWORD PTR tv227[ebp]
  0030d	89 55 88	 mov	 DWORD PTR _y_m2$32[ebp], edx

; 726  :             int y_m1 = (y >= 2) ? -1 : 1;

  00310	83 7d 98 02	 cmp	 DWORD PTR _y$36[ebp], 2
  00314	7c 0c		 jl	 SHORT $LN33@convert_yv
  00316	c7 85 fc fe ff
	ff ff ff ff ff	 mov	 DWORD PTR tv229[ebp], -1
  00320	eb 0a		 jmp	 SHORT $LN34@convert_yv
$LN33@convert_yv:
  00322	c7 85 fc fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv229[ebp], 1
$LN34@convert_yv:
  0032c	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR tv229[ebp]
  00332	89 45 84	 mov	 DWORD PTR _y_m1$31[ebp], eax

; 727  :             int y_p1 = (y < uv_fin - 2) ? 1 : -1;

  00335	8b 4d ac	 mov	 ecx, DWORD PTR _uv_fin$[ebp]
  00338	83 e9 02	 sub	 ecx, 2
  0033b	39 4d 98	 cmp	 DWORD PTR _y$36[ebp], ecx
  0033e	7d 0c		 jge	 SHORT $LN35@convert_yv
  00340	c7 85 f8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv232[ebp], 1
  0034a	eb 0a		 jmp	 SHORT $LN36@convert_yv
$LN35@convert_yv:
  0034c	c7 85 f8 fe ff
	ff ff ff ff ff	 mov	 DWORD PTR tv232[ebp], -1
$LN36@convert_yv:
  00356	8b 95 f8 fe ff
	ff		 mov	 edx, DWORD PTR tv232[ebp]
  0035c	89 55 80	 mov	 DWORD PTR _y_p1$30[ebp], edx

; 728  :             int y_p2 = (y < uv_fin - 4) ? 2 :  0;

  0035f	8b 45 ac	 mov	 eax, DWORD PTR _uv_fin$[ebp]
  00362	83 e8 04	 sub	 eax, 4
  00365	39 45 98	 cmp	 DWORD PTR _y$36[ebp], eax
  00368	7d 0c		 jge	 SHORT $LN37@convert_yv
  0036a	c7 85 f4 fe ff
	ff 02 00 00 00	 mov	 DWORD PTR tv235[ebp], 2
  00374	eb 0a		 jmp	 SHORT $LN38@convert_yv
$LN37@convert_yv:
  00376	c7 85 f4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv235[ebp], 0
$LN38@convert_yv:
  00380	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR tv235[ebp]
  00386	89 8d 7c ff ff
	ff		 mov	 DWORD PTR _y_p2$29[ebp], ecx

; 729  :             int y_p3 = (y < uv_fin - 6) ? 3 : ((y < uv_fin - 2) ? 1 : -1);

  0038c	8b 55 ac	 mov	 edx, DWORD PTR _uv_fin$[ebp]
  0038f	83 ea 06	 sub	 edx, 6
  00392	39 55 98	 cmp	 DWORD PTR _y$36[ebp], edx
  00395	7d 0c		 jge	 SHORT $LN41@convert_yv
  00397	c7 85 f0 fe ff
	ff 03 00 00 00	 mov	 DWORD PTR tv241[ebp], 3
  003a1	eb 2d		 jmp	 SHORT $LN42@convert_yv
$LN41@convert_yv:
  003a3	8b 45 ac	 mov	 eax, DWORD PTR _uv_fin$[ebp]
  003a6	83 e8 02	 sub	 eax, 2
  003a9	39 45 98	 cmp	 DWORD PTR _y$36[ebp], eax
  003ac	7d 0c		 jge	 SHORT $LN39@convert_yv
  003ae	c7 85 ec fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv240[ebp], 1
  003b8	eb 0a		 jmp	 SHORT $LN40@convert_yv
$LN39@convert_yv:
  003ba	c7 85 ec fe ff
	ff ff ff ff ff	 mov	 DWORD PTR tv240[ebp], -1
$LN40@convert_yv:
  003c4	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR tv240[ebp]
  003ca	89 8d f0 fe ff
	ff		 mov	 DWORD PTR tv241[ebp], ecx
$LN42@convert_yv:
  003d0	8b 95 f0 fe ff
	ff		 mov	 edx, DWORD PTR tv241[ebp]
  003d6	89 95 78 ff ff
	ff		 mov	 DWORD PTR _y_p3$28[ebp], edx

; 730  : 
; 731  :             int sy0x0 = srcP[y_m2*src_uv_pitch + 0];

  003dc	8b 45 88	 mov	 eax, DWORD PTR _y_m2$32[ebp]
  003df	0f af 45 a8	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp]
  003e3	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  003e6	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  003ea	89 95 74 ff ff
	ff		 mov	 DWORD PTR _sy0x0$27[ebp], edx

; 732  :             int sy1x0 = srcP[y_m1*src_uv_pitch + 0];

  003f0	8b 45 84	 mov	 eax, DWORD PTR _y_m1$31[ebp]
  003f3	0f af 45 a8	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp]
  003f7	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  003fa	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  003fe	89 95 70 ff ff
	ff		 mov	 DWORD PTR _sy1x0$26[ebp], edx

; 733  :             int sy2x0 = srcP[   0*src_uv_pitch + 0];

  00404	6b 45 a8 00	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp], 0
  00408	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  0040b	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  0040f	89 95 6c ff ff
	ff		 mov	 DWORD PTR _sy2x0$25[ebp], edx

; 734  :             int sy3x0 = srcP[y_p1*src_uv_pitch + 0];

  00415	8b 45 80	 mov	 eax, DWORD PTR _y_p1$30[ebp]
  00418	0f af 45 a8	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp]
  0041c	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  0041f	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  00423	89 95 68 ff ff
	ff		 mov	 DWORD PTR _sy3x0$24[ebp], edx

; 735  :             int sy4x0 = srcP[y_p2*src_uv_pitch + 0];

  00429	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _y_p2$29[ebp]
  0042f	0f af 45 a8	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp]
  00433	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  00436	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  0043a	89 95 64 ff ff
	ff		 mov	 DWORD PTR _sy4x0$23[ebp], edx

; 736  :             int sy5x0 = srcP[y_p3*src_uv_pitch + 0];

  00440	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _y_p3$28[ebp]
  00446	0f af 45 a8	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp]
  0044a	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  0044d	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  00451	89 95 60 ff ff
	ff		 mov	 DWORD PTR _sy5x0$22[ebp], edx

; 737  : 
; 738  :             int cy0x0 = (sy0x0 * 1 + sy2x0 * 7 + 4);

  00457	6b 85 6c ff ff
	ff 07		 imul	 eax, DWORD PTR _sy2x0$25[ebp], 7
  0045e	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _sy0x0$27[ebp]
  00464	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00468	89 95 5c ff ff
	ff		 mov	 DWORD PTR _cy0x0$21[ebp], edx

; 739  :             int cy1x0 = (sy1x0 * 3 + sy3x0 * 5 + 4);

  0046e	6b 85 70 ff ff
	ff 03		 imul	 eax, DWORD PTR _sy1x0$26[ebp], 3
  00475	6b 8d 68 ff ff
	ff 05		 imul	 ecx, DWORD PTR _sy3x0$24[ebp], 5
  0047c	8d 54 08 04	 lea	 edx, DWORD PTR [eax+ecx+4]
  00480	89 95 58 ff ff
	ff		 mov	 DWORD PTR _cy1x0$20[ebp], edx

; 740  :             int cy2x0 = (sy2x0 * 5 + sy4x0 * 3 + 4);

  00486	6b 85 6c ff ff
	ff 05		 imul	 eax, DWORD PTR _sy2x0$25[ebp], 5
  0048d	6b 8d 64 ff ff
	ff 03		 imul	 ecx, DWORD PTR _sy4x0$23[ebp], 3
  00494	8d 54 08 04	 lea	 edx, DWORD PTR [eax+ecx+4]
  00498	89 95 54 ff ff
	ff		 mov	 DWORD PTR _cy2x0$19[ebp], edx

; 741  :             int cy3x0 = (sy3x0 * 7 + sy5x0 * 1 + 4);

  0049e	6b 85 68 ff ff
	ff 07		 imul	 eax, DWORD PTR _sy3x0$24[ebp], 7
  004a5	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _sy5x0$22[ebp]
  004ab	8d 54 08 04	 lea	 edx, DWORD PTR [eax+ecx+4]
  004af	89 95 50 ff ff
	ff		 mov	 DWORD PTR _cy3x0$18[ebp], edx

; 742  :             CHANGE_BIT_DEPTH_4(cy0x0, cy1x0, cy2x0, cy3x0, 3);

  004b5	33 c0		 xor	 eax, eax
  004b7	74 3e		 je	 SHORT $LN24@convert_yv
  004b9	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _cy0x0$21[ebp]
  004bf	c1 e1 ff	 shl	 ecx, -1
  004c2	89 8d 5c ff ff
	ff		 mov	 DWORD PTR _cy0x0$21[ebp], ecx
  004c8	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x0$20[ebp]
  004ce	c1 e2 ff	 shl	 edx, -1
  004d1	89 95 58 ff ff
	ff		 mov	 DWORD PTR _cy1x0$20[ebp], edx
  004d7	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR _cy2x0$19[ebp]
  004dd	c1 e0 ff	 shl	 eax, -1
  004e0	89 85 54 ff ff
	ff		 mov	 DWORD PTR _cy2x0$19[ebp], eax
  004e6	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x0$18[ebp]
  004ec	c1 e1 ff	 shl	 ecx, -1
  004ef	89 8d 50 ff ff
	ff		 mov	 DWORD PTR _cy3x0$18[ebp], ecx
  004f5	eb 41		 jmp	 SHORT $LN25@convert_yv
$LN24@convert_yv:
  004f7	ba 01 00 00 00	 mov	 edx, 1
  004fc	85 d2		 test	 edx, edx
  004fe	74 38		 je	 SHORT $LN25@convert_yv
  00500	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _cy0x0$21[ebp]
  00506	d1 f8		 sar	 eax, 1
  00508	89 85 5c ff ff
	ff		 mov	 DWORD PTR _cy0x0$21[ebp], eax
  0050e	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x0$20[ebp]
  00514	d1 f9		 sar	 ecx, 1
  00516	89 8d 58 ff ff
	ff		 mov	 DWORD PTR _cy1x0$20[ebp], ecx
  0051c	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR _cy2x0$19[ebp]
  00522	d1 fa		 sar	 edx, 1
  00524	89 95 54 ff ff
	ff		 mov	 DWORD PTR _cy2x0$19[ebp], edx
  0052a	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$18[ebp]
  00530	d1 f8		 sar	 eax, 1
  00532	89 85 50 ff ff
	ff		 mov	 DWORD PTR _cy3x0$18[ebp], eax
$LN25@convert_yv:

; 743  : 
; 744  :             for (int x = 0; x < x_fin; x += 2, dstC += 2, srcP++) {

  00538	c7 85 4c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _x$17[ebp], 0
  00542	eb 21		 jmp	 SHORT $LN16@convert_yv
$LN14@convert_yv:
  00544	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _x$17[ebp]
  0054a	83 c1 02	 add	 ecx, 2
  0054d	89 8d 4c ff ff
	ff		 mov	 DWORD PTR _x$17[ebp], ecx
  00553	8b 55 94	 mov	 edx, DWORD PTR _dstC$35[ebp]
  00556	83 c2 04	 add	 edx, 4
  00559	89 55 94	 mov	 DWORD PTR _dstC$35[ebp], edx
  0055c	8b 45 90	 mov	 eax, DWORD PTR _srcP$34[ebp]
  0055f	83 c0 02	 add	 eax, 2
  00562	89 45 90	 mov	 DWORD PTR _srcP$34[ebp], eax
$LN16@convert_yv:
  00565	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _x$17[ebp]
  0056b	3b 4d 8c	 cmp	 ecx, DWORD PTR _x_fin$33[ebp]
  0056e	0f 8d a5 02 00
	00		 jge	 $LN15@convert_yv

; 745  :                 int cxplus = (x + 2 < x_fin);

  00574	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR _x$17[ebp]
  0057a	83 c2 02	 add	 edx, 2
  0057d	3b 55 8c	 cmp	 edx, DWORD PTR _x_fin$33[ebp]
  00580	7d 0c		 jge	 SHORT $LN43@convert_yv
  00582	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv302[ebp], 1
  0058c	eb 0a		 jmp	 SHORT $LN44@convert_yv
$LN43@convert_yv:
  0058e	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv302[ebp], 0
$LN44@convert_yv:
  00598	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv302[ebp]
  0059e	89 85 48 ff ff
	ff		 mov	 DWORD PTR _cxplus$16[ebp], eax

; 746  :                 int sy0x1 = srcP[y_m2*src_uv_pitch + cxplus];

  005a4	8b 4d 88	 mov	 ecx, DWORD PTR _y_m2$32[ebp]
  005a7	0f af 4d a8	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  005ab	03 8d 48 ff ff
	ff		 add	 ecx, DWORD PTR _cxplus$16[ebp]
  005b1	8b 55 90	 mov	 edx, DWORD PTR _srcP$34[ebp]
  005b4	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  005b8	89 85 44 ff ff
	ff		 mov	 DWORD PTR _sy0x1$15[ebp], eax

; 747  :                 int sy1x1 = srcP[y_m1*src_uv_pitch + cxplus];

  005be	8b 4d 84	 mov	 ecx, DWORD PTR _y_m1$31[ebp]
  005c1	0f af 4d a8	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  005c5	03 8d 48 ff ff
	ff		 add	 ecx, DWORD PTR _cxplus$16[ebp]
  005cb	8b 55 90	 mov	 edx, DWORD PTR _srcP$34[ebp]
  005ce	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  005d2	89 85 40 ff ff
	ff		 mov	 DWORD PTR _sy1x1$14[ebp], eax

; 748  :                 int sy2x1 = srcP[   0*src_uv_pitch + cxplus];

  005d8	6b 4d a8 00	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 0
  005dc	03 8d 48 ff ff
	ff		 add	 ecx, DWORD PTR _cxplus$16[ebp]
  005e2	8b 55 90	 mov	 edx, DWORD PTR _srcP$34[ebp]
  005e5	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  005e9	89 85 3c ff ff
	ff		 mov	 DWORD PTR _sy2x1$13[ebp], eax

; 749  :                 int sy3x1 = srcP[y_p1*src_uv_pitch + cxplus];

  005ef	8b 4d 80	 mov	 ecx, DWORD PTR _y_p1$30[ebp]
  005f2	0f af 4d a8	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  005f6	03 8d 48 ff ff
	ff		 add	 ecx, DWORD PTR _cxplus$16[ebp]
  005fc	8b 55 90	 mov	 edx, DWORD PTR _srcP$34[ebp]
  005ff	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00603	89 85 38 ff ff
	ff		 mov	 DWORD PTR _sy3x1$12[ebp], eax

; 750  :                 int sy4x1 = srcP[y_p2*src_uv_pitch + cxplus];

  00609	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _y_p2$29[ebp]
  0060f	0f af 4d a8	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00613	03 8d 48 ff ff
	ff		 add	 ecx, DWORD PTR _cxplus$16[ebp]
  00619	8b 55 90	 mov	 edx, DWORD PTR _srcP$34[ebp]
  0061c	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00620	89 85 34 ff ff
	ff		 mov	 DWORD PTR _sy4x1$11[ebp], eax

; 751  :                 int sy5x1 = srcP[y_p3*src_uv_pitch + cxplus];

  00626	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _y_p3$28[ebp]
  0062c	0f af 4d a8	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00630	03 8d 48 ff ff
	ff		 add	 ecx, DWORD PTR _cxplus$16[ebp]
  00636	8b 55 90	 mov	 edx, DWORD PTR _srcP$34[ebp]
  00639	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  0063d	89 85 30 ff ff
	ff		 mov	 DWORD PTR _sy5x1$10[ebp], eax

; 752  : 
; 753  :                 int cy0x1 = (sy0x1 * 1 + sy2x1 * 7 + 4);

  00643	6b 8d 3c ff ff
	ff 07		 imul	 ecx, DWORD PTR _sy2x1$13[ebp], 7
  0064a	8b 95 44 ff ff
	ff		 mov	 edx, DWORD PTR _sy0x1$15[ebp]
  00650	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  00654	89 85 2c ff ff
	ff		 mov	 DWORD PTR _cy0x1$9[ebp], eax

; 754  :                 int cy1x1 = (sy1x1 * 3 + sy3x1 * 5 + 4);

  0065a	6b 8d 40 ff ff
	ff 03		 imul	 ecx, DWORD PTR _sy1x1$14[ebp], 3
  00661	6b 95 38 ff ff
	ff 05		 imul	 edx, DWORD PTR _sy3x1$12[ebp], 5
  00668	8d 44 11 04	 lea	 eax, DWORD PTR [ecx+edx+4]
  0066c	89 85 28 ff ff
	ff		 mov	 DWORD PTR _cy1x1$8[ebp], eax

; 755  :                 int cy2x1 = (sy2x1 * 5 + sy4x1 * 3 + 4);

  00672	6b 8d 3c ff ff
	ff 05		 imul	 ecx, DWORD PTR _sy2x1$13[ebp], 5
  00679	6b 95 34 ff ff
	ff 03		 imul	 edx, DWORD PTR _sy4x1$11[ebp], 3
  00680	8d 44 11 04	 lea	 eax, DWORD PTR [ecx+edx+4]
  00684	89 85 24 ff ff
	ff		 mov	 DWORD PTR _cy2x1$7[ebp], eax

; 756  :                 int cy3x1 = (sy3x1 * 7 + sy5x1 * 1 + 4);

  0068a	6b 8d 38 ff ff
	ff 07		 imul	 ecx, DWORD PTR _sy3x1$12[ebp], 7
  00691	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR _sy5x1$10[ebp]
  00697	8d 44 11 04	 lea	 eax, DWORD PTR [ecx+edx+4]
  0069b	89 85 20 ff ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], eax

; 757  :                 CHANGE_BIT_DEPTH_4(cy0x1, cy1x1, cy2x1, cy3x1, 3);

  006a1	33 c9		 xor	 ecx, ecx
  006a3	74 3e		 je	 SHORT $LN27@convert_yv
  006a5	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR _cy0x1$9[ebp]
  006ab	c1 e2 ff	 shl	 edx, -1
  006ae	89 95 2c ff ff
	ff		 mov	 DWORD PTR _cy0x1$9[ebp], edx
  006b4	8b 85 28 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x1$8[ebp]
  006ba	c1 e0 ff	 shl	 eax, -1
  006bd	89 85 28 ff ff
	ff		 mov	 DWORD PTR _cy1x1$8[ebp], eax
  006c3	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR _cy2x1$7[ebp]
  006c9	c1 e1 ff	 shl	 ecx, -1
  006cc	89 8d 24 ff ff
	ff		 mov	 DWORD PTR _cy2x1$7[ebp], ecx
  006d2	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR _cy3x1$6[ebp]
  006d8	c1 e2 ff	 shl	 edx, -1
  006db	89 95 20 ff ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], edx
  006e1	eb 41		 jmp	 SHORT $LN28@convert_yv
$LN27@convert_yv:
  006e3	b8 01 00 00 00	 mov	 eax, 1
  006e8	85 c0		 test	 eax, eax
  006ea	74 38		 je	 SHORT $LN28@convert_yv
  006ec	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR _cy0x1$9[ebp]
  006f2	d1 f9		 sar	 ecx, 1
  006f4	89 8d 2c ff ff
	ff		 mov	 DWORD PTR _cy0x1$9[ebp], ecx
  006fa	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x1$8[ebp]
  00700	d1 fa		 sar	 edx, 1
  00702	89 95 28 ff ff
	ff		 mov	 DWORD PTR _cy1x1$8[ebp], edx
  00708	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _cy2x1$7[ebp]
  0070e	d1 f8		 sar	 eax, 1
  00710	89 85 24 ff ff
	ff		 mov	 DWORD PTR _cy2x1$7[ebp], eax
  00716	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x1$6[ebp]
  0071c	d1 f9		 sar	 ecx, 1
  0071e	89 8d 20 ff ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], ecx
$LN28@convert_yv:

; 758  : 
; 759  :                 dstC[0*dst_y_pitch   + 0] = (Tout)cy0x0;

  00724	6b 55 e4 00	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 0
  00728	8b 45 94	 mov	 eax, DWORD PTR _dstC$35[ebp]
  0072b	66 8b 8d 5c ff
	ff ff		 mov	 cx, WORD PTR _cy0x0$21[ebp]
  00732	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx

; 760  :                 dstC[0*dst_y_pitch   + 1] = (Tout)((cy0x0 + cy0x1 + 1) >> 1);

  00736	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR _cy0x1$9[ebp]
  0073c	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _cy0x0$21[ebp]
  00742	8d 4c 10 01	 lea	 ecx, DWORD PTR [eax+edx+1]
  00746	d1 f9		 sar	 ecx, 1
  00748	6b 55 e4 00	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 0
  0074c	8b 45 94	 mov	 eax, DWORD PTR _dstC$35[ebp]
  0074f	66 89 4c 50 02	 mov	 WORD PTR [eax+edx*2+2], cx

; 761  :                 dstC[1*dst_y_pitch   + 0] = (Tout)cy1x0;

  00754	8b 4d e4	 mov	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  00757	8b 55 94	 mov	 edx, DWORD PTR _dstC$35[ebp]
  0075a	66 8b 85 58 ff
	ff ff		 mov	 ax, WORD PTR _cy1x0$20[ebp]
  00761	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax

; 762  :                 dstC[1*dst_y_pitch   + 1] = (Tout)((cy1x0 + cy1x1 + 1) >> 1);

  00765	8b 8d 28 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x1$8[ebp]
  0076b	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x0$20[ebp]
  00771	8d 44 0a 01	 lea	 eax, DWORD PTR [edx+ecx+1]
  00775	d1 f8		 sar	 eax, 1
  00777	8b 4d e4	 mov	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  0077a	8b 55 94	 mov	 edx, DWORD PTR _dstC$35[ebp]
  0077d	66 89 44 4a 02	 mov	 WORD PTR [edx+ecx*2+2], ax

; 763  :                 dstC[2*dst_y_pitch   + 0] = (Tout)cy2x0;

  00782	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  00785	d1 e0		 shl	 eax, 1
  00787	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$35[ebp]
  0078a	66 8b 95 54 ff
	ff ff		 mov	 dx, WORD PTR _cy2x0$19[ebp]
  00791	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx

; 764  :                 dstC[2*dst_y_pitch   + 1] = (Tout)((cy2x0 + cy2x1 + 1) >> 1);

  00795	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _cy2x1$7[ebp]
  0079b	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _cy2x0$19[ebp]
  007a1	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  007a5	d1 fa		 sar	 edx, 1
  007a7	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  007aa	d1 e0		 shl	 eax, 1
  007ac	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$35[ebp]
  007af	66 89 54 41 02	 mov	 WORD PTR [ecx+eax*2+2], dx

; 765  :                 dstC[3*dst_y_pitch   + 0] = (Tout)cy3x0;

  007b4	6b 55 e4 03	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 3
  007b8	8b 45 94	 mov	 eax, DWORD PTR _dstC$35[ebp]
  007bb	66 8b 8d 50 ff
	ff ff		 mov	 cx, WORD PTR _cy3x0$18[ebp]
  007c2	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx

; 766  :                 dstC[3*dst_y_pitch   + 1] = (Tout)((cy3x0 + cy3x1 + 1) >> 1);

  007c6	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR _cy3x1$6[ebp]
  007cc	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$18[ebp]
  007d2	8d 4c 10 01	 lea	 ecx, DWORD PTR [eax+edx+1]
  007d6	d1 f9		 sar	 ecx, 1
  007d8	6b 55 e4 03	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 3
  007dc	8b 45 94	 mov	 eax, DWORD PTR _dstC$35[ebp]
  007df	66 89 4c 50 02	 mov	 WORD PTR [eax+edx*2+2], cx

; 767  : 
; 768  :                 cy0x0 = cy0x1;

  007e4	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR _cy0x1$9[ebp]
  007ea	89 8d 5c ff ff
	ff		 mov	 DWORD PTR _cy0x0$21[ebp], ecx

; 769  :                 cy1x0 = cy1x1;

  007f0	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x1$8[ebp]
  007f6	89 95 58 ff ff
	ff		 mov	 DWORD PTR _cy1x0$20[ebp], edx

; 770  :                 cy2x0 = cy2x1;

  007fc	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _cy2x1$7[ebp]
  00802	89 85 54 ff ff
	ff		 mov	 DWORD PTR _cy2x0$19[ebp], eax

; 771  :                 cy3x0 = cy3x1;

  00808	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x1$6[ebp]
  0080e	89 8d 50 ff ff
	ff		 mov	 DWORD PTR _cy3x0$18[ebp], ecx

; 772  :             }

  00814	e9 2b fd ff ff	 jmp	 $LN14@convert_yv
$LN15@convert_yv:

; 773  :         }

  00819	e9 83 fa ff ff	 jmp	 $LN11@convert_yv
$LN12@convert_yv:

; 774  :     }

  0081e	e9 31 fa ff ff	 jmp	 $LN8@convert_yv
$LN1@convert_yv:

; 775  : }

  00823	52		 push	 edx
  00824	8b cd		 mov	 ecx, ebp
  00826	50		 push	 eax
  00827	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN47@convert_yv
  0082d	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00832	58		 pop	 eax
  00833	5a		 pop	 edx
  00834	5f		 pop	 edi
  00835	5e		 pop	 esi
  00836	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00839	33 cd		 xor	 ecx, ebp
  0083b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00840	81 c4 18 01 00
	00		 add	 esp, 280		; 00000118H
  00846	3b ec		 cmp	 ebp, esp
  00848	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0084d	8b e5		 mov	 esp, ebp
  0084f	5d		 pop	 ebp
  00850	c3		 ret	 0
  00851	0f 1f 00	 npad	 3
$LN47@convert_yv:
  00854	01 00 00 00	 DD	 1
  00858	00 00 00 00	 DD	 $LN46@convert_yv
$LN46@convert_yv:
  0085c	d4 ff ff ff	 DD	 -44			; ffffffd4H
  00860	0c 00 00 00	 DD	 12			; 0000000cH
  00864	00 00 00 00	 DD	 $LN45@convert_yv
$LN45@convert_yv:
  00868	79		 DB	 121			; 00000079H
  00869	5f		 DB	 95			; 0000005fH
  0086a	72		 DB	 114			; 00000072H
  0086b	61		 DB	 97			; 00000061H
  0086c	6e		 DB	 110			; 0000006eH
  0086d	67		 DB	 103			; 00000067H
  0086e	65		 DB	 101			; 00000065H
  0086f	00		 DB	 0
??$convert_yv12_i_to_yuv444_c@G$0O@G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_i_to_yuv444_c<unsigned short,14,unsigned short,16,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yv12_14_i_to_yuv444_16bit@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_14_i_to_yuv444_16bit

; 845  : static void convert_yv12_14_i_to_yuv444_16bit(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 846  :     convert_yv12_i_to_yuv444_c<uint16_t, 14, uint16_t, 16, false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yv12_i_to_yuv444_c@G$0O@G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_i_to_yuv444_c<unsigned short,14,unsigned short,16,0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 847  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yv12_14_i_to_yuv444_16bit@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_14_i_to_yuv444_16bit
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
tv416 = -300						; size = 4
tv309 = -296						; size = 4
tv232 = -292						; size = 4
$T1 = -288						; size = 4
$T2 = -284						; size = 4
$T3 = -280						; size = 4
$T4 = -276						; size = 4
$T5 = -272						; size = 12
_cy3x1$6 = -260						; size = 4
_cy1x1$7 = -256						; size = 4
_cy3x0$8 = -252						; size = 4
_cy1x0$9 = -248						; size = 4
_cy4x1$10 = -244					; size = 4
_cy2x1$11 = -240					; size = 4
_cy0x1$12 = -236					; size = 4
_cy4x0$13 = -232					; size = 4
_cy2x0$14 = -228					; size = 4
_cy0x0$15 = -224					; size = 4
_cxplus$16 = -220					; size = 4
_x$17 = -216						; size = 4
_cy3x1$18 = -212					; size = 4
_cy1x1$19 = -208					; size = 4
_cy3x0$20 = -204					; size = 4
_cy1x0$21 = -200					; size = 4
_cy4x1$22 = -196					; size = 4
_cy2x1$23 = -192					; size = 4
_cy0x1$24 = -188					; size = 4
_cy4x0$25 = -184					; size = 4
_cy2x0$26 = -180					; size = 4
_cy0x0$27 = -176					; size = 4
_cxplus$28 = -172					; size = 4
_x$29 = -168						; size = 4
_cy3x1$30 = -164					; size = 4
_cy1x1$31 = -160					; size = 4
_cy3x0$32 = -156					; size = 4
_cy1x0$33 = -152					; size = 4
_cy4x1$34 = -148					; size = 4
_cy2x1$35 = -144					; size = 4
_cy0x1$36 = -140					; size = 4
_cy4x0$37 = -136					; size = 4
_cy2x0$38 = -132					; size = 4
_cy0x0$39 = -128					; size = 4
_cxplus$40 = -124					; size = 4
_x$41 = -120						; size = 4
_x_fin$42 = -116					; size = 4
_srcP$43 = -112						; size = 4
_dstC$44 = -108						; size = 4
_y$45 = -104						; size = 4
_dstLine$46 = -100					; size = 4
_srcCLine$47 = -96					; size = 4
_ic$48 = -92						; size = 4
_src_uv_pitch$ = -88					; size = 4
_x$49 = -84						; size = 4
_y$50 = -80						; size = 4
_y_width$51 = -76					; size = 4
_y_fin$52 = -72						; size = 4
_dstLine$53 = -68					; size = 4
_srcYLine$54 = -64					; size = 4
$T55 = -60						; size = 12
_y_range$ = -44						; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yv12_p_to_yuv444_c@G$0O@G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_p_to_yuv444_c<unsigned short,14,unsigned short,16,0>

; 573  : static void __forceinline convert_yv12_p_to_yuv444_c(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 2c 01 00
	00		 sub	 esp, 300		; 0000012cH
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8d bd d4 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-300]
  00011	b9 4b 00 00 00	 mov	 ecx, 75			; 0000004bH
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 574  :     static_assert((sizeof(Tin)  == 1 && in_bit_depth  == 8) || (sizeof(Tin)  == 2 && 8 < in_bit_depth  && in_bit_depth  <= 16), "invalid input bit depth.");
; 575  :     static_assert((sizeof(Tout) == 1 && out_bit_depth == 8) || (sizeof(Tout) == 2 && 8 < out_bit_depth && out_bit_depth <= 16), "invalid output bit depth.");
; 576  :     const int crop_left   = crop[0];

  00027	b8 04 00 00 00	 mov	 eax, 4
  0002c	6b c8 00	 imul	 ecx, eax, 0
  0002f	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00032	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00035	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 577  :     const int crop_up     = crop[1];

  00038	b9 04 00 00 00	 mov	 ecx, 4
  0003d	c1 e1 00	 shl	 ecx, 0
  00040	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00043	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00046	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 578  :     const int crop_right  = crop[2];

  00049	b9 04 00 00 00	 mov	 ecx, 4
  0004e	d1 e1		 shl	 ecx, 1
  00050	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00053	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00056	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 579  :     const int crop_bottom = crop[3];

  00059	b9 04 00 00 00	 mov	 ecx, 4
  0005e	6b d1 03	 imul	 edx, ecx, 3
  00061	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00064	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00067	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 580  :     const int src_y_pitch = src_y_pitch_byte / sizeof(Tin);

  0006a	8b 55 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebp]
  0006d	d1 ea		 shr	 edx, 1
  0006f	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 581  :     const int dst_y_pitch = dst_y_pitch_byte / sizeof(Tout);

  00072	8b 45 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  00075	d1 e8		 shr	 eax, 1
  00077	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 582  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  0007a	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0007d	51		 push	 ecx
  0007e	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  00081	52		 push	 edx
  00082	8b 45 20	 mov	 eax, DWORD PTR _height$[ebp]
  00085	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  00088	50		 push	 eax
  00089	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  0008c	51		 push	 ecx
  0008d	8d 95 f0 fe ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  00093	52		 push	 edx
  00094	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00099	83 c4 14	 add	 esp, 20			; 00000014H
  0009c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009e	89 4d c4	 mov	 DWORD PTR $T55[ebp], ecx
  000a1	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a4	89 55 c8	 mov	 DWORD PTR $T55[ebp+4], edx
  000a7	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000aa	89 45 cc	 mov	 DWORD PTR $T55[ebp+8], eax
  000ad	8b 4d c4	 mov	 ecx, DWORD PTR $T55[ebp]
  000b0	89 4d d4	 mov	 DWORD PTR _y_range$[ebp], ecx
  000b3	8b 55 c8	 mov	 edx, DWORD PTR $T55[ebp+4]
  000b6	89 55 d8	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000b9	8b 45 cc	 mov	 eax, DWORD PTR $T55[ebp+8]
  000bc	89 45 dc	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 583  :     //Y
; 584  :     if (!uv_only) {

  000bf	b9 01 00 00 00	 mov	 ecx, 1
  000c4	85 c9		 test	 ecx, ecx
  000c6	0f 84 77 01 00
	00		 je	 $LN23@convert_yv

; 585  :         Tin *srcYLine = (Tin *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000cc	ba 04 00 00 00	 mov	 edx, 4
  000d1	6b c2 00	 imul	 eax, edx, 0
  000d4	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  000d7	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  000db	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  000de	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  000e1	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  000e4	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  000e7	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  000ea	89 45 c0	 mov	 DWORD PTR _srcYLine$54[ebp], eax

; 586  :         Tout *dstLine = (Tout *)dst[0] + dst_y_pitch * y_range.start_dst;

  000ed	b9 04 00 00 00	 mov	 ecx, 4
  000f2	6b d1 00	 imul	 edx, ecx, 0
  000f5	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  000f8	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  000fc	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  000ff	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  00102	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  00105	89 45 bc	 mov	 DWORD PTR _dstLine$53[ebp], eax

; 587  :         const int y_fin = height - crop_bottom;

  00108	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  0010b	2b 4d ec	 sub	 ecx, DWORD PTR _crop_bottom$[ebp]
  0010e	89 4d b8	 mov	 DWORD PTR _y_fin$52[ebp], ecx

; 588  :         const int y_width = width - crop_right - crop_left;

  00111	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00114	2b 55 f0	 sub	 edx, DWORD PTR _crop_right$[ebp]
  00117	2b 55 f8	 sub	 edx, DWORD PTR _crop_left$[ebp]
  0011a	89 55 b4	 mov	 DWORD PTR _y_width$51[ebp], edx

; 589  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  0011d	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _y$50[ebp], 0
  00124	eb 21		 jmp	 SHORT $LN4@convert_yv
$LN2@convert_yv:
  00126	8b 45 b0	 mov	 eax, DWORD PTR _y$50[ebp]
  00129	83 c0 01	 add	 eax, 1
  0012c	89 45 b0	 mov	 DWORD PTR _y$50[ebp], eax
  0012f	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  00132	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$54[ebp]
  00135	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  00138	89 45 c0	 mov	 DWORD PTR _srcYLine$54[ebp], eax
  0013b	8b 4d e4	 mov	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  0013e	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$53[ebp]
  00141	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  00144	89 45 bc	 mov	 DWORD PTR _dstLine$53[ebp], eax
$LN4@convert_yv:
  00147	8b 4d b0	 mov	 ecx, DWORD PTR _y$50[ebp]
  0014a	3b 4d dc	 cmp	 ecx, DWORD PTR _y_range$[ebp+8]
  0014d	0f 8d f0 00 00
	00		 jge	 $LN23@convert_yv

; 590  :             if (in_bit_depth == out_bit_depth && sizeof(Tin) == sizeof(Tout)) {

  00153	33 d2		 xor	 edx, edx
  00155	74 1b		 je	 SHORT $LN24@convert_yv

; 591  :                 memcpy(dstLine, srcYLine, y_width * sizeof(Tin));

  00157	8b 45 b4	 mov	 eax, DWORD PTR _y_width$51[ebp]
  0015a	d1 e0		 shl	 eax, 1
  0015c	50		 push	 eax
  0015d	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$54[ebp]
  00160	51		 push	 ecx
  00161	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$53[ebp]
  00164	52		 push	 edx
  00165	e8 00 00 00 00	 call	 _memcpy
  0016a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 592  :             } else {

  0016d	e9 cc 00 00 00	 jmp	 $LN25@convert_yv
$LN24@convert_yv:

; 593  :                 for (int x = 0; x < y_width; x++) {

  00172	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR _x$49[ebp], 0
  00179	eb 09		 jmp	 SHORT $LN7@convert_yv
$LN5@convert_yv:
  0017b	8b 45 ac	 mov	 eax, DWORD PTR _x$49[ebp]
  0017e	83 c0 01	 add	 eax, 1
  00181	89 45 ac	 mov	 DWORD PTR _x$49[ebp], eax
$LN7@convert_yv:
  00184	8b 4d ac	 mov	 ecx, DWORD PTR _x$49[ebp]
  00187	3b 4d b4	 cmp	 ecx, DWORD PTR _y_width$51[ebp]
  0018a	0f 8d ae 00 00
	00		 jge	 $LN25@convert_yv

; 594  :                     if (out_bit_depth > in_bit_depth) {

  00190	ba 01 00 00 00	 mov	 edx, 1
  00195	85 d2		 test	 edx, edx
  00197	74 44		 je	 SHORT $LN26@convert_yv

; 595  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) << std::max(out_bit_depth - in_bit_depth, 0));

  00199	c7 85 ec fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], 0
  001a3	c7 85 e8 fe ff
	ff 02 00 00 00	 mov	 DWORD PTR $T3[ebp], 2
  001ad	8b 45 ac	 mov	 eax, DWORD PTR _x$49[ebp]
  001b0	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$54[ebp]
  001b3	0f b7 34 41	 movzx	 esi, WORD PTR [ecx+eax*2]
  001b7	8d 95 ec fe ff
	ff		 lea	 edx, DWORD PTR $T4[ebp]
  001bd	52		 push	 edx
  001be	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  001c4	50		 push	 eax
  001c5	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  001ca	83 c4 08	 add	 esp, 8
  001cd	8b 08		 mov	 ecx, DWORD PTR [eax]
  001cf	d3 e6		 shl	 esi, cl
  001d1	8b 4d ac	 mov	 ecx, DWORD PTR _x$49[ebp]
  001d4	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$53[ebp]
  001d7	66 89 34 4a	 mov	 WORD PTR [edx+ecx*2], si
  001db	eb 5c		 jmp	 SHORT $LN27@convert_yv
$LN26@convert_yv:

; 596  :                     } else if (out_bit_depth < in_bit_depth) {

  001dd	33 c0		 xor	 eax, eax
  001df	74 44		 je	 SHORT $LN28@convert_yv

; 597  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) >> std::max(in_bit_depth - out_bit_depth, 0));

  001e1	c7 85 e4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], 0
  001eb	c7 85 e0 fe ff
	ff fe ff ff ff	 mov	 DWORD PTR $T1[ebp], -2	; fffffffeH
  001f5	8b 4d ac	 mov	 ecx, DWORD PTR _x$49[ebp]
  001f8	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$54[ebp]
  001fb	0f b7 34 4a	 movzx	 esi, WORD PTR [edx+ecx*2]
  001ff	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  00205	50		 push	 eax
  00206	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  0020c	51		 push	 ecx
  0020d	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  00212	83 c4 08	 add	 esp, 8
  00215	8b 08		 mov	 ecx, DWORD PTR [eax]
  00217	d3 fe		 sar	 esi, cl
  00219	8b 55 ac	 mov	 edx, DWORD PTR _x$49[ebp]
  0021c	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$53[ebp]
  0021f	66 89 34 50	 mov	 WORD PTR [eax+edx*2], si

; 598  :                     } else {

  00223	eb 14		 jmp	 SHORT $LN27@convert_yv
$LN28@convert_yv:

; 599  :                         dstLine[x] = (Tout)srcYLine[x];

  00225	8b 4d ac	 mov	 ecx, DWORD PTR _x$49[ebp]
  00228	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$53[ebp]
  0022b	8b 45 ac	 mov	 eax, DWORD PTR _x$49[ebp]
  0022e	8b 75 c0	 mov	 esi, DWORD PTR _srcYLine$54[ebp]
  00231	66 8b 04 46	 mov	 ax, WORD PTR [esi+eax*2]
  00235	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax
$LN27@convert_yv:

; 600  :                     }
; 601  :                 }

  00239	e9 3d ff ff ff	 jmp	 $LN5@convert_yv
$LN25@convert_yv:

; 602  :             }
; 603  :         }

  0023e	e9 e3 fe ff ff	 jmp	 $LN2@convert_yv
$LN23@convert_yv:

; 604  :     }
; 605  :     //UV
; 606  :     const int src_uv_pitch = src_uv_pitch_byte / sizeof(Tin);

  00243	8b 4d 18	 mov	 ecx, DWORD PTR _src_uv_pitch_byte$[ebp]
  00246	d1 e9		 shr	 ecx, 1
  00248	89 4d a8	 mov	 DWORD PTR _src_uv_pitch$[ebp], ecx

; 607  :     for (int ic = 1; ic < 3; ic++) {

  0024b	c7 45 a4 01 00
	00 00		 mov	 DWORD PTR _ic$48[ebp], 1
  00252	eb 09		 jmp	 SHORT $LN10@convert_yv
$LN8@convert_yv:
  00254	8b 55 a4	 mov	 edx, DWORD PTR _ic$48[ebp]
  00257	83 c2 01	 add	 edx, 1
  0025a	89 55 a4	 mov	 DWORD PTR _ic$48[ebp], edx
$LN10@convert_yv:
  0025d	83 7d a4 03	 cmp	 DWORD PTR _ic$48[ebp], 3
  00261	0f 8d b0 06 00
	00		 jge	 $LN1@convert_yv

; 608  :         Tin *srcCLine = (Tin *)src[ic] + (((src_uv_pitch * y_range.start_src) + crop_left) >> 1);

  00267	8b 45 a8	 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  0026a	0f af 45 d4	 imul	 eax, DWORD PTR _y_range$[ebp]
  0026e	03 45 f8	 add	 eax, DWORD PTR _crop_left$[ebp]
  00271	d1 f8		 sar	 eax, 1
  00273	8b 4d a4	 mov	 ecx, DWORD PTR _ic$48[ebp]
  00276	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  00279	8b 0c 8a	 mov	 ecx, DWORD PTR [edx+ecx*4]
  0027c	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  0027f	89 55 a0	 mov	 DWORD PTR _srcCLine$47[ebp], edx

; 609  :         Tout *dstLine = (Tout *)dst[ic] + dst_y_pitch * y_range.start_dst;

  00282	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  00285	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  00289	8b 4d a4	 mov	 ecx, DWORD PTR _ic$48[ebp]
  0028c	8b 55 08	 mov	 edx, DWORD PTR _dst$[ebp]
  0028f	8b 0c 8a	 mov	 ecx, DWORD PTR [edx+ecx*4]
  00292	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00295	89 55 9c	 mov	 DWORD PTR _dstLine$46[ebp], edx

; 610  :         for (int y = 0; y < y_range.len; y += 2, srcCLine += src_uv_pitch, dstLine += dst_y_pitch * 2) {

  00298	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _y$45[ebp], 0
  0029f	eb 23		 jmp	 SHORT $LN13@convert_yv
$LN11@convert_yv:
  002a1	8b 45 98	 mov	 eax, DWORD PTR _y$45[ebp]
  002a4	83 c0 02	 add	 eax, 2
  002a7	89 45 98	 mov	 DWORD PTR _y$45[ebp], eax
  002aa	8b 4d a8	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  002ad	8b 55 a0	 mov	 edx, DWORD PTR _srcCLine$47[ebp]
  002b0	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  002b3	89 45 a0	 mov	 DWORD PTR _srcCLine$47[ebp], eax
  002b6	8b 4d e4	 mov	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  002b9	d1 e1		 shl	 ecx, 1
  002bb	8b 55 9c	 mov	 edx, DWORD PTR _dstLine$46[ebp]
  002be	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  002c1	89 45 9c	 mov	 DWORD PTR _dstLine$46[ebp], eax
$LN13@convert_yv:
  002c4	8b 4d 98	 mov	 ecx, DWORD PTR _y$45[ebp]
  002c7	3b 4d dc	 cmp	 ecx, DWORD PTR _y_range$[ebp+8]
  002ca	0f 8d 42 06 00
	00		 jge	 $LN12@convert_yv

; 611  :             Tout *dstC = dstLine;

  002d0	8b 55 9c	 mov	 edx, DWORD PTR _dstLine$46[ebp]
  002d3	89 55 94	 mov	 DWORD PTR _dstC$44[ebp], edx

; 612  :             Tin *srcP = srcCLine;

  002d6	8b 45 a0	 mov	 eax, DWORD PTR _srcCLine$47[ebp]
  002d9	89 45 90	 mov	 DWORD PTR _srcP$43[ebp], eax

; 613  :             const int x_fin = width - crop_right - crop_left;

  002dc	8b 4d 10	 mov	 ecx, DWORD PTR _width$[ebp]
  002df	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  002e2	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  002e5	89 4d 8c	 mov	 DWORD PTR _x_fin$42[ebp], ecx

; 614  :             if (y == 0) {

  002e8	83 7d 98 00	 cmp	 DWORD PTR _y$45[ebp], 0
  002ec	0f 85 ef 01 00
	00		 jne	 $LN30@convert_yv

; 615  :                 for (int x = 0; x < x_fin; x += 2, dstC += 2, srcP++) {

  002f2	c7 45 88 00 00
	00 00		 mov	 DWORD PTR _x$41[ebp], 0
  002f9	eb 1b		 jmp	 SHORT $LN16@convert_yv
$LN14@convert_yv:
  002fb	8b 55 88	 mov	 edx, DWORD PTR _x$41[ebp]
  002fe	83 c2 02	 add	 edx, 2
  00301	89 55 88	 mov	 DWORD PTR _x$41[ebp], edx
  00304	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  00307	83 c0 04	 add	 eax, 4
  0030a	89 45 94	 mov	 DWORD PTR _dstC$44[ebp], eax
  0030d	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$43[ebp]
  00310	83 c1 02	 add	 ecx, 2
  00313	89 4d 90	 mov	 DWORD PTR _srcP$43[ebp], ecx
$LN16@convert_yv:
  00316	8b 55 88	 mov	 edx, DWORD PTR _x$41[ebp]
  00319	3b 55 8c	 cmp	 edx, DWORD PTR _x_fin$42[ebp]
  0031c	0f 8d ba 01 00
	00		 jge	 $LN15@convert_yv

; 616  :                     int cxplus = (x + 2 < x_fin);

  00322	8b 45 88	 mov	 eax, DWORD PTR _x$41[ebp]
  00325	83 c0 02	 add	 eax, 2
  00328	3b 45 8c	 cmp	 eax, DWORD PTR _x_fin$42[ebp]
  0032b	7d 0c		 jge	 SHORT $LN44@convert_yv
  0032d	c7 85 dc fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv232[ebp], 1
  00337	eb 0a		 jmp	 SHORT $LN45@convert_yv
$LN44@convert_yv:
  00339	c7 85 dc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv232[ebp], 0
$LN45@convert_yv:
  00343	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR tv232[ebp]
  00349	89 4d 84	 mov	 DWORD PTR _cxplus$40[ebp], ecx

; 617  :                     int cy0x0 = srcP[ 0*src_uv_pitch + 0];

  0034c	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  00350	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  00353	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  00357	89 4d 80	 mov	 DWORD PTR _cy0x0$39[ebp], ecx

; 618  :                     int cy2x0 = srcP[ 0*src_uv_pitch + 0];

  0035a	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  0035e	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  00361	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  00365	89 8d 7c ff ff
	ff		 mov	 DWORD PTR _cy2x0$38[ebp], ecx

; 619  :                     int cy4x0 = srcP[ 1*src_uv_pitch + 0];

  0036b	8b 55 a8	 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  0036e	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  00371	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  00375	89 8d 78 ff ff
	ff		 mov	 DWORD PTR _cy4x0$37[ebp], ecx

; 620  :                     int cy0x1 = srcP[ 0*src_uv_pitch + cxplus];

  0037b	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  0037f	03 55 84	 add	 edx, DWORD PTR _cxplus$40[ebp]
  00382	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  00385	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  00389	89 8d 74 ff ff
	ff		 mov	 DWORD PTR _cy0x1$36[ebp], ecx

; 621  :                     int cy2x1 = srcP[ 0*src_uv_pitch + cxplus];

  0038f	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  00393	03 55 84	 add	 edx, DWORD PTR _cxplus$40[ebp]
  00396	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  00399	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  0039d	89 8d 70 ff ff
	ff		 mov	 DWORD PTR _cy2x1$35[ebp], ecx

; 622  :                     int cy4x1 = srcP[ 1*src_uv_pitch + cxplus];

  003a3	8b 55 84	 mov	 edx, DWORD PTR _cxplus$40[ebp]
  003a6	03 55 a8	 add	 edx, DWORD PTR _src_uv_pitch$[ebp]
  003a9	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  003ac	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  003b0	89 8d 6c ff ff
	ff		 mov	 DWORD PTR _cy4x1$34[ebp], ecx

; 623  : 
; 624  :                     int cy1x0 = (cy0x0 * 1 + cy2x0 * 3 + 2);

  003b6	6b 95 7c ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x0$38[ebp], 3
  003bd	8b 45 80	 mov	 eax, DWORD PTR _cy0x0$39[ebp]
  003c0	8d 4c 10 02	 lea	 ecx, DWORD PTR [eax+edx+2]
  003c4	89 8d 68 ff ff
	ff		 mov	 DWORD PTR _cy1x0$33[ebp], ecx

; 625  :                     int cy3x0 = (cy2x0 * 3 + cy4x0 * 1 + 2);

  003ca	6b 95 7c ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x0$38[ebp], 3
  003d1	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _cy4x0$37[ebp]
  003d7	8d 4c 02 02	 lea	 ecx, DWORD PTR [edx+eax+2]
  003db	89 8d 64 ff ff
	ff		 mov	 DWORD PTR _cy3x0$32[ebp], ecx

; 626  :                     int cy1x1 = (cy0x1 * 1 + cy2x1 * 3 + 2);

  003e1	6b 95 70 ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x1$35[ebp], 3
  003e8	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _cy0x1$36[ebp]
  003ee	8d 4c 10 02	 lea	 ecx, DWORD PTR [eax+edx+2]
  003f2	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _cy1x1$31[ebp], ecx

; 627  :                     int cy3x1 = (cy2x1 * 3 + cy4x1 * 1 + 2);

  003f8	6b 95 70 ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x1$35[ebp], 3
  003ff	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _cy4x1$34[ebp]
  00405	8d 4c 02 02	 lea	 ecx, DWORD PTR [edx+eax+2]
  00409	89 8d 5c ff ff
	ff		 mov	 DWORD PTR _cy3x1$30[ebp], ecx

; 628  :                     CHANGE_BIT_DEPTH_4(cy1x0, cy3x0, cy1x1, cy3x1, 2);

  0040f	33 d2		 xor	 edx, edx
  00411	74 32		 je	 SHORT $LN32@convert_yv
  00413	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x0$33[ebp]
  00419	89 85 68 ff ff
	ff		 mov	 DWORD PTR _cy1x0$33[ebp], eax
  0041f	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x0$32[ebp]
  00425	89 8d 64 ff ff
	ff		 mov	 DWORD PTR _cy3x0$32[ebp], ecx
  0042b	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x1$31[ebp]
  00431	89 95 60 ff ff
	ff		 mov	 DWORD PTR _cy1x1$31[ebp], edx
  00437	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _cy3x1$30[ebp]
  0043d	89 85 5c ff ff
	ff		 mov	 DWORD PTR _cy3x1$30[ebp], eax
  00443	eb 34		 jmp	 SHORT $LN33@convert_yv
$LN32@convert_yv:
  00445	33 c9		 xor	 ecx, ecx
  00447	74 30		 je	 SHORT $LN33@convert_yv
  00449	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x0$33[ebp]
  0044f	89 95 68 ff ff
	ff		 mov	 DWORD PTR _cy1x0$33[ebp], edx
  00455	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$32[ebp]
  0045b	89 85 64 ff ff
	ff		 mov	 DWORD PTR _cy3x0$32[ebp], eax
  00461	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x1$31[ebp]
  00467	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _cy1x1$31[ebp], ecx
  0046d	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR _cy3x1$30[ebp]
  00473	89 95 5c ff ff
	ff		 mov	 DWORD PTR _cy3x1$30[ebp], edx
$LN33@convert_yv:

; 629  : 
; 630  :                     dstC[0*dst_y_pitch   + 0] = (Tout)cy1x0;

  00479	6b 45 e4 00	 imul	 eax, DWORD PTR _dst_y_pitch$[ebp], 0
  0047d	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$44[ebp]
  00480	66 8b 95 68 ff
	ff ff		 mov	 dx, WORD PTR _cy1x0$33[ebp]
  00487	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx

; 631  :                     dstC[0*dst_y_pitch   + 1] = (Tout)((cy1x0 + cy1x1 + 1) >> 1);

  0048b	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x1$31[ebp]
  00491	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x0$33[ebp]
  00497	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  0049b	d1 fa		 sar	 edx, 1
  0049d	6b 45 e4 00	 imul	 eax, DWORD PTR _dst_y_pitch$[ebp], 0
  004a1	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$44[ebp]
  004a4	66 89 54 41 02	 mov	 WORD PTR [ecx+eax*2+2], dx

; 632  :                     dstC[1*dst_y_pitch   + 0] = (Tout)cy3x0;

  004a9	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  004ac	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  004af	66 8b 8d 64 ff
	ff ff		 mov	 cx, WORD PTR _cy3x0$32[ebp]
  004b6	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx

; 633  :                     dstC[1*dst_y_pitch   + 1] = (Tout)((cy3x0 + cy3x1 + 1) >> 1);

  004ba	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR _cy3x1$30[ebp]
  004c0	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$32[ebp]
  004c6	8d 4c 10 01	 lea	 ecx, DWORD PTR [eax+edx+1]
  004ca	d1 f9		 sar	 ecx, 1
  004cc	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  004cf	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  004d2	66 89 4c 50 02	 mov	 WORD PTR [eax+edx*2+2], cx

; 634  :                 }

  004d7	e9 1f fe ff ff	 jmp	 $LN14@convert_yv
$LN15@convert_yv:

; 635  :             } else if (y >= height-2) {

  004dc	e9 2c 04 00 00	 jmp	 $LN31@convert_yv
$LN30@convert_yv:
  004e1	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  004e4	83 e9 02	 sub	 ecx, 2
  004e7	39 4d 98	 cmp	 DWORD PTR _y$45[ebp], ecx
  004ea	0f 8c 12 02 00
	00		 jl	 $LN35@convert_yv

; 636  :                 for (int x = 0; x < x_fin; x += 2, dstC += 2, srcP++) {

  004f0	c7 85 58 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _x$29[ebp], 0
  004fa	eb 21		 jmp	 SHORT $LN19@convert_yv
$LN17@convert_yv:
  004fc	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _x$29[ebp]
  00502	83 c2 02	 add	 edx, 2
  00505	89 95 58 ff ff
	ff		 mov	 DWORD PTR _x$29[ebp], edx
  0050b	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  0050e	83 c0 04	 add	 eax, 4
  00511	89 45 94	 mov	 DWORD PTR _dstC$44[ebp], eax
  00514	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$43[ebp]
  00517	83 c1 02	 add	 ecx, 2
  0051a	89 4d 90	 mov	 DWORD PTR _srcP$43[ebp], ecx
$LN19@convert_yv:
  0051d	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _x$29[ebp]
  00523	3b 55 8c	 cmp	 edx, DWORD PTR _x_fin$42[ebp]
  00526	0f 8d d1 01 00
	00		 jge	 $LN18@convert_yv

; 637  :                     int cxplus = (x + 2 < x_fin);

  0052c	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _x$29[ebp]
  00532	83 c0 02	 add	 eax, 2
  00535	3b 45 8c	 cmp	 eax, DWORD PTR _x_fin$42[ebp]
  00538	7d 0c		 jge	 SHORT $LN46@convert_yv
  0053a	c7 85 d8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv309[ebp], 1
  00544	eb 0a		 jmp	 SHORT $LN47@convert_yv
$LN46@convert_yv:
  00546	c7 85 d8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv309[ebp], 0
$LN47@convert_yv:
  00550	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR tv309[ebp]
  00556	89 8d 54 ff ff
	ff		 mov	 DWORD PTR _cxplus$28[ebp], ecx

; 638  :                     int cy0x0 = srcP[-1*src_uv_pitch + 0];

  0055c	6b 55 a8 ff	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], -1
  00560	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  00563	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  00567	89 8d 50 ff ff
	ff		 mov	 DWORD PTR _cy0x0$27[ebp], ecx

; 639  :                     int cy2x0 = srcP[ 0*src_uv_pitch + 0];

  0056d	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  00571	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  00574	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  00578	89 8d 4c ff ff
	ff		 mov	 DWORD PTR _cy2x0$26[ebp], ecx

; 640  :                     int cy4x0 = srcP[ 0*src_uv_pitch + 0];

  0057e	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  00582	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  00585	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  00589	89 8d 48 ff ff
	ff		 mov	 DWORD PTR _cy4x0$25[ebp], ecx

; 641  :                     int cy0x1 = srcP[-1*src_uv_pitch + cxplus];

  0058f	6b 55 a8 ff	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], -1
  00593	03 95 54 ff ff
	ff		 add	 edx, DWORD PTR _cxplus$28[ebp]
  00599	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  0059c	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  005a0	89 8d 44 ff ff
	ff		 mov	 DWORD PTR _cy0x1$24[ebp], ecx

; 642  :                     int cy2x1 = srcP[ 0*src_uv_pitch + cxplus];

  005a6	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  005aa	03 95 54 ff ff
	ff		 add	 edx, DWORD PTR _cxplus$28[ebp]
  005b0	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  005b3	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  005b7	89 8d 40 ff ff
	ff		 mov	 DWORD PTR _cy2x1$23[ebp], ecx

; 643  :                     int cy4x1 = srcP[ 0*src_uv_pitch + cxplus];

  005bd	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  005c1	03 95 54 ff ff
	ff		 add	 edx, DWORD PTR _cxplus$28[ebp]
  005c7	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  005ca	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  005ce	89 8d 3c ff ff
	ff		 mov	 DWORD PTR _cy4x1$22[ebp], ecx

; 644  : 
; 645  :                     int cy1x0 = (cy0x0 * 1 + cy2x0 * 3 + 2);

  005d4	6b 95 4c ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x0$26[ebp], 3
  005db	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _cy0x0$27[ebp]
  005e1	8d 4c 10 02	 lea	 ecx, DWORD PTR [eax+edx+2]
  005e5	89 8d 38 ff ff
	ff		 mov	 DWORD PTR _cy1x0$21[ebp], ecx

; 646  :                     int cy3x0 = (cy2x0 * 3 + cy4x0 * 1 + 2);

  005eb	6b 95 4c ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x0$26[ebp], 3
  005f2	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _cy4x0$25[ebp]
  005f8	8d 4c 02 02	 lea	 ecx, DWORD PTR [edx+eax+2]
  005fc	89 8d 34 ff ff
	ff		 mov	 DWORD PTR _cy3x0$20[ebp], ecx

; 647  :                     int cy1x1 = (cy0x1 * 1 + cy2x1 * 3 + 2);

  00602	6b 95 40 ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x1$23[ebp], 3
  00609	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _cy0x1$24[ebp]
  0060f	8d 4c 10 02	 lea	 ecx, DWORD PTR [eax+edx+2]
  00613	89 8d 30 ff ff
	ff		 mov	 DWORD PTR _cy1x1$19[ebp], ecx

; 648  :                     int cy3x1 = (cy2x1 * 3 + cy4x1 * 1 + 2);

  00619	6b 95 40 ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x1$23[ebp], 3
  00620	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _cy4x1$22[ebp]
  00626	8d 4c 02 02	 lea	 ecx, DWORD PTR [edx+eax+2]
  0062a	89 8d 2c ff ff
	ff		 mov	 DWORD PTR _cy3x1$18[ebp], ecx

; 649  :                     CHANGE_BIT_DEPTH_4(cy1x0, cy3x0, cy1x1, cy3x1, 2);

  00630	33 d2		 xor	 edx, edx
  00632	74 32		 je	 SHORT $LN37@convert_yv
  00634	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x0$21[ebp]
  0063a	89 85 38 ff ff
	ff		 mov	 DWORD PTR _cy1x0$21[ebp], eax
  00640	8b 8d 34 ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x0$20[ebp]
  00646	89 8d 34 ff ff
	ff		 mov	 DWORD PTR _cy3x0$20[ebp], ecx
  0064c	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x1$19[ebp]
  00652	89 95 30 ff ff
	ff		 mov	 DWORD PTR _cy1x1$19[ebp], edx
  00658	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR _cy3x1$18[ebp]
  0065e	89 85 2c ff ff
	ff		 mov	 DWORD PTR _cy3x1$18[ebp], eax
  00664	eb 34		 jmp	 SHORT $LN38@convert_yv
$LN37@convert_yv:
  00666	33 c9		 xor	 ecx, ecx
  00668	74 30		 je	 SHORT $LN38@convert_yv
  0066a	8b 95 38 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x0$21[ebp]
  00670	89 95 38 ff ff
	ff		 mov	 DWORD PTR _cy1x0$21[ebp], edx
  00676	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$20[ebp]
  0067c	89 85 34 ff ff
	ff		 mov	 DWORD PTR _cy3x0$20[ebp], eax
  00682	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x1$19[ebp]
  00688	89 8d 30 ff ff
	ff		 mov	 DWORD PTR _cy1x1$19[ebp], ecx
  0068e	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR _cy3x1$18[ebp]
  00694	89 95 2c ff ff
	ff		 mov	 DWORD PTR _cy3x1$18[ebp], edx
$LN38@convert_yv:

; 650  : 
; 651  :                     dstC[0*dst_y_pitch   + 0] = (Tout)cy1x0;

  0069a	6b 45 e4 00	 imul	 eax, DWORD PTR _dst_y_pitch$[ebp], 0
  0069e	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$44[ebp]
  006a1	66 8b 95 38 ff
	ff ff		 mov	 dx, WORD PTR _cy1x0$21[ebp]
  006a8	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx

; 652  :                     dstC[0*dst_y_pitch   + 1] = (Tout)((cy1x0 + cy1x1 + 1) >> 1);

  006ac	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x1$19[ebp]
  006b2	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x0$21[ebp]
  006b8	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  006bc	d1 fa		 sar	 edx, 1
  006be	6b 45 e4 00	 imul	 eax, DWORD PTR _dst_y_pitch$[ebp], 0
  006c2	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$44[ebp]
  006c5	66 89 54 41 02	 mov	 WORD PTR [ecx+eax*2+2], dx

; 653  :                     dstC[1*dst_y_pitch   + 0] = (Tout)cy3x0;

  006ca	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  006cd	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  006d0	66 8b 8d 34 ff
	ff ff		 mov	 cx, WORD PTR _cy3x0$20[ebp]
  006d7	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx

; 654  :                     dstC[1*dst_y_pitch   + 1] = (Tout)((cy3x0 + cy3x1 + 1) >> 1);

  006db	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR _cy3x1$18[ebp]
  006e1	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$20[ebp]
  006e7	8d 4c 10 01	 lea	 ecx, DWORD PTR [eax+edx+1]
  006eb	d1 f9		 sar	 ecx, 1
  006ed	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  006f0	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  006f3	66 89 4c 50 02	 mov	 WORD PTR [eax+edx*2+2], cx

; 655  :                 }

  006f8	e9 ff fd ff ff	 jmp	 $LN17@convert_yv
$LN18@convert_yv:

; 656  :             } else {

  006fd	e9 0b 02 00 00	 jmp	 $LN31@convert_yv
$LN35@convert_yv:

; 657  :                 for (int x = 0; x < x_fin; x += 2, dstC += 2, srcP++) {

  00702	c7 85 28 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _x$17[ebp], 0
  0070c	eb 21		 jmp	 SHORT $LN22@convert_yv
$LN20@convert_yv:
  0070e	8b 8d 28 ff ff
	ff		 mov	 ecx, DWORD PTR _x$17[ebp]
  00714	83 c1 02	 add	 ecx, 2
  00717	89 8d 28 ff ff
	ff		 mov	 DWORD PTR _x$17[ebp], ecx
  0071d	8b 55 94	 mov	 edx, DWORD PTR _dstC$44[ebp]
  00720	83 c2 04	 add	 edx, 4
  00723	89 55 94	 mov	 DWORD PTR _dstC$44[ebp], edx
  00726	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  00729	83 c0 02	 add	 eax, 2
  0072c	89 45 90	 mov	 DWORD PTR _srcP$43[ebp], eax
$LN22@convert_yv:
  0072f	8b 8d 28 ff ff
	ff		 mov	 ecx, DWORD PTR _x$17[ebp]
  00735	3b 4d 8c	 cmp	 ecx, DWORD PTR _x_fin$42[ebp]
  00738	0f 8d cf 01 00
	00		 jge	 $LN31@convert_yv

; 658  :                     int cxplus = (x + 2 < x_fin);

  0073e	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR _x$17[ebp]
  00744	83 c2 02	 add	 edx, 2
  00747	3b 55 8c	 cmp	 edx, DWORD PTR _x_fin$42[ebp]
  0074a	7d 0c		 jge	 SHORT $LN48@convert_yv
  0074c	c7 85 d4 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv416[ebp], 1
  00756	eb 0a		 jmp	 SHORT $LN49@convert_yv
$LN48@convert_yv:
  00758	c7 85 d4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv416[ebp], 0
$LN49@convert_yv:
  00762	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR tv416[ebp]
  00768	89 85 24 ff ff
	ff		 mov	 DWORD PTR _cxplus$16[ebp], eax

; 659  :                     int cy0x0 = srcP[-1*src_uv_pitch + 0];

  0076e	6b 4d a8 ff	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], -1
  00772	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  00775	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00779	89 85 20 ff ff
	ff		 mov	 DWORD PTR _cy0x0$15[ebp], eax

; 660  :                     int cy2x0 = srcP[ 0*src_uv_pitch + 0];

  0077f	6b 4d a8 00	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 0
  00783	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  00786	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  0078a	89 85 1c ff ff
	ff		 mov	 DWORD PTR _cy2x0$14[ebp], eax

; 661  :                     int cy4x0 = srcP[ 1*src_uv_pitch + 0];

  00790	8b 4d a8	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00793	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  00796	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  0079a	89 85 18 ff ff
	ff		 mov	 DWORD PTR _cy4x0$13[ebp], eax

; 662  :                     int cy0x1 = srcP[-1*src_uv_pitch + cxplus];

  007a0	6b 4d a8 ff	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], -1
  007a4	03 8d 24 ff ff
	ff		 add	 ecx, DWORD PTR _cxplus$16[ebp]
  007aa	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  007ad	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  007b1	89 85 14 ff ff
	ff		 mov	 DWORD PTR _cy0x1$12[ebp], eax

; 663  :                     int cy2x1 = srcP[ 0*src_uv_pitch + cxplus];

  007b7	6b 4d a8 00	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 0
  007bb	03 8d 24 ff ff
	ff		 add	 ecx, DWORD PTR _cxplus$16[ebp]
  007c1	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  007c4	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  007c8	89 85 10 ff ff
	ff		 mov	 DWORD PTR _cy2x1$11[ebp], eax

; 664  :                     int cy4x1 = srcP[ 1*src_uv_pitch + cxplus];

  007ce	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR _cxplus$16[ebp]
  007d4	03 4d a8	 add	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  007d7	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  007da	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  007de	89 85 0c ff ff
	ff		 mov	 DWORD PTR _cy4x1$10[ebp], eax

; 665  : 
; 666  :                     int cy1x0 = (cy0x0 * 1 + cy2x0 * 3 + 2);

  007e4	6b 8d 1c ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy2x0$14[ebp], 3
  007eb	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR _cy0x0$15[ebp]
  007f1	8d 44 0a 02	 lea	 eax, DWORD PTR [edx+ecx+2]
  007f5	89 85 08 ff ff
	ff		 mov	 DWORD PTR _cy1x0$9[ebp], eax

; 667  :                     int cy3x0 = (cy2x0 * 3 + cy4x0 * 1 + 2);

  007fb	6b 8d 1c ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy2x0$14[ebp], 3
  00802	8b 95 18 ff ff
	ff		 mov	 edx, DWORD PTR _cy4x0$13[ebp]
  00808	8d 44 11 02	 lea	 eax, DWORD PTR [ecx+edx+2]
  0080c	89 85 04 ff ff
	ff		 mov	 DWORD PTR _cy3x0$8[ebp], eax

; 668  :                     int cy1x1 = (cy0x1 * 1 + cy2x1 * 3 + 2);

  00812	6b 8d 10 ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy2x1$11[ebp], 3
  00819	8b 95 14 ff ff
	ff		 mov	 edx, DWORD PTR _cy0x1$12[ebp]
  0081f	8d 44 0a 02	 lea	 eax, DWORD PTR [edx+ecx+2]
  00823	89 85 00 ff ff
	ff		 mov	 DWORD PTR _cy1x1$7[ebp], eax

; 669  :                     int cy3x1 = (cy2x1 * 3 + cy4x1 * 1 + 2);

  00829	6b 8d 10 ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy2x1$11[ebp], 3
  00830	8b 95 0c ff ff
	ff		 mov	 edx, DWORD PTR _cy4x1$10[ebp]
  00836	8d 44 11 02	 lea	 eax, DWORD PTR [ecx+edx+2]
  0083a	89 85 fc fe ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], eax

; 670  :                     CHANGE_BIT_DEPTH_4(cy1x0, cy3x0, cy1x1, cy3x1, 2);

  00840	33 c9		 xor	 ecx, ecx
  00842	74 32		 je	 SHORT $LN40@convert_yv
  00844	8b 95 08 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x0$9[ebp]
  0084a	89 95 08 ff ff
	ff		 mov	 DWORD PTR _cy1x0$9[ebp], edx
  00850	8b 85 04 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$8[ebp]
  00856	89 85 04 ff ff
	ff		 mov	 DWORD PTR _cy3x0$8[ebp], eax
  0085c	8b 8d 00 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x1$7[ebp]
  00862	89 8d 00 ff ff
	ff		 mov	 DWORD PTR _cy1x1$7[ebp], ecx
  00868	8b 95 fc fe ff
	ff		 mov	 edx, DWORD PTR _cy3x1$6[ebp]
  0086e	89 95 fc fe ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], edx
  00874	eb 34		 jmp	 SHORT $LN41@convert_yv
$LN40@convert_yv:
  00876	33 c0		 xor	 eax, eax
  00878	74 30		 je	 SHORT $LN41@convert_yv
  0087a	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x0$9[ebp]
  00880	89 8d 08 ff ff
	ff		 mov	 DWORD PTR _cy1x0$9[ebp], ecx
  00886	8b 95 04 ff ff
	ff		 mov	 edx, DWORD PTR _cy3x0$8[ebp]
  0088c	89 95 04 ff ff
	ff		 mov	 DWORD PTR _cy3x0$8[ebp], edx
  00892	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x1$7[ebp]
  00898	89 85 00 ff ff
	ff		 mov	 DWORD PTR _cy1x1$7[ebp], eax
  0089e	8b 8d fc fe ff
	ff		 mov	 ecx, DWORD PTR _cy3x1$6[ebp]
  008a4	89 8d fc fe ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], ecx
$LN41@convert_yv:

; 671  : 
; 672  :                     dstC[0*dst_y_pitch   + 0] = (Tout)cy1x0;

  008aa	6b 55 e4 00	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 0
  008ae	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  008b1	66 8b 8d 08 ff
	ff ff		 mov	 cx, WORD PTR _cy1x0$9[ebp]
  008b8	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx

; 673  :                     dstC[0*dst_y_pitch   + 1] = (Tout)((cy1x0 + cy1x1 + 1) >> 1);

  008bc	8b 95 00 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x1$7[ebp]
  008c2	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x0$9[ebp]
  008c8	8d 4c 10 01	 lea	 ecx, DWORD PTR [eax+edx+1]
  008cc	d1 f9		 sar	 ecx, 1
  008ce	6b 55 e4 00	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 0
  008d2	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  008d5	66 89 4c 50 02	 mov	 WORD PTR [eax+edx*2+2], cx

; 674  :                     dstC[1*dst_y_pitch   + 0] = (Tout)cy3x0;

  008da	8b 4d e4	 mov	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  008dd	8b 55 94	 mov	 edx, DWORD PTR _dstC$44[ebp]
  008e0	66 8b 85 04 ff
	ff ff		 mov	 ax, WORD PTR _cy3x0$8[ebp]
  008e7	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax

; 675  :                     dstC[1*dst_y_pitch   + 1] = (Tout)((cy3x0 + cy3x1 + 1) >> 1);

  008eb	8b 8d fc fe ff
	ff		 mov	 ecx, DWORD PTR _cy3x1$6[ebp]
  008f1	8b 95 04 ff ff
	ff		 mov	 edx, DWORD PTR _cy3x0$8[ebp]
  008f7	8d 44 0a 01	 lea	 eax, DWORD PTR [edx+ecx+1]
  008fb	d1 f8		 sar	 eax, 1
  008fd	8b 4d e4	 mov	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  00900	8b 55 94	 mov	 edx, DWORD PTR _dstC$44[ebp]
  00903	66 89 44 4a 02	 mov	 WORD PTR [edx+ecx*2+2], ax

; 676  :                 }

  00908	e9 01 fe ff ff	 jmp	 $LN20@convert_yv
$LN31@convert_yv:

; 677  :             }
; 678  :         }

  0090d	e9 8f f9 ff ff	 jmp	 $LN11@convert_yv
$LN12@convert_yv:

; 679  :     }

  00912	e9 3d f9 ff ff	 jmp	 $LN8@convert_yv
$LN1@convert_yv:

; 680  : }

  00917	52		 push	 edx
  00918	8b cd		 mov	 ecx, ebp
  0091a	50		 push	 eax
  0091b	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN52@convert_yv
  00921	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00926	58		 pop	 eax
  00927	5a		 pop	 edx
  00928	5f		 pop	 edi
  00929	5e		 pop	 esi
  0092a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0092d	33 cd		 xor	 ecx, ebp
  0092f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00934	81 c4 2c 01 00
	00		 add	 esp, 300		; 0000012cH
  0093a	3b ec		 cmp	 ebp, esp
  0093c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00941	8b e5		 mov	 esp, ebp
  00943	5d		 pop	 ebp
  00944	c3		 ret	 0
  00945	0f 1f 00	 npad	 3
$LN52@convert_yv:
  00948	01 00 00 00	 DD	 1
  0094c	00 00 00 00	 DD	 $LN51@convert_yv
$LN51@convert_yv:
  00950	d4 ff ff ff	 DD	 -44			; ffffffd4H
  00954	0c 00 00 00	 DD	 12			; 0000000cH
  00958	00 00 00 00	 DD	 $LN50@convert_yv
$LN50@convert_yv:
  0095c	79		 DB	 121			; 00000079H
  0095d	5f		 DB	 95			; 0000005fH
  0095e	72		 DB	 114			; 00000072H
  0095f	61		 DB	 97			; 00000061H
  00960	6e		 DB	 110			; 0000006eH
  00961	67		 DB	 103			; 00000067H
  00962	65		 DB	 101			; 00000065H
  00963	00		 DB	 0
??$convert_yv12_p_to_yuv444_c@G$0O@G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_p_to_yuv444_c<unsigned short,14,unsigned short,16,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yv12_14_p_to_yuv444_16bit@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_14_p_to_yuv444_16bit

; 841  : static void convert_yv12_14_p_to_yuv444_16bit(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 842  :     convert_yv12_p_to_yuv444_c<uint16_t, 14, uint16_t, 16, false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yv12_p_to_yuv444_c@G$0O@G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_p_to_yuv444_c<unsigned short,14,unsigned short,16,0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 843  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yv12_14_p_to_yuv444_16bit@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_14_p_to_yuv444_16bit
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
tv302 = -280						; size = 4
tv240 = -276						; size = 4
tv241 = -272						; size = 4
tv235 = -268						; size = 4
tv232 = -264						; size = 4
tv229 = -260						; size = 4
tv227 = -256						; size = 4
$T1 = -252						; size = 4
$T2 = -248						; size = 4
$T3 = -244						; size = 4
$T4 = -240						; size = 4
$T5 = -236						; size = 12
_cy3x1$6 = -224						; size = 4
_cy2x1$7 = -220						; size = 4
_cy1x1$8 = -216						; size = 4
_cy0x1$9 = -212						; size = 4
_sy5x1$10 = -208					; size = 4
_sy4x1$11 = -204					; size = 4
_sy3x1$12 = -200					; size = 4
_sy2x1$13 = -196					; size = 4
_sy1x1$14 = -192					; size = 4
_sy0x1$15 = -188					; size = 4
_cxplus$16 = -184					; size = 4
_x$17 = -180						; size = 4
_cy3x0$18 = -176					; size = 4
_cy2x0$19 = -172					; size = 4
_cy1x0$20 = -168					; size = 4
_cy0x0$21 = -164					; size = 4
_sy5x0$22 = -160					; size = 4
_sy4x0$23 = -156					; size = 4
_sy3x0$24 = -152					; size = 4
_sy2x0$25 = -148					; size = 4
_sy1x0$26 = -144					; size = 4
_sy0x0$27 = -140					; size = 4
_y_p3$28 = -136						; size = 4
_y_p2$29 = -132						; size = 4
_y_p1$30 = -128						; size = 4
_y_m1$31 = -124						; size = 4
_y_m2$32 = -120						; size = 4
_x_fin$33 = -116					; size = 4
_srcP$34 = -112						; size = 4
_dstC$35 = -108						; size = 4
_y$36 = -104						; size = 4
_dstLine$37 = -100					; size = 4
_srcCLine$38 = -96					; size = 4
_ic$39 = -92						; size = 4
_src_uv_pitch$ = -88					; size = 4
_uv_fin$ = -84						; size = 4
_x$40 = -80						; size = 4
_y$41 = -76						; size = 4
_y_width$42 = -72					; size = 4
_dstLine$43 = -68					; size = 4
_srcYLine$44 = -64					; size = 4
$T45 = -60						; size = 12
_y_range$ = -44						; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yv12_i_to_yuv444_c@G$0BA@G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_i_to_yuv444_c<unsigned short,16,unsigned short,16,0>

; 683  : static void __forceinline convert_yv12_i_to_yuv444_c(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8d bd e8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-280]
  00011	b9 46 00 00 00	 mov	 ecx, 70			; 00000046H
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 684  :     static_assert((sizeof(Tin)  == 1 && in_bit_depth  == 8) || (sizeof(Tin)  == 2 && 8 < in_bit_depth  && in_bit_depth  <= 16), "invalid input bit depth.");
; 685  :     static_assert((sizeof(Tout) == 1 && out_bit_depth == 8) || (sizeof(Tout) == 2 && 8 < out_bit_depth && out_bit_depth <= 16), "invalid output bit depth.");
; 686  :     const int crop_left   = crop[0];

  00027	b8 04 00 00 00	 mov	 eax, 4
  0002c	6b c8 00	 imul	 ecx, eax, 0
  0002f	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00032	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00035	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 687  :     const int crop_up     = crop[1];

  00038	b9 04 00 00 00	 mov	 ecx, 4
  0003d	c1 e1 00	 shl	 ecx, 0
  00040	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00043	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00046	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 688  :     const int crop_right  = crop[2];

  00049	b9 04 00 00 00	 mov	 ecx, 4
  0004e	d1 e1		 shl	 ecx, 1
  00050	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00053	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00056	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 689  :     const int crop_bottom = crop[3];

  00059	b9 04 00 00 00	 mov	 ecx, 4
  0005e	6b d1 03	 imul	 edx, ecx, 3
  00061	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00064	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00067	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 690  :     const int src_y_pitch = src_y_pitch_byte / sizeof(Tin);

  0006a	8b 55 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebp]
  0006d	d1 ea		 shr	 edx, 1
  0006f	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 691  :     const int dst_y_pitch = dst_y_pitch_byte / sizeof(Tout);

  00072	8b 45 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  00075	d1 e8		 shr	 eax, 1
  00077	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 692  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  0007a	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0007d	51		 push	 ecx
  0007e	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  00081	52		 push	 edx
  00082	8b 45 20	 mov	 eax, DWORD PTR _height$[ebp]
  00085	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  00088	50		 push	 eax
  00089	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  0008c	51		 push	 ecx
  0008d	8d 95 14 ff ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  00093	52		 push	 edx
  00094	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00099	83 c4 14	 add	 esp, 20			; 00000014H
  0009c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009e	89 4d c4	 mov	 DWORD PTR $T45[ebp], ecx
  000a1	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a4	89 55 c8	 mov	 DWORD PTR $T45[ebp+4], edx
  000a7	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000aa	89 45 cc	 mov	 DWORD PTR $T45[ebp+8], eax
  000ad	8b 4d c4	 mov	 ecx, DWORD PTR $T45[ebp]
  000b0	89 4d d4	 mov	 DWORD PTR _y_range$[ebp], ecx
  000b3	8b 55 c8	 mov	 edx, DWORD PTR $T45[ebp+4]
  000b6	89 55 d8	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000b9	8b 45 cc	 mov	 eax, DWORD PTR $T45[ebp+8]
  000bc	89 45 dc	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 693  :     //Y
; 694  :     if (!uv_only) {

  000bf	b9 01 00 00 00	 mov	 ecx, 1
  000c4	85 c9		 test	 ecx, ecx
  000c6	0f 84 6e 01 00
	00		 je	 $LN17@convert_yv

; 695  :         Tin *srcYLine = (Tin *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000cc	ba 04 00 00 00	 mov	 edx, 4
  000d1	6b c2 00	 imul	 eax, edx, 0
  000d4	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  000d7	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  000db	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  000de	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  000e1	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  000e4	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  000e7	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  000ea	89 45 c0	 mov	 DWORD PTR _srcYLine$44[ebp], eax

; 696  :         Tout *dstLine = (Tout *)dst[0] + dst_y_pitch * y_range.start_dst;

  000ed	b9 04 00 00 00	 mov	 ecx, 4
  000f2	6b d1 00	 imul	 edx, ecx, 0
  000f5	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  000f8	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  000fc	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  000ff	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  00102	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  00105	89 45 bc	 mov	 DWORD PTR _dstLine$43[ebp], eax

; 697  :         const int y_width = width - crop_right - crop_left;

  00108	8b 4d 10	 mov	 ecx, DWORD PTR _width$[ebp]
  0010b	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  0010e	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  00111	89 4d b8	 mov	 DWORD PTR _y_width$42[ebp], ecx

; 698  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  00114	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _y$41[ebp], 0
  0011b	eb 21		 jmp	 SHORT $LN4@convert_yv
$LN2@convert_yv:
  0011d	8b 55 b4	 mov	 edx, DWORD PTR _y$41[ebp]
  00120	83 c2 01	 add	 edx, 1
  00123	89 55 b4	 mov	 DWORD PTR _y$41[ebp], edx
  00126	8b 45 e8	 mov	 eax, DWORD PTR _src_y_pitch$[ebp]
  00129	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$44[ebp]
  0012c	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  0012f	89 55 c0	 mov	 DWORD PTR _srcYLine$44[ebp], edx
  00132	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  00135	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$43[ebp]
  00138	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  0013b	89 55 bc	 mov	 DWORD PTR _dstLine$43[ebp], edx
$LN4@convert_yv:
  0013e	8b 45 b4	 mov	 eax, DWORD PTR _y$41[ebp]
  00141	3b 45 dc	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  00144	0f 8d f0 00 00
	00		 jge	 $LN17@convert_yv

; 699  :             if (in_bit_depth == out_bit_depth) {

  0014a	b9 01 00 00 00	 mov	 ecx, 1
  0014f	85 c9		 test	 ecx, ecx
  00151	74 1b		 je	 SHORT $LN18@convert_yv

; 700  :                 memcpy(dstLine, srcYLine, y_width * sizeof(Tin));

  00153	8b 55 b8	 mov	 edx, DWORD PTR _y_width$42[ebp]
  00156	d1 e2		 shl	 edx, 1
  00158	52		 push	 edx
  00159	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$44[ebp]
  0015c	50		 push	 eax
  0015d	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$43[ebp]
  00160	51		 push	 ecx
  00161	e8 00 00 00 00	 call	 _memcpy
  00166	83 c4 0c	 add	 esp, 12			; 0000000cH

; 701  :             } else {

  00169	e9 c7 00 00 00	 jmp	 $LN19@convert_yv
$LN18@convert_yv:

; 702  :                 for (int x = 0; x < y_width; x++) {

  0016e	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _x$40[ebp], 0
  00175	eb 09		 jmp	 SHORT $LN7@convert_yv
$LN5@convert_yv:
  00177	8b 55 b0	 mov	 edx, DWORD PTR _x$40[ebp]
  0017a	83 c2 01	 add	 edx, 1
  0017d	89 55 b0	 mov	 DWORD PTR _x$40[ebp], edx
$LN7@convert_yv:
  00180	8b 45 b0	 mov	 eax, DWORD PTR _x$40[ebp]
  00183	3b 45 b8	 cmp	 eax, DWORD PTR _y_width$42[ebp]
  00186	0f 8d a9 00 00
	00		 jge	 $LN19@convert_yv

; 703  :                     if (out_bit_depth > in_bit_depth) {

  0018c	33 c9		 xor	 ecx, ecx
  0018e	74 44		 je	 SHORT $LN20@convert_yv

; 704  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) << std::max(out_bit_depth - in_bit_depth, 0));

  00190	c7 85 10 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], 0
  0019a	c7 85 0c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T3[ebp], 0
  001a4	8b 55 b0	 mov	 edx, DWORD PTR _x$40[ebp]
  001a7	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$44[ebp]
  001aa	0f b7 34 50	 movzx	 esi, WORD PTR [eax+edx*2]
  001ae	8d 8d 10 ff ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  001b4	51		 push	 ecx
  001b5	8d 95 0c ff ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  001bb	52		 push	 edx
  001bc	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  001c1	83 c4 08	 add	 esp, 8
  001c4	8b 08		 mov	 ecx, DWORD PTR [eax]
  001c6	d3 e6		 shl	 esi, cl
  001c8	8b 45 b0	 mov	 eax, DWORD PTR _x$40[ebp]
  001cb	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$43[ebp]
  001ce	66 89 34 41	 mov	 WORD PTR [ecx+eax*2], si
  001d2	eb 5c		 jmp	 SHORT $LN21@convert_yv
$LN20@convert_yv:

; 705  :                     } else if (out_bit_depth < in_bit_depth) {

  001d4	33 d2		 xor	 edx, edx
  001d6	74 44		 je	 SHORT $LN22@convert_yv

; 706  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) >> std::max(in_bit_depth - out_bit_depth, 0));

  001d8	c7 85 08 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], 0
  001e2	c7 85 04 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T1[ebp], 0
  001ec	8b 45 b0	 mov	 eax, DWORD PTR _x$40[ebp]
  001ef	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$44[ebp]
  001f2	0f b7 34 41	 movzx	 esi, WORD PTR [ecx+eax*2]
  001f6	8d 95 08 ff ff
	ff		 lea	 edx, DWORD PTR $T2[ebp]
  001fc	52		 push	 edx
  001fd	8d 85 04 ff ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  00203	50		 push	 eax
  00204	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  00209	83 c4 08	 add	 esp, 8
  0020c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0020e	d3 fe		 sar	 esi, cl
  00210	8b 4d b0	 mov	 ecx, DWORD PTR _x$40[ebp]
  00213	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$43[ebp]
  00216	66 89 34 4a	 mov	 WORD PTR [edx+ecx*2], si

; 707  :                     } else {

  0021a	eb 14		 jmp	 SHORT $LN21@convert_yv
$LN22@convert_yv:

; 708  :                         dstLine[x] = (Tout)srcYLine[x];

  0021c	8b 45 b0	 mov	 eax, DWORD PTR _x$40[ebp]
  0021f	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$43[ebp]
  00222	8b 55 b0	 mov	 edx, DWORD PTR _x$40[ebp]
  00225	8b 75 c0	 mov	 esi, DWORD PTR _srcYLine$44[ebp]
  00228	66 8b 14 56	 mov	 dx, WORD PTR [esi+edx*2]
  0022c	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx
$LN21@convert_yv:

; 709  :                     }
; 710  :                 }

  00230	e9 42 ff ff ff	 jmp	 $LN5@convert_yv
$LN19@convert_yv:

; 711  :             }
; 712  :         }

  00235	e9 e3 fe ff ff	 jmp	 $LN2@convert_yv
$LN17@convert_yv:

; 713  :     }
; 714  :     //UV
; 715  :     const int uv_fin = height - crop_bottom;

  0023a	8b 45 20	 mov	 eax, DWORD PTR _height$[ebp]
  0023d	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  00240	89 45 ac	 mov	 DWORD PTR _uv_fin$[ebp], eax

; 716  :     const int src_uv_pitch = src_uv_pitch_byte / sizeof(Tin);

  00243	8b 4d 18	 mov	 ecx, DWORD PTR _src_uv_pitch_byte$[ebp]
  00246	d1 e9		 shr	 ecx, 1
  00248	89 4d a8	 mov	 DWORD PTR _src_uv_pitch$[ebp], ecx

; 717  :     for (int ic = 1; ic < 3; ic++) {

  0024b	c7 45 a4 01 00
	00 00		 mov	 DWORD PTR _ic$39[ebp], 1
  00252	eb 09		 jmp	 SHORT $LN10@convert_yv
$LN8@convert_yv:
  00254	8b 55 a4	 mov	 edx, DWORD PTR _ic$39[ebp]
  00257	83 c2 01	 add	 edx, 1
  0025a	89 55 a4	 mov	 DWORD PTR _ic$39[ebp], edx
$LN10@convert_yv:
  0025d	83 7d a4 03	 cmp	 DWORD PTR _ic$39[ebp], 3
  00261	0f 8d c4 05 00
	00		 jge	 $LN1@convert_yv

; 718  :         Tin *srcCLine = (Tin *)src[ic] + (((src_uv_pitch * y_range.start_src) + crop_left) >> 1);

  00267	8b 45 a8	 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  0026a	0f af 45 d4	 imul	 eax, DWORD PTR _y_range$[ebp]
  0026e	03 45 f8	 add	 eax, DWORD PTR _crop_left$[ebp]
  00271	d1 f8		 sar	 eax, 1
  00273	8b 4d a4	 mov	 ecx, DWORD PTR _ic$39[ebp]
  00276	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  00279	8b 0c 8a	 mov	 ecx, DWORD PTR [edx+ecx*4]
  0027c	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  0027f	89 55 a0	 mov	 DWORD PTR _srcCLine$38[ebp], edx

; 719  :         Tout *dstLine = (Tout *)dst[ic] + dst_y_pitch * y_range.start_dst;

  00282	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  00285	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  00289	8b 4d a4	 mov	 ecx, DWORD PTR _ic$39[ebp]
  0028c	8b 55 08	 mov	 edx, DWORD PTR _dst$[ebp]
  0028f	8b 0c 8a	 mov	 ecx, DWORD PTR [edx+ecx*4]
  00292	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00295	89 55 9c	 mov	 DWORD PTR _dstLine$37[ebp], edx

; 720  :         for (int y = 0; y < y_range.len; y += 4, srcCLine += src_uv_pitch * 2, dstLine += dst_y_pitch * 4) {

  00298	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _y$36[ebp], 0
  0029f	eb 26		 jmp	 SHORT $LN13@convert_yv
$LN11@convert_yv:
  002a1	8b 45 98	 mov	 eax, DWORD PTR _y$36[ebp]
  002a4	83 c0 04	 add	 eax, 4
  002a7	89 45 98	 mov	 DWORD PTR _y$36[ebp], eax
  002aa	8b 4d a8	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  002ad	d1 e1		 shl	 ecx, 1
  002af	8b 55 a0	 mov	 edx, DWORD PTR _srcCLine$38[ebp]
  002b2	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  002b5	89 45 a0	 mov	 DWORD PTR _srcCLine$38[ebp], eax
  002b8	8b 4d e4	 mov	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  002bb	c1 e1 02	 shl	 ecx, 2
  002be	8b 55 9c	 mov	 edx, DWORD PTR _dstLine$37[ebp]
  002c1	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  002c4	89 45 9c	 mov	 DWORD PTR _dstLine$37[ebp], eax
$LN13@convert_yv:
  002c7	8b 4d 98	 mov	 ecx, DWORD PTR _y$36[ebp]
  002ca	3b 4d dc	 cmp	 ecx, DWORD PTR _y_range$[ebp+8]
  002cd	0f 8d 53 05 00
	00		 jge	 $LN12@convert_yv

; 721  :             Tout *dstC = dstLine;

  002d3	8b 55 9c	 mov	 edx, DWORD PTR _dstLine$37[ebp]
  002d6	89 55 94	 mov	 DWORD PTR _dstC$35[ebp], edx

; 722  :             Tin *srcP = srcCLine;

  002d9	8b 45 a0	 mov	 eax, DWORD PTR _srcCLine$38[ebp]
  002dc	89 45 90	 mov	 DWORD PTR _srcP$34[ebp], eax

; 723  :             const int x_fin = width - crop_right - crop_left;

  002df	8b 4d 10	 mov	 ecx, DWORD PTR _width$[ebp]
  002e2	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  002e5	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  002e8	89 4d 8c	 mov	 DWORD PTR _x_fin$33[ebp], ecx

; 724  : 
; 725  :             int y_m2 = (y >= 4) ? -2 : 0;

  002eb	83 7d 98 04	 cmp	 DWORD PTR _y$36[ebp], 4
  002ef	7c 0c		 jl	 SHORT $LN31@convert_yv
  002f1	c7 85 00 ff ff
	ff fe ff ff ff	 mov	 DWORD PTR tv227[ebp], -2 ; fffffffeH
  002fb	eb 0a		 jmp	 SHORT $LN32@convert_yv
$LN31@convert_yv:
  002fd	c7 85 00 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv227[ebp], 0
$LN32@convert_yv:
  00307	8b 95 00 ff ff
	ff		 mov	 edx, DWORD PTR tv227[ebp]
  0030d	89 55 88	 mov	 DWORD PTR _y_m2$32[ebp], edx

; 726  :             int y_m1 = (y >= 2) ? -1 : 1;

  00310	83 7d 98 02	 cmp	 DWORD PTR _y$36[ebp], 2
  00314	7c 0c		 jl	 SHORT $LN33@convert_yv
  00316	c7 85 fc fe ff
	ff ff ff ff ff	 mov	 DWORD PTR tv229[ebp], -1
  00320	eb 0a		 jmp	 SHORT $LN34@convert_yv
$LN33@convert_yv:
  00322	c7 85 fc fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv229[ebp], 1
$LN34@convert_yv:
  0032c	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR tv229[ebp]
  00332	89 45 84	 mov	 DWORD PTR _y_m1$31[ebp], eax

; 727  :             int y_p1 = (y < uv_fin - 2) ? 1 : -1;

  00335	8b 4d ac	 mov	 ecx, DWORD PTR _uv_fin$[ebp]
  00338	83 e9 02	 sub	 ecx, 2
  0033b	39 4d 98	 cmp	 DWORD PTR _y$36[ebp], ecx
  0033e	7d 0c		 jge	 SHORT $LN35@convert_yv
  00340	c7 85 f8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv232[ebp], 1
  0034a	eb 0a		 jmp	 SHORT $LN36@convert_yv
$LN35@convert_yv:
  0034c	c7 85 f8 fe ff
	ff ff ff ff ff	 mov	 DWORD PTR tv232[ebp], -1
$LN36@convert_yv:
  00356	8b 95 f8 fe ff
	ff		 mov	 edx, DWORD PTR tv232[ebp]
  0035c	89 55 80	 mov	 DWORD PTR _y_p1$30[ebp], edx

; 728  :             int y_p2 = (y < uv_fin - 4) ? 2 :  0;

  0035f	8b 45 ac	 mov	 eax, DWORD PTR _uv_fin$[ebp]
  00362	83 e8 04	 sub	 eax, 4
  00365	39 45 98	 cmp	 DWORD PTR _y$36[ebp], eax
  00368	7d 0c		 jge	 SHORT $LN37@convert_yv
  0036a	c7 85 f4 fe ff
	ff 02 00 00 00	 mov	 DWORD PTR tv235[ebp], 2
  00374	eb 0a		 jmp	 SHORT $LN38@convert_yv
$LN37@convert_yv:
  00376	c7 85 f4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv235[ebp], 0
$LN38@convert_yv:
  00380	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR tv235[ebp]
  00386	89 8d 7c ff ff
	ff		 mov	 DWORD PTR _y_p2$29[ebp], ecx

; 729  :             int y_p3 = (y < uv_fin - 6) ? 3 : ((y < uv_fin - 2) ? 1 : -1);

  0038c	8b 55 ac	 mov	 edx, DWORD PTR _uv_fin$[ebp]
  0038f	83 ea 06	 sub	 edx, 6
  00392	39 55 98	 cmp	 DWORD PTR _y$36[ebp], edx
  00395	7d 0c		 jge	 SHORT $LN41@convert_yv
  00397	c7 85 f0 fe ff
	ff 03 00 00 00	 mov	 DWORD PTR tv241[ebp], 3
  003a1	eb 2d		 jmp	 SHORT $LN42@convert_yv
$LN41@convert_yv:
  003a3	8b 45 ac	 mov	 eax, DWORD PTR _uv_fin$[ebp]
  003a6	83 e8 02	 sub	 eax, 2
  003a9	39 45 98	 cmp	 DWORD PTR _y$36[ebp], eax
  003ac	7d 0c		 jge	 SHORT $LN39@convert_yv
  003ae	c7 85 ec fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv240[ebp], 1
  003b8	eb 0a		 jmp	 SHORT $LN40@convert_yv
$LN39@convert_yv:
  003ba	c7 85 ec fe ff
	ff ff ff ff ff	 mov	 DWORD PTR tv240[ebp], -1
$LN40@convert_yv:
  003c4	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR tv240[ebp]
  003ca	89 8d f0 fe ff
	ff		 mov	 DWORD PTR tv241[ebp], ecx
$LN42@convert_yv:
  003d0	8b 95 f0 fe ff
	ff		 mov	 edx, DWORD PTR tv241[ebp]
  003d6	89 95 78 ff ff
	ff		 mov	 DWORD PTR _y_p3$28[ebp], edx

; 730  : 
; 731  :             int sy0x0 = srcP[y_m2*src_uv_pitch + 0];

  003dc	8b 45 88	 mov	 eax, DWORD PTR _y_m2$32[ebp]
  003df	0f af 45 a8	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp]
  003e3	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  003e6	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  003ea	89 95 74 ff ff
	ff		 mov	 DWORD PTR _sy0x0$27[ebp], edx

; 732  :             int sy1x0 = srcP[y_m1*src_uv_pitch + 0];

  003f0	8b 45 84	 mov	 eax, DWORD PTR _y_m1$31[ebp]
  003f3	0f af 45 a8	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp]
  003f7	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  003fa	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  003fe	89 95 70 ff ff
	ff		 mov	 DWORD PTR _sy1x0$26[ebp], edx

; 733  :             int sy2x0 = srcP[   0*src_uv_pitch + 0];

  00404	6b 45 a8 00	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp], 0
  00408	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  0040b	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  0040f	89 95 6c ff ff
	ff		 mov	 DWORD PTR _sy2x0$25[ebp], edx

; 734  :             int sy3x0 = srcP[y_p1*src_uv_pitch + 0];

  00415	8b 45 80	 mov	 eax, DWORD PTR _y_p1$30[ebp]
  00418	0f af 45 a8	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp]
  0041c	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  0041f	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  00423	89 95 68 ff ff
	ff		 mov	 DWORD PTR _sy3x0$24[ebp], edx

; 735  :             int sy4x0 = srcP[y_p2*src_uv_pitch + 0];

  00429	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _y_p2$29[ebp]
  0042f	0f af 45 a8	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp]
  00433	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  00436	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  0043a	89 95 64 ff ff
	ff		 mov	 DWORD PTR _sy4x0$23[ebp], edx

; 736  :             int sy5x0 = srcP[y_p3*src_uv_pitch + 0];

  00440	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _y_p3$28[ebp]
  00446	0f af 45 a8	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp]
  0044a	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  0044d	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  00451	89 95 60 ff ff
	ff		 mov	 DWORD PTR _sy5x0$22[ebp], edx

; 737  : 
; 738  :             int cy0x0 = (sy0x0 * 1 + sy2x0 * 7 + 4);

  00457	6b 85 6c ff ff
	ff 07		 imul	 eax, DWORD PTR _sy2x0$25[ebp], 7
  0045e	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _sy0x0$27[ebp]
  00464	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00468	89 95 5c ff ff
	ff		 mov	 DWORD PTR _cy0x0$21[ebp], edx

; 739  :             int cy1x0 = (sy1x0 * 3 + sy3x0 * 5 + 4);

  0046e	6b 85 70 ff ff
	ff 03		 imul	 eax, DWORD PTR _sy1x0$26[ebp], 3
  00475	6b 8d 68 ff ff
	ff 05		 imul	 ecx, DWORD PTR _sy3x0$24[ebp], 5
  0047c	8d 54 08 04	 lea	 edx, DWORD PTR [eax+ecx+4]
  00480	89 95 58 ff ff
	ff		 mov	 DWORD PTR _cy1x0$20[ebp], edx

; 740  :             int cy2x0 = (sy2x0 * 5 + sy4x0 * 3 + 4);

  00486	6b 85 6c ff ff
	ff 05		 imul	 eax, DWORD PTR _sy2x0$25[ebp], 5
  0048d	6b 8d 64 ff ff
	ff 03		 imul	 ecx, DWORD PTR _sy4x0$23[ebp], 3
  00494	8d 54 08 04	 lea	 edx, DWORD PTR [eax+ecx+4]
  00498	89 95 54 ff ff
	ff		 mov	 DWORD PTR _cy2x0$19[ebp], edx

; 741  :             int cy3x0 = (sy3x0 * 7 + sy5x0 * 1 + 4);

  0049e	6b 85 68 ff ff
	ff 07		 imul	 eax, DWORD PTR _sy3x0$24[ebp], 7
  004a5	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _sy5x0$22[ebp]
  004ab	8d 54 08 04	 lea	 edx, DWORD PTR [eax+ecx+4]
  004af	89 95 50 ff ff
	ff		 mov	 DWORD PTR _cy3x0$18[ebp], edx

; 742  :             CHANGE_BIT_DEPTH_4(cy0x0, cy1x0, cy2x0, cy3x0, 3);

  004b5	33 c0		 xor	 eax, eax
  004b7	74 3e		 je	 SHORT $LN24@convert_yv
  004b9	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _cy0x0$21[ebp]
  004bf	c1 e1 fd	 shl	 ecx, -3			; fffffffdH
  004c2	89 8d 5c ff ff
	ff		 mov	 DWORD PTR _cy0x0$21[ebp], ecx
  004c8	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x0$20[ebp]
  004ce	c1 e2 fd	 shl	 edx, -3			; fffffffdH
  004d1	89 95 58 ff ff
	ff		 mov	 DWORD PTR _cy1x0$20[ebp], edx
  004d7	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR _cy2x0$19[ebp]
  004dd	c1 e0 fd	 shl	 eax, -3			; fffffffdH
  004e0	89 85 54 ff ff
	ff		 mov	 DWORD PTR _cy2x0$19[ebp], eax
  004e6	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x0$18[ebp]
  004ec	c1 e1 fd	 shl	 ecx, -3			; fffffffdH
  004ef	89 8d 50 ff ff
	ff		 mov	 DWORD PTR _cy3x0$18[ebp], ecx
  004f5	eb 45		 jmp	 SHORT $LN25@convert_yv
$LN24@convert_yv:
  004f7	ba 01 00 00 00	 mov	 edx, 1
  004fc	85 d2		 test	 edx, edx
  004fe	74 3c		 je	 SHORT $LN25@convert_yv
  00500	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _cy0x0$21[ebp]
  00506	c1 f8 03	 sar	 eax, 3
  00509	89 85 5c ff ff
	ff		 mov	 DWORD PTR _cy0x0$21[ebp], eax
  0050f	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x0$20[ebp]
  00515	c1 f9 03	 sar	 ecx, 3
  00518	89 8d 58 ff ff
	ff		 mov	 DWORD PTR _cy1x0$20[ebp], ecx
  0051e	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR _cy2x0$19[ebp]
  00524	c1 fa 03	 sar	 edx, 3
  00527	89 95 54 ff ff
	ff		 mov	 DWORD PTR _cy2x0$19[ebp], edx
  0052d	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$18[ebp]
  00533	c1 f8 03	 sar	 eax, 3
  00536	89 85 50 ff ff
	ff		 mov	 DWORD PTR _cy3x0$18[ebp], eax
$LN25@convert_yv:

; 743  : 
; 744  :             for (int x = 0; x < x_fin; x += 2, dstC += 2, srcP++) {

  0053c	c7 85 4c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _x$17[ebp], 0
  00546	eb 21		 jmp	 SHORT $LN16@convert_yv
$LN14@convert_yv:
  00548	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _x$17[ebp]
  0054e	83 c1 02	 add	 ecx, 2
  00551	89 8d 4c ff ff
	ff		 mov	 DWORD PTR _x$17[ebp], ecx
  00557	8b 55 94	 mov	 edx, DWORD PTR _dstC$35[ebp]
  0055a	83 c2 04	 add	 edx, 4
  0055d	89 55 94	 mov	 DWORD PTR _dstC$35[ebp], edx
  00560	8b 45 90	 mov	 eax, DWORD PTR _srcP$34[ebp]
  00563	83 c0 02	 add	 eax, 2
  00566	89 45 90	 mov	 DWORD PTR _srcP$34[ebp], eax
$LN16@convert_yv:
  00569	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _x$17[ebp]
  0056f	3b 4d 8c	 cmp	 ecx, DWORD PTR _x_fin$33[ebp]
  00572	0f 8d a9 02 00
	00		 jge	 $LN15@convert_yv

; 745  :                 int cxplus = (x + 2 < x_fin);

  00578	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR _x$17[ebp]
  0057e	83 c2 02	 add	 edx, 2
  00581	3b 55 8c	 cmp	 edx, DWORD PTR _x_fin$33[ebp]
  00584	7d 0c		 jge	 SHORT $LN43@convert_yv
  00586	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv302[ebp], 1
  00590	eb 0a		 jmp	 SHORT $LN44@convert_yv
$LN43@convert_yv:
  00592	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv302[ebp], 0
$LN44@convert_yv:
  0059c	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv302[ebp]
  005a2	89 85 48 ff ff
	ff		 mov	 DWORD PTR _cxplus$16[ebp], eax

; 746  :                 int sy0x1 = srcP[y_m2*src_uv_pitch + cxplus];

  005a8	8b 4d 88	 mov	 ecx, DWORD PTR _y_m2$32[ebp]
  005ab	0f af 4d a8	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  005af	03 8d 48 ff ff
	ff		 add	 ecx, DWORD PTR _cxplus$16[ebp]
  005b5	8b 55 90	 mov	 edx, DWORD PTR _srcP$34[ebp]
  005b8	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  005bc	89 85 44 ff ff
	ff		 mov	 DWORD PTR _sy0x1$15[ebp], eax

; 747  :                 int sy1x1 = srcP[y_m1*src_uv_pitch + cxplus];

  005c2	8b 4d 84	 mov	 ecx, DWORD PTR _y_m1$31[ebp]
  005c5	0f af 4d a8	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  005c9	03 8d 48 ff ff
	ff		 add	 ecx, DWORD PTR _cxplus$16[ebp]
  005cf	8b 55 90	 mov	 edx, DWORD PTR _srcP$34[ebp]
  005d2	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  005d6	89 85 40 ff ff
	ff		 mov	 DWORD PTR _sy1x1$14[ebp], eax

; 748  :                 int sy2x1 = srcP[   0*src_uv_pitch + cxplus];

  005dc	6b 4d a8 00	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 0
  005e0	03 8d 48 ff ff
	ff		 add	 ecx, DWORD PTR _cxplus$16[ebp]
  005e6	8b 55 90	 mov	 edx, DWORD PTR _srcP$34[ebp]
  005e9	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  005ed	89 85 3c ff ff
	ff		 mov	 DWORD PTR _sy2x1$13[ebp], eax

; 749  :                 int sy3x1 = srcP[y_p1*src_uv_pitch + cxplus];

  005f3	8b 4d 80	 mov	 ecx, DWORD PTR _y_p1$30[ebp]
  005f6	0f af 4d a8	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  005fa	03 8d 48 ff ff
	ff		 add	 ecx, DWORD PTR _cxplus$16[ebp]
  00600	8b 55 90	 mov	 edx, DWORD PTR _srcP$34[ebp]
  00603	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00607	89 85 38 ff ff
	ff		 mov	 DWORD PTR _sy3x1$12[ebp], eax

; 750  :                 int sy4x1 = srcP[y_p2*src_uv_pitch + cxplus];

  0060d	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _y_p2$29[ebp]
  00613	0f af 4d a8	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00617	03 8d 48 ff ff
	ff		 add	 ecx, DWORD PTR _cxplus$16[ebp]
  0061d	8b 55 90	 mov	 edx, DWORD PTR _srcP$34[ebp]
  00620	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00624	89 85 34 ff ff
	ff		 mov	 DWORD PTR _sy4x1$11[ebp], eax

; 751  :                 int sy5x1 = srcP[y_p3*src_uv_pitch + cxplus];

  0062a	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _y_p3$28[ebp]
  00630	0f af 4d a8	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00634	03 8d 48 ff ff
	ff		 add	 ecx, DWORD PTR _cxplus$16[ebp]
  0063a	8b 55 90	 mov	 edx, DWORD PTR _srcP$34[ebp]
  0063d	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00641	89 85 30 ff ff
	ff		 mov	 DWORD PTR _sy5x1$10[ebp], eax

; 752  : 
; 753  :                 int cy0x1 = (sy0x1 * 1 + sy2x1 * 7 + 4);

  00647	6b 8d 3c ff ff
	ff 07		 imul	 ecx, DWORD PTR _sy2x1$13[ebp], 7
  0064e	8b 95 44 ff ff
	ff		 mov	 edx, DWORD PTR _sy0x1$15[ebp]
  00654	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  00658	89 85 2c ff ff
	ff		 mov	 DWORD PTR _cy0x1$9[ebp], eax

; 754  :                 int cy1x1 = (sy1x1 * 3 + sy3x1 * 5 + 4);

  0065e	6b 8d 40 ff ff
	ff 03		 imul	 ecx, DWORD PTR _sy1x1$14[ebp], 3
  00665	6b 95 38 ff ff
	ff 05		 imul	 edx, DWORD PTR _sy3x1$12[ebp], 5
  0066c	8d 44 11 04	 lea	 eax, DWORD PTR [ecx+edx+4]
  00670	89 85 28 ff ff
	ff		 mov	 DWORD PTR _cy1x1$8[ebp], eax

; 755  :                 int cy2x1 = (sy2x1 * 5 + sy4x1 * 3 + 4);

  00676	6b 8d 3c ff ff
	ff 05		 imul	 ecx, DWORD PTR _sy2x1$13[ebp], 5
  0067d	6b 95 34 ff ff
	ff 03		 imul	 edx, DWORD PTR _sy4x1$11[ebp], 3
  00684	8d 44 11 04	 lea	 eax, DWORD PTR [ecx+edx+4]
  00688	89 85 24 ff ff
	ff		 mov	 DWORD PTR _cy2x1$7[ebp], eax

; 756  :                 int cy3x1 = (sy3x1 * 7 + sy5x1 * 1 + 4);

  0068e	6b 8d 38 ff ff
	ff 07		 imul	 ecx, DWORD PTR _sy3x1$12[ebp], 7
  00695	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR _sy5x1$10[ebp]
  0069b	8d 44 11 04	 lea	 eax, DWORD PTR [ecx+edx+4]
  0069f	89 85 20 ff ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], eax

; 757  :                 CHANGE_BIT_DEPTH_4(cy0x1, cy1x1, cy2x1, cy3x1, 3);

  006a5	33 c9		 xor	 ecx, ecx
  006a7	74 3e		 je	 SHORT $LN27@convert_yv
  006a9	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR _cy0x1$9[ebp]
  006af	c1 e2 fd	 shl	 edx, -3			; fffffffdH
  006b2	89 95 2c ff ff
	ff		 mov	 DWORD PTR _cy0x1$9[ebp], edx
  006b8	8b 85 28 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x1$8[ebp]
  006be	c1 e0 fd	 shl	 eax, -3			; fffffffdH
  006c1	89 85 28 ff ff
	ff		 mov	 DWORD PTR _cy1x1$8[ebp], eax
  006c7	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR _cy2x1$7[ebp]
  006cd	c1 e1 fd	 shl	 ecx, -3			; fffffffdH
  006d0	89 8d 24 ff ff
	ff		 mov	 DWORD PTR _cy2x1$7[ebp], ecx
  006d6	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR _cy3x1$6[ebp]
  006dc	c1 e2 fd	 shl	 edx, -3			; fffffffdH
  006df	89 95 20 ff ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], edx
  006e5	eb 45		 jmp	 SHORT $LN28@convert_yv
$LN27@convert_yv:
  006e7	b8 01 00 00 00	 mov	 eax, 1
  006ec	85 c0		 test	 eax, eax
  006ee	74 3c		 je	 SHORT $LN28@convert_yv
  006f0	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR _cy0x1$9[ebp]
  006f6	c1 f9 03	 sar	 ecx, 3
  006f9	89 8d 2c ff ff
	ff		 mov	 DWORD PTR _cy0x1$9[ebp], ecx
  006ff	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x1$8[ebp]
  00705	c1 fa 03	 sar	 edx, 3
  00708	89 95 28 ff ff
	ff		 mov	 DWORD PTR _cy1x1$8[ebp], edx
  0070e	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _cy2x1$7[ebp]
  00714	c1 f8 03	 sar	 eax, 3
  00717	89 85 24 ff ff
	ff		 mov	 DWORD PTR _cy2x1$7[ebp], eax
  0071d	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x1$6[ebp]
  00723	c1 f9 03	 sar	 ecx, 3
  00726	89 8d 20 ff ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], ecx
$LN28@convert_yv:

; 758  : 
; 759  :                 dstC[0*dst_y_pitch   + 0] = (Tout)cy0x0;

  0072c	6b 55 e4 00	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 0
  00730	8b 45 94	 mov	 eax, DWORD PTR _dstC$35[ebp]
  00733	66 8b 8d 5c ff
	ff ff		 mov	 cx, WORD PTR _cy0x0$21[ebp]
  0073a	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx

; 760  :                 dstC[0*dst_y_pitch   + 1] = (Tout)((cy0x0 + cy0x1 + 1) >> 1);

  0073e	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR _cy0x1$9[ebp]
  00744	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _cy0x0$21[ebp]
  0074a	8d 4c 10 01	 lea	 ecx, DWORD PTR [eax+edx+1]
  0074e	d1 f9		 sar	 ecx, 1
  00750	6b 55 e4 00	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 0
  00754	8b 45 94	 mov	 eax, DWORD PTR _dstC$35[ebp]
  00757	66 89 4c 50 02	 mov	 WORD PTR [eax+edx*2+2], cx

; 761  :                 dstC[1*dst_y_pitch   + 0] = (Tout)cy1x0;

  0075c	8b 4d e4	 mov	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  0075f	8b 55 94	 mov	 edx, DWORD PTR _dstC$35[ebp]
  00762	66 8b 85 58 ff
	ff ff		 mov	 ax, WORD PTR _cy1x0$20[ebp]
  00769	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax

; 762  :                 dstC[1*dst_y_pitch   + 1] = (Tout)((cy1x0 + cy1x1 + 1) >> 1);

  0076d	8b 8d 28 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x1$8[ebp]
  00773	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x0$20[ebp]
  00779	8d 44 0a 01	 lea	 eax, DWORD PTR [edx+ecx+1]
  0077d	d1 f8		 sar	 eax, 1
  0077f	8b 4d e4	 mov	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  00782	8b 55 94	 mov	 edx, DWORD PTR _dstC$35[ebp]
  00785	66 89 44 4a 02	 mov	 WORD PTR [edx+ecx*2+2], ax

; 763  :                 dstC[2*dst_y_pitch   + 0] = (Tout)cy2x0;

  0078a	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  0078d	d1 e0		 shl	 eax, 1
  0078f	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$35[ebp]
  00792	66 8b 95 54 ff
	ff ff		 mov	 dx, WORD PTR _cy2x0$19[ebp]
  00799	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx

; 764  :                 dstC[2*dst_y_pitch   + 1] = (Tout)((cy2x0 + cy2x1 + 1) >> 1);

  0079d	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _cy2x1$7[ebp]
  007a3	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _cy2x0$19[ebp]
  007a9	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  007ad	d1 fa		 sar	 edx, 1
  007af	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  007b2	d1 e0		 shl	 eax, 1
  007b4	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$35[ebp]
  007b7	66 89 54 41 02	 mov	 WORD PTR [ecx+eax*2+2], dx

; 765  :                 dstC[3*dst_y_pitch   + 0] = (Tout)cy3x0;

  007bc	6b 55 e4 03	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 3
  007c0	8b 45 94	 mov	 eax, DWORD PTR _dstC$35[ebp]
  007c3	66 8b 8d 50 ff
	ff ff		 mov	 cx, WORD PTR _cy3x0$18[ebp]
  007ca	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx

; 766  :                 dstC[3*dst_y_pitch   + 1] = (Tout)((cy3x0 + cy3x1 + 1) >> 1);

  007ce	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR _cy3x1$6[ebp]
  007d4	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$18[ebp]
  007da	8d 4c 10 01	 lea	 ecx, DWORD PTR [eax+edx+1]
  007de	d1 f9		 sar	 ecx, 1
  007e0	6b 55 e4 03	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 3
  007e4	8b 45 94	 mov	 eax, DWORD PTR _dstC$35[ebp]
  007e7	66 89 4c 50 02	 mov	 WORD PTR [eax+edx*2+2], cx

; 767  : 
; 768  :                 cy0x0 = cy0x1;

  007ec	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR _cy0x1$9[ebp]
  007f2	89 8d 5c ff ff
	ff		 mov	 DWORD PTR _cy0x0$21[ebp], ecx

; 769  :                 cy1x0 = cy1x1;

  007f8	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x1$8[ebp]
  007fe	89 95 58 ff ff
	ff		 mov	 DWORD PTR _cy1x0$20[ebp], edx

; 770  :                 cy2x0 = cy2x1;

  00804	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _cy2x1$7[ebp]
  0080a	89 85 54 ff ff
	ff		 mov	 DWORD PTR _cy2x0$19[ebp], eax

; 771  :                 cy3x0 = cy3x1;

  00810	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x1$6[ebp]
  00816	89 8d 50 ff ff
	ff		 mov	 DWORD PTR _cy3x0$18[ebp], ecx

; 772  :             }

  0081c	e9 27 fd ff ff	 jmp	 $LN14@convert_yv
$LN15@convert_yv:

; 773  :         }

  00821	e9 7b fa ff ff	 jmp	 $LN11@convert_yv
$LN12@convert_yv:

; 774  :     }

  00826	e9 29 fa ff ff	 jmp	 $LN8@convert_yv
$LN1@convert_yv:

; 775  : }

  0082b	52		 push	 edx
  0082c	8b cd		 mov	 ecx, ebp
  0082e	50		 push	 eax
  0082f	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN47@convert_yv
  00835	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0083a	58		 pop	 eax
  0083b	5a		 pop	 edx
  0083c	5f		 pop	 edi
  0083d	5e		 pop	 esi
  0083e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00841	33 cd		 xor	 ecx, ebp
  00843	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00848	81 c4 18 01 00
	00		 add	 esp, 280		; 00000118H
  0084e	3b ec		 cmp	 ebp, esp
  00850	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00855	8b e5		 mov	 esp, ebp
  00857	5d		 pop	 ebp
  00858	c3		 ret	 0
  00859	0f 1f 00	 npad	 3
$LN47@convert_yv:
  0085c	01 00 00 00	 DD	 1
  00860	00 00 00 00	 DD	 $LN46@convert_yv
$LN46@convert_yv:
  00864	d4 ff ff ff	 DD	 -44			; ffffffd4H
  00868	0c 00 00 00	 DD	 12			; 0000000cH
  0086c	00 00 00 00	 DD	 $LN45@convert_yv
$LN45@convert_yv:
  00870	79		 DB	 121			; 00000079H
  00871	5f		 DB	 95			; 0000005fH
  00872	72		 DB	 114			; 00000072H
  00873	61		 DB	 97			; 00000061H
  00874	6e		 DB	 110			; 0000006eH
  00875	67		 DB	 103			; 00000067H
  00876	65		 DB	 101			; 00000065H
  00877	00		 DB	 0
??$convert_yv12_i_to_yuv444_c@G$0BA@G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_i_to_yuv444_c<unsigned short,16,unsigned short,16,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yv12_16_i_to_yuv444_16bit@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_16_i_to_yuv444_16bit

; 837  : static void convert_yv12_16_i_to_yuv444_16bit(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 838  :     convert_yv12_i_to_yuv444_c<uint16_t, 16, uint16_t, 16, false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yv12_i_to_yuv444_c@G$0BA@G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_i_to_yuv444_c<unsigned short,16,unsigned short,16,0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 839  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yv12_16_i_to_yuv444_16bit@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_16_i_to_yuv444_16bit
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
tv432 = -300						; size = 4
tv317 = -296						; size = 4
tv232 = -292						; size = 4
$T1 = -288						; size = 4
$T2 = -284						; size = 4
$T3 = -280						; size = 4
$T4 = -276						; size = 4
$T5 = -272						; size = 12
_cy3x1$6 = -260						; size = 4
_cy1x1$7 = -256						; size = 4
_cy3x0$8 = -252						; size = 4
_cy1x0$9 = -248						; size = 4
_cy4x1$10 = -244					; size = 4
_cy2x1$11 = -240					; size = 4
_cy0x1$12 = -236					; size = 4
_cy4x0$13 = -232					; size = 4
_cy2x0$14 = -228					; size = 4
_cy0x0$15 = -224					; size = 4
_cxplus$16 = -220					; size = 4
_x$17 = -216						; size = 4
_cy3x1$18 = -212					; size = 4
_cy1x1$19 = -208					; size = 4
_cy3x0$20 = -204					; size = 4
_cy1x0$21 = -200					; size = 4
_cy4x1$22 = -196					; size = 4
_cy2x1$23 = -192					; size = 4
_cy0x1$24 = -188					; size = 4
_cy4x0$25 = -184					; size = 4
_cy2x0$26 = -180					; size = 4
_cy0x0$27 = -176					; size = 4
_cxplus$28 = -172					; size = 4
_x$29 = -168						; size = 4
_cy3x1$30 = -164					; size = 4
_cy1x1$31 = -160					; size = 4
_cy3x0$32 = -156					; size = 4
_cy1x0$33 = -152					; size = 4
_cy4x1$34 = -148					; size = 4
_cy2x1$35 = -144					; size = 4
_cy0x1$36 = -140					; size = 4
_cy4x0$37 = -136					; size = 4
_cy2x0$38 = -132					; size = 4
_cy0x0$39 = -128					; size = 4
_cxplus$40 = -124					; size = 4
_x$41 = -120						; size = 4
_x_fin$42 = -116					; size = 4
_srcP$43 = -112						; size = 4
_dstC$44 = -108						; size = 4
_y$45 = -104						; size = 4
_dstLine$46 = -100					; size = 4
_srcCLine$47 = -96					; size = 4
_ic$48 = -92						; size = 4
_src_uv_pitch$ = -88					; size = 4
_x$49 = -84						; size = 4
_y$50 = -80						; size = 4
_y_width$51 = -76					; size = 4
_y_fin$52 = -72						; size = 4
_dstLine$53 = -68					; size = 4
_srcYLine$54 = -64					; size = 4
$T55 = -60						; size = 12
_y_range$ = -44						; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yv12_p_to_yuv444_c@G$0BA@G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_p_to_yuv444_c<unsigned short,16,unsigned short,16,0>

; 573  : static void __forceinline convert_yv12_p_to_yuv444_c(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 2c 01 00
	00		 sub	 esp, 300		; 0000012cH
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8d bd d4 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-300]
  00011	b9 4b 00 00 00	 mov	 ecx, 75			; 0000004bH
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 574  :     static_assert((sizeof(Tin)  == 1 && in_bit_depth  == 8) || (sizeof(Tin)  == 2 && 8 < in_bit_depth  && in_bit_depth  <= 16), "invalid input bit depth.");
; 575  :     static_assert((sizeof(Tout) == 1 && out_bit_depth == 8) || (sizeof(Tout) == 2 && 8 < out_bit_depth && out_bit_depth <= 16), "invalid output bit depth.");
; 576  :     const int crop_left   = crop[0];

  00027	b8 04 00 00 00	 mov	 eax, 4
  0002c	6b c8 00	 imul	 ecx, eax, 0
  0002f	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00032	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00035	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 577  :     const int crop_up     = crop[1];

  00038	b9 04 00 00 00	 mov	 ecx, 4
  0003d	c1 e1 00	 shl	 ecx, 0
  00040	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00043	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00046	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 578  :     const int crop_right  = crop[2];

  00049	b9 04 00 00 00	 mov	 ecx, 4
  0004e	d1 e1		 shl	 ecx, 1
  00050	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00053	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00056	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 579  :     const int crop_bottom = crop[3];

  00059	b9 04 00 00 00	 mov	 ecx, 4
  0005e	6b d1 03	 imul	 edx, ecx, 3
  00061	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00064	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00067	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 580  :     const int src_y_pitch = src_y_pitch_byte / sizeof(Tin);

  0006a	8b 55 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebp]
  0006d	d1 ea		 shr	 edx, 1
  0006f	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 581  :     const int dst_y_pitch = dst_y_pitch_byte / sizeof(Tout);

  00072	8b 45 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  00075	d1 e8		 shr	 eax, 1
  00077	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 582  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  0007a	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0007d	51		 push	 ecx
  0007e	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  00081	52		 push	 edx
  00082	8b 45 20	 mov	 eax, DWORD PTR _height$[ebp]
  00085	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  00088	50		 push	 eax
  00089	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  0008c	51		 push	 ecx
  0008d	8d 95 f0 fe ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  00093	52		 push	 edx
  00094	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00099	83 c4 14	 add	 esp, 20			; 00000014H
  0009c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009e	89 4d c4	 mov	 DWORD PTR $T55[ebp], ecx
  000a1	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a4	89 55 c8	 mov	 DWORD PTR $T55[ebp+4], edx
  000a7	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000aa	89 45 cc	 mov	 DWORD PTR $T55[ebp+8], eax
  000ad	8b 4d c4	 mov	 ecx, DWORD PTR $T55[ebp]
  000b0	89 4d d4	 mov	 DWORD PTR _y_range$[ebp], ecx
  000b3	8b 55 c8	 mov	 edx, DWORD PTR $T55[ebp+4]
  000b6	89 55 d8	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000b9	8b 45 cc	 mov	 eax, DWORD PTR $T55[ebp+8]
  000bc	89 45 dc	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 583  :     //Y
; 584  :     if (!uv_only) {

  000bf	b9 01 00 00 00	 mov	 ecx, 1
  000c4	85 c9		 test	 ecx, ecx
  000c6	0f 84 77 01 00
	00		 je	 $LN23@convert_yv

; 585  :         Tin *srcYLine = (Tin *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000cc	ba 04 00 00 00	 mov	 edx, 4
  000d1	6b c2 00	 imul	 eax, edx, 0
  000d4	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  000d7	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  000db	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  000de	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  000e1	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  000e4	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  000e7	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  000ea	89 45 c0	 mov	 DWORD PTR _srcYLine$54[ebp], eax

; 586  :         Tout *dstLine = (Tout *)dst[0] + dst_y_pitch * y_range.start_dst;

  000ed	b9 04 00 00 00	 mov	 ecx, 4
  000f2	6b d1 00	 imul	 edx, ecx, 0
  000f5	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  000f8	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  000fc	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  000ff	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  00102	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  00105	89 45 bc	 mov	 DWORD PTR _dstLine$53[ebp], eax

; 587  :         const int y_fin = height - crop_bottom;

  00108	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  0010b	2b 4d ec	 sub	 ecx, DWORD PTR _crop_bottom$[ebp]
  0010e	89 4d b8	 mov	 DWORD PTR _y_fin$52[ebp], ecx

; 588  :         const int y_width = width - crop_right - crop_left;

  00111	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00114	2b 55 f0	 sub	 edx, DWORD PTR _crop_right$[ebp]
  00117	2b 55 f8	 sub	 edx, DWORD PTR _crop_left$[ebp]
  0011a	89 55 b4	 mov	 DWORD PTR _y_width$51[ebp], edx

; 589  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  0011d	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _y$50[ebp], 0
  00124	eb 21		 jmp	 SHORT $LN4@convert_yv
$LN2@convert_yv:
  00126	8b 45 b0	 mov	 eax, DWORD PTR _y$50[ebp]
  00129	83 c0 01	 add	 eax, 1
  0012c	89 45 b0	 mov	 DWORD PTR _y$50[ebp], eax
  0012f	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  00132	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$54[ebp]
  00135	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  00138	89 45 c0	 mov	 DWORD PTR _srcYLine$54[ebp], eax
  0013b	8b 4d e4	 mov	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  0013e	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$53[ebp]
  00141	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  00144	89 45 bc	 mov	 DWORD PTR _dstLine$53[ebp], eax
$LN4@convert_yv:
  00147	8b 4d b0	 mov	 ecx, DWORD PTR _y$50[ebp]
  0014a	3b 4d dc	 cmp	 ecx, DWORD PTR _y_range$[ebp+8]
  0014d	0f 8d f0 00 00
	00		 jge	 $LN23@convert_yv

; 590  :             if (in_bit_depth == out_bit_depth && sizeof(Tin) == sizeof(Tout)) {

  00153	ba 01 00 00 00	 mov	 edx, 1
  00158	85 d2		 test	 edx, edx
  0015a	74 1b		 je	 SHORT $LN24@convert_yv

; 591  :                 memcpy(dstLine, srcYLine, y_width * sizeof(Tin));

  0015c	8b 45 b4	 mov	 eax, DWORD PTR _y_width$51[ebp]
  0015f	d1 e0		 shl	 eax, 1
  00161	50		 push	 eax
  00162	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$54[ebp]
  00165	51		 push	 ecx
  00166	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$53[ebp]
  00169	52		 push	 edx
  0016a	e8 00 00 00 00	 call	 _memcpy
  0016f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 592  :             } else {

  00172	e9 c7 00 00 00	 jmp	 $LN25@convert_yv
$LN24@convert_yv:

; 593  :                 for (int x = 0; x < y_width; x++) {

  00177	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR _x$49[ebp], 0
  0017e	eb 09		 jmp	 SHORT $LN7@convert_yv
$LN5@convert_yv:
  00180	8b 45 ac	 mov	 eax, DWORD PTR _x$49[ebp]
  00183	83 c0 01	 add	 eax, 1
  00186	89 45 ac	 mov	 DWORD PTR _x$49[ebp], eax
$LN7@convert_yv:
  00189	8b 4d ac	 mov	 ecx, DWORD PTR _x$49[ebp]
  0018c	3b 4d b4	 cmp	 ecx, DWORD PTR _y_width$51[ebp]
  0018f	0f 8d a9 00 00
	00		 jge	 $LN25@convert_yv

; 594  :                     if (out_bit_depth > in_bit_depth) {

  00195	33 d2		 xor	 edx, edx
  00197	74 44		 je	 SHORT $LN26@convert_yv

; 595  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) << std::max(out_bit_depth - in_bit_depth, 0));

  00199	c7 85 ec fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], 0
  001a3	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T3[ebp], 0
  001ad	8b 45 ac	 mov	 eax, DWORD PTR _x$49[ebp]
  001b0	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$54[ebp]
  001b3	0f b7 34 41	 movzx	 esi, WORD PTR [ecx+eax*2]
  001b7	8d 95 ec fe ff
	ff		 lea	 edx, DWORD PTR $T4[ebp]
  001bd	52		 push	 edx
  001be	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  001c4	50		 push	 eax
  001c5	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  001ca	83 c4 08	 add	 esp, 8
  001cd	8b 08		 mov	 ecx, DWORD PTR [eax]
  001cf	d3 e6		 shl	 esi, cl
  001d1	8b 4d ac	 mov	 ecx, DWORD PTR _x$49[ebp]
  001d4	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$53[ebp]
  001d7	66 89 34 4a	 mov	 WORD PTR [edx+ecx*2], si
  001db	eb 5c		 jmp	 SHORT $LN27@convert_yv
$LN26@convert_yv:

; 596  :                     } else if (out_bit_depth < in_bit_depth) {

  001dd	33 c0		 xor	 eax, eax
  001df	74 44		 je	 SHORT $LN28@convert_yv

; 597  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) >> std::max(in_bit_depth - out_bit_depth, 0));

  001e1	c7 85 e4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], 0
  001eb	c7 85 e0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T1[ebp], 0
  001f5	8b 4d ac	 mov	 ecx, DWORD PTR _x$49[ebp]
  001f8	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$54[ebp]
  001fb	0f b7 34 4a	 movzx	 esi, WORD PTR [edx+ecx*2]
  001ff	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  00205	50		 push	 eax
  00206	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  0020c	51		 push	 ecx
  0020d	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  00212	83 c4 08	 add	 esp, 8
  00215	8b 08		 mov	 ecx, DWORD PTR [eax]
  00217	d3 fe		 sar	 esi, cl
  00219	8b 55 ac	 mov	 edx, DWORD PTR _x$49[ebp]
  0021c	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$53[ebp]
  0021f	66 89 34 50	 mov	 WORD PTR [eax+edx*2], si

; 598  :                     } else {

  00223	eb 14		 jmp	 SHORT $LN27@convert_yv
$LN28@convert_yv:

; 599  :                         dstLine[x] = (Tout)srcYLine[x];

  00225	8b 4d ac	 mov	 ecx, DWORD PTR _x$49[ebp]
  00228	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$53[ebp]
  0022b	8b 45 ac	 mov	 eax, DWORD PTR _x$49[ebp]
  0022e	8b 75 c0	 mov	 esi, DWORD PTR _srcYLine$54[ebp]
  00231	66 8b 04 46	 mov	 ax, WORD PTR [esi+eax*2]
  00235	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax
$LN27@convert_yv:

; 600  :                     }
; 601  :                 }

  00239	e9 42 ff ff ff	 jmp	 $LN5@convert_yv
$LN25@convert_yv:

; 602  :             }
; 603  :         }

  0023e	e9 e3 fe ff ff	 jmp	 $LN2@convert_yv
$LN23@convert_yv:

; 604  :     }
; 605  :     //UV
; 606  :     const int src_uv_pitch = src_uv_pitch_byte / sizeof(Tin);

  00243	8b 4d 18	 mov	 ecx, DWORD PTR _src_uv_pitch_byte$[ebp]
  00246	d1 e9		 shr	 ecx, 1
  00248	89 4d a8	 mov	 DWORD PTR _src_uv_pitch$[ebp], ecx

; 607  :     for (int ic = 1; ic < 3; ic++) {

  0024b	c7 45 a4 01 00
	00 00		 mov	 DWORD PTR _ic$48[ebp], 1
  00252	eb 09		 jmp	 SHORT $LN10@convert_yv
$LN8@convert_yv:
  00254	8b 55 a4	 mov	 edx, DWORD PTR _ic$48[ebp]
  00257	83 c2 01	 add	 edx, 1
  0025a	89 55 a4	 mov	 DWORD PTR _ic$48[ebp], edx
$LN10@convert_yv:
  0025d	83 7d a4 03	 cmp	 DWORD PTR _ic$48[ebp], 3
  00261	0f 8d 07 07 00
	00		 jge	 $LN1@convert_yv

; 608  :         Tin *srcCLine = (Tin *)src[ic] + (((src_uv_pitch * y_range.start_src) + crop_left) >> 1);

  00267	8b 45 a8	 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  0026a	0f af 45 d4	 imul	 eax, DWORD PTR _y_range$[ebp]
  0026e	03 45 f8	 add	 eax, DWORD PTR _crop_left$[ebp]
  00271	d1 f8		 sar	 eax, 1
  00273	8b 4d a4	 mov	 ecx, DWORD PTR _ic$48[ebp]
  00276	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  00279	8b 0c 8a	 mov	 ecx, DWORD PTR [edx+ecx*4]
  0027c	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  0027f	89 55 a0	 mov	 DWORD PTR _srcCLine$47[ebp], edx

; 609  :         Tout *dstLine = (Tout *)dst[ic] + dst_y_pitch * y_range.start_dst;

  00282	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  00285	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  00289	8b 4d a4	 mov	 ecx, DWORD PTR _ic$48[ebp]
  0028c	8b 55 08	 mov	 edx, DWORD PTR _dst$[ebp]
  0028f	8b 0c 8a	 mov	 ecx, DWORD PTR [edx+ecx*4]
  00292	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00295	89 55 9c	 mov	 DWORD PTR _dstLine$46[ebp], edx

; 610  :         for (int y = 0; y < y_range.len; y += 2, srcCLine += src_uv_pitch, dstLine += dst_y_pitch * 2) {

  00298	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _y$45[ebp], 0
  0029f	eb 23		 jmp	 SHORT $LN13@convert_yv
$LN11@convert_yv:
  002a1	8b 45 98	 mov	 eax, DWORD PTR _y$45[ebp]
  002a4	83 c0 02	 add	 eax, 2
  002a7	89 45 98	 mov	 DWORD PTR _y$45[ebp], eax
  002aa	8b 4d a8	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  002ad	8b 55 a0	 mov	 edx, DWORD PTR _srcCLine$47[ebp]
  002b0	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  002b3	89 45 a0	 mov	 DWORD PTR _srcCLine$47[ebp], eax
  002b6	8b 4d e4	 mov	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  002b9	d1 e1		 shl	 ecx, 1
  002bb	8b 55 9c	 mov	 edx, DWORD PTR _dstLine$46[ebp]
  002be	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  002c1	89 45 9c	 mov	 DWORD PTR _dstLine$46[ebp], eax
$LN13@convert_yv:
  002c4	8b 4d 98	 mov	 ecx, DWORD PTR _y$45[ebp]
  002c7	3b 4d dc	 cmp	 ecx, DWORD PTR _y_range$[ebp+8]
  002ca	0f 8d 99 06 00
	00		 jge	 $LN12@convert_yv

; 611  :             Tout *dstC = dstLine;

  002d0	8b 55 9c	 mov	 edx, DWORD PTR _dstLine$46[ebp]
  002d3	89 55 94	 mov	 DWORD PTR _dstC$44[ebp], edx

; 612  :             Tin *srcP = srcCLine;

  002d6	8b 45 a0	 mov	 eax, DWORD PTR _srcCLine$47[ebp]
  002d9	89 45 90	 mov	 DWORD PTR _srcP$43[ebp], eax

; 613  :             const int x_fin = width - crop_right - crop_left;

  002dc	8b 4d 10	 mov	 ecx, DWORD PTR _width$[ebp]
  002df	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  002e2	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  002e5	89 4d 8c	 mov	 DWORD PTR _x_fin$42[ebp], ecx

; 614  :             if (y == 0) {

  002e8	83 7d 98 00	 cmp	 DWORD PTR _y$45[ebp], 0
  002ec	0f 85 0c 02 00
	00		 jne	 $LN30@convert_yv

; 615  :                 for (int x = 0; x < x_fin; x += 2, dstC += 2, srcP++) {

  002f2	c7 45 88 00 00
	00 00		 mov	 DWORD PTR _x$41[ebp], 0
  002f9	eb 1b		 jmp	 SHORT $LN16@convert_yv
$LN14@convert_yv:
  002fb	8b 55 88	 mov	 edx, DWORD PTR _x$41[ebp]
  002fe	83 c2 02	 add	 edx, 2
  00301	89 55 88	 mov	 DWORD PTR _x$41[ebp], edx
  00304	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  00307	83 c0 04	 add	 eax, 4
  0030a	89 45 94	 mov	 DWORD PTR _dstC$44[ebp], eax
  0030d	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$43[ebp]
  00310	83 c1 02	 add	 ecx, 2
  00313	89 4d 90	 mov	 DWORD PTR _srcP$43[ebp], ecx
$LN16@convert_yv:
  00316	8b 55 88	 mov	 edx, DWORD PTR _x$41[ebp]
  00319	3b 55 8c	 cmp	 edx, DWORD PTR _x_fin$42[ebp]
  0031c	0f 8d d7 01 00
	00		 jge	 $LN15@convert_yv

; 616  :                     int cxplus = (x + 2 < x_fin);

  00322	8b 45 88	 mov	 eax, DWORD PTR _x$41[ebp]
  00325	83 c0 02	 add	 eax, 2
  00328	3b 45 8c	 cmp	 eax, DWORD PTR _x_fin$42[ebp]
  0032b	7d 0c		 jge	 SHORT $LN44@convert_yv
  0032d	c7 85 dc fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv232[ebp], 1
  00337	eb 0a		 jmp	 SHORT $LN45@convert_yv
$LN44@convert_yv:
  00339	c7 85 dc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv232[ebp], 0
$LN45@convert_yv:
  00343	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR tv232[ebp]
  00349	89 4d 84	 mov	 DWORD PTR _cxplus$40[ebp], ecx

; 617  :                     int cy0x0 = srcP[ 0*src_uv_pitch + 0];

  0034c	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  00350	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  00353	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  00357	89 4d 80	 mov	 DWORD PTR _cy0x0$39[ebp], ecx

; 618  :                     int cy2x0 = srcP[ 0*src_uv_pitch + 0];

  0035a	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  0035e	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  00361	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  00365	89 8d 7c ff ff
	ff		 mov	 DWORD PTR _cy2x0$38[ebp], ecx

; 619  :                     int cy4x0 = srcP[ 1*src_uv_pitch + 0];

  0036b	8b 55 a8	 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  0036e	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  00371	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  00375	89 8d 78 ff ff
	ff		 mov	 DWORD PTR _cy4x0$37[ebp], ecx

; 620  :                     int cy0x1 = srcP[ 0*src_uv_pitch + cxplus];

  0037b	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  0037f	03 55 84	 add	 edx, DWORD PTR _cxplus$40[ebp]
  00382	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  00385	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  00389	89 8d 74 ff ff
	ff		 mov	 DWORD PTR _cy0x1$36[ebp], ecx

; 621  :                     int cy2x1 = srcP[ 0*src_uv_pitch + cxplus];

  0038f	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  00393	03 55 84	 add	 edx, DWORD PTR _cxplus$40[ebp]
  00396	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  00399	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  0039d	89 8d 70 ff ff
	ff		 mov	 DWORD PTR _cy2x1$35[ebp], ecx

; 622  :                     int cy4x1 = srcP[ 1*src_uv_pitch + cxplus];

  003a3	8b 55 84	 mov	 edx, DWORD PTR _cxplus$40[ebp]
  003a6	03 55 a8	 add	 edx, DWORD PTR _src_uv_pitch$[ebp]
  003a9	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  003ac	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  003b0	89 8d 6c ff ff
	ff		 mov	 DWORD PTR _cy4x1$34[ebp], ecx

; 623  : 
; 624  :                     int cy1x0 = (cy0x0 * 1 + cy2x0 * 3 + 2);

  003b6	6b 95 7c ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x0$38[ebp], 3
  003bd	8b 45 80	 mov	 eax, DWORD PTR _cy0x0$39[ebp]
  003c0	8d 4c 10 02	 lea	 ecx, DWORD PTR [eax+edx+2]
  003c4	89 8d 68 ff ff
	ff		 mov	 DWORD PTR _cy1x0$33[ebp], ecx

; 625  :                     int cy3x0 = (cy2x0 * 3 + cy4x0 * 1 + 2);

  003ca	6b 95 7c ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x0$38[ebp], 3
  003d1	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _cy4x0$37[ebp]
  003d7	8d 4c 02 02	 lea	 ecx, DWORD PTR [edx+eax+2]
  003db	89 8d 64 ff ff
	ff		 mov	 DWORD PTR _cy3x0$32[ebp], ecx

; 626  :                     int cy1x1 = (cy0x1 * 1 + cy2x1 * 3 + 2);

  003e1	6b 95 70 ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x1$35[ebp], 3
  003e8	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _cy0x1$36[ebp]
  003ee	8d 4c 10 02	 lea	 ecx, DWORD PTR [eax+edx+2]
  003f2	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _cy1x1$31[ebp], ecx

; 627  :                     int cy3x1 = (cy2x1 * 3 + cy4x1 * 1 + 2);

  003f8	6b 95 70 ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x1$35[ebp], 3
  003ff	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _cy4x1$34[ebp]
  00405	8d 4c 02 02	 lea	 ecx, DWORD PTR [edx+eax+2]
  00409	89 8d 5c ff ff
	ff		 mov	 DWORD PTR _cy3x1$30[ebp], ecx

; 628  :                     CHANGE_BIT_DEPTH_4(cy1x0, cy3x0, cy1x1, cy3x1, 2);

  0040f	33 d2		 xor	 edx, edx
  00411	74 3e		 je	 SHORT $LN32@convert_yv
  00413	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x0$33[ebp]
  00419	c1 e0 fe	 shl	 eax, -2			; fffffffeH
  0041c	89 85 68 ff ff
	ff		 mov	 DWORD PTR _cy1x0$33[ebp], eax
  00422	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x0$32[ebp]
  00428	c1 e1 fe	 shl	 ecx, -2			; fffffffeH
  0042b	89 8d 64 ff ff
	ff		 mov	 DWORD PTR _cy3x0$32[ebp], ecx
  00431	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x1$31[ebp]
  00437	c1 e2 fe	 shl	 edx, -2			; fffffffeH
  0043a	89 95 60 ff ff
	ff		 mov	 DWORD PTR _cy1x1$31[ebp], edx
  00440	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _cy3x1$30[ebp]
  00446	c1 e0 fe	 shl	 eax, -2			; fffffffeH
  00449	89 85 5c ff ff
	ff		 mov	 DWORD PTR _cy3x1$30[ebp], eax
  0044f	eb 45		 jmp	 SHORT $LN33@convert_yv
$LN32@convert_yv:
  00451	b9 01 00 00 00	 mov	 ecx, 1
  00456	85 c9		 test	 ecx, ecx
  00458	74 3c		 je	 SHORT $LN33@convert_yv
  0045a	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x0$33[ebp]
  00460	c1 fa 02	 sar	 edx, 2
  00463	89 95 68 ff ff
	ff		 mov	 DWORD PTR _cy1x0$33[ebp], edx
  00469	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$32[ebp]
  0046f	c1 f8 02	 sar	 eax, 2
  00472	89 85 64 ff ff
	ff		 mov	 DWORD PTR _cy3x0$32[ebp], eax
  00478	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x1$31[ebp]
  0047e	c1 f9 02	 sar	 ecx, 2
  00481	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _cy1x1$31[ebp], ecx
  00487	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR _cy3x1$30[ebp]
  0048d	c1 fa 02	 sar	 edx, 2
  00490	89 95 5c ff ff
	ff		 mov	 DWORD PTR _cy3x1$30[ebp], edx
$LN33@convert_yv:

; 629  : 
; 630  :                     dstC[0*dst_y_pitch   + 0] = (Tout)cy1x0;

  00496	6b 45 e4 00	 imul	 eax, DWORD PTR _dst_y_pitch$[ebp], 0
  0049a	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$44[ebp]
  0049d	66 8b 95 68 ff
	ff ff		 mov	 dx, WORD PTR _cy1x0$33[ebp]
  004a4	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx

; 631  :                     dstC[0*dst_y_pitch   + 1] = (Tout)((cy1x0 + cy1x1 + 1) >> 1);

  004a8	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x1$31[ebp]
  004ae	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x0$33[ebp]
  004b4	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  004b8	d1 fa		 sar	 edx, 1
  004ba	6b 45 e4 00	 imul	 eax, DWORD PTR _dst_y_pitch$[ebp], 0
  004be	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$44[ebp]
  004c1	66 89 54 41 02	 mov	 WORD PTR [ecx+eax*2+2], dx

; 632  :                     dstC[1*dst_y_pitch   + 0] = (Tout)cy3x0;

  004c6	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  004c9	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  004cc	66 8b 8d 64 ff
	ff ff		 mov	 cx, WORD PTR _cy3x0$32[ebp]
  004d3	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx

; 633  :                     dstC[1*dst_y_pitch   + 1] = (Tout)((cy3x0 + cy3x1 + 1) >> 1);

  004d7	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR _cy3x1$30[ebp]
  004dd	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$32[ebp]
  004e3	8d 4c 10 01	 lea	 ecx, DWORD PTR [eax+edx+1]
  004e7	d1 f9		 sar	 ecx, 1
  004e9	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  004ec	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  004ef	66 89 4c 50 02	 mov	 WORD PTR [eax+edx*2+2], cx

; 634  :                 }

  004f4	e9 02 fe ff ff	 jmp	 $LN14@convert_yv
$LN15@convert_yv:

; 635  :             } else if (y >= height-2) {

  004f9	e9 66 04 00 00	 jmp	 $LN31@convert_yv
$LN30@convert_yv:
  004fe	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00501	83 e9 02	 sub	 ecx, 2
  00504	39 4d 98	 cmp	 DWORD PTR _y$45[ebp], ecx
  00507	0f 8c 2f 02 00
	00		 jl	 $LN35@convert_yv

; 636  :                 for (int x = 0; x < x_fin; x += 2, dstC += 2, srcP++) {

  0050d	c7 85 58 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _x$29[ebp], 0
  00517	eb 21		 jmp	 SHORT $LN19@convert_yv
$LN17@convert_yv:
  00519	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _x$29[ebp]
  0051f	83 c2 02	 add	 edx, 2
  00522	89 95 58 ff ff
	ff		 mov	 DWORD PTR _x$29[ebp], edx
  00528	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  0052b	83 c0 04	 add	 eax, 4
  0052e	89 45 94	 mov	 DWORD PTR _dstC$44[ebp], eax
  00531	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$43[ebp]
  00534	83 c1 02	 add	 ecx, 2
  00537	89 4d 90	 mov	 DWORD PTR _srcP$43[ebp], ecx
$LN19@convert_yv:
  0053a	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _x$29[ebp]
  00540	3b 55 8c	 cmp	 edx, DWORD PTR _x_fin$42[ebp]
  00543	0f 8d ee 01 00
	00		 jge	 $LN18@convert_yv

; 637  :                     int cxplus = (x + 2 < x_fin);

  00549	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _x$29[ebp]
  0054f	83 c0 02	 add	 eax, 2
  00552	3b 45 8c	 cmp	 eax, DWORD PTR _x_fin$42[ebp]
  00555	7d 0c		 jge	 SHORT $LN46@convert_yv
  00557	c7 85 d8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv317[ebp], 1
  00561	eb 0a		 jmp	 SHORT $LN47@convert_yv
$LN46@convert_yv:
  00563	c7 85 d8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv317[ebp], 0
$LN47@convert_yv:
  0056d	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR tv317[ebp]
  00573	89 8d 54 ff ff
	ff		 mov	 DWORD PTR _cxplus$28[ebp], ecx

; 638  :                     int cy0x0 = srcP[-1*src_uv_pitch + 0];

  00579	6b 55 a8 ff	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], -1
  0057d	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  00580	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  00584	89 8d 50 ff ff
	ff		 mov	 DWORD PTR _cy0x0$27[ebp], ecx

; 639  :                     int cy2x0 = srcP[ 0*src_uv_pitch + 0];

  0058a	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  0058e	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  00591	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  00595	89 8d 4c ff ff
	ff		 mov	 DWORD PTR _cy2x0$26[ebp], ecx

; 640  :                     int cy4x0 = srcP[ 0*src_uv_pitch + 0];

  0059b	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  0059f	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  005a2	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  005a6	89 8d 48 ff ff
	ff		 mov	 DWORD PTR _cy4x0$25[ebp], ecx

; 641  :                     int cy0x1 = srcP[-1*src_uv_pitch + cxplus];

  005ac	6b 55 a8 ff	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], -1
  005b0	03 95 54 ff ff
	ff		 add	 edx, DWORD PTR _cxplus$28[ebp]
  005b6	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  005b9	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  005bd	89 8d 44 ff ff
	ff		 mov	 DWORD PTR _cy0x1$24[ebp], ecx

; 642  :                     int cy2x1 = srcP[ 0*src_uv_pitch + cxplus];

  005c3	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  005c7	03 95 54 ff ff
	ff		 add	 edx, DWORD PTR _cxplus$28[ebp]
  005cd	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  005d0	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  005d4	89 8d 40 ff ff
	ff		 mov	 DWORD PTR _cy2x1$23[ebp], ecx

; 643  :                     int cy4x1 = srcP[ 0*src_uv_pitch + cxplus];

  005da	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  005de	03 95 54 ff ff
	ff		 add	 edx, DWORD PTR _cxplus$28[ebp]
  005e4	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  005e7	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  005eb	89 8d 3c ff ff
	ff		 mov	 DWORD PTR _cy4x1$22[ebp], ecx

; 644  : 
; 645  :                     int cy1x0 = (cy0x0 * 1 + cy2x0 * 3 + 2);

  005f1	6b 95 4c ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x0$26[ebp], 3
  005f8	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _cy0x0$27[ebp]
  005fe	8d 4c 10 02	 lea	 ecx, DWORD PTR [eax+edx+2]
  00602	89 8d 38 ff ff
	ff		 mov	 DWORD PTR _cy1x0$21[ebp], ecx

; 646  :                     int cy3x0 = (cy2x0 * 3 + cy4x0 * 1 + 2);

  00608	6b 95 4c ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x0$26[ebp], 3
  0060f	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _cy4x0$25[ebp]
  00615	8d 4c 02 02	 lea	 ecx, DWORD PTR [edx+eax+2]
  00619	89 8d 34 ff ff
	ff		 mov	 DWORD PTR _cy3x0$20[ebp], ecx

; 647  :                     int cy1x1 = (cy0x1 * 1 + cy2x1 * 3 + 2);

  0061f	6b 95 40 ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x1$23[ebp], 3
  00626	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _cy0x1$24[ebp]
  0062c	8d 4c 10 02	 lea	 ecx, DWORD PTR [eax+edx+2]
  00630	89 8d 30 ff ff
	ff		 mov	 DWORD PTR _cy1x1$19[ebp], ecx

; 648  :                     int cy3x1 = (cy2x1 * 3 + cy4x1 * 1 + 2);

  00636	6b 95 40 ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x1$23[ebp], 3
  0063d	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _cy4x1$22[ebp]
  00643	8d 4c 02 02	 lea	 ecx, DWORD PTR [edx+eax+2]
  00647	89 8d 2c ff ff
	ff		 mov	 DWORD PTR _cy3x1$18[ebp], ecx

; 649  :                     CHANGE_BIT_DEPTH_4(cy1x0, cy3x0, cy1x1, cy3x1, 2);

  0064d	33 d2		 xor	 edx, edx
  0064f	74 3e		 je	 SHORT $LN37@convert_yv
  00651	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x0$21[ebp]
  00657	c1 e0 fe	 shl	 eax, -2			; fffffffeH
  0065a	89 85 38 ff ff
	ff		 mov	 DWORD PTR _cy1x0$21[ebp], eax
  00660	8b 8d 34 ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x0$20[ebp]
  00666	c1 e1 fe	 shl	 ecx, -2			; fffffffeH
  00669	89 8d 34 ff ff
	ff		 mov	 DWORD PTR _cy3x0$20[ebp], ecx
  0066f	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x1$19[ebp]
  00675	c1 e2 fe	 shl	 edx, -2			; fffffffeH
  00678	89 95 30 ff ff
	ff		 mov	 DWORD PTR _cy1x1$19[ebp], edx
  0067e	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR _cy3x1$18[ebp]
  00684	c1 e0 fe	 shl	 eax, -2			; fffffffeH
  00687	89 85 2c ff ff
	ff		 mov	 DWORD PTR _cy3x1$18[ebp], eax
  0068d	eb 45		 jmp	 SHORT $LN38@convert_yv
$LN37@convert_yv:
  0068f	b9 01 00 00 00	 mov	 ecx, 1
  00694	85 c9		 test	 ecx, ecx
  00696	74 3c		 je	 SHORT $LN38@convert_yv
  00698	8b 95 38 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x0$21[ebp]
  0069e	c1 fa 02	 sar	 edx, 2
  006a1	89 95 38 ff ff
	ff		 mov	 DWORD PTR _cy1x0$21[ebp], edx
  006a7	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$20[ebp]
  006ad	c1 f8 02	 sar	 eax, 2
  006b0	89 85 34 ff ff
	ff		 mov	 DWORD PTR _cy3x0$20[ebp], eax
  006b6	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x1$19[ebp]
  006bc	c1 f9 02	 sar	 ecx, 2
  006bf	89 8d 30 ff ff
	ff		 mov	 DWORD PTR _cy1x1$19[ebp], ecx
  006c5	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR _cy3x1$18[ebp]
  006cb	c1 fa 02	 sar	 edx, 2
  006ce	89 95 2c ff ff
	ff		 mov	 DWORD PTR _cy3x1$18[ebp], edx
$LN38@convert_yv:

; 650  : 
; 651  :                     dstC[0*dst_y_pitch   + 0] = (Tout)cy1x0;

  006d4	6b 45 e4 00	 imul	 eax, DWORD PTR _dst_y_pitch$[ebp], 0
  006d8	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$44[ebp]
  006db	66 8b 95 38 ff
	ff ff		 mov	 dx, WORD PTR _cy1x0$21[ebp]
  006e2	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx

; 652  :                     dstC[0*dst_y_pitch   + 1] = (Tout)((cy1x0 + cy1x1 + 1) >> 1);

  006e6	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x1$19[ebp]
  006ec	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x0$21[ebp]
  006f2	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  006f6	d1 fa		 sar	 edx, 1
  006f8	6b 45 e4 00	 imul	 eax, DWORD PTR _dst_y_pitch$[ebp], 0
  006fc	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$44[ebp]
  006ff	66 89 54 41 02	 mov	 WORD PTR [ecx+eax*2+2], dx

; 653  :                     dstC[1*dst_y_pitch   + 0] = (Tout)cy3x0;

  00704	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  00707	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  0070a	66 8b 8d 34 ff
	ff ff		 mov	 cx, WORD PTR _cy3x0$20[ebp]
  00711	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx

; 654  :                     dstC[1*dst_y_pitch   + 1] = (Tout)((cy3x0 + cy3x1 + 1) >> 1);

  00715	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR _cy3x1$18[ebp]
  0071b	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$20[ebp]
  00721	8d 4c 10 01	 lea	 ecx, DWORD PTR [eax+edx+1]
  00725	d1 f9		 sar	 ecx, 1
  00727	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  0072a	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  0072d	66 89 4c 50 02	 mov	 WORD PTR [eax+edx*2+2], cx

; 655  :                 }

  00732	e9 e2 fd ff ff	 jmp	 $LN17@convert_yv
$LN18@convert_yv:

; 656  :             } else {

  00737	e9 28 02 00 00	 jmp	 $LN31@convert_yv
$LN35@convert_yv:

; 657  :                 for (int x = 0; x < x_fin; x += 2, dstC += 2, srcP++) {

  0073c	c7 85 28 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _x$17[ebp], 0
  00746	eb 21		 jmp	 SHORT $LN22@convert_yv
$LN20@convert_yv:
  00748	8b 8d 28 ff ff
	ff		 mov	 ecx, DWORD PTR _x$17[ebp]
  0074e	83 c1 02	 add	 ecx, 2
  00751	89 8d 28 ff ff
	ff		 mov	 DWORD PTR _x$17[ebp], ecx
  00757	8b 55 94	 mov	 edx, DWORD PTR _dstC$44[ebp]
  0075a	83 c2 04	 add	 edx, 4
  0075d	89 55 94	 mov	 DWORD PTR _dstC$44[ebp], edx
  00760	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  00763	83 c0 02	 add	 eax, 2
  00766	89 45 90	 mov	 DWORD PTR _srcP$43[ebp], eax
$LN22@convert_yv:
  00769	8b 8d 28 ff ff
	ff		 mov	 ecx, DWORD PTR _x$17[ebp]
  0076f	3b 4d 8c	 cmp	 ecx, DWORD PTR _x_fin$42[ebp]
  00772	0f 8d ec 01 00
	00		 jge	 $LN31@convert_yv

; 658  :                     int cxplus = (x + 2 < x_fin);

  00778	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR _x$17[ebp]
  0077e	83 c2 02	 add	 edx, 2
  00781	3b 55 8c	 cmp	 edx, DWORD PTR _x_fin$42[ebp]
  00784	7d 0c		 jge	 SHORT $LN48@convert_yv
  00786	c7 85 d4 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv432[ebp], 1
  00790	eb 0a		 jmp	 SHORT $LN49@convert_yv
$LN48@convert_yv:
  00792	c7 85 d4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv432[ebp], 0
$LN49@convert_yv:
  0079c	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR tv432[ebp]
  007a2	89 85 24 ff ff
	ff		 mov	 DWORD PTR _cxplus$16[ebp], eax

; 659  :                     int cy0x0 = srcP[-1*src_uv_pitch + 0];

  007a8	6b 4d a8 ff	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], -1
  007ac	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  007af	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  007b3	89 85 20 ff ff
	ff		 mov	 DWORD PTR _cy0x0$15[ebp], eax

; 660  :                     int cy2x0 = srcP[ 0*src_uv_pitch + 0];

  007b9	6b 4d a8 00	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 0
  007bd	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  007c0	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  007c4	89 85 1c ff ff
	ff		 mov	 DWORD PTR _cy2x0$14[ebp], eax

; 661  :                     int cy4x0 = srcP[ 1*src_uv_pitch + 0];

  007ca	8b 4d a8	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  007cd	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  007d0	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  007d4	89 85 18 ff ff
	ff		 mov	 DWORD PTR _cy4x0$13[ebp], eax

; 662  :                     int cy0x1 = srcP[-1*src_uv_pitch + cxplus];

  007da	6b 4d a8 ff	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], -1
  007de	03 8d 24 ff ff
	ff		 add	 ecx, DWORD PTR _cxplus$16[ebp]
  007e4	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  007e7	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  007eb	89 85 14 ff ff
	ff		 mov	 DWORD PTR _cy0x1$12[ebp], eax

; 663  :                     int cy2x1 = srcP[ 0*src_uv_pitch + cxplus];

  007f1	6b 4d a8 00	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 0
  007f5	03 8d 24 ff ff
	ff		 add	 ecx, DWORD PTR _cxplus$16[ebp]
  007fb	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  007fe	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00802	89 85 10 ff ff
	ff		 mov	 DWORD PTR _cy2x1$11[ebp], eax

; 664  :                     int cy4x1 = srcP[ 1*src_uv_pitch + cxplus];

  00808	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR _cxplus$16[ebp]
  0080e	03 4d a8	 add	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00811	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  00814	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00818	89 85 0c ff ff
	ff		 mov	 DWORD PTR _cy4x1$10[ebp], eax

; 665  : 
; 666  :                     int cy1x0 = (cy0x0 * 1 + cy2x0 * 3 + 2);

  0081e	6b 8d 1c ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy2x0$14[ebp], 3
  00825	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR _cy0x0$15[ebp]
  0082b	8d 44 0a 02	 lea	 eax, DWORD PTR [edx+ecx+2]
  0082f	89 85 08 ff ff
	ff		 mov	 DWORD PTR _cy1x0$9[ebp], eax

; 667  :                     int cy3x0 = (cy2x0 * 3 + cy4x0 * 1 + 2);

  00835	6b 8d 1c ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy2x0$14[ebp], 3
  0083c	8b 95 18 ff ff
	ff		 mov	 edx, DWORD PTR _cy4x0$13[ebp]
  00842	8d 44 11 02	 lea	 eax, DWORD PTR [ecx+edx+2]
  00846	89 85 04 ff ff
	ff		 mov	 DWORD PTR _cy3x0$8[ebp], eax

; 668  :                     int cy1x1 = (cy0x1 * 1 + cy2x1 * 3 + 2);

  0084c	6b 8d 10 ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy2x1$11[ebp], 3
  00853	8b 95 14 ff ff
	ff		 mov	 edx, DWORD PTR _cy0x1$12[ebp]
  00859	8d 44 0a 02	 lea	 eax, DWORD PTR [edx+ecx+2]
  0085d	89 85 00 ff ff
	ff		 mov	 DWORD PTR _cy1x1$7[ebp], eax

; 669  :                     int cy3x1 = (cy2x1 * 3 + cy4x1 * 1 + 2);

  00863	6b 8d 10 ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy2x1$11[ebp], 3
  0086a	8b 95 0c ff ff
	ff		 mov	 edx, DWORD PTR _cy4x1$10[ebp]
  00870	8d 44 11 02	 lea	 eax, DWORD PTR [ecx+edx+2]
  00874	89 85 fc fe ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], eax

; 670  :                     CHANGE_BIT_DEPTH_4(cy1x0, cy3x0, cy1x1, cy3x1, 2);

  0087a	33 c9		 xor	 ecx, ecx
  0087c	74 3e		 je	 SHORT $LN40@convert_yv
  0087e	8b 95 08 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x0$9[ebp]
  00884	c1 e2 fe	 shl	 edx, -2			; fffffffeH
  00887	89 95 08 ff ff
	ff		 mov	 DWORD PTR _cy1x0$9[ebp], edx
  0088d	8b 85 04 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$8[ebp]
  00893	c1 e0 fe	 shl	 eax, -2			; fffffffeH
  00896	89 85 04 ff ff
	ff		 mov	 DWORD PTR _cy3x0$8[ebp], eax
  0089c	8b 8d 00 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x1$7[ebp]
  008a2	c1 e1 fe	 shl	 ecx, -2			; fffffffeH
  008a5	89 8d 00 ff ff
	ff		 mov	 DWORD PTR _cy1x1$7[ebp], ecx
  008ab	8b 95 fc fe ff
	ff		 mov	 edx, DWORD PTR _cy3x1$6[ebp]
  008b1	c1 e2 fe	 shl	 edx, -2			; fffffffeH
  008b4	89 95 fc fe ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], edx
  008ba	eb 45		 jmp	 SHORT $LN41@convert_yv
$LN40@convert_yv:
  008bc	b8 01 00 00 00	 mov	 eax, 1
  008c1	85 c0		 test	 eax, eax
  008c3	74 3c		 je	 SHORT $LN41@convert_yv
  008c5	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x0$9[ebp]
  008cb	c1 f9 02	 sar	 ecx, 2
  008ce	89 8d 08 ff ff
	ff		 mov	 DWORD PTR _cy1x0$9[ebp], ecx
  008d4	8b 95 04 ff ff
	ff		 mov	 edx, DWORD PTR _cy3x0$8[ebp]
  008da	c1 fa 02	 sar	 edx, 2
  008dd	89 95 04 ff ff
	ff		 mov	 DWORD PTR _cy3x0$8[ebp], edx
  008e3	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x1$7[ebp]
  008e9	c1 f8 02	 sar	 eax, 2
  008ec	89 85 00 ff ff
	ff		 mov	 DWORD PTR _cy1x1$7[ebp], eax
  008f2	8b 8d fc fe ff
	ff		 mov	 ecx, DWORD PTR _cy3x1$6[ebp]
  008f8	c1 f9 02	 sar	 ecx, 2
  008fb	89 8d fc fe ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], ecx
$LN41@convert_yv:

; 671  : 
; 672  :                     dstC[0*dst_y_pitch   + 0] = (Tout)cy1x0;

  00901	6b 55 e4 00	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 0
  00905	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  00908	66 8b 8d 08 ff
	ff ff		 mov	 cx, WORD PTR _cy1x0$9[ebp]
  0090f	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx

; 673  :                     dstC[0*dst_y_pitch   + 1] = (Tout)((cy1x0 + cy1x1 + 1) >> 1);

  00913	8b 95 00 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x1$7[ebp]
  00919	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x0$9[ebp]
  0091f	8d 4c 10 01	 lea	 ecx, DWORD PTR [eax+edx+1]
  00923	d1 f9		 sar	 ecx, 1
  00925	6b 55 e4 00	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 0
  00929	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  0092c	66 89 4c 50 02	 mov	 WORD PTR [eax+edx*2+2], cx

; 674  :                     dstC[1*dst_y_pitch   + 0] = (Tout)cy3x0;

  00931	8b 4d e4	 mov	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  00934	8b 55 94	 mov	 edx, DWORD PTR _dstC$44[ebp]
  00937	66 8b 85 04 ff
	ff ff		 mov	 ax, WORD PTR _cy3x0$8[ebp]
  0093e	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax

; 675  :                     dstC[1*dst_y_pitch   + 1] = (Tout)((cy3x0 + cy3x1 + 1) >> 1);

  00942	8b 8d fc fe ff
	ff		 mov	 ecx, DWORD PTR _cy3x1$6[ebp]
  00948	8b 95 04 ff ff
	ff		 mov	 edx, DWORD PTR _cy3x0$8[ebp]
  0094e	8d 44 0a 01	 lea	 eax, DWORD PTR [edx+ecx+1]
  00952	d1 f8		 sar	 eax, 1
  00954	8b 4d e4	 mov	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  00957	8b 55 94	 mov	 edx, DWORD PTR _dstC$44[ebp]
  0095a	66 89 44 4a 02	 mov	 WORD PTR [edx+ecx*2+2], ax

; 676  :                 }

  0095f	e9 e4 fd ff ff	 jmp	 $LN20@convert_yv
$LN31@convert_yv:

; 677  :             }
; 678  :         }

  00964	e9 38 f9 ff ff	 jmp	 $LN11@convert_yv
$LN12@convert_yv:

; 679  :     }

  00969	e9 e6 f8 ff ff	 jmp	 $LN8@convert_yv
$LN1@convert_yv:

; 680  : }

  0096e	52		 push	 edx
  0096f	8b cd		 mov	 ecx, ebp
  00971	50		 push	 eax
  00972	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN52@convert_yv
  00978	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0097d	58		 pop	 eax
  0097e	5a		 pop	 edx
  0097f	5f		 pop	 edi
  00980	5e		 pop	 esi
  00981	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00984	33 cd		 xor	 ecx, ebp
  00986	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0098b	81 c4 2c 01 00
	00		 add	 esp, 300		; 0000012cH
  00991	3b ec		 cmp	 ebp, esp
  00993	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00998	8b e5		 mov	 esp, ebp
  0099a	5d		 pop	 ebp
  0099b	c3		 ret	 0
$LN52@convert_yv:
  0099c	01 00 00 00	 DD	 1
  009a0	00 00 00 00	 DD	 $LN51@convert_yv
$LN51@convert_yv:
  009a4	d4 ff ff ff	 DD	 -44			; ffffffd4H
  009a8	0c 00 00 00	 DD	 12			; 0000000cH
  009ac	00 00 00 00	 DD	 $LN50@convert_yv
$LN50@convert_yv:
  009b0	79		 DB	 121			; 00000079H
  009b1	5f		 DB	 95			; 0000005fH
  009b2	72		 DB	 114			; 00000072H
  009b3	61		 DB	 97			; 00000061H
  009b4	6e		 DB	 110			; 0000006eH
  009b5	67		 DB	 103			; 00000067H
  009b6	65		 DB	 101			; 00000065H
  009b7	00		 DB	 0
??$convert_yv12_p_to_yuv444_c@G$0BA@G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_p_to_yuv444_c<unsigned short,16,unsigned short,16,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yv12_16_p_to_yuv444_16bit@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_16_p_to_yuv444_16bit

; 833  : static void convert_yv12_16_p_to_yuv444_16bit(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 834  :     convert_yv12_p_to_yuv444_c<uint16_t, 16, uint16_t, 16, false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yv12_p_to_yuv444_c@G$0BA@G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_p_to_yuv444_c<unsigned short,16,unsigned short,16,0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 835  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yv12_16_p_to_yuv444_16bit@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_16_p_to_yuv444_16bit
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
tv297 = -280						; size = 4
tv235 = -276						; size = 4
tv236 = -272						; size = 4
tv230 = -268						; size = 4
tv227 = -264						; size = 4
tv224 = -260						; size = 4
tv222 = -256						; size = 4
$T1 = -252						; size = 4
$T2 = -248						; size = 4
$T3 = -244						; size = 4
$T4 = -240						; size = 4
$T5 = -236						; size = 12
_cy3x1$6 = -224						; size = 4
_cy2x1$7 = -220						; size = 4
_cy1x1$8 = -216						; size = 4
_cy0x1$9 = -212						; size = 4
_sy5x1$10 = -208					; size = 4
_sy4x1$11 = -204					; size = 4
_sy3x1$12 = -200					; size = 4
_sy2x1$13 = -196					; size = 4
_sy1x1$14 = -192					; size = 4
_sy0x1$15 = -188					; size = 4
_cxplus$16 = -184					; size = 4
_x$17 = -180						; size = 4
_cy3x0$18 = -176					; size = 4
_cy2x0$19 = -172					; size = 4
_cy1x0$20 = -168					; size = 4
_cy0x0$21 = -164					; size = 4
_sy5x0$22 = -160					; size = 4
_sy4x0$23 = -156					; size = 4
_sy3x0$24 = -152					; size = 4
_sy2x0$25 = -148					; size = 4
_sy1x0$26 = -144					; size = 4
_sy0x0$27 = -140					; size = 4
_y_p3$28 = -136						; size = 4
_y_p2$29 = -132						; size = 4
_y_p1$30 = -128						; size = 4
_y_m1$31 = -124						; size = 4
_y_m2$32 = -120						; size = 4
_x_fin$33 = -116					; size = 4
_srcP$34 = -112						; size = 4
_dstC$35 = -108						; size = 4
_y$36 = -104						; size = 4
_dstLine$37 = -100					; size = 4
_srcCLine$38 = -96					; size = 4
_ic$39 = -92						; size = 4
_src_uv_pitch$ = -88					; size = 4
_uv_fin$ = -84						; size = 4
_x$40 = -80						; size = 4
_y$41 = -76						; size = 4
_y_width$42 = -72					; size = 4
_dstLine$43 = -68					; size = 4
_srcYLine$44 = -64					; size = 4
$T45 = -60						; size = 12
_y_range$ = -44						; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yv12_i_to_yuv444_c@G$08E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_i_to_yuv444_c<unsigned short,9,unsigned char,8,0>

; 683  : static void __forceinline convert_yv12_i_to_yuv444_c(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  00009	53		 push	 ebx
  0000a	57		 push	 edi
  0000b	8d bd e8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-280]
  00011	b9 46 00 00 00	 mov	 ecx, 70			; 00000046H
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 684  :     static_assert((sizeof(Tin)  == 1 && in_bit_depth  == 8) || (sizeof(Tin)  == 2 && 8 < in_bit_depth  && in_bit_depth  <= 16), "invalid input bit depth.");
; 685  :     static_assert((sizeof(Tout) == 1 && out_bit_depth == 8) || (sizeof(Tout) == 2 && 8 < out_bit_depth && out_bit_depth <= 16), "invalid output bit depth.");
; 686  :     const int crop_left   = crop[0];

  00027	b8 04 00 00 00	 mov	 eax, 4
  0002c	6b c8 00	 imul	 ecx, eax, 0
  0002f	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00032	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00035	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 687  :     const int crop_up     = crop[1];

  00038	b9 04 00 00 00	 mov	 ecx, 4
  0003d	c1 e1 00	 shl	 ecx, 0
  00040	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00043	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00046	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 688  :     const int crop_right  = crop[2];

  00049	b9 04 00 00 00	 mov	 ecx, 4
  0004e	d1 e1		 shl	 ecx, 1
  00050	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00053	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00056	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 689  :     const int crop_bottom = crop[3];

  00059	b9 04 00 00 00	 mov	 ecx, 4
  0005e	6b d1 03	 imul	 edx, ecx, 3
  00061	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00064	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00067	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 690  :     const int src_y_pitch = src_y_pitch_byte / sizeof(Tin);

  0006a	8b 55 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebp]
  0006d	d1 ea		 shr	 edx, 1
  0006f	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 691  :     const int dst_y_pitch = dst_y_pitch_byte / sizeof(Tout);

  00072	8b 45 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  00075	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 692  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00078	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0007b	51		 push	 ecx
  0007c	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0007f	52		 push	 edx
  00080	8b 45 20	 mov	 eax, DWORD PTR _height$[ebp]
  00083	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  00086	50		 push	 eax
  00087	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  0008a	51		 push	 ecx
  0008b	8d 95 14 ff ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  00091	52		 push	 edx
  00092	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00097	83 c4 14	 add	 esp, 20			; 00000014H
  0009a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009c	89 4d c4	 mov	 DWORD PTR $T45[ebp], ecx
  0009f	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a2	89 55 c8	 mov	 DWORD PTR $T45[ebp+4], edx
  000a5	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000a8	89 45 cc	 mov	 DWORD PTR $T45[ebp+8], eax
  000ab	8b 4d c4	 mov	 ecx, DWORD PTR $T45[ebp]
  000ae	89 4d d4	 mov	 DWORD PTR _y_range$[ebp], ecx
  000b1	8b 55 c8	 mov	 edx, DWORD PTR $T45[ebp+4]
  000b4	89 55 d8	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000b7	8b 45 cc	 mov	 eax, DWORD PTR $T45[ebp+8]
  000ba	89 45 dc	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 693  :     //Y
; 694  :     if (!uv_only) {

  000bd	b9 01 00 00 00	 mov	 ecx, 1
  000c2	85 c9		 test	 ecx, ecx
  000c4	0f 84 61 01 00
	00		 je	 $LN17@convert_yv

; 695  :         Tin *srcYLine = (Tin *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000ca	ba 04 00 00 00	 mov	 edx, 4
  000cf	6b c2 00	 imul	 eax, edx, 0
  000d2	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  000d5	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  000d9	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  000dc	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  000df	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  000e2	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  000e5	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  000e8	89 45 c0	 mov	 DWORD PTR _srcYLine$44[ebp], eax

; 696  :         Tout *dstLine = (Tout *)dst[0] + dst_y_pitch * y_range.start_dst;

  000eb	b9 04 00 00 00	 mov	 ecx, 4
  000f0	6b d1 00	 imul	 edx, ecx, 0
  000f3	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  000f6	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  000fa	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  000fd	03 04 11	 add	 eax, DWORD PTR [ecx+edx]
  00100	89 45 bc	 mov	 DWORD PTR _dstLine$43[ebp], eax

; 697  :         const int y_width = width - crop_right - crop_left;

  00103	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00106	2b 55 f0	 sub	 edx, DWORD PTR _crop_right$[ebp]
  00109	2b 55 f8	 sub	 edx, DWORD PTR _crop_left$[ebp]
  0010c	89 55 b8	 mov	 DWORD PTR _y_width$42[ebp], edx

; 698  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  0010f	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _y$41[ebp], 0
  00116	eb 1e		 jmp	 SHORT $LN4@convert_yv
$LN2@convert_yv:
  00118	8b 45 b4	 mov	 eax, DWORD PTR _y$41[ebp]
  0011b	83 c0 01	 add	 eax, 1
  0011e	89 45 b4	 mov	 DWORD PTR _y$41[ebp], eax
  00121	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  00124	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$44[ebp]
  00127	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  0012a	89 45 c0	 mov	 DWORD PTR _srcYLine$44[ebp], eax
  0012d	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$43[ebp]
  00130	03 4d e4	 add	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  00133	89 4d bc	 mov	 DWORD PTR _dstLine$43[ebp], ecx
$LN4@convert_yv:
  00136	8b 55 b4	 mov	 edx, DWORD PTR _y$41[ebp]
  00139	3b 55 dc	 cmp	 edx, DWORD PTR _y_range$[ebp+8]
  0013c	0f 8d e9 00 00
	00		 jge	 $LN17@convert_yv

; 699  :             if (in_bit_depth == out_bit_depth) {

  00142	33 c0		 xor	 eax, eax
  00144	74 1b		 je	 SHORT $LN18@convert_yv

; 700  :                 memcpy(dstLine, srcYLine, y_width * sizeof(Tin));

  00146	8b 4d b8	 mov	 ecx, DWORD PTR _y_width$42[ebp]
  00149	d1 e1		 shl	 ecx, 1
  0014b	51		 push	 ecx
  0014c	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$44[ebp]
  0014f	52		 push	 edx
  00150	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$43[ebp]
  00153	50		 push	 eax
  00154	e8 00 00 00 00	 call	 _memcpy
  00159	83 c4 0c	 add	 esp, 12			; 0000000cH

; 701  :             } else {

  0015c	e9 c5 00 00 00	 jmp	 $LN19@convert_yv
$LN18@convert_yv:

; 702  :                 for (int x = 0; x < y_width; x++) {

  00161	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _x$40[ebp], 0
  00168	eb 09		 jmp	 SHORT $LN7@convert_yv
$LN5@convert_yv:
  0016a	8b 4d b0	 mov	 ecx, DWORD PTR _x$40[ebp]
  0016d	83 c1 01	 add	 ecx, 1
  00170	89 4d b0	 mov	 DWORD PTR _x$40[ebp], ecx
$LN7@convert_yv:
  00173	8b 55 b0	 mov	 edx, DWORD PTR _x$40[ebp]
  00176	3b 55 b8	 cmp	 edx, DWORD PTR _y_width$42[ebp]
  00179	0f 8d a7 00 00
	00		 jge	 $LN19@convert_yv

; 703  :                     if (out_bit_depth > in_bit_depth) {

  0017f	33 c0		 xor	 eax, eax
  00181	74 42		 je	 SHORT $LN20@convert_yv

; 704  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) << std::max(out_bit_depth - in_bit_depth, 0));

  00183	c7 85 10 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], 0
  0018d	c7 85 0c ff ff
	ff ff ff ff ff	 mov	 DWORD PTR $T3[ebp], -1
  00197	8b 4d b0	 mov	 ecx, DWORD PTR _x$40[ebp]
  0019a	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$44[ebp]
  0019d	0f b7 1c 4a	 movzx	 ebx, WORD PTR [edx+ecx*2]
  001a1	8d 85 10 ff ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  001a7	50		 push	 eax
  001a8	8d 8d 0c ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  001ae	51		 push	 ecx
  001af	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  001b4	83 c4 08	 add	 esp, 8
  001b7	8b 08		 mov	 ecx, DWORD PTR [eax]
  001b9	d3 e3		 shl	 ebx, cl
  001bb	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$43[ebp]
  001be	03 55 b0	 add	 edx, DWORD PTR _x$40[ebp]
  001c1	88 1a		 mov	 BYTE PTR [edx], bl
  001c3	eb 5c		 jmp	 SHORT $LN21@convert_yv
$LN20@convert_yv:

; 705  :                     } else if (out_bit_depth < in_bit_depth) {

  001c5	b8 01 00 00 00	 mov	 eax, 1
  001ca	85 c0		 test	 eax, eax
  001cc	74 42		 je	 SHORT $LN22@convert_yv

; 706  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) >> std::max(in_bit_depth - out_bit_depth, 0));

  001ce	c7 85 08 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], 0
  001d8	c7 85 04 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR $T1[ebp], 1
  001e2	8b 4d b0	 mov	 ecx, DWORD PTR _x$40[ebp]
  001e5	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$44[ebp]
  001e8	0f b7 1c 4a	 movzx	 ebx, WORD PTR [edx+ecx*2]
  001ec	8d 85 08 ff ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  001f2	50		 push	 eax
  001f3	8d 8d 04 ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  001f9	51		 push	 ecx
  001fa	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  001ff	83 c4 08	 add	 esp, 8
  00202	8b 08		 mov	 ecx, DWORD PTR [eax]
  00204	d3 fb		 sar	 ebx, cl
  00206	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$43[ebp]
  00209	03 55 b0	 add	 edx, DWORD PTR _x$40[ebp]
  0020c	88 1a		 mov	 BYTE PTR [edx], bl

; 707  :                     } else {

  0020e	eb 11		 jmp	 SHORT $LN21@convert_yv
$LN22@convert_yv:

; 708  :                         dstLine[x] = (Tout)srcYLine[x];

  00210	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$43[ebp]
  00213	03 45 b0	 add	 eax, DWORD PTR _x$40[ebp]
  00216	8b 4d b0	 mov	 ecx, DWORD PTR _x$40[ebp]
  00219	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$44[ebp]
  0021c	8a 0c 4a	 mov	 cl, BYTE PTR [edx+ecx*2]
  0021f	88 08		 mov	 BYTE PTR [eax], cl
$LN21@convert_yv:

; 709  :                     }
; 710  :                 }

  00221	e9 44 ff ff ff	 jmp	 $LN5@convert_yv
$LN19@convert_yv:

; 711  :             }
; 712  :         }

  00226	e9 ed fe ff ff	 jmp	 $LN2@convert_yv
$LN17@convert_yv:

; 713  :     }
; 714  :     //UV
; 715  :     const int uv_fin = height - crop_bottom;

  0022b	8b 55 20	 mov	 edx, DWORD PTR _height$[ebp]
  0022e	2b 55 ec	 sub	 edx, DWORD PTR _crop_bottom$[ebp]
  00231	89 55 ac	 mov	 DWORD PTR _uv_fin$[ebp], edx

; 716  :     const int src_uv_pitch = src_uv_pitch_byte / sizeof(Tin);

  00234	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  00237	d1 e8		 shr	 eax, 1
  00239	89 45 a8	 mov	 DWORD PTR _src_uv_pitch$[ebp], eax

; 717  :     for (int ic = 1; ic < 3; ic++) {

  0023c	c7 45 a4 01 00
	00 00		 mov	 DWORD PTR _ic$39[ebp], 1
  00243	eb 09		 jmp	 SHORT $LN10@convert_yv
$LN8@convert_yv:
  00245	8b 4d a4	 mov	 ecx, DWORD PTR _ic$39[ebp]
  00248	83 c1 01	 add	 ecx, 1
  0024b	89 4d a4	 mov	 DWORD PTR _ic$39[ebp], ecx
$LN10@convert_yv:
  0024e	83 7d a4 03	 cmp	 DWORD PTR _ic$39[ebp], 3
  00252	0f 8d ac 05 00
	00		 jge	 $LN1@convert_yv

; 718  :         Tin *srcCLine = (Tin *)src[ic] + (((src_uv_pitch * y_range.start_src) + crop_left) >> 1);

  00258	8b 55 a8	 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  0025b	0f af 55 d4	 imul	 edx, DWORD PTR _y_range$[ebp]
  0025f	03 55 f8	 add	 edx, DWORD PTR _crop_left$[ebp]
  00262	d1 fa		 sar	 edx, 1
  00264	8b 45 a4	 mov	 eax, DWORD PTR _ic$39[ebp]
  00267	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  0026a	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  0026d	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00270	89 4d a0	 mov	 DWORD PTR _srcCLine$38[ebp], ecx

; 719  :         Tout *dstLine = (Tout *)dst[ic] + dst_y_pitch * y_range.start_dst;

  00273	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  00276	0f af 55 d8	 imul	 edx, DWORD PTR _y_range$[ebp+4]
  0027a	8b 45 a4	 mov	 eax, DWORD PTR _ic$39[ebp]
  0027d	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  00280	03 14 81	 add	 edx, DWORD PTR [ecx+eax*4]
  00283	89 55 9c	 mov	 DWORD PTR _dstLine$37[ebp], edx

; 720  :         for (int y = 0; y < y_range.len; y += 4, srcCLine += src_uv_pitch * 2, dstLine += dst_y_pitch * 4) {

  00286	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _y$36[ebp], 0
  0028d	eb 23		 jmp	 SHORT $LN13@convert_yv
$LN11@convert_yv:
  0028f	8b 55 98	 mov	 edx, DWORD PTR _y$36[ebp]
  00292	83 c2 04	 add	 edx, 4
  00295	89 55 98	 mov	 DWORD PTR _y$36[ebp], edx
  00298	8b 45 a8	 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  0029b	d1 e0		 shl	 eax, 1
  0029d	8b 4d a0	 mov	 ecx, DWORD PTR _srcCLine$38[ebp]
  002a0	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  002a3	89 55 a0	 mov	 DWORD PTR _srcCLine$38[ebp], edx
  002a6	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  002a9	8b 4d 9c	 mov	 ecx, DWORD PTR _dstLine$37[ebp]
  002ac	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  002af	89 55 9c	 mov	 DWORD PTR _dstLine$37[ebp], edx
$LN13@convert_yv:
  002b2	8b 45 98	 mov	 eax, DWORD PTR _y$36[ebp]
  002b5	3b 45 dc	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  002b8	0f 8d 41 05 00
	00		 jge	 $LN12@convert_yv

; 721  :             Tout *dstC = dstLine;

  002be	8b 4d 9c	 mov	 ecx, DWORD PTR _dstLine$37[ebp]
  002c1	89 4d 94	 mov	 DWORD PTR _dstC$35[ebp], ecx

; 722  :             Tin *srcP = srcCLine;

  002c4	8b 55 a0	 mov	 edx, DWORD PTR _srcCLine$38[ebp]
  002c7	89 55 90	 mov	 DWORD PTR _srcP$34[ebp], edx

; 723  :             const int x_fin = width - crop_right - crop_left;

  002ca	8b 45 10	 mov	 eax, DWORD PTR _width$[ebp]
  002cd	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  002d0	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  002d3	89 45 8c	 mov	 DWORD PTR _x_fin$33[ebp], eax

; 724  : 
; 725  :             int y_m2 = (y >= 4) ? -2 : 0;

  002d6	83 7d 98 04	 cmp	 DWORD PTR _y$36[ebp], 4
  002da	7c 0c		 jl	 SHORT $LN31@convert_yv
  002dc	c7 85 00 ff ff
	ff fe ff ff ff	 mov	 DWORD PTR tv222[ebp], -2 ; fffffffeH
  002e6	eb 0a		 jmp	 SHORT $LN32@convert_yv
$LN31@convert_yv:
  002e8	c7 85 00 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv222[ebp], 0
$LN32@convert_yv:
  002f2	8b 8d 00 ff ff
	ff		 mov	 ecx, DWORD PTR tv222[ebp]
  002f8	89 4d 88	 mov	 DWORD PTR _y_m2$32[ebp], ecx

; 726  :             int y_m1 = (y >= 2) ? -1 : 1;

  002fb	83 7d 98 02	 cmp	 DWORD PTR _y$36[ebp], 2
  002ff	7c 0c		 jl	 SHORT $LN33@convert_yv
  00301	c7 85 fc fe ff
	ff ff ff ff ff	 mov	 DWORD PTR tv224[ebp], -1
  0030b	eb 0a		 jmp	 SHORT $LN34@convert_yv
$LN33@convert_yv:
  0030d	c7 85 fc fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv224[ebp], 1
$LN34@convert_yv:
  00317	8b 95 fc fe ff
	ff		 mov	 edx, DWORD PTR tv224[ebp]
  0031d	89 55 84	 mov	 DWORD PTR _y_m1$31[ebp], edx

; 727  :             int y_p1 = (y < uv_fin - 2) ? 1 : -1;

  00320	8b 45 ac	 mov	 eax, DWORD PTR _uv_fin$[ebp]
  00323	83 e8 02	 sub	 eax, 2
  00326	39 45 98	 cmp	 DWORD PTR _y$36[ebp], eax
  00329	7d 0c		 jge	 SHORT $LN35@convert_yv
  0032b	c7 85 f8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv227[ebp], 1
  00335	eb 0a		 jmp	 SHORT $LN36@convert_yv
$LN35@convert_yv:
  00337	c7 85 f8 fe ff
	ff ff ff ff ff	 mov	 DWORD PTR tv227[ebp], -1
$LN36@convert_yv:
  00341	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR tv227[ebp]
  00347	89 4d 80	 mov	 DWORD PTR _y_p1$30[ebp], ecx

; 728  :             int y_p2 = (y < uv_fin - 4) ? 2 :  0;

  0034a	8b 55 ac	 mov	 edx, DWORD PTR _uv_fin$[ebp]
  0034d	83 ea 04	 sub	 edx, 4
  00350	39 55 98	 cmp	 DWORD PTR _y$36[ebp], edx
  00353	7d 0c		 jge	 SHORT $LN37@convert_yv
  00355	c7 85 f4 fe ff
	ff 02 00 00 00	 mov	 DWORD PTR tv230[ebp], 2
  0035f	eb 0a		 jmp	 SHORT $LN38@convert_yv
$LN37@convert_yv:
  00361	c7 85 f4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv230[ebp], 0
$LN38@convert_yv:
  0036b	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR tv230[ebp]
  00371	89 85 7c ff ff
	ff		 mov	 DWORD PTR _y_p2$29[ebp], eax

; 729  :             int y_p3 = (y < uv_fin - 6) ? 3 : ((y < uv_fin - 2) ? 1 : -1);

  00377	8b 4d ac	 mov	 ecx, DWORD PTR _uv_fin$[ebp]
  0037a	83 e9 06	 sub	 ecx, 6
  0037d	39 4d 98	 cmp	 DWORD PTR _y$36[ebp], ecx
  00380	7d 0c		 jge	 SHORT $LN41@convert_yv
  00382	c7 85 f0 fe ff
	ff 03 00 00 00	 mov	 DWORD PTR tv236[ebp], 3
  0038c	eb 2d		 jmp	 SHORT $LN42@convert_yv
$LN41@convert_yv:
  0038e	8b 55 ac	 mov	 edx, DWORD PTR _uv_fin$[ebp]
  00391	83 ea 02	 sub	 edx, 2
  00394	39 55 98	 cmp	 DWORD PTR _y$36[ebp], edx
  00397	7d 0c		 jge	 SHORT $LN39@convert_yv
  00399	c7 85 ec fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv235[ebp], 1
  003a3	eb 0a		 jmp	 SHORT $LN40@convert_yv
$LN39@convert_yv:
  003a5	c7 85 ec fe ff
	ff ff ff ff ff	 mov	 DWORD PTR tv235[ebp], -1
$LN40@convert_yv:
  003af	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR tv235[ebp]
  003b5	89 85 f0 fe ff
	ff		 mov	 DWORD PTR tv236[ebp], eax
$LN42@convert_yv:
  003bb	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR tv236[ebp]
  003c1	89 8d 78 ff ff
	ff		 mov	 DWORD PTR _y_p3$28[ebp], ecx

; 730  : 
; 731  :             int sy0x0 = srcP[y_m2*src_uv_pitch + 0];

  003c7	8b 55 88	 mov	 edx, DWORD PTR _y_m2$32[ebp]
  003ca	0f af 55 a8	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp]
  003ce	8b 45 90	 mov	 eax, DWORD PTR _srcP$34[ebp]
  003d1	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  003d5	89 8d 74 ff ff
	ff		 mov	 DWORD PTR _sy0x0$27[ebp], ecx

; 732  :             int sy1x0 = srcP[y_m1*src_uv_pitch + 0];

  003db	8b 55 84	 mov	 edx, DWORD PTR _y_m1$31[ebp]
  003de	0f af 55 a8	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp]
  003e2	8b 45 90	 mov	 eax, DWORD PTR _srcP$34[ebp]
  003e5	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  003e9	89 8d 70 ff ff
	ff		 mov	 DWORD PTR _sy1x0$26[ebp], ecx

; 733  :             int sy2x0 = srcP[   0*src_uv_pitch + 0];

  003ef	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  003f3	8b 45 90	 mov	 eax, DWORD PTR _srcP$34[ebp]
  003f6	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  003fa	89 8d 6c ff ff
	ff		 mov	 DWORD PTR _sy2x0$25[ebp], ecx

; 734  :             int sy3x0 = srcP[y_p1*src_uv_pitch + 0];

  00400	8b 55 80	 mov	 edx, DWORD PTR _y_p1$30[ebp]
  00403	0f af 55 a8	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp]
  00407	8b 45 90	 mov	 eax, DWORD PTR _srcP$34[ebp]
  0040a	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  0040e	89 8d 68 ff ff
	ff		 mov	 DWORD PTR _sy3x0$24[ebp], ecx

; 735  :             int sy4x0 = srcP[y_p2*src_uv_pitch + 0];

  00414	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR _y_p2$29[ebp]
  0041a	0f af 55 a8	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp]
  0041e	8b 45 90	 mov	 eax, DWORD PTR _srcP$34[ebp]
  00421	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  00425	89 8d 64 ff ff
	ff		 mov	 DWORD PTR _sy4x0$23[ebp], ecx

; 736  :             int sy5x0 = srcP[y_p3*src_uv_pitch + 0];

  0042b	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _y_p3$28[ebp]
  00431	0f af 55 a8	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp]
  00435	8b 45 90	 mov	 eax, DWORD PTR _srcP$34[ebp]
  00438	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  0043c	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _sy5x0$22[ebp], ecx

; 737  : 
; 738  :             int cy0x0 = (sy0x0 * 1 + sy2x0 * 7 + 4);

  00442	6b 95 6c ff ff
	ff 07		 imul	 edx, DWORD PTR _sy2x0$25[ebp], 7
  00449	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _sy0x0$27[ebp]
  0044f	8d 4c 10 04	 lea	 ecx, DWORD PTR [eax+edx+4]
  00453	89 8d 5c ff ff
	ff		 mov	 DWORD PTR _cy0x0$21[ebp], ecx

; 739  :             int cy1x0 = (sy1x0 * 3 + sy3x0 * 5 + 4);

  00459	6b 95 70 ff ff
	ff 03		 imul	 edx, DWORD PTR _sy1x0$26[ebp], 3
  00460	6b 85 68 ff ff
	ff 05		 imul	 eax, DWORD PTR _sy3x0$24[ebp], 5
  00467	8d 4c 02 04	 lea	 ecx, DWORD PTR [edx+eax+4]
  0046b	89 8d 58 ff ff
	ff		 mov	 DWORD PTR _cy1x0$20[ebp], ecx

; 740  :             int cy2x0 = (sy2x0 * 5 + sy4x0 * 3 + 4);

  00471	6b 95 6c ff ff
	ff 05		 imul	 edx, DWORD PTR _sy2x0$25[ebp], 5
  00478	6b 85 64 ff ff
	ff 03		 imul	 eax, DWORD PTR _sy4x0$23[ebp], 3
  0047f	8d 4c 02 04	 lea	 ecx, DWORD PTR [edx+eax+4]
  00483	89 8d 54 ff ff
	ff		 mov	 DWORD PTR _cy2x0$19[ebp], ecx

; 741  :             int cy3x0 = (sy3x0 * 7 + sy5x0 * 1 + 4);

  00489	6b 95 68 ff ff
	ff 07		 imul	 edx, DWORD PTR _sy3x0$24[ebp], 7
  00490	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _sy5x0$22[ebp]
  00496	8d 4c 02 04	 lea	 ecx, DWORD PTR [edx+eax+4]
  0049a	89 8d 50 ff ff
	ff		 mov	 DWORD PTR _cy3x0$18[ebp], ecx

; 742  :             CHANGE_BIT_DEPTH_4(cy0x0, cy1x0, cy2x0, cy3x0, 3);

  004a0	33 d2		 xor	 edx, edx
  004a2	74 3e		 je	 SHORT $LN24@convert_yv
  004a4	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _cy0x0$21[ebp]
  004aa	c1 e0 fc	 shl	 eax, -4			; fffffffcH
  004ad	89 85 5c ff ff
	ff		 mov	 DWORD PTR _cy0x0$21[ebp], eax
  004b3	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x0$20[ebp]
  004b9	c1 e1 fc	 shl	 ecx, -4			; fffffffcH
  004bc	89 8d 58 ff ff
	ff		 mov	 DWORD PTR _cy1x0$20[ebp], ecx
  004c2	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR _cy2x0$19[ebp]
  004c8	c1 e2 fc	 shl	 edx, -4			; fffffffcH
  004cb	89 95 54 ff ff
	ff		 mov	 DWORD PTR _cy2x0$19[ebp], edx
  004d1	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$18[ebp]
  004d7	c1 e0 fc	 shl	 eax, -4			; fffffffcH
  004da	89 85 50 ff ff
	ff		 mov	 DWORD PTR _cy3x0$18[ebp], eax
  004e0	eb 45		 jmp	 SHORT $LN25@convert_yv
$LN24@convert_yv:
  004e2	b9 01 00 00 00	 mov	 ecx, 1
  004e7	85 c9		 test	 ecx, ecx
  004e9	74 3c		 je	 SHORT $LN25@convert_yv
  004eb	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR _cy0x0$21[ebp]
  004f1	c1 fa 04	 sar	 edx, 4
  004f4	89 95 5c ff ff
	ff		 mov	 DWORD PTR _cy0x0$21[ebp], edx
  004fa	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x0$20[ebp]
  00500	c1 f8 04	 sar	 eax, 4
  00503	89 85 58 ff ff
	ff		 mov	 DWORD PTR _cy1x0$20[ebp], eax
  00509	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _cy2x0$19[ebp]
  0050f	c1 f9 04	 sar	 ecx, 4
  00512	89 8d 54 ff ff
	ff		 mov	 DWORD PTR _cy2x0$19[ebp], ecx
  00518	8b 95 50 ff ff
	ff		 mov	 edx, DWORD PTR _cy3x0$18[ebp]
  0051e	c1 fa 04	 sar	 edx, 4
  00521	89 95 50 ff ff
	ff		 mov	 DWORD PTR _cy3x0$18[ebp], edx
$LN25@convert_yv:

; 743  : 
; 744  :             for (int x = 0; x < x_fin; x += 2, dstC += 2, srcP++) {

  00527	c7 85 4c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _x$17[ebp], 0
  00531	eb 21		 jmp	 SHORT $LN16@convert_yv
$LN14@convert_yv:
  00533	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _x$17[ebp]
  00539	83 c0 02	 add	 eax, 2
  0053c	89 85 4c ff ff
	ff		 mov	 DWORD PTR _x$17[ebp], eax
  00542	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$35[ebp]
  00545	83 c1 02	 add	 ecx, 2
  00548	89 4d 94	 mov	 DWORD PTR _dstC$35[ebp], ecx
  0054b	8b 55 90	 mov	 edx, DWORD PTR _srcP$34[ebp]
  0054e	83 c2 02	 add	 edx, 2
  00551	89 55 90	 mov	 DWORD PTR _srcP$34[ebp], edx
$LN16@convert_yv:
  00554	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _x$17[ebp]
  0055a	3b 45 8c	 cmp	 eax, DWORD PTR _x_fin$33[ebp]
  0055d	0f 8d 97 02 00
	00		 jge	 $LN15@convert_yv

; 745  :                 int cxplus = (x + 2 < x_fin);

  00563	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _x$17[ebp]
  00569	83 c1 02	 add	 ecx, 2
  0056c	3b 4d 8c	 cmp	 ecx, DWORD PTR _x_fin$33[ebp]
  0056f	7d 0c		 jge	 SHORT $LN43@convert_yv
  00571	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv297[ebp], 1
  0057b	eb 0a		 jmp	 SHORT $LN44@convert_yv
$LN43@convert_yv:
  0057d	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv297[ebp], 0
$LN44@convert_yv:
  00587	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR tv297[ebp]
  0058d	89 95 48 ff ff
	ff		 mov	 DWORD PTR _cxplus$16[ebp], edx

; 746  :                 int sy0x1 = srcP[y_m2*src_uv_pitch + cxplus];

  00593	8b 45 88	 mov	 eax, DWORD PTR _y_m2$32[ebp]
  00596	0f af 45 a8	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp]
  0059a	03 85 48 ff ff
	ff		 add	 eax, DWORD PTR _cxplus$16[ebp]
  005a0	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  005a3	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  005a7	89 95 44 ff ff
	ff		 mov	 DWORD PTR _sy0x1$15[ebp], edx

; 747  :                 int sy1x1 = srcP[y_m1*src_uv_pitch + cxplus];

  005ad	8b 45 84	 mov	 eax, DWORD PTR _y_m1$31[ebp]
  005b0	0f af 45 a8	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp]
  005b4	03 85 48 ff ff
	ff		 add	 eax, DWORD PTR _cxplus$16[ebp]
  005ba	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  005bd	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  005c1	89 95 40 ff ff
	ff		 mov	 DWORD PTR _sy1x1$14[ebp], edx

; 748  :                 int sy2x1 = srcP[   0*src_uv_pitch + cxplus];

  005c7	6b 45 a8 00	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp], 0
  005cb	03 85 48 ff ff
	ff		 add	 eax, DWORD PTR _cxplus$16[ebp]
  005d1	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  005d4	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  005d8	89 95 3c ff ff
	ff		 mov	 DWORD PTR _sy2x1$13[ebp], edx

; 749  :                 int sy3x1 = srcP[y_p1*src_uv_pitch + cxplus];

  005de	8b 45 80	 mov	 eax, DWORD PTR _y_p1$30[ebp]
  005e1	0f af 45 a8	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp]
  005e5	03 85 48 ff ff
	ff		 add	 eax, DWORD PTR _cxplus$16[ebp]
  005eb	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  005ee	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  005f2	89 95 38 ff ff
	ff		 mov	 DWORD PTR _sy3x1$12[ebp], edx

; 750  :                 int sy4x1 = srcP[y_p2*src_uv_pitch + cxplus];

  005f8	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _y_p2$29[ebp]
  005fe	0f af 45 a8	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp]
  00602	03 85 48 ff ff
	ff		 add	 eax, DWORD PTR _cxplus$16[ebp]
  00608	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  0060b	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  0060f	89 95 34 ff ff
	ff		 mov	 DWORD PTR _sy4x1$11[ebp], edx

; 751  :                 int sy5x1 = srcP[y_p3*src_uv_pitch + cxplus];

  00615	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _y_p3$28[ebp]
  0061b	0f af 45 a8	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp]
  0061f	03 85 48 ff ff
	ff		 add	 eax, DWORD PTR _cxplus$16[ebp]
  00625	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  00628	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  0062c	89 95 30 ff ff
	ff		 mov	 DWORD PTR _sy5x1$10[ebp], edx

; 752  : 
; 753  :                 int cy0x1 = (sy0x1 * 1 + sy2x1 * 7 + 4);

  00632	6b 85 3c ff ff
	ff 07		 imul	 eax, DWORD PTR _sy2x1$13[ebp], 7
  00639	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _sy0x1$15[ebp]
  0063f	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00643	89 95 2c ff ff
	ff		 mov	 DWORD PTR _cy0x1$9[ebp], edx

; 754  :                 int cy1x1 = (sy1x1 * 3 + sy3x1 * 5 + 4);

  00649	6b 85 40 ff ff
	ff 03		 imul	 eax, DWORD PTR _sy1x1$14[ebp], 3
  00650	6b 8d 38 ff ff
	ff 05		 imul	 ecx, DWORD PTR _sy3x1$12[ebp], 5
  00657	8d 54 08 04	 lea	 edx, DWORD PTR [eax+ecx+4]
  0065b	89 95 28 ff ff
	ff		 mov	 DWORD PTR _cy1x1$8[ebp], edx

; 755  :                 int cy2x1 = (sy2x1 * 5 + sy4x1 * 3 + 4);

  00661	6b 85 3c ff ff
	ff 05		 imul	 eax, DWORD PTR _sy2x1$13[ebp], 5
  00668	6b 8d 34 ff ff
	ff 03		 imul	 ecx, DWORD PTR _sy4x1$11[ebp], 3
  0066f	8d 54 08 04	 lea	 edx, DWORD PTR [eax+ecx+4]
  00673	89 95 24 ff ff
	ff		 mov	 DWORD PTR _cy2x1$7[ebp], edx

; 756  :                 int cy3x1 = (sy3x1 * 7 + sy5x1 * 1 + 4);

  00679	6b 85 38 ff ff
	ff 07		 imul	 eax, DWORD PTR _sy3x1$12[ebp], 7
  00680	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR _sy5x1$10[ebp]
  00686	8d 54 08 04	 lea	 edx, DWORD PTR [eax+ecx+4]
  0068a	89 95 20 ff ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], edx

; 757  :                 CHANGE_BIT_DEPTH_4(cy0x1, cy1x1, cy2x1, cy3x1, 3);

  00690	33 c0		 xor	 eax, eax
  00692	74 3e		 je	 SHORT $LN27@convert_yv
  00694	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR _cy0x1$9[ebp]
  0069a	c1 e1 fc	 shl	 ecx, -4			; fffffffcH
  0069d	89 8d 2c ff ff
	ff		 mov	 DWORD PTR _cy0x1$9[ebp], ecx
  006a3	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x1$8[ebp]
  006a9	c1 e2 fc	 shl	 edx, -4			; fffffffcH
  006ac	89 95 28 ff ff
	ff		 mov	 DWORD PTR _cy1x1$8[ebp], edx
  006b2	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _cy2x1$7[ebp]
  006b8	c1 e0 fc	 shl	 eax, -4			; fffffffcH
  006bb	89 85 24 ff ff
	ff		 mov	 DWORD PTR _cy2x1$7[ebp], eax
  006c1	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x1$6[ebp]
  006c7	c1 e1 fc	 shl	 ecx, -4			; fffffffcH
  006ca	89 8d 20 ff ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], ecx
  006d0	eb 45		 jmp	 SHORT $LN28@convert_yv
$LN27@convert_yv:
  006d2	ba 01 00 00 00	 mov	 edx, 1
  006d7	85 d2		 test	 edx, edx
  006d9	74 3c		 je	 SHORT $LN28@convert_yv
  006db	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR _cy0x1$9[ebp]
  006e1	c1 f8 04	 sar	 eax, 4
  006e4	89 85 2c ff ff
	ff		 mov	 DWORD PTR _cy0x1$9[ebp], eax
  006ea	8b 8d 28 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x1$8[ebp]
  006f0	c1 f9 04	 sar	 ecx, 4
  006f3	89 8d 28 ff ff
	ff		 mov	 DWORD PTR _cy1x1$8[ebp], ecx
  006f9	8b 95 24 ff ff
	ff		 mov	 edx, DWORD PTR _cy2x1$7[ebp]
  006ff	c1 fa 04	 sar	 edx, 4
  00702	89 95 24 ff ff
	ff		 mov	 DWORD PTR _cy2x1$7[ebp], edx
  00708	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x1$6[ebp]
  0070e	c1 f8 04	 sar	 eax, 4
  00711	89 85 20 ff ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], eax
$LN28@convert_yv:

; 758  : 
; 759  :                 dstC[0*dst_y_pitch   + 0] = (Tout)cy0x0;

  00717	6b 4d e4 00	 imul	 ecx, DWORD PTR _dst_y_pitch$[ebp], 0
  0071b	8b 55 94	 mov	 edx, DWORD PTR _dstC$35[ebp]
  0071e	8a 85 5c ff ff
	ff		 mov	 al, BYTE PTR _cy0x0$21[ebp]
  00724	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 760  :                 dstC[0*dst_y_pitch   + 1] = (Tout)((cy0x0 + cy0x1 + 1) >> 1);

  00727	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR _cy0x1$9[ebp]
  0072d	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR _cy0x0$21[ebp]
  00733	8d 44 0a 01	 lea	 eax, DWORD PTR [edx+ecx+1]
  00737	d1 f8		 sar	 eax, 1
  00739	6b 4d e4 00	 imul	 ecx, DWORD PTR _dst_y_pitch$[ebp], 0
  0073d	8b 55 94	 mov	 edx, DWORD PTR _dstC$35[ebp]
  00740	88 44 0a 01	 mov	 BYTE PTR [edx+ecx+1], al

; 761  :                 dstC[1*dst_y_pitch   + 0] = (Tout)cy1x0;

  00744	8b 45 94	 mov	 eax, DWORD PTR _dstC$35[ebp]
  00747	03 45 e4	 add	 eax, DWORD PTR _dst_y_pitch$[ebp]
  0074a	8a 8d 58 ff ff
	ff		 mov	 cl, BYTE PTR _cy1x0$20[ebp]
  00750	88 08		 mov	 BYTE PTR [eax], cl

; 762  :                 dstC[1*dst_y_pitch   + 1] = (Tout)((cy1x0 + cy1x1 + 1) >> 1);

  00752	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x1$8[ebp]
  00758	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x0$20[ebp]
  0075e	8d 4c 10 01	 lea	 ecx, DWORD PTR [eax+edx+1]
  00762	d1 f9		 sar	 ecx, 1
  00764	8b 55 94	 mov	 edx, DWORD PTR _dstC$35[ebp]
  00767	03 55 e4	 add	 edx, DWORD PTR _dst_y_pitch$[ebp]
  0076a	88 4a 01	 mov	 BYTE PTR [edx+1], cl

; 763  :                 dstC[2*dst_y_pitch   + 0] = (Tout)cy2x0;

  0076d	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  00770	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$35[ebp]
  00773	8a 95 54 ff ff
	ff		 mov	 dl, BYTE PTR _cy2x0$19[ebp]
  00779	88 14 41	 mov	 BYTE PTR [ecx+eax*2], dl

; 764  :                 dstC[2*dst_y_pitch   + 1] = (Tout)((cy2x0 + cy2x1 + 1) >> 1);

  0077c	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _cy2x1$7[ebp]
  00782	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _cy2x0$19[ebp]
  00788	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  0078c	d1 fa		 sar	 edx, 1
  0078e	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  00791	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$35[ebp]
  00794	88 54 41 01	 mov	 BYTE PTR [ecx+eax*2+1], dl

; 765  :                 dstC[3*dst_y_pitch   + 0] = (Tout)cy3x0;

  00798	6b 55 e4 03	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 3
  0079c	8b 45 94	 mov	 eax, DWORD PTR _dstC$35[ebp]
  0079f	8a 8d 50 ff ff
	ff		 mov	 cl, BYTE PTR _cy3x0$18[ebp]
  007a5	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 766  :                 dstC[3*dst_y_pitch   + 1] = (Tout)((cy3x0 + cy3x1 + 1) >> 1);

  007a8	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR _cy3x1$6[ebp]
  007ae	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$18[ebp]
  007b4	8d 4c 10 01	 lea	 ecx, DWORD PTR [eax+edx+1]
  007b8	d1 f9		 sar	 ecx, 1
  007ba	6b 55 e4 03	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 3
  007be	8b 45 94	 mov	 eax, DWORD PTR _dstC$35[ebp]
  007c1	88 4c 10 01	 mov	 BYTE PTR [eax+edx+1], cl

; 767  : 
; 768  :                 cy0x0 = cy0x1;

  007c5	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR _cy0x1$9[ebp]
  007cb	89 8d 5c ff ff
	ff		 mov	 DWORD PTR _cy0x0$21[ebp], ecx

; 769  :                 cy1x0 = cy1x1;

  007d1	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x1$8[ebp]
  007d7	89 95 58 ff ff
	ff		 mov	 DWORD PTR _cy1x0$20[ebp], edx

; 770  :                 cy2x0 = cy2x1;

  007dd	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _cy2x1$7[ebp]
  007e3	89 85 54 ff ff
	ff		 mov	 DWORD PTR _cy2x0$19[ebp], eax

; 771  :                 cy3x0 = cy3x1;

  007e9	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x1$6[ebp]
  007ef	89 8d 50 ff ff
	ff		 mov	 DWORD PTR _cy3x0$18[ebp], ecx

; 772  :             }

  007f5	e9 39 fd ff ff	 jmp	 $LN14@convert_yv
$LN15@convert_yv:

; 773  :         }

  007fa	e9 90 fa ff ff	 jmp	 $LN11@convert_yv
$LN12@convert_yv:

; 774  :     }

  007ff	e9 41 fa ff ff	 jmp	 $LN8@convert_yv
$LN1@convert_yv:

; 775  : }

  00804	52		 push	 edx
  00805	8b cd		 mov	 ecx, ebp
  00807	50		 push	 eax
  00808	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN47@convert_yv
  0080e	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00813	58		 pop	 eax
  00814	5a		 pop	 edx
  00815	5f		 pop	 edi
  00816	5b		 pop	 ebx
  00817	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0081a	33 cd		 xor	 ecx, ebp
  0081c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00821	81 c4 18 01 00
	00		 add	 esp, 280		; 00000118H
  00827	3b ec		 cmp	 ebp, esp
  00829	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0082e	8b e5		 mov	 esp, ebp
  00830	5d		 pop	 ebp
  00831	c3		 ret	 0
  00832	66 90		 npad	 2
$LN47@convert_yv:
  00834	01 00 00 00	 DD	 1
  00838	00 00 00 00	 DD	 $LN46@convert_yv
$LN46@convert_yv:
  0083c	d4 ff ff ff	 DD	 -44			; ffffffd4H
  00840	0c 00 00 00	 DD	 12			; 0000000cH
  00844	00 00 00 00	 DD	 $LN45@convert_yv
$LN45@convert_yv:
  00848	79		 DB	 121			; 00000079H
  00849	5f		 DB	 95			; 0000005fH
  0084a	72		 DB	 114			; 00000072H
  0084b	61		 DB	 97			; 00000061H
  0084c	6e		 DB	 110			; 0000006eH
  0084d	67		 DB	 103			; 00000067H
  0084e	65		 DB	 101			; 00000065H
  0084f	00		 DB	 0
??$convert_yv12_i_to_yuv444_c@G$08E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_i_to_yuv444_c<unsigned short,9,unsigned char,8,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yv12_09_i_to_yuv444@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_09_i_to_yuv444

; 829  : static void convert_yv12_09_i_to_yuv444(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 830  :     convert_yv12_i_to_yuv444_c<uint16_t, 9, uint8_t, 8, false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yv12_i_to_yuv444_c@G$08E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_i_to_yuv444_c<unsigned short,9,unsigned char,8,0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 831  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yv12_09_i_to_yuv444@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_09_i_to_yuv444
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
tv427 = -300						; size = 4
tv312 = -296						; size = 4
tv227 = -292						; size = 4
$T1 = -288						; size = 4
$T2 = -284						; size = 4
$T3 = -280						; size = 4
$T4 = -276						; size = 4
$T5 = -272						; size = 12
_cy3x1$6 = -260						; size = 4
_cy1x1$7 = -256						; size = 4
_cy3x0$8 = -252						; size = 4
_cy1x0$9 = -248						; size = 4
_cy4x1$10 = -244					; size = 4
_cy2x1$11 = -240					; size = 4
_cy0x1$12 = -236					; size = 4
_cy4x0$13 = -232					; size = 4
_cy2x0$14 = -228					; size = 4
_cy0x0$15 = -224					; size = 4
_cxplus$16 = -220					; size = 4
_x$17 = -216						; size = 4
_cy3x1$18 = -212					; size = 4
_cy1x1$19 = -208					; size = 4
_cy3x0$20 = -204					; size = 4
_cy1x0$21 = -200					; size = 4
_cy4x1$22 = -196					; size = 4
_cy2x1$23 = -192					; size = 4
_cy0x1$24 = -188					; size = 4
_cy4x0$25 = -184					; size = 4
_cy2x0$26 = -180					; size = 4
_cy0x0$27 = -176					; size = 4
_cxplus$28 = -172					; size = 4
_x$29 = -168						; size = 4
_cy3x1$30 = -164					; size = 4
_cy1x1$31 = -160					; size = 4
_cy3x0$32 = -156					; size = 4
_cy1x0$33 = -152					; size = 4
_cy4x1$34 = -148					; size = 4
_cy2x1$35 = -144					; size = 4
_cy0x1$36 = -140					; size = 4
_cy4x0$37 = -136					; size = 4
_cy2x0$38 = -132					; size = 4
_cy0x0$39 = -128					; size = 4
_cxplus$40 = -124					; size = 4
_x$41 = -120						; size = 4
_x_fin$42 = -116					; size = 4
_srcP$43 = -112						; size = 4
_dstC$44 = -108						; size = 4
_y$45 = -104						; size = 4
_dstLine$46 = -100					; size = 4
_srcCLine$47 = -96					; size = 4
_ic$48 = -92						; size = 4
_src_uv_pitch$ = -88					; size = 4
_x$49 = -84						; size = 4
_y$50 = -80						; size = 4
_y_width$51 = -76					; size = 4
_y_fin$52 = -72						; size = 4
_dstLine$53 = -68					; size = 4
_srcYLine$54 = -64					; size = 4
$T55 = -60						; size = 12
_y_range$ = -44						; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yv12_p_to_yuv444_c@G$08E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_p_to_yuv444_c<unsigned short,9,unsigned char,8,0>

; 573  : static void __forceinline convert_yv12_p_to_yuv444_c(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 2c 01 00
	00		 sub	 esp, 300		; 0000012cH
  00009	53		 push	 ebx
  0000a	57		 push	 edi
  0000b	8d bd d4 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-300]
  00011	b9 4b 00 00 00	 mov	 ecx, 75			; 0000004bH
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 574  :     static_assert((sizeof(Tin)  == 1 && in_bit_depth  == 8) || (sizeof(Tin)  == 2 && 8 < in_bit_depth  && in_bit_depth  <= 16), "invalid input bit depth.");
; 575  :     static_assert((sizeof(Tout) == 1 && out_bit_depth == 8) || (sizeof(Tout) == 2 && 8 < out_bit_depth && out_bit_depth <= 16), "invalid output bit depth.");
; 576  :     const int crop_left   = crop[0];

  00027	b8 04 00 00 00	 mov	 eax, 4
  0002c	6b c8 00	 imul	 ecx, eax, 0
  0002f	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00032	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00035	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 577  :     const int crop_up     = crop[1];

  00038	b9 04 00 00 00	 mov	 ecx, 4
  0003d	c1 e1 00	 shl	 ecx, 0
  00040	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00043	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00046	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 578  :     const int crop_right  = crop[2];

  00049	b9 04 00 00 00	 mov	 ecx, 4
  0004e	d1 e1		 shl	 ecx, 1
  00050	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00053	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00056	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 579  :     const int crop_bottom = crop[3];

  00059	b9 04 00 00 00	 mov	 ecx, 4
  0005e	6b d1 03	 imul	 edx, ecx, 3
  00061	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00064	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00067	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 580  :     const int src_y_pitch = src_y_pitch_byte / sizeof(Tin);

  0006a	8b 55 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebp]
  0006d	d1 ea		 shr	 edx, 1
  0006f	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 581  :     const int dst_y_pitch = dst_y_pitch_byte / sizeof(Tout);

  00072	8b 45 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  00075	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 582  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00078	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0007b	51		 push	 ecx
  0007c	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0007f	52		 push	 edx
  00080	8b 45 20	 mov	 eax, DWORD PTR _height$[ebp]
  00083	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  00086	50		 push	 eax
  00087	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  0008a	51		 push	 ecx
  0008b	8d 95 f0 fe ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  00091	52		 push	 edx
  00092	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00097	83 c4 14	 add	 esp, 20			; 00000014H
  0009a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009c	89 4d c4	 mov	 DWORD PTR $T55[ebp], ecx
  0009f	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a2	89 55 c8	 mov	 DWORD PTR $T55[ebp+4], edx
  000a5	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000a8	89 45 cc	 mov	 DWORD PTR $T55[ebp+8], eax
  000ab	8b 4d c4	 mov	 ecx, DWORD PTR $T55[ebp]
  000ae	89 4d d4	 mov	 DWORD PTR _y_range$[ebp], ecx
  000b1	8b 55 c8	 mov	 edx, DWORD PTR $T55[ebp+4]
  000b4	89 55 d8	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000b7	8b 45 cc	 mov	 eax, DWORD PTR $T55[ebp+8]
  000ba	89 45 dc	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 583  :     //Y
; 584  :     if (!uv_only) {

  000bd	b9 01 00 00 00	 mov	 ecx, 1
  000c2	85 c9		 test	 ecx, ecx
  000c4	0f 84 6a 01 00
	00		 je	 $LN23@convert_yv

; 585  :         Tin *srcYLine = (Tin *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000ca	ba 04 00 00 00	 mov	 edx, 4
  000cf	6b c2 00	 imul	 eax, edx, 0
  000d2	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  000d5	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  000d9	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  000dc	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  000df	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  000e2	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  000e5	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  000e8	89 45 c0	 mov	 DWORD PTR _srcYLine$54[ebp], eax

; 586  :         Tout *dstLine = (Tout *)dst[0] + dst_y_pitch * y_range.start_dst;

  000eb	b9 04 00 00 00	 mov	 ecx, 4
  000f0	6b d1 00	 imul	 edx, ecx, 0
  000f3	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  000f6	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  000fa	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  000fd	03 04 11	 add	 eax, DWORD PTR [ecx+edx]
  00100	89 45 bc	 mov	 DWORD PTR _dstLine$53[ebp], eax

; 587  :         const int y_fin = height - crop_bottom;

  00103	8b 55 20	 mov	 edx, DWORD PTR _height$[ebp]
  00106	2b 55 ec	 sub	 edx, DWORD PTR _crop_bottom$[ebp]
  00109	89 55 b8	 mov	 DWORD PTR _y_fin$52[ebp], edx

; 588  :         const int y_width = width - crop_right - crop_left;

  0010c	8b 45 10	 mov	 eax, DWORD PTR _width$[ebp]
  0010f	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  00112	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  00115	89 45 b4	 mov	 DWORD PTR _y_width$51[ebp], eax

; 589  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  00118	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _y$50[ebp], 0
  0011f	eb 1e		 jmp	 SHORT $LN4@convert_yv
$LN2@convert_yv:
  00121	8b 4d b0	 mov	 ecx, DWORD PTR _y$50[ebp]
  00124	83 c1 01	 add	 ecx, 1
  00127	89 4d b0	 mov	 DWORD PTR _y$50[ebp], ecx
  0012a	8b 55 e8	 mov	 edx, DWORD PTR _src_y_pitch$[ebp]
  0012d	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$54[ebp]
  00130	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00133	89 4d c0	 mov	 DWORD PTR _srcYLine$54[ebp], ecx
  00136	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$53[ebp]
  00139	03 55 e4	 add	 edx, DWORD PTR _dst_y_pitch$[ebp]
  0013c	89 55 bc	 mov	 DWORD PTR _dstLine$53[ebp], edx
$LN4@convert_yv:
  0013f	8b 45 b0	 mov	 eax, DWORD PTR _y$50[ebp]
  00142	3b 45 dc	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  00145	0f 8d e9 00 00
	00		 jge	 $LN23@convert_yv

; 590  :             if (in_bit_depth == out_bit_depth && sizeof(Tin) == sizeof(Tout)) {

  0014b	33 c9		 xor	 ecx, ecx
  0014d	74 1b		 je	 SHORT $LN24@convert_yv

; 591  :                 memcpy(dstLine, srcYLine, y_width * sizeof(Tin));

  0014f	8b 55 b4	 mov	 edx, DWORD PTR _y_width$51[ebp]
  00152	d1 e2		 shl	 edx, 1
  00154	52		 push	 edx
  00155	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$54[ebp]
  00158	50		 push	 eax
  00159	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$53[ebp]
  0015c	51		 push	 ecx
  0015d	e8 00 00 00 00	 call	 _memcpy
  00162	83 c4 0c	 add	 esp, 12			; 0000000cH

; 592  :             } else {

  00165	e9 c5 00 00 00	 jmp	 $LN25@convert_yv
$LN24@convert_yv:

; 593  :                 for (int x = 0; x < y_width; x++) {

  0016a	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR _x$49[ebp], 0
  00171	eb 09		 jmp	 SHORT $LN7@convert_yv
$LN5@convert_yv:
  00173	8b 55 ac	 mov	 edx, DWORD PTR _x$49[ebp]
  00176	83 c2 01	 add	 edx, 1
  00179	89 55 ac	 mov	 DWORD PTR _x$49[ebp], edx
$LN7@convert_yv:
  0017c	8b 45 ac	 mov	 eax, DWORD PTR _x$49[ebp]
  0017f	3b 45 b4	 cmp	 eax, DWORD PTR _y_width$51[ebp]
  00182	0f 8d a7 00 00
	00		 jge	 $LN25@convert_yv

; 594  :                     if (out_bit_depth > in_bit_depth) {

  00188	33 c9		 xor	 ecx, ecx
  0018a	74 42		 je	 SHORT $LN26@convert_yv

; 595  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) << std::max(out_bit_depth - in_bit_depth, 0));

  0018c	c7 85 ec fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], 0
  00196	c7 85 e8 fe ff
	ff ff ff ff ff	 mov	 DWORD PTR $T3[ebp], -1
  001a0	8b 55 ac	 mov	 edx, DWORD PTR _x$49[ebp]
  001a3	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$54[ebp]
  001a6	0f b7 1c 50	 movzx	 ebx, WORD PTR [eax+edx*2]
  001aa	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  001b0	51		 push	 ecx
  001b1	8d 95 e8 fe ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  001b7	52		 push	 edx
  001b8	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  001bd	83 c4 08	 add	 esp, 8
  001c0	8b 08		 mov	 ecx, DWORD PTR [eax]
  001c2	d3 e3		 shl	 ebx, cl
  001c4	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$53[ebp]
  001c7	03 45 ac	 add	 eax, DWORD PTR _x$49[ebp]
  001ca	88 18		 mov	 BYTE PTR [eax], bl
  001cc	eb 5c		 jmp	 SHORT $LN27@convert_yv
$LN26@convert_yv:

; 596  :                     } else if (out_bit_depth < in_bit_depth) {

  001ce	b9 01 00 00 00	 mov	 ecx, 1
  001d3	85 c9		 test	 ecx, ecx
  001d5	74 42		 je	 SHORT $LN28@convert_yv

; 597  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) >> std::max(in_bit_depth - out_bit_depth, 0));

  001d7	c7 85 e4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], 0
  001e1	c7 85 e0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR $T1[ebp], 1
  001eb	8b 55 ac	 mov	 edx, DWORD PTR _x$49[ebp]
  001ee	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$54[ebp]
  001f1	0f b7 1c 50	 movzx	 ebx, WORD PTR [eax+edx*2]
  001f5	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  001fb	51		 push	 ecx
  001fc	8d 95 e0 fe ff
	ff		 lea	 edx, DWORD PTR $T1[ebp]
  00202	52		 push	 edx
  00203	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  00208	83 c4 08	 add	 esp, 8
  0020b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0020d	d3 fb		 sar	 ebx, cl
  0020f	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$53[ebp]
  00212	03 45 ac	 add	 eax, DWORD PTR _x$49[ebp]
  00215	88 18		 mov	 BYTE PTR [eax], bl

; 598  :                     } else {

  00217	eb 11		 jmp	 SHORT $LN27@convert_yv
$LN28@convert_yv:

; 599  :                         dstLine[x] = (Tout)srcYLine[x];

  00219	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$53[ebp]
  0021c	03 4d ac	 add	 ecx, DWORD PTR _x$49[ebp]
  0021f	8b 55 ac	 mov	 edx, DWORD PTR _x$49[ebp]
  00222	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$54[ebp]
  00225	8a 14 50	 mov	 dl, BYTE PTR [eax+edx*2]
  00228	88 11		 mov	 BYTE PTR [ecx], dl
$LN27@convert_yv:

; 600  :                     }
; 601  :                 }

  0022a	e9 44 ff ff ff	 jmp	 $LN5@convert_yv
$LN25@convert_yv:

; 602  :             }
; 603  :         }

  0022f	e9 ed fe ff ff	 jmp	 $LN2@convert_yv
$LN23@convert_yv:

; 604  :     }
; 605  :     //UV
; 606  :     const int src_uv_pitch = src_uv_pitch_byte / sizeof(Tin);

  00234	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  00237	d1 e8		 shr	 eax, 1
  00239	89 45 a8	 mov	 DWORD PTR _src_uv_pitch$[ebp], eax

; 607  :     for (int ic = 1; ic < 3; ic++) {

  0023c	c7 45 a4 01 00
	00 00		 mov	 DWORD PTR _ic$48[ebp], 1
  00243	eb 09		 jmp	 SHORT $LN10@convert_yv
$LN8@convert_yv:
  00245	8b 4d a4	 mov	 ecx, DWORD PTR _ic$48[ebp]
  00248	83 c1 01	 add	 ecx, 1
  0024b	89 4d a4	 mov	 DWORD PTR _ic$48[ebp], ecx
$LN10@convert_yv:
  0024e	83 7d a4 03	 cmp	 DWORD PTR _ic$48[ebp], 3
  00252	0f 8d ea 06 00
	00		 jge	 $LN1@convert_yv

; 608  :         Tin *srcCLine = (Tin *)src[ic] + (((src_uv_pitch * y_range.start_src) + crop_left) >> 1);

  00258	8b 55 a8	 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  0025b	0f af 55 d4	 imul	 edx, DWORD PTR _y_range$[ebp]
  0025f	03 55 f8	 add	 edx, DWORD PTR _crop_left$[ebp]
  00262	d1 fa		 sar	 edx, 1
  00264	8b 45 a4	 mov	 eax, DWORD PTR _ic$48[ebp]
  00267	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  0026a	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  0026d	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00270	89 4d a0	 mov	 DWORD PTR _srcCLine$47[ebp], ecx

; 609  :         Tout *dstLine = (Tout *)dst[ic] + dst_y_pitch * y_range.start_dst;

  00273	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  00276	0f af 55 d8	 imul	 edx, DWORD PTR _y_range$[ebp+4]
  0027a	8b 45 a4	 mov	 eax, DWORD PTR _ic$48[ebp]
  0027d	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  00280	03 14 81	 add	 edx, DWORD PTR [ecx+eax*4]
  00283	89 55 9c	 mov	 DWORD PTR _dstLine$46[ebp], edx

; 610  :         for (int y = 0; y < y_range.len; y += 2, srcCLine += src_uv_pitch, dstLine += dst_y_pitch * 2) {

  00286	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _y$45[ebp], 0
  0028d	eb 21		 jmp	 SHORT $LN13@convert_yv
$LN11@convert_yv:
  0028f	8b 55 98	 mov	 edx, DWORD PTR _y$45[ebp]
  00292	83 c2 02	 add	 edx, 2
  00295	89 55 98	 mov	 DWORD PTR _y$45[ebp], edx
  00298	8b 45 a8	 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  0029b	8b 4d a0	 mov	 ecx, DWORD PTR _srcCLine$47[ebp]
  0029e	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  002a1	89 55 a0	 mov	 DWORD PTR _srcCLine$47[ebp], edx
  002a4	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  002a7	8b 4d 9c	 mov	 ecx, DWORD PTR _dstLine$46[ebp]
  002aa	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  002ad	89 55 9c	 mov	 DWORD PTR _dstLine$46[ebp], edx
$LN13@convert_yv:
  002b0	8b 45 98	 mov	 eax, DWORD PTR _y$45[ebp]
  002b3	3b 45 dc	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  002b6	0f 8d 81 06 00
	00		 jge	 $LN12@convert_yv

; 611  :             Tout *dstC = dstLine;

  002bc	8b 4d 9c	 mov	 ecx, DWORD PTR _dstLine$46[ebp]
  002bf	89 4d 94	 mov	 DWORD PTR _dstC$44[ebp], ecx

; 612  :             Tin *srcP = srcCLine;

  002c2	8b 55 a0	 mov	 edx, DWORD PTR _srcCLine$47[ebp]
  002c5	89 55 90	 mov	 DWORD PTR _srcP$43[ebp], edx

; 613  :             const int x_fin = width - crop_right - crop_left;

  002c8	8b 45 10	 mov	 eax, DWORD PTR _width$[ebp]
  002cb	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  002ce	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  002d1	89 45 8c	 mov	 DWORD PTR _x_fin$42[ebp], eax

; 614  :             if (y == 0) {

  002d4	83 7d 98 00	 cmp	 DWORD PTR _y$45[ebp], 0
  002d8	0f 85 04 02 00
	00		 jne	 $LN30@convert_yv

; 615  :                 for (int x = 0; x < x_fin; x += 2, dstC += 2, srcP++) {

  002de	c7 45 88 00 00
	00 00		 mov	 DWORD PTR _x$41[ebp], 0
  002e5	eb 1b		 jmp	 SHORT $LN16@convert_yv
$LN14@convert_yv:
  002e7	8b 4d 88	 mov	 ecx, DWORD PTR _x$41[ebp]
  002ea	83 c1 02	 add	 ecx, 2
  002ed	89 4d 88	 mov	 DWORD PTR _x$41[ebp], ecx
  002f0	8b 55 94	 mov	 edx, DWORD PTR _dstC$44[ebp]
  002f3	83 c2 02	 add	 edx, 2
  002f6	89 55 94	 mov	 DWORD PTR _dstC$44[ebp], edx
  002f9	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  002fc	83 c0 02	 add	 eax, 2
  002ff	89 45 90	 mov	 DWORD PTR _srcP$43[ebp], eax
$LN16@convert_yv:
  00302	8b 4d 88	 mov	 ecx, DWORD PTR _x$41[ebp]
  00305	3b 4d 8c	 cmp	 ecx, DWORD PTR _x_fin$42[ebp]
  00308	0f 8d cf 01 00
	00		 jge	 $LN15@convert_yv

; 616  :                     int cxplus = (x + 2 < x_fin);

  0030e	8b 55 88	 mov	 edx, DWORD PTR _x$41[ebp]
  00311	83 c2 02	 add	 edx, 2
  00314	3b 55 8c	 cmp	 edx, DWORD PTR _x_fin$42[ebp]
  00317	7d 0c		 jge	 SHORT $LN44@convert_yv
  00319	c7 85 dc fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv227[ebp], 1
  00323	eb 0a		 jmp	 SHORT $LN45@convert_yv
$LN44@convert_yv:
  00325	c7 85 dc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv227[ebp], 0
$LN45@convert_yv:
  0032f	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR tv227[ebp]
  00335	89 45 84	 mov	 DWORD PTR _cxplus$40[ebp], eax

; 617  :                     int cy0x0 = srcP[ 0*src_uv_pitch + 0];

  00338	6b 4d a8 00	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 0
  0033c	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  0033f	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00343	89 45 80	 mov	 DWORD PTR _cy0x0$39[ebp], eax

; 618  :                     int cy2x0 = srcP[ 0*src_uv_pitch + 0];

  00346	6b 4d a8 00	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 0
  0034a	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  0034d	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00351	89 85 7c ff ff
	ff		 mov	 DWORD PTR _cy2x0$38[ebp], eax

; 619  :                     int cy4x0 = srcP[ 1*src_uv_pitch + 0];

  00357	8b 4d a8	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  0035a	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  0035d	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00361	89 85 78 ff ff
	ff		 mov	 DWORD PTR _cy4x0$37[ebp], eax

; 620  :                     int cy0x1 = srcP[ 0*src_uv_pitch + cxplus];

  00367	6b 4d a8 00	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 0
  0036b	03 4d 84	 add	 ecx, DWORD PTR _cxplus$40[ebp]
  0036e	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  00371	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00375	89 85 74 ff ff
	ff		 mov	 DWORD PTR _cy0x1$36[ebp], eax

; 621  :                     int cy2x1 = srcP[ 0*src_uv_pitch + cxplus];

  0037b	6b 4d a8 00	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 0
  0037f	03 4d 84	 add	 ecx, DWORD PTR _cxplus$40[ebp]
  00382	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  00385	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00389	89 85 70 ff ff
	ff		 mov	 DWORD PTR _cy2x1$35[ebp], eax

; 622  :                     int cy4x1 = srcP[ 1*src_uv_pitch + cxplus];

  0038f	8b 4d 84	 mov	 ecx, DWORD PTR _cxplus$40[ebp]
  00392	03 4d a8	 add	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00395	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  00398	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  0039c	89 85 6c ff ff
	ff		 mov	 DWORD PTR _cy4x1$34[ebp], eax

; 623  : 
; 624  :                     int cy1x0 = (cy0x0 * 1 + cy2x0 * 3 + 2);

  003a2	6b 8d 7c ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy2x0$38[ebp], 3
  003a9	8b 55 80	 mov	 edx, DWORD PTR _cy0x0$39[ebp]
  003ac	8d 44 0a 02	 lea	 eax, DWORD PTR [edx+ecx+2]
  003b0	89 85 68 ff ff
	ff		 mov	 DWORD PTR _cy1x0$33[ebp], eax

; 625  :                     int cy3x0 = (cy2x0 * 3 + cy4x0 * 1 + 2);

  003b6	6b 8d 7c ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy2x0$38[ebp], 3
  003bd	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _cy4x0$37[ebp]
  003c3	8d 44 11 02	 lea	 eax, DWORD PTR [ecx+edx+2]
  003c7	89 85 64 ff ff
	ff		 mov	 DWORD PTR _cy3x0$32[ebp], eax

; 626  :                     int cy1x1 = (cy0x1 * 1 + cy2x1 * 3 + 2);

  003cd	6b 8d 70 ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy2x1$35[ebp], 3
  003d4	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _cy0x1$36[ebp]
  003da	8d 44 0a 02	 lea	 eax, DWORD PTR [edx+ecx+2]
  003de	89 85 60 ff ff
	ff		 mov	 DWORD PTR _cy1x1$31[ebp], eax

; 627  :                     int cy3x1 = (cy2x1 * 3 + cy4x1 * 1 + 2);

  003e4	6b 8d 70 ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy2x1$35[ebp], 3
  003eb	8b 95 6c ff ff
	ff		 mov	 edx, DWORD PTR _cy4x1$34[ebp]
  003f1	8d 44 11 02	 lea	 eax, DWORD PTR [ecx+edx+2]
  003f5	89 85 5c ff ff
	ff		 mov	 DWORD PTR _cy3x1$30[ebp], eax

; 628  :                     CHANGE_BIT_DEPTH_4(cy1x0, cy3x0, cy1x1, cy3x1, 2);

  003fb	33 c9		 xor	 ecx, ecx
  003fd	74 3e		 je	 SHORT $LN32@convert_yv
  003ff	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x0$33[ebp]
  00405	c1 e2 fd	 shl	 edx, -3			; fffffffdH
  00408	89 95 68 ff ff
	ff		 mov	 DWORD PTR _cy1x0$33[ebp], edx
  0040e	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$32[ebp]
  00414	c1 e0 fd	 shl	 eax, -3			; fffffffdH
  00417	89 85 64 ff ff
	ff		 mov	 DWORD PTR _cy3x0$32[ebp], eax
  0041d	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x1$31[ebp]
  00423	c1 e1 fd	 shl	 ecx, -3			; fffffffdH
  00426	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _cy1x1$31[ebp], ecx
  0042c	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR _cy3x1$30[ebp]
  00432	c1 e2 fd	 shl	 edx, -3			; fffffffdH
  00435	89 95 5c ff ff
	ff		 mov	 DWORD PTR _cy3x1$30[ebp], edx
  0043b	eb 45		 jmp	 SHORT $LN33@convert_yv
$LN32@convert_yv:
  0043d	b8 01 00 00 00	 mov	 eax, 1
  00442	85 c0		 test	 eax, eax
  00444	74 3c		 je	 SHORT $LN33@convert_yv
  00446	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x0$33[ebp]
  0044c	c1 f9 03	 sar	 ecx, 3
  0044f	89 8d 68 ff ff
	ff		 mov	 DWORD PTR _cy1x0$33[ebp], ecx
  00455	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR _cy3x0$32[ebp]
  0045b	c1 fa 03	 sar	 edx, 3
  0045e	89 95 64 ff ff
	ff		 mov	 DWORD PTR _cy3x0$32[ebp], edx
  00464	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x1$31[ebp]
  0046a	c1 f8 03	 sar	 eax, 3
  0046d	89 85 60 ff ff
	ff		 mov	 DWORD PTR _cy1x1$31[ebp], eax
  00473	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x1$30[ebp]
  00479	c1 f9 03	 sar	 ecx, 3
  0047c	89 8d 5c ff ff
	ff		 mov	 DWORD PTR _cy3x1$30[ebp], ecx
$LN33@convert_yv:

; 629  : 
; 630  :                     dstC[0*dst_y_pitch   + 0] = (Tout)cy1x0;

  00482	6b 55 e4 00	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 0
  00486	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  00489	8a 8d 68 ff ff
	ff		 mov	 cl, BYTE PTR _cy1x0$33[ebp]
  0048f	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 631  :                     dstC[0*dst_y_pitch   + 1] = (Tout)((cy1x0 + cy1x1 + 1) >> 1);

  00492	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x1$31[ebp]
  00498	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x0$33[ebp]
  0049e	8d 4c 10 01	 lea	 ecx, DWORD PTR [eax+edx+1]
  004a2	d1 f9		 sar	 ecx, 1
  004a4	6b 55 e4 00	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 0
  004a8	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  004ab	88 4c 10 01	 mov	 BYTE PTR [eax+edx+1], cl

; 632  :                     dstC[1*dst_y_pitch   + 0] = (Tout)cy3x0;

  004af	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$44[ebp]
  004b2	03 4d e4	 add	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  004b5	8a 95 64 ff ff
	ff		 mov	 dl, BYTE PTR _cy3x0$32[ebp]
  004bb	88 11		 mov	 BYTE PTR [ecx], dl

; 633  :                     dstC[1*dst_y_pitch   + 1] = (Tout)((cy3x0 + cy3x1 + 1) >> 1);

  004bd	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _cy3x1$30[ebp]
  004c3	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x0$32[ebp]
  004c9	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  004cd	d1 fa		 sar	 edx, 1
  004cf	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  004d2	03 45 e4	 add	 eax, DWORD PTR _dst_y_pitch$[ebp]
  004d5	88 50 01	 mov	 BYTE PTR [eax+1], dl

; 634  :                 }

  004d8	e9 0a fe ff ff	 jmp	 $LN14@convert_yv
$LN15@convert_yv:

; 635  :             } else if (y >= height-2) {

  004dd	e9 56 04 00 00	 jmp	 $LN31@convert_yv
$LN30@convert_yv:
  004e2	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  004e5	83 e9 02	 sub	 ecx, 2
  004e8	39 4d 98	 cmp	 DWORD PTR _y$45[ebp], ecx
  004eb	0f 8c 27 02 00
	00		 jl	 $LN35@convert_yv

; 636  :                 for (int x = 0; x < x_fin; x += 2, dstC += 2, srcP++) {

  004f1	c7 85 58 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _x$29[ebp], 0
  004fb	eb 21		 jmp	 SHORT $LN19@convert_yv
$LN17@convert_yv:
  004fd	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _x$29[ebp]
  00503	83 c2 02	 add	 edx, 2
  00506	89 95 58 ff ff
	ff		 mov	 DWORD PTR _x$29[ebp], edx
  0050c	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  0050f	83 c0 02	 add	 eax, 2
  00512	89 45 94	 mov	 DWORD PTR _dstC$44[ebp], eax
  00515	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$43[ebp]
  00518	83 c1 02	 add	 ecx, 2
  0051b	89 4d 90	 mov	 DWORD PTR _srcP$43[ebp], ecx
$LN19@convert_yv:
  0051e	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _x$29[ebp]
  00524	3b 55 8c	 cmp	 edx, DWORD PTR _x_fin$42[ebp]
  00527	0f 8d e6 01 00
	00		 jge	 $LN18@convert_yv

; 637  :                     int cxplus = (x + 2 < x_fin);

  0052d	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _x$29[ebp]
  00533	83 c0 02	 add	 eax, 2
  00536	3b 45 8c	 cmp	 eax, DWORD PTR _x_fin$42[ebp]
  00539	7d 0c		 jge	 SHORT $LN46@convert_yv
  0053b	c7 85 d8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv312[ebp], 1
  00545	eb 0a		 jmp	 SHORT $LN47@convert_yv
$LN46@convert_yv:
  00547	c7 85 d8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv312[ebp], 0
$LN47@convert_yv:
  00551	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR tv312[ebp]
  00557	89 8d 54 ff ff
	ff		 mov	 DWORD PTR _cxplus$28[ebp], ecx

; 638  :                     int cy0x0 = srcP[-1*src_uv_pitch + 0];

  0055d	6b 55 a8 ff	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], -1
  00561	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  00564	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  00568	89 8d 50 ff ff
	ff		 mov	 DWORD PTR _cy0x0$27[ebp], ecx

; 639  :                     int cy2x0 = srcP[ 0*src_uv_pitch + 0];

  0056e	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  00572	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  00575	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  00579	89 8d 4c ff ff
	ff		 mov	 DWORD PTR _cy2x0$26[ebp], ecx

; 640  :                     int cy4x0 = srcP[ 0*src_uv_pitch + 0];

  0057f	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  00583	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  00586	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  0058a	89 8d 48 ff ff
	ff		 mov	 DWORD PTR _cy4x0$25[ebp], ecx

; 641  :                     int cy0x1 = srcP[-1*src_uv_pitch + cxplus];

  00590	6b 55 a8 ff	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], -1
  00594	03 95 54 ff ff
	ff		 add	 edx, DWORD PTR _cxplus$28[ebp]
  0059a	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  0059d	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  005a1	89 8d 44 ff ff
	ff		 mov	 DWORD PTR _cy0x1$24[ebp], ecx

; 642  :                     int cy2x1 = srcP[ 0*src_uv_pitch + cxplus];

  005a7	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  005ab	03 95 54 ff ff
	ff		 add	 edx, DWORD PTR _cxplus$28[ebp]
  005b1	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  005b4	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  005b8	89 8d 40 ff ff
	ff		 mov	 DWORD PTR _cy2x1$23[ebp], ecx

; 643  :                     int cy4x1 = srcP[ 0*src_uv_pitch + cxplus];

  005be	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  005c2	03 95 54 ff ff
	ff		 add	 edx, DWORD PTR _cxplus$28[ebp]
  005c8	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  005cb	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  005cf	89 8d 3c ff ff
	ff		 mov	 DWORD PTR _cy4x1$22[ebp], ecx

; 644  : 
; 645  :                     int cy1x0 = (cy0x0 * 1 + cy2x0 * 3 + 2);

  005d5	6b 95 4c ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x0$26[ebp], 3
  005dc	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _cy0x0$27[ebp]
  005e2	8d 4c 10 02	 lea	 ecx, DWORD PTR [eax+edx+2]
  005e6	89 8d 38 ff ff
	ff		 mov	 DWORD PTR _cy1x0$21[ebp], ecx

; 646  :                     int cy3x0 = (cy2x0 * 3 + cy4x0 * 1 + 2);

  005ec	6b 95 4c ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x0$26[ebp], 3
  005f3	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _cy4x0$25[ebp]
  005f9	8d 4c 02 02	 lea	 ecx, DWORD PTR [edx+eax+2]
  005fd	89 8d 34 ff ff
	ff		 mov	 DWORD PTR _cy3x0$20[ebp], ecx

; 647  :                     int cy1x1 = (cy0x1 * 1 + cy2x1 * 3 + 2);

  00603	6b 95 40 ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x1$23[ebp], 3
  0060a	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _cy0x1$24[ebp]
  00610	8d 4c 10 02	 lea	 ecx, DWORD PTR [eax+edx+2]
  00614	89 8d 30 ff ff
	ff		 mov	 DWORD PTR _cy1x1$19[ebp], ecx

; 648  :                     int cy3x1 = (cy2x1 * 3 + cy4x1 * 1 + 2);

  0061a	6b 95 40 ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x1$23[ebp], 3
  00621	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _cy4x1$22[ebp]
  00627	8d 4c 02 02	 lea	 ecx, DWORD PTR [edx+eax+2]
  0062b	89 8d 2c ff ff
	ff		 mov	 DWORD PTR _cy3x1$18[ebp], ecx

; 649  :                     CHANGE_BIT_DEPTH_4(cy1x0, cy3x0, cy1x1, cy3x1, 2);

  00631	33 d2		 xor	 edx, edx
  00633	74 3e		 je	 SHORT $LN37@convert_yv
  00635	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x0$21[ebp]
  0063b	c1 e0 fd	 shl	 eax, -3			; fffffffdH
  0063e	89 85 38 ff ff
	ff		 mov	 DWORD PTR _cy1x0$21[ebp], eax
  00644	8b 8d 34 ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x0$20[ebp]
  0064a	c1 e1 fd	 shl	 ecx, -3			; fffffffdH
  0064d	89 8d 34 ff ff
	ff		 mov	 DWORD PTR _cy3x0$20[ebp], ecx
  00653	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x1$19[ebp]
  00659	c1 e2 fd	 shl	 edx, -3			; fffffffdH
  0065c	89 95 30 ff ff
	ff		 mov	 DWORD PTR _cy1x1$19[ebp], edx
  00662	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR _cy3x1$18[ebp]
  00668	c1 e0 fd	 shl	 eax, -3			; fffffffdH
  0066b	89 85 2c ff ff
	ff		 mov	 DWORD PTR _cy3x1$18[ebp], eax
  00671	eb 45		 jmp	 SHORT $LN38@convert_yv
$LN37@convert_yv:
  00673	b9 01 00 00 00	 mov	 ecx, 1
  00678	85 c9		 test	 ecx, ecx
  0067a	74 3c		 je	 SHORT $LN38@convert_yv
  0067c	8b 95 38 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x0$21[ebp]
  00682	c1 fa 03	 sar	 edx, 3
  00685	89 95 38 ff ff
	ff		 mov	 DWORD PTR _cy1x0$21[ebp], edx
  0068b	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$20[ebp]
  00691	c1 f8 03	 sar	 eax, 3
  00694	89 85 34 ff ff
	ff		 mov	 DWORD PTR _cy3x0$20[ebp], eax
  0069a	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x1$19[ebp]
  006a0	c1 f9 03	 sar	 ecx, 3
  006a3	89 8d 30 ff ff
	ff		 mov	 DWORD PTR _cy1x1$19[ebp], ecx
  006a9	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR _cy3x1$18[ebp]
  006af	c1 fa 03	 sar	 edx, 3
  006b2	89 95 2c ff ff
	ff		 mov	 DWORD PTR _cy3x1$18[ebp], edx
$LN38@convert_yv:

; 650  : 
; 651  :                     dstC[0*dst_y_pitch   + 0] = (Tout)cy1x0;

  006b8	6b 45 e4 00	 imul	 eax, DWORD PTR _dst_y_pitch$[ebp], 0
  006bc	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$44[ebp]
  006bf	8a 95 38 ff ff
	ff		 mov	 dl, BYTE PTR _cy1x0$21[ebp]
  006c5	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 652  :                     dstC[0*dst_y_pitch   + 1] = (Tout)((cy1x0 + cy1x1 + 1) >> 1);

  006c8	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x1$19[ebp]
  006ce	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x0$21[ebp]
  006d4	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  006d8	d1 fa		 sar	 edx, 1
  006da	6b 45 e4 00	 imul	 eax, DWORD PTR _dst_y_pitch$[ebp], 0
  006de	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$44[ebp]
  006e1	88 54 01 01	 mov	 BYTE PTR [ecx+eax+1], dl

; 653  :                     dstC[1*dst_y_pitch   + 0] = (Tout)cy3x0;

  006e5	8b 55 94	 mov	 edx, DWORD PTR _dstC$44[ebp]
  006e8	03 55 e4	 add	 edx, DWORD PTR _dst_y_pitch$[ebp]
  006eb	8a 85 34 ff ff
	ff		 mov	 al, BYTE PTR _cy3x0$20[ebp]
  006f1	88 02		 mov	 BYTE PTR [edx], al

; 654  :                     dstC[1*dst_y_pitch   + 1] = (Tout)((cy3x0 + cy3x1 + 1) >> 1);

  006f3	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x1$18[ebp]
  006f9	8b 95 34 ff ff
	ff		 mov	 edx, DWORD PTR _cy3x0$20[ebp]
  006ff	8d 44 0a 01	 lea	 eax, DWORD PTR [edx+ecx+1]
  00703	d1 f8		 sar	 eax, 1
  00705	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$44[ebp]
  00708	03 4d e4	 add	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  0070b	88 41 01	 mov	 BYTE PTR [ecx+1], al

; 655  :                 }

  0070e	e9 ea fd ff ff	 jmp	 $LN17@convert_yv
$LN18@convert_yv:

; 656  :             } else {

  00713	e9 20 02 00 00	 jmp	 $LN31@convert_yv
$LN35@convert_yv:

; 657  :                 for (int x = 0; x < x_fin; x += 2, dstC += 2, srcP++) {

  00718	c7 85 28 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _x$17[ebp], 0
  00722	eb 21		 jmp	 SHORT $LN22@convert_yv
$LN20@convert_yv:
  00724	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR _x$17[ebp]
  0072a	83 c2 02	 add	 edx, 2
  0072d	89 95 28 ff ff
	ff		 mov	 DWORD PTR _x$17[ebp], edx
  00733	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  00736	83 c0 02	 add	 eax, 2
  00739	89 45 94	 mov	 DWORD PTR _dstC$44[ebp], eax
  0073c	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$43[ebp]
  0073f	83 c1 02	 add	 ecx, 2
  00742	89 4d 90	 mov	 DWORD PTR _srcP$43[ebp], ecx
$LN22@convert_yv:
  00745	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR _x$17[ebp]
  0074b	3b 55 8c	 cmp	 edx, DWORD PTR _x_fin$42[ebp]
  0074e	0f 8d e4 01 00
	00		 jge	 $LN31@convert_yv

; 658  :                     int cxplus = (x + 2 < x_fin);

  00754	8b 85 28 ff ff
	ff		 mov	 eax, DWORD PTR _x$17[ebp]
  0075a	83 c0 02	 add	 eax, 2
  0075d	3b 45 8c	 cmp	 eax, DWORD PTR _x_fin$42[ebp]
  00760	7d 0c		 jge	 SHORT $LN48@convert_yv
  00762	c7 85 d4 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv427[ebp], 1
  0076c	eb 0a		 jmp	 SHORT $LN49@convert_yv
$LN48@convert_yv:
  0076e	c7 85 d4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv427[ebp], 0
$LN49@convert_yv:
  00778	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR tv427[ebp]
  0077e	89 8d 24 ff ff
	ff		 mov	 DWORD PTR _cxplus$16[ebp], ecx

; 659  :                     int cy0x0 = srcP[-1*src_uv_pitch + 0];

  00784	6b 55 a8 ff	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], -1
  00788	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  0078b	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  0078f	89 8d 20 ff ff
	ff		 mov	 DWORD PTR _cy0x0$15[ebp], ecx

; 660  :                     int cy2x0 = srcP[ 0*src_uv_pitch + 0];

  00795	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  00799	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  0079c	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  007a0	89 8d 1c ff ff
	ff		 mov	 DWORD PTR _cy2x0$14[ebp], ecx

; 661  :                     int cy4x0 = srcP[ 1*src_uv_pitch + 0];

  007a6	8b 55 a8	 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  007a9	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  007ac	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  007b0	89 8d 18 ff ff
	ff		 mov	 DWORD PTR _cy4x0$13[ebp], ecx

; 662  :                     int cy0x1 = srcP[-1*src_uv_pitch + cxplus];

  007b6	6b 55 a8 ff	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], -1
  007ba	03 95 24 ff ff
	ff		 add	 edx, DWORD PTR _cxplus$16[ebp]
  007c0	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  007c3	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  007c7	89 8d 14 ff ff
	ff		 mov	 DWORD PTR _cy0x1$12[ebp], ecx

; 663  :                     int cy2x1 = srcP[ 0*src_uv_pitch + cxplus];

  007cd	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  007d1	03 95 24 ff ff
	ff		 add	 edx, DWORD PTR _cxplus$16[ebp]
  007d7	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  007da	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  007de	89 8d 10 ff ff
	ff		 mov	 DWORD PTR _cy2x1$11[ebp], ecx

; 664  :                     int cy4x1 = srcP[ 1*src_uv_pitch + cxplus];

  007e4	8b 95 24 ff ff
	ff		 mov	 edx, DWORD PTR _cxplus$16[ebp]
  007ea	03 55 a8	 add	 edx, DWORD PTR _src_uv_pitch$[ebp]
  007ed	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  007f0	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  007f4	89 8d 0c ff ff
	ff		 mov	 DWORD PTR _cy4x1$10[ebp], ecx

; 665  : 
; 666  :                     int cy1x0 = (cy0x0 * 1 + cy2x0 * 3 + 2);

  007fa	6b 95 1c ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x0$14[ebp], 3
  00801	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR _cy0x0$15[ebp]
  00807	8d 4c 10 02	 lea	 ecx, DWORD PTR [eax+edx+2]
  0080b	89 8d 08 ff ff
	ff		 mov	 DWORD PTR _cy1x0$9[ebp], ecx

; 667  :                     int cy3x0 = (cy2x0 * 3 + cy4x0 * 1 + 2);

  00811	6b 95 1c ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x0$14[ebp], 3
  00818	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _cy4x0$13[ebp]
  0081e	8d 4c 02 02	 lea	 ecx, DWORD PTR [edx+eax+2]
  00822	89 8d 04 ff ff
	ff		 mov	 DWORD PTR _cy3x0$8[ebp], ecx

; 668  :                     int cy1x1 = (cy0x1 * 1 + cy2x1 * 3 + 2);

  00828	6b 95 10 ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x1$11[ebp], 3
  0082f	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _cy0x1$12[ebp]
  00835	8d 4c 10 02	 lea	 ecx, DWORD PTR [eax+edx+2]
  00839	89 8d 00 ff ff
	ff		 mov	 DWORD PTR _cy1x1$7[ebp], ecx

; 669  :                     int cy3x1 = (cy2x1 * 3 + cy4x1 * 1 + 2);

  0083f	6b 95 10 ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x1$11[ebp], 3
  00846	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _cy4x1$10[ebp]
  0084c	8d 4c 02 02	 lea	 ecx, DWORD PTR [edx+eax+2]
  00850	89 8d fc fe ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], ecx

; 670  :                     CHANGE_BIT_DEPTH_4(cy1x0, cy3x0, cy1x1, cy3x1, 2);

  00856	33 d2		 xor	 edx, edx
  00858	74 3e		 je	 SHORT $LN40@convert_yv
  0085a	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x0$9[ebp]
  00860	c1 e0 fd	 shl	 eax, -3			; fffffffdH
  00863	89 85 08 ff ff
	ff		 mov	 DWORD PTR _cy1x0$9[ebp], eax
  00869	8b 8d 04 ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x0$8[ebp]
  0086f	c1 e1 fd	 shl	 ecx, -3			; fffffffdH
  00872	89 8d 04 ff ff
	ff		 mov	 DWORD PTR _cy3x0$8[ebp], ecx
  00878	8b 95 00 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x1$7[ebp]
  0087e	c1 e2 fd	 shl	 edx, -3			; fffffffdH
  00881	89 95 00 ff ff
	ff		 mov	 DWORD PTR _cy1x1$7[ebp], edx
  00887	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR _cy3x1$6[ebp]
  0088d	c1 e0 fd	 shl	 eax, -3			; fffffffdH
  00890	89 85 fc fe ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], eax
  00896	eb 45		 jmp	 SHORT $LN41@convert_yv
$LN40@convert_yv:
  00898	b9 01 00 00 00	 mov	 ecx, 1
  0089d	85 c9		 test	 ecx, ecx
  0089f	74 3c		 je	 SHORT $LN41@convert_yv
  008a1	8b 95 08 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x0$9[ebp]
  008a7	c1 fa 03	 sar	 edx, 3
  008aa	89 95 08 ff ff
	ff		 mov	 DWORD PTR _cy1x0$9[ebp], edx
  008b0	8b 85 04 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$8[ebp]
  008b6	c1 f8 03	 sar	 eax, 3
  008b9	89 85 04 ff ff
	ff		 mov	 DWORD PTR _cy3x0$8[ebp], eax
  008bf	8b 8d 00 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x1$7[ebp]
  008c5	c1 f9 03	 sar	 ecx, 3
  008c8	89 8d 00 ff ff
	ff		 mov	 DWORD PTR _cy1x1$7[ebp], ecx
  008ce	8b 95 fc fe ff
	ff		 mov	 edx, DWORD PTR _cy3x1$6[ebp]
  008d4	c1 fa 03	 sar	 edx, 3
  008d7	89 95 fc fe ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], edx
$LN41@convert_yv:

; 671  : 
; 672  :                     dstC[0*dst_y_pitch   + 0] = (Tout)cy1x0;

  008dd	6b 45 e4 00	 imul	 eax, DWORD PTR _dst_y_pitch$[ebp], 0
  008e1	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$44[ebp]
  008e4	8a 95 08 ff ff
	ff		 mov	 dl, BYTE PTR _cy1x0$9[ebp]
  008ea	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 673  :                     dstC[0*dst_y_pitch   + 1] = (Tout)((cy1x0 + cy1x1 + 1) >> 1);

  008ed	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x1$7[ebp]
  008f3	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x0$9[ebp]
  008f9	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  008fd	d1 fa		 sar	 edx, 1
  008ff	6b 45 e4 00	 imul	 eax, DWORD PTR _dst_y_pitch$[ebp], 0
  00903	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$44[ebp]
  00906	88 54 01 01	 mov	 BYTE PTR [ecx+eax+1], dl

; 674  :                     dstC[1*dst_y_pitch   + 0] = (Tout)cy3x0;

  0090a	8b 55 94	 mov	 edx, DWORD PTR _dstC$44[ebp]
  0090d	03 55 e4	 add	 edx, DWORD PTR _dst_y_pitch$[ebp]
  00910	8a 85 04 ff ff
	ff		 mov	 al, BYTE PTR _cy3x0$8[ebp]
  00916	88 02		 mov	 BYTE PTR [edx], al

; 675  :                     dstC[1*dst_y_pitch   + 1] = (Tout)((cy3x0 + cy3x1 + 1) >> 1);

  00918	8b 8d fc fe ff
	ff		 mov	 ecx, DWORD PTR _cy3x1$6[ebp]
  0091e	8b 95 04 ff ff
	ff		 mov	 edx, DWORD PTR _cy3x0$8[ebp]
  00924	8d 44 0a 01	 lea	 eax, DWORD PTR [edx+ecx+1]
  00928	d1 f8		 sar	 eax, 1
  0092a	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$44[ebp]
  0092d	03 4d e4	 add	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  00930	88 41 01	 mov	 BYTE PTR [ecx+1], al

; 676  :                 }

  00933	e9 ec fd ff ff	 jmp	 $LN20@convert_yv
$LN31@convert_yv:

; 677  :             }
; 678  :         }

  00938	e9 52 f9 ff ff	 jmp	 $LN11@convert_yv
$LN12@convert_yv:

; 679  :     }

  0093d	e9 03 f9 ff ff	 jmp	 $LN8@convert_yv
$LN1@convert_yv:

; 680  : }

  00942	52		 push	 edx
  00943	8b cd		 mov	 ecx, ebp
  00945	50		 push	 eax
  00946	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN52@convert_yv
  0094c	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00951	58		 pop	 eax
  00952	5a		 pop	 edx
  00953	5f		 pop	 edi
  00954	5b		 pop	 ebx
  00955	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00958	33 cd		 xor	 ecx, ebp
  0095a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0095f	81 c4 2c 01 00
	00		 add	 esp, 300		; 0000012cH
  00965	3b ec		 cmp	 ebp, esp
  00967	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0096c	8b e5		 mov	 esp, ebp
  0096e	5d		 pop	 ebp
  0096f	c3		 ret	 0
$LN52@convert_yv:
  00970	01 00 00 00	 DD	 1
  00974	00 00 00 00	 DD	 $LN51@convert_yv
$LN51@convert_yv:
  00978	d4 ff ff ff	 DD	 -44			; ffffffd4H
  0097c	0c 00 00 00	 DD	 12			; 0000000cH
  00980	00 00 00 00	 DD	 $LN50@convert_yv
$LN50@convert_yv:
  00984	79		 DB	 121			; 00000079H
  00985	5f		 DB	 95			; 0000005fH
  00986	72		 DB	 114			; 00000072H
  00987	61		 DB	 97			; 00000061H
  00988	6e		 DB	 110			; 0000006eH
  00989	67		 DB	 103			; 00000067H
  0098a	65		 DB	 101			; 00000065H
  0098b	00		 DB	 0
??$convert_yv12_p_to_yuv444_c@G$08E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_p_to_yuv444_c<unsigned short,9,unsigned char,8,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yv12_09_p_to_yuv444@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_09_p_to_yuv444

; 825  : static void convert_yv12_09_p_to_yuv444(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 826  :     convert_yv12_p_to_yuv444_c<uint16_t, 9, uint8_t, 8, false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yv12_p_to_yuv444_c@G$08E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_p_to_yuv444_c<unsigned short,9,unsigned char,8,0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 827  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yv12_09_p_to_yuv444@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_09_p_to_yuv444
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
tv297 = -280						; size = 4
tv235 = -276						; size = 4
tv236 = -272						; size = 4
tv230 = -268						; size = 4
tv227 = -264						; size = 4
tv224 = -260						; size = 4
tv222 = -256						; size = 4
$T1 = -252						; size = 4
$T2 = -248						; size = 4
$T3 = -244						; size = 4
$T4 = -240						; size = 4
$T5 = -236						; size = 12
_cy3x1$6 = -224						; size = 4
_cy2x1$7 = -220						; size = 4
_cy1x1$8 = -216						; size = 4
_cy0x1$9 = -212						; size = 4
_sy5x1$10 = -208					; size = 4
_sy4x1$11 = -204					; size = 4
_sy3x1$12 = -200					; size = 4
_sy2x1$13 = -196					; size = 4
_sy1x1$14 = -192					; size = 4
_sy0x1$15 = -188					; size = 4
_cxplus$16 = -184					; size = 4
_x$17 = -180						; size = 4
_cy3x0$18 = -176					; size = 4
_cy2x0$19 = -172					; size = 4
_cy1x0$20 = -168					; size = 4
_cy0x0$21 = -164					; size = 4
_sy5x0$22 = -160					; size = 4
_sy4x0$23 = -156					; size = 4
_sy3x0$24 = -152					; size = 4
_sy2x0$25 = -148					; size = 4
_sy1x0$26 = -144					; size = 4
_sy0x0$27 = -140					; size = 4
_y_p3$28 = -136						; size = 4
_y_p2$29 = -132						; size = 4
_y_p1$30 = -128						; size = 4
_y_m1$31 = -124						; size = 4
_y_m2$32 = -120						; size = 4
_x_fin$33 = -116					; size = 4
_srcP$34 = -112						; size = 4
_dstC$35 = -108						; size = 4
_y$36 = -104						; size = 4
_dstLine$37 = -100					; size = 4
_srcCLine$38 = -96					; size = 4
_ic$39 = -92						; size = 4
_src_uv_pitch$ = -88					; size = 4
_uv_fin$ = -84						; size = 4
_x$40 = -80						; size = 4
_y$41 = -76						; size = 4
_y_width$42 = -72					; size = 4
_dstLine$43 = -68					; size = 4
_srcYLine$44 = -64					; size = 4
$T45 = -60						; size = 12
_y_range$ = -44						; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yv12_i_to_yuv444_c@G$09E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_i_to_yuv444_c<unsigned short,10,unsigned char,8,0>

; 683  : static void __forceinline convert_yv12_i_to_yuv444_c(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  00009	53		 push	 ebx
  0000a	57		 push	 edi
  0000b	8d bd e8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-280]
  00011	b9 46 00 00 00	 mov	 ecx, 70			; 00000046H
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 684  :     static_assert((sizeof(Tin)  == 1 && in_bit_depth  == 8) || (sizeof(Tin)  == 2 && 8 < in_bit_depth  && in_bit_depth  <= 16), "invalid input bit depth.");
; 685  :     static_assert((sizeof(Tout) == 1 && out_bit_depth == 8) || (sizeof(Tout) == 2 && 8 < out_bit_depth && out_bit_depth <= 16), "invalid output bit depth.");
; 686  :     const int crop_left   = crop[0];

  00027	b8 04 00 00 00	 mov	 eax, 4
  0002c	6b c8 00	 imul	 ecx, eax, 0
  0002f	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00032	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00035	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 687  :     const int crop_up     = crop[1];

  00038	b9 04 00 00 00	 mov	 ecx, 4
  0003d	c1 e1 00	 shl	 ecx, 0
  00040	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00043	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00046	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 688  :     const int crop_right  = crop[2];

  00049	b9 04 00 00 00	 mov	 ecx, 4
  0004e	d1 e1		 shl	 ecx, 1
  00050	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00053	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00056	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 689  :     const int crop_bottom = crop[3];

  00059	b9 04 00 00 00	 mov	 ecx, 4
  0005e	6b d1 03	 imul	 edx, ecx, 3
  00061	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00064	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00067	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 690  :     const int src_y_pitch = src_y_pitch_byte / sizeof(Tin);

  0006a	8b 55 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebp]
  0006d	d1 ea		 shr	 edx, 1
  0006f	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 691  :     const int dst_y_pitch = dst_y_pitch_byte / sizeof(Tout);

  00072	8b 45 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  00075	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 692  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00078	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0007b	51		 push	 ecx
  0007c	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0007f	52		 push	 edx
  00080	8b 45 20	 mov	 eax, DWORD PTR _height$[ebp]
  00083	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  00086	50		 push	 eax
  00087	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  0008a	51		 push	 ecx
  0008b	8d 95 14 ff ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  00091	52		 push	 edx
  00092	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00097	83 c4 14	 add	 esp, 20			; 00000014H
  0009a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009c	89 4d c4	 mov	 DWORD PTR $T45[ebp], ecx
  0009f	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a2	89 55 c8	 mov	 DWORD PTR $T45[ebp+4], edx
  000a5	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000a8	89 45 cc	 mov	 DWORD PTR $T45[ebp+8], eax
  000ab	8b 4d c4	 mov	 ecx, DWORD PTR $T45[ebp]
  000ae	89 4d d4	 mov	 DWORD PTR _y_range$[ebp], ecx
  000b1	8b 55 c8	 mov	 edx, DWORD PTR $T45[ebp+4]
  000b4	89 55 d8	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000b7	8b 45 cc	 mov	 eax, DWORD PTR $T45[ebp+8]
  000ba	89 45 dc	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 693  :     //Y
; 694  :     if (!uv_only) {

  000bd	b9 01 00 00 00	 mov	 ecx, 1
  000c2	85 c9		 test	 ecx, ecx
  000c4	0f 84 61 01 00
	00		 je	 $LN17@convert_yv

; 695  :         Tin *srcYLine = (Tin *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000ca	ba 04 00 00 00	 mov	 edx, 4
  000cf	6b c2 00	 imul	 eax, edx, 0
  000d2	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  000d5	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  000d9	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  000dc	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  000df	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  000e2	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  000e5	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  000e8	89 45 c0	 mov	 DWORD PTR _srcYLine$44[ebp], eax

; 696  :         Tout *dstLine = (Tout *)dst[0] + dst_y_pitch * y_range.start_dst;

  000eb	b9 04 00 00 00	 mov	 ecx, 4
  000f0	6b d1 00	 imul	 edx, ecx, 0
  000f3	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  000f6	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  000fa	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  000fd	03 04 11	 add	 eax, DWORD PTR [ecx+edx]
  00100	89 45 bc	 mov	 DWORD PTR _dstLine$43[ebp], eax

; 697  :         const int y_width = width - crop_right - crop_left;

  00103	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00106	2b 55 f0	 sub	 edx, DWORD PTR _crop_right$[ebp]
  00109	2b 55 f8	 sub	 edx, DWORD PTR _crop_left$[ebp]
  0010c	89 55 b8	 mov	 DWORD PTR _y_width$42[ebp], edx

; 698  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  0010f	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _y$41[ebp], 0
  00116	eb 1e		 jmp	 SHORT $LN4@convert_yv
$LN2@convert_yv:
  00118	8b 45 b4	 mov	 eax, DWORD PTR _y$41[ebp]
  0011b	83 c0 01	 add	 eax, 1
  0011e	89 45 b4	 mov	 DWORD PTR _y$41[ebp], eax
  00121	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  00124	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$44[ebp]
  00127	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  0012a	89 45 c0	 mov	 DWORD PTR _srcYLine$44[ebp], eax
  0012d	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$43[ebp]
  00130	03 4d e4	 add	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  00133	89 4d bc	 mov	 DWORD PTR _dstLine$43[ebp], ecx
$LN4@convert_yv:
  00136	8b 55 b4	 mov	 edx, DWORD PTR _y$41[ebp]
  00139	3b 55 dc	 cmp	 edx, DWORD PTR _y_range$[ebp+8]
  0013c	0f 8d e9 00 00
	00		 jge	 $LN17@convert_yv

; 699  :             if (in_bit_depth == out_bit_depth) {

  00142	33 c0		 xor	 eax, eax
  00144	74 1b		 je	 SHORT $LN18@convert_yv

; 700  :                 memcpy(dstLine, srcYLine, y_width * sizeof(Tin));

  00146	8b 4d b8	 mov	 ecx, DWORD PTR _y_width$42[ebp]
  00149	d1 e1		 shl	 ecx, 1
  0014b	51		 push	 ecx
  0014c	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$44[ebp]
  0014f	52		 push	 edx
  00150	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$43[ebp]
  00153	50		 push	 eax
  00154	e8 00 00 00 00	 call	 _memcpy
  00159	83 c4 0c	 add	 esp, 12			; 0000000cH

; 701  :             } else {

  0015c	e9 c5 00 00 00	 jmp	 $LN19@convert_yv
$LN18@convert_yv:

; 702  :                 for (int x = 0; x < y_width; x++) {

  00161	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _x$40[ebp], 0
  00168	eb 09		 jmp	 SHORT $LN7@convert_yv
$LN5@convert_yv:
  0016a	8b 4d b0	 mov	 ecx, DWORD PTR _x$40[ebp]
  0016d	83 c1 01	 add	 ecx, 1
  00170	89 4d b0	 mov	 DWORD PTR _x$40[ebp], ecx
$LN7@convert_yv:
  00173	8b 55 b0	 mov	 edx, DWORD PTR _x$40[ebp]
  00176	3b 55 b8	 cmp	 edx, DWORD PTR _y_width$42[ebp]
  00179	0f 8d a7 00 00
	00		 jge	 $LN19@convert_yv

; 703  :                     if (out_bit_depth > in_bit_depth) {

  0017f	33 c0		 xor	 eax, eax
  00181	74 42		 je	 SHORT $LN20@convert_yv

; 704  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) << std::max(out_bit_depth - in_bit_depth, 0));

  00183	c7 85 10 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], 0
  0018d	c7 85 0c ff ff
	ff fe ff ff ff	 mov	 DWORD PTR $T3[ebp], -2	; fffffffeH
  00197	8b 4d b0	 mov	 ecx, DWORD PTR _x$40[ebp]
  0019a	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$44[ebp]
  0019d	0f b7 1c 4a	 movzx	 ebx, WORD PTR [edx+ecx*2]
  001a1	8d 85 10 ff ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  001a7	50		 push	 eax
  001a8	8d 8d 0c ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  001ae	51		 push	 ecx
  001af	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  001b4	83 c4 08	 add	 esp, 8
  001b7	8b 08		 mov	 ecx, DWORD PTR [eax]
  001b9	d3 e3		 shl	 ebx, cl
  001bb	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$43[ebp]
  001be	03 55 b0	 add	 edx, DWORD PTR _x$40[ebp]
  001c1	88 1a		 mov	 BYTE PTR [edx], bl
  001c3	eb 5c		 jmp	 SHORT $LN21@convert_yv
$LN20@convert_yv:

; 705  :                     } else if (out_bit_depth < in_bit_depth) {

  001c5	b8 01 00 00 00	 mov	 eax, 1
  001ca	85 c0		 test	 eax, eax
  001cc	74 42		 je	 SHORT $LN22@convert_yv

; 706  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) >> std::max(in_bit_depth - out_bit_depth, 0));

  001ce	c7 85 08 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], 0
  001d8	c7 85 04 ff ff
	ff 02 00 00 00	 mov	 DWORD PTR $T1[ebp], 2
  001e2	8b 4d b0	 mov	 ecx, DWORD PTR _x$40[ebp]
  001e5	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$44[ebp]
  001e8	0f b7 1c 4a	 movzx	 ebx, WORD PTR [edx+ecx*2]
  001ec	8d 85 08 ff ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  001f2	50		 push	 eax
  001f3	8d 8d 04 ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  001f9	51		 push	 ecx
  001fa	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  001ff	83 c4 08	 add	 esp, 8
  00202	8b 08		 mov	 ecx, DWORD PTR [eax]
  00204	d3 fb		 sar	 ebx, cl
  00206	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$43[ebp]
  00209	03 55 b0	 add	 edx, DWORD PTR _x$40[ebp]
  0020c	88 1a		 mov	 BYTE PTR [edx], bl

; 707  :                     } else {

  0020e	eb 11		 jmp	 SHORT $LN21@convert_yv
$LN22@convert_yv:

; 708  :                         dstLine[x] = (Tout)srcYLine[x];

  00210	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$43[ebp]
  00213	03 45 b0	 add	 eax, DWORD PTR _x$40[ebp]
  00216	8b 4d b0	 mov	 ecx, DWORD PTR _x$40[ebp]
  00219	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$44[ebp]
  0021c	8a 0c 4a	 mov	 cl, BYTE PTR [edx+ecx*2]
  0021f	88 08		 mov	 BYTE PTR [eax], cl
$LN21@convert_yv:

; 709  :                     }
; 710  :                 }

  00221	e9 44 ff ff ff	 jmp	 $LN5@convert_yv
$LN19@convert_yv:

; 711  :             }
; 712  :         }

  00226	e9 ed fe ff ff	 jmp	 $LN2@convert_yv
$LN17@convert_yv:

; 713  :     }
; 714  :     //UV
; 715  :     const int uv_fin = height - crop_bottom;

  0022b	8b 55 20	 mov	 edx, DWORD PTR _height$[ebp]
  0022e	2b 55 ec	 sub	 edx, DWORD PTR _crop_bottom$[ebp]
  00231	89 55 ac	 mov	 DWORD PTR _uv_fin$[ebp], edx

; 716  :     const int src_uv_pitch = src_uv_pitch_byte / sizeof(Tin);

  00234	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  00237	d1 e8		 shr	 eax, 1
  00239	89 45 a8	 mov	 DWORD PTR _src_uv_pitch$[ebp], eax

; 717  :     for (int ic = 1; ic < 3; ic++) {

  0023c	c7 45 a4 01 00
	00 00		 mov	 DWORD PTR _ic$39[ebp], 1
  00243	eb 09		 jmp	 SHORT $LN10@convert_yv
$LN8@convert_yv:
  00245	8b 4d a4	 mov	 ecx, DWORD PTR _ic$39[ebp]
  00248	83 c1 01	 add	 ecx, 1
  0024b	89 4d a4	 mov	 DWORD PTR _ic$39[ebp], ecx
$LN10@convert_yv:
  0024e	83 7d a4 03	 cmp	 DWORD PTR _ic$39[ebp], 3
  00252	0f 8d ac 05 00
	00		 jge	 $LN1@convert_yv

; 718  :         Tin *srcCLine = (Tin *)src[ic] + (((src_uv_pitch * y_range.start_src) + crop_left) >> 1);

  00258	8b 55 a8	 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  0025b	0f af 55 d4	 imul	 edx, DWORD PTR _y_range$[ebp]
  0025f	03 55 f8	 add	 edx, DWORD PTR _crop_left$[ebp]
  00262	d1 fa		 sar	 edx, 1
  00264	8b 45 a4	 mov	 eax, DWORD PTR _ic$39[ebp]
  00267	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  0026a	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  0026d	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00270	89 4d a0	 mov	 DWORD PTR _srcCLine$38[ebp], ecx

; 719  :         Tout *dstLine = (Tout *)dst[ic] + dst_y_pitch * y_range.start_dst;

  00273	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  00276	0f af 55 d8	 imul	 edx, DWORD PTR _y_range$[ebp+4]
  0027a	8b 45 a4	 mov	 eax, DWORD PTR _ic$39[ebp]
  0027d	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  00280	03 14 81	 add	 edx, DWORD PTR [ecx+eax*4]
  00283	89 55 9c	 mov	 DWORD PTR _dstLine$37[ebp], edx

; 720  :         for (int y = 0; y < y_range.len; y += 4, srcCLine += src_uv_pitch * 2, dstLine += dst_y_pitch * 4) {

  00286	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _y$36[ebp], 0
  0028d	eb 23		 jmp	 SHORT $LN13@convert_yv
$LN11@convert_yv:
  0028f	8b 55 98	 mov	 edx, DWORD PTR _y$36[ebp]
  00292	83 c2 04	 add	 edx, 4
  00295	89 55 98	 mov	 DWORD PTR _y$36[ebp], edx
  00298	8b 45 a8	 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  0029b	d1 e0		 shl	 eax, 1
  0029d	8b 4d a0	 mov	 ecx, DWORD PTR _srcCLine$38[ebp]
  002a0	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  002a3	89 55 a0	 mov	 DWORD PTR _srcCLine$38[ebp], edx
  002a6	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  002a9	8b 4d 9c	 mov	 ecx, DWORD PTR _dstLine$37[ebp]
  002ac	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  002af	89 55 9c	 mov	 DWORD PTR _dstLine$37[ebp], edx
$LN13@convert_yv:
  002b2	8b 45 98	 mov	 eax, DWORD PTR _y$36[ebp]
  002b5	3b 45 dc	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  002b8	0f 8d 41 05 00
	00		 jge	 $LN12@convert_yv

; 721  :             Tout *dstC = dstLine;

  002be	8b 4d 9c	 mov	 ecx, DWORD PTR _dstLine$37[ebp]
  002c1	89 4d 94	 mov	 DWORD PTR _dstC$35[ebp], ecx

; 722  :             Tin *srcP = srcCLine;

  002c4	8b 55 a0	 mov	 edx, DWORD PTR _srcCLine$38[ebp]
  002c7	89 55 90	 mov	 DWORD PTR _srcP$34[ebp], edx

; 723  :             const int x_fin = width - crop_right - crop_left;

  002ca	8b 45 10	 mov	 eax, DWORD PTR _width$[ebp]
  002cd	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  002d0	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  002d3	89 45 8c	 mov	 DWORD PTR _x_fin$33[ebp], eax

; 724  : 
; 725  :             int y_m2 = (y >= 4) ? -2 : 0;

  002d6	83 7d 98 04	 cmp	 DWORD PTR _y$36[ebp], 4
  002da	7c 0c		 jl	 SHORT $LN31@convert_yv
  002dc	c7 85 00 ff ff
	ff fe ff ff ff	 mov	 DWORD PTR tv222[ebp], -2 ; fffffffeH
  002e6	eb 0a		 jmp	 SHORT $LN32@convert_yv
$LN31@convert_yv:
  002e8	c7 85 00 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv222[ebp], 0
$LN32@convert_yv:
  002f2	8b 8d 00 ff ff
	ff		 mov	 ecx, DWORD PTR tv222[ebp]
  002f8	89 4d 88	 mov	 DWORD PTR _y_m2$32[ebp], ecx

; 726  :             int y_m1 = (y >= 2) ? -1 : 1;

  002fb	83 7d 98 02	 cmp	 DWORD PTR _y$36[ebp], 2
  002ff	7c 0c		 jl	 SHORT $LN33@convert_yv
  00301	c7 85 fc fe ff
	ff ff ff ff ff	 mov	 DWORD PTR tv224[ebp], -1
  0030b	eb 0a		 jmp	 SHORT $LN34@convert_yv
$LN33@convert_yv:
  0030d	c7 85 fc fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv224[ebp], 1
$LN34@convert_yv:
  00317	8b 95 fc fe ff
	ff		 mov	 edx, DWORD PTR tv224[ebp]
  0031d	89 55 84	 mov	 DWORD PTR _y_m1$31[ebp], edx

; 727  :             int y_p1 = (y < uv_fin - 2) ? 1 : -1;

  00320	8b 45 ac	 mov	 eax, DWORD PTR _uv_fin$[ebp]
  00323	83 e8 02	 sub	 eax, 2
  00326	39 45 98	 cmp	 DWORD PTR _y$36[ebp], eax
  00329	7d 0c		 jge	 SHORT $LN35@convert_yv
  0032b	c7 85 f8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv227[ebp], 1
  00335	eb 0a		 jmp	 SHORT $LN36@convert_yv
$LN35@convert_yv:
  00337	c7 85 f8 fe ff
	ff ff ff ff ff	 mov	 DWORD PTR tv227[ebp], -1
$LN36@convert_yv:
  00341	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR tv227[ebp]
  00347	89 4d 80	 mov	 DWORD PTR _y_p1$30[ebp], ecx

; 728  :             int y_p2 = (y < uv_fin - 4) ? 2 :  0;

  0034a	8b 55 ac	 mov	 edx, DWORD PTR _uv_fin$[ebp]
  0034d	83 ea 04	 sub	 edx, 4
  00350	39 55 98	 cmp	 DWORD PTR _y$36[ebp], edx
  00353	7d 0c		 jge	 SHORT $LN37@convert_yv
  00355	c7 85 f4 fe ff
	ff 02 00 00 00	 mov	 DWORD PTR tv230[ebp], 2
  0035f	eb 0a		 jmp	 SHORT $LN38@convert_yv
$LN37@convert_yv:
  00361	c7 85 f4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv230[ebp], 0
$LN38@convert_yv:
  0036b	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR tv230[ebp]
  00371	89 85 7c ff ff
	ff		 mov	 DWORD PTR _y_p2$29[ebp], eax

; 729  :             int y_p3 = (y < uv_fin - 6) ? 3 : ((y < uv_fin - 2) ? 1 : -1);

  00377	8b 4d ac	 mov	 ecx, DWORD PTR _uv_fin$[ebp]
  0037a	83 e9 06	 sub	 ecx, 6
  0037d	39 4d 98	 cmp	 DWORD PTR _y$36[ebp], ecx
  00380	7d 0c		 jge	 SHORT $LN41@convert_yv
  00382	c7 85 f0 fe ff
	ff 03 00 00 00	 mov	 DWORD PTR tv236[ebp], 3
  0038c	eb 2d		 jmp	 SHORT $LN42@convert_yv
$LN41@convert_yv:
  0038e	8b 55 ac	 mov	 edx, DWORD PTR _uv_fin$[ebp]
  00391	83 ea 02	 sub	 edx, 2
  00394	39 55 98	 cmp	 DWORD PTR _y$36[ebp], edx
  00397	7d 0c		 jge	 SHORT $LN39@convert_yv
  00399	c7 85 ec fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv235[ebp], 1
  003a3	eb 0a		 jmp	 SHORT $LN40@convert_yv
$LN39@convert_yv:
  003a5	c7 85 ec fe ff
	ff ff ff ff ff	 mov	 DWORD PTR tv235[ebp], -1
$LN40@convert_yv:
  003af	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR tv235[ebp]
  003b5	89 85 f0 fe ff
	ff		 mov	 DWORD PTR tv236[ebp], eax
$LN42@convert_yv:
  003bb	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR tv236[ebp]
  003c1	89 8d 78 ff ff
	ff		 mov	 DWORD PTR _y_p3$28[ebp], ecx

; 730  : 
; 731  :             int sy0x0 = srcP[y_m2*src_uv_pitch + 0];

  003c7	8b 55 88	 mov	 edx, DWORD PTR _y_m2$32[ebp]
  003ca	0f af 55 a8	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp]
  003ce	8b 45 90	 mov	 eax, DWORD PTR _srcP$34[ebp]
  003d1	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  003d5	89 8d 74 ff ff
	ff		 mov	 DWORD PTR _sy0x0$27[ebp], ecx

; 732  :             int sy1x0 = srcP[y_m1*src_uv_pitch + 0];

  003db	8b 55 84	 mov	 edx, DWORD PTR _y_m1$31[ebp]
  003de	0f af 55 a8	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp]
  003e2	8b 45 90	 mov	 eax, DWORD PTR _srcP$34[ebp]
  003e5	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  003e9	89 8d 70 ff ff
	ff		 mov	 DWORD PTR _sy1x0$26[ebp], ecx

; 733  :             int sy2x0 = srcP[   0*src_uv_pitch + 0];

  003ef	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  003f3	8b 45 90	 mov	 eax, DWORD PTR _srcP$34[ebp]
  003f6	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  003fa	89 8d 6c ff ff
	ff		 mov	 DWORD PTR _sy2x0$25[ebp], ecx

; 734  :             int sy3x0 = srcP[y_p1*src_uv_pitch + 0];

  00400	8b 55 80	 mov	 edx, DWORD PTR _y_p1$30[ebp]
  00403	0f af 55 a8	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp]
  00407	8b 45 90	 mov	 eax, DWORD PTR _srcP$34[ebp]
  0040a	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  0040e	89 8d 68 ff ff
	ff		 mov	 DWORD PTR _sy3x0$24[ebp], ecx

; 735  :             int sy4x0 = srcP[y_p2*src_uv_pitch + 0];

  00414	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR _y_p2$29[ebp]
  0041a	0f af 55 a8	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp]
  0041e	8b 45 90	 mov	 eax, DWORD PTR _srcP$34[ebp]
  00421	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  00425	89 8d 64 ff ff
	ff		 mov	 DWORD PTR _sy4x0$23[ebp], ecx

; 736  :             int sy5x0 = srcP[y_p3*src_uv_pitch + 0];

  0042b	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _y_p3$28[ebp]
  00431	0f af 55 a8	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp]
  00435	8b 45 90	 mov	 eax, DWORD PTR _srcP$34[ebp]
  00438	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  0043c	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _sy5x0$22[ebp], ecx

; 737  : 
; 738  :             int cy0x0 = (sy0x0 * 1 + sy2x0 * 7 + 4);

  00442	6b 95 6c ff ff
	ff 07		 imul	 edx, DWORD PTR _sy2x0$25[ebp], 7
  00449	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _sy0x0$27[ebp]
  0044f	8d 4c 10 04	 lea	 ecx, DWORD PTR [eax+edx+4]
  00453	89 8d 5c ff ff
	ff		 mov	 DWORD PTR _cy0x0$21[ebp], ecx

; 739  :             int cy1x0 = (sy1x0 * 3 + sy3x0 * 5 + 4);

  00459	6b 95 70 ff ff
	ff 03		 imul	 edx, DWORD PTR _sy1x0$26[ebp], 3
  00460	6b 85 68 ff ff
	ff 05		 imul	 eax, DWORD PTR _sy3x0$24[ebp], 5
  00467	8d 4c 02 04	 lea	 ecx, DWORD PTR [edx+eax+4]
  0046b	89 8d 58 ff ff
	ff		 mov	 DWORD PTR _cy1x0$20[ebp], ecx

; 740  :             int cy2x0 = (sy2x0 * 5 + sy4x0 * 3 + 4);

  00471	6b 95 6c ff ff
	ff 05		 imul	 edx, DWORD PTR _sy2x0$25[ebp], 5
  00478	6b 85 64 ff ff
	ff 03		 imul	 eax, DWORD PTR _sy4x0$23[ebp], 3
  0047f	8d 4c 02 04	 lea	 ecx, DWORD PTR [edx+eax+4]
  00483	89 8d 54 ff ff
	ff		 mov	 DWORD PTR _cy2x0$19[ebp], ecx

; 741  :             int cy3x0 = (sy3x0 * 7 + sy5x0 * 1 + 4);

  00489	6b 95 68 ff ff
	ff 07		 imul	 edx, DWORD PTR _sy3x0$24[ebp], 7
  00490	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _sy5x0$22[ebp]
  00496	8d 4c 02 04	 lea	 ecx, DWORD PTR [edx+eax+4]
  0049a	89 8d 50 ff ff
	ff		 mov	 DWORD PTR _cy3x0$18[ebp], ecx

; 742  :             CHANGE_BIT_DEPTH_4(cy0x0, cy1x0, cy2x0, cy3x0, 3);

  004a0	33 d2		 xor	 edx, edx
  004a2	74 3e		 je	 SHORT $LN24@convert_yv
  004a4	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _cy0x0$21[ebp]
  004aa	c1 e0 fb	 shl	 eax, -5			; fffffffbH
  004ad	89 85 5c ff ff
	ff		 mov	 DWORD PTR _cy0x0$21[ebp], eax
  004b3	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x0$20[ebp]
  004b9	c1 e1 fb	 shl	 ecx, -5			; fffffffbH
  004bc	89 8d 58 ff ff
	ff		 mov	 DWORD PTR _cy1x0$20[ebp], ecx
  004c2	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR _cy2x0$19[ebp]
  004c8	c1 e2 fb	 shl	 edx, -5			; fffffffbH
  004cb	89 95 54 ff ff
	ff		 mov	 DWORD PTR _cy2x0$19[ebp], edx
  004d1	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$18[ebp]
  004d7	c1 e0 fb	 shl	 eax, -5			; fffffffbH
  004da	89 85 50 ff ff
	ff		 mov	 DWORD PTR _cy3x0$18[ebp], eax
  004e0	eb 45		 jmp	 SHORT $LN25@convert_yv
$LN24@convert_yv:
  004e2	b9 01 00 00 00	 mov	 ecx, 1
  004e7	85 c9		 test	 ecx, ecx
  004e9	74 3c		 je	 SHORT $LN25@convert_yv
  004eb	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR _cy0x0$21[ebp]
  004f1	c1 fa 05	 sar	 edx, 5
  004f4	89 95 5c ff ff
	ff		 mov	 DWORD PTR _cy0x0$21[ebp], edx
  004fa	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x0$20[ebp]
  00500	c1 f8 05	 sar	 eax, 5
  00503	89 85 58 ff ff
	ff		 mov	 DWORD PTR _cy1x0$20[ebp], eax
  00509	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _cy2x0$19[ebp]
  0050f	c1 f9 05	 sar	 ecx, 5
  00512	89 8d 54 ff ff
	ff		 mov	 DWORD PTR _cy2x0$19[ebp], ecx
  00518	8b 95 50 ff ff
	ff		 mov	 edx, DWORD PTR _cy3x0$18[ebp]
  0051e	c1 fa 05	 sar	 edx, 5
  00521	89 95 50 ff ff
	ff		 mov	 DWORD PTR _cy3x0$18[ebp], edx
$LN25@convert_yv:

; 743  : 
; 744  :             for (int x = 0; x < x_fin; x += 2, dstC += 2, srcP++) {

  00527	c7 85 4c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _x$17[ebp], 0
  00531	eb 21		 jmp	 SHORT $LN16@convert_yv
$LN14@convert_yv:
  00533	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _x$17[ebp]
  00539	83 c0 02	 add	 eax, 2
  0053c	89 85 4c ff ff
	ff		 mov	 DWORD PTR _x$17[ebp], eax
  00542	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$35[ebp]
  00545	83 c1 02	 add	 ecx, 2
  00548	89 4d 94	 mov	 DWORD PTR _dstC$35[ebp], ecx
  0054b	8b 55 90	 mov	 edx, DWORD PTR _srcP$34[ebp]
  0054e	83 c2 02	 add	 edx, 2
  00551	89 55 90	 mov	 DWORD PTR _srcP$34[ebp], edx
$LN16@convert_yv:
  00554	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _x$17[ebp]
  0055a	3b 45 8c	 cmp	 eax, DWORD PTR _x_fin$33[ebp]
  0055d	0f 8d 97 02 00
	00		 jge	 $LN15@convert_yv

; 745  :                 int cxplus = (x + 2 < x_fin);

  00563	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _x$17[ebp]
  00569	83 c1 02	 add	 ecx, 2
  0056c	3b 4d 8c	 cmp	 ecx, DWORD PTR _x_fin$33[ebp]
  0056f	7d 0c		 jge	 SHORT $LN43@convert_yv
  00571	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv297[ebp], 1
  0057b	eb 0a		 jmp	 SHORT $LN44@convert_yv
$LN43@convert_yv:
  0057d	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv297[ebp], 0
$LN44@convert_yv:
  00587	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR tv297[ebp]
  0058d	89 95 48 ff ff
	ff		 mov	 DWORD PTR _cxplus$16[ebp], edx

; 746  :                 int sy0x1 = srcP[y_m2*src_uv_pitch + cxplus];

  00593	8b 45 88	 mov	 eax, DWORD PTR _y_m2$32[ebp]
  00596	0f af 45 a8	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp]
  0059a	03 85 48 ff ff
	ff		 add	 eax, DWORD PTR _cxplus$16[ebp]
  005a0	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  005a3	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  005a7	89 95 44 ff ff
	ff		 mov	 DWORD PTR _sy0x1$15[ebp], edx

; 747  :                 int sy1x1 = srcP[y_m1*src_uv_pitch + cxplus];

  005ad	8b 45 84	 mov	 eax, DWORD PTR _y_m1$31[ebp]
  005b0	0f af 45 a8	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp]
  005b4	03 85 48 ff ff
	ff		 add	 eax, DWORD PTR _cxplus$16[ebp]
  005ba	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  005bd	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  005c1	89 95 40 ff ff
	ff		 mov	 DWORD PTR _sy1x1$14[ebp], edx

; 748  :                 int sy2x1 = srcP[   0*src_uv_pitch + cxplus];

  005c7	6b 45 a8 00	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp], 0
  005cb	03 85 48 ff ff
	ff		 add	 eax, DWORD PTR _cxplus$16[ebp]
  005d1	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  005d4	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  005d8	89 95 3c ff ff
	ff		 mov	 DWORD PTR _sy2x1$13[ebp], edx

; 749  :                 int sy3x1 = srcP[y_p1*src_uv_pitch + cxplus];

  005de	8b 45 80	 mov	 eax, DWORD PTR _y_p1$30[ebp]
  005e1	0f af 45 a8	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp]
  005e5	03 85 48 ff ff
	ff		 add	 eax, DWORD PTR _cxplus$16[ebp]
  005eb	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  005ee	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  005f2	89 95 38 ff ff
	ff		 mov	 DWORD PTR _sy3x1$12[ebp], edx

; 750  :                 int sy4x1 = srcP[y_p2*src_uv_pitch + cxplus];

  005f8	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _y_p2$29[ebp]
  005fe	0f af 45 a8	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp]
  00602	03 85 48 ff ff
	ff		 add	 eax, DWORD PTR _cxplus$16[ebp]
  00608	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  0060b	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  0060f	89 95 34 ff ff
	ff		 mov	 DWORD PTR _sy4x1$11[ebp], edx

; 751  :                 int sy5x1 = srcP[y_p3*src_uv_pitch + cxplus];

  00615	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _y_p3$28[ebp]
  0061b	0f af 45 a8	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp]
  0061f	03 85 48 ff ff
	ff		 add	 eax, DWORD PTR _cxplus$16[ebp]
  00625	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  00628	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  0062c	89 95 30 ff ff
	ff		 mov	 DWORD PTR _sy5x1$10[ebp], edx

; 752  : 
; 753  :                 int cy0x1 = (sy0x1 * 1 + sy2x1 * 7 + 4);

  00632	6b 85 3c ff ff
	ff 07		 imul	 eax, DWORD PTR _sy2x1$13[ebp], 7
  00639	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _sy0x1$15[ebp]
  0063f	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00643	89 95 2c ff ff
	ff		 mov	 DWORD PTR _cy0x1$9[ebp], edx

; 754  :                 int cy1x1 = (sy1x1 * 3 + sy3x1 * 5 + 4);

  00649	6b 85 40 ff ff
	ff 03		 imul	 eax, DWORD PTR _sy1x1$14[ebp], 3
  00650	6b 8d 38 ff ff
	ff 05		 imul	 ecx, DWORD PTR _sy3x1$12[ebp], 5
  00657	8d 54 08 04	 lea	 edx, DWORD PTR [eax+ecx+4]
  0065b	89 95 28 ff ff
	ff		 mov	 DWORD PTR _cy1x1$8[ebp], edx

; 755  :                 int cy2x1 = (sy2x1 * 5 + sy4x1 * 3 + 4);

  00661	6b 85 3c ff ff
	ff 05		 imul	 eax, DWORD PTR _sy2x1$13[ebp], 5
  00668	6b 8d 34 ff ff
	ff 03		 imul	 ecx, DWORD PTR _sy4x1$11[ebp], 3
  0066f	8d 54 08 04	 lea	 edx, DWORD PTR [eax+ecx+4]
  00673	89 95 24 ff ff
	ff		 mov	 DWORD PTR _cy2x1$7[ebp], edx

; 756  :                 int cy3x1 = (sy3x1 * 7 + sy5x1 * 1 + 4);

  00679	6b 85 38 ff ff
	ff 07		 imul	 eax, DWORD PTR _sy3x1$12[ebp], 7
  00680	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR _sy5x1$10[ebp]
  00686	8d 54 08 04	 lea	 edx, DWORD PTR [eax+ecx+4]
  0068a	89 95 20 ff ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], edx

; 757  :                 CHANGE_BIT_DEPTH_4(cy0x1, cy1x1, cy2x1, cy3x1, 3);

  00690	33 c0		 xor	 eax, eax
  00692	74 3e		 je	 SHORT $LN27@convert_yv
  00694	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR _cy0x1$9[ebp]
  0069a	c1 e1 fb	 shl	 ecx, -5			; fffffffbH
  0069d	89 8d 2c ff ff
	ff		 mov	 DWORD PTR _cy0x1$9[ebp], ecx
  006a3	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x1$8[ebp]
  006a9	c1 e2 fb	 shl	 edx, -5			; fffffffbH
  006ac	89 95 28 ff ff
	ff		 mov	 DWORD PTR _cy1x1$8[ebp], edx
  006b2	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _cy2x1$7[ebp]
  006b8	c1 e0 fb	 shl	 eax, -5			; fffffffbH
  006bb	89 85 24 ff ff
	ff		 mov	 DWORD PTR _cy2x1$7[ebp], eax
  006c1	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x1$6[ebp]
  006c7	c1 e1 fb	 shl	 ecx, -5			; fffffffbH
  006ca	89 8d 20 ff ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], ecx
  006d0	eb 45		 jmp	 SHORT $LN28@convert_yv
$LN27@convert_yv:
  006d2	ba 01 00 00 00	 mov	 edx, 1
  006d7	85 d2		 test	 edx, edx
  006d9	74 3c		 je	 SHORT $LN28@convert_yv
  006db	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR _cy0x1$9[ebp]
  006e1	c1 f8 05	 sar	 eax, 5
  006e4	89 85 2c ff ff
	ff		 mov	 DWORD PTR _cy0x1$9[ebp], eax
  006ea	8b 8d 28 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x1$8[ebp]
  006f0	c1 f9 05	 sar	 ecx, 5
  006f3	89 8d 28 ff ff
	ff		 mov	 DWORD PTR _cy1x1$8[ebp], ecx
  006f9	8b 95 24 ff ff
	ff		 mov	 edx, DWORD PTR _cy2x1$7[ebp]
  006ff	c1 fa 05	 sar	 edx, 5
  00702	89 95 24 ff ff
	ff		 mov	 DWORD PTR _cy2x1$7[ebp], edx
  00708	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x1$6[ebp]
  0070e	c1 f8 05	 sar	 eax, 5
  00711	89 85 20 ff ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], eax
$LN28@convert_yv:

; 758  : 
; 759  :                 dstC[0*dst_y_pitch   + 0] = (Tout)cy0x0;

  00717	6b 4d e4 00	 imul	 ecx, DWORD PTR _dst_y_pitch$[ebp], 0
  0071b	8b 55 94	 mov	 edx, DWORD PTR _dstC$35[ebp]
  0071e	8a 85 5c ff ff
	ff		 mov	 al, BYTE PTR _cy0x0$21[ebp]
  00724	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 760  :                 dstC[0*dst_y_pitch   + 1] = (Tout)((cy0x0 + cy0x1 + 1) >> 1);

  00727	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR _cy0x1$9[ebp]
  0072d	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR _cy0x0$21[ebp]
  00733	8d 44 0a 01	 lea	 eax, DWORD PTR [edx+ecx+1]
  00737	d1 f8		 sar	 eax, 1
  00739	6b 4d e4 00	 imul	 ecx, DWORD PTR _dst_y_pitch$[ebp], 0
  0073d	8b 55 94	 mov	 edx, DWORD PTR _dstC$35[ebp]
  00740	88 44 0a 01	 mov	 BYTE PTR [edx+ecx+1], al

; 761  :                 dstC[1*dst_y_pitch   + 0] = (Tout)cy1x0;

  00744	8b 45 94	 mov	 eax, DWORD PTR _dstC$35[ebp]
  00747	03 45 e4	 add	 eax, DWORD PTR _dst_y_pitch$[ebp]
  0074a	8a 8d 58 ff ff
	ff		 mov	 cl, BYTE PTR _cy1x0$20[ebp]
  00750	88 08		 mov	 BYTE PTR [eax], cl

; 762  :                 dstC[1*dst_y_pitch   + 1] = (Tout)((cy1x0 + cy1x1 + 1) >> 1);

  00752	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x1$8[ebp]
  00758	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x0$20[ebp]
  0075e	8d 4c 10 01	 lea	 ecx, DWORD PTR [eax+edx+1]
  00762	d1 f9		 sar	 ecx, 1
  00764	8b 55 94	 mov	 edx, DWORD PTR _dstC$35[ebp]
  00767	03 55 e4	 add	 edx, DWORD PTR _dst_y_pitch$[ebp]
  0076a	88 4a 01	 mov	 BYTE PTR [edx+1], cl

; 763  :                 dstC[2*dst_y_pitch   + 0] = (Tout)cy2x0;

  0076d	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  00770	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$35[ebp]
  00773	8a 95 54 ff ff
	ff		 mov	 dl, BYTE PTR _cy2x0$19[ebp]
  00779	88 14 41	 mov	 BYTE PTR [ecx+eax*2], dl

; 764  :                 dstC[2*dst_y_pitch   + 1] = (Tout)((cy2x0 + cy2x1 + 1) >> 1);

  0077c	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _cy2x1$7[ebp]
  00782	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _cy2x0$19[ebp]
  00788	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  0078c	d1 fa		 sar	 edx, 1
  0078e	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  00791	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$35[ebp]
  00794	88 54 41 01	 mov	 BYTE PTR [ecx+eax*2+1], dl

; 765  :                 dstC[3*dst_y_pitch   + 0] = (Tout)cy3x0;

  00798	6b 55 e4 03	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 3
  0079c	8b 45 94	 mov	 eax, DWORD PTR _dstC$35[ebp]
  0079f	8a 8d 50 ff ff
	ff		 mov	 cl, BYTE PTR _cy3x0$18[ebp]
  007a5	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 766  :                 dstC[3*dst_y_pitch   + 1] = (Tout)((cy3x0 + cy3x1 + 1) >> 1);

  007a8	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR _cy3x1$6[ebp]
  007ae	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$18[ebp]
  007b4	8d 4c 10 01	 lea	 ecx, DWORD PTR [eax+edx+1]
  007b8	d1 f9		 sar	 ecx, 1
  007ba	6b 55 e4 03	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 3
  007be	8b 45 94	 mov	 eax, DWORD PTR _dstC$35[ebp]
  007c1	88 4c 10 01	 mov	 BYTE PTR [eax+edx+1], cl

; 767  : 
; 768  :                 cy0x0 = cy0x1;

  007c5	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR _cy0x1$9[ebp]
  007cb	89 8d 5c ff ff
	ff		 mov	 DWORD PTR _cy0x0$21[ebp], ecx

; 769  :                 cy1x0 = cy1x1;

  007d1	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x1$8[ebp]
  007d7	89 95 58 ff ff
	ff		 mov	 DWORD PTR _cy1x0$20[ebp], edx

; 770  :                 cy2x0 = cy2x1;

  007dd	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _cy2x1$7[ebp]
  007e3	89 85 54 ff ff
	ff		 mov	 DWORD PTR _cy2x0$19[ebp], eax

; 771  :                 cy3x0 = cy3x1;

  007e9	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x1$6[ebp]
  007ef	89 8d 50 ff ff
	ff		 mov	 DWORD PTR _cy3x0$18[ebp], ecx

; 772  :             }

  007f5	e9 39 fd ff ff	 jmp	 $LN14@convert_yv
$LN15@convert_yv:

; 773  :         }

  007fa	e9 90 fa ff ff	 jmp	 $LN11@convert_yv
$LN12@convert_yv:

; 774  :     }

  007ff	e9 41 fa ff ff	 jmp	 $LN8@convert_yv
$LN1@convert_yv:

; 775  : }

  00804	52		 push	 edx
  00805	8b cd		 mov	 ecx, ebp
  00807	50		 push	 eax
  00808	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN47@convert_yv
  0080e	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00813	58		 pop	 eax
  00814	5a		 pop	 edx
  00815	5f		 pop	 edi
  00816	5b		 pop	 ebx
  00817	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0081a	33 cd		 xor	 ecx, ebp
  0081c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00821	81 c4 18 01 00
	00		 add	 esp, 280		; 00000118H
  00827	3b ec		 cmp	 ebp, esp
  00829	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0082e	8b e5		 mov	 esp, ebp
  00830	5d		 pop	 ebp
  00831	c3		 ret	 0
  00832	66 90		 npad	 2
$LN47@convert_yv:
  00834	01 00 00 00	 DD	 1
  00838	00 00 00 00	 DD	 $LN46@convert_yv
$LN46@convert_yv:
  0083c	d4 ff ff ff	 DD	 -44			; ffffffd4H
  00840	0c 00 00 00	 DD	 12			; 0000000cH
  00844	00 00 00 00	 DD	 $LN45@convert_yv
$LN45@convert_yv:
  00848	79		 DB	 121			; 00000079H
  00849	5f		 DB	 95			; 0000005fH
  0084a	72		 DB	 114			; 00000072H
  0084b	61		 DB	 97			; 00000061H
  0084c	6e		 DB	 110			; 0000006eH
  0084d	67		 DB	 103			; 00000067H
  0084e	65		 DB	 101			; 00000065H
  0084f	00		 DB	 0
??$convert_yv12_i_to_yuv444_c@G$09E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_i_to_yuv444_c<unsigned short,10,unsigned char,8,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yv12_10_i_to_yuv444@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_10_i_to_yuv444

; 821  : static void convert_yv12_10_i_to_yuv444(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 822  :     convert_yv12_i_to_yuv444_c<uint16_t, 10, uint8_t, 8, false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yv12_i_to_yuv444_c@G$09E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_i_to_yuv444_c<unsigned short,10,unsigned char,8,0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 823  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yv12_10_i_to_yuv444@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_10_i_to_yuv444
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
tv427 = -300						; size = 4
tv312 = -296						; size = 4
tv227 = -292						; size = 4
$T1 = -288						; size = 4
$T2 = -284						; size = 4
$T3 = -280						; size = 4
$T4 = -276						; size = 4
$T5 = -272						; size = 12
_cy3x1$6 = -260						; size = 4
_cy1x1$7 = -256						; size = 4
_cy3x0$8 = -252						; size = 4
_cy1x0$9 = -248						; size = 4
_cy4x1$10 = -244					; size = 4
_cy2x1$11 = -240					; size = 4
_cy0x1$12 = -236					; size = 4
_cy4x0$13 = -232					; size = 4
_cy2x0$14 = -228					; size = 4
_cy0x0$15 = -224					; size = 4
_cxplus$16 = -220					; size = 4
_x$17 = -216						; size = 4
_cy3x1$18 = -212					; size = 4
_cy1x1$19 = -208					; size = 4
_cy3x0$20 = -204					; size = 4
_cy1x0$21 = -200					; size = 4
_cy4x1$22 = -196					; size = 4
_cy2x1$23 = -192					; size = 4
_cy0x1$24 = -188					; size = 4
_cy4x0$25 = -184					; size = 4
_cy2x0$26 = -180					; size = 4
_cy0x0$27 = -176					; size = 4
_cxplus$28 = -172					; size = 4
_x$29 = -168						; size = 4
_cy3x1$30 = -164					; size = 4
_cy1x1$31 = -160					; size = 4
_cy3x0$32 = -156					; size = 4
_cy1x0$33 = -152					; size = 4
_cy4x1$34 = -148					; size = 4
_cy2x1$35 = -144					; size = 4
_cy0x1$36 = -140					; size = 4
_cy4x0$37 = -136					; size = 4
_cy2x0$38 = -132					; size = 4
_cy0x0$39 = -128					; size = 4
_cxplus$40 = -124					; size = 4
_x$41 = -120						; size = 4
_x_fin$42 = -116					; size = 4
_srcP$43 = -112						; size = 4
_dstC$44 = -108						; size = 4
_y$45 = -104						; size = 4
_dstLine$46 = -100					; size = 4
_srcCLine$47 = -96					; size = 4
_ic$48 = -92						; size = 4
_src_uv_pitch$ = -88					; size = 4
_x$49 = -84						; size = 4
_y$50 = -80						; size = 4
_y_width$51 = -76					; size = 4
_y_fin$52 = -72						; size = 4
_dstLine$53 = -68					; size = 4
_srcYLine$54 = -64					; size = 4
$T55 = -60						; size = 12
_y_range$ = -44						; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yv12_p_to_yuv444_c@G$09E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_p_to_yuv444_c<unsigned short,10,unsigned char,8,0>

; 573  : static void __forceinline convert_yv12_p_to_yuv444_c(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 2c 01 00
	00		 sub	 esp, 300		; 0000012cH
  00009	53		 push	 ebx
  0000a	57		 push	 edi
  0000b	8d bd d4 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-300]
  00011	b9 4b 00 00 00	 mov	 ecx, 75			; 0000004bH
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 574  :     static_assert((sizeof(Tin)  == 1 && in_bit_depth  == 8) || (sizeof(Tin)  == 2 && 8 < in_bit_depth  && in_bit_depth  <= 16), "invalid input bit depth.");
; 575  :     static_assert((sizeof(Tout) == 1 && out_bit_depth == 8) || (sizeof(Tout) == 2 && 8 < out_bit_depth && out_bit_depth <= 16), "invalid output bit depth.");
; 576  :     const int crop_left   = crop[0];

  00027	b8 04 00 00 00	 mov	 eax, 4
  0002c	6b c8 00	 imul	 ecx, eax, 0
  0002f	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00032	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00035	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 577  :     const int crop_up     = crop[1];

  00038	b9 04 00 00 00	 mov	 ecx, 4
  0003d	c1 e1 00	 shl	 ecx, 0
  00040	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00043	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00046	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 578  :     const int crop_right  = crop[2];

  00049	b9 04 00 00 00	 mov	 ecx, 4
  0004e	d1 e1		 shl	 ecx, 1
  00050	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00053	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00056	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 579  :     const int crop_bottom = crop[3];

  00059	b9 04 00 00 00	 mov	 ecx, 4
  0005e	6b d1 03	 imul	 edx, ecx, 3
  00061	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00064	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00067	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 580  :     const int src_y_pitch = src_y_pitch_byte / sizeof(Tin);

  0006a	8b 55 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebp]
  0006d	d1 ea		 shr	 edx, 1
  0006f	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 581  :     const int dst_y_pitch = dst_y_pitch_byte / sizeof(Tout);

  00072	8b 45 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  00075	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 582  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00078	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0007b	51		 push	 ecx
  0007c	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0007f	52		 push	 edx
  00080	8b 45 20	 mov	 eax, DWORD PTR _height$[ebp]
  00083	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  00086	50		 push	 eax
  00087	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  0008a	51		 push	 ecx
  0008b	8d 95 f0 fe ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  00091	52		 push	 edx
  00092	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00097	83 c4 14	 add	 esp, 20			; 00000014H
  0009a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009c	89 4d c4	 mov	 DWORD PTR $T55[ebp], ecx
  0009f	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a2	89 55 c8	 mov	 DWORD PTR $T55[ebp+4], edx
  000a5	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000a8	89 45 cc	 mov	 DWORD PTR $T55[ebp+8], eax
  000ab	8b 4d c4	 mov	 ecx, DWORD PTR $T55[ebp]
  000ae	89 4d d4	 mov	 DWORD PTR _y_range$[ebp], ecx
  000b1	8b 55 c8	 mov	 edx, DWORD PTR $T55[ebp+4]
  000b4	89 55 d8	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000b7	8b 45 cc	 mov	 eax, DWORD PTR $T55[ebp+8]
  000ba	89 45 dc	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 583  :     //Y
; 584  :     if (!uv_only) {

  000bd	b9 01 00 00 00	 mov	 ecx, 1
  000c2	85 c9		 test	 ecx, ecx
  000c4	0f 84 6a 01 00
	00		 je	 $LN23@convert_yv

; 585  :         Tin *srcYLine = (Tin *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000ca	ba 04 00 00 00	 mov	 edx, 4
  000cf	6b c2 00	 imul	 eax, edx, 0
  000d2	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  000d5	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  000d9	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  000dc	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  000df	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  000e2	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  000e5	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  000e8	89 45 c0	 mov	 DWORD PTR _srcYLine$54[ebp], eax

; 586  :         Tout *dstLine = (Tout *)dst[0] + dst_y_pitch * y_range.start_dst;

  000eb	b9 04 00 00 00	 mov	 ecx, 4
  000f0	6b d1 00	 imul	 edx, ecx, 0
  000f3	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  000f6	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  000fa	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  000fd	03 04 11	 add	 eax, DWORD PTR [ecx+edx]
  00100	89 45 bc	 mov	 DWORD PTR _dstLine$53[ebp], eax

; 587  :         const int y_fin = height - crop_bottom;

  00103	8b 55 20	 mov	 edx, DWORD PTR _height$[ebp]
  00106	2b 55 ec	 sub	 edx, DWORD PTR _crop_bottom$[ebp]
  00109	89 55 b8	 mov	 DWORD PTR _y_fin$52[ebp], edx

; 588  :         const int y_width = width - crop_right - crop_left;

  0010c	8b 45 10	 mov	 eax, DWORD PTR _width$[ebp]
  0010f	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  00112	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  00115	89 45 b4	 mov	 DWORD PTR _y_width$51[ebp], eax

; 589  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  00118	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _y$50[ebp], 0
  0011f	eb 1e		 jmp	 SHORT $LN4@convert_yv
$LN2@convert_yv:
  00121	8b 4d b0	 mov	 ecx, DWORD PTR _y$50[ebp]
  00124	83 c1 01	 add	 ecx, 1
  00127	89 4d b0	 mov	 DWORD PTR _y$50[ebp], ecx
  0012a	8b 55 e8	 mov	 edx, DWORD PTR _src_y_pitch$[ebp]
  0012d	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$54[ebp]
  00130	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00133	89 4d c0	 mov	 DWORD PTR _srcYLine$54[ebp], ecx
  00136	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$53[ebp]
  00139	03 55 e4	 add	 edx, DWORD PTR _dst_y_pitch$[ebp]
  0013c	89 55 bc	 mov	 DWORD PTR _dstLine$53[ebp], edx
$LN4@convert_yv:
  0013f	8b 45 b0	 mov	 eax, DWORD PTR _y$50[ebp]
  00142	3b 45 dc	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  00145	0f 8d e9 00 00
	00		 jge	 $LN23@convert_yv

; 590  :             if (in_bit_depth == out_bit_depth && sizeof(Tin) == sizeof(Tout)) {

  0014b	33 c9		 xor	 ecx, ecx
  0014d	74 1b		 je	 SHORT $LN24@convert_yv

; 591  :                 memcpy(dstLine, srcYLine, y_width * sizeof(Tin));

  0014f	8b 55 b4	 mov	 edx, DWORD PTR _y_width$51[ebp]
  00152	d1 e2		 shl	 edx, 1
  00154	52		 push	 edx
  00155	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$54[ebp]
  00158	50		 push	 eax
  00159	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$53[ebp]
  0015c	51		 push	 ecx
  0015d	e8 00 00 00 00	 call	 _memcpy
  00162	83 c4 0c	 add	 esp, 12			; 0000000cH

; 592  :             } else {

  00165	e9 c5 00 00 00	 jmp	 $LN25@convert_yv
$LN24@convert_yv:

; 593  :                 for (int x = 0; x < y_width; x++) {

  0016a	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR _x$49[ebp], 0
  00171	eb 09		 jmp	 SHORT $LN7@convert_yv
$LN5@convert_yv:
  00173	8b 55 ac	 mov	 edx, DWORD PTR _x$49[ebp]
  00176	83 c2 01	 add	 edx, 1
  00179	89 55 ac	 mov	 DWORD PTR _x$49[ebp], edx
$LN7@convert_yv:
  0017c	8b 45 ac	 mov	 eax, DWORD PTR _x$49[ebp]
  0017f	3b 45 b4	 cmp	 eax, DWORD PTR _y_width$51[ebp]
  00182	0f 8d a7 00 00
	00		 jge	 $LN25@convert_yv

; 594  :                     if (out_bit_depth > in_bit_depth) {

  00188	33 c9		 xor	 ecx, ecx
  0018a	74 42		 je	 SHORT $LN26@convert_yv

; 595  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) << std::max(out_bit_depth - in_bit_depth, 0));

  0018c	c7 85 ec fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], 0
  00196	c7 85 e8 fe ff
	ff fe ff ff ff	 mov	 DWORD PTR $T3[ebp], -2	; fffffffeH
  001a0	8b 55 ac	 mov	 edx, DWORD PTR _x$49[ebp]
  001a3	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$54[ebp]
  001a6	0f b7 1c 50	 movzx	 ebx, WORD PTR [eax+edx*2]
  001aa	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  001b0	51		 push	 ecx
  001b1	8d 95 e8 fe ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  001b7	52		 push	 edx
  001b8	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  001bd	83 c4 08	 add	 esp, 8
  001c0	8b 08		 mov	 ecx, DWORD PTR [eax]
  001c2	d3 e3		 shl	 ebx, cl
  001c4	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$53[ebp]
  001c7	03 45 ac	 add	 eax, DWORD PTR _x$49[ebp]
  001ca	88 18		 mov	 BYTE PTR [eax], bl
  001cc	eb 5c		 jmp	 SHORT $LN27@convert_yv
$LN26@convert_yv:

; 596  :                     } else if (out_bit_depth < in_bit_depth) {

  001ce	b9 01 00 00 00	 mov	 ecx, 1
  001d3	85 c9		 test	 ecx, ecx
  001d5	74 42		 je	 SHORT $LN28@convert_yv

; 597  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) >> std::max(in_bit_depth - out_bit_depth, 0));

  001d7	c7 85 e4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], 0
  001e1	c7 85 e0 fe ff
	ff 02 00 00 00	 mov	 DWORD PTR $T1[ebp], 2
  001eb	8b 55 ac	 mov	 edx, DWORD PTR _x$49[ebp]
  001ee	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$54[ebp]
  001f1	0f b7 1c 50	 movzx	 ebx, WORD PTR [eax+edx*2]
  001f5	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  001fb	51		 push	 ecx
  001fc	8d 95 e0 fe ff
	ff		 lea	 edx, DWORD PTR $T1[ebp]
  00202	52		 push	 edx
  00203	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  00208	83 c4 08	 add	 esp, 8
  0020b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0020d	d3 fb		 sar	 ebx, cl
  0020f	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$53[ebp]
  00212	03 45 ac	 add	 eax, DWORD PTR _x$49[ebp]
  00215	88 18		 mov	 BYTE PTR [eax], bl

; 598  :                     } else {

  00217	eb 11		 jmp	 SHORT $LN27@convert_yv
$LN28@convert_yv:

; 599  :                         dstLine[x] = (Tout)srcYLine[x];

  00219	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$53[ebp]
  0021c	03 4d ac	 add	 ecx, DWORD PTR _x$49[ebp]
  0021f	8b 55 ac	 mov	 edx, DWORD PTR _x$49[ebp]
  00222	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$54[ebp]
  00225	8a 14 50	 mov	 dl, BYTE PTR [eax+edx*2]
  00228	88 11		 mov	 BYTE PTR [ecx], dl
$LN27@convert_yv:

; 600  :                     }
; 601  :                 }

  0022a	e9 44 ff ff ff	 jmp	 $LN5@convert_yv
$LN25@convert_yv:

; 602  :             }
; 603  :         }

  0022f	e9 ed fe ff ff	 jmp	 $LN2@convert_yv
$LN23@convert_yv:

; 604  :     }
; 605  :     //UV
; 606  :     const int src_uv_pitch = src_uv_pitch_byte / sizeof(Tin);

  00234	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  00237	d1 e8		 shr	 eax, 1
  00239	89 45 a8	 mov	 DWORD PTR _src_uv_pitch$[ebp], eax

; 607  :     for (int ic = 1; ic < 3; ic++) {

  0023c	c7 45 a4 01 00
	00 00		 mov	 DWORD PTR _ic$48[ebp], 1
  00243	eb 09		 jmp	 SHORT $LN10@convert_yv
$LN8@convert_yv:
  00245	8b 4d a4	 mov	 ecx, DWORD PTR _ic$48[ebp]
  00248	83 c1 01	 add	 ecx, 1
  0024b	89 4d a4	 mov	 DWORD PTR _ic$48[ebp], ecx
$LN10@convert_yv:
  0024e	83 7d a4 03	 cmp	 DWORD PTR _ic$48[ebp], 3
  00252	0f 8d ea 06 00
	00		 jge	 $LN1@convert_yv

; 608  :         Tin *srcCLine = (Tin *)src[ic] + (((src_uv_pitch * y_range.start_src) + crop_left) >> 1);

  00258	8b 55 a8	 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  0025b	0f af 55 d4	 imul	 edx, DWORD PTR _y_range$[ebp]
  0025f	03 55 f8	 add	 edx, DWORD PTR _crop_left$[ebp]
  00262	d1 fa		 sar	 edx, 1
  00264	8b 45 a4	 mov	 eax, DWORD PTR _ic$48[ebp]
  00267	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  0026a	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  0026d	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00270	89 4d a0	 mov	 DWORD PTR _srcCLine$47[ebp], ecx

; 609  :         Tout *dstLine = (Tout *)dst[ic] + dst_y_pitch * y_range.start_dst;

  00273	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  00276	0f af 55 d8	 imul	 edx, DWORD PTR _y_range$[ebp+4]
  0027a	8b 45 a4	 mov	 eax, DWORD PTR _ic$48[ebp]
  0027d	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  00280	03 14 81	 add	 edx, DWORD PTR [ecx+eax*4]
  00283	89 55 9c	 mov	 DWORD PTR _dstLine$46[ebp], edx

; 610  :         for (int y = 0; y < y_range.len; y += 2, srcCLine += src_uv_pitch, dstLine += dst_y_pitch * 2) {

  00286	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _y$45[ebp], 0
  0028d	eb 21		 jmp	 SHORT $LN13@convert_yv
$LN11@convert_yv:
  0028f	8b 55 98	 mov	 edx, DWORD PTR _y$45[ebp]
  00292	83 c2 02	 add	 edx, 2
  00295	89 55 98	 mov	 DWORD PTR _y$45[ebp], edx
  00298	8b 45 a8	 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  0029b	8b 4d a0	 mov	 ecx, DWORD PTR _srcCLine$47[ebp]
  0029e	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  002a1	89 55 a0	 mov	 DWORD PTR _srcCLine$47[ebp], edx
  002a4	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  002a7	8b 4d 9c	 mov	 ecx, DWORD PTR _dstLine$46[ebp]
  002aa	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  002ad	89 55 9c	 mov	 DWORD PTR _dstLine$46[ebp], edx
$LN13@convert_yv:
  002b0	8b 45 98	 mov	 eax, DWORD PTR _y$45[ebp]
  002b3	3b 45 dc	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  002b6	0f 8d 81 06 00
	00		 jge	 $LN12@convert_yv

; 611  :             Tout *dstC = dstLine;

  002bc	8b 4d 9c	 mov	 ecx, DWORD PTR _dstLine$46[ebp]
  002bf	89 4d 94	 mov	 DWORD PTR _dstC$44[ebp], ecx

; 612  :             Tin *srcP = srcCLine;

  002c2	8b 55 a0	 mov	 edx, DWORD PTR _srcCLine$47[ebp]
  002c5	89 55 90	 mov	 DWORD PTR _srcP$43[ebp], edx

; 613  :             const int x_fin = width - crop_right - crop_left;

  002c8	8b 45 10	 mov	 eax, DWORD PTR _width$[ebp]
  002cb	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  002ce	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  002d1	89 45 8c	 mov	 DWORD PTR _x_fin$42[ebp], eax

; 614  :             if (y == 0) {

  002d4	83 7d 98 00	 cmp	 DWORD PTR _y$45[ebp], 0
  002d8	0f 85 04 02 00
	00		 jne	 $LN30@convert_yv

; 615  :                 for (int x = 0; x < x_fin; x += 2, dstC += 2, srcP++) {

  002de	c7 45 88 00 00
	00 00		 mov	 DWORD PTR _x$41[ebp], 0
  002e5	eb 1b		 jmp	 SHORT $LN16@convert_yv
$LN14@convert_yv:
  002e7	8b 4d 88	 mov	 ecx, DWORD PTR _x$41[ebp]
  002ea	83 c1 02	 add	 ecx, 2
  002ed	89 4d 88	 mov	 DWORD PTR _x$41[ebp], ecx
  002f0	8b 55 94	 mov	 edx, DWORD PTR _dstC$44[ebp]
  002f3	83 c2 02	 add	 edx, 2
  002f6	89 55 94	 mov	 DWORD PTR _dstC$44[ebp], edx
  002f9	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  002fc	83 c0 02	 add	 eax, 2
  002ff	89 45 90	 mov	 DWORD PTR _srcP$43[ebp], eax
$LN16@convert_yv:
  00302	8b 4d 88	 mov	 ecx, DWORD PTR _x$41[ebp]
  00305	3b 4d 8c	 cmp	 ecx, DWORD PTR _x_fin$42[ebp]
  00308	0f 8d cf 01 00
	00		 jge	 $LN15@convert_yv

; 616  :                     int cxplus = (x + 2 < x_fin);

  0030e	8b 55 88	 mov	 edx, DWORD PTR _x$41[ebp]
  00311	83 c2 02	 add	 edx, 2
  00314	3b 55 8c	 cmp	 edx, DWORD PTR _x_fin$42[ebp]
  00317	7d 0c		 jge	 SHORT $LN44@convert_yv
  00319	c7 85 dc fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv227[ebp], 1
  00323	eb 0a		 jmp	 SHORT $LN45@convert_yv
$LN44@convert_yv:
  00325	c7 85 dc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv227[ebp], 0
$LN45@convert_yv:
  0032f	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR tv227[ebp]
  00335	89 45 84	 mov	 DWORD PTR _cxplus$40[ebp], eax

; 617  :                     int cy0x0 = srcP[ 0*src_uv_pitch + 0];

  00338	6b 4d a8 00	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 0
  0033c	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  0033f	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00343	89 45 80	 mov	 DWORD PTR _cy0x0$39[ebp], eax

; 618  :                     int cy2x0 = srcP[ 0*src_uv_pitch + 0];

  00346	6b 4d a8 00	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 0
  0034a	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  0034d	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00351	89 85 7c ff ff
	ff		 mov	 DWORD PTR _cy2x0$38[ebp], eax

; 619  :                     int cy4x0 = srcP[ 1*src_uv_pitch + 0];

  00357	8b 4d a8	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  0035a	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  0035d	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00361	89 85 78 ff ff
	ff		 mov	 DWORD PTR _cy4x0$37[ebp], eax

; 620  :                     int cy0x1 = srcP[ 0*src_uv_pitch + cxplus];

  00367	6b 4d a8 00	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 0
  0036b	03 4d 84	 add	 ecx, DWORD PTR _cxplus$40[ebp]
  0036e	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  00371	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00375	89 85 74 ff ff
	ff		 mov	 DWORD PTR _cy0x1$36[ebp], eax

; 621  :                     int cy2x1 = srcP[ 0*src_uv_pitch + cxplus];

  0037b	6b 4d a8 00	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 0
  0037f	03 4d 84	 add	 ecx, DWORD PTR _cxplus$40[ebp]
  00382	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  00385	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00389	89 85 70 ff ff
	ff		 mov	 DWORD PTR _cy2x1$35[ebp], eax

; 622  :                     int cy4x1 = srcP[ 1*src_uv_pitch + cxplus];

  0038f	8b 4d 84	 mov	 ecx, DWORD PTR _cxplus$40[ebp]
  00392	03 4d a8	 add	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00395	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  00398	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  0039c	89 85 6c ff ff
	ff		 mov	 DWORD PTR _cy4x1$34[ebp], eax

; 623  : 
; 624  :                     int cy1x0 = (cy0x0 * 1 + cy2x0 * 3 + 2);

  003a2	6b 8d 7c ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy2x0$38[ebp], 3
  003a9	8b 55 80	 mov	 edx, DWORD PTR _cy0x0$39[ebp]
  003ac	8d 44 0a 02	 lea	 eax, DWORD PTR [edx+ecx+2]
  003b0	89 85 68 ff ff
	ff		 mov	 DWORD PTR _cy1x0$33[ebp], eax

; 625  :                     int cy3x0 = (cy2x0 * 3 + cy4x0 * 1 + 2);

  003b6	6b 8d 7c ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy2x0$38[ebp], 3
  003bd	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _cy4x0$37[ebp]
  003c3	8d 44 11 02	 lea	 eax, DWORD PTR [ecx+edx+2]
  003c7	89 85 64 ff ff
	ff		 mov	 DWORD PTR _cy3x0$32[ebp], eax

; 626  :                     int cy1x1 = (cy0x1 * 1 + cy2x1 * 3 + 2);

  003cd	6b 8d 70 ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy2x1$35[ebp], 3
  003d4	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _cy0x1$36[ebp]
  003da	8d 44 0a 02	 lea	 eax, DWORD PTR [edx+ecx+2]
  003de	89 85 60 ff ff
	ff		 mov	 DWORD PTR _cy1x1$31[ebp], eax

; 627  :                     int cy3x1 = (cy2x1 * 3 + cy4x1 * 1 + 2);

  003e4	6b 8d 70 ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy2x1$35[ebp], 3
  003eb	8b 95 6c ff ff
	ff		 mov	 edx, DWORD PTR _cy4x1$34[ebp]
  003f1	8d 44 11 02	 lea	 eax, DWORD PTR [ecx+edx+2]
  003f5	89 85 5c ff ff
	ff		 mov	 DWORD PTR _cy3x1$30[ebp], eax

; 628  :                     CHANGE_BIT_DEPTH_4(cy1x0, cy3x0, cy1x1, cy3x1, 2);

  003fb	33 c9		 xor	 ecx, ecx
  003fd	74 3e		 je	 SHORT $LN32@convert_yv
  003ff	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x0$33[ebp]
  00405	c1 e2 fc	 shl	 edx, -4			; fffffffcH
  00408	89 95 68 ff ff
	ff		 mov	 DWORD PTR _cy1x0$33[ebp], edx
  0040e	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$32[ebp]
  00414	c1 e0 fc	 shl	 eax, -4			; fffffffcH
  00417	89 85 64 ff ff
	ff		 mov	 DWORD PTR _cy3x0$32[ebp], eax
  0041d	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x1$31[ebp]
  00423	c1 e1 fc	 shl	 ecx, -4			; fffffffcH
  00426	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _cy1x1$31[ebp], ecx
  0042c	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR _cy3x1$30[ebp]
  00432	c1 e2 fc	 shl	 edx, -4			; fffffffcH
  00435	89 95 5c ff ff
	ff		 mov	 DWORD PTR _cy3x1$30[ebp], edx
  0043b	eb 45		 jmp	 SHORT $LN33@convert_yv
$LN32@convert_yv:
  0043d	b8 01 00 00 00	 mov	 eax, 1
  00442	85 c0		 test	 eax, eax
  00444	74 3c		 je	 SHORT $LN33@convert_yv
  00446	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x0$33[ebp]
  0044c	c1 f9 04	 sar	 ecx, 4
  0044f	89 8d 68 ff ff
	ff		 mov	 DWORD PTR _cy1x0$33[ebp], ecx
  00455	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR _cy3x0$32[ebp]
  0045b	c1 fa 04	 sar	 edx, 4
  0045e	89 95 64 ff ff
	ff		 mov	 DWORD PTR _cy3x0$32[ebp], edx
  00464	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x1$31[ebp]
  0046a	c1 f8 04	 sar	 eax, 4
  0046d	89 85 60 ff ff
	ff		 mov	 DWORD PTR _cy1x1$31[ebp], eax
  00473	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x1$30[ebp]
  00479	c1 f9 04	 sar	 ecx, 4
  0047c	89 8d 5c ff ff
	ff		 mov	 DWORD PTR _cy3x1$30[ebp], ecx
$LN33@convert_yv:

; 629  : 
; 630  :                     dstC[0*dst_y_pitch   + 0] = (Tout)cy1x0;

  00482	6b 55 e4 00	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 0
  00486	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  00489	8a 8d 68 ff ff
	ff		 mov	 cl, BYTE PTR _cy1x0$33[ebp]
  0048f	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 631  :                     dstC[0*dst_y_pitch   + 1] = (Tout)((cy1x0 + cy1x1 + 1) >> 1);

  00492	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x1$31[ebp]
  00498	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x0$33[ebp]
  0049e	8d 4c 10 01	 lea	 ecx, DWORD PTR [eax+edx+1]
  004a2	d1 f9		 sar	 ecx, 1
  004a4	6b 55 e4 00	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 0
  004a8	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  004ab	88 4c 10 01	 mov	 BYTE PTR [eax+edx+1], cl

; 632  :                     dstC[1*dst_y_pitch   + 0] = (Tout)cy3x0;

  004af	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$44[ebp]
  004b2	03 4d e4	 add	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  004b5	8a 95 64 ff ff
	ff		 mov	 dl, BYTE PTR _cy3x0$32[ebp]
  004bb	88 11		 mov	 BYTE PTR [ecx], dl

; 633  :                     dstC[1*dst_y_pitch   + 1] = (Tout)((cy3x0 + cy3x1 + 1) >> 1);

  004bd	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _cy3x1$30[ebp]
  004c3	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x0$32[ebp]
  004c9	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  004cd	d1 fa		 sar	 edx, 1
  004cf	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  004d2	03 45 e4	 add	 eax, DWORD PTR _dst_y_pitch$[ebp]
  004d5	88 50 01	 mov	 BYTE PTR [eax+1], dl

; 634  :                 }

  004d8	e9 0a fe ff ff	 jmp	 $LN14@convert_yv
$LN15@convert_yv:

; 635  :             } else if (y >= height-2) {

  004dd	e9 56 04 00 00	 jmp	 $LN31@convert_yv
$LN30@convert_yv:
  004e2	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  004e5	83 e9 02	 sub	 ecx, 2
  004e8	39 4d 98	 cmp	 DWORD PTR _y$45[ebp], ecx
  004eb	0f 8c 27 02 00
	00		 jl	 $LN35@convert_yv

; 636  :                 for (int x = 0; x < x_fin; x += 2, dstC += 2, srcP++) {

  004f1	c7 85 58 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _x$29[ebp], 0
  004fb	eb 21		 jmp	 SHORT $LN19@convert_yv
$LN17@convert_yv:
  004fd	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _x$29[ebp]
  00503	83 c2 02	 add	 edx, 2
  00506	89 95 58 ff ff
	ff		 mov	 DWORD PTR _x$29[ebp], edx
  0050c	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  0050f	83 c0 02	 add	 eax, 2
  00512	89 45 94	 mov	 DWORD PTR _dstC$44[ebp], eax
  00515	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$43[ebp]
  00518	83 c1 02	 add	 ecx, 2
  0051b	89 4d 90	 mov	 DWORD PTR _srcP$43[ebp], ecx
$LN19@convert_yv:
  0051e	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _x$29[ebp]
  00524	3b 55 8c	 cmp	 edx, DWORD PTR _x_fin$42[ebp]
  00527	0f 8d e6 01 00
	00		 jge	 $LN18@convert_yv

; 637  :                     int cxplus = (x + 2 < x_fin);

  0052d	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _x$29[ebp]
  00533	83 c0 02	 add	 eax, 2
  00536	3b 45 8c	 cmp	 eax, DWORD PTR _x_fin$42[ebp]
  00539	7d 0c		 jge	 SHORT $LN46@convert_yv
  0053b	c7 85 d8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv312[ebp], 1
  00545	eb 0a		 jmp	 SHORT $LN47@convert_yv
$LN46@convert_yv:
  00547	c7 85 d8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv312[ebp], 0
$LN47@convert_yv:
  00551	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR tv312[ebp]
  00557	89 8d 54 ff ff
	ff		 mov	 DWORD PTR _cxplus$28[ebp], ecx

; 638  :                     int cy0x0 = srcP[-1*src_uv_pitch + 0];

  0055d	6b 55 a8 ff	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], -1
  00561	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  00564	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  00568	89 8d 50 ff ff
	ff		 mov	 DWORD PTR _cy0x0$27[ebp], ecx

; 639  :                     int cy2x0 = srcP[ 0*src_uv_pitch + 0];

  0056e	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  00572	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  00575	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  00579	89 8d 4c ff ff
	ff		 mov	 DWORD PTR _cy2x0$26[ebp], ecx

; 640  :                     int cy4x0 = srcP[ 0*src_uv_pitch + 0];

  0057f	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  00583	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  00586	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  0058a	89 8d 48 ff ff
	ff		 mov	 DWORD PTR _cy4x0$25[ebp], ecx

; 641  :                     int cy0x1 = srcP[-1*src_uv_pitch + cxplus];

  00590	6b 55 a8 ff	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], -1
  00594	03 95 54 ff ff
	ff		 add	 edx, DWORD PTR _cxplus$28[ebp]
  0059a	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  0059d	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  005a1	89 8d 44 ff ff
	ff		 mov	 DWORD PTR _cy0x1$24[ebp], ecx

; 642  :                     int cy2x1 = srcP[ 0*src_uv_pitch + cxplus];

  005a7	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  005ab	03 95 54 ff ff
	ff		 add	 edx, DWORD PTR _cxplus$28[ebp]
  005b1	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  005b4	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  005b8	89 8d 40 ff ff
	ff		 mov	 DWORD PTR _cy2x1$23[ebp], ecx

; 643  :                     int cy4x1 = srcP[ 0*src_uv_pitch + cxplus];

  005be	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  005c2	03 95 54 ff ff
	ff		 add	 edx, DWORD PTR _cxplus$28[ebp]
  005c8	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  005cb	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  005cf	89 8d 3c ff ff
	ff		 mov	 DWORD PTR _cy4x1$22[ebp], ecx

; 644  : 
; 645  :                     int cy1x0 = (cy0x0 * 1 + cy2x0 * 3 + 2);

  005d5	6b 95 4c ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x0$26[ebp], 3
  005dc	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _cy0x0$27[ebp]
  005e2	8d 4c 10 02	 lea	 ecx, DWORD PTR [eax+edx+2]
  005e6	89 8d 38 ff ff
	ff		 mov	 DWORD PTR _cy1x0$21[ebp], ecx

; 646  :                     int cy3x0 = (cy2x0 * 3 + cy4x0 * 1 + 2);

  005ec	6b 95 4c ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x0$26[ebp], 3
  005f3	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _cy4x0$25[ebp]
  005f9	8d 4c 02 02	 lea	 ecx, DWORD PTR [edx+eax+2]
  005fd	89 8d 34 ff ff
	ff		 mov	 DWORD PTR _cy3x0$20[ebp], ecx

; 647  :                     int cy1x1 = (cy0x1 * 1 + cy2x1 * 3 + 2);

  00603	6b 95 40 ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x1$23[ebp], 3
  0060a	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _cy0x1$24[ebp]
  00610	8d 4c 10 02	 lea	 ecx, DWORD PTR [eax+edx+2]
  00614	89 8d 30 ff ff
	ff		 mov	 DWORD PTR _cy1x1$19[ebp], ecx

; 648  :                     int cy3x1 = (cy2x1 * 3 + cy4x1 * 1 + 2);

  0061a	6b 95 40 ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x1$23[ebp], 3
  00621	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _cy4x1$22[ebp]
  00627	8d 4c 02 02	 lea	 ecx, DWORD PTR [edx+eax+2]
  0062b	89 8d 2c ff ff
	ff		 mov	 DWORD PTR _cy3x1$18[ebp], ecx

; 649  :                     CHANGE_BIT_DEPTH_4(cy1x0, cy3x0, cy1x1, cy3x1, 2);

  00631	33 d2		 xor	 edx, edx
  00633	74 3e		 je	 SHORT $LN37@convert_yv
  00635	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x0$21[ebp]
  0063b	c1 e0 fc	 shl	 eax, -4			; fffffffcH
  0063e	89 85 38 ff ff
	ff		 mov	 DWORD PTR _cy1x0$21[ebp], eax
  00644	8b 8d 34 ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x0$20[ebp]
  0064a	c1 e1 fc	 shl	 ecx, -4			; fffffffcH
  0064d	89 8d 34 ff ff
	ff		 mov	 DWORD PTR _cy3x0$20[ebp], ecx
  00653	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x1$19[ebp]
  00659	c1 e2 fc	 shl	 edx, -4			; fffffffcH
  0065c	89 95 30 ff ff
	ff		 mov	 DWORD PTR _cy1x1$19[ebp], edx
  00662	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR _cy3x1$18[ebp]
  00668	c1 e0 fc	 shl	 eax, -4			; fffffffcH
  0066b	89 85 2c ff ff
	ff		 mov	 DWORD PTR _cy3x1$18[ebp], eax
  00671	eb 45		 jmp	 SHORT $LN38@convert_yv
$LN37@convert_yv:
  00673	b9 01 00 00 00	 mov	 ecx, 1
  00678	85 c9		 test	 ecx, ecx
  0067a	74 3c		 je	 SHORT $LN38@convert_yv
  0067c	8b 95 38 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x0$21[ebp]
  00682	c1 fa 04	 sar	 edx, 4
  00685	89 95 38 ff ff
	ff		 mov	 DWORD PTR _cy1x0$21[ebp], edx
  0068b	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$20[ebp]
  00691	c1 f8 04	 sar	 eax, 4
  00694	89 85 34 ff ff
	ff		 mov	 DWORD PTR _cy3x0$20[ebp], eax
  0069a	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x1$19[ebp]
  006a0	c1 f9 04	 sar	 ecx, 4
  006a3	89 8d 30 ff ff
	ff		 mov	 DWORD PTR _cy1x1$19[ebp], ecx
  006a9	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR _cy3x1$18[ebp]
  006af	c1 fa 04	 sar	 edx, 4
  006b2	89 95 2c ff ff
	ff		 mov	 DWORD PTR _cy3x1$18[ebp], edx
$LN38@convert_yv:

; 650  : 
; 651  :                     dstC[0*dst_y_pitch   + 0] = (Tout)cy1x0;

  006b8	6b 45 e4 00	 imul	 eax, DWORD PTR _dst_y_pitch$[ebp], 0
  006bc	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$44[ebp]
  006bf	8a 95 38 ff ff
	ff		 mov	 dl, BYTE PTR _cy1x0$21[ebp]
  006c5	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 652  :                     dstC[0*dst_y_pitch   + 1] = (Tout)((cy1x0 + cy1x1 + 1) >> 1);

  006c8	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x1$19[ebp]
  006ce	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x0$21[ebp]
  006d4	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  006d8	d1 fa		 sar	 edx, 1
  006da	6b 45 e4 00	 imul	 eax, DWORD PTR _dst_y_pitch$[ebp], 0
  006de	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$44[ebp]
  006e1	88 54 01 01	 mov	 BYTE PTR [ecx+eax+1], dl

; 653  :                     dstC[1*dst_y_pitch   + 0] = (Tout)cy3x0;

  006e5	8b 55 94	 mov	 edx, DWORD PTR _dstC$44[ebp]
  006e8	03 55 e4	 add	 edx, DWORD PTR _dst_y_pitch$[ebp]
  006eb	8a 85 34 ff ff
	ff		 mov	 al, BYTE PTR _cy3x0$20[ebp]
  006f1	88 02		 mov	 BYTE PTR [edx], al

; 654  :                     dstC[1*dst_y_pitch   + 1] = (Tout)((cy3x0 + cy3x1 + 1) >> 1);

  006f3	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x1$18[ebp]
  006f9	8b 95 34 ff ff
	ff		 mov	 edx, DWORD PTR _cy3x0$20[ebp]
  006ff	8d 44 0a 01	 lea	 eax, DWORD PTR [edx+ecx+1]
  00703	d1 f8		 sar	 eax, 1
  00705	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$44[ebp]
  00708	03 4d e4	 add	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  0070b	88 41 01	 mov	 BYTE PTR [ecx+1], al

; 655  :                 }

  0070e	e9 ea fd ff ff	 jmp	 $LN17@convert_yv
$LN18@convert_yv:

; 656  :             } else {

  00713	e9 20 02 00 00	 jmp	 $LN31@convert_yv
$LN35@convert_yv:

; 657  :                 for (int x = 0; x < x_fin; x += 2, dstC += 2, srcP++) {

  00718	c7 85 28 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _x$17[ebp], 0
  00722	eb 21		 jmp	 SHORT $LN22@convert_yv
$LN20@convert_yv:
  00724	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR _x$17[ebp]
  0072a	83 c2 02	 add	 edx, 2
  0072d	89 95 28 ff ff
	ff		 mov	 DWORD PTR _x$17[ebp], edx
  00733	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  00736	83 c0 02	 add	 eax, 2
  00739	89 45 94	 mov	 DWORD PTR _dstC$44[ebp], eax
  0073c	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$43[ebp]
  0073f	83 c1 02	 add	 ecx, 2
  00742	89 4d 90	 mov	 DWORD PTR _srcP$43[ebp], ecx
$LN22@convert_yv:
  00745	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR _x$17[ebp]
  0074b	3b 55 8c	 cmp	 edx, DWORD PTR _x_fin$42[ebp]
  0074e	0f 8d e4 01 00
	00		 jge	 $LN31@convert_yv

; 658  :                     int cxplus = (x + 2 < x_fin);

  00754	8b 85 28 ff ff
	ff		 mov	 eax, DWORD PTR _x$17[ebp]
  0075a	83 c0 02	 add	 eax, 2
  0075d	3b 45 8c	 cmp	 eax, DWORD PTR _x_fin$42[ebp]
  00760	7d 0c		 jge	 SHORT $LN48@convert_yv
  00762	c7 85 d4 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv427[ebp], 1
  0076c	eb 0a		 jmp	 SHORT $LN49@convert_yv
$LN48@convert_yv:
  0076e	c7 85 d4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv427[ebp], 0
$LN49@convert_yv:
  00778	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR tv427[ebp]
  0077e	89 8d 24 ff ff
	ff		 mov	 DWORD PTR _cxplus$16[ebp], ecx

; 659  :                     int cy0x0 = srcP[-1*src_uv_pitch + 0];

  00784	6b 55 a8 ff	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], -1
  00788	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  0078b	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  0078f	89 8d 20 ff ff
	ff		 mov	 DWORD PTR _cy0x0$15[ebp], ecx

; 660  :                     int cy2x0 = srcP[ 0*src_uv_pitch + 0];

  00795	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  00799	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  0079c	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  007a0	89 8d 1c ff ff
	ff		 mov	 DWORD PTR _cy2x0$14[ebp], ecx

; 661  :                     int cy4x0 = srcP[ 1*src_uv_pitch + 0];

  007a6	8b 55 a8	 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  007a9	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  007ac	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  007b0	89 8d 18 ff ff
	ff		 mov	 DWORD PTR _cy4x0$13[ebp], ecx

; 662  :                     int cy0x1 = srcP[-1*src_uv_pitch + cxplus];

  007b6	6b 55 a8 ff	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], -1
  007ba	03 95 24 ff ff
	ff		 add	 edx, DWORD PTR _cxplus$16[ebp]
  007c0	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  007c3	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  007c7	89 8d 14 ff ff
	ff		 mov	 DWORD PTR _cy0x1$12[ebp], ecx

; 663  :                     int cy2x1 = srcP[ 0*src_uv_pitch + cxplus];

  007cd	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  007d1	03 95 24 ff ff
	ff		 add	 edx, DWORD PTR _cxplus$16[ebp]
  007d7	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  007da	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  007de	89 8d 10 ff ff
	ff		 mov	 DWORD PTR _cy2x1$11[ebp], ecx

; 664  :                     int cy4x1 = srcP[ 1*src_uv_pitch + cxplus];

  007e4	8b 95 24 ff ff
	ff		 mov	 edx, DWORD PTR _cxplus$16[ebp]
  007ea	03 55 a8	 add	 edx, DWORD PTR _src_uv_pitch$[ebp]
  007ed	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  007f0	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  007f4	89 8d 0c ff ff
	ff		 mov	 DWORD PTR _cy4x1$10[ebp], ecx

; 665  : 
; 666  :                     int cy1x0 = (cy0x0 * 1 + cy2x0 * 3 + 2);

  007fa	6b 95 1c ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x0$14[ebp], 3
  00801	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR _cy0x0$15[ebp]
  00807	8d 4c 10 02	 lea	 ecx, DWORD PTR [eax+edx+2]
  0080b	89 8d 08 ff ff
	ff		 mov	 DWORD PTR _cy1x0$9[ebp], ecx

; 667  :                     int cy3x0 = (cy2x0 * 3 + cy4x0 * 1 + 2);

  00811	6b 95 1c ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x0$14[ebp], 3
  00818	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _cy4x0$13[ebp]
  0081e	8d 4c 02 02	 lea	 ecx, DWORD PTR [edx+eax+2]
  00822	89 8d 04 ff ff
	ff		 mov	 DWORD PTR _cy3x0$8[ebp], ecx

; 668  :                     int cy1x1 = (cy0x1 * 1 + cy2x1 * 3 + 2);

  00828	6b 95 10 ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x1$11[ebp], 3
  0082f	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _cy0x1$12[ebp]
  00835	8d 4c 10 02	 lea	 ecx, DWORD PTR [eax+edx+2]
  00839	89 8d 00 ff ff
	ff		 mov	 DWORD PTR _cy1x1$7[ebp], ecx

; 669  :                     int cy3x1 = (cy2x1 * 3 + cy4x1 * 1 + 2);

  0083f	6b 95 10 ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x1$11[ebp], 3
  00846	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _cy4x1$10[ebp]
  0084c	8d 4c 02 02	 lea	 ecx, DWORD PTR [edx+eax+2]
  00850	89 8d fc fe ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], ecx

; 670  :                     CHANGE_BIT_DEPTH_4(cy1x0, cy3x0, cy1x1, cy3x1, 2);

  00856	33 d2		 xor	 edx, edx
  00858	74 3e		 je	 SHORT $LN40@convert_yv
  0085a	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x0$9[ebp]
  00860	c1 e0 fc	 shl	 eax, -4			; fffffffcH
  00863	89 85 08 ff ff
	ff		 mov	 DWORD PTR _cy1x0$9[ebp], eax
  00869	8b 8d 04 ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x0$8[ebp]
  0086f	c1 e1 fc	 shl	 ecx, -4			; fffffffcH
  00872	89 8d 04 ff ff
	ff		 mov	 DWORD PTR _cy3x0$8[ebp], ecx
  00878	8b 95 00 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x1$7[ebp]
  0087e	c1 e2 fc	 shl	 edx, -4			; fffffffcH
  00881	89 95 00 ff ff
	ff		 mov	 DWORD PTR _cy1x1$7[ebp], edx
  00887	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR _cy3x1$6[ebp]
  0088d	c1 e0 fc	 shl	 eax, -4			; fffffffcH
  00890	89 85 fc fe ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], eax
  00896	eb 45		 jmp	 SHORT $LN41@convert_yv
$LN40@convert_yv:
  00898	b9 01 00 00 00	 mov	 ecx, 1
  0089d	85 c9		 test	 ecx, ecx
  0089f	74 3c		 je	 SHORT $LN41@convert_yv
  008a1	8b 95 08 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x0$9[ebp]
  008a7	c1 fa 04	 sar	 edx, 4
  008aa	89 95 08 ff ff
	ff		 mov	 DWORD PTR _cy1x0$9[ebp], edx
  008b0	8b 85 04 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$8[ebp]
  008b6	c1 f8 04	 sar	 eax, 4
  008b9	89 85 04 ff ff
	ff		 mov	 DWORD PTR _cy3x0$8[ebp], eax
  008bf	8b 8d 00 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x1$7[ebp]
  008c5	c1 f9 04	 sar	 ecx, 4
  008c8	89 8d 00 ff ff
	ff		 mov	 DWORD PTR _cy1x1$7[ebp], ecx
  008ce	8b 95 fc fe ff
	ff		 mov	 edx, DWORD PTR _cy3x1$6[ebp]
  008d4	c1 fa 04	 sar	 edx, 4
  008d7	89 95 fc fe ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], edx
$LN41@convert_yv:

; 671  : 
; 672  :                     dstC[0*dst_y_pitch   + 0] = (Tout)cy1x0;

  008dd	6b 45 e4 00	 imul	 eax, DWORD PTR _dst_y_pitch$[ebp], 0
  008e1	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$44[ebp]
  008e4	8a 95 08 ff ff
	ff		 mov	 dl, BYTE PTR _cy1x0$9[ebp]
  008ea	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 673  :                     dstC[0*dst_y_pitch   + 1] = (Tout)((cy1x0 + cy1x1 + 1) >> 1);

  008ed	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x1$7[ebp]
  008f3	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x0$9[ebp]
  008f9	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  008fd	d1 fa		 sar	 edx, 1
  008ff	6b 45 e4 00	 imul	 eax, DWORD PTR _dst_y_pitch$[ebp], 0
  00903	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$44[ebp]
  00906	88 54 01 01	 mov	 BYTE PTR [ecx+eax+1], dl

; 674  :                     dstC[1*dst_y_pitch   + 0] = (Tout)cy3x0;

  0090a	8b 55 94	 mov	 edx, DWORD PTR _dstC$44[ebp]
  0090d	03 55 e4	 add	 edx, DWORD PTR _dst_y_pitch$[ebp]
  00910	8a 85 04 ff ff
	ff		 mov	 al, BYTE PTR _cy3x0$8[ebp]
  00916	88 02		 mov	 BYTE PTR [edx], al

; 675  :                     dstC[1*dst_y_pitch   + 1] = (Tout)((cy3x0 + cy3x1 + 1) >> 1);

  00918	8b 8d fc fe ff
	ff		 mov	 ecx, DWORD PTR _cy3x1$6[ebp]
  0091e	8b 95 04 ff ff
	ff		 mov	 edx, DWORD PTR _cy3x0$8[ebp]
  00924	8d 44 0a 01	 lea	 eax, DWORD PTR [edx+ecx+1]
  00928	d1 f8		 sar	 eax, 1
  0092a	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$44[ebp]
  0092d	03 4d e4	 add	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  00930	88 41 01	 mov	 BYTE PTR [ecx+1], al

; 676  :                 }

  00933	e9 ec fd ff ff	 jmp	 $LN20@convert_yv
$LN31@convert_yv:

; 677  :             }
; 678  :         }

  00938	e9 52 f9 ff ff	 jmp	 $LN11@convert_yv
$LN12@convert_yv:

; 679  :     }

  0093d	e9 03 f9 ff ff	 jmp	 $LN8@convert_yv
$LN1@convert_yv:

; 680  : }

  00942	52		 push	 edx
  00943	8b cd		 mov	 ecx, ebp
  00945	50		 push	 eax
  00946	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN52@convert_yv
  0094c	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00951	58		 pop	 eax
  00952	5a		 pop	 edx
  00953	5f		 pop	 edi
  00954	5b		 pop	 ebx
  00955	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00958	33 cd		 xor	 ecx, ebp
  0095a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0095f	81 c4 2c 01 00
	00		 add	 esp, 300		; 0000012cH
  00965	3b ec		 cmp	 ebp, esp
  00967	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0096c	8b e5		 mov	 esp, ebp
  0096e	5d		 pop	 ebp
  0096f	c3		 ret	 0
$LN52@convert_yv:
  00970	01 00 00 00	 DD	 1
  00974	00 00 00 00	 DD	 $LN51@convert_yv
$LN51@convert_yv:
  00978	d4 ff ff ff	 DD	 -44			; ffffffd4H
  0097c	0c 00 00 00	 DD	 12			; 0000000cH
  00980	00 00 00 00	 DD	 $LN50@convert_yv
$LN50@convert_yv:
  00984	79		 DB	 121			; 00000079H
  00985	5f		 DB	 95			; 0000005fH
  00986	72		 DB	 114			; 00000072H
  00987	61		 DB	 97			; 00000061H
  00988	6e		 DB	 110			; 0000006eH
  00989	67		 DB	 103			; 00000067H
  0098a	65		 DB	 101			; 00000065H
  0098b	00		 DB	 0
??$convert_yv12_p_to_yuv444_c@G$09E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_p_to_yuv444_c<unsigned short,10,unsigned char,8,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yv12_10_p_to_yuv444@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_10_p_to_yuv444

; 817  : static void convert_yv12_10_p_to_yuv444(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 818  :     convert_yv12_p_to_yuv444_c<uint16_t, 10, uint8_t, 8, false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yv12_p_to_yuv444_c@G$09E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_p_to_yuv444_c<unsigned short,10,unsigned char,8,0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 819  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yv12_10_p_to_yuv444@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_10_p_to_yuv444
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
tv297 = -280						; size = 4
tv235 = -276						; size = 4
tv236 = -272						; size = 4
tv230 = -268						; size = 4
tv227 = -264						; size = 4
tv224 = -260						; size = 4
tv222 = -256						; size = 4
$T1 = -252						; size = 4
$T2 = -248						; size = 4
$T3 = -244						; size = 4
$T4 = -240						; size = 4
$T5 = -236						; size = 12
_cy3x1$6 = -224						; size = 4
_cy2x1$7 = -220						; size = 4
_cy1x1$8 = -216						; size = 4
_cy0x1$9 = -212						; size = 4
_sy5x1$10 = -208					; size = 4
_sy4x1$11 = -204					; size = 4
_sy3x1$12 = -200					; size = 4
_sy2x1$13 = -196					; size = 4
_sy1x1$14 = -192					; size = 4
_sy0x1$15 = -188					; size = 4
_cxplus$16 = -184					; size = 4
_x$17 = -180						; size = 4
_cy3x0$18 = -176					; size = 4
_cy2x0$19 = -172					; size = 4
_cy1x0$20 = -168					; size = 4
_cy0x0$21 = -164					; size = 4
_sy5x0$22 = -160					; size = 4
_sy4x0$23 = -156					; size = 4
_sy3x0$24 = -152					; size = 4
_sy2x0$25 = -148					; size = 4
_sy1x0$26 = -144					; size = 4
_sy0x0$27 = -140					; size = 4
_y_p3$28 = -136						; size = 4
_y_p2$29 = -132						; size = 4
_y_p1$30 = -128						; size = 4
_y_m1$31 = -124						; size = 4
_y_m2$32 = -120						; size = 4
_x_fin$33 = -116					; size = 4
_srcP$34 = -112						; size = 4
_dstC$35 = -108						; size = 4
_y$36 = -104						; size = 4
_dstLine$37 = -100					; size = 4
_srcCLine$38 = -96					; size = 4
_ic$39 = -92						; size = 4
_src_uv_pitch$ = -88					; size = 4
_uv_fin$ = -84						; size = 4
_x$40 = -80						; size = 4
_y$41 = -76						; size = 4
_y_width$42 = -72					; size = 4
_dstLine$43 = -68					; size = 4
_srcYLine$44 = -64					; size = 4
$T45 = -60						; size = 12
_y_range$ = -44						; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yv12_i_to_yuv444_c@G$0M@E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_i_to_yuv444_c<unsigned short,12,unsigned char,8,0>

; 683  : static void __forceinline convert_yv12_i_to_yuv444_c(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  00009	53		 push	 ebx
  0000a	57		 push	 edi
  0000b	8d bd e8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-280]
  00011	b9 46 00 00 00	 mov	 ecx, 70			; 00000046H
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 684  :     static_assert((sizeof(Tin)  == 1 && in_bit_depth  == 8) || (sizeof(Tin)  == 2 && 8 < in_bit_depth  && in_bit_depth  <= 16), "invalid input bit depth.");
; 685  :     static_assert((sizeof(Tout) == 1 && out_bit_depth == 8) || (sizeof(Tout) == 2 && 8 < out_bit_depth && out_bit_depth <= 16), "invalid output bit depth.");
; 686  :     const int crop_left   = crop[0];

  00027	b8 04 00 00 00	 mov	 eax, 4
  0002c	6b c8 00	 imul	 ecx, eax, 0
  0002f	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00032	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00035	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 687  :     const int crop_up     = crop[1];

  00038	b9 04 00 00 00	 mov	 ecx, 4
  0003d	c1 e1 00	 shl	 ecx, 0
  00040	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00043	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00046	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 688  :     const int crop_right  = crop[2];

  00049	b9 04 00 00 00	 mov	 ecx, 4
  0004e	d1 e1		 shl	 ecx, 1
  00050	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00053	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00056	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 689  :     const int crop_bottom = crop[3];

  00059	b9 04 00 00 00	 mov	 ecx, 4
  0005e	6b d1 03	 imul	 edx, ecx, 3
  00061	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00064	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00067	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 690  :     const int src_y_pitch = src_y_pitch_byte / sizeof(Tin);

  0006a	8b 55 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebp]
  0006d	d1 ea		 shr	 edx, 1
  0006f	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 691  :     const int dst_y_pitch = dst_y_pitch_byte / sizeof(Tout);

  00072	8b 45 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  00075	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 692  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00078	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0007b	51		 push	 ecx
  0007c	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0007f	52		 push	 edx
  00080	8b 45 20	 mov	 eax, DWORD PTR _height$[ebp]
  00083	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  00086	50		 push	 eax
  00087	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  0008a	51		 push	 ecx
  0008b	8d 95 14 ff ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  00091	52		 push	 edx
  00092	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00097	83 c4 14	 add	 esp, 20			; 00000014H
  0009a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009c	89 4d c4	 mov	 DWORD PTR $T45[ebp], ecx
  0009f	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a2	89 55 c8	 mov	 DWORD PTR $T45[ebp+4], edx
  000a5	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000a8	89 45 cc	 mov	 DWORD PTR $T45[ebp+8], eax
  000ab	8b 4d c4	 mov	 ecx, DWORD PTR $T45[ebp]
  000ae	89 4d d4	 mov	 DWORD PTR _y_range$[ebp], ecx
  000b1	8b 55 c8	 mov	 edx, DWORD PTR $T45[ebp+4]
  000b4	89 55 d8	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000b7	8b 45 cc	 mov	 eax, DWORD PTR $T45[ebp+8]
  000ba	89 45 dc	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 693  :     //Y
; 694  :     if (!uv_only) {

  000bd	b9 01 00 00 00	 mov	 ecx, 1
  000c2	85 c9		 test	 ecx, ecx
  000c4	0f 84 61 01 00
	00		 je	 $LN17@convert_yv

; 695  :         Tin *srcYLine = (Tin *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000ca	ba 04 00 00 00	 mov	 edx, 4
  000cf	6b c2 00	 imul	 eax, edx, 0
  000d2	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  000d5	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  000d9	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  000dc	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  000df	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  000e2	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  000e5	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  000e8	89 45 c0	 mov	 DWORD PTR _srcYLine$44[ebp], eax

; 696  :         Tout *dstLine = (Tout *)dst[0] + dst_y_pitch * y_range.start_dst;

  000eb	b9 04 00 00 00	 mov	 ecx, 4
  000f0	6b d1 00	 imul	 edx, ecx, 0
  000f3	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  000f6	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  000fa	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  000fd	03 04 11	 add	 eax, DWORD PTR [ecx+edx]
  00100	89 45 bc	 mov	 DWORD PTR _dstLine$43[ebp], eax

; 697  :         const int y_width = width - crop_right - crop_left;

  00103	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00106	2b 55 f0	 sub	 edx, DWORD PTR _crop_right$[ebp]
  00109	2b 55 f8	 sub	 edx, DWORD PTR _crop_left$[ebp]
  0010c	89 55 b8	 mov	 DWORD PTR _y_width$42[ebp], edx

; 698  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  0010f	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _y$41[ebp], 0
  00116	eb 1e		 jmp	 SHORT $LN4@convert_yv
$LN2@convert_yv:
  00118	8b 45 b4	 mov	 eax, DWORD PTR _y$41[ebp]
  0011b	83 c0 01	 add	 eax, 1
  0011e	89 45 b4	 mov	 DWORD PTR _y$41[ebp], eax
  00121	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  00124	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$44[ebp]
  00127	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  0012a	89 45 c0	 mov	 DWORD PTR _srcYLine$44[ebp], eax
  0012d	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$43[ebp]
  00130	03 4d e4	 add	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  00133	89 4d bc	 mov	 DWORD PTR _dstLine$43[ebp], ecx
$LN4@convert_yv:
  00136	8b 55 b4	 mov	 edx, DWORD PTR _y$41[ebp]
  00139	3b 55 dc	 cmp	 edx, DWORD PTR _y_range$[ebp+8]
  0013c	0f 8d e9 00 00
	00		 jge	 $LN17@convert_yv

; 699  :             if (in_bit_depth == out_bit_depth) {

  00142	33 c0		 xor	 eax, eax
  00144	74 1b		 je	 SHORT $LN18@convert_yv

; 700  :                 memcpy(dstLine, srcYLine, y_width * sizeof(Tin));

  00146	8b 4d b8	 mov	 ecx, DWORD PTR _y_width$42[ebp]
  00149	d1 e1		 shl	 ecx, 1
  0014b	51		 push	 ecx
  0014c	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$44[ebp]
  0014f	52		 push	 edx
  00150	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$43[ebp]
  00153	50		 push	 eax
  00154	e8 00 00 00 00	 call	 _memcpy
  00159	83 c4 0c	 add	 esp, 12			; 0000000cH

; 701  :             } else {

  0015c	e9 c5 00 00 00	 jmp	 $LN19@convert_yv
$LN18@convert_yv:

; 702  :                 for (int x = 0; x < y_width; x++) {

  00161	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _x$40[ebp], 0
  00168	eb 09		 jmp	 SHORT $LN7@convert_yv
$LN5@convert_yv:
  0016a	8b 4d b0	 mov	 ecx, DWORD PTR _x$40[ebp]
  0016d	83 c1 01	 add	 ecx, 1
  00170	89 4d b0	 mov	 DWORD PTR _x$40[ebp], ecx
$LN7@convert_yv:
  00173	8b 55 b0	 mov	 edx, DWORD PTR _x$40[ebp]
  00176	3b 55 b8	 cmp	 edx, DWORD PTR _y_width$42[ebp]
  00179	0f 8d a7 00 00
	00		 jge	 $LN19@convert_yv

; 703  :                     if (out_bit_depth > in_bit_depth) {

  0017f	33 c0		 xor	 eax, eax
  00181	74 42		 je	 SHORT $LN20@convert_yv

; 704  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) << std::max(out_bit_depth - in_bit_depth, 0));

  00183	c7 85 10 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], 0
  0018d	c7 85 0c ff ff
	ff fc ff ff ff	 mov	 DWORD PTR $T3[ebp], -4	; fffffffcH
  00197	8b 4d b0	 mov	 ecx, DWORD PTR _x$40[ebp]
  0019a	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$44[ebp]
  0019d	0f b7 1c 4a	 movzx	 ebx, WORD PTR [edx+ecx*2]
  001a1	8d 85 10 ff ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  001a7	50		 push	 eax
  001a8	8d 8d 0c ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  001ae	51		 push	 ecx
  001af	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  001b4	83 c4 08	 add	 esp, 8
  001b7	8b 08		 mov	 ecx, DWORD PTR [eax]
  001b9	d3 e3		 shl	 ebx, cl
  001bb	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$43[ebp]
  001be	03 55 b0	 add	 edx, DWORD PTR _x$40[ebp]
  001c1	88 1a		 mov	 BYTE PTR [edx], bl
  001c3	eb 5c		 jmp	 SHORT $LN21@convert_yv
$LN20@convert_yv:

; 705  :                     } else if (out_bit_depth < in_bit_depth) {

  001c5	b8 01 00 00 00	 mov	 eax, 1
  001ca	85 c0		 test	 eax, eax
  001cc	74 42		 je	 SHORT $LN22@convert_yv

; 706  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) >> std::max(in_bit_depth - out_bit_depth, 0));

  001ce	c7 85 08 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], 0
  001d8	c7 85 04 ff ff
	ff 04 00 00 00	 mov	 DWORD PTR $T1[ebp], 4
  001e2	8b 4d b0	 mov	 ecx, DWORD PTR _x$40[ebp]
  001e5	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$44[ebp]
  001e8	0f b7 1c 4a	 movzx	 ebx, WORD PTR [edx+ecx*2]
  001ec	8d 85 08 ff ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  001f2	50		 push	 eax
  001f3	8d 8d 04 ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  001f9	51		 push	 ecx
  001fa	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  001ff	83 c4 08	 add	 esp, 8
  00202	8b 08		 mov	 ecx, DWORD PTR [eax]
  00204	d3 fb		 sar	 ebx, cl
  00206	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$43[ebp]
  00209	03 55 b0	 add	 edx, DWORD PTR _x$40[ebp]
  0020c	88 1a		 mov	 BYTE PTR [edx], bl

; 707  :                     } else {

  0020e	eb 11		 jmp	 SHORT $LN21@convert_yv
$LN22@convert_yv:

; 708  :                         dstLine[x] = (Tout)srcYLine[x];

  00210	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$43[ebp]
  00213	03 45 b0	 add	 eax, DWORD PTR _x$40[ebp]
  00216	8b 4d b0	 mov	 ecx, DWORD PTR _x$40[ebp]
  00219	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$44[ebp]
  0021c	8a 0c 4a	 mov	 cl, BYTE PTR [edx+ecx*2]
  0021f	88 08		 mov	 BYTE PTR [eax], cl
$LN21@convert_yv:

; 709  :                     }
; 710  :                 }

  00221	e9 44 ff ff ff	 jmp	 $LN5@convert_yv
$LN19@convert_yv:

; 711  :             }
; 712  :         }

  00226	e9 ed fe ff ff	 jmp	 $LN2@convert_yv
$LN17@convert_yv:

; 713  :     }
; 714  :     //UV
; 715  :     const int uv_fin = height - crop_bottom;

  0022b	8b 55 20	 mov	 edx, DWORD PTR _height$[ebp]
  0022e	2b 55 ec	 sub	 edx, DWORD PTR _crop_bottom$[ebp]
  00231	89 55 ac	 mov	 DWORD PTR _uv_fin$[ebp], edx

; 716  :     const int src_uv_pitch = src_uv_pitch_byte / sizeof(Tin);

  00234	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  00237	d1 e8		 shr	 eax, 1
  00239	89 45 a8	 mov	 DWORD PTR _src_uv_pitch$[ebp], eax

; 717  :     for (int ic = 1; ic < 3; ic++) {

  0023c	c7 45 a4 01 00
	00 00		 mov	 DWORD PTR _ic$39[ebp], 1
  00243	eb 09		 jmp	 SHORT $LN10@convert_yv
$LN8@convert_yv:
  00245	8b 4d a4	 mov	 ecx, DWORD PTR _ic$39[ebp]
  00248	83 c1 01	 add	 ecx, 1
  0024b	89 4d a4	 mov	 DWORD PTR _ic$39[ebp], ecx
$LN10@convert_yv:
  0024e	83 7d a4 03	 cmp	 DWORD PTR _ic$39[ebp], 3
  00252	0f 8d ac 05 00
	00		 jge	 $LN1@convert_yv

; 718  :         Tin *srcCLine = (Tin *)src[ic] + (((src_uv_pitch * y_range.start_src) + crop_left) >> 1);

  00258	8b 55 a8	 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  0025b	0f af 55 d4	 imul	 edx, DWORD PTR _y_range$[ebp]
  0025f	03 55 f8	 add	 edx, DWORD PTR _crop_left$[ebp]
  00262	d1 fa		 sar	 edx, 1
  00264	8b 45 a4	 mov	 eax, DWORD PTR _ic$39[ebp]
  00267	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  0026a	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  0026d	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00270	89 4d a0	 mov	 DWORD PTR _srcCLine$38[ebp], ecx

; 719  :         Tout *dstLine = (Tout *)dst[ic] + dst_y_pitch * y_range.start_dst;

  00273	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  00276	0f af 55 d8	 imul	 edx, DWORD PTR _y_range$[ebp+4]
  0027a	8b 45 a4	 mov	 eax, DWORD PTR _ic$39[ebp]
  0027d	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  00280	03 14 81	 add	 edx, DWORD PTR [ecx+eax*4]
  00283	89 55 9c	 mov	 DWORD PTR _dstLine$37[ebp], edx

; 720  :         for (int y = 0; y < y_range.len; y += 4, srcCLine += src_uv_pitch * 2, dstLine += dst_y_pitch * 4) {

  00286	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _y$36[ebp], 0
  0028d	eb 23		 jmp	 SHORT $LN13@convert_yv
$LN11@convert_yv:
  0028f	8b 55 98	 mov	 edx, DWORD PTR _y$36[ebp]
  00292	83 c2 04	 add	 edx, 4
  00295	89 55 98	 mov	 DWORD PTR _y$36[ebp], edx
  00298	8b 45 a8	 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  0029b	d1 e0		 shl	 eax, 1
  0029d	8b 4d a0	 mov	 ecx, DWORD PTR _srcCLine$38[ebp]
  002a0	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  002a3	89 55 a0	 mov	 DWORD PTR _srcCLine$38[ebp], edx
  002a6	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  002a9	8b 4d 9c	 mov	 ecx, DWORD PTR _dstLine$37[ebp]
  002ac	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  002af	89 55 9c	 mov	 DWORD PTR _dstLine$37[ebp], edx
$LN13@convert_yv:
  002b2	8b 45 98	 mov	 eax, DWORD PTR _y$36[ebp]
  002b5	3b 45 dc	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  002b8	0f 8d 41 05 00
	00		 jge	 $LN12@convert_yv

; 721  :             Tout *dstC = dstLine;

  002be	8b 4d 9c	 mov	 ecx, DWORD PTR _dstLine$37[ebp]
  002c1	89 4d 94	 mov	 DWORD PTR _dstC$35[ebp], ecx

; 722  :             Tin *srcP = srcCLine;

  002c4	8b 55 a0	 mov	 edx, DWORD PTR _srcCLine$38[ebp]
  002c7	89 55 90	 mov	 DWORD PTR _srcP$34[ebp], edx

; 723  :             const int x_fin = width - crop_right - crop_left;

  002ca	8b 45 10	 mov	 eax, DWORD PTR _width$[ebp]
  002cd	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  002d0	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  002d3	89 45 8c	 mov	 DWORD PTR _x_fin$33[ebp], eax

; 724  : 
; 725  :             int y_m2 = (y >= 4) ? -2 : 0;

  002d6	83 7d 98 04	 cmp	 DWORD PTR _y$36[ebp], 4
  002da	7c 0c		 jl	 SHORT $LN31@convert_yv
  002dc	c7 85 00 ff ff
	ff fe ff ff ff	 mov	 DWORD PTR tv222[ebp], -2 ; fffffffeH
  002e6	eb 0a		 jmp	 SHORT $LN32@convert_yv
$LN31@convert_yv:
  002e8	c7 85 00 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv222[ebp], 0
$LN32@convert_yv:
  002f2	8b 8d 00 ff ff
	ff		 mov	 ecx, DWORD PTR tv222[ebp]
  002f8	89 4d 88	 mov	 DWORD PTR _y_m2$32[ebp], ecx

; 726  :             int y_m1 = (y >= 2) ? -1 : 1;

  002fb	83 7d 98 02	 cmp	 DWORD PTR _y$36[ebp], 2
  002ff	7c 0c		 jl	 SHORT $LN33@convert_yv
  00301	c7 85 fc fe ff
	ff ff ff ff ff	 mov	 DWORD PTR tv224[ebp], -1
  0030b	eb 0a		 jmp	 SHORT $LN34@convert_yv
$LN33@convert_yv:
  0030d	c7 85 fc fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv224[ebp], 1
$LN34@convert_yv:
  00317	8b 95 fc fe ff
	ff		 mov	 edx, DWORD PTR tv224[ebp]
  0031d	89 55 84	 mov	 DWORD PTR _y_m1$31[ebp], edx

; 727  :             int y_p1 = (y < uv_fin - 2) ? 1 : -1;

  00320	8b 45 ac	 mov	 eax, DWORD PTR _uv_fin$[ebp]
  00323	83 e8 02	 sub	 eax, 2
  00326	39 45 98	 cmp	 DWORD PTR _y$36[ebp], eax
  00329	7d 0c		 jge	 SHORT $LN35@convert_yv
  0032b	c7 85 f8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv227[ebp], 1
  00335	eb 0a		 jmp	 SHORT $LN36@convert_yv
$LN35@convert_yv:
  00337	c7 85 f8 fe ff
	ff ff ff ff ff	 mov	 DWORD PTR tv227[ebp], -1
$LN36@convert_yv:
  00341	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR tv227[ebp]
  00347	89 4d 80	 mov	 DWORD PTR _y_p1$30[ebp], ecx

; 728  :             int y_p2 = (y < uv_fin - 4) ? 2 :  0;

  0034a	8b 55 ac	 mov	 edx, DWORD PTR _uv_fin$[ebp]
  0034d	83 ea 04	 sub	 edx, 4
  00350	39 55 98	 cmp	 DWORD PTR _y$36[ebp], edx
  00353	7d 0c		 jge	 SHORT $LN37@convert_yv
  00355	c7 85 f4 fe ff
	ff 02 00 00 00	 mov	 DWORD PTR tv230[ebp], 2
  0035f	eb 0a		 jmp	 SHORT $LN38@convert_yv
$LN37@convert_yv:
  00361	c7 85 f4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv230[ebp], 0
$LN38@convert_yv:
  0036b	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR tv230[ebp]
  00371	89 85 7c ff ff
	ff		 mov	 DWORD PTR _y_p2$29[ebp], eax

; 729  :             int y_p3 = (y < uv_fin - 6) ? 3 : ((y < uv_fin - 2) ? 1 : -1);

  00377	8b 4d ac	 mov	 ecx, DWORD PTR _uv_fin$[ebp]
  0037a	83 e9 06	 sub	 ecx, 6
  0037d	39 4d 98	 cmp	 DWORD PTR _y$36[ebp], ecx
  00380	7d 0c		 jge	 SHORT $LN41@convert_yv
  00382	c7 85 f0 fe ff
	ff 03 00 00 00	 mov	 DWORD PTR tv236[ebp], 3
  0038c	eb 2d		 jmp	 SHORT $LN42@convert_yv
$LN41@convert_yv:
  0038e	8b 55 ac	 mov	 edx, DWORD PTR _uv_fin$[ebp]
  00391	83 ea 02	 sub	 edx, 2
  00394	39 55 98	 cmp	 DWORD PTR _y$36[ebp], edx
  00397	7d 0c		 jge	 SHORT $LN39@convert_yv
  00399	c7 85 ec fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv235[ebp], 1
  003a3	eb 0a		 jmp	 SHORT $LN40@convert_yv
$LN39@convert_yv:
  003a5	c7 85 ec fe ff
	ff ff ff ff ff	 mov	 DWORD PTR tv235[ebp], -1
$LN40@convert_yv:
  003af	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR tv235[ebp]
  003b5	89 85 f0 fe ff
	ff		 mov	 DWORD PTR tv236[ebp], eax
$LN42@convert_yv:
  003bb	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR tv236[ebp]
  003c1	89 8d 78 ff ff
	ff		 mov	 DWORD PTR _y_p3$28[ebp], ecx

; 730  : 
; 731  :             int sy0x0 = srcP[y_m2*src_uv_pitch + 0];

  003c7	8b 55 88	 mov	 edx, DWORD PTR _y_m2$32[ebp]
  003ca	0f af 55 a8	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp]
  003ce	8b 45 90	 mov	 eax, DWORD PTR _srcP$34[ebp]
  003d1	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  003d5	89 8d 74 ff ff
	ff		 mov	 DWORD PTR _sy0x0$27[ebp], ecx

; 732  :             int sy1x0 = srcP[y_m1*src_uv_pitch + 0];

  003db	8b 55 84	 mov	 edx, DWORD PTR _y_m1$31[ebp]
  003de	0f af 55 a8	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp]
  003e2	8b 45 90	 mov	 eax, DWORD PTR _srcP$34[ebp]
  003e5	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  003e9	89 8d 70 ff ff
	ff		 mov	 DWORD PTR _sy1x0$26[ebp], ecx

; 733  :             int sy2x0 = srcP[   0*src_uv_pitch + 0];

  003ef	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  003f3	8b 45 90	 mov	 eax, DWORD PTR _srcP$34[ebp]
  003f6	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  003fa	89 8d 6c ff ff
	ff		 mov	 DWORD PTR _sy2x0$25[ebp], ecx

; 734  :             int sy3x0 = srcP[y_p1*src_uv_pitch + 0];

  00400	8b 55 80	 mov	 edx, DWORD PTR _y_p1$30[ebp]
  00403	0f af 55 a8	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp]
  00407	8b 45 90	 mov	 eax, DWORD PTR _srcP$34[ebp]
  0040a	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  0040e	89 8d 68 ff ff
	ff		 mov	 DWORD PTR _sy3x0$24[ebp], ecx

; 735  :             int sy4x0 = srcP[y_p2*src_uv_pitch + 0];

  00414	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR _y_p2$29[ebp]
  0041a	0f af 55 a8	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp]
  0041e	8b 45 90	 mov	 eax, DWORD PTR _srcP$34[ebp]
  00421	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  00425	89 8d 64 ff ff
	ff		 mov	 DWORD PTR _sy4x0$23[ebp], ecx

; 736  :             int sy5x0 = srcP[y_p3*src_uv_pitch + 0];

  0042b	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _y_p3$28[ebp]
  00431	0f af 55 a8	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp]
  00435	8b 45 90	 mov	 eax, DWORD PTR _srcP$34[ebp]
  00438	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  0043c	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _sy5x0$22[ebp], ecx

; 737  : 
; 738  :             int cy0x0 = (sy0x0 * 1 + sy2x0 * 7 + 4);

  00442	6b 95 6c ff ff
	ff 07		 imul	 edx, DWORD PTR _sy2x0$25[ebp], 7
  00449	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _sy0x0$27[ebp]
  0044f	8d 4c 10 04	 lea	 ecx, DWORD PTR [eax+edx+4]
  00453	89 8d 5c ff ff
	ff		 mov	 DWORD PTR _cy0x0$21[ebp], ecx

; 739  :             int cy1x0 = (sy1x0 * 3 + sy3x0 * 5 + 4);

  00459	6b 95 70 ff ff
	ff 03		 imul	 edx, DWORD PTR _sy1x0$26[ebp], 3
  00460	6b 85 68 ff ff
	ff 05		 imul	 eax, DWORD PTR _sy3x0$24[ebp], 5
  00467	8d 4c 02 04	 lea	 ecx, DWORD PTR [edx+eax+4]
  0046b	89 8d 58 ff ff
	ff		 mov	 DWORD PTR _cy1x0$20[ebp], ecx

; 740  :             int cy2x0 = (sy2x0 * 5 + sy4x0 * 3 + 4);

  00471	6b 95 6c ff ff
	ff 05		 imul	 edx, DWORD PTR _sy2x0$25[ebp], 5
  00478	6b 85 64 ff ff
	ff 03		 imul	 eax, DWORD PTR _sy4x0$23[ebp], 3
  0047f	8d 4c 02 04	 lea	 ecx, DWORD PTR [edx+eax+4]
  00483	89 8d 54 ff ff
	ff		 mov	 DWORD PTR _cy2x0$19[ebp], ecx

; 741  :             int cy3x0 = (sy3x0 * 7 + sy5x0 * 1 + 4);

  00489	6b 95 68 ff ff
	ff 07		 imul	 edx, DWORD PTR _sy3x0$24[ebp], 7
  00490	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _sy5x0$22[ebp]
  00496	8d 4c 02 04	 lea	 ecx, DWORD PTR [edx+eax+4]
  0049a	89 8d 50 ff ff
	ff		 mov	 DWORD PTR _cy3x0$18[ebp], ecx

; 742  :             CHANGE_BIT_DEPTH_4(cy0x0, cy1x0, cy2x0, cy3x0, 3);

  004a0	33 d2		 xor	 edx, edx
  004a2	74 3e		 je	 SHORT $LN24@convert_yv
  004a4	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _cy0x0$21[ebp]
  004aa	c1 e0 f9	 shl	 eax, -7			; fffffff9H
  004ad	89 85 5c ff ff
	ff		 mov	 DWORD PTR _cy0x0$21[ebp], eax
  004b3	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x0$20[ebp]
  004b9	c1 e1 f9	 shl	 ecx, -7			; fffffff9H
  004bc	89 8d 58 ff ff
	ff		 mov	 DWORD PTR _cy1x0$20[ebp], ecx
  004c2	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR _cy2x0$19[ebp]
  004c8	c1 e2 f9	 shl	 edx, -7			; fffffff9H
  004cb	89 95 54 ff ff
	ff		 mov	 DWORD PTR _cy2x0$19[ebp], edx
  004d1	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$18[ebp]
  004d7	c1 e0 f9	 shl	 eax, -7			; fffffff9H
  004da	89 85 50 ff ff
	ff		 mov	 DWORD PTR _cy3x0$18[ebp], eax
  004e0	eb 45		 jmp	 SHORT $LN25@convert_yv
$LN24@convert_yv:
  004e2	b9 01 00 00 00	 mov	 ecx, 1
  004e7	85 c9		 test	 ecx, ecx
  004e9	74 3c		 je	 SHORT $LN25@convert_yv
  004eb	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR _cy0x0$21[ebp]
  004f1	c1 fa 07	 sar	 edx, 7
  004f4	89 95 5c ff ff
	ff		 mov	 DWORD PTR _cy0x0$21[ebp], edx
  004fa	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x0$20[ebp]
  00500	c1 f8 07	 sar	 eax, 7
  00503	89 85 58 ff ff
	ff		 mov	 DWORD PTR _cy1x0$20[ebp], eax
  00509	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _cy2x0$19[ebp]
  0050f	c1 f9 07	 sar	 ecx, 7
  00512	89 8d 54 ff ff
	ff		 mov	 DWORD PTR _cy2x0$19[ebp], ecx
  00518	8b 95 50 ff ff
	ff		 mov	 edx, DWORD PTR _cy3x0$18[ebp]
  0051e	c1 fa 07	 sar	 edx, 7
  00521	89 95 50 ff ff
	ff		 mov	 DWORD PTR _cy3x0$18[ebp], edx
$LN25@convert_yv:

; 743  : 
; 744  :             for (int x = 0; x < x_fin; x += 2, dstC += 2, srcP++) {

  00527	c7 85 4c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _x$17[ebp], 0
  00531	eb 21		 jmp	 SHORT $LN16@convert_yv
$LN14@convert_yv:
  00533	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _x$17[ebp]
  00539	83 c0 02	 add	 eax, 2
  0053c	89 85 4c ff ff
	ff		 mov	 DWORD PTR _x$17[ebp], eax
  00542	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$35[ebp]
  00545	83 c1 02	 add	 ecx, 2
  00548	89 4d 94	 mov	 DWORD PTR _dstC$35[ebp], ecx
  0054b	8b 55 90	 mov	 edx, DWORD PTR _srcP$34[ebp]
  0054e	83 c2 02	 add	 edx, 2
  00551	89 55 90	 mov	 DWORD PTR _srcP$34[ebp], edx
$LN16@convert_yv:
  00554	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _x$17[ebp]
  0055a	3b 45 8c	 cmp	 eax, DWORD PTR _x_fin$33[ebp]
  0055d	0f 8d 97 02 00
	00		 jge	 $LN15@convert_yv

; 745  :                 int cxplus = (x + 2 < x_fin);

  00563	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _x$17[ebp]
  00569	83 c1 02	 add	 ecx, 2
  0056c	3b 4d 8c	 cmp	 ecx, DWORD PTR _x_fin$33[ebp]
  0056f	7d 0c		 jge	 SHORT $LN43@convert_yv
  00571	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv297[ebp], 1
  0057b	eb 0a		 jmp	 SHORT $LN44@convert_yv
$LN43@convert_yv:
  0057d	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv297[ebp], 0
$LN44@convert_yv:
  00587	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR tv297[ebp]
  0058d	89 95 48 ff ff
	ff		 mov	 DWORD PTR _cxplus$16[ebp], edx

; 746  :                 int sy0x1 = srcP[y_m2*src_uv_pitch + cxplus];

  00593	8b 45 88	 mov	 eax, DWORD PTR _y_m2$32[ebp]
  00596	0f af 45 a8	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp]
  0059a	03 85 48 ff ff
	ff		 add	 eax, DWORD PTR _cxplus$16[ebp]
  005a0	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  005a3	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  005a7	89 95 44 ff ff
	ff		 mov	 DWORD PTR _sy0x1$15[ebp], edx

; 747  :                 int sy1x1 = srcP[y_m1*src_uv_pitch + cxplus];

  005ad	8b 45 84	 mov	 eax, DWORD PTR _y_m1$31[ebp]
  005b0	0f af 45 a8	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp]
  005b4	03 85 48 ff ff
	ff		 add	 eax, DWORD PTR _cxplus$16[ebp]
  005ba	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  005bd	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  005c1	89 95 40 ff ff
	ff		 mov	 DWORD PTR _sy1x1$14[ebp], edx

; 748  :                 int sy2x1 = srcP[   0*src_uv_pitch + cxplus];

  005c7	6b 45 a8 00	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp], 0
  005cb	03 85 48 ff ff
	ff		 add	 eax, DWORD PTR _cxplus$16[ebp]
  005d1	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  005d4	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  005d8	89 95 3c ff ff
	ff		 mov	 DWORD PTR _sy2x1$13[ebp], edx

; 749  :                 int sy3x1 = srcP[y_p1*src_uv_pitch + cxplus];

  005de	8b 45 80	 mov	 eax, DWORD PTR _y_p1$30[ebp]
  005e1	0f af 45 a8	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp]
  005e5	03 85 48 ff ff
	ff		 add	 eax, DWORD PTR _cxplus$16[ebp]
  005eb	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  005ee	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  005f2	89 95 38 ff ff
	ff		 mov	 DWORD PTR _sy3x1$12[ebp], edx

; 750  :                 int sy4x1 = srcP[y_p2*src_uv_pitch + cxplus];

  005f8	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _y_p2$29[ebp]
  005fe	0f af 45 a8	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp]
  00602	03 85 48 ff ff
	ff		 add	 eax, DWORD PTR _cxplus$16[ebp]
  00608	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  0060b	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  0060f	89 95 34 ff ff
	ff		 mov	 DWORD PTR _sy4x1$11[ebp], edx

; 751  :                 int sy5x1 = srcP[y_p3*src_uv_pitch + cxplus];

  00615	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _y_p3$28[ebp]
  0061b	0f af 45 a8	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp]
  0061f	03 85 48 ff ff
	ff		 add	 eax, DWORD PTR _cxplus$16[ebp]
  00625	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  00628	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  0062c	89 95 30 ff ff
	ff		 mov	 DWORD PTR _sy5x1$10[ebp], edx

; 752  : 
; 753  :                 int cy0x1 = (sy0x1 * 1 + sy2x1 * 7 + 4);

  00632	6b 85 3c ff ff
	ff 07		 imul	 eax, DWORD PTR _sy2x1$13[ebp], 7
  00639	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _sy0x1$15[ebp]
  0063f	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00643	89 95 2c ff ff
	ff		 mov	 DWORD PTR _cy0x1$9[ebp], edx

; 754  :                 int cy1x1 = (sy1x1 * 3 + sy3x1 * 5 + 4);

  00649	6b 85 40 ff ff
	ff 03		 imul	 eax, DWORD PTR _sy1x1$14[ebp], 3
  00650	6b 8d 38 ff ff
	ff 05		 imul	 ecx, DWORD PTR _sy3x1$12[ebp], 5
  00657	8d 54 08 04	 lea	 edx, DWORD PTR [eax+ecx+4]
  0065b	89 95 28 ff ff
	ff		 mov	 DWORD PTR _cy1x1$8[ebp], edx

; 755  :                 int cy2x1 = (sy2x1 * 5 + sy4x1 * 3 + 4);

  00661	6b 85 3c ff ff
	ff 05		 imul	 eax, DWORD PTR _sy2x1$13[ebp], 5
  00668	6b 8d 34 ff ff
	ff 03		 imul	 ecx, DWORD PTR _sy4x1$11[ebp], 3
  0066f	8d 54 08 04	 lea	 edx, DWORD PTR [eax+ecx+4]
  00673	89 95 24 ff ff
	ff		 mov	 DWORD PTR _cy2x1$7[ebp], edx

; 756  :                 int cy3x1 = (sy3x1 * 7 + sy5x1 * 1 + 4);

  00679	6b 85 38 ff ff
	ff 07		 imul	 eax, DWORD PTR _sy3x1$12[ebp], 7
  00680	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR _sy5x1$10[ebp]
  00686	8d 54 08 04	 lea	 edx, DWORD PTR [eax+ecx+4]
  0068a	89 95 20 ff ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], edx

; 757  :                 CHANGE_BIT_DEPTH_4(cy0x1, cy1x1, cy2x1, cy3x1, 3);

  00690	33 c0		 xor	 eax, eax
  00692	74 3e		 je	 SHORT $LN27@convert_yv
  00694	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR _cy0x1$9[ebp]
  0069a	c1 e1 f9	 shl	 ecx, -7			; fffffff9H
  0069d	89 8d 2c ff ff
	ff		 mov	 DWORD PTR _cy0x1$9[ebp], ecx
  006a3	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x1$8[ebp]
  006a9	c1 e2 f9	 shl	 edx, -7			; fffffff9H
  006ac	89 95 28 ff ff
	ff		 mov	 DWORD PTR _cy1x1$8[ebp], edx
  006b2	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _cy2x1$7[ebp]
  006b8	c1 e0 f9	 shl	 eax, -7			; fffffff9H
  006bb	89 85 24 ff ff
	ff		 mov	 DWORD PTR _cy2x1$7[ebp], eax
  006c1	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x1$6[ebp]
  006c7	c1 e1 f9	 shl	 ecx, -7			; fffffff9H
  006ca	89 8d 20 ff ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], ecx
  006d0	eb 45		 jmp	 SHORT $LN28@convert_yv
$LN27@convert_yv:
  006d2	ba 01 00 00 00	 mov	 edx, 1
  006d7	85 d2		 test	 edx, edx
  006d9	74 3c		 je	 SHORT $LN28@convert_yv
  006db	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR _cy0x1$9[ebp]
  006e1	c1 f8 07	 sar	 eax, 7
  006e4	89 85 2c ff ff
	ff		 mov	 DWORD PTR _cy0x1$9[ebp], eax
  006ea	8b 8d 28 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x1$8[ebp]
  006f0	c1 f9 07	 sar	 ecx, 7
  006f3	89 8d 28 ff ff
	ff		 mov	 DWORD PTR _cy1x1$8[ebp], ecx
  006f9	8b 95 24 ff ff
	ff		 mov	 edx, DWORD PTR _cy2x1$7[ebp]
  006ff	c1 fa 07	 sar	 edx, 7
  00702	89 95 24 ff ff
	ff		 mov	 DWORD PTR _cy2x1$7[ebp], edx
  00708	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x1$6[ebp]
  0070e	c1 f8 07	 sar	 eax, 7
  00711	89 85 20 ff ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], eax
$LN28@convert_yv:

; 758  : 
; 759  :                 dstC[0*dst_y_pitch   + 0] = (Tout)cy0x0;

  00717	6b 4d e4 00	 imul	 ecx, DWORD PTR _dst_y_pitch$[ebp], 0
  0071b	8b 55 94	 mov	 edx, DWORD PTR _dstC$35[ebp]
  0071e	8a 85 5c ff ff
	ff		 mov	 al, BYTE PTR _cy0x0$21[ebp]
  00724	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 760  :                 dstC[0*dst_y_pitch   + 1] = (Tout)((cy0x0 + cy0x1 + 1) >> 1);

  00727	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR _cy0x1$9[ebp]
  0072d	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR _cy0x0$21[ebp]
  00733	8d 44 0a 01	 lea	 eax, DWORD PTR [edx+ecx+1]
  00737	d1 f8		 sar	 eax, 1
  00739	6b 4d e4 00	 imul	 ecx, DWORD PTR _dst_y_pitch$[ebp], 0
  0073d	8b 55 94	 mov	 edx, DWORD PTR _dstC$35[ebp]
  00740	88 44 0a 01	 mov	 BYTE PTR [edx+ecx+1], al

; 761  :                 dstC[1*dst_y_pitch   + 0] = (Tout)cy1x0;

  00744	8b 45 94	 mov	 eax, DWORD PTR _dstC$35[ebp]
  00747	03 45 e4	 add	 eax, DWORD PTR _dst_y_pitch$[ebp]
  0074a	8a 8d 58 ff ff
	ff		 mov	 cl, BYTE PTR _cy1x0$20[ebp]
  00750	88 08		 mov	 BYTE PTR [eax], cl

; 762  :                 dstC[1*dst_y_pitch   + 1] = (Tout)((cy1x0 + cy1x1 + 1) >> 1);

  00752	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x1$8[ebp]
  00758	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x0$20[ebp]
  0075e	8d 4c 10 01	 lea	 ecx, DWORD PTR [eax+edx+1]
  00762	d1 f9		 sar	 ecx, 1
  00764	8b 55 94	 mov	 edx, DWORD PTR _dstC$35[ebp]
  00767	03 55 e4	 add	 edx, DWORD PTR _dst_y_pitch$[ebp]
  0076a	88 4a 01	 mov	 BYTE PTR [edx+1], cl

; 763  :                 dstC[2*dst_y_pitch   + 0] = (Tout)cy2x0;

  0076d	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  00770	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$35[ebp]
  00773	8a 95 54 ff ff
	ff		 mov	 dl, BYTE PTR _cy2x0$19[ebp]
  00779	88 14 41	 mov	 BYTE PTR [ecx+eax*2], dl

; 764  :                 dstC[2*dst_y_pitch   + 1] = (Tout)((cy2x0 + cy2x1 + 1) >> 1);

  0077c	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _cy2x1$7[ebp]
  00782	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _cy2x0$19[ebp]
  00788	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  0078c	d1 fa		 sar	 edx, 1
  0078e	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  00791	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$35[ebp]
  00794	88 54 41 01	 mov	 BYTE PTR [ecx+eax*2+1], dl

; 765  :                 dstC[3*dst_y_pitch   + 0] = (Tout)cy3x0;

  00798	6b 55 e4 03	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 3
  0079c	8b 45 94	 mov	 eax, DWORD PTR _dstC$35[ebp]
  0079f	8a 8d 50 ff ff
	ff		 mov	 cl, BYTE PTR _cy3x0$18[ebp]
  007a5	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 766  :                 dstC[3*dst_y_pitch   + 1] = (Tout)((cy3x0 + cy3x1 + 1) >> 1);

  007a8	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR _cy3x1$6[ebp]
  007ae	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$18[ebp]
  007b4	8d 4c 10 01	 lea	 ecx, DWORD PTR [eax+edx+1]
  007b8	d1 f9		 sar	 ecx, 1
  007ba	6b 55 e4 03	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 3
  007be	8b 45 94	 mov	 eax, DWORD PTR _dstC$35[ebp]
  007c1	88 4c 10 01	 mov	 BYTE PTR [eax+edx+1], cl

; 767  : 
; 768  :                 cy0x0 = cy0x1;

  007c5	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR _cy0x1$9[ebp]
  007cb	89 8d 5c ff ff
	ff		 mov	 DWORD PTR _cy0x0$21[ebp], ecx

; 769  :                 cy1x0 = cy1x1;

  007d1	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x1$8[ebp]
  007d7	89 95 58 ff ff
	ff		 mov	 DWORD PTR _cy1x0$20[ebp], edx

; 770  :                 cy2x0 = cy2x1;

  007dd	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _cy2x1$7[ebp]
  007e3	89 85 54 ff ff
	ff		 mov	 DWORD PTR _cy2x0$19[ebp], eax

; 771  :                 cy3x0 = cy3x1;

  007e9	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x1$6[ebp]
  007ef	89 8d 50 ff ff
	ff		 mov	 DWORD PTR _cy3x0$18[ebp], ecx

; 772  :             }

  007f5	e9 39 fd ff ff	 jmp	 $LN14@convert_yv
$LN15@convert_yv:

; 773  :         }

  007fa	e9 90 fa ff ff	 jmp	 $LN11@convert_yv
$LN12@convert_yv:

; 774  :     }

  007ff	e9 41 fa ff ff	 jmp	 $LN8@convert_yv
$LN1@convert_yv:

; 775  : }

  00804	52		 push	 edx
  00805	8b cd		 mov	 ecx, ebp
  00807	50		 push	 eax
  00808	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN47@convert_yv
  0080e	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00813	58		 pop	 eax
  00814	5a		 pop	 edx
  00815	5f		 pop	 edi
  00816	5b		 pop	 ebx
  00817	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0081a	33 cd		 xor	 ecx, ebp
  0081c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00821	81 c4 18 01 00
	00		 add	 esp, 280		; 00000118H
  00827	3b ec		 cmp	 ebp, esp
  00829	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0082e	8b e5		 mov	 esp, ebp
  00830	5d		 pop	 ebp
  00831	c3		 ret	 0
  00832	66 90		 npad	 2
$LN47@convert_yv:
  00834	01 00 00 00	 DD	 1
  00838	00 00 00 00	 DD	 $LN46@convert_yv
$LN46@convert_yv:
  0083c	d4 ff ff ff	 DD	 -44			; ffffffd4H
  00840	0c 00 00 00	 DD	 12			; 0000000cH
  00844	00 00 00 00	 DD	 $LN45@convert_yv
$LN45@convert_yv:
  00848	79		 DB	 121			; 00000079H
  00849	5f		 DB	 95			; 0000005fH
  0084a	72		 DB	 114			; 00000072H
  0084b	61		 DB	 97			; 00000061H
  0084c	6e		 DB	 110			; 0000006eH
  0084d	67		 DB	 103			; 00000067H
  0084e	65		 DB	 101			; 00000065H
  0084f	00		 DB	 0
??$convert_yv12_i_to_yuv444_c@G$0M@E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_i_to_yuv444_c<unsigned short,12,unsigned char,8,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yv12_12_i_to_yuv444@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_12_i_to_yuv444

; 813  : static void convert_yv12_12_i_to_yuv444(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 814  :     convert_yv12_i_to_yuv444_c<uint16_t, 12, uint8_t, 8, false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yv12_i_to_yuv444_c@G$0M@E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_i_to_yuv444_c<unsigned short,12,unsigned char,8,0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 815  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yv12_12_i_to_yuv444@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_12_i_to_yuv444
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
tv427 = -300						; size = 4
tv312 = -296						; size = 4
tv227 = -292						; size = 4
$T1 = -288						; size = 4
$T2 = -284						; size = 4
$T3 = -280						; size = 4
$T4 = -276						; size = 4
$T5 = -272						; size = 12
_cy3x1$6 = -260						; size = 4
_cy1x1$7 = -256						; size = 4
_cy3x0$8 = -252						; size = 4
_cy1x0$9 = -248						; size = 4
_cy4x1$10 = -244					; size = 4
_cy2x1$11 = -240					; size = 4
_cy0x1$12 = -236					; size = 4
_cy4x0$13 = -232					; size = 4
_cy2x0$14 = -228					; size = 4
_cy0x0$15 = -224					; size = 4
_cxplus$16 = -220					; size = 4
_x$17 = -216						; size = 4
_cy3x1$18 = -212					; size = 4
_cy1x1$19 = -208					; size = 4
_cy3x0$20 = -204					; size = 4
_cy1x0$21 = -200					; size = 4
_cy4x1$22 = -196					; size = 4
_cy2x1$23 = -192					; size = 4
_cy0x1$24 = -188					; size = 4
_cy4x0$25 = -184					; size = 4
_cy2x0$26 = -180					; size = 4
_cy0x0$27 = -176					; size = 4
_cxplus$28 = -172					; size = 4
_x$29 = -168						; size = 4
_cy3x1$30 = -164					; size = 4
_cy1x1$31 = -160					; size = 4
_cy3x0$32 = -156					; size = 4
_cy1x0$33 = -152					; size = 4
_cy4x1$34 = -148					; size = 4
_cy2x1$35 = -144					; size = 4
_cy0x1$36 = -140					; size = 4
_cy4x0$37 = -136					; size = 4
_cy2x0$38 = -132					; size = 4
_cy0x0$39 = -128					; size = 4
_cxplus$40 = -124					; size = 4
_x$41 = -120						; size = 4
_x_fin$42 = -116					; size = 4
_srcP$43 = -112						; size = 4
_dstC$44 = -108						; size = 4
_y$45 = -104						; size = 4
_dstLine$46 = -100					; size = 4
_srcCLine$47 = -96					; size = 4
_ic$48 = -92						; size = 4
_src_uv_pitch$ = -88					; size = 4
_x$49 = -84						; size = 4
_y$50 = -80						; size = 4
_y_width$51 = -76					; size = 4
_y_fin$52 = -72						; size = 4
_dstLine$53 = -68					; size = 4
_srcYLine$54 = -64					; size = 4
$T55 = -60						; size = 12
_y_range$ = -44						; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yv12_p_to_yuv444_c@G$0M@E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_p_to_yuv444_c<unsigned short,12,unsigned char,8,0>

; 573  : static void __forceinline convert_yv12_p_to_yuv444_c(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 2c 01 00
	00		 sub	 esp, 300		; 0000012cH
  00009	53		 push	 ebx
  0000a	57		 push	 edi
  0000b	8d bd d4 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-300]
  00011	b9 4b 00 00 00	 mov	 ecx, 75			; 0000004bH
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 574  :     static_assert((sizeof(Tin)  == 1 && in_bit_depth  == 8) || (sizeof(Tin)  == 2 && 8 < in_bit_depth  && in_bit_depth  <= 16), "invalid input bit depth.");
; 575  :     static_assert((sizeof(Tout) == 1 && out_bit_depth == 8) || (sizeof(Tout) == 2 && 8 < out_bit_depth && out_bit_depth <= 16), "invalid output bit depth.");
; 576  :     const int crop_left   = crop[0];

  00027	b8 04 00 00 00	 mov	 eax, 4
  0002c	6b c8 00	 imul	 ecx, eax, 0
  0002f	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00032	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00035	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 577  :     const int crop_up     = crop[1];

  00038	b9 04 00 00 00	 mov	 ecx, 4
  0003d	c1 e1 00	 shl	 ecx, 0
  00040	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00043	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00046	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 578  :     const int crop_right  = crop[2];

  00049	b9 04 00 00 00	 mov	 ecx, 4
  0004e	d1 e1		 shl	 ecx, 1
  00050	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00053	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00056	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 579  :     const int crop_bottom = crop[3];

  00059	b9 04 00 00 00	 mov	 ecx, 4
  0005e	6b d1 03	 imul	 edx, ecx, 3
  00061	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00064	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00067	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 580  :     const int src_y_pitch = src_y_pitch_byte / sizeof(Tin);

  0006a	8b 55 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebp]
  0006d	d1 ea		 shr	 edx, 1
  0006f	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 581  :     const int dst_y_pitch = dst_y_pitch_byte / sizeof(Tout);

  00072	8b 45 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  00075	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 582  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00078	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0007b	51		 push	 ecx
  0007c	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0007f	52		 push	 edx
  00080	8b 45 20	 mov	 eax, DWORD PTR _height$[ebp]
  00083	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  00086	50		 push	 eax
  00087	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  0008a	51		 push	 ecx
  0008b	8d 95 f0 fe ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  00091	52		 push	 edx
  00092	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00097	83 c4 14	 add	 esp, 20			; 00000014H
  0009a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009c	89 4d c4	 mov	 DWORD PTR $T55[ebp], ecx
  0009f	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a2	89 55 c8	 mov	 DWORD PTR $T55[ebp+4], edx
  000a5	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000a8	89 45 cc	 mov	 DWORD PTR $T55[ebp+8], eax
  000ab	8b 4d c4	 mov	 ecx, DWORD PTR $T55[ebp]
  000ae	89 4d d4	 mov	 DWORD PTR _y_range$[ebp], ecx
  000b1	8b 55 c8	 mov	 edx, DWORD PTR $T55[ebp+4]
  000b4	89 55 d8	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000b7	8b 45 cc	 mov	 eax, DWORD PTR $T55[ebp+8]
  000ba	89 45 dc	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 583  :     //Y
; 584  :     if (!uv_only) {

  000bd	b9 01 00 00 00	 mov	 ecx, 1
  000c2	85 c9		 test	 ecx, ecx
  000c4	0f 84 6a 01 00
	00		 je	 $LN23@convert_yv

; 585  :         Tin *srcYLine = (Tin *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000ca	ba 04 00 00 00	 mov	 edx, 4
  000cf	6b c2 00	 imul	 eax, edx, 0
  000d2	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  000d5	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  000d9	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  000dc	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  000df	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  000e2	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  000e5	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  000e8	89 45 c0	 mov	 DWORD PTR _srcYLine$54[ebp], eax

; 586  :         Tout *dstLine = (Tout *)dst[0] + dst_y_pitch * y_range.start_dst;

  000eb	b9 04 00 00 00	 mov	 ecx, 4
  000f0	6b d1 00	 imul	 edx, ecx, 0
  000f3	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  000f6	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  000fa	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  000fd	03 04 11	 add	 eax, DWORD PTR [ecx+edx]
  00100	89 45 bc	 mov	 DWORD PTR _dstLine$53[ebp], eax

; 587  :         const int y_fin = height - crop_bottom;

  00103	8b 55 20	 mov	 edx, DWORD PTR _height$[ebp]
  00106	2b 55 ec	 sub	 edx, DWORD PTR _crop_bottom$[ebp]
  00109	89 55 b8	 mov	 DWORD PTR _y_fin$52[ebp], edx

; 588  :         const int y_width = width - crop_right - crop_left;

  0010c	8b 45 10	 mov	 eax, DWORD PTR _width$[ebp]
  0010f	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  00112	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  00115	89 45 b4	 mov	 DWORD PTR _y_width$51[ebp], eax

; 589  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  00118	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _y$50[ebp], 0
  0011f	eb 1e		 jmp	 SHORT $LN4@convert_yv
$LN2@convert_yv:
  00121	8b 4d b0	 mov	 ecx, DWORD PTR _y$50[ebp]
  00124	83 c1 01	 add	 ecx, 1
  00127	89 4d b0	 mov	 DWORD PTR _y$50[ebp], ecx
  0012a	8b 55 e8	 mov	 edx, DWORD PTR _src_y_pitch$[ebp]
  0012d	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$54[ebp]
  00130	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00133	89 4d c0	 mov	 DWORD PTR _srcYLine$54[ebp], ecx
  00136	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$53[ebp]
  00139	03 55 e4	 add	 edx, DWORD PTR _dst_y_pitch$[ebp]
  0013c	89 55 bc	 mov	 DWORD PTR _dstLine$53[ebp], edx
$LN4@convert_yv:
  0013f	8b 45 b0	 mov	 eax, DWORD PTR _y$50[ebp]
  00142	3b 45 dc	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  00145	0f 8d e9 00 00
	00		 jge	 $LN23@convert_yv

; 590  :             if (in_bit_depth == out_bit_depth && sizeof(Tin) == sizeof(Tout)) {

  0014b	33 c9		 xor	 ecx, ecx
  0014d	74 1b		 je	 SHORT $LN24@convert_yv

; 591  :                 memcpy(dstLine, srcYLine, y_width * sizeof(Tin));

  0014f	8b 55 b4	 mov	 edx, DWORD PTR _y_width$51[ebp]
  00152	d1 e2		 shl	 edx, 1
  00154	52		 push	 edx
  00155	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$54[ebp]
  00158	50		 push	 eax
  00159	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$53[ebp]
  0015c	51		 push	 ecx
  0015d	e8 00 00 00 00	 call	 _memcpy
  00162	83 c4 0c	 add	 esp, 12			; 0000000cH

; 592  :             } else {

  00165	e9 c5 00 00 00	 jmp	 $LN25@convert_yv
$LN24@convert_yv:

; 593  :                 for (int x = 0; x < y_width; x++) {

  0016a	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR _x$49[ebp], 0
  00171	eb 09		 jmp	 SHORT $LN7@convert_yv
$LN5@convert_yv:
  00173	8b 55 ac	 mov	 edx, DWORD PTR _x$49[ebp]
  00176	83 c2 01	 add	 edx, 1
  00179	89 55 ac	 mov	 DWORD PTR _x$49[ebp], edx
$LN7@convert_yv:
  0017c	8b 45 ac	 mov	 eax, DWORD PTR _x$49[ebp]
  0017f	3b 45 b4	 cmp	 eax, DWORD PTR _y_width$51[ebp]
  00182	0f 8d a7 00 00
	00		 jge	 $LN25@convert_yv

; 594  :                     if (out_bit_depth > in_bit_depth) {

  00188	33 c9		 xor	 ecx, ecx
  0018a	74 42		 je	 SHORT $LN26@convert_yv

; 595  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) << std::max(out_bit_depth - in_bit_depth, 0));

  0018c	c7 85 ec fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], 0
  00196	c7 85 e8 fe ff
	ff fc ff ff ff	 mov	 DWORD PTR $T3[ebp], -4	; fffffffcH
  001a0	8b 55 ac	 mov	 edx, DWORD PTR _x$49[ebp]
  001a3	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$54[ebp]
  001a6	0f b7 1c 50	 movzx	 ebx, WORD PTR [eax+edx*2]
  001aa	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  001b0	51		 push	 ecx
  001b1	8d 95 e8 fe ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  001b7	52		 push	 edx
  001b8	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  001bd	83 c4 08	 add	 esp, 8
  001c0	8b 08		 mov	 ecx, DWORD PTR [eax]
  001c2	d3 e3		 shl	 ebx, cl
  001c4	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$53[ebp]
  001c7	03 45 ac	 add	 eax, DWORD PTR _x$49[ebp]
  001ca	88 18		 mov	 BYTE PTR [eax], bl
  001cc	eb 5c		 jmp	 SHORT $LN27@convert_yv
$LN26@convert_yv:

; 596  :                     } else if (out_bit_depth < in_bit_depth) {

  001ce	b9 01 00 00 00	 mov	 ecx, 1
  001d3	85 c9		 test	 ecx, ecx
  001d5	74 42		 je	 SHORT $LN28@convert_yv

; 597  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) >> std::max(in_bit_depth - out_bit_depth, 0));

  001d7	c7 85 e4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], 0
  001e1	c7 85 e0 fe ff
	ff 04 00 00 00	 mov	 DWORD PTR $T1[ebp], 4
  001eb	8b 55 ac	 mov	 edx, DWORD PTR _x$49[ebp]
  001ee	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$54[ebp]
  001f1	0f b7 1c 50	 movzx	 ebx, WORD PTR [eax+edx*2]
  001f5	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  001fb	51		 push	 ecx
  001fc	8d 95 e0 fe ff
	ff		 lea	 edx, DWORD PTR $T1[ebp]
  00202	52		 push	 edx
  00203	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  00208	83 c4 08	 add	 esp, 8
  0020b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0020d	d3 fb		 sar	 ebx, cl
  0020f	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$53[ebp]
  00212	03 45 ac	 add	 eax, DWORD PTR _x$49[ebp]
  00215	88 18		 mov	 BYTE PTR [eax], bl

; 598  :                     } else {

  00217	eb 11		 jmp	 SHORT $LN27@convert_yv
$LN28@convert_yv:

; 599  :                         dstLine[x] = (Tout)srcYLine[x];

  00219	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$53[ebp]
  0021c	03 4d ac	 add	 ecx, DWORD PTR _x$49[ebp]
  0021f	8b 55 ac	 mov	 edx, DWORD PTR _x$49[ebp]
  00222	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$54[ebp]
  00225	8a 14 50	 mov	 dl, BYTE PTR [eax+edx*2]
  00228	88 11		 mov	 BYTE PTR [ecx], dl
$LN27@convert_yv:

; 600  :                     }
; 601  :                 }

  0022a	e9 44 ff ff ff	 jmp	 $LN5@convert_yv
$LN25@convert_yv:

; 602  :             }
; 603  :         }

  0022f	e9 ed fe ff ff	 jmp	 $LN2@convert_yv
$LN23@convert_yv:

; 604  :     }
; 605  :     //UV
; 606  :     const int src_uv_pitch = src_uv_pitch_byte / sizeof(Tin);

  00234	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  00237	d1 e8		 shr	 eax, 1
  00239	89 45 a8	 mov	 DWORD PTR _src_uv_pitch$[ebp], eax

; 607  :     for (int ic = 1; ic < 3; ic++) {

  0023c	c7 45 a4 01 00
	00 00		 mov	 DWORD PTR _ic$48[ebp], 1
  00243	eb 09		 jmp	 SHORT $LN10@convert_yv
$LN8@convert_yv:
  00245	8b 4d a4	 mov	 ecx, DWORD PTR _ic$48[ebp]
  00248	83 c1 01	 add	 ecx, 1
  0024b	89 4d a4	 mov	 DWORD PTR _ic$48[ebp], ecx
$LN10@convert_yv:
  0024e	83 7d a4 03	 cmp	 DWORD PTR _ic$48[ebp], 3
  00252	0f 8d ea 06 00
	00		 jge	 $LN1@convert_yv

; 608  :         Tin *srcCLine = (Tin *)src[ic] + (((src_uv_pitch * y_range.start_src) + crop_left) >> 1);

  00258	8b 55 a8	 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  0025b	0f af 55 d4	 imul	 edx, DWORD PTR _y_range$[ebp]
  0025f	03 55 f8	 add	 edx, DWORD PTR _crop_left$[ebp]
  00262	d1 fa		 sar	 edx, 1
  00264	8b 45 a4	 mov	 eax, DWORD PTR _ic$48[ebp]
  00267	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  0026a	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  0026d	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00270	89 4d a0	 mov	 DWORD PTR _srcCLine$47[ebp], ecx

; 609  :         Tout *dstLine = (Tout *)dst[ic] + dst_y_pitch * y_range.start_dst;

  00273	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  00276	0f af 55 d8	 imul	 edx, DWORD PTR _y_range$[ebp+4]
  0027a	8b 45 a4	 mov	 eax, DWORD PTR _ic$48[ebp]
  0027d	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  00280	03 14 81	 add	 edx, DWORD PTR [ecx+eax*4]
  00283	89 55 9c	 mov	 DWORD PTR _dstLine$46[ebp], edx

; 610  :         for (int y = 0; y < y_range.len; y += 2, srcCLine += src_uv_pitch, dstLine += dst_y_pitch * 2) {

  00286	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _y$45[ebp], 0
  0028d	eb 21		 jmp	 SHORT $LN13@convert_yv
$LN11@convert_yv:
  0028f	8b 55 98	 mov	 edx, DWORD PTR _y$45[ebp]
  00292	83 c2 02	 add	 edx, 2
  00295	89 55 98	 mov	 DWORD PTR _y$45[ebp], edx
  00298	8b 45 a8	 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  0029b	8b 4d a0	 mov	 ecx, DWORD PTR _srcCLine$47[ebp]
  0029e	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  002a1	89 55 a0	 mov	 DWORD PTR _srcCLine$47[ebp], edx
  002a4	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  002a7	8b 4d 9c	 mov	 ecx, DWORD PTR _dstLine$46[ebp]
  002aa	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  002ad	89 55 9c	 mov	 DWORD PTR _dstLine$46[ebp], edx
$LN13@convert_yv:
  002b0	8b 45 98	 mov	 eax, DWORD PTR _y$45[ebp]
  002b3	3b 45 dc	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  002b6	0f 8d 81 06 00
	00		 jge	 $LN12@convert_yv

; 611  :             Tout *dstC = dstLine;

  002bc	8b 4d 9c	 mov	 ecx, DWORD PTR _dstLine$46[ebp]
  002bf	89 4d 94	 mov	 DWORD PTR _dstC$44[ebp], ecx

; 612  :             Tin *srcP = srcCLine;

  002c2	8b 55 a0	 mov	 edx, DWORD PTR _srcCLine$47[ebp]
  002c5	89 55 90	 mov	 DWORD PTR _srcP$43[ebp], edx

; 613  :             const int x_fin = width - crop_right - crop_left;

  002c8	8b 45 10	 mov	 eax, DWORD PTR _width$[ebp]
  002cb	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  002ce	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  002d1	89 45 8c	 mov	 DWORD PTR _x_fin$42[ebp], eax

; 614  :             if (y == 0) {

  002d4	83 7d 98 00	 cmp	 DWORD PTR _y$45[ebp], 0
  002d8	0f 85 04 02 00
	00		 jne	 $LN30@convert_yv

; 615  :                 for (int x = 0; x < x_fin; x += 2, dstC += 2, srcP++) {

  002de	c7 45 88 00 00
	00 00		 mov	 DWORD PTR _x$41[ebp], 0
  002e5	eb 1b		 jmp	 SHORT $LN16@convert_yv
$LN14@convert_yv:
  002e7	8b 4d 88	 mov	 ecx, DWORD PTR _x$41[ebp]
  002ea	83 c1 02	 add	 ecx, 2
  002ed	89 4d 88	 mov	 DWORD PTR _x$41[ebp], ecx
  002f0	8b 55 94	 mov	 edx, DWORD PTR _dstC$44[ebp]
  002f3	83 c2 02	 add	 edx, 2
  002f6	89 55 94	 mov	 DWORD PTR _dstC$44[ebp], edx
  002f9	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  002fc	83 c0 02	 add	 eax, 2
  002ff	89 45 90	 mov	 DWORD PTR _srcP$43[ebp], eax
$LN16@convert_yv:
  00302	8b 4d 88	 mov	 ecx, DWORD PTR _x$41[ebp]
  00305	3b 4d 8c	 cmp	 ecx, DWORD PTR _x_fin$42[ebp]
  00308	0f 8d cf 01 00
	00		 jge	 $LN15@convert_yv

; 616  :                     int cxplus = (x + 2 < x_fin);

  0030e	8b 55 88	 mov	 edx, DWORD PTR _x$41[ebp]
  00311	83 c2 02	 add	 edx, 2
  00314	3b 55 8c	 cmp	 edx, DWORD PTR _x_fin$42[ebp]
  00317	7d 0c		 jge	 SHORT $LN44@convert_yv
  00319	c7 85 dc fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv227[ebp], 1
  00323	eb 0a		 jmp	 SHORT $LN45@convert_yv
$LN44@convert_yv:
  00325	c7 85 dc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv227[ebp], 0
$LN45@convert_yv:
  0032f	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR tv227[ebp]
  00335	89 45 84	 mov	 DWORD PTR _cxplus$40[ebp], eax

; 617  :                     int cy0x0 = srcP[ 0*src_uv_pitch + 0];

  00338	6b 4d a8 00	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 0
  0033c	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  0033f	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00343	89 45 80	 mov	 DWORD PTR _cy0x0$39[ebp], eax

; 618  :                     int cy2x0 = srcP[ 0*src_uv_pitch + 0];

  00346	6b 4d a8 00	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 0
  0034a	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  0034d	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00351	89 85 7c ff ff
	ff		 mov	 DWORD PTR _cy2x0$38[ebp], eax

; 619  :                     int cy4x0 = srcP[ 1*src_uv_pitch + 0];

  00357	8b 4d a8	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  0035a	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  0035d	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00361	89 85 78 ff ff
	ff		 mov	 DWORD PTR _cy4x0$37[ebp], eax

; 620  :                     int cy0x1 = srcP[ 0*src_uv_pitch + cxplus];

  00367	6b 4d a8 00	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 0
  0036b	03 4d 84	 add	 ecx, DWORD PTR _cxplus$40[ebp]
  0036e	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  00371	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00375	89 85 74 ff ff
	ff		 mov	 DWORD PTR _cy0x1$36[ebp], eax

; 621  :                     int cy2x1 = srcP[ 0*src_uv_pitch + cxplus];

  0037b	6b 4d a8 00	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 0
  0037f	03 4d 84	 add	 ecx, DWORD PTR _cxplus$40[ebp]
  00382	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  00385	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00389	89 85 70 ff ff
	ff		 mov	 DWORD PTR _cy2x1$35[ebp], eax

; 622  :                     int cy4x1 = srcP[ 1*src_uv_pitch + cxplus];

  0038f	8b 4d 84	 mov	 ecx, DWORD PTR _cxplus$40[ebp]
  00392	03 4d a8	 add	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00395	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  00398	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  0039c	89 85 6c ff ff
	ff		 mov	 DWORD PTR _cy4x1$34[ebp], eax

; 623  : 
; 624  :                     int cy1x0 = (cy0x0 * 1 + cy2x0 * 3 + 2);

  003a2	6b 8d 7c ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy2x0$38[ebp], 3
  003a9	8b 55 80	 mov	 edx, DWORD PTR _cy0x0$39[ebp]
  003ac	8d 44 0a 02	 lea	 eax, DWORD PTR [edx+ecx+2]
  003b0	89 85 68 ff ff
	ff		 mov	 DWORD PTR _cy1x0$33[ebp], eax

; 625  :                     int cy3x0 = (cy2x0 * 3 + cy4x0 * 1 + 2);

  003b6	6b 8d 7c ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy2x0$38[ebp], 3
  003bd	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _cy4x0$37[ebp]
  003c3	8d 44 11 02	 lea	 eax, DWORD PTR [ecx+edx+2]
  003c7	89 85 64 ff ff
	ff		 mov	 DWORD PTR _cy3x0$32[ebp], eax

; 626  :                     int cy1x1 = (cy0x1 * 1 + cy2x1 * 3 + 2);

  003cd	6b 8d 70 ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy2x1$35[ebp], 3
  003d4	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _cy0x1$36[ebp]
  003da	8d 44 0a 02	 lea	 eax, DWORD PTR [edx+ecx+2]
  003de	89 85 60 ff ff
	ff		 mov	 DWORD PTR _cy1x1$31[ebp], eax

; 627  :                     int cy3x1 = (cy2x1 * 3 + cy4x1 * 1 + 2);

  003e4	6b 8d 70 ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy2x1$35[ebp], 3
  003eb	8b 95 6c ff ff
	ff		 mov	 edx, DWORD PTR _cy4x1$34[ebp]
  003f1	8d 44 11 02	 lea	 eax, DWORD PTR [ecx+edx+2]
  003f5	89 85 5c ff ff
	ff		 mov	 DWORD PTR _cy3x1$30[ebp], eax

; 628  :                     CHANGE_BIT_DEPTH_4(cy1x0, cy3x0, cy1x1, cy3x1, 2);

  003fb	33 c9		 xor	 ecx, ecx
  003fd	74 3e		 je	 SHORT $LN32@convert_yv
  003ff	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x0$33[ebp]
  00405	c1 e2 fa	 shl	 edx, -6			; fffffffaH
  00408	89 95 68 ff ff
	ff		 mov	 DWORD PTR _cy1x0$33[ebp], edx
  0040e	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$32[ebp]
  00414	c1 e0 fa	 shl	 eax, -6			; fffffffaH
  00417	89 85 64 ff ff
	ff		 mov	 DWORD PTR _cy3x0$32[ebp], eax
  0041d	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x1$31[ebp]
  00423	c1 e1 fa	 shl	 ecx, -6			; fffffffaH
  00426	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _cy1x1$31[ebp], ecx
  0042c	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR _cy3x1$30[ebp]
  00432	c1 e2 fa	 shl	 edx, -6			; fffffffaH
  00435	89 95 5c ff ff
	ff		 mov	 DWORD PTR _cy3x1$30[ebp], edx
  0043b	eb 45		 jmp	 SHORT $LN33@convert_yv
$LN32@convert_yv:
  0043d	b8 01 00 00 00	 mov	 eax, 1
  00442	85 c0		 test	 eax, eax
  00444	74 3c		 je	 SHORT $LN33@convert_yv
  00446	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x0$33[ebp]
  0044c	c1 f9 06	 sar	 ecx, 6
  0044f	89 8d 68 ff ff
	ff		 mov	 DWORD PTR _cy1x0$33[ebp], ecx
  00455	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR _cy3x0$32[ebp]
  0045b	c1 fa 06	 sar	 edx, 6
  0045e	89 95 64 ff ff
	ff		 mov	 DWORD PTR _cy3x0$32[ebp], edx
  00464	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x1$31[ebp]
  0046a	c1 f8 06	 sar	 eax, 6
  0046d	89 85 60 ff ff
	ff		 mov	 DWORD PTR _cy1x1$31[ebp], eax
  00473	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x1$30[ebp]
  00479	c1 f9 06	 sar	 ecx, 6
  0047c	89 8d 5c ff ff
	ff		 mov	 DWORD PTR _cy3x1$30[ebp], ecx
$LN33@convert_yv:

; 629  : 
; 630  :                     dstC[0*dst_y_pitch   + 0] = (Tout)cy1x0;

  00482	6b 55 e4 00	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 0
  00486	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  00489	8a 8d 68 ff ff
	ff		 mov	 cl, BYTE PTR _cy1x0$33[ebp]
  0048f	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 631  :                     dstC[0*dst_y_pitch   + 1] = (Tout)((cy1x0 + cy1x1 + 1) >> 1);

  00492	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x1$31[ebp]
  00498	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x0$33[ebp]
  0049e	8d 4c 10 01	 lea	 ecx, DWORD PTR [eax+edx+1]
  004a2	d1 f9		 sar	 ecx, 1
  004a4	6b 55 e4 00	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 0
  004a8	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  004ab	88 4c 10 01	 mov	 BYTE PTR [eax+edx+1], cl

; 632  :                     dstC[1*dst_y_pitch   + 0] = (Tout)cy3x0;

  004af	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$44[ebp]
  004b2	03 4d e4	 add	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  004b5	8a 95 64 ff ff
	ff		 mov	 dl, BYTE PTR _cy3x0$32[ebp]
  004bb	88 11		 mov	 BYTE PTR [ecx], dl

; 633  :                     dstC[1*dst_y_pitch   + 1] = (Tout)((cy3x0 + cy3x1 + 1) >> 1);

  004bd	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _cy3x1$30[ebp]
  004c3	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x0$32[ebp]
  004c9	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  004cd	d1 fa		 sar	 edx, 1
  004cf	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  004d2	03 45 e4	 add	 eax, DWORD PTR _dst_y_pitch$[ebp]
  004d5	88 50 01	 mov	 BYTE PTR [eax+1], dl

; 634  :                 }

  004d8	e9 0a fe ff ff	 jmp	 $LN14@convert_yv
$LN15@convert_yv:

; 635  :             } else if (y >= height-2) {

  004dd	e9 56 04 00 00	 jmp	 $LN31@convert_yv
$LN30@convert_yv:
  004e2	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  004e5	83 e9 02	 sub	 ecx, 2
  004e8	39 4d 98	 cmp	 DWORD PTR _y$45[ebp], ecx
  004eb	0f 8c 27 02 00
	00		 jl	 $LN35@convert_yv

; 636  :                 for (int x = 0; x < x_fin; x += 2, dstC += 2, srcP++) {

  004f1	c7 85 58 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _x$29[ebp], 0
  004fb	eb 21		 jmp	 SHORT $LN19@convert_yv
$LN17@convert_yv:
  004fd	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _x$29[ebp]
  00503	83 c2 02	 add	 edx, 2
  00506	89 95 58 ff ff
	ff		 mov	 DWORD PTR _x$29[ebp], edx
  0050c	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  0050f	83 c0 02	 add	 eax, 2
  00512	89 45 94	 mov	 DWORD PTR _dstC$44[ebp], eax
  00515	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$43[ebp]
  00518	83 c1 02	 add	 ecx, 2
  0051b	89 4d 90	 mov	 DWORD PTR _srcP$43[ebp], ecx
$LN19@convert_yv:
  0051e	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _x$29[ebp]
  00524	3b 55 8c	 cmp	 edx, DWORD PTR _x_fin$42[ebp]
  00527	0f 8d e6 01 00
	00		 jge	 $LN18@convert_yv

; 637  :                     int cxplus = (x + 2 < x_fin);

  0052d	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _x$29[ebp]
  00533	83 c0 02	 add	 eax, 2
  00536	3b 45 8c	 cmp	 eax, DWORD PTR _x_fin$42[ebp]
  00539	7d 0c		 jge	 SHORT $LN46@convert_yv
  0053b	c7 85 d8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv312[ebp], 1
  00545	eb 0a		 jmp	 SHORT $LN47@convert_yv
$LN46@convert_yv:
  00547	c7 85 d8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv312[ebp], 0
$LN47@convert_yv:
  00551	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR tv312[ebp]
  00557	89 8d 54 ff ff
	ff		 mov	 DWORD PTR _cxplus$28[ebp], ecx

; 638  :                     int cy0x0 = srcP[-1*src_uv_pitch + 0];

  0055d	6b 55 a8 ff	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], -1
  00561	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  00564	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  00568	89 8d 50 ff ff
	ff		 mov	 DWORD PTR _cy0x0$27[ebp], ecx

; 639  :                     int cy2x0 = srcP[ 0*src_uv_pitch + 0];

  0056e	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  00572	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  00575	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  00579	89 8d 4c ff ff
	ff		 mov	 DWORD PTR _cy2x0$26[ebp], ecx

; 640  :                     int cy4x0 = srcP[ 0*src_uv_pitch + 0];

  0057f	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  00583	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  00586	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  0058a	89 8d 48 ff ff
	ff		 mov	 DWORD PTR _cy4x0$25[ebp], ecx

; 641  :                     int cy0x1 = srcP[-1*src_uv_pitch + cxplus];

  00590	6b 55 a8 ff	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], -1
  00594	03 95 54 ff ff
	ff		 add	 edx, DWORD PTR _cxplus$28[ebp]
  0059a	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  0059d	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  005a1	89 8d 44 ff ff
	ff		 mov	 DWORD PTR _cy0x1$24[ebp], ecx

; 642  :                     int cy2x1 = srcP[ 0*src_uv_pitch + cxplus];

  005a7	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  005ab	03 95 54 ff ff
	ff		 add	 edx, DWORD PTR _cxplus$28[ebp]
  005b1	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  005b4	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  005b8	89 8d 40 ff ff
	ff		 mov	 DWORD PTR _cy2x1$23[ebp], ecx

; 643  :                     int cy4x1 = srcP[ 0*src_uv_pitch + cxplus];

  005be	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  005c2	03 95 54 ff ff
	ff		 add	 edx, DWORD PTR _cxplus$28[ebp]
  005c8	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  005cb	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  005cf	89 8d 3c ff ff
	ff		 mov	 DWORD PTR _cy4x1$22[ebp], ecx

; 644  : 
; 645  :                     int cy1x0 = (cy0x0 * 1 + cy2x0 * 3 + 2);

  005d5	6b 95 4c ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x0$26[ebp], 3
  005dc	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _cy0x0$27[ebp]
  005e2	8d 4c 10 02	 lea	 ecx, DWORD PTR [eax+edx+2]
  005e6	89 8d 38 ff ff
	ff		 mov	 DWORD PTR _cy1x0$21[ebp], ecx

; 646  :                     int cy3x0 = (cy2x0 * 3 + cy4x0 * 1 + 2);

  005ec	6b 95 4c ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x0$26[ebp], 3
  005f3	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _cy4x0$25[ebp]
  005f9	8d 4c 02 02	 lea	 ecx, DWORD PTR [edx+eax+2]
  005fd	89 8d 34 ff ff
	ff		 mov	 DWORD PTR _cy3x0$20[ebp], ecx

; 647  :                     int cy1x1 = (cy0x1 * 1 + cy2x1 * 3 + 2);

  00603	6b 95 40 ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x1$23[ebp], 3
  0060a	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _cy0x1$24[ebp]
  00610	8d 4c 10 02	 lea	 ecx, DWORD PTR [eax+edx+2]
  00614	89 8d 30 ff ff
	ff		 mov	 DWORD PTR _cy1x1$19[ebp], ecx

; 648  :                     int cy3x1 = (cy2x1 * 3 + cy4x1 * 1 + 2);

  0061a	6b 95 40 ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x1$23[ebp], 3
  00621	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _cy4x1$22[ebp]
  00627	8d 4c 02 02	 lea	 ecx, DWORD PTR [edx+eax+2]
  0062b	89 8d 2c ff ff
	ff		 mov	 DWORD PTR _cy3x1$18[ebp], ecx

; 649  :                     CHANGE_BIT_DEPTH_4(cy1x0, cy3x0, cy1x1, cy3x1, 2);

  00631	33 d2		 xor	 edx, edx
  00633	74 3e		 je	 SHORT $LN37@convert_yv
  00635	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x0$21[ebp]
  0063b	c1 e0 fa	 shl	 eax, -6			; fffffffaH
  0063e	89 85 38 ff ff
	ff		 mov	 DWORD PTR _cy1x0$21[ebp], eax
  00644	8b 8d 34 ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x0$20[ebp]
  0064a	c1 e1 fa	 shl	 ecx, -6			; fffffffaH
  0064d	89 8d 34 ff ff
	ff		 mov	 DWORD PTR _cy3x0$20[ebp], ecx
  00653	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x1$19[ebp]
  00659	c1 e2 fa	 shl	 edx, -6			; fffffffaH
  0065c	89 95 30 ff ff
	ff		 mov	 DWORD PTR _cy1x1$19[ebp], edx
  00662	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR _cy3x1$18[ebp]
  00668	c1 e0 fa	 shl	 eax, -6			; fffffffaH
  0066b	89 85 2c ff ff
	ff		 mov	 DWORD PTR _cy3x1$18[ebp], eax
  00671	eb 45		 jmp	 SHORT $LN38@convert_yv
$LN37@convert_yv:
  00673	b9 01 00 00 00	 mov	 ecx, 1
  00678	85 c9		 test	 ecx, ecx
  0067a	74 3c		 je	 SHORT $LN38@convert_yv
  0067c	8b 95 38 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x0$21[ebp]
  00682	c1 fa 06	 sar	 edx, 6
  00685	89 95 38 ff ff
	ff		 mov	 DWORD PTR _cy1x0$21[ebp], edx
  0068b	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$20[ebp]
  00691	c1 f8 06	 sar	 eax, 6
  00694	89 85 34 ff ff
	ff		 mov	 DWORD PTR _cy3x0$20[ebp], eax
  0069a	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x1$19[ebp]
  006a0	c1 f9 06	 sar	 ecx, 6
  006a3	89 8d 30 ff ff
	ff		 mov	 DWORD PTR _cy1x1$19[ebp], ecx
  006a9	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR _cy3x1$18[ebp]
  006af	c1 fa 06	 sar	 edx, 6
  006b2	89 95 2c ff ff
	ff		 mov	 DWORD PTR _cy3x1$18[ebp], edx
$LN38@convert_yv:

; 650  : 
; 651  :                     dstC[0*dst_y_pitch   + 0] = (Tout)cy1x0;

  006b8	6b 45 e4 00	 imul	 eax, DWORD PTR _dst_y_pitch$[ebp], 0
  006bc	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$44[ebp]
  006bf	8a 95 38 ff ff
	ff		 mov	 dl, BYTE PTR _cy1x0$21[ebp]
  006c5	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 652  :                     dstC[0*dst_y_pitch   + 1] = (Tout)((cy1x0 + cy1x1 + 1) >> 1);

  006c8	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x1$19[ebp]
  006ce	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x0$21[ebp]
  006d4	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  006d8	d1 fa		 sar	 edx, 1
  006da	6b 45 e4 00	 imul	 eax, DWORD PTR _dst_y_pitch$[ebp], 0
  006de	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$44[ebp]
  006e1	88 54 01 01	 mov	 BYTE PTR [ecx+eax+1], dl

; 653  :                     dstC[1*dst_y_pitch   + 0] = (Tout)cy3x0;

  006e5	8b 55 94	 mov	 edx, DWORD PTR _dstC$44[ebp]
  006e8	03 55 e4	 add	 edx, DWORD PTR _dst_y_pitch$[ebp]
  006eb	8a 85 34 ff ff
	ff		 mov	 al, BYTE PTR _cy3x0$20[ebp]
  006f1	88 02		 mov	 BYTE PTR [edx], al

; 654  :                     dstC[1*dst_y_pitch   + 1] = (Tout)((cy3x0 + cy3x1 + 1) >> 1);

  006f3	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x1$18[ebp]
  006f9	8b 95 34 ff ff
	ff		 mov	 edx, DWORD PTR _cy3x0$20[ebp]
  006ff	8d 44 0a 01	 lea	 eax, DWORD PTR [edx+ecx+1]
  00703	d1 f8		 sar	 eax, 1
  00705	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$44[ebp]
  00708	03 4d e4	 add	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  0070b	88 41 01	 mov	 BYTE PTR [ecx+1], al

; 655  :                 }

  0070e	e9 ea fd ff ff	 jmp	 $LN17@convert_yv
$LN18@convert_yv:

; 656  :             } else {

  00713	e9 20 02 00 00	 jmp	 $LN31@convert_yv
$LN35@convert_yv:

; 657  :                 for (int x = 0; x < x_fin; x += 2, dstC += 2, srcP++) {

  00718	c7 85 28 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _x$17[ebp], 0
  00722	eb 21		 jmp	 SHORT $LN22@convert_yv
$LN20@convert_yv:
  00724	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR _x$17[ebp]
  0072a	83 c2 02	 add	 edx, 2
  0072d	89 95 28 ff ff
	ff		 mov	 DWORD PTR _x$17[ebp], edx
  00733	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  00736	83 c0 02	 add	 eax, 2
  00739	89 45 94	 mov	 DWORD PTR _dstC$44[ebp], eax
  0073c	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$43[ebp]
  0073f	83 c1 02	 add	 ecx, 2
  00742	89 4d 90	 mov	 DWORD PTR _srcP$43[ebp], ecx
$LN22@convert_yv:
  00745	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR _x$17[ebp]
  0074b	3b 55 8c	 cmp	 edx, DWORD PTR _x_fin$42[ebp]
  0074e	0f 8d e4 01 00
	00		 jge	 $LN31@convert_yv

; 658  :                     int cxplus = (x + 2 < x_fin);

  00754	8b 85 28 ff ff
	ff		 mov	 eax, DWORD PTR _x$17[ebp]
  0075a	83 c0 02	 add	 eax, 2
  0075d	3b 45 8c	 cmp	 eax, DWORD PTR _x_fin$42[ebp]
  00760	7d 0c		 jge	 SHORT $LN48@convert_yv
  00762	c7 85 d4 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv427[ebp], 1
  0076c	eb 0a		 jmp	 SHORT $LN49@convert_yv
$LN48@convert_yv:
  0076e	c7 85 d4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv427[ebp], 0
$LN49@convert_yv:
  00778	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR tv427[ebp]
  0077e	89 8d 24 ff ff
	ff		 mov	 DWORD PTR _cxplus$16[ebp], ecx

; 659  :                     int cy0x0 = srcP[-1*src_uv_pitch + 0];

  00784	6b 55 a8 ff	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], -1
  00788	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  0078b	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  0078f	89 8d 20 ff ff
	ff		 mov	 DWORD PTR _cy0x0$15[ebp], ecx

; 660  :                     int cy2x0 = srcP[ 0*src_uv_pitch + 0];

  00795	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  00799	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  0079c	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  007a0	89 8d 1c ff ff
	ff		 mov	 DWORD PTR _cy2x0$14[ebp], ecx

; 661  :                     int cy4x0 = srcP[ 1*src_uv_pitch + 0];

  007a6	8b 55 a8	 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  007a9	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  007ac	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  007b0	89 8d 18 ff ff
	ff		 mov	 DWORD PTR _cy4x0$13[ebp], ecx

; 662  :                     int cy0x1 = srcP[-1*src_uv_pitch + cxplus];

  007b6	6b 55 a8 ff	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], -1
  007ba	03 95 24 ff ff
	ff		 add	 edx, DWORD PTR _cxplus$16[ebp]
  007c0	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  007c3	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  007c7	89 8d 14 ff ff
	ff		 mov	 DWORD PTR _cy0x1$12[ebp], ecx

; 663  :                     int cy2x1 = srcP[ 0*src_uv_pitch + cxplus];

  007cd	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  007d1	03 95 24 ff ff
	ff		 add	 edx, DWORD PTR _cxplus$16[ebp]
  007d7	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  007da	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  007de	89 8d 10 ff ff
	ff		 mov	 DWORD PTR _cy2x1$11[ebp], ecx

; 664  :                     int cy4x1 = srcP[ 1*src_uv_pitch + cxplus];

  007e4	8b 95 24 ff ff
	ff		 mov	 edx, DWORD PTR _cxplus$16[ebp]
  007ea	03 55 a8	 add	 edx, DWORD PTR _src_uv_pitch$[ebp]
  007ed	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  007f0	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  007f4	89 8d 0c ff ff
	ff		 mov	 DWORD PTR _cy4x1$10[ebp], ecx

; 665  : 
; 666  :                     int cy1x0 = (cy0x0 * 1 + cy2x0 * 3 + 2);

  007fa	6b 95 1c ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x0$14[ebp], 3
  00801	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR _cy0x0$15[ebp]
  00807	8d 4c 10 02	 lea	 ecx, DWORD PTR [eax+edx+2]
  0080b	89 8d 08 ff ff
	ff		 mov	 DWORD PTR _cy1x0$9[ebp], ecx

; 667  :                     int cy3x0 = (cy2x0 * 3 + cy4x0 * 1 + 2);

  00811	6b 95 1c ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x0$14[ebp], 3
  00818	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _cy4x0$13[ebp]
  0081e	8d 4c 02 02	 lea	 ecx, DWORD PTR [edx+eax+2]
  00822	89 8d 04 ff ff
	ff		 mov	 DWORD PTR _cy3x0$8[ebp], ecx

; 668  :                     int cy1x1 = (cy0x1 * 1 + cy2x1 * 3 + 2);

  00828	6b 95 10 ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x1$11[ebp], 3
  0082f	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _cy0x1$12[ebp]
  00835	8d 4c 10 02	 lea	 ecx, DWORD PTR [eax+edx+2]
  00839	89 8d 00 ff ff
	ff		 mov	 DWORD PTR _cy1x1$7[ebp], ecx

; 669  :                     int cy3x1 = (cy2x1 * 3 + cy4x1 * 1 + 2);

  0083f	6b 95 10 ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x1$11[ebp], 3
  00846	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _cy4x1$10[ebp]
  0084c	8d 4c 02 02	 lea	 ecx, DWORD PTR [edx+eax+2]
  00850	89 8d fc fe ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], ecx

; 670  :                     CHANGE_BIT_DEPTH_4(cy1x0, cy3x0, cy1x1, cy3x1, 2);

  00856	33 d2		 xor	 edx, edx
  00858	74 3e		 je	 SHORT $LN40@convert_yv
  0085a	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x0$9[ebp]
  00860	c1 e0 fa	 shl	 eax, -6			; fffffffaH
  00863	89 85 08 ff ff
	ff		 mov	 DWORD PTR _cy1x0$9[ebp], eax
  00869	8b 8d 04 ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x0$8[ebp]
  0086f	c1 e1 fa	 shl	 ecx, -6			; fffffffaH
  00872	89 8d 04 ff ff
	ff		 mov	 DWORD PTR _cy3x0$8[ebp], ecx
  00878	8b 95 00 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x1$7[ebp]
  0087e	c1 e2 fa	 shl	 edx, -6			; fffffffaH
  00881	89 95 00 ff ff
	ff		 mov	 DWORD PTR _cy1x1$7[ebp], edx
  00887	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR _cy3x1$6[ebp]
  0088d	c1 e0 fa	 shl	 eax, -6			; fffffffaH
  00890	89 85 fc fe ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], eax
  00896	eb 45		 jmp	 SHORT $LN41@convert_yv
$LN40@convert_yv:
  00898	b9 01 00 00 00	 mov	 ecx, 1
  0089d	85 c9		 test	 ecx, ecx
  0089f	74 3c		 je	 SHORT $LN41@convert_yv
  008a1	8b 95 08 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x0$9[ebp]
  008a7	c1 fa 06	 sar	 edx, 6
  008aa	89 95 08 ff ff
	ff		 mov	 DWORD PTR _cy1x0$9[ebp], edx
  008b0	8b 85 04 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$8[ebp]
  008b6	c1 f8 06	 sar	 eax, 6
  008b9	89 85 04 ff ff
	ff		 mov	 DWORD PTR _cy3x0$8[ebp], eax
  008bf	8b 8d 00 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x1$7[ebp]
  008c5	c1 f9 06	 sar	 ecx, 6
  008c8	89 8d 00 ff ff
	ff		 mov	 DWORD PTR _cy1x1$7[ebp], ecx
  008ce	8b 95 fc fe ff
	ff		 mov	 edx, DWORD PTR _cy3x1$6[ebp]
  008d4	c1 fa 06	 sar	 edx, 6
  008d7	89 95 fc fe ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], edx
$LN41@convert_yv:

; 671  : 
; 672  :                     dstC[0*dst_y_pitch   + 0] = (Tout)cy1x0;

  008dd	6b 45 e4 00	 imul	 eax, DWORD PTR _dst_y_pitch$[ebp], 0
  008e1	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$44[ebp]
  008e4	8a 95 08 ff ff
	ff		 mov	 dl, BYTE PTR _cy1x0$9[ebp]
  008ea	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 673  :                     dstC[0*dst_y_pitch   + 1] = (Tout)((cy1x0 + cy1x1 + 1) >> 1);

  008ed	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x1$7[ebp]
  008f3	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x0$9[ebp]
  008f9	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  008fd	d1 fa		 sar	 edx, 1
  008ff	6b 45 e4 00	 imul	 eax, DWORD PTR _dst_y_pitch$[ebp], 0
  00903	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$44[ebp]
  00906	88 54 01 01	 mov	 BYTE PTR [ecx+eax+1], dl

; 674  :                     dstC[1*dst_y_pitch   + 0] = (Tout)cy3x0;

  0090a	8b 55 94	 mov	 edx, DWORD PTR _dstC$44[ebp]
  0090d	03 55 e4	 add	 edx, DWORD PTR _dst_y_pitch$[ebp]
  00910	8a 85 04 ff ff
	ff		 mov	 al, BYTE PTR _cy3x0$8[ebp]
  00916	88 02		 mov	 BYTE PTR [edx], al

; 675  :                     dstC[1*dst_y_pitch   + 1] = (Tout)((cy3x0 + cy3x1 + 1) >> 1);

  00918	8b 8d fc fe ff
	ff		 mov	 ecx, DWORD PTR _cy3x1$6[ebp]
  0091e	8b 95 04 ff ff
	ff		 mov	 edx, DWORD PTR _cy3x0$8[ebp]
  00924	8d 44 0a 01	 lea	 eax, DWORD PTR [edx+ecx+1]
  00928	d1 f8		 sar	 eax, 1
  0092a	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$44[ebp]
  0092d	03 4d e4	 add	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  00930	88 41 01	 mov	 BYTE PTR [ecx+1], al

; 676  :                 }

  00933	e9 ec fd ff ff	 jmp	 $LN20@convert_yv
$LN31@convert_yv:

; 677  :             }
; 678  :         }

  00938	e9 52 f9 ff ff	 jmp	 $LN11@convert_yv
$LN12@convert_yv:

; 679  :     }

  0093d	e9 03 f9 ff ff	 jmp	 $LN8@convert_yv
$LN1@convert_yv:

; 680  : }

  00942	52		 push	 edx
  00943	8b cd		 mov	 ecx, ebp
  00945	50		 push	 eax
  00946	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN52@convert_yv
  0094c	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00951	58		 pop	 eax
  00952	5a		 pop	 edx
  00953	5f		 pop	 edi
  00954	5b		 pop	 ebx
  00955	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00958	33 cd		 xor	 ecx, ebp
  0095a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0095f	81 c4 2c 01 00
	00		 add	 esp, 300		; 0000012cH
  00965	3b ec		 cmp	 ebp, esp
  00967	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0096c	8b e5		 mov	 esp, ebp
  0096e	5d		 pop	 ebp
  0096f	c3		 ret	 0
$LN52@convert_yv:
  00970	01 00 00 00	 DD	 1
  00974	00 00 00 00	 DD	 $LN51@convert_yv
$LN51@convert_yv:
  00978	d4 ff ff ff	 DD	 -44			; ffffffd4H
  0097c	0c 00 00 00	 DD	 12			; 0000000cH
  00980	00 00 00 00	 DD	 $LN50@convert_yv
$LN50@convert_yv:
  00984	79		 DB	 121			; 00000079H
  00985	5f		 DB	 95			; 0000005fH
  00986	72		 DB	 114			; 00000072H
  00987	61		 DB	 97			; 00000061H
  00988	6e		 DB	 110			; 0000006eH
  00989	67		 DB	 103			; 00000067H
  0098a	65		 DB	 101			; 00000065H
  0098b	00		 DB	 0
??$convert_yv12_p_to_yuv444_c@G$0M@E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_p_to_yuv444_c<unsigned short,12,unsigned char,8,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yv12_12_p_to_yuv444@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_12_p_to_yuv444

; 809  : static void convert_yv12_12_p_to_yuv444(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 810  :     convert_yv12_p_to_yuv444_c<uint16_t, 12, uint8_t, 8, false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yv12_p_to_yuv444_c@G$0M@E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_p_to_yuv444_c<unsigned short,12,unsigned char,8,0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 811  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yv12_12_p_to_yuv444@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_12_p_to_yuv444
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
tv297 = -280						; size = 4
tv235 = -276						; size = 4
tv236 = -272						; size = 4
tv230 = -268						; size = 4
tv227 = -264						; size = 4
tv224 = -260						; size = 4
tv222 = -256						; size = 4
$T1 = -252						; size = 4
$T2 = -248						; size = 4
$T3 = -244						; size = 4
$T4 = -240						; size = 4
$T5 = -236						; size = 12
_cy3x1$6 = -224						; size = 4
_cy2x1$7 = -220						; size = 4
_cy1x1$8 = -216						; size = 4
_cy0x1$9 = -212						; size = 4
_sy5x1$10 = -208					; size = 4
_sy4x1$11 = -204					; size = 4
_sy3x1$12 = -200					; size = 4
_sy2x1$13 = -196					; size = 4
_sy1x1$14 = -192					; size = 4
_sy0x1$15 = -188					; size = 4
_cxplus$16 = -184					; size = 4
_x$17 = -180						; size = 4
_cy3x0$18 = -176					; size = 4
_cy2x0$19 = -172					; size = 4
_cy1x0$20 = -168					; size = 4
_cy0x0$21 = -164					; size = 4
_sy5x0$22 = -160					; size = 4
_sy4x0$23 = -156					; size = 4
_sy3x0$24 = -152					; size = 4
_sy2x0$25 = -148					; size = 4
_sy1x0$26 = -144					; size = 4
_sy0x0$27 = -140					; size = 4
_y_p3$28 = -136						; size = 4
_y_p2$29 = -132						; size = 4
_y_p1$30 = -128						; size = 4
_y_m1$31 = -124						; size = 4
_y_m2$32 = -120						; size = 4
_x_fin$33 = -116					; size = 4
_srcP$34 = -112						; size = 4
_dstC$35 = -108						; size = 4
_y$36 = -104						; size = 4
_dstLine$37 = -100					; size = 4
_srcCLine$38 = -96					; size = 4
_ic$39 = -92						; size = 4
_src_uv_pitch$ = -88					; size = 4
_uv_fin$ = -84						; size = 4
_x$40 = -80						; size = 4
_y$41 = -76						; size = 4
_y_width$42 = -72					; size = 4
_dstLine$43 = -68					; size = 4
_srcYLine$44 = -64					; size = 4
$T45 = -60						; size = 12
_y_range$ = -44						; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yv12_i_to_yuv444_c@G$0O@E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_i_to_yuv444_c<unsigned short,14,unsigned char,8,0>

; 683  : static void __forceinline convert_yv12_i_to_yuv444_c(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  00009	53		 push	 ebx
  0000a	57		 push	 edi
  0000b	8d bd e8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-280]
  00011	b9 46 00 00 00	 mov	 ecx, 70			; 00000046H
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 684  :     static_assert((sizeof(Tin)  == 1 && in_bit_depth  == 8) || (sizeof(Tin)  == 2 && 8 < in_bit_depth  && in_bit_depth  <= 16), "invalid input bit depth.");
; 685  :     static_assert((sizeof(Tout) == 1 && out_bit_depth == 8) || (sizeof(Tout) == 2 && 8 < out_bit_depth && out_bit_depth <= 16), "invalid output bit depth.");
; 686  :     const int crop_left   = crop[0];

  00027	b8 04 00 00 00	 mov	 eax, 4
  0002c	6b c8 00	 imul	 ecx, eax, 0
  0002f	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00032	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00035	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 687  :     const int crop_up     = crop[1];

  00038	b9 04 00 00 00	 mov	 ecx, 4
  0003d	c1 e1 00	 shl	 ecx, 0
  00040	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00043	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00046	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 688  :     const int crop_right  = crop[2];

  00049	b9 04 00 00 00	 mov	 ecx, 4
  0004e	d1 e1		 shl	 ecx, 1
  00050	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00053	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00056	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 689  :     const int crop_bottom = crop[3];

  00059	b9 04 00 00 00	 mov	 ecx, 4
  0005e	6b d1 03	 imul	 edx, ecx, 3
  00061	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00064	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00067	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 690  :     const int src_y_pitch = src_y_pitch_byte / sizeof(Tin);

  0006a	8b 55 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebp]
  0006d	d1 ea		 shr	 edx, 1
  0006f	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 691  :     const int dst_y_pitch = dst_y_pitch_byte / sizeof(Tout);

  00072	8b 45 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  00075	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 692  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00078	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0007b	51		 push	 ecx
  0007c	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0007f	52		 push	 edx
  00080	8b 45 20	 mov	 eax, DWORD PTR _height$[ebp]
  00083	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  00086	50		 push	 eax
  00087	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  0008a	51		 push	 ecx
  0008b	8d 95 14 ff ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  00091	52		 push	 edx
  00092	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00097	83 c4 14	 add	 esp, 20			; 00000014H
  0009a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009c	89 4d c4	 mov	 DWORD PTR $T45[ebp], ecx
  0009f	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a2	89 55 c8	 mov	 DWORD PTR $T45[ebp+4], edx
  000a5	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000a8	89 45 cc	 mov	 DWORD PTR $T45[ebp+8], eax
  000ab	8b 4d c4	 mov	 ecx, DWORD PTR $T45[ebp]
  000ae	89 4d d4	 mov	 DWORD PTR _y_range$[ebp], ecx
  000b1	8b 55 c8	 mov	 edx, DWORD PTR $T45[ebp+4]
  000b4	89 55 d8	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000b7	8b 45 cc	 mov	 eax, DWORD PTR $T45[ebp+8]
  000ba	89 45 dc	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 693  :     //Y
; 694  :     if (!uv_only) {

  000bd	b9 01 00 00 00	 mov	 ecx, 1
  000c2	85 c9		 test	 ecx, ecx
  000c4	0f 84 61 01 00
	00		 je	 $LN17@convert_yv

; 695  :         Tin *srcYLine = (Tin *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000ca	ba 04 00 00 00	 mov	 edx, 4
  000cf	6b c2 00	 imul	 eax, edx, 0
  000d2	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  000d5	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  000d9	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  000dc	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  000df	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  000e2	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  000e5	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  000e8	89 45 c0	 mov	 DWORD PTR _srcYLine$44[ebp], eax

; 696  :         Tout *dstLine = (Tout *)dst[0] + dst_y_pitch * y_range.start_dst;

  000eb	b9 04 00 00 00	 mov	 ecx, 4
  000f0	6b d1 00	 imul	 edx, ecx, 0
  000f3	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  000f6	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  000fa	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  000fd	03 04 11	 add	 eax, DWORD PTR [ecx+edx]
  00100	89 45 bc	 mov	 DWORD PTR _dstLine$43[ebp], eax

; 697  :         const int y_width = width - crop_right - crop_left;

  00103	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00106	2b 55 f0	 sub	 edx, DWORD PTR _crop_right$[ebp]
  00109	2b 55 f8	 sub	 edx, DWORD PTR _crop_left$[ebp]
  0010c	89 55 b8	 mov	 DWORD PTR _y_width$42[ebp], edx

; 698  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  0010f	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _y$41[ebp], 0
  00116	eb 1e		 jmp	 SHORT $LN4@convert_yv
$LN2@convert_yv:
  00118	8b 45 b4	 mov	 eax, DWORD PTR _y$41[ebp]
  0011b	83 c0 01	 add	 eax, 1
  0011e	89 45 b4	 mov	 DWORD PTR _y$41[ebp], eax
  00121	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  00124	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$44[ebp]
  00127	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  0012a	89 45 c0	 mov	 DWORD PTR _srcYLine$44[ebp], eax
  0012d	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$43[ebp]
  00130	03 4d e4	 add	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  00133	89 4d bc	 mov	 DWORD PTR _dstLine$43[ebp], ecx
$LN4@convert_yv:
  00136	8b 55 b4	 mov	 edx, DWORD PTR _y$41[ebp]
  00139	3b 55 dc	 cmp	 edx, DWORD PTR _y_range$[ebp+8]
  0013c	0f 8d e9 00 00
	00		 jge	 $LN17@convert_yv

; 699  :             if (in_bit_depth == out_bit_depth) {

  00142	33 c0		 xor	 eax, eax
  00144	74 1b		 je	 SHORT $LN18@convert_yv

; 700  :                 memcpy(dstLine, srcYLine, y_width * sizeof(Tin));

  00146	8b 4d b8	 mov	 ecx, DWORD PTR _y_width$42[ebp]
  00149	d1 e1		 shl	 ecx, 1
  0014b	51		 push	 ecx
  0014c	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$44[ebp]
  0014f	52		 push	 edx
  00150	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$43[ebp]
  00153	50		 push	 eax
  00154	e8 00 00 00 00	 call	 _memcpy
  00159	83 c4 0c	 add	 esp, 12			; 0000000cH

; 701  :             } else {

  0015c	e9 c5 00 00 00	 jmp	 $LN19@convert_yv
$LN18@convert_yv:

; 702  :                 for (int x = 0; x < y_width; x++) {

  00161	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _x$40[ebp], 0
  00168	eb 09		 jmp	 SHORT $LN7@convert_yv
$LN5@convert_yv:
  0016a	8b 4d b0	 mov	 ecx, DWORD PTR _x$40[ebp]
  0016d	83 c1 01	 add	 ecx, 1
  00170	89 4d b0	 mov	 DWORD PTR _x$40[ebp], ecx
$LN7@convert_yv:
  00173	8b 55 b0	 mov	 edx, DWORD PTR _x$40[ebp]
  00176	3b 55 b8	 cmp	 edx, DWORD PTR _y_width$42[ebp]
  00179	0f 8d a7 00 00
	00		 jge	 $LN19@convert_yv

; 703  :                     if (out_bit_depth > in_bit_depth) {

  0017f	33 c0		 xor	 eax, eax
  00181	74 42		 je	 SHORT $LN20@convert_yv

; 704  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) << std::max(out_bit_depth - in_bit_depth, 0));

  00183	c7 85 10 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], 0
  0018d	c7 85 0c ff ff
	ff fa ff ff ff	 mov	 DWORD PTR $T3[ebp], -6	; fffffffaH
  00197	8b 4d b0	 mov	 ecx, DWORD PTR _x$40[ebp]
  0019a	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$44[ebp]
  0019d	0f b7 1c 4a	 movzx	 ebx, WORD PTR [edx+ecx*2]
  001a1	8d 85 10 ff ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  001a7	50		 push	 eax
  001a8	8d 8d 0c ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  001ae	51		 push	 ecx
  001af	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  001b4	83 c4 08	 add	 esp, 8
  001b7	8b 08		 mov	 ecx, DWORD PTR [eax]
  001b9	d3 e3		 shl	 ebx, cl
  001bb	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$43[ebp]
  001be	03 55 b0	 add	 edx, DWORD PTR _x$40[ebp]
  001c1	88 1a		 mov	 BYTE PTR [edx], bl
  001c3	eb 5c		 jmp	 SHORT $LN21@convert_yv
$LN20@convert_yv:

; 705  :                     } else if (out_bit_depth < in_bit_depth) {

  001c5	b8 01 00 00 00	 mov	 eax, 1
  001ca	85 c0		 test	 eax, eax
  001cc	74 42		 je	 SHORT $LN22@convert_yv

; 706  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) >> std::max(in_bit_depth - out_bit_depth, 0));

  001ce	c7 85 08 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], 0
  001d8	c7 85 04 ff ff
	ff 06 00 00 00	 mov	 DWORD PTR $T1[ebp], 6
  001e2	8b 4d b0	 mov	 ecx, DWORD PTR _x$40[ebp]
  001e5	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$44[ebp]
  001e8	0f b7 1c 4a	 movzx	 ebx, WORD PTR [edx+ecx*2]
  001ec	8d 85 08 ff ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  001f2	50		 push	 eax
  001f3	8d 8d 04 ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  001f9	51		 push	 ecx
  001fa	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  001ff	83 c4 08	 add	 esp, 8
  00202	8b 08		 mov	 ecx, DWORD PTR [eax]
  00204	d3 fb		 sar	 ebx, cl
  00206	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$43[ebp]
  00209	03 55 b0	 add	 edx, DWORD PTR _x$40[ebp]
  0020c	88 1a		 mov	 BYTE PTR [edx], bl

; 707  :                     } else {

  0020e	eb 11		 jmp	 SHORT $LN21@convert_yv
$LN22@convert_yv:

; 708  :                         dstLine[x] = (Tout)srcYLine[x];

  00210	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$43[ebp]
  00213	03 45 b0	 add	 eax, DWORD PTR _x$40[ebp]
  00216	8b 4d b0	 mov	 ecx, DWORD PTR _x$40[ebp]
  00219	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$44[ebp]
  0021c	8a 0c 4a	 mov	 cl, BYTE PTR [edx+ecx*2]
  0021f	88 08		 mov	 BYTE PTR [eax], cl
$LN21@convert_yv:

; 709  :                     }
; 710  :                 }

  00221	e9 44 ff ff ff	 jmp	 $LN5@convert_yv
$LN19@convert_yv:

; 711  :             }
; 712  :         }

  00226	e9 ed fe ff ff	 jmp	 $LN2@convert_yv
$LN17@convert_yv:

; 713  :     }
; 714  :     //UV
; 715  :     const int uv_fin = height - crop_bottom;

  0022b	8b 55 20	 mov	 edx, DWORD PTR _height$[ebp]
  0022e	2b 55 ec	 sub	 edx, DWORD PTR _crop_bottom$[ebp]
  00231	89 55 ac	 mov	 DWORD PTR _uv_fin$[ebp], edx

; 716  :     const int src_uv_pitch = src_uv_pitch_byte / sizeof(Tin);

  00234	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  00237	d1 e8		 shr	 eax, 1
  00239	89 45 a8	 mov	 DWORD PTR _src_uv_pitch$[ebp], eax

; 717  :     for (int ic = 1; ic < 3; ic++) {

  0023c	c7 45 a4 01 00
	00 00		 mov	 DWORD PTR _ic$39[ebp], 1
  00243	eb 09		 jmp	 SHORT $LN10@convert_yv
$LN8@convert_yv:
  00245	8b 4d a4	 mov	 ecx, DWORD PTR _ic$39[ebp]
  00248	83 c1 01	 add	 ecx, 1
  0024b	89 4d a4	 mov	 DWORD PTR _ic$39[ebp], ecx
$LN10@convert_yv:
  0024e	83 7d a4 03	 cmp	 DWORD PTR _ic$39[ebp], 3
  00252	0f 8d ac 05 00
	00		 jge	 $LN1@convert_yv

; 718  :         Tin *srcCLine = (Tin *)src[ic] + (((src_uv_pitch * y_range.start_src) + crop_left) >> 1);

  00258	8b 55 a8	 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  0025b	0f af 55 d4	 imul	 edx, DWORD PTR _y_range$[ebp]
  0025f	03 55 f8	 add	 edx, DWORD PTR _crop_left$[ebp]
  00262	d1 fa		 sar	 edx, 1
  00264	8b 45 a4	 mov	 eax, DWORD PTR _ic$39[ebp]
  00267	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  0026a	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  0026d	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00270	89 4d a0	 mov	 DWORD PTR _srcCLine$38[ebp], ecx

; 719  :         Tout *dstLine = (Tout *)dst[ic] + dst_y_pitch * y_range.start_dst;

  00273	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  00276	0f af 55 d8	 imul	 edx, DWORD PTR _y_range$[ebp+4]
  0027a	8b 45 a4	 mov	 eax, DWORD PTR _ic$39[ebp]
  0027d	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  00280	03 14 81	 add	 edx, DWORD PTR [ecx+eax*4]
  00283	89 55 9c	 mov	 DWORD PTR _dstLine$37[ebp], edx

; 720  :         for (int y = 0; y < y_range.len; y += 4, srcCLine += src_uv_pitch * 2, dstLine += dst_y_pitch * 4) {

  00286	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _y$36[ebp], 0
  0028d	eb 23		 jmp	 SHORT $LN13@convert_yv
$LN11@convert_yv:
  0028f	8b 55 98	 mov	 edx, DWORD PTR _y$36[ebp]
  00292	83 c2 04	 add	 edx, 4
  00295	89 55 98	 mov	 DWORD PTR _y$36[ebp], edx
  00298	8b 45 a8	 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  0029b	d1 e0		 shl	 eax, 1
  0029d	8b 4d a0	 mov	 ecx, DWORD PTR _srcCLine$38[ebp]
  002a0	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  002a3	89 55 a0	 mov	 DWORD PTR _srcCLine$38[ebp], edx
  002a6	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  002a9	8b 4d 9c	 mov	 ecx, DWORD PTR _dstLine$37[ebp]
  002ac	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  002af	89 55 9c	 mov	 DWORD PTR _dstLine$37[ebp], edx
$LN13@convert_yv:
  002b2	8b 45 98	 mov	 eax, DWORD PTR _y$36[ebp]
  002b5	3b 45 dc	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  002b8	0f 8d 41 05 00
	00		 jge	 $LN12@convert_yv

; 721  :             Tout *dstC = dstLine;

  002be	8b 4d 9c	 mov	 ecx, DWORD PTR _dstLine$37[ebp]
  002c1	89 4d 94	 mov	 DWORD PTR _dstC$35[ebp], ecx

; 722  :             Tin *srcP = srcCLine;

  002c4	8b 55 a0	 mov	 edx, DWORD PTR _srcCLine$38[ebp]
  002c7	89 55 90	 mov	 DWORD PTR _srcP$34[ebp], edx

; 723  :             const int x_fin = width - crop_right - crop_left;

  002ca	8b 45 10	 mov	 eax, DWORD PTR _width$[ebp]
  002cd	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  002d0	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  002d3	89 45 8c	 mov	 DWORD PTR _x_fin$33[ebp], eax

; 724  : 
; 725  :             int y_m2 = (y >= 4) ? -2 : 0;

  002d6	83 7d 98 04	 cmp	 DWORD PTR _y$36[ebp], 4
  002da	7c 0c		 jl	 SHORT $LN31@convert_yv
  002dc	c7 85 00 ff ff
	ff fe ff ff ff	 mov	 DWORD PTR tv222[ebp], -2 ; fffffffeH
  002e6	eb 0a		 jmp	 SHORT $LN32@convert_yv
$LN31@convert_yv:
  002e8	c7 85 00 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv222[ebp], 0
$LN32@convert_yv:
  002f2	8b 8d 00 ff ff
	ff		 mov	 ecx, DWORD PTR tv222[ebp]
  002f8	89 4d 88	 mov	 DWORD PTR _y_m2$32[ebp], ecx

; 726  :             int y_m1 = (y >= 2) ? -1 : 1;

  002fb	83 7d 98 02	 cmp	 DWORD PTR _y$36[ebp], 2
  002ff	7c 0c		 jl	 SHORT $LN33@convert_yv
  00301	c7 85 fc fe ff
	ff ff ff ff ff	 mov	 DWORD PTR tv224[ebp], -1
  0030b	eb 0a		 jmp	 SHORT $LN34@convert_yv
$LN33@convert_yv:
  0030d	c7 85 fc fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv224[ebp], 1
$LN34@convert_yv:
  00317	8b 95 fc fe ff
	ff		 mov	 edx, DWORD PTR tv224[ebp]
  0031d	89 55 84	 mov	 DWORD PTR _y_m1$31[ebp], edx

; 727  :             int y_p1 = (y < uv_fin - 2) ? 1 : -1;

  00320	8b 45 ac	 mov	 eax, DWORD PTR _uv_fin$[ebp]
  00323	83 e8 02	 sub	 eax, 2
  00326	39 45 98	 cmp	 DWORD PTR _y$36[ebp], eax
  00329	7d 0c		 jge	 SHORT $LN35@convert_yv
  0032b	c7 85 f8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv227[ebp], 1
  00335	eb 0a		 jmp	 SHORT $LN36@convert_yv
$LN35@convert_yv:
  00337	c7 85 f8 fe ff
	ff ff ff ff ff	 mov	 DWORD PTR tv227[ebp], -1
$LN36@convert_yv:
  00341	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR tv227[ebp]
  00347	89 4d 80	 mov	 DWORD PTR _y_p1$30[ebp], ecx

; 728  :             int y_p2 = (y < uv_fin - 4) ? 2 :  0;

  0034a	8b 55 ac	 mov	 edx, DWORD PTR _uv_fin$[ebp]
  0034d	83 ea 04	 sub	 edx, 4
  00350	39 55 98	 cmp	 DWORD PTR _y$36[ebp], edx
  00353	7d 0c		 jge	 SHORT $LN37@convert_yv
  00355	c7 85 f4 fe ff
	ff 02 00 00 00	 mov	 DWORD PTR tv230[ebp], 2
  0035f	eb 0a		 jmp	 SHORT $LN38@convert_yv
$LN37@convert_yv:
  00361	c7 85 f4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv230[ebp], 0
$LN38@convert_yv:
  0036b	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR tv230[ebp]
  00371	89 85 7c ff ff
	ff		 mov	 DWORD PTR _y_p2$29[ebp], eax

; 729  :             int y_p3 = (y < uv_fin - 6) ? 3 : ((y < uv_fin - 2) ? 1 : -1);

  00377	8b 4d ac	 mov	 ecx, DWORD PTR _uv_fin$[ebp]
  0037a	83 e9 06	 sub	 ecx, 6
  0037d	39 4d 98	 cmp	 DWORD PTR _y$36[ebp], ecx
  00380	7d 0c		 jge	 SHORT $LN41@convert_yv
  00382	c7 85 f0 fe ff
	ff 03 00 00 00	 mov	 DWORD PTR tv236[ebp], 3
  0038c	eb 2d		 jmp	 SHORT $LN42@convert_yv
$LN41@convert_yv:
  0038e	8b 55 ac	 mov	 edx, DWORD PTR _uv_fin$[ebp]
  00391	83 ea 02	 sub	 edx, 2
  00394	39 55 98	 cmp	 DWORD PTR _y$36[ebp], edx
  00397	7d 0c		 jge	 SHORT $LN39@convert_yv
  00399	c7 85 ec fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv235[ebp], 1
  003a3	eb 0a		 jmp	 SHORT $LN40@convert_yv
$LN39@convert_yv:
  003a5	c7 85 ec fe ff
	ff ff ff ff ff	 mov	 DWORD PTR tv235[ebp], -1
$LN40@convert_yv:
  003af	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR tv235[ebp]
  003b5	89 85 f0 fe ff
	ff		 mov	 DWORD PTR tv236[ebp], eax
$LN42@convert_yv:
  003bb	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR tv236[ebp]
  003c1	89 8d 78 ff ff
	ff		 mov	 DWORD PTR _y_p3$28[ebp], ecx

; 730  : 
; 731  :             int sy0x0 = srcP[y_m2*src_uv_pitch + 0];

  003c7	8b 55 88	 mov	 edx, DWORD PTR _y_m2$32[ebp]
  003ca	0f af 55 a8	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp]
  003ce	8b 45 90	 mov	 eax, DWORD PTR _srcP$34[ebp]
  003d1	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  003d5	89 8d 74 ff ff
	ff		 mov	 DWORD PTR _sy0x0$27[ebp], ecx

; 732  :             int sy1x0 = srcP[y_m1*src_uv_pitch + 0];

  003db	8b 55 84	 mov	 edx, DWORD PTR _y_m1$31[ebp]
  003de	0f af 55 a8	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp]
  003e2	8b 45 90	 mov	 eax, DWORD PTR _srcP$34[ebp]
  003e5	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  003e9	89 8d 70 ff ff
	ff		 mov	 DWORD PTR _sy1x0$26[ebp], ecx

; 733  :             int sy2x0 = srcP[   0*src_uv_pitch + 0];

  003ef	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  003f3	8b 45 90	 mov	 eax, DWORD PTR _srcP$34[ebp]
  003f6	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  003fa	89 8d 6c ff ff
	ff		 mov	 DWORD PTR _sy2x0$25[ebp], ecx

; 734  :             int sy3x0 = srcP[y_p1*src_uv_pitch + 0];

  00400	8b 55 80	 mov	 edx, DWORD PTR _y_p1$30[ebp]
  00403	0f af 55 a8	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp]
  00407	8b 45 90	 mov	 eax, DWORD PTR _srcP$34[ebp]
  0040a	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  0040e	89 8d 68 ff ff
	ff		 mov	 DWORD PTR _sy3x0$24[ebp], ecx

; 735  :             int sy4x0 = srcP[y_p2*src_uv_pitch + 0];

  00414	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR _y_p2$29[ebp]
  0041a	0f af 55 a8	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp]
  0041e	8b 45 90	 mov	 eax, DWORD PTR _srcP$34[ebp]
  00421	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  00425	89 8d 64 ff ff
	ff		 mov	 DWORD PTR _sy4x0$23[ebp], ecx

; 736  :             int sy5x0 = srcP[y_p3*src_uv_pitch + 0];

  0042b	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _y_p3$28[ebp]
  00431	0f af 55 a8	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp]
  00435	8b 45 90	 mov	 eax, DWORD PTR _srcP$34[ebp]
  00438	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  0043c	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _sy5x0$22[ebp], ecx

; 737  : 
; 738  :             int cy0x0 = (sy0x0 * 1 + sy2x0 * 7 + 4);

  00442	6b 95 6c ff ff
	ff 07		 imul	 edx, DWORD PTR _sy2x0$25[ebp], 7
  00449	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _sy0x0$27[ebp]
  0044f	8d 4c 10 04	 lea	 ecx, DWORD PTR [eax+edx+4]
  00453	89 8d 5c ff ff
	ff		 mov	 DWORD PTR _cy0x0$21[ebp], ecx

; 739  :             int cy1x0 = (sy1x0 * 3 + sy3x0 * 5 + 4);

  00459	6b 95 70 ff ff
	ff 03		 imul	 edx, DWORD PTR _sy1x0$26[ebp], 3
  00460	6b 85 68 ff ff
	ff 05		 imul	 eax, DWORD PTR _sy3x0$24[ebp], 5
  00467	8d 4c 02 04	 lea	 ecx, DWORD PTR [edx+eax+4]
  0046b	89 8d 58 ff ff
	ff		 mov	 DWORD PTR _cy1x0$20[ebp], ecx

; 740  :             int cy2x0 = (sy2x0 * 5 + sy4x0 * 3 + 4);

  00471	6b 95 6c ff ff
	ff 05		 imul	 edx, DWORD PTR _sy2x0$25[ebp], 5
  00478	6b 85 64 ff ff
	ff 03		 imul	 eax, DWORD PTR _sy4x0$23[ebp], 3
  0047f	8d 4c 02 04	 lea	 ecx, DWORD PTR [edx+eax+4]
  00483	89 8d 54 ff ff
	ff		 mov	 DWORD PTR _cy2x0$19[ebp], ecx

; 741  :             int cy3x0 = (sy3x0 * 7 + sy5x0 * 1 + 4);

  00489	6b 95 68 ff ff
	ff 07		 imul	 edx, DWORD PTR _sy3x0$24[ebp], 7
  00490	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _sy5x0$22[ebp]
  00496	8d 4c 02 04	 lea	 ecx, DWORD PTR [edx+eax+4]
  0049a	89 8d 50 ff ff
	ff		 mov	 DWORD PTR _cy3x0$18[ebp], ecx

; 742  :             CHANGE_BIT_DEPTH_4(cy0x0, cy1x0, cy2x0, cy3x0, 3);

  004a0	33 d2		 xor	 edx, edx
  004a2	74 3e		 je	 SHORT $LN24@convert_yv
  004a4	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _cy0x0$21[ebp]
  004aa	c1 e0 f7	 shl	 eax, -9			; fffffff7H
  004ad	89 85 5c ff ff
	ff		 mov	 DWORD PTR _cy0x0$21[ebp], eax
  004b3	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x0$20[ebp]
  004b9	c1 e1 f7	 shl	 ecx, -9			; fffffff7H
  004bc	89 8d 58 ff ff
	ff		 mov	 DWORD PTR _cy1x0$20[ebp], ecx
  004c2	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR _cy2x0$19[ebp]
  004c8	c1 e2 f7	 shl	 edx, -9			; fffffff7H
  004cb	89 95 54 ff ff
	ff		 mov	 DWORD PTR _cy2x0$19[ebp], edx
  004d1	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$18[ebp]
  004d7	c1 e0 f7	 shl	 eax, -9			; fffffff7H
  004da	89 85 50 ff ff
	ff		 mov	 DWORD PTR _cy3x0$18[ebp], eax
  004e0	eb 45		 jmp	 SHORT $LN25@convert_yv
$LN24@convert_yv:
  004e2	b9 01 00 00 00	 mov	 ecx, 1
  004e7	85 c9		 test	 ecx, ecx
  004e9	74 3c		 je	 SHORT $LN25@convert_yv
  004eb	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR _cy0x0$21[ebp]
  004f1	c1 fa 09	 sar	 edx, 9
  004f4	89 95 5c ff ff
	ff		 mov	 DWORD PTR _cy0x0$21[ebp], edx
  004fa	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x0$20[ebp]
  00500	c1 f8 09	 sar	 eax, 9
  00503	89 85 58 ff ff
	ff		 mov	 DWORD PTR _cy1x0$20[ebp], eax
  00509	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _cy2x0$19[ebp]
  0050f	c1 f9 09	 sar	 ecx, 9
  00512	89 8d 54 ff ff
	ff		 mov	 DWORD PTR _cy2x0$19[ebp], ecx
  00518	8b 95 50 ff ff
	ff		 mov	 edx, DWORD PTR _cy3x0$18[ebp]
  0051e	c1 fa 09	 sar	 edx, 9
  00521	89 95 50 ff ff
	ff		 mov	 DWORD PTR _cy3x0$18[ebp], edx
$LN25@convert_yv:

; 743  : 
; 744  :             for (int x = 0; x < x_fin; x += 2, dstC += 2, srcP++) {

  00527	c7 85 4c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _x$17[ebp], 0
  00531	eb 21		 jmp	 SHORT $LN16@convert_yv
$LN14@convert_yv:
  00533	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _x$17[ebp]
  00539	83 c0 02	 add	 eax, 2
  0053c	89 85 4c ff ff
	ff		 mov	 DWORD PTR _x$17[ebp], eax
  00542	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$35[ebp]
  00545	83 c1 02	 add	 ecx, 2
  00548	89 4d 94	 mov	 DWORD PTR _dstC$35[ebp], ecx
  0054b	8b 55 90	 mov	 edx, DWORD PTR _srcP$34[ebp]
  0054e	83 c2 02	 add	 edx, 2
  00551	89 55 90	 mov	 DWORD PTR _srcP$34[ebp], edx
$LN16@convert_yv:
  00554	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _x$17[ebp]
  0055a	3b 45 8c	 cmp	 eax, DWORD PTR _x_fin$33[ebp]
  0055d	0f 8d 97 02 00
	00		 jge	 $LN15@convert_yv

; 745  :                 int cxplus = (x + 2 < x_fin);

  00563	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _x$17[ebp]
  00569	83 c1 02	 add	 ecx, 2
  0056c	3b 4d 8c	 cmp	 ecx, DWORD PTR _x_fin$33[ebp]
  0056f	7d 0c		 jge	 SHORT $LN43@convert_yv
  00571	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv297[ebp], 1
  0057b	eb 0a		 jmp	 SHORT $LN44@convert_yv
$LN43@convert_yv:
  0057d	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv297[ebp], 0
$LN44@convert_yv:
  00587	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR tv297[ebp]
  0058d	89 95 48 ff ff
	ff		 mov	 DWORD PTR _cxplus$16[ebp], edx

; 746  :                 int sy0x1 = srcP[y_m2*src_uv_pitch + cxplus];

  00593	8b 45 88	 mov	 eax, DWORD PTR _y_m2$32[ebp]
  00596	0f af 45 a8	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp]
  0059a	03 85 48 ff ff
	ff		 add	 eax, DWORD PTR _cxplus$16[ebp]
  005a0	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  005a3	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  005a7	89 95 44 ff ff
	ff		 mov	 DWORD PTR _sy0x1$15[ebp], edx

; 747  :                 int sy1x1 = srcP[y_m1*src_uv_pitch + cxplus];

  005ad	8b 45 84	 mov	 eax, DWORD PTR _y_m1$31[ebp]
  005b0	0f af 45 a8	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp]
  005b4	03 85 48 ff ff
	ff		 add	 eax, DWORD PTR _cxplus$16[ebp]
  005ba	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  005bd	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  005c1	89 95 40 ff ff
	ff		 mov	 DWORD PTR _sy1x1$14[ebp], edx

; 748  :                 int sy2x1 = srcP[   0*src_uv_pitch + cxplus];

  005c7	6b 45 a8 00	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp], 0
  005cb	03 85 48 ff ff
	ff		 add	 eax, DWORD PTR _cxplus$16[ebp]
  005d1	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  005d4	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  005d8	89 95 3c ff ff
	ff		 mov	 DWORD PTR _sy2x1$13[ebp], edx

; 749  :                 int sy3x1 = srcP[y_p1*src_uv_pitch + cxplus];

  005de	8b 45 80	 mov	 eax, DWORD PTR _y_p1$30[ebp]
  005e1	0f af 45 a8	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp]
  005e5	03 85 48 ff ff
	ff		 add	 eax, DWORD PTR _cxplus$16[ebp]
  005eb	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  005ee	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  005f2	89 95 38 ff ff
	ff		 mov	 DWORD PTR _sy3x1$12[ebp], edx

; 750  :                 int sy4x1 = srcP[y_p2*src_uv_pitch + cxplus];

  005f8	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _y_p2$29[ebp]
  005fe	0f af 45 a8	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp]
  00602	03 85 48 ff ff
	ff		 add	 eax, DWORD PTR _cxplus$16[ebp]
  00608	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  0060b	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  0060f	89 95 34 ff ff
	ff		 mov	 DWORD PTR _sy4x1$11[ebp], edx

; 751  :                 int sy5x1 = srcP[y_p3*src_uv_pitch + cxplus];

  00615	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _y_p3$28[ebp]
  0061b	0f af 45 a8	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp]
  0061f	03 85 48 ff ff
	ff		 add	 eax, DWORD PTR _cxplus$16[ebp]
  00625	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  00628	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  0062c	89 95 30 ff ff
	ff		 mov	 DWORD PTR _sy5x1$10[ebp], edx

; 752  : 
; 753  :                 int cy0x1 = (sy0x1 * 1 + sy2x1 * 7 + 4);

  00632	6b 85 3c ff ff
	ff 07		 imul	 eax, DWORD PTR _sy2x1$13[ebp], 7
  00639	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _sy0x1$15[ebp]
  0063f	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00643	89 95 2c ff ff
	ff		 mov	 DWORD PTR _cy0x1$9[ebp], edx

; 754  :                 int cy1x1 = (sy1x1 * 3 + sy3x1 * 5 + 4);

  00649	6b 85 40 ff ff
	ff 03		 imul	 eax, DWORD PTR _sy1x1$14[ebp], 3
  00650	6b 8d 38 ff ff
	ff 05		 imul	 ecx, DWORD PTR _sy3x1$12[ebp], 5
  00657	8d 54 08 04	 lea	 edx, DWORD PTR [eax+ecx+4]
  0065b	89 95 28 ff ff
	ff		 mov	 DWORD PTR _cy1x1$8[ebp], edx

; 755  :                 int cy2x1 = (sy2x1 * 5 + sy4x1 * 3 + 4);

  00661	6b 85 3c ff ff
	ff 05		 imul	 eax, DWORD PTR _sy2x1$13[ebp], 5
  00668	6b 8d 34 ff ff
	ff 03		 imul	 ecx, DWORD PTR _sy4x1$11[ebp], 3
  0066f	8d 54 08 04	 lea	 edx, DWORD PTR [eax+ecx+4]
  00673	89 95 24 ff ff
	ff		 mov	 DWORD PTR _cy2x1$7[ebp], edx

; 756  :                 int cy3x1 = (sy3x1 * 7 + sy5x1 * 1 + 4);

  00679	6b 85 38 ff ff
	ff 07		 imul	 eax, DWORD PTR _sy3x1$12[ebp], 7
  00680	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR _sy5x1$10[ebp]
  00686	8d 54 08 04	 lea	 edx, DWORD PTR [eax+ecx+4]
  0068a	89 95 20 ff ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], edx

; 757  :                 CHANGE_BIT_DEPTH_4(cy0x1, cy1x1, cy2x1, cy3x1, 3);

  00690	33 c0		 xor	 eax, eax
  00692	74 3e		 je	 SHORT $LN27@convert_yv
  00694	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR _cy0x1$9[ebp]
  0069a	c1 e1 f7	 shl	 ecx, -9			; fffffff7H
  0069d	89 8d 2c ff ff
	ff		 mov	 DWORD PTR _cy0x1$9[ebp], ecx
  006a3	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x1$8[ebp]
  006a9	c1 e2 f7	 shl	 edx, -9			; fffffff7H
  006ac	89 95 28 ff ff
	ff		 mov	 DWORD PTR _cy1x1$8[ebp], edx
  006b2	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _cy2x1$7[ebp]
  006b8	c1 e0 f7	 shl	 eax, -9			; fffffff7H
  006bb	89 85 24 ff ff
	ff		 mov	 DWORD PTR _cy2x1$7[ebp], eax
  006c1	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x1$6[ebp]
  006c7	c1 e1 f7	 shl	 ecx, -9			; fffffff7H
  006ca	89 8d 20 ff ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], ecx
  006d0	eb 45		 jmp	 SHORT $LN28@convert_yv
$LN27@convert_yv:
  006d2	ba 01 00 00 00	 mov	 edx, 1
  006d7	85 d2		 test	 edx, edx
  006d9	74 3c		 je	 SHORT $LN28@convert_yv
  006db	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR _cy0x1$9[ebp]
  006e1	c1 f8 09	 sar	 eax, 9
  006e4	89 85 2c ff ff
	ff		 mov	 DWORD PTR _cy0x1$9[ebp], eax
  006ea	8b 8d 28 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x1$8[ebp]
  006f0	c1 f9 09	 sar	 ecx, 9
  006f3	89 8d 28 ff ff
	ff		 mov	 DWORD PTR _cy1x1$8[ebp], ecx
  006f9	8b 95 24 ff ff
	ff		 mov	 edx, DWORD PTR _cy2x1$7[ebp]
  006ff	c1 fa 09	 sar	 edx, 9
  00702	89 95 24 ff ff
	ff		 mov	 DWORD PTR _cy2x1$7[ebp], edx
  00708	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x1$6[ebp]
  0070e	c1 f8 09	 sar	 eax, 9
  00711	89 85 20 ff ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], eax
$LN28@convert_yv:

; 758  : 
; 759  :                 dstC[0*dst_y_pitch   + 0] = (Tout)cy0x0;

  00717	6b 4d e4 00	 imul	 ecx, DWORD PTR _dst_y_pitch$[ebp], 0
  0071b	8b 55 94	 mov	 edx, DWORD PTR _dstC$35[ebp]
  0071e	8a 85 5c ff ff
	ff		 mov	 al, BYTE PTR _cy0x0$21[ebp]
  00724	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 760  :                 dstC[0*dst_y_pitch   + 1] = (Tout)((cy0x0 + cy0x1 + 1) >> 1);

  00727	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR _cy0x1$9[ebp]
  0072d	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR _cy0x0$21[ebp]
  00733	8d 44 0a 01	 lea	 eax, DWORD PTR [edx+ecx+1]
  00737	d1 f8		 sar	 eax, 1
  00739	6b 4d e4 00	 imul	 ecx, DWORD PTR _dst_y_pitch$[ebp], 0
  0073d	8b 55 94	 mov	 edx, DWORD PTR _dstC$35[ebp]
  00740	88 44 0a 01	 mov	 BYTE PTR [edx+ecx+1], al

; 761  :                 dstC[1*dst_y_pitch   + 0] = (Tout)cy1x0;

  00744	8b 45 94	 mov	 eax, DWORD PTR _dstC$35[ebp]
  00747	03 45 e4	 add	 eax, DWORD PTR _dst_y_pitch$[ebp]
  0074a	8a 8d 58 ff ff
	ff		 mov	 cl, BYTE PTR _cy1x0$20[ebp]
  00750	88 08		 mov	 BYTE PTR [eax], cl

; 762  :                 dstC[1*dst_y_pitch   + 1] = (Tout)((cy1x0 + cy1x1 + 1) >> 1);

  00752	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x1$8[ebp]
  00758	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x0$20[ebp]
  0075e	8d 4c 10 01	 lea	 ecx, DWORD PTR [eax+edx+1]
  00762	d1 f9		 sar	 ecx, 1
  00764	8b 55 94	 mov	 edx, DWORD PTR _dstC$35[ebp]
  00767	03 55 e4	 add	 edx, DWORD PTR _dst_y_pitch$[ebp]
  0076a	88 4a 01	 mov	 BYTE PTR [edx+1], cl

; 763  :                 dstC[2*dst_y_pitch   + 0] = (Tout)cy2x0;

  0076d	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  00770	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$35[ebp]
  00773	8a 95 54 ff ff
	ff		 mov	 dl, BYTE PTR _cy2x0$19[ebp]
  00779	88 14 41	 mov	 BYTE PTR [ecx+eax*2], dl

; 764  :                 dstC[2*dst_y_pitch   + 1] = (Tout)((cy2x0 + cy2x1 + 1) >> 1);

  0077c	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _cy2x1$7[ebp]
  00782	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _cy2x0$19[ebp]
  00788	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  0078c	d1 fa		 sar	 edx, 1
  0078e	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  00791	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$35[ebp]
  00794	88 54 41 01	 mov	 BYTE PTR [ecx+eax*2+1], dl

; 765  :                 dstC[3*dst_y_pitch   + 0] = (Tout)cy3x0;

  00798	6b 55 e4 03	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 3
  0079c	8b 45 94	 mov	 eax, DWORD PTR _dstC$35[ebp]
  0079f	8a 8d 50 ff ff
	ff		 mov	 cl, BYTE PTR _cy3x0$18[ebp]
  007a5	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 766  :                 dstC[3*dst_y_pitch   + 1] = (Tout)((cy3x0 + cy3x1 + 1) >> 1);

  007a8	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR _cy3x1$6[ebp]
  007ae	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$18[ebp]
  007b4	8d 4c 10 01	 lea	 ecx, DWORD PTR [eax+edx+1]
  007b8	d1 f9		 sar	 ecx, 1
  007ba	6b 55 e4 03	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 3
  007be	8b 45 94	 mov	 eax, DWORD PTR _dstC$35[ebp]
  007c1	88 4c 10 01	 mov	 BYTE PTR [eax+edx+1], cl

; 767  : 
; 768  :                 cy0x0 = cy0x1;

  007c5	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR _cy0x1$9[ebp]
  007cb	89 8d 5c ff ff
	ff		 mov	 DWORD PTR _cy0x0$21[ebp], ecx

; 769  :                 cy1x0 = cy1x1;

  007d1	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x1$8[ebp]
  007d7	89 95 58 ff ff
	ff		 mov	 DWORD PTR _cy1x0$20[ebp], edx

; 770  :                 cy2x0 = cy2x1;

  007dd	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _cy2x1$7[ebp]
  007e3	89 85 54 ff ff
	ff		 mov	 DWORD PTR _cy2x0$19[ebp], eax

; 771  :                 cy3x0 = cy3x1;

  007e9	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x1$6[ebp]
  007ef	89 8d 50 ff ff
	ff		 mov	 DWORD PTR _cy3x0$18[ebp], ecx

; 772  :             }

  007f5	e9 39 fd ff ff	 jmp	 $LN14@convert_yv
$LN15@convert_yv:

; 773  :         }

  007fa	e9 90 fa ff ff	 jmp	 $LN11@convert_yv
$LN12@convert_yv:

; 774  :     }

  007ff	e9 41 fa ff ff	 jmp	 $LN8@convert_yv
$LN1@convert_yv:

; 775  : }

  00804	52		 push	 edx
  00805	8b cd		 mov	 ecx, ebp
  00807	50		 push	 eax
  00808	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN47@convert_yv
  0080e	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00813	58		 pop	 eax
  00814	5a		 pop	 edx
  00815	5f		 pop	 edi
  00816	5b		 pop	 ebx
  00817	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0081a	33 cd		 xor	 ecx, ebp
  0081c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00821	81 c4 18 01 00
	00		 add	 esp, 280		; 00000118H
  00827	3b ec		 cmp	 ebp, esp
  00829	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0082e	8b e5		 mov	 esp, ebp
  00830	5d		 pop	 ebp
  00831	c3		 ret	 0
  00832	66 90		 npad	 2
$LN47@convert_yv:
  00834	01 00 00 00	 DD	 1
  00838	00 00 00 00	 DD	 $LN46@convert_yv
$LN46@convert_yv:
  0083c	d4 ff ff ff	 DD	 -44			; ffffffd4H
  00840	0c 00 00 00	 DD	 12			; 0000000cH
  00844	00 00 00 00	 DD	 $LN45@convert_yv
$LN45@convert_yv:
  00848	79		 DB	 121			; 00000079H
  00849	5f		 DB	 95			; 0000005fH
  0084a	72		 DB	 114			; 00000072H
  0084b	61		 DB	 97			; 00000061H
  0084c	6e		 DB	 110			; 0000006eH
  0084d	67		 DB	 103			; 00000067H
  0084e	65		 DB	 101			; 00000065H
  0084f	00		 DB	 0
??$convert_yv12_i_to_yuv444_c@G$0O@E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_i_to_yuv444_c<unsigned short,14,unsigned char,8,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yv12_14_i_to_yuv444@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_14_i_to_yuv444

; 805  : static void convert_yv12_14_i_to_yuv444(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 806  :     convert_yv12_i_to_yuv444_c<uint16_t, 14, uint8_t, 8, false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yv12_i_to_yuv444_c@G$0O@E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_i_to_yuv444_c<unsigned short,14,unsigned char,8,0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 807  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yv12_14_i_to_yuv444@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_14_i_to_yuv444
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
tv427 = -300						; size = 4
tv312 = -296						; size = 4
tv227 = -292						; size = 4
$T1 = -288						; size = 4
$T2 = -284						; size = 4
$T3 = -280						; size = 4
$T4 = -276						; size = 4
$T5 = -272						; size = 12
_cy3x1$6 = -260						; size = 4
_cy1x1$7 = -256						; size = 4
_cy3x0$8 = -252						; size = 4
_cy1x0$9 = -248						; size = 4
_cy4x1$10 = -244					; size = 4
_cy2x1$11 = -240					; size = 4
_cy0x1$12 = -236					; size = 4
_cy4x0$13 = -232					; size = 4
_cy2x0$14 = -228					; size = 4
_cy0x0$15 = -224					; size = 4
_cxplus$16 = -220					; size = 4
_x$17 = -216						; size = 4
_cy3x1$18 = -212					; size = 4
_cy1x1$19 = -208					; size = 4
_cy3x0$20 = -204					; size = 4
_cy1x0$21 = -200					; size = 4
_cy4x1$22 = -196					; size = 4
_cy2x1$23 = -192					; size = 4
_cy0x1$24 = -188					; size = 4
_cy4x0$25 = -184					; size = 4
_cy2x0$26 = -180					; size = 4
_cy0x0$27 = -176					; size = 4
_cxplus$28 = -172					; size = 4
_x$29 = -168						; size = 4
_cy3x1$30 = -164					; size = 4
_cy1x1$31 = -160					; size = 4
_cy3x0$32 = -156					; size = 4
_cy1x0$33 = -152					; size = 4
_cy4x1$34 = -148					; size = 4
_cy2x1$35 = -144					; size = 4
_cy0x1$36 = -140					; size = 4
_cy4x0$37 = -136					; size = 4
_cy2x0$38 = -132					; size = 4
_cy0x0$39 = -128					; size = 4
_cxplus$40 = -124					; size = 4
_x$41 = -120						; size = 4
_x_fin$42 = -116					; size = 4
_srcP$43 = -112						; size = 4
_dstC$44 = -108						; size = 4
_y$45 = -104						; size = 4
_dstLine$46 = -100					; size = 4
_srcCLine$47 = -96					; size = 4
_ic$48 = -92						; size = 4
_src_uv_pitch$ = -88					; size = 4
_x$49 = -84						; size = 4
_y$50 = -80						; size = 4
_y_width$51 = -76					; size = 4
_y_fin$52 = -72						; size = 4
_dstLine$53 = -68					; size = 4
_srcYLine$54 = -64					; size = 4
$T55 = -60						; size = 12
_y_range$ = -44						; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yv12_p_to_yuv444_c@G$0O@E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_p_to_yuv444_c<unsigned short,14,unsigned char,8,0>

; 573  : static void __forceinline convert_yv12_p_to_yuv444_c(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 2c 01 00
	00		 sub	 esp, 300		; 0000012cH
  00009	53		 push	 ebx
  0000a	57		 push	 edi
  0000b	8d bd d4 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-300]
  00011	b9 4b 00 00 00	 mov	 ecx, 75			; 0000004bH
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 574  :     static_assert((sizeof(Tin)  == 1 && in_bit_depth  == 8) || (sizeof(Tin)  == 2 && 8 < in_bit_depth  && in_bit_depth  <= 16), "invalid input bit depth.");
; 575  :     static_assert((sizeof(Tout) == 1 && out_bit_depth == 8) || (sizeof(Tout) == 2 && 8 < out_bit_depth && out_bit_depth <= 16), "invalid output bit depth.");
; 576  :     const int crop_left   = crop[0];

  00027	b8 04 00 00 00	 mov	 eax, 4
  0002c	6b c8 00	 imul	 ecx, eax, 0
  0002f	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00032	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00035	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 577  :     const int crop_up     = crop[1];

  00038	b9 04 00 00 00	 mov	 ecx, 4
  0003d	c1 e1 00	 shl	 ecx, 0
  00040	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00043	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00046	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 578  :     const int crop_right  = crop[2];

  00049	b9 04 00 00 00	 mov	 ecx, 4
  0004e	d1 e1		 shl	 ecx, 1
  00050	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00053	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00056	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 579  :     const int crop_bottom = crop[3];

  00059	b9 04 00 00 00	 mov	 ecx, 4
  0005e	6b d1 03	 imul	 edx, ecx, 3
  00061	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00064	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00067	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 580  :     const int src_y_pitch = src_y_pitch_byte / sizeof(Tin);

  0006a	8b 55 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebp]
  0006d	d1 ea		 shr	 edx, 1
  0006f	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 581  :     const int dst_y_pitch = dst_y_pitch_byte / sizeof(Tout);

  00072	8b 45 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  00075	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 582  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00078	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0007b	51		 push	 ecx
  0007c	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0007f	52		 push	 edx
  00080	8b 45 20	 mov	 eax, DWORD PTR _height$[ebp]
  00083	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  00086	50		 push	 eax
  00087	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  0008a	51		 push	 ecx
  0008b	8d 95 f0 fe ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  00091	52		 push	 edx
  00092	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00097	83 c4 14	 add	 esp, 20			; 00000014H
  0009a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009c	89 4d c4	 mov	 DWORD PTR $T55[ebp], ecx
  0009f	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a2	89 55 c8	 mov	 DWORD PTR $T55[ebp+4], edx
  000a5	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000a8	89 45 cc	 mov	 DWORD PTR $T55[ebp+8], eax
  000ab	8b 4d c4	 mov	 ecx, DWORD PTR $T55[ebp]
  000ae	89 4d d4	 mov	 DWORD PTR _y_range$[ebp], ecx
  000b1	8b 55 c8	 mov	 edx, DWORD PTR $T55[ebp+4]
  000b4	89 55 d8	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000b7	8b 45 cc	 mov	 eax, DWORD PTR $T55[ebp+8]
  000ba	89 45 dc	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 583  :     //Y
; 584  :     if (!uv_only) {

  000bd	b9 01 00 00 00	 mov	 ecx, 1
  000c2	85 c9		 test	 ecx, ecx
  000c4	0f 84 6a 01 00
	00		 je	 $LN23@convert_yv

; 585  :         Tin *srcYLine = (Tin *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000ca	ba 04 00 00 00	 mov	 edx, 4
  000cf	6b c2 00	 imul	 eax, edx, 0
  000d2	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  000d5	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  000d9	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  000dc	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  000df	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  000e2	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  000e5	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  000e8	89 45 c0	 mov	 DWORD PTR _srcYLine$54[ebp], eax

; 586  :         Tout *dstLine = (Tout *)dst[0] + dst_y_pitch * y_range.start_dst;

  000eb	b9 04 00 00 00	 mov	 ecx, 4
  000f0	6b d1 00	 imul	 edx, ecx, 0
  000f3	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  000f6	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  000fa	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  000fd	03 04 11	 add	 eax, DWORD PTR [ecx+edx]
  00100	89 45 bc	 mov	 DWORD PTR _dstLine$53[ebp], eax

; 587  :         const int y_fin = height - crop_bottom;

  00103	8b 55 20	 mov	 edx, DWORD PTR _height$[ebp]
  00106	2b 55 ec	 sub	 edx, DWORD PTR _crop_bottom$[ebp]
  00109	89 55 b8	 mov	 DWORD PTR _y_fin$52[ebp], edx

; 588  :         const int y_width = width - crop_right - crop_left;

  0010c	8b 45 10	 mov	 eax, DWORD PTR _width$[ebp]
  0010f	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  00112	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  00115	89 45 b4	 mov	 DWORD PTR _y_width$51[ebp], eax

; 589  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  00118	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _y$50[ebp], 0
  0011f	eb 1e		 jmp	 SHORT $LN4@convert_yv
$LN2@convert_yv:
  00121	8b 4d b0	 mov	 ecx, DWORD PTR _y$50[ebp]
  00124	83 c1 01	 add	 ecx, 1
  00127	89 4d b0	 mov	 DWORD PTR _y$50[ebp], ecx
  0012a	8b 55 e8	 mov	 edx, DWORD PTR _src_y_pitch$[ebp]
  0012d	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$54[ebp]
  00130	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00133	89 4d c0	 mov	 DWORD PTR _srcYLine$54[ebp], ecx
  00136	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$53[ebp]
  00139	03 55 e4	 add	 edx, DWORD PTR _dst_y_pitch$[ebp]
  0013c	89 55 bc	 mov	 DWORD PTR _dstLine$53[ebp], edx
$LN4@convert_yv:
  0013f	8b 45 b0	 mov	 eax, DWORD PTR _y$50[ebp]
  00142	3b 45 dc	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  00145	0f 8d e9 00 00
	00		 jge	 $LN23@convert_yv

; 590  :             if (in_bit_depth == out_bit_depth && sizeof(Tin) == sizeof(Tout)) {

  0014b	33 c9		 xor	 ecx, ecx
  0014d	74 1b		 je	 SHORT $LN24@convert_yv

; 591  :                 memcpy(dstLine, srcYLine, y_width * sizeof(Tin));

  0014f	8b 55 b4	 mov	 edx, DWORD PTR _y_width$51[ebp]
  00152	d1 e2		 shl	 edx, 1
  00154	52		 push	 edx
  00155	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$54[ebp]
  00158	50		 push	 eax
  00159	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$53[ebp]
  0015c	51		 push	 ecx
  0015d	e8 00 00 00 00	 call	 _memcpy
  00162	83 c4 0c	 add	 esp, 12			; 0000000cH

; 592  :             } else {

  00165	e9 c5 00 00 00	 jmp	 $LN25@convert_yv
$LN24@convert_yv:

; 593  :                 for (int x = 0; x < y_width; x++) {

  0016a	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR _x$49[ebp], 0
  00171	eb 09		 jmp	 SHORT $LN7@convert_yv
$LN5@convert_yv:
  00173	8b 55 ac	 mov	 edx, DWORD PTR _x$49[ebp]
  00176	83 c2 01	 add	 edx, 1
  00179	89 55 ac	 mov	 DWORD PTR _x$49[ebp], edx
$LN7@convert_yv:
  0017c	8b 45 ac	 mov	 eax, DWORD PTR _x$49[ebp]
  0017f	3b 45 b4	 cmp	 eax, DWORD PTR _y_width$51[ebp]
  00182	0f 8d a7 00 00
	00		 jge	 $LN25@convert_yv

; 594  :                     if (out_bit_depth > in_bit_depth) {

  00188	33 c9		 xor	 ecx, ecx
  0018a	74 42		 je	 SHORT $LN26@convert_yv

; 595  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) << std::max(out_bit_depth - in_bit_depth, 0));

  0018c	c7 85 ec fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], 0
  00196	c7 85 e8 fe ff
	ff fa ff ff ff	 mov	 DWORD PTR $T3[ebp], -6	; fffffffaH
  001a0	8b 55 ac	 mov	 edx, DWORD PTR _x$49[ebp]
  001a3	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$54[ebp]
  001a6	0f b7 1c 50	 movzx	 ebx, WORD PTR [eax+edx*2]
  001aa	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  001b0	51		 push	 ecx
  001b1	8d 95 e8 fe ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  001b7	52		 push	 edx
  001b8	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  001bd	83 c4 08	 add	 esp, 8
  001c0	8b 08		 mov	 ecx, DWORD PTR [eax]
  001c2	d3 e3		 shl	 ebx, cl
  001c4	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$53[ebp]
  001c7	03 45 ac	 add	 eax, DWORD PTR _x$49[ebp]
  001ca	88 18		 mov	 BYTE PTR [eax], bl
  001cc	eb 5c		 jmp	 SHORT $LN27@convert_yv
$LN26@convert_yv:

; 596  :                     } else if (out_bit_depth < in_bit_depth) {

  001ce	b9 01 00 00 00	 mov	 ecx, 1
  001d3	85 c9		 test	 ecx, ecx
  001d5	74 42		 je	 SHORT $LN28@convert_yv

; 597  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) >> std::max(in_bit_depth - out_bit_depth, 0));

  001d7	c7 85 e4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], 0
  001e1	c7 85 e0 fe ff
	ff 06 00 00 00	 mov	 DWORD PTR $T1[ebp], 6
  001eb	8b 55 ac	 mov	 edx, DWORD PTR _x$49[ebp]
  001ee	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$54[ebp]
  001f1	0f b7 1c 50	 movzx	 ebx, WORD PTR [eax+edx*2]
  001f5	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  001fb	51		 push	 ecx
  001fc	8d 95 e0 fe ff
	ff		 lea	 edx, DWORD PTR $T1[ebp]
  00202	52		 push	 edx
  00203	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  00208	83 c4 08	 add	 esp, 8
  0020b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0020d	d3 fb		 sar	 ebx, cl
  0020f	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$53[ebp]
  00212	03 45 ac	 add	 eax, DWORD PTR _x$49[ebp]
  00215	88 18		 mov	 BYTE PTR [eax], bl

; 598  :                     } else {

  00217	eb 11		 jmp	 SHORT $LN27@convert_yv
$LN28@convert_yv:

; 599  :                         dstLine[x] = (Tout)srcYLine[x];

  00219	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$53[ebp]
  0021c	03 4d ac	 add	 ecx, DWORD PTR _x$49[ebp]
  0021f	8b 55 ac	 mov	 edx, DWORD PTR _x$49[ebp]
  00222	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$54[ebp]
  00225	8a 14 50	 mov	 dl, BYTE PTR [eax+edx*2]
  00228	88 11		 mov	 BYTE PTR [ecx], dl
$LN27@convert_yv:

; 600  :                     }
; 601  :                 }

  0022a	e9 44 ff ff ff	 jmp	 $LN5@convert_yv
$LN25@convert_yv:

; 602  :             }
; 603  :         }

  0022f	e9 ed fe ff ff	 jmp	 $LN2@convert_yv
$LN23@convert_yv:

; 604  :     }
; 605  :     //UV
; 606  :     const int src_uv_pitch = src_uv_pitch_byte / sizeof(Tin);

  00234	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  00237	d1 e8		 shr	 eax, 1
  00239	89 45 a8	 mov	 DWORD PTR _src_uv_pitch$[ebp], eax

; 607  :     for (int ic = 1; ic < 3; ic++) {

  0023c	c7 45 a4 01 00
	00 00		 mov	 DWORD PTR _ic$48[ebp], 1
  00243	eb 09		 jmp	 SHORT $LN10@convert_yv
$LN8@convert_yv:
  00245	8b 4d a4	 mov	 ecx, DWORD PTR _ic$48[ebp]
  00248	83 c1 01	 add	 ecx, 1
  0024b	89 4d a4	 mov	 DWORD PTR _ic$48[ebp], ecx
$LN10@convert_yv:
  0024e	83 7d a4 03	 cmp	 DWORD PTR _ic$48[ebp], 3
  00252	0f 8d ea 06 00
	00		 jge	 $LN1@convert_yv

; 608  :         Tin *srcCLine = (Tin *)src[ic] + (((src_uv_pitch * y_range.start_src) + crop_left) >> 1);

  00258	8b 55 a8	 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  0025b	0f af 55 d4	 imul	 edx, DWORD PTR _y_range$[ebp]
  0025f	03 55 f8	 add	 edx, DWORD PTR _crop_left$[ebp]
  00262	d1 fa		 sar	 edx, 1
  00264	8b 45 a4	 mov	 eax, DWORD PTR _ic$48[ebp]
  00267	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  0026a	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  0026d	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00270	89 4d a0	 mov	 DWORD PTR _srcCLine$47[ebp], ecx

; 609  :         Tout *dstLine = (Tout *)dst[ic] + dst_y_pitch * y_range.start_dst;

  00273	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  00276	0f af 55 d8	 imul	 edx, DWORD PTR _y_range$[ebp+4]
  0027a	8b 45 a4	 mov	 eax, DWORD PTR _ic$48[ebp]
  0027d	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  00280	03 14 81	 add	 edx, DWORD PTR [ecx+eax*4]
  00283	89 55 9c	 mov	 DWORD PTR _dstLine$46[ebp], edx

; 610  :         for (int y = 0; y < y_range.len; y += 2, srcCLine += src_uv_pitch, dstLine += dst_y_pitch * 2) {

  00286	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _y$45[ebp], 0
  0028d	eb 21		 jmp	 SHORT $LN13@convert_yv
$LN11@convert_yv:
  0028f	8b 55 98	 mov	 edx, DWORD PTR _y$45[ebp]
  00292	83 c2 02	 add	 edx, 2
  00295	89 55 98	 mov	 DWORD PTR _y$45[ebp], edx
  00298	8b 45 a8	 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  0029b	8b 4d a0	 mov	 ecx, DWORD PTR _srcCLine$47[ebp]
  0029e	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  002a1	89 55 a0	 mov	 DWORD PTR _srcCLine$47[ebp], edx
  002a4	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  002a7	8b 4d 9c	 mov	 ecx, DWORD PTR _dstLine$46[ebp]
  002aa	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  002ad	89 55 9c	 mov	 DWORD PTR _dstLine$46[ebp], edx
$LN13@convert_yv:
  002b0	8b 45 98	 mov	 eax, DWORD PTR _y$45[ebp]
  002b3	3b 45 dc	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  002b6	0f 8d 81 06 00
	00		 jge	 $LN12@convert_yv

; 611  :             Tout *dstC = dstLine;

  002bc	8b 4d 9c	 mov	 ecx, DWORD PTR _dstLine$46[ebp]
  002bf	89 4d 94	 mov	 DWORD PTR _dstC$44[ebp], ecx

; 612  :             Tin *srcP = srcCLine;

  002c2	8b 55 a0	 mov	 edx, DWORD PTR _srcCLine$47[ebp]
  002c5	89 55 90	 mov	 DWORD PTR _srcP$43[ebp], edx

; 613  :             const int x_fin = width - crop_right - crop_left;

  002c8	8b 45 10	 mov	 eax, DWORD PTR _width$[ebp]
  002cb	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  002ce	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  002d1	89 45 8c	 mov	 DWORD PTR _x_fin$42[ebp], eax

; 614  :             if (y == 0) {

  002d4	83 7d 98 00	 cmp	 DWORD PTR _y$45[ebp], 0
  002d8	0f 85 04 02 00
	00		 jne	 $LN30@convert_yv

; 615  :                 for (int x = 0; x < x_fin; x += 2, dstC += 2, srcP++) {

  002de	c7 45 88 00 00
	00 00		 mov	 DWORD PTR _x$41[ebp], 0
  002e5	eb 1b		 jmp	 SHORT $LN16@convert_yv
$LN14@convert_yv:
  002e7	8b 4d 88	 mov	 ecx, DWORD PTR _x$41[ebp]
  002ea	83 c1 02	 add	 ecx, 2
  002ed	89 4d 88	 mov	 DWORD PTR _x$41[ebp], ecx
  002f0	8b 55 94	 mov	 edx, DWORD PTR _dstC$44[ebp]
  002f3	83 c2 02	 add	 edx, 2
  002f6	89 55 94	 mov	 DWORD PTR _dstC$44[ebp], edx
  002f9	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  002fc	83 c0 02	 add	 eax, 2
  002ff	89 45 90	 mov	 DWORD PTR _srcP$43[ebp], eax
$LN16@convert_yv:
  00302	8b 4d 88	 mov	 ecx, DWORD PTR _x$41[ebp]
  00305	3b 4d 8c	 cmp	 ecx, DWORD PTR _x_fin$42[ebp]
  00308	0f 8d cf 01 00
	00		 jge	 $LN15@convert_yv

; 616  :                     int cxplus = (x + 2 < x_fin);

  0030e	8b 55 88	 mov	 edx, DWORD PTR _x$41[ebp]
  00311	83 c2 02	 add	 edx, 2
  00314	3b 55 8c	 cmp	 edx, DWORD PTR _x_fin$42[ebp]
  00317	7d 0c		 jge	 SHORT $LN44@convert_yv
  00319	c7 85 dc fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv227[ebp], 1
  00323	eb 0a		 jmp	 SHORT $LN45@convert_yv
$LN44@convert_yv:
  00325	c7 85 dc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv227[ebp], 0
$LN45@convert_yv:
  0032f	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR tv227[ebp]
  00335	89 45 84	 mov	 DWORD PTR _cxplus$40[ebp], eax

; 617  :                     int cy0x0 = srcP[ 0*src_uv_pitch + 0];

  00338	6b 4d a8 00	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 0
  0033c	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  0033f	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00343	89 45 80	 mov	 DWORD PTR _cy0x0$39[ebp], eax

; 618  :                     int cy2x0 = srcP[ 0*src_uv_pitch + 0];

  00346	6b 4d a8 00	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 0
  0034a	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  0034d	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00351	89 85 7c ff ff
	ff		 mov	 DWORD PTR _cy2x0$38[ebp], eax

; 619  :                     int cy4x0 = srcP[ 1*src_uv_pitch + 0];

  00357	8b 4d a8	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  0035a	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  0035d	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00361	89 85 78 ff ff
	ff		 mov	 DWORD PTR _cy4x0$37[ebp], eax

; 620  :                     int cy0x1 = srcP[ 0*src_uv_pitch + cxplus];

  00367	6b 4d a8 00	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 0
  0036b	03 4d 84	 add	 ecx, DWORD PTR _cxplus$40[ebp]
  0036e	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  00371	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00375	89 85 74 ff ff
	ff		 mov	 DWORD PTR _cy0x1$36[ebp], eax

; 621  :                     int cy2x1 = srcP[ 0*src_uv_pitch + cxplus];

  0037b	6b 4d a8 00	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 0
  0037f	03 4d 84	 add	 ecx, DWORD PTR _cxplus$40[ebp]
  00382	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  00385	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00389	89 85 70 ff ff
	ff		 mov	 DWORD PTR _cy2x1$35[ebp], eax

; 622  :                     int cy4x1 = srcP[ 1*src_uv_pitch + cxplus];

  0038f	8b 4d 84	 mov	 ecx, DWORD PTR _cxplus$40[ebp]
  00392	03 4d a8	 add	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00395	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  00398	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  0039c	89 85 6c ff ff
	ff		 mov	 DWORD PTR _cy4x1$34[ebp], eax

; 623  : 
; 624  :                     int cy1x0 = (cy0x0 * 1 + cy2x0 * 3 + 2);

  003a2	6b 8d 7c ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy2x0$38[ebp], 3
  003a9	8b 55 80	 mov	 edx, DWORD PTR _cy0x0$39[ebp]
  003ac	8d 44 0a 02	 lea	 eax, DWORD PTR [edx+ecx+2]
  003b0	89 85 68 ff ff
	ff		 mov	 DWORD PTR _cy1x0$33[ebp], eax

; 625  :                     int cy3x0 = (cy2x0 * 3 + cy4x0 * 1 + 2);

  003b6	6b 8d 7c ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy2x0$38[ebp], 3
  003bd	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _cy4x0$37[ebp]
  003c3	8d 44 11 02	 lea	 eax, DWORD PTR [ecx+edx+2]
  003c7	89 85 64 ff ff
	ff		 mov	 DWORD PTR _cy3x0$32[ebp], eax

; 626  :                     int cy1x1 = (cy0x1 * 1 + cy2x1 * 3 + 2);

  003cd	6b 8d 70 ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy2x1$35[ebp], 3
  003d4	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _cy0x1$36[ebp]
  003da	8d 44 0a 02	 lea	 eax, DWORD PTR [edx+ecx+2]
  003de	89 85 60 ff ff
	ff		 mov	 DWORD PTR _cy1x1$31[ebp], eax

; 627  :                     int cy3x1 = (cy2x1 * 3 + cy4x1 * 1 + 2);

  003e4	6b 8d 70 ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy2x1$35[ebp], 3
  003eb	8b 95 6c ff ff
	ff		 mov	 edx, DWORD PTR _cy4x1$34[ebp]
  003f1	8d 44 11 02	 lea	 eax, DWORD PTR [ecx+edx+2]
  003f5	89 85 5c ff ff
	ff		 mov	 DWORD PTR _cy3x1$30[ebp], eax

; 628  :                     CHANGE_BIT_DEPTH_4(cy1x0, cy3x0, cy1x1, cy3x1, 2);

  003fb	33 c9		 xor	 ecx, ecx
  003fd	74 3e		 je	 SHORT $LN32@convert_yv
  003ff	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x0$33[ebp]
  00405	c1 e2 f8	 shl	 edx, -8			; fffffff8H
  00408	89 95 68 ff ff
	ff		 mov	 DWORD PTR _cy1x0$33[ebp], edx
  0040e	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$32[ebp]
  00414	c1 e0 f8	 shl	 eax, -8			; fffffff8H
  00417	89 85 64 ff ff
	ff		 mov	 DWORD PTR _cy3x0$32[ebp], eax
  0041d	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x1$31[ebp]
  00423	c1 e1 f8	 shl	 ecx, -8			; fffffff8H
  00426	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _cy1x1$31[ebp], ecx
  0042c	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR _cy3x1$30[ebp]
  00432	c1 e2 f8	 shl	 edx, -8			; fffffff8H
  00435	89 95 5c ff ff
	ff		 mov	 DWORD PTR _cy3x1$30[ebp], edx
  0043b	eb 45		 jmp	 SHORT $LN33@convert_yv
$LN32@convert_yv:
  0043d	b8 01 00 00 00	 mov	 eax, 1
  00442	85 c0		 test	 eax, eax
  00444	74 3c		 je	 SHORT $LN33@convert_yv
  00446	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x0$33[ebp]
  0044c	c1 f9 08	 sar	 ecx, 8
  0044f	89 8d 68 ff ff
	ff		 mov	 DWORD PTR _cy1x0$33[ebp], ecx
  00455	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR _cy3x0$32[ebp]
  0045b	c1 fa 08	 sar	 edx, 8
  0045e	89 95 64 ff ff
	ff		 mov	 DWORD PTR _cy3x0$32[ebp], edx
  00464	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x1$31[ebp]
  0046a	c1 f8 08	 sar	 eax, 8
  0046d	89 85 60 ff ff
	ff		 mov	 DWORD PTR _cy1x1$31[ebp], eax
  00473	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x1$30[ebp]
  00479	c1 f9 08	 sar	 ecx, 8
  0047c	89 8d 5c ff ff
	ff		 mov	 DWORD PTR _cy3x1$30[ebp], ecx
$LN33@convert_yv:

; 629  : 
; 630  :                     dstC[0*dst_y_pitch   + 0] = (Tout)cy1x0;

  00482	6b 55 e4 00	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 0
  00486	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  00489	8a 8d 68 ff ff
	ff		 mov	 cl, BYTE PTR _cy1x0$33[ebp]
  0048f	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 631  :                     dstC[0*dst_y_pitch   + 1] = (Tout)((cy1x0 + cy1x1 + 1) >> 1);

  00492	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x1$31[ebp]
  00498	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x0$33[ebp]
  0049e	8d 4c 10 01	 lea	 ecx, DWORD PTR [eax+edx+1]
  004a2	d1 f9		 sar	 ecx, 1
  004a4	6b 55 e4 00	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 0
  004a8	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  004ab	88 4c 10 01	 mov	 BYTE PTR [eax+edx+1], cl

; 632  :                     dstC[1*dst_y_pitch   + 0] = (Tout)cy3x0;

  004af	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$44[ebp]
  004b2	03 4d e4	 add	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  004b5	8a 95 64 ff ff
	ff		 mov	 dl, BYTE PTR _cy3x0$32[ebp]
  004bb	88 11		 mov	 BYTE PTR [ecx], dl

; 633  :                     dstC[1*dst_y_pitch   + 1] = (Tout)((cy3x0 + cy3x1 + 1) >> 1);

  004bd	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _cy3x1$30[ebp]
  004c3	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x0$32[ebp]
  004c9	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  004cd	d1 fa		 sar	 edx, 1
  004cf	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  004d2	03 45 e4	 add	 eax, DWORD PTR _dst_y_pitch$[ebp]
  004d5	88 50 01	 mov	 BYTE PTR [eax+1], dl

; 634  :                 }

  004d8	e9 0a fe ff ff	 jmp	 $LN14@convert_yv
$LN15@convert_yv:

; 635  :             } else if (y >= height-2) {

  004dd	e9 56 04 00 00	 jmp	 $LN31@convert_yv
$LN30@convert_yv:
  004e2	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  004e5	83 e9 02	 sub	 ecx, 2
  004e8	39 4d 98	 cmp	 DWORD PTR _y$45[ebp], ecx
  004eb	0f 8c 27 02 00
	00		 jl	 $LN35@convert_yv

; 636  :                 for (int x = 0; x < x_fin; x += 2, dstC += 2, srcP++) {

  004f1	c7 85 58 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _x$29[ebp], 0
  004fb	eb 21		 jmp	 SHORT $LN19@convert_yv
$LN17@convert_yv:
  004fd	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _x$29[ebp]
  00503	83 c2 02	 add	 edx, 2
  00506	89 95 58 ff ff
	ff		 mov	 DWORD PTR _x$29[ebp], edx
  0050c	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  0050f	83 c0 02	 add	 eax, 2
  00512	89 45 94	 mov	 DWORD PTR _dstC$44[ebp], eax
  00515	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$43[ebp]
  00518	83 c1 02	 add	 ecx, 2
  0051b	89 4d 90	 mov	 DWORD PTR _srcP$43[ebp], ecx
$LN19@convert_yv:
  0051e	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _x$29[ebp]
  00524	3b 55 8c	 cmp	 edx, DWORD PTR _x_fin$42[ebp]
  00527	0f 8d e6 01 00
	00		 jge	 $LN18@convert_yv

; 637  :                     int cxplus = (x + 2 < x_fin);

  0052d	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _x$29[ebp]
  00533	83 c0 02	 add	 eax, 2
  00536	3b 45 8c	 cmp	 eax, DWORD PTR _x_fin$42[ebp]
  00539	7d 0c		 jge	 SHORT $LN46@convert_yv
  0053b	c7 85 d8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv312[ebp], 1
  00545	eb 0a		 jmp	 SHORT $LN47@convert_yv
$LN46@convert_yv:
  00547	c7 85 d8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv312[ebp], 0
$LN47@convert_yv:
  00551	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR tv312[ebp]
  00557	89 8d 54 ff ff
	ff		 mov	 DWORD PTR _cxplus$28[ebp], ecx

; 638  :                     int cy0x0 = srcP[-1*src_uv_pitch + 0];

  0055d	6b 55 a8 ff	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], -1
  00561	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  00564	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  00568	89 8d 50 ff ff
	ff		 mov	 DWORD PTR _cy0x0$27[ebp], ecx

; 639  :                     int cy2x0 = srcP[ 0*src_uv_pitch + 0];

  0056e	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  00572	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  00575	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  00579	89 8d 4c ff ff
	ff		 mov	 DWORD PTR _cy2x0$26[ebp], ecx

; 640  :                     int cy4x0 = srcP[ 0*src_uv_pitch + 0];

  0057f	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  00583	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  00586	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  0058a	89 8d 48 ff ff
	ff		 mov	 DWORD PTR _cy4x0$25[ebp], ecx

; 641  :                     int cy0x1 = srcP[-1*src_uv_pitch + cxplus];

  00590	6b 55 a8 ff	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], -1
  00594	03 95 54 ff ff
	ff		 add	 edx, DWORD PTR _cxplus$28[ebp]
  0059a	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  0059d	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  005a1	89 8d 44 ff ff
	ff		 mov	 DWORD PTR _cy0x1$24[ebp], ecx

; 642  :                     int cy2x1 = srcP[ 0*src_uv_pitch + cxplus];

  005a7	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  005ab	03 95 54 ff ff
	ff		 add	 edx, DWORD PTR _cxplus$28[ebp]
  005b1	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  005b4	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  005b8	89 8d 40 ff ff
	ff		 mov	 DWORD PTR _cy2x1$23[ebp], ecx

; 643  :                     int cy4x1 = srcP[ 0*src_uv_pitch + cxplus];

  005be	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  005c2	03 95 54 ff ff
	ff		 add	 edx, DWORD PTR _cxplus$28[ebp]
  005c8	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  005cb	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  005cf	89 8d 3c ff ff
	ff		 mov	 DWORD PTR _cy4x1$22[ebp], ecx

; 644  : 
; 645  :                     int cy1x0 = (cy0x0 * 1 + cy2x0 * 3 + 2);

  005d5	6b 95 4c ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x0$26[ebp], 3
  005dc	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _cy0x0$27[ebp]
  005e2	8d 4c 10 02	 lea	 ecx, DWORD PTR [eax+edx+2]
  005e6	89 8d 38 ff ff
	ff		 mov	 DWORD PTR _cy1x0$21[ebp], ecx

; 646  :                     int cy3x0 = (cy2x0 * 3 + cy4x0 * 1 + 2);

  005ec	6b 95 4c ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x0$26[ebp], 3
  005f3	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _cy4x0$25[ebp]
  005f9	8d 4c 02 02	 lea	 ecx, DWORD PTR [edx+eax+2]
  005fd	89 8d 34 ff ff
	ff		 mov	 DWORD PTR _cy3x0$20[ebp], ecx

; 647  :                     int cy1x1 = (cy0x1 * 1 + cy2x1 * 3 + 2);

  00603	6b 95 40 ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x1$23[ebp], 3
  0060a	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _cy0x1$24[ebp]
  00610	8d 4c 10 02	 lea	 ecx, DWORD PTR [eax+edx+2]
  00614	89 8d 30 ff ff
	ff		 mov	 DWORD PTR _cy1x1$19[ebp], ecx

; 648  :                     int cy3x1 = (cy2x1 * 3 + cy4x1 * 1 + 2);

  0061a	6b 95 40 ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x1$23[ebp], 3
  00621	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _cy4x1$22[ebp]
  00627	8d 4c 02 02	 lea	 ecx, DWORD PTR [edx+eax+2]
  0062b	89 8d 2c ff ff
	ff		 mov	 DWORD PTR _cy3x1$18[ebp], ecx

; 649  :                     CHANGE_BIT_DEPTH_4(cy1x0, cy3x0, cy1x1, cy3x1, 2);

  00631	33 d2		 xor	 edx, edx
  00633	74 3e		 je	 SHORT $LN37@convert_yv
  00635	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x0$21[ebp]
  0063b	c1 e0 f8	 shl	 eax, -8			; fffffff8H
  0063e	89 85 38 ff ff
	ff		 mov	 DWORD PTR _cy1x0$21[ebp], eax
  00644	8b 8d 34 ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x0$20[ebp]
  0064a	c1 e1 f8	 shl	 ecx, -8			; fffffff8H
  0064d	89 8d 34 ff ff
	ff		 mov	 DWORD PTR _cy3x0$20[ebp], ecx
  00653	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x1$19[ebp]
  00659	c1 e2 f8	 shl	 edx, -8			; fffffff8H
  0065c	89 95 30 ff ff
	ff		 mov	 DWORD PTR _cy1x1$19[ebp], edx
  00662	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR _cy3x1$18[ebp]
  00668	c1 e0 f8	 shl	 eax, -8			; fffffff8H
  0066b	89 85 2c ff ff
	ff		 mov	 DWORD PTR _cy3x1$18[ebp], eax
  00671	eb 45		 jmp	 SHORT $LN38@convert_yv
$LN37@convert_yv:
  00673	b9 01 00 00 00	 mov	 ecx, 1
  00678	85 c9		 test	 ecx, ecx
  0067a	74 3c		 je	 SHORT $LN38@convert_yv
  0067c	8b 95 38 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x0$21[ebp]
  00682	c1 fa 08	 sar	 edx, 8
  00685	89 95 38 ff ff
	ff		 mov	 DWORD PTR _cy1x0$21[ebp], edx
  0068b	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$20[ebp]
  00691	c1 f8 08	 sar	 eax, 8
  00694	89 85 34 ff ff
	ff		 mov	 DWORD PTR _cy3x0$20[ebp], eax
  0069a	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x1$19[ebp]
  006a0	c1 f9 08	 sar	 ecx, 8
  006a3	89 8d 30 ff ff
	ff		 mov	 DWORD PTR _cy1x1$19[ebp], ecx
  006a9	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR _cy3x1$18[ebp]
  006af	c1 fa 08	 sar	 edx, 8
  006b2	89 95 2c ff ff
	ff		 mov	 DWORD PTR _cy3x1$18[ebp], edx
$LN38@convert_yv:

; 650  : 
; 651  :                     dstC[0*dst_y_pitch   + 0] = (Tout)cy1x0;

  006b8	6b 45 e4 00	 imul	 eax, DWORD PTR _dst_y_pitch$[ebp], 0
  006bc	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$44[ebp]
  006bf	8a 95 38 ff ff
	ff		 mov	 dl, BYTE PTR _cy1x0$21[ebp]
  006c5	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 652  :                     dstC[0*dst_y_pitch   + 1] = (Tout)((cy1x0 + cy1x1 + 1) >> 1);

  006c8	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x1$19[ebp]
  006ce	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x0$21[ebp]
  006d4	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  006d8	d1 fa		 sar	 edx, 1
  006da	6b 45 e4 00	 imul	 eax, DWORD PTR _dst_y_pitch$[ebp], 0
  006de	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$44[ebp]
  006e1	88 54 01 01	 mov	 BYTE PTR [ecx+eax+1], dl

; 653  :                     dstC[1*dst_y_pitch   + 0] = (Tout)cy3x0;

  006e5	8b 55 94	 mov	 edx, DWORD PTR _dstC$44[ebp]
  006e8	03 55 e4	 add	 edx, DWORD PTR _dst_y_pitch$[ebp]
  006eb	8a 85 34 ff ff
	ff		 mov	 al, BYTE PTR _cy3x0$20[ebp]
  006f1	88 02		 mov	 BYTE PTR [edx], al

; 654  :                     dstC[1*dst_y_pitch   + 1] = (Tout)((cy3x0 + cy3x1 + 1) >> 1);

  006f3	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x1$18[ebp]
  006f9	8b 95 34 ff ff
	ff		 mov	 edx, DWORD PTR _cy3x0$20[ebp]
  006ff	8d 44 0a 01	 lea	 eax, DWORD PTR [edx+ecx+1]
  00703	d1 f8		 sar	 eax, 1
  00705	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$44[ebp]
  00708	03 4d e4	 add	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  0070b	88 41 01	 mov	 BYTE PTR [ecx+1], al

; 655  :                 }

  0070e	e9 ea fd ff ff	 jmp	 $LN17@convert_yv
$LN18@convert_yv:

; 656  :             } else {

  00713	e9 20 02 00 00	 jmp	 $LN31@convert_yv
$LN35@convert_yv:

; 657  :                 for (int x = 0; x < x_fin; x += 2, dstC += 2, srcP++) {

  00718	c7 85 28 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _x$17[ebp], 0
  00722	eb 21		 jmp	 SHORT $LN22@convert_yv
$LN20@convert_yv:
  00724	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR _x$17[ebp]
  0072a	83 c2 02	 add	 edx, 2
  0072d	89 95 28 ff ff
	ff		 mov	 DWORD PTR _x$17[ebp], edx
  00733	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  00736	83 c0 02	 add	 eax, 2
  00739	89 45 94	 mov	 DWORD PTR _dstC$44[ebp], eax
  0073c	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$43[ebp]
  0073f	83 c1 02	 add	 ecx, 2
  00742	89 4d 90	 mov	 DWORD PTR _srcP$43[ebp], ecx
$LN22@convert_yv:
  00745	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR _x$17[ebp]
  0074b	3b 55 8c	 cmp	 edx, DWORD PTR _x_fin$42[ebp]
  0074e	0f 8d e4 01 00
	00		 jge	 $LN31@convert_yv

; 658  :                     int cxplus = (x + 2 < x_fin);

  00754	8b 85 28 ff ff
	ff		 mov	 eax, DWORD PTR _x$17[ebp]
  0075a	83 c0 02	 add	 eax, 2
  0075d	3b 45 8c	 cmp	 eax, DWORD PTR _x_fin$42[ebp]
  00760	7d 0c		 jge	 SHORT $LN48@convert_yv
  00762	c7 85 d4 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv427[ebp], 1
  0076c	eb 0a		 jmp	 SHORT $LN49@convert_yv
$LN48@convert_yv:
  0076e	c7 85 d4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv427[ebp], 0
$LN49@convert_yv:
  00778	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR tv427[ebp]
  0077e	89 8d 24 ff ff
	ff		 mov	 DWORD PTR _cxplus$16[ebp], ecx

; 659  :                     int cy0x0 = srcP[-1*src_uv_pitch + 0];

  00784	6b 55 a8 ff	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], -1
  00788	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  0078b	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  0078f	89 8d 20 ff ff
	ff		 mov	 DWORD PTR _cy0x0$15[ebp], ecx

; 660  :                     int cy2x0 = srcP[ 0*src_uv_pitch + 0];

  00795	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  00799	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  0079c	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  007a0	89 8d 1c ff ff
	ff		 mov	 DWORD PTR _cy2x0$14[ebp], ecx

; 661  :                     int cy4x0 = srcP[ 1*src_uv_pitch + 0];

  007a6	8b 55 a8	 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  007a9	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  007ac	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  007b0	89 8d 18 ff ff
	ff		 mov	 DWORD PTR _cy4x0$13[ebp], ecx

; 662  :                     int cy0x1 = srcP[-1*src_uv_pitch + cxplus];

  007b6	6b 55 a8 ff	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], -1
  007ba	03 95 24 ff ff
	ff		 add	 edx, DWORD PTR _cxplus$16[ebp]
  007c0	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  007c3	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  007c7	89 8d 14 ff ff
	ff		 mov	 DWORD PTR _cy0x1$12[ebp], ecx

; 663  :                     int cy2x1 = srcP[ 0*src_uv_pitch + cxplus];

  007cd	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  007d1	03 95 24 ff ff
	ff		 add	 edx, DWORD PTR _cxplus$16[ebp]
  007d7	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  007da	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  007de	89 8d 10 ff ff
	ff		 mov	 DWORD PTR _cy2x1$11[ebp], ecx

; 664  :                     int cy4x1 = srcP[ 1*src_uv_pitch + cxplus];

  007e4	8b 95 24 ff ff
	ff		 mov	 edx, DWORD PTR _cxplus$16[ebp]
  007ea	03 55 a8	 add	 edx, DWORD PTR _src_uv_pitch$[ebp]
  007ed	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  007f0	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  007f4	89 8d 0c ff ff
	ff		 mov	 DWORD PTR _cy4x1$10[ebp], ecx

; 665  : 
; 666  :                     int cy1x0 = (cy0x0 * 1 + cy2x0 * 3 + 2);

  007fa	6b 95 1c ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x0$14[ebp], 3
  00801	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR _cy0x0$15[ebp]
  00807	8d 4c 10 02	 lea	 ecx, DWORD PTR [eax+edx+2]
  0080b	89 8d 08 ff ff
	ff		 mov	 DWORD PTR _cy1x0$9[ebp], ecx

; 667  :                     int cy3x0 = (cy2x0 * 3 + cy4x0 * 1 + 2);

  00811	6b 95 1c ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x0$14[ebp], 3
  00818	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _cy4x0$13[ebp]
  0081e	8d 4c 02 02	 lea	 ecx, DWORD PTR [edx+eax+2]
  00822	89 8d 04 ff ff
	ff		 mov	 DWORD PTR _cy3x0$8[ebp], ecx

; 668  :                     int cy1x1 = (cy0x1 * 1 + cy2x1 * 3 + 2);

  00828	6b 95 10 ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x1$11[ebp], 3
  0082f	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _cy0x1$12[ebp]
  00835	8d 4c 10 02	 lea	 ecx, DWORD PTR [eax+edx+2]
  00839	89 8d 00 ff ff
	ff		 mov	 DWORD PTR _cy1x1$7[ebp], ecx

; 669  :                     int cy3x1 = (cy2x1 * 3 + cy4x1 * 1 + 2);

  0083f	6b 95 10 ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x1$11[ebp], 3
  00846	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _cy4x1$10[ebp]
  0084c	8d 4c 02 02	 lea	 ecx, DWORD PTR [edx+eax+2]
  00850	89 8d fc fe ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], ecx

; 670  :                     CHANGE_BIT_DEPTH_4(cy1x0, cy3x0, cy1x1, cy3x1, 2);

  00856	33 d2		 xor	 edx, edx
  00858	74 3e		 je	 SHORT $LN40@convert_yv
  0085a	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x0$9[ebp]
  00860	c1 e0 f8	 shl	 eax, -8			; fffffff8H
  00863	89 85 08 ff ff
	ff		 mov	 DWORD PTR _cy1x0$9[ebp], eax
  00869	8b 8d 04 ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x0$8[ebp]
  0086f	c1 e1 f8	 shl	 ecx, -8			; fffffff8H
  00872	89 8d 04 ff ff
	ff		 mov	 DWORD PTR _cy3x0$8[ebp], ecx
  00878	8b 95 00 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x1$7[ebp]
  0087e	c1 e2 f8	 shl	 edx, -8			; fffffff8H
  00881	89 95 00 ff ff
	ff		 mov	 DWORD PTR _cy1x1$7[ebp], edx
  00887	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR _cy3x1$6[ebp]
  0088d	c1 e0 f8	 shl	 eax, -8			; fffffff8H
  00890	89 85 fc fe ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], eax
  00896	eb 45		 jmp	 SHORT $LN41@convert_yv
$LN40@convert_yv:
  00898	b9 01 00 00 00	 mov	 ecx, 1
  0089d	85 c9		 test	 ecx, ecx
  0089f	74 3c		 je	 SHORT $LN41@convert_yv
  008a1	8b 95 08 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x0$9[ebp]
  008a7	c1 fa 08	 sar	 edx, 8
  008aa	89 95 08 ff ff
	ff		 mov	 DWORD PTR _cy1x0$9[ebp], edx
  008b0	8b 85 04 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$8[ebp]
  008b6	c1 f8 08	 sar	 eax, 8
  008b9	89 85 04 ff ff
	ff		 mov	 DWORD PTR _cy3x0$8[ebp], eax
  008bf	8b 8d 00 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x1$7[ebp]
  008c5	c1 f9 08	 sar	 ecx, 8
  008c8	89 8d 00 ff ff
	ff		 mov	 DWORD PTR _cy1x1$7[ebp], ecx
  008ce	8b 95 fc fe ff
	ff		 mov	 edx, DWORD PTR _cy3x1$6[ebp]
  008d4	c1 fa 08	 sar	 edx, 8
  008d7	89 95 fc fe ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], edx
$LN41@convert_yv:

; 671  : 
; 672  :                     dstC[0*dst_y_pitch   + 0] = (Tout)cy1x0;

  008dd	6b 45 e4 00	 imul	 eax, DWORD PTR _dst_y_pitch$[ebp], 0
  008e1	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$44[ebp]
  008e4	8a 95 08 ff ff
	ff		 mov	 dl, BYTE PTR _cy1x0$9[ebp]
  008ea	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 673  :                     dstC[0*dst_y_pitch   + 1] = (Tout)((cy1x0 + cy1x1 + 1) >> 1);

  008ed	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x1$7[ebp]
  008f3	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x0$9[ebp]
  008f9	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  008fd	d1 fa		 sar	 edx, 1
  008ff	6b 45 e4 00	 imul	 eax, DWORD PTR _dst_y_pitch$[ebp], 0
  00903	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$44[ebp]
  00906	88 54 01 01	 mov	 BYTE PTR [ecx+eax+1], dl

; 674  :                     dstC[1*dst_y_pitch   + 0] = (Tout)cy3x0;

  0090a	8b 55 94	 mov	 edx, DWORD PTR _dstC$44[ebp]
  0090d	03 55 e4	 add	 edx, DWORD PTR _dst_y_pitch$[ebp]
  00910	8a 85 04 ff ff
	ff		 mov	 al, BYTE PTR _cy3x0$8[ebp]
  00916	88 02		 mov	 BYTE PTR [edx], al

; 675  :                     dstC[1*dst_y_pitch   + 1] = (Tout)((cy3x0 + cy3x1 + 1) >> 1);

  00918	8b 8d fc fe ff
	ff		 mov	 ecx, DWORD PTR _cy3x1$6[ebp]
  0091e	8b 95 04 ff ff
	ff		 mov	 edx, DWORD PTR _cy3x0$8[ebp]
  00924	8d 44 0a 01	 lea	 eax, DWORD PTR [edx+ecx+1]
  00928	d1 f8		 sar	 eax, 1
  0092a	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$44[ebp]
  0092d	03 4d e4	 add	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  00930	88 41 01	 mov	 BYTE PTR [ecx+1], al

; 676  :                 }

  00933	e9 ec fd ff ff	 jmp	 $LN20@convert_yv
$LN31@convert_yv:

; 677  :             }
; 678  :         }

  00938	e9 52 f9 ff ff	 jmp	 $LN11@convert_yv
$LN12@convert_yv:

; 679  :     }

  0093d	e9 03 f9 ff ff	 jmp	 $LN8@convert_yv
$LN1@convert_yv:

; 680  : }

  00942	52		 push	 edx
  00943	8b cd		 mov	 ecx, ebp
  00945	50		 push	 eax
  00946	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN52@convert_yv
  0094c	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00951	58		 pop	 eax
  00952	5a		 pop	 edx
  00953	5f		 pop	 edi
  00954	5b		 pop	 ebx
  00955	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00958	33 cd		 xor	 ecx, ebp
  0095a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0095f	81 c4 2c 01 00
	00		 add	 esp, 300		; 0000012cH
  00965	3b ec		 cmp	 ebp, esp
  00967	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0096c	8b e5		 mov	 esp, ebp
  0096e	5d		 pop	 ebp
  0096f	c3		 ret	 0
$LN52@convert_yv:
  00970	01 00 00 00	 DD	 1
  00974	00 00 00 00	 DD	 $LN51@convert_yv
$LN51@convert_yv:
  00978	d4 ff ff ff	 DD	 -44			; ffffffd4H
  0097c	0c 00 00 00	 DD	 12			; 0000000cH
  00980	00 00 00 00	 DD	 $LN50@convert_yv
$LN50@convert_yv:
  00984	79		 DB	 121			; 00000079H
  00985	5f		 DB	 95			; 0000005fH
  00986	72		 DB	 114			; 00000072H
  00987	61		 DB	 97			; 00000061H
  00988	6e		 DB	 110			; 0000006eH
  00989	67		 DB	 103			; 00000067H
  0098a	65		 DB	 101			; 00000065H
  0098b	00		 DB	 0
??$convert_yv12_p_to_yuv444_c@G$0O@E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_p_to_yuv444_c<unsigned short,14,unsigned char,8,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yv12_14_p_to_yuv444@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_14_p_to_yuv444

; 801  : static void convert_yv12_14_p_to_yuv444(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 802  :     convert_yv12_p_to_yuv444_c<uint16_t, 14, uint8_t, 8, false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yv12_p_to_yuv444_c@G$0O@E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_p_to_yuv444_c<unsigned short,14,unsigned char,8,0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 803  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yv12_14_p_to_yuv444@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_14_p_to_yuv444
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
tv297 = -280						; size = 4
tv235 = -276						; size = 4
tv236 = -272						; size = 4
tv230 = -268						; size = 4
tv227 = -264						; size = 4
tv224 = -260						; size = 4
tv222 = -256						; size = 4
$T1 = -252						; size = 4
$T2 = -248						; size = 4
$T3 = -244						; size = 4
$T4 = -240						; size = 4
$T5 = -236						; size = 12
_cy3x1$6 = -224						; size = 4
_cy2x1$7 = -220						; size = 4
_cy1x1$8 = -216						; size = 4
_cy0x1$9 = -212						; size = 4
_sy5x1$10 = -208					; size = 4
_sy4x1$11 = -204					; size = 4
_sy3x1$12 = -200					; size = 4
_sy2x1$13 = -196					; size = 4
_sy1x1$14 = -192					; size = 4
_sy0x1$15 = -188					; size = 4
_cxplus$16 = -184					; size = 4
_x$17 = -180						; size = 4
_cy3x0$18 = -176					; size = 4
_cy2x0$19 = -172					; size = 4
_cy1x0$20 = -168					; size = 4
_cy0x0$21 = -164					; size = 4
_sy5x0$22 = -160					; size = 4
_sy4x0$23 = -156					; size = 4
_sy3x0$24 = -152					; size = 4
_sy2x0$25 = -148					; size = 4
_sy1x0$26 = -144					; size = 4
_sy0x0$27 = -140					; size = 4
_y_p3$28 = -136						; size = 4
_y_p2$29 = -132						; size = 4
_y_p1$30 = -128						; size = 4
_y_m1$31 = -124						; size = 4
_y_m2$32 = -120						; size = 4
_x_fin$33 = -116					; size = 4
_srcP$34 = -112						; size = 4
_dstC$35 = -108						; size = 4
_y$36 = -104						; size = 4
_dstLine$37 = -100					; size = 4
_srcCLine$38 = -96					; size = 4
_ic$39 = -92						; size = 4
_src_uv_pitch$ = -88					; size = 4
_uv_fin$ = -84						; size = 4
_x$40 = -80						; size = 4
_y$41 = -76						; size = 4
_y_width$42 = -72					; size = 4
_dstLine$43 = -68					; size = 4
_srcYLine$44 = -64					; size = 4
$T45 = -60						; size = 12
_y_range$ = -44						; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yv12_i_to_yuv444_c@G$0BA@E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_i_to_yuv444_c<unsigned short,16,unsigned char,8,0>

; 683  : static void __forceinline convert_yv12_i_to_yuv444_c(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  00009	53		 push	 ebx
  0000a	57		 push	 edi
  0000b	8d bd e8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-280]
  00011	b9 46 00 00 00	 mov	 ecx, 70			; 00000046H
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 684  :     static_assert((sizeof(Tin)  == 1 && in_bit_depth  == 8) || (sizeof(Tin)  == 2 && 8 < in_bit_depth  && in_bit_depth  <= 16), "invalid input bit depth.");
; 685  :     static_assert((sizeof(Tout) == 1 && out_bit_depth == 8) || (sizeof(Tout) == 2 && 8 < out_bit_depth && out_bit_depth <= 16), "invalid output bit depth.");
; 686  :     const int crop_left   = crop[0];

  00027	b8 04 00 00 00	 mov	 eax, 4
  0002c	6b c8 00	 imul	 ecx, eax, 0
  0002f	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00032	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00035	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 687  :     const int crop_up     = crop[1];

  00038	b9 04 00 00 00	 mov	 ecx, 4
  0003d	c1 e1 00	 shl	 ecx, 0
  00040	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00043	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00046	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 688  :     const int crop_right  = crop[2];

  00049	b9 04 00 00 00	 mov	 ecx, 4
  0004e	d1 e1		 shl	 ecx, 1
  00050	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00053	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00056	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 689  :     const int crop_bottom = crop[3];

  00059	b9 04 00 00 00	 mov	 ecx, 4
  0005e	6b d1 03	 imul	 edx, ecx, 3
  00061	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00064	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00067	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 690  :     const int src_y_pitch = src_y_pitch_byte / sizeof(Tin);

  0006a	8b 55 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebp]
  0006d	d1 ea		 shr	 edx, 1
  0006f	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 691  :     const int dst_y_pitch = dst_y_pitch_byte / sizeof(Tout);

  00072	8b 45 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  00075	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 692  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00078	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0007b	51		 push	 ecx
  0007c	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0007f	52		 push	 edx
  00080	8b 45 20	 mov	 eax, DWORD PTR _height$[ebp]
  00083	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  00086	50		 push	 eax
  00087	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  0008a	51		 push	 ecx
  0008b	8d 95 14 ff ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  00091	52		 push	 edx
  00092	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00097	83 c4 14	 add	 esp, 20			; 00000014H
  0009a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009c	89 4d c4	 mov	 DWORD PTR $T45[ebp], ecx
  0009f	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a2	89 55 c8	 mov	 DWORD PTR $T45[ebp+4], edx
  000a5	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000a8	89 45 cc	 mov	 DWORD PTR $T45[ebp+8], eax
  000ab	8b 4d c4	 mov	 ecx, DWORD PTR $T45[ebp]
  000ae	89 4d d4	 mov	 DWORD PTR _y_range$[ebp], ecx
  000b1	8b 55 c8	 mov	 edx, DWORD PTR $T45[ebp+4]
  000b4	89 55 d8	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000b7	8b 45 cc	 mov	 eax, DWORD PTR $T45[ebp+8]
  000ba	89 45 dc	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 693  :     //Y
; 694  :     if (!uv_only) {

  000bd	b9 01 00 00 00	 mov	 ecx, 1
  000c2	85 c9		 test	 ecx, ecx
  000c4	0f 84 61 01 00
	00		 je	 $LN17@convert_yv

; 695  :         Tin *srcYLine = (Tin *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000ca	ba 04 00 00 00	 mov	 edx, 4
  000cf	6b c2 00	 imul	 eax, edx, 0
  000d2	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  000d5	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  000d9	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  000dc	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  000df	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  000e2	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  000e5	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  000e8	89 45 c0	 mov	 DWORD PTR _srcYLine$44[ebp], eax

; 696  :         Tout *dstLine = (Tout *)dst[0] + dst_y_pitch * y_range.start_dst;

  000eb	b9 04 00 00 00	 mov	 ecx, 4
  000f0	6b d1 00	 imul	 edx, ecx, 0
  000f3	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  000f6	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  000fa	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  000fd	03 04 11	 add	 eax, DWORD PTR [ecx+edx]
  00100	89 45 bc	 mov	 DWORD PTR _dstLine$43[ebp], eax

; 697  :         const int y_width = width - crop_right - crop_left;

  00103	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00106	2b 55 f0	 sub	 edx, DWORD PTR _crop_right$[ebp]
  00109	2b 55 f8	 sub	 edx, DWORD PTR _crop_left$[ebp]
  0010c	89 55 b8	 mov	 DWORD PTR _y_width$42[ebp], edx

; 698  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  0010f	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _y$41[ebp], 0
  00116	eb 1e		 jmp	 SHORT $LN4@convert_yv
$LN2@convert_yv:
  00118	8b 45 b4	 mov	 eax, DWORD PTR _y$41[ebp]
  0011b	83 c0 01	 add	 eax, 1
  0011e	89 45 b4	 mov	 DWORD PTR _y$41[ebp], eax
  00121	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  00124	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$44[ebp]
  00127	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  0012a	89 45 c0	 mov	 DWORD PTR _srcYLine$44[ebp], eax
  0012d	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$43[ebp]
  00130	03 4d e4	 add	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  00133	89 4d bc	 mov	 DWORD PTR _dstLine$43[ebp], ecx
$LN4@convert_yv:
  00136	8b 55 b4	 mov	 edx, DWORD PTR _y$41[ebp]
  00139	3b 55 dc	 cmp	 edx, DWORD PTR _y_range$[ebp+8]
  0013c	0f 8d e9 00 00
	00		 jge	 $LN17@convert_yv

; 699  :             if (in_bit_depth == out_bit_depth) {

  00142	33 c0		 xor	 eax, eax
  00144	74 1b		 je	 SHORT $LN18@convert_yv

; 700  :                 memcpy(dstLine, srcYLine, y_width * sizeof(Tin));

  00146	8b 4d b8	 mov	 ecx, DWORD PTR _y_width$42[ebp]
  00149	d1 e1		 shl	 ecx, 1
  0014b	51		 push	 ecx
  0014c	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$44[ebp]
  0014f	52		 push	 edx
  00150	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$43[ebp]
  00153	50		 push	 eax
  00154	e8 00 00 00 00	 call	 _memcpy
  00159	83 c4 0c	 add	 esp, 12			; 0000000cH

; 701  :             } else {

  0015c	e9 c5 00 00 00	 jmp	 $LN19@convert_yv
$LN18@convert_yv:

; 702  :                 for (int x = 0; x < y_width; x++) {

  00161	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _x$40[ebp], 0
  00168	eb 09		 jmp	 SHORT $LN7@convert_yv
$LN5@convert_yv:
  0016a	8b 4d b0	 mov	 ecx, DWORD PTR _x$40[ebp]
  0016d	83 c1 01	 add	 ecx, 1
  00170	89 4d b0	 mov	 DWORD PTR _x$40[ebp], ecx
$LN7@convert_yv:
  00173	8b 55 b0	 mov	 edx, DWORD PTR _x$40[ebp]
  00176	3b 55 b8	 cmp	 edx, DWORD PTR _y_width$42[ebp]
  00179	0f 8d a7 00 00
	00		 jge	 $LN19@convert_yv

; 703  :                     if (out_bit_depth > in_bit_depth) {

  0017f	33 c0		 xor	 eax, eax
  00181	74 42		 je	 SHORT $LN20@convert_yv

; 704  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) << std::max(out_bit_depth - in_bit_depth, 0));

  00183	c7 85 10 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], 0
  0018d	c7 85 0c ff ff
	ff f8 ff ff ff	 mov	 DWORD PTR $T3[ebp], -8	; fffffff8H
  00197	8b 4d b0	 mov	 ecx, DWORD PTR _x$40[ebp]
  0019a	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$44[ebp]
  0019d	0f b7 1c 4a	 movzx	 ebx, WORD PTR [edx+ecx*2]
  001a1	8d 85 10 ff ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  001a7	50		 push	 eax
  001a8	8d 8d 0c ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  001ae	51		 push	 ecx
  001af	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  001b4	83 c4 08	 add	 esp, 8
  001b7	8b 08		 mov	 ecx, DWORD PTR [eax]
  001b9	d3 e3		 shl	 ebx, cl
  001bb	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$43[ebp]
  001be	03 55 b0	 add	 edx, DWORD PTR _x$40[ebp]
  001c1	88 1a		 mov	 BYTE PTR [edx], bl
  001c3	eb 5c		 jmp	 SHORT $LN21@convert_yv
$LN20@convert_yv:

; 705  :                     } else if (out_bit_depth < in_bit_depth) {

  001c5	b8 01 00 00 00	 mov	 eax, 1
  001ca	85 c0		 test	 eax, eax
  001cc	74 42		 je	 SHORT $LN22@convert_yv

; 706  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) >> std::max(in_bit_depth - out_bit_depth, 0));

  001ce	c7 85 08 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], 0
  001d8	c7 85 04 ff ff
	ff 08 00 00 00	 mov	 DWORD PTR $T1[ebp], 8
  001e2	8b 4d b0	 mov	 ecx, DWORD PTR _x$40[ebp]
  001e5	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$44[ebp]
  001e8	0f b7 1c 4a	 movzx	 ebx, WORD PTR [edx+ecx*2]
  001ec	8d 85 08 ff ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  001f2	50		 push	 eax
  001f3	8d 8d 04 ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  001f9	51		 push	 ecx
  001fa	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  001ff	83 c4 08	 add	 esp, 8
  00202	8b 08		 mov	 ecx, DWORD PTR [eax]
  00204	d3 fb		 sar	 ebx, cl
  00206	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$43[ebp]
  00209	03 55 b0	 add	 edx, DWORD PTR _x$40[ebp]
  0020c	88 1a		 mov	 BYTE PTR [edx], bl

; 707  :                     } else {

  0020e	eb 11		 jmp	 SHORT $LN21@convert_yv
$LN22@convert_yv:

; 708  :                         dstLine[x] = (Tout)srcYLine[x];

  00210	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$43[ebp]
  00213	03 45 b0	 add	 eax, DWORD PTR _x$40[ebp]
  00216	8b 4d b0	 mov	 ecx, DWORD PTR _x$40[ebp]
  00219	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$44[ebp]
  0021c	8a 0c 4a	 mov	 cl, BYTE PTR [edx+ecx*2]
  0021f	88 08		 mov	 BYTE PTR [eax], cl
$LN21@convert_yv:

; 709  :                     }
; 710  :                 }

  00221	e9 44 ff ff ff	 jmp	 $LN5@convert_yv
$LN19@convert_yv:

; 711  :             }
; 712  :         }

  00226	e9 ed fe ff ff	 jmp	 $LN2@convert_yv
$LN17@convert_yv:

; 713  :     }
; 714  :     //UV
; 715  :     const int uv_fin = height - crop_bottom;

  0022b	8b 55 20	 mov	 edx, DWORD PTR _height$[ebp]
  0022e	2b 55 ec	 sub	 edx, DWORD PTR _crop_bottom$[ebp]
  00231	89 55 ac	 mov	 DWORD PTR _uv_fin$[ebp], edx

; 716  :     const int src_uv_pitch = src_uv_pitch_byte / sizeof(Tin);

  00234	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  00237	d1 e8		 shr	 eax, 1
  00239	89 45 a8	 mov	 DWORD PTR _src_uv_pitch$[ebp], eax

; 717  :     for (int ic = 1; ic < 3; ic++) {

  0023c	c7 45 a4 01 00
	00 00		 mov	 DWORD PTR _ic$39[ebp], 1
  00243	eb 09		 jmp	 SHORT $LN10@convert_yv
$LN8@convert_yv:
  00245	8b 4d a4	 mov	 ecx, DWORD PTR _ic$39[ebp]
  00248	83 c1 01	 add	 ecx, 1
  0024b	89 4d a4	 mov	 DWORD PTR _ic$39[ebp], ecx
$LN10@convert_yv:
  0024e	83 7d a4 03	 cmp	 DWORD PTR _ic$39[ebp], 3
  00252	0f 8d ac 05 00
	00		 jge	 $LN1@convert_yv

; 718  :         Tin *srcCLine = (Tin *)src[ic] + (((src_uv_pitch * y_range.start_src) + crop_left) >> 1);

  00258	8b 55 a8	 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  0025b	0f af 55 d4	 imul	 edx, DWORD PTR _y_range$[ebp]
  0025f	03 55 f8	 add	 edx, DWORD PTR _crop_left$[ebp]
  00262	d1 fa		 sar	 edx, 1
  00264	8b 45 a4	 mov	 eax, DWORD PTR _ic$39[ebp]
  00267	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  0026a	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  0026d	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00270	89 4d a0	 mov	 DWORD PTR _srcCLine$38[ebp], ecx

; 719  :         Tout *dstLine = (Tout *)dst[ic] + dst_y_pitch * y_range.start_dst;

  00273	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  00276	0f af 55 d8	 imul	 edx, DWORD PTR _y_range$[ebp+4]
  0027a	8b 45 a4	 mov	 eax, DWORD PTR _ic$39[ebp]
  0027d	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  00280	03 14 81	 add	 edx, DWORD PTR [ecx+eax*4]
  00283	89 55 9c	 mov	 DWORD PTR _dstLine$37[ebp], edx

; 720  :         for (int y = 0; y < y_range.len; y += 4, srcCLine += src_uv_pitch * 2, dstLine += dst_y_pitch * 4) {

  00286	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _y$36[ebp], 0
  0028d	eb 23		 jmp	 SHORT $LN13@convert_yv
$LN11@convert_yv:
  0028f	8b 55 98	 mov	 edx, DWORD PTR _y$36[ebp]
  00292	83 c2 04	 add	 edx, 4
  00295	89 55 98	 mov	 DWORD PTR _y$36[ebp], edx
  00298	8b 45 a8	 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  0029b	d1 e0		 shl	 eax, 1
  0029d	8b 4d a0	 mov	 ecx, DWORD PTR _srcCLine$38[ebp]
  002a0	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  002a3	89 55 a0	 mov	 DWORD PTR _srcCLine$38[ebp], edx
  002a6	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  002a9	8b 4d 9c	 mov	 ecx, DWORD PTR _dstLine$37[ebp]
  002ac	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  002af	89 55 9c	 mov	 DWORD PTR _dstLine$37[ebp], edx
$LN13@convert_yv:
  002b2	8b 45 98	 mov	 eax, DWORD PTR _y$36[ebp]
  002b5	3b 45 dc	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  002b8	0f 8d 41 05 00
	00		 jge	 $LN12@convert_yv

; 721  :             Tout *dstC = dstLine;

  002be	8b 4d 9c	 mov	 ecx, DWORD PTR _dstLine$37[ebp]
  002c1	89 4d 94	 mov	 DWORD PTR _dstC$35[ebp], ecx

; 722  :             Tin *srcP = srcCLine;

  002c4	8b 55 a0	 mov	 edx, DWORD PTR _srcCLine$38[ebp]
  002c7	89 55 90	 mov	 DWORD PTR _srcP$34[ebp], edx

; 723  :             const int x_fin = width - crop_right - crop_left;

  002ca	8b 45 10	 mov	 eax, DWORD PTR _width$[ebp]
  002cd	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  002d0	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  002d3	89 45 8c	 mov	 DWORD PTR _x_fin$33[ebp], eax

; 724  : 
; 725  :             int y_m2 = (y >= 4) ? -2 : 0;

  002d6	83 7d 98 04	 cmp	 DWORD PTR _y$36[ebp], 4
  002da	7c 0c		 jl	 SHORT $LN31@convert_yv
  002dc	c7 85 00 ff ff
	ff fe ff ff ff	 mov	 DWORD PTR tv222[ebp], -2 ; fffffffeH
  002e6	eb 0a		 jmp	 SHORT $LN32@convert_yv
$LN31@convert_yv:
  002e8	c7 85 00 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv222[ebp], 0
$LN32@convert_yv:
  002f2	8b 8d 00 ff ff
	ff		 mov	 ecx, DWORD PTR tv222[ebp]
  002f8	89 4d 88	 mov	 DWORD PTR _y_m2$32[ebp], ecx

; 726  :             int y_m1 = (y >= 2) ? -1 : 1;

  002fb	83 7d 98 02	 cmp	 DWORD PTR _y$36[ebp], 2
  002ff	7c 0c		 jl	 SHORT $LN33@convert_yv
  00301	c7 85 fc fe ff
	ff ff ff ff ff	 mov	 DWORD PTR tv224[ebp], -1
  0030b	eb 0a		 jmp	 SHORT $LN34@convert_yv
$LN33@convert_yv:
  0030d	c7 85 fc fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv224[ebp], 1
$LN34@convert_yv:
  00317	8b 95 fc fe ff
	ff		 mov	 edx, DWORD PTR tv224[ebp]
  0031d	89 55 84	 mov	 DWORD PTR _y_m1$31[ebp], edx

; 727  :             int y_p1 = (y < uv_fin - 2) ? 1 : -1;

  00320	8b 45 ac	 mov	 eax, DWORD PTR _uv_fin$[ebp]
  00323	83 e8 02	 sub	 eax, 2
  00326	39 45 98	 cmp	 DWORD PTR _y$36[ebp], eax
  00329	7d 0c		 jge	 SHORT $LN35@convert_yv
  0032b	c7 85 f8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv227[ebp], 1
  00335	eb 0a		 jmp	 SHORT $LN36@convert_yv
$LN35@convert_yv:
  00337	c7 85 f8 fe ff
	ff ff ff ff ff	 mov	 DWORD PTR tv227[ebp], -1
$LN36@convert_yv:
  00341	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR tv227[ebp]
  00347	89 4d 80	 mov	 DWORD PTR _y_p1$30[ebp], ecx

; 728  :             int y_p2 = (y < uv_fin - 4) ? 2 :  0;

  0034a	8b 55 ac	 mov	 edx, DWORD PTR _uv_fin$[ebp]
  0034d	83 ea 04	 sub	 edx, 4
  00350	39 55 98	 cmp	 DWORD PTR _y$36[ebp], edx
  00353	7d 0c		 jge	 SHORT $LN37@convert_yv
  00355	c7 85 f4 fe ff
	ff 02 00 00 00	 mov	 DWORD PTR tv230[ebp], 2
  0035f	eb 0a		 jmp	 SHORT $LN38@convert_yv
$LN37@convert_yv:
  00361	c7 85 f4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv230[ebp], 0
$LN38@convert_yv:
  0036b	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR tv230[ebp]
  00371	89 85 7c ff ff
	ff		 mov	 DWORD PTR _y_p2$29[ebp], eax

; 729  :             int y_p3 = (y < uv_fin - 6) ? 3 : ((y < uv_fin - 2) ? 1 : -1);

  00377	8b 4d ac	 mov	 ecx, DWORD PTR _uv_fin$[ebp]
  0037a	83 e9 06	 sub	 ecx, 6
  0037d	39 4d 98	 cmp	 DWORD PTR _y$36[ebp], ecx
  00380	7d 0c		 jge	 SHORT $LN41@convert_yv
  00382	c7 85 f0 fe ff
	ff 03 00 00 00	 mov	 DWORD PTR tv236[ebp], 3
  0038c	eb 2d		 jmp	 SHORT $LN42@convert_yv
$LN41@convert_yv:
  0038e	8b 55 ac	 mov	 edx, DWORD PTR _uv_fin$[ebp]
  00391	83 ea 02	 sub	 edx, 2
  00394	39 55 98	 cmp	 DWORD PTR _y$36[ebp], edx
  00397	7d 0c		 jge	 SHORT $LN39@convert_yv
  00399	c7 85 ec fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv235[ebp], 1
  003a3	eb 0a		 jmp	 SHORT $LN40@convert_yv
$LN39@convert_yv:
  003a5	c7 85 ec fe ff
	ff ff ff ff ff	 mov	 DWORD PTR tv235[ebp], -1
$LN40@convert_yv:
  003af	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR tv235[ebp]
  003b5	89 85 f0 fe ff
	ff		 mov	 DWORD PTR tv236[ebp], eax
$LN42@convert_yv:
  003bb	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR tv236[ebp]
  003c1	89 8d 78 ff ff
	ff		 mov	 DWORD PTR _y_p3$28[ebp], ecx

; 730  : 
; 731  :             int sy0x0 = srcP[y_m2*src_uv_pitch + 0];

  003c7	8b 55 88	 mov	 edx, DWORD PTR _y_m2$32[ebp]
  003ca	0f af 55 a8	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp]
  003ce	8b 45 90	 mov	 eax, DWORD PTR _srcP$34[ebp]
  003d1	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  003d5	89 8d 74 ff ff
	ff		 mov	 DWORD PTR _sy0x0$27[ebp], ecx

; 732  :             int sy1x0 = srcP[y_m1*src_uv_pitch + 0];

  003db	8b 55 84	 mov	 edx, DWORD PTR _y_m1$31[ebp]
  003de	0f af 55 a8	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp]
  003e2	8b 45 90	 mov	 eax, DWORD PTR _srcP$34[ebp]
  003e5	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  003e9	89 8d 70 ff ff
	ff		 mov	 DWORD PTR _sy1x0$26[ebp], ecx

; 733  :             int sy2x0 = srcP[   0*src_uv_pitch + 0];

  003ef	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  003f3	8b 45 90	 mov	 eax, DWORD PTR _srcP$34[ebp]
  003f6	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  003fa	89 8d 6c ff ff
	ff		 mov	 DWORD PTR _sy2x0$25[ebp], ecx

; 734  :             int sy3x0 = srcP[y_p1*src_uv_pitch + 0];

  00400	8b 55 80	 mov	 edx, DWORD PTR _y_p1$30[ebp]
  00403	0f af 55 a8	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp]
  00407	8b 45 90	 mov	 eax, DWORD PTR _srcP$34[ebp]
  0040a	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  0040e	89 8d 68 ff ff
	ff		 mov	 DWORD PTR _sy3x0$24[ebp], ecx

; 735  :             int sy4x0 = srcP[y_p2*src_uv_pitch + 0];

  00414	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR _y_p2$29[ebp]
  0041a	0f af 55 a8	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp]
  0041e	8b 45 90	 mov	 eax, DWORD PTR _srcP$34[ebp]
  00421	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  00425	89 8d 64 ff ff
	ff		 mov	 DWORD PTR _sy4x0$23[ebp], ecx

; 736  :             int sy5x0 = srcP[y_p3*src_uv_pitch + 0];

  0042b	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _y_p3$28[ebp]
  00431	0f af 55 a8	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp]
  00435	8b 45 90	 mov	 eax, DWORD PTR _srcP$34[ebp]
  00438	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  0043c	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _sy5x0$22[ebp], ecx

; 737  : 
; 738  :             int cy0x0 = (sy0x0 * 1 + sy2x0 * 7 + 4);

  00442	6b 95 6c ff ff
	ff 07		 imul	 edx, DWORD PTR _sy2x0$25[ebp], 7
  00449	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _sy0x0$27[ebp]
  0044f	8d 4c 10 04	 lea	 ecx, DWORD PTR [eax+edx+4]
  00453	89 8d 5c ff ff
	ff		 mov	 DWORD PTR _cy0x0$21[ebp], ecx

; 739  :             int cy1x0 = (sy1x0 * 3 + sy3x0 * 5 + 4);

  00459	6b 95 70 ff ff
	ff 03		 imul	 edx, DWORD PTR _sy1x0$26[ebp], 3
  00460	6b 85 68 ff ff
	ff 05		 imul	 eax, DWORD PTR _sy3x0$24[ebp], 5
  00467	8d 4c 02 04	 lea	 ecx, DWORD PTR [edx+eax+4]
  0046b	89 8d 58 ff ff
	ff		 mov	 DWORD PTR _cy1x0$20[ebp], ecx

; 740  :             int cy2x0 = (sy2x0 * 5 + sy4x0 * 3 + 4);

  00471	6b 95 6c ff ff
	ff 05		 imul	 edx, DWORD PTR _sy2x0$25[ebp], 5
  00478	6b 85 64 ff ff
	ff 03		 imul	 eax, DWORD PTR _sy4x0$23[ebp], 3
  0047f	8d 4c 02 04	 lea	 ecx, DWORD PTR [edx+eax+4]
  00483	89 8d 54 ff ff
	ff		 mov	 DWORD PTR _cy2x0$19[ebp], ecx

; 741  :             int cy3x0 = (sy3x0 * 7 + sy5x0 * 1 + 4);

  00489	6b 95 68 ff ff
	ff 07		 imul	 edx, DWORD PTR _sy3x0$24[ebp], 7
  00490	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _sy5x0$22[ebp]
  00496	8d 4c 02 04	 lea	 ecx, DWORD PTR [edx+eax+4]
  0049a	89 8d 50 ff ff
	ff		 mov	 DWORD PTR _cy3x0$18[ebp], ecx

; 742  :             CHANGE_BIT_DEPTH_4(cy0x0, cy1x0, cy2x0, cy3x0, 3);

  004a0	33 d2		 xor	 edx, edx
  004a2	74 3e		 je	 SHORT $LN24@convert_yv
  004a4	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _cy0x0$21[ebp]
  004aa	c1 e0 f5	 shl	 eax, -11		; fffffff5H
  004ad	89 85 5c ff ff
	ff		 mov	 DWORD PTR _cy0x0$21[ebp], eax
  004b3	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x0$20[ebp]
  004b9	c1 e1 f5	 shl	 ecx, -11		; fffffff5H
  004bc	89 8d 58 ff ff
	ff		 mov	 DWORD PTR _cy1x0$20[ebp], ecx
  004c2	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR _cy2x0$19[ebp]
  004c8	c1 e2 f5	 shl	 edx, -11		; fffffff5H
  004cb	89 95 54 ff ff
	ff		 mov	 DWORD PTR _cy2x0$19[ebp], edx
  004d1	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$18[ebp]
  004d7	c1 e0 f5	 shl	 eax, -11		; fffffff5H
  004da	89 85 50 ff ff
	ff		 mov	 DWORD PTR _cy3x0$18[ebp], eax
  004e0	eb 45		 jmp	 SHORT $LN25@convert_yv
$LN24@convert_yv:
  004e2	b9 01 00 00 00	 mov	 ecx, 1
  004e7	85 c9		 test	 ecx, ecx
  004e9	74 3c		 je	 SHORT $LN25@convert_yv
  004eb	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR _cy0x0$21[ebp]
  004f1	c1 fa 0b	 sar	 edx, 11			; 0000000bH
  004f4	89 95 5c ff ff
	ff		 mov	 DWORD PTR _cy0x0$21[ebp], edx
  004fa	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x0$20[ebp]
  00500	c1 f8 0b	 sar	 eax, 11			; 0000000bH
  00503	89 85 58 ff ff
	ff		 mov	 DWORD PTR _cy1x0$20[ebp], eax
  00509	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _cy2x0$19[ebp]
  0050f	c1 f9 0b	 sar	 ecx, 11			; 0000000bH
  00512	89 8d 54 ff ff
	ff		 mov	 DWORD PTR _cy2x0$19[ebp], ecx
  00518	8b 95 50 ff ff
	ff		 mov	 edx, DWORD PTR _cy3x0$18[ebp]
  0051e	c1 fa 0b	 sar	 edx, 11			; 0000000bH
  00521	89 95 50 ff ff
	ff		 mov	 DWORD PTR _cy3x0$18[ebp], edx
$LN25@convert_yv:

; 743  : 
; 744  :             for (int x = 0; x < x_fin; x += 2, dstC += 2, srcP++) {

  00527	c7 85 4c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _x$17[ebp], 0
  00531	eb 21		 jmp	 SHORT $LN16@convert_yv
$LN14@convert_yv:
  00533	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _x$17[ebp]
  00539	83 c0 02	 add	 eax, 2
  0053c	89 85 4c ff ff
	ff		 mov	 DWORD PTR _x$17[ebp], eax
  00542	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$35[ebp]
  00545	83 c1 02	 add	 ecx, 2
  00548	89 4d 94	 mov	 DWORD PTR _dstC$35[ebp], ecx
  0054b	8b 55 90	 mov	 edx, DWORD PTR _srcP$34[ebp]
  0054e	83 c2 02	 add	 edx, 2
  00551	89 55 90	 mov	 DWORD PTR _srcP$34[ebp], edx
$LN16@convert_yv:
  00554	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _x$17[ebp]
  0055a	3b 45 8c	 cmp	 eax, DWORD PTR _x_fin$33[ebp]
  0055d	0f 8d 97 02 00
	00		 jge	 $LN15@convert_yv

; 745  :                 int cxplus = (x + 2 < x_fin);

  00563	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _x$17[ebp]
  00569	83 c1 02	 add	 ecx, 2
  0056c	3b 4d 8c	 cmp	 ecx, DWORD PTR _x_fin$33[ebp]
  0056f	7d 0c		 jge	 SHORT $LN43@convert_yv
  00571	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv297[ebp], 1
  0057b	eb 0a		 jmp	 SHORT $LN44@convert_yv
$LN43@convert_yv:
  0057d	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv297[ebp], 0
$LN44@convert_yv:
  00587	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR tv297[ebp]
  0058d	89 95 48 ff ff
	ff		 mov	 DWORD PTR _cxplus$16[ebp], edx

; 746  :                 int sy0x1 = srcP[y_m2*src_uv_pitch + cxplus];

  00593	8b 45 88	 mov	 eax, DWORD PTR _y_m2$32[ebp]
  00596	0f af 45 a8	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp]
  0059a	03 85 48 ff ff
	ff		 add	 eax, DWORD PTR _cxplus$16[ebp]
  005a0	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  005a3	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  005a7	89 95 44 ff ff
	ff		 mov	 DWORD PTR _sy0x1$15[ebp], edx

; 747  :                 int sy1x1 = srcP[y_m1*src_uv_pitch + cxplus];

  005ad	8b 45 84	 mov	 eax, DWORD PTR _y_m1$31[ebp]
  005b0	0f af 45 a8	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp]
  005b4	03 85 48 ff ff
	ff		 add	 eax, DWORD PTR _cxplus$16[ebp]
  005ba	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  005bd	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  005c1	89 95 40 ff ff
	ff		 mov	 DWORD PTR _sy1x1$14[ebp], edx

; 748  :                 int sy2x1 = srcP[   0*src_uv_pitch + cxplus];

  005c7	6b 45 a8 00	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp], 0
  005cb	03 85 48 ff ff
	ff		 add	 eax, DWORD PTR _cxplus$16[ebp]
  005d1	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  005d4	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  005d8	89 95 3c ff ff
	ff		 mov	 DWORD PTR _sy2x1$13[ebp], edx

; 749  :                 int sy3x1 = srcP[y_p1*src_uv_pitch + cxplus];

  005de	8b 45 80	 mov	 eax, DWORD PTR _y_p1$30[ebp]
  005e1	0f af 45 a8	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp]
  005e5	03 85 48 ff ff
	ff		 add	 eax, DWORD PTR _cxplus$16[ebp]
  005eb	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  005ee	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  005f2	89 95 38 ff ff
	ff		 mov	 DWORD PTR _sy3x1$12[ebp], edx

; 750  :                 int sy4x1 = srcP[y_p2*src_uv_pitch + cxplus];

  005f8	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _y_p2$29[ebp]
  005fe	0f af 45 a8	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp]
  00602	03 85 48 ff ff
	ff		 add	 eax, DWORD PTR _cxplus$16[ebp]
  00608	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  0060b	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  0060f	89 95 34 ff ff
	ff		 mov	 DWORD PTR _sy4x1$11[ebp], edx

; 751  :                 int sy5x1 = srcP[y_p3*src_uv_pitch + cxplus];

  00615	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _y_p3$28[ebp]
  0061b	0f af 45 a8	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp]
  0061f	03 85 48 ff ff
	ff		 add	 eax, DWORD PTR _cxplus$16[ebp]
  00625	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  00628	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  0062c	89 95 30 ff ff
	ff		 mov	 DWORD PTR _sy5x1$10[ebp], edx

; 752  : 
; 753  :                 int cy0x1 = (sy0x1 * 1 + sy2x1 * 7 + 4);

  00632	6b 85 3c ff ff
	ff 07		 imul	 eax, DWORD PTR _sy2x1$13[ebp], 7
  00639	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _sy0x1$15[ebp]
  0063f	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00643	89 95 2c ff ff
	ff		 mov	 DWORD PTR _cy0x1$9[ebp], edx

; 754  :                 int cy1x1 = (sy1x1 * 3 + sy3x1 * 5 + 4);

  00649	6b 85 40 ff ff
	ff 03		 imul	 eax, DWORD PTR _sy1x1$14[ebp], 3
  00650	6b 8d 38 ff ff
	ff 05		 imul	 ecx, DWORD PTR _sy3x1$12[ebp], 5
  00657	8d 54 08 04	 lea	 edx, DWORD PTR [eax+ecx+4]
  0065b	89 95 28 ff ff
	ff		 mov	 DWORD PTR _cy1x1$8[ebp], edx

; 755  :                 int cy2x1 = (sy2x1 * 5 + sy4x1 * 3 + 4);

  00661	6b 85 3c ff ff
	ff 05		 imul	 eax, DWORD PTR _sy2x1$13[ebp], 5
  00668	6b 8d 34 ff ff
	ff 03		 imul	 ecx, DWORD PTR _sy4x1$11[ebp], 3
  0066f	8d 54 08 04	 lea	 edx, DWORD PTR [eax+ecx+4]
  00673	89 95 24 ff ff
	ff		 mov	 DWORD PTR _cy2x1$7[ebp], edx

; 756  :                 int cy3x1 = (sy3x1 * 7 + sy5x1 * 1 + 4);

  00679	6b 85 38 ff ff
	ff 07		 imul	 eax, DWORD PTR _sy3x1$12[ebp], 7
  00680	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR _sy5x1$10[ebp]
  00686	8d 54 08 04	 lea	 edx, DWORD PTR [eax+ecx+4]
  0068a	89 95 20 ff ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], edx

; 757  :                 CHANGE_BIT_DEPTH_4(cy0x1, cy1x1, cy2x1, cy3x1, 3);

  00690	33 c0		 xor	 eax, eax
  00692	74 3e		 je	 SHORT $LN27@convert_yv
  00694	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR _cy0x1$9[ebp]
  0069a	c1 e1 f5	 shl	 ecx, -11		; fffffff5H
  0069d	89 8d 2c ff ff
	ff		 mov	 DWORD PTR _cy0x1$9[ebp], ecx
  006a3	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x1$8[ebp]
  006a9	c1 e2 f5	 shl	 edx, -11		; fffffff5H
  006ac	89 95 28 ff ff
	ff		 mov	 DWORD PTR _cy1x1$8[ebp], edx
  006b2	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _cy2x1$7[ebp]
  006b8	c1 e0 f5	 shl	 eax, -11		; fffffff5H
  006bb	89 85 24 ff ff
	ff		 mov	 DWORD PTR _cy2x1$7[ebp], eax
  006c1	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x1$6[ebp]
  006c7	c1 e1 f5	 shl	 ecx, -11		; fffffff5H
  006ca	89 8d 20 ff ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], ecx
  006d0	eb 45		 jmp	 SHORT $LN28@convert_yv
$LN27@convert_yv:
  006d2	ba 01 00 00 00	 mov	 edx, 1
  006d7	85 d2		 test	 edx, edx
  006d9	74 3c		 je	 SHORT $LN28@convert_yv
  006db	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR _cy0x1$9[ebp]
  006e1	c1 f8 0b	 sar	 eax, 11			; 0000000bH
  006e4	89 85 2c ff ff
	ff		 mov	 DWORD PTR _cy0x1$9[ebp], eax
  006ea	8b 8d 28 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x1$8[ebp]
  006f0	c1 f9 0b	 sar	 ecx, 11			; 0000000bH
  006f3	89 8d 28 ff ff
	ff		 mov	 DWORD PTR _cy1x1$8[ebp], ecx
  006f9	8b 95 24 ff ff
	ff		 mov	 edx, DWORD PTR _cy2x1$7[ebp]
  006ff	c1 fa 0b	 sar	 edx, 11			; 0000000bH
  00702	89 95 24 ff ff
	ff		 mov	 DWORD PTR _cy2x1$7[ebp], edx
  00708	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x1$6[ebp]
  0070e	c1 f8 0b	 sar	 eax, 11			; 0000000bH
  00711	89 85 20 ff ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], eax
$LN28@convert_yv:

; 758  : 
; 759  :                 dstC[0*dst_y_pitch   + 0] = (Tout)cy0x0;

  00717	6b 4d e4 00	 imul	 ecx, DWORD PTR _dst_y_pitch$[ebp], 0
  0071b	8b 55 94	 mov	 edx, DWORD PTR _dstC$35[ebp]
  0071e	8a 85 5c ff ff
	ff		 mov	 al, BYTE PTR _cy0x0$21[ebp]
  00724	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 760  :                 dstC[0*dst_y_pitch   + 1] = (Tout)((cy0x0 + cy0x1 + 1) >> 1);

  00727	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR _cy0x1$9[ebp]
  0072d	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR _cy0x0$21[ebp]
  00733	8d 44 0a 01	 lea	 eax, DWORD PTR [edx+ecx+1]
  00737	d1 f8		 sar	 eax, 1
  00739	6b 4d e4 00	 imul	 ecx, DWORD PTR _dst_y_pitch$[ebp], 0
  0073d	8b 55 94	 mov	 edx, DWORD PTR _dstC$35[ebp]
  00740	88 44 0a 01	 mov	 BYTE PTR [edx+ecx+1], al

; 761  :                 dstC[1*dst_y_pitch   + 0] = (Tout)cy1x0;

  00744	8b 45 94	 mov	 eax, DWORD PTR _dstC$35[ebp]
  00747	03 45 e4	 add	 eax, DWORD PTR _dst_y_pitch$[ebp]
  0074a	8a 8d 58 ff ff
	ff		 mov	 cl, BYTE PTR _cy1x0$20[ebp]
  00750	88 08		 mov	 BYTE PTR [eax], cl

; 762  :                 dstC[1*dst_y_pitch   + 1] = (Tout)((cy1x0 + cy1x1 + 1) >> 1);

  00752	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x1$8[ebp]
  00758	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x0$20[ebp]
  0075e	8d 4c 10 01	 lea	 ecx, DWORD PTR [eax+edx+1]
  00762	d1 f9		 sar	 ecx, 1
  00764	8b 55 94	 mov	 edx, DWORD PTR _dstC$35[ebp]
  00767	03 55 e4	 add	 edx, DWORD PTR _dst_y_pitch$[ebp]
  0076a	88 4a 01	 mov	 BYTE PTR [edx+1], cl

; 763  :                 dstC[2*dst_y_pitch   + 0] = (Tout)cy2x0;

  0076d	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  00770	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$35[ebp]
  00773	8a 95 54 ff ff
	ff		 mov	 dl, BYTE PTR _cy2x0$19[ebp]
  00779	88 14 41	 mov	 BYTE PTR [ecx+eax*2], dl

; 764  :                 dstC[2*dst_y_pitch   + 1] = (Tout)((cy2x0 + cy2x1 + 1) >> 1);

  0077c	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _cy2x1$7[ebp]
  00782	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _cy2x0$19[ebp]
  00788	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  0078c	d1 fa		 sar	 edx, 1
  0078e	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  00791	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$35[ebp]
  00794	88 54 41 01	 mov	 BYTE PTR [ecx+eax*2+1], dl

; 765  :                 dstC[3*dst_y_pitch   + 0] = (Tout)cy3x0;

  00798	6b 55 e4 03	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 3
  0079c	8b 45 94	 mov	 eax, DWORD PTR _dstC$35[ebp]
  0079f	8a 8d 50 ff ff
	ff		 mov	 cl, BYTE PTR _cy3x0$18[ebp]
  007a5	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 766  :                 dstC[3*dst_y_pitch   + 1] = (Tout)((cy3x0 + cy3x1 + 1) >> 1);

  007a8	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR _cy3x1$6[ebp]
  007ae	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$18[ebp]
  007b4	8d 4c 10 01	 lea	 ecx, DWORD PTR [eax+edx+1]
  007b8	d1 f9		 sar	 ecx, 1
  007ba	6b 55 e4 03	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 3
  007be	8b 45 94	 mov	 eax, DWORD PTR _dstC$35[ebp]
  007c1	88 4c 10 01	 mov	 BYTE PTR [eax+edx+1], cl

; 767  : 
; 768  :                 cy0x0 = cy0x1;

  007c5	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR _cy0x1$9[ebp]
  007cb	89 8d 5c ff ff
	ff		 mov	 DWORD PTR _cy0x0$21[ebp], ecx

; 769  :                 cy1x0 = cy1x1;

  007d1	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x1$8[ebp]
  007d7	89 95 58 ff ff
	ff		 mov	 DWORD PTR _cy1x0$20[ebp], edx

; 770  :                 cy2x0 = cy2x1;

  007dd	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _cy2x1$7[ebp]
  007e3	89 85 54 ff ff
	ff		 mov	 DWORD PTR _cy2x0$19[ebp], eax

; 771  :                 cy3x0 = cy3x1;

  007e9	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x1$6[ebp]
  007ef	89 8d 50 ff ff
	ff		 mov	 DWORD PTR _cy3x0$18[ebp], ecx

; 772  :             }

  007f5	e9 39 fd ff ff	 jmp	 $LN14@convert_yv
$LN15@convert_yv:

; 773  :         }

  007fa	e9 90 fa ff ff	 jmp	 $LN11@convert_yv
$LN12@convert_yv:

; 774  :     }

  007ff	e9 41 fa ff ff	 jmp	 $LN8@convert_yv
$LN1@convert_yv:

; 775  : }

  00804	52		 push	 edx
  00805	8b cd		 mov	 ecx, ebp
  00807	50		 push	 eax
  00808	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN47@convert_yv
  0080e	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00813	58		 pop	 eax
  00814	5a		 pop	 edx
  00815	5f		 pop	 edi
  00816	5b		 pop	 ebx
  00817	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0081a	33 cd		 xor	 ecx, ebp
  0081c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00821	81 c4 18 01 00
	00		 add	 esp, 280		; 00000118H
  00827	3b ec		 cmp	 ebp, esp
  00829	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0082e	8b e5		 mov	 esp, ebp
  00830	5d		 pop	 ebp
  00831	c3		 ret	 0
  00832	66 90		 npad	 2
$LN47@convert_yv:
  00834	01 00 00 00	 DD	 1
  00838	00 00 00 00	 DD	 $LN46@convert_yv
$LN46@convert_yv:
  0083c	d4 ff ff ff	 DD	 -44			; ffffffd4H
  00840	0c 00 00 00	 DD	 12			; 0000000cH
  00844	00 00 00 00	 DD	 $LN45@convert_yv
$LN45@convert_yv:
  00848	79		 DB	 121			; 00000079H
  00849	5f		 DB	 95			; 0000005fH
  0084a	72		 DB	 114			; 00000072H
  0084b	61		 DB	 97			; 00000061H
  0084c	6e		 DB	 110			; 0000006eH
  0084d	67		 DB	 103			; 00000067H
  0084e	65		 DB	 101			; 00000065H
  0084f	00		 DB	 0
??$convert_yv12_i_to_yuv444_c@G$0BA@E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_i_to_yuv444_c<unsigned short,16,unsigned char,8,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yv12_16_i_to_yuv444@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_16_i_to_yuv444

; 797  : static void convert_yv12_16_i_to_yuv444(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 798  :     convert_yv12_i_to_yuv444_c<uint16_t, 16, uint8_t, 8, false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yv12_i_to_yuv444_c@G$0BA@E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_i_to_yuv444_c<unsigned short,16,unsigned char,8,0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 799  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yv12_16_i_to_yuv444@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_16_i_to_yuv444
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
tv427 = -300						; size = 4
tv312 = -296						; size = 4
tv227 = -292						; size = 4
$T1 = -288						; size = 4
$T2 = -284						; size = 4
$T3 = -280						; size = 4
$T4 = -276						; size = 4
$T5 = -272						; size = 12
_cy3x1$6 = -260						; size = 4
_cy1x1$7 = -256						; size = 4
_cy3x0$8 = -252						; size = 4
_cy1x0$9 = -248						; size = 4
_cy4x1$10 = -244					; size = 4
_cy2x1$11 = -240					; size = 4
_cy0x1$12 = -236					; size = 4
_cy4x0$13 = -232					; size = 4
_cy2x0$14 = -228					; size = 4
_cy0x0$15 = -224					; size = 4
_cxplus$16 = -220					; size = 4
_x$17 = -216						; size = 4
_cy3x1$18 = -212					; size = 4
_cy1x1$19 = -208					; size = 4
_cy3x0$20 = -204					; size = 4
_cy1x0$21 = -200					; size = 4
_cy4x1$22 = -196					; size = 4
_cy2x1$23 = -192					; size = 4
_cy0x1$24 = -188					; size = 4
_cy4x0$25 = -184					; size = 4
_cy2x0$26 = -180					; size = 4
_cy0x0$27 = -176					; size = 4
_cxplus$28 = -172					; size = 4
_x$29 = -168						; size = 4
_cy3x1$30 = -164					; size = 4
_cy1x1$31 = -160					; size = 4
_cy3x0$32 = -156					; size = 4
_cy1x0$33 = -152					; size = 4
_cy4x1$34 = -148					; size = 4
_cy2x1$35 = -144					; size = 4
_cy0x1$36 = -140					; size = 4
_cy4x0$37 = -136					; size = 4
_cy2x0$38 = -132					; size = 4
_cy0x0$39 = -128					; size = 4
_cxplus$40 = -124					; size = 4
_x$41 = -120						; size = 4
_x_fin$42 = -116					; size = 4
_srcP$43 = -112						; size = 4
_dstC$44 = -108						; size = 4
_y$45 = -104						; size = 4
_dstLine$46 = -100					; size = 4
_srcCLine$47 = -96					; size = 4
_ic$48 = -92						; size = 4
_src_uv_pitch$ = -88					; size = 4
_x$49 = -84						; size = 4
_y$50 = -80						; size = 4
_y_width$51 = -76					; size = 4
_y_fin$52 = -72						; size = 4
_dstLine$53 = -68					; size = 4
_srcYLine$54 = -64					; size = 4
$T55 = -60						; size = 12
_y_range$ = -44						; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yv12_p_to_yuv444_c@G$0BA@E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_p_to_yuv444_c<unsigned short,16,unsigned char,8,0>

; 573  : static void __forceinline convert_yv12_p_to_yuv444_c(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 2c 01 00
	00		 sub	 esp, 300		; 0000012cH
  00009	53		 push	 ebx
  0000a	57		 push	 edi
  0000b	8d bd d4 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-300]
  00011	b9 4b 00 00 00	 mov	 ecx, 75			; 0000004bH
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 574  :     static_assert((sizeof(Tin)  == 1 && in_bit_depth  == 8) || (sizeof(Tin)  == 2 && 8 < in_bit_depth  && in_bit_depth  <= 16), "invalid input bit depth.");
; 575  :     static_assert((sizeof(Tout) == 1 && out_bit_depth == 8) || (sizeof(Tout) == 2 && 8 < out_bit_depth && out_bit_depth <= 16), "invalid output bit depth.");
; 576  :     const int crop_left   = crop[0];

  00027	b8 04 00 00 00	 mov	 eax, 4
  0002c	6b c8 00	 imul	 ecx, eax, 0
  0002f	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00032	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00035	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 577  :     const int crop_up     = crop[1];

  00038	b9 04 00 00 00	 mov	 ecx, 4
  0003d	c1 e1 00	 shl	 ecx, 0
  00040	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00043	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00046	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 578  :     const int crop_right  = crop[2];

  00049	b9 04 00 00 00	 mov	 ecx, 4
  0004e	d1 e1		 shl	 ecx, 1
  00050	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00053	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00056	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 579  :     const int crop_bottom = crop[3];

  00059	b9 04 00 00 00	 mov	 ecx, 4
  0005e	6b d1 03	 imul	 edx, ecx, 3
  00061	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00064	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00067	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 580  :     const int src_y_pitch = src_y_pitch_byte / sizeof(Tin);

  0006a	8b 55 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebp]
  0006d	d1 ea		 shr	 edx, 1
  0006f	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 581  :     const int dst_y_pitch = dst_y_pitch_byte / sizeof(Tout);

  00072	8b 45 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  00075	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 582  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00078	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0007b	51		 push	 ecx
  0007c	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0007f	52		 push	 edx
  00080	8b 45 20	 mov	 eax, DWORD PTR _height$[ebp]
  00083	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  00086	50		 push	 eax
  00087	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  0008a	51		 push	 ecx
  0008b	8d 95 f0 fe ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  00091	52		 push	 edx
  00092	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00097	83 c4 14	 add	 esp, 20			; 00000014H
  0009a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009c	89 4d c4	 mov	 DWORD PTR $T55[ebp], ecx
  0009f	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a2	89 55 c8	 mov	 DWORD PTR $T55[ebp+4], edx
  000a5	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000a8	89 45 cc	 mov	 DWORD PTR $T55[ebp+8], eax
  000ab	8b 4d c4	 mov	 ecx, DWORD PTR $T55[ebp]
  000ae	89 4d d4	 mov	 DWORD PTR _y_range$[ebp], ecx
  000b1	8b 55 c8	 mov	 edx, DWORD PTR $T55[ebp+4]
  000b4	89 55 d8	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000b7	8b 45 cc	 mov	 eax, DWORD PTR $T55[ebp+8]
  000ba	89 45 dc	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 583  :     //Y
; 584  :     if (!uv_only) {

  000bd	b9 01 00 00 00	 mov	 ecx, 1
  000c2	85 c9		 test	 ecx, ecx
  000c4	0f 84 6a 01 00
	00		 je	 $LN23@convert_yv

; 585  :         Tin *srcYLine = (Tin *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000ca	ba 04 00 00 00	 mov	 edx, 4
  000cf	6b c2 00	 imul	 eax, edx, 0
  000d2	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  000d5	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  000d9	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  000dc	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  000df	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  000e2	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  000e5	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  000e8	89 45 c0	 mov	 DWORD PTR _srcYLine$54[ebp], eax

; 586  :         Tout *dstLine = (Tout *)dst[0] + dst_y_pitch * y_range.start_dst;

  000eb	b9 04 00 00 00	 mov	 ecx, 4
  000f0	6b d1 00	 imul	 edx, ecx, 0
  000f3	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  000f6	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  000fa	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  000fd	03 04 11	 add	 eax, DWORD PTR [ecx+edx]
  00100	89 45 bc	 mov	 DWORD PTR _dstLine$53[ebp], eax

; 587  :         const int y_fin = height - crop_bottom;

  00103	8b 55 20	 mov	 edx, DWORD PTR _height$[ebp]
  00106	2b 55 ec	 sub	 edx, DWORD PTR _crop_bottom$[ebp]
  00109	89 55 b8	 mov	 DWORD PTR _y_fin$52[ebp], edx

; 588  :         const int y_width = width - crop_right - crop_left;

  0010c	8b 45 10	 mov	 eax, DWORD PTR _width$[ebp]
  0010f	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  00112	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  00115	89 45 b4	 mov	 DWORD PTR _y_width$51[ebp], eax

; 589  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  00118	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _y$50[ebp], 0
  0011f	eb 1e		 jmp	 SHORT $LN4@convert_yv
$LN2@convert_yv:
  00121	8b 4d b0	 mov	 ecx, DWORD PTR _y$50[ebp]
  00124	83 c1 01	 add	 ecx, 1
  00127	89 4d b0	 mov	 DWORD PTR _y$50[ebp], ecx
  0012a	8b 55 e8	 mov	 edx, DWORD PTR _src_y_pitch$[ebp]
  0012d	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$54[ebp]
  00130	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00133	89 4d c0	 mov	 DWORD PTR _srcYLine$54[ebp], ecx
  00136	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$53[ebp]
  00139	03 55 e4	 add	 edx, DWORD PTR _dst_y_pitch$[ebp]
  0013c	89 55 bc	 mov	 DWORD PTR _dstLine$53[ebp], edx
$LN4@convert_yv:
  0013f	8b 45 b0	 mov	 eax, DWORD PTR _y$50[ebp]
  00142	3b 45 dc	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  00145	0f 8d e9 00 00
	00		 jge	 $LN23@convert_yv

; 590  :             if (in_bit_depth == out_bit_depth && sizeof(Tin) == sizeof(Tout)) {

  0014b	33 c9		 xor	 ecx, ecx
  0014d	74 1b		 je	 SHORT $LN24@convert_yv

; 591  :                 memcpy(dstLine, srcYLine, y_width * sizeof(Tin));

  0014f	8b 55 b4	 mov	 edx, DWORD PTR _y_width$51[ebp]
  00152	d1 e2		 shl	 edx, 1
  00154	52		 push	 edx
  00155	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$54[ebp]
  00158	50		 push	 eax
  00159	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$53[ebp]
  0015c	51		 push	 ecx
  0015d	e8 00 00 00 00	 call	 _memcpy
  00162	83 c4 0c	 add	 esp, 12			; 0000000cH

; 592  :             } else {

  00165	e9 c5 00 00 00	 jmp	 $LN25@convert_yv
$LN24@convert_yv:

; 593  :                 for (int x = 0; x < y_width; x++) {

  0016a	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR _x$49[ebp], 0
  00171	eb 09		 jmp	 SHORT $LN7@convert_yv
$LN5@convert_yv:
  00173	8b 55 ac	 mov	 edx, DWORD PTR _x$49[ebp]
  00176	83 c2 01	 add	 edx, 1
  00179	89 55 ac	 mov	 DWORD PTR _x$49[ebp], edx
$LN7@convert_yv:
  0017c	8b 45 ac	 mov	 eax, DWORD PTR _x$49[ebp]
  0017f	3b 45 b4	 cmp	 eax, DWORD PTR _y_width$51[ebp]
  00182	0f 8d a7 00 00
	00		 jge	 $LN25@convert_yv

; 594  :                     if (out_bit_depth > in_bit_depth) {

  00188	33 c9		 xor	 ecx, ecx
  0018a	74 42		 je	 SHORT $LN26@convert_yv

; 595  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) << std::max(out_bit_depth - in_bit_depth, 0));

  0018c	c7 85 ec fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], 0
  00196	c7 85 e8 fe ff
	ff f8 ff ff ff	 mov	 DWORD PTR $T3[ebp], -8	; fffffff8H
  001a0	8b 55 ac	 mov	 edx, DWORD PTR _x$49[ebp]
  001a3	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$54[ebp]
  001a6	0f b7 1c 50	 movzx	 ebx, WORD PTR [eax+edx*2]
  001aa	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  001b0	51		 push	 ecx
  001b1	8d 95 e8 fe ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  001b7	52		 push	 edx
  001b8	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  001bd	83 c4 08	 add	 esp, 8
  001c0	8b 08		 mov	 ecx, DWORD PTR [eax]
  001c2	d3 e3		 shl	 ebx, cl
  001c4	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$53[ebp]
  001c7	03 45 ac	 add	 eax, DWORD PTR _x$49[ebp]
  001ca	88 18		 mov	 BYTE PTR [eax], bl
  001cc	eb 5c		 jmp	 SHORT $LN27@convert_yv
$LN26@convert_yv:

; 596  :                     } else if (out_bit_depth < in_bit_depth) {

  001ce	b9 01 00 00 00	 mov	 ecx, 1
  001d3	85 c9		 test	 ecx, ecx
  001d5	74 42		 je	 SHORT $LN28@convert_yv

; 597  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) >> std::max(in_bit_depth - out_bit_depth, 0));

  001d7	c7 85 e4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], 0
  001e1	c7 85 e0 fe ff
	ff 08 00 00 00	 mov	 DWORD PTR $T1[ebp], 8
  001eb	8b 55 ac	 mov	 edx, DWORD PTR _x$49[ebp]
  001ee	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$54[ebp]
  001f1	0f b7 1c 50	 movzx	 ebx, WORD PTR [eax+edx*2]
  001f5	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  001fb	51		 push	 ecx
  001fc	8d 95 e0 fe ff
	ff		 lea	 edx, DWORD PTR $T1[ebp]
  00202	52		 push	 edx
  00203	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  00208	83 c4 08	 add	 esp, 8
  0020b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0020d	d3 fb		 sar	 ebx, cl
  0020f	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$53[ebp]
  00212	03 45 ac	 add	 eax, DWORD PTR _x$49[ebp]
  00215	88 18		 mov	 BYTE PTR [eax], bl

; 598  :                     } else {

  00217	eb 11		 jmp	 SHORT $LN27@convert_yv
$LN28@convert_yv:

; 599  :                         dstLine[x] = (Tout)srcYLine[x];

  00219	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$53[ebp]
  0021c	03 4d ac	 add	 ecx, DWORD PTR _x$49[ebp]
  0021f	8b 55 ac	 mov	 edx, DWORD PTR _x$49[ebp]
  00222	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$54[ebp]
  00225	8a 14 50	 mov	 dl, BYTE PTR [eax+edx*2]
  00228	88 11		 mov	 BYTE PTR [ecx], dl
$LN27@convert_yv:

; 600  :                     }
; 601  :                 }

  0022a	e9 44 ff ff ff	 jmp	 $LN5@convert_yv
$LN25@convert_yv:

; 602  :             }
; 603  :         }

  0022f	e9 ed fe ff ff	 jmp	 $LN2@convert_yv
$LN23@convert_yv:

; 604  :     }
; 605  :     //UV
; 606  :     const int src_uv_pitch = src_uv_pitch_byte / sizeof(Tin);

  00234	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  00237	d1 e8		 shr	 eax, 1
  00239	89 45 a8	 mov	 DWORD PTR _src_uv_pitch$[ebp], eax

; 607  :     for (int ic = 1; ic < 3; ic++) {

  0023c	c7 45 a4 01 00
	00 00		 mov	 DWORD PTR _ic$48[ebp], 1
  00243	eb 09		 jmp	 SHORT $LN10@convert_yv
$LN8@convert_yv:
  00245	8b 4d a4	 mov	 ecx, DWORD PTR _ic$48[ebp]
  00248	83 c1 01	 add	 ecx, 1
  0024b	89 4d a4	 mov	 DWORD PTR _ic$48[ebp], ecx
$LN10@convert_yv:
  0024e	83 7d a4 03	 cmp	 DWORD PTR _ic$48[ebp], 3
  00252	0f 8d ea 06 00
	00		 jge	 $LN1@convert_yv

; 608  :         Tin *srcCLine = (Tin *)src[ic] + (((src_uv_pitch * y_range.start_src) + crop_left) >> 1);

  00258	8b 55 a8	 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  0025b	0f af 55 d4	 imul	 edx, DWORD PTR _y_range$[ebp]
  0025f	03 55 f8	 add	 edx, DWORD PTR _crop_left$[ebp]
  00262	d1 fa		 sar	 edx, 1
  00264	8b 45 a4	 mov	 eax, DWORD PTR _ic$48[ebp]
  00267	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  0026a	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  0026d	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00270	89 4d a0	 mov	 DWORD PTR _srcCLine$47[ebp], ecx

; 609  :         Tout *dstLine = (Tout *)dst[ic] + dst_y_pitch * y_range.start_dst;

  00273	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  00276	0f af 55 d8	 imul	 edx, DWORD PTR _y_range$[ebp+4]
  0027a	8b 45 a4	 mov	 eax, DWORD PTR _ic$48[ebp]
  0027d	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  00280	03 14 81	 add	 edx, DWORD PTR [ecx+eax*4]
  00283	89 55 9c	 mov	 DWORD PTR _dstLine$46[ebp], edx

; 610  :         for (int y = 0; y < y_range.len; y += 2, srcCLine += src_uv_pitch, dstLine += dst_y_pitch * 2) {

  00286	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _y$45[ebp], 0
  0028d	eb 21		 jmp	 SHORT $LN13@convert_yv
$LN11@convert_yv:
  0028f	8b 55 98	 mov	 edx, DWORD PTR _y$45[ebp]
  00292	83 c2 02	 add	 edx, 2
  00295	89 55 98	 mov	 DWORD PTR _y$45[ebp], edx
  00298	8b 45 a8	 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  0029b	8b 4d a0	 mov	 ecx, DWORD PTR _srcCLine$47[ebp]
  0029e	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  002a1	89 55 a0	 mov	 DWORD PTR _srcCLine$47[ebp], edx
  002a4	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  002a7	8b 4d 9c	 mov	 ecx, DWORD PTR _dstLine$46[ebp]
  002aa	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  002ad	89 55 9c	 mov	 DWORD PTR _dstLine$46[ebp], edx
$LN13@convert_yv:
  002b0	8b 45 98	 mov	 eax, DWORD PTR _y$45[ebp]
  002b3	3b 45 dc	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  002b6	0f 8d 81 06 00
	00		 jge	 $LN12@convert_yv

; 611  :             Tout *dstC = dstLine;

  002bc	8b 4d 9c	 mov	 ecx, DWORD PTR _dstLine$46[ebp]
  002bf	89 4d 94	 mov	 DWORD PTR _dstC$44[ebp], ecx

; 612  :             Tin *srcP = srcCLine;

  002c2	8b 55 a0	 mov	 edx, DWORD PTR _srcCLine$47[ebp]
  002c5	89 55 90	 mov	 DWORD PTR _srcP$43[ebp], edx

; 613  :             const int x_fin = width - crop_right - crop_left;

  002c8	8b 45 10	 mov	 eax, DWORD PTR _width$[ebp]
  002cb	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  002ce	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  002d1	89 45 8c	 mov	 DWORD PTR _x_fin$42[ebp], eax

; 614  :             if (y == 0) {

  002d4	83 7d 98 00	 cmp	 DWORD PTR _y$45[ebp], 0
  002d8	0f 85 04 02 00
	00		 jne	 $LN30@convert_yv

; 615  :                 for (int x = 0; x < x_fin; x += 2, dstC += 2, srcP++) {

  002de	c7 45 88 00 00
	00 00		 mov	 DWORD PTR _x$41[ebp], 0
  002e5	eb 1b		 jmp	 SHORT $LN16@convert_yv
$LN14@convert_yv:
  002e7	8b 4d 88	 mov	 ecx, DWORD PTR _x$41[ebp]
  002ea	83 c1 02	 add	 ecx, 2
  002ed	89 4d 88	 mov	 DWORD PTR _x$41[ebp], ecx
  002f0	8b 55 94	 mov	 edx, DWORD PTR _dstC$44[ebp]
  002f3	83 c2 02	 add	 edx, 2
  002f6	89 55 94	 mov	 DWORD PTR _dstC$44[ebp], edx
  002f9	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  002fc	83 c0 02	 add	 eax, 2
  002ff	89 45 90	 mov	 DWORD PTR _srcP$43[ebp], eax
$LN16@convert_yv:
  00302	8b 4d 88	 mov	 ecx, DWORD PTR _x$41[ebp]
  00305	3b 4d 8c	 cmp	 ecx, DWORD PTR _x_fin$42[ebp]
  00308	0f 8d cf 01 00
	00		 jge	 $LN15@convert_yv

; 616  :                     int cxplus = (x + 2 < x_fin);

  0030e	8b 55 88	 mov	 edx, DWORD PTR _x$41[ebp]
  00311	83 c2 02	 add	 edx, 2
  00314	3b 55 8c	 cmp	 edx, DWORD PTR _x_fin$42[ebp]
  00317	7d 0c		 jge	 SHORT $LN44@convert_yv
  00319	c7 85 dc fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv227[ebp], 1
  00323	eb 0a		 jmp	 SHORT $LN45@convert_yv
$LN44@convert_yv:
  00325	c7 85 dc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv227[ebp], 0
$LN45@convert_yv:
  0032f	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR tv227[ebp]
  00335	89 45 84	 mov	 DWORD PTR _cxplus$40[ebp], eax

; 617  :                     int cy0x0 = srcP[ 0*src_uv_pitch + 0];

  00338	6b 4d a8 00	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 0
  0033c	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  0033f	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00343	89 45 80	 mov	 DWORD PTR _cy0x0$39[ebp], eax

; 618  :                     int cy2x0 = srcP[ 0*src_uv_pitch + 0];

  00346	6b 4d a8 00	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 0
  0034a	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  0034d	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00351	89 85 7c ff ff
	ff		 mov	 DWORD PTR _cy2x0$38[ebp], eax

; 619  :                     int cy4x0 = srcP[ 1*src_uv_pitch + 0];

  00357	8b 4d a8	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  0035a	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  0035d	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00361	89 85 78 ff ff
	ff		 mov	 DWORD PTR _cy4x0$37[ebp], eax

; 620  :                     int cy0x1 = srcP[ 0*src_uv_pitch + cxplus];

  00367	6b 4d a8 00	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 0
  0036b	03 4d 84	 add	 ecx, DWORD PTR _cxplus$40[ebp]
  0036e	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  00371	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00375	89 85 74 ff ff
	ff		 mov	 DWORD PTR _cy0x1$36[ebp], eax

; 621  :                     int cy2x1 = srcP[ 0*src_uv_pitch + cxplus];

  0037b	6b 4d a8 00	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 0
  0037f	03 4d 84	 add	 ecx, DWORD PTR _cxplus$40[ebp]
  00382	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  00385	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00389	89 85 70 ff ff
	ff		 mov	 DWORD PTR _cy2x1$35[ebp], eax

; 622  :                     int cy4x1 = srcP[ 1*src_uv_pitch + cxplus];

  0038f	8b 4d 84	 mov	 ecx, DWORD PTR _cxplus$40[ebp]
  00392	03 4d a8	 add	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00395	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  00398	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  0039c	89 85 6c ff ff
	ff		 mov	 DWORD PTR _cy4x1$34[ebp], eax

; 623  : 
; 624  :                     int cy1x0 = (cy0x0 * 1 + cy2x0 * 3 + 2);

  003a2	6b 8d 7c ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy2x0$38[ebp], 3
  003a9	8b 55 80	 mov	 edx, DWORD PTR _cy0x0$39[ebp]
  003ac	8d 44 0a 02	 lea	 eax, DWORD PTR [edx+ecx+2]
  003b0	89 85 68 ff ff
	ff		 mov	 DWORD PTR _cy1x0$33[ebp], eax

; 625  :                     int cy3x0 = (cy2x0 * 3 + cy4x0 * 1 + 2);

  003b6	6b 8d 7c ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy2x0$38[ebp], 3
  003bd	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _cy4x0$37[ebp]
  003c3	8d 44 11 02	 lea	 eax, DWORD PTR [ecx+edx+2]
  003c7	89 85 64 ff ff
	ff		 mov	 DWORD PTR _cy3x0$32[ebp], eax

; 626  :                     int cy1x1 = (cy0x1 * 1 + cy2x1 * 3 + 2);

  003cd	6b 8d 70 ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy2x1$35[ebp], 3
  003d4	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _cy0x1$36[ebp]
  003da	8d 44 0a 02	 lea	 eax, DWORD PTR [edx+ecx+2]
  003de	89 85 60 ff ff
	ff		 mov	 DWORD PTR _cy1x1$31[ebp], eax

; 627  :                     int cy3x1 = (cy2x1 * 3 + cy4x1 * 1 + 2);

  003e4	6b 8d 70 ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy2x1$35[ebp], 3
  003eb	8b 95 6c ff ff
	ff		 mov	 edx, DWORD PTR _cy4x1$34[ebp]
  003f1	8d 44 11 02	 lea	 eax, DWORD PTR [ecx+edx+2]
  003f5	89 85 5c ff ff
	ff		 mov	 DWORD PTR _cy3x1$30[ebp], eax

; 628  :                     CHANGE_BIT_DEPTH_4(cy1x0, cy3x0, cy1x1, cy3x1, 2);

  003fb	33 c9		 xor	 ecx, ecx
  003fd	74 3e		 je	 SHORT $LN32@convert_yv
  003ff	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x0$33[ebp]
  00405	c1 e2 f6	 shl	 edx, -10		; fffffff6H
  00408	89 95 68 ff ff
	ff		 mov	 DWORD PTR _cy1x0$33[ebp], edx
  0040e	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$32[ebp]
  00414	c1 e0 f6	 shl	 eax, -10		; fffffff6H
  00417	89 85 64 ff ff
	ff		 mov	 DWORD PTR _cy3x0$32[ebp], eax
  0041d	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x1$31[ebp]
  00423	c1 e1 f6	 shl	 ecx, -10		; fffffff6H
  00426	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _cy1x1$31[ebp], ecx
  0042c	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR _cy3x1$30[ebp]
  00432	c1 e2 f6	 shl	 edx, -10		; fffffff6H
  00435	89 95 5c ff ff
	ff		 mov	 DWORD PTR _cy3x1$30[ebp], edx
  0043b	eb 45		 jmp	 SHORT $LN33@convert_yv
$LN32@convert_yv:
  0043d	b8 01 00 00 00	 mov	 eax, 1
  00442	85 c0		 test	 eax, eax
  00444	74 3c		 je	 SHORT $LN33@convert_yv
  00446	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x0$33[ebp]
  0044c	c1 f9 0a	 sar	 ecx, 10			; 0000000aH
  0044f	89 8d 68 ff ff
	ff		 mov	 DWORD PTR _cy1x0$33[ebp], ecx
  00455	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR _cy3x0$32[ebp]
  0045b	c1 fa 0a	 sar	 edx, 10			; 0000000aH
  0045e	89 95 64 ff ff
	ff		 mov	 DWORD PTR _cy3x0$32[ebp], edx
  00464	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x1$31[ebp]
  0046a	c1 f8 0a	 sar	 eax, 10			; 0000000aH
  0046d	89 85 60 ff ff
	ff		 mov	 DWORD PTR _cy1x1$31[ebp], eax
  00473	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x1$30[ebp]
  00479	c1 f9 0a	 sar	 ecx, 10			; 0000000aH
  0047c	89 8d 5c ff ff
	ff		 mov	 DWORD PTR _cy3x1$30[ebp], ecx
$LN33@convert_yv:

; 629  : 
; 630  :                     dstC[0*dst_y_pitch   + 0] = (Tout)cy1x0;

  00482	6b 55 e4 00	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 0
  00486	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  00489	8a 8d 68 ff ff
	ff		 mov	 cl, BYTE PTR _cy1x0$33[ebp]
  0048f	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 631  :                     dstC[0*dst_y_pitch   + 1] = (Tout)((cy1x0 + cy1x1 + 1) >> 1);

  00492	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x1$31[ebp]
  00498	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x0$33[ebp]
  0049e	8d 4c 10 01	 lea	 ecx, DWORD PTR [eax+edx+1]
  004a2	d1 f9		 sar	 ecx, 1
  004a4	6b 55 e4 00	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 0
  004a8	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  004ab	88 4c 10 01	 mov	 BYTE PTR [eax+edx+1], cl

; 632  :                     dstC[1*dst_y_pitch   + 0] = (Tout)cy3x0;

  004af	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$44[ebp]
  004b2	03 4d e4	 add	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  004b5	8a 95 64 ff ff
	ff		 mov	 dl, BYTE PTR _cy3x0$32[ebp]
  004bb	88 11		 mov	 BYTE PTR [ecx], dl

; 633  :                     dstC[1*dst_y_pitch   + 1] = (Tout)((cy3x0 + cy3x1 + 1) >> 1);

  004bd	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _cy3x1$30[ebp]
  004c3	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x0$32[ebp]
  004c9	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  004cd	d1 fa		 sar	 edx, 1
  004cf	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  004d2	03 45 e4	 add	 eax, DWORD PTR _dst_y_pitch$[ebp]
  004d5	88 50 01	 mov	 BYTE PTR [eax+1], dl

; 634  :                 }

  004d8	e9 0a fe ff ff	 jmp	 $LN14@convert_yv
$LN15@convert_yv:

; 635  :             } else if (y >= height-2) {

  004dd	e9 56 04 00 00	 jmp	 $LN31@convert_yv
$LN30@convert_yv:
  004e2	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  004e5	83 e9 02	 sub	 ecx, 2
  004e8	39 4d 98	 cmp	 DWORD PTR _y$45[ebp], ecx
  004eb	0f 8c 27 02 00
	00		 jl	 $LN35@convert_yv

; 636  :                 for (int x = 0; x < x_fin; x += 2, dstC += 2, srcP++) {

  004f1	c7 85 58 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _x$29[ebp], 0
  004fb	eb 21		 jmp	 SHORT $LN19@convert_yv
$LN17@convert_yv:
  004fd	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _x$29[ebp]
  00503	83 c2 02	 add	 edx, 2
  00506	89 95 58 ff ff
	ff		 mov	 DWORD PTR _x$29[ebp], edx
  0050c	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  0050f	83 c0 02	 add	 eax, 2
  00512	89 45 94	 mov	 DWORD PTR _dstC$44[ebp], eax
  00515	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$43[ebp]
  00518	83 c1 02	 add	 ecx, 2
  0051b	89 4d 90	 mov	 DWORD PTR _srcP$43[ebp], ecx
$LN19@convert_yv:
  0051e	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _x$29[ebp]
  00524	3b 55 8c	 cmp	 edx, DWORD PTR _x_fin$42[ebp]
  00527	0f 8d e6 01 00
	00		 jge	 $LN18@convert_yv

; 637  :                     int cxplus = (x + 2 < x_fin);

  0052d	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _x$29[ebp]
  00533	83 c0 02	 add	 eax, 2
  00536	3b 45 8c	 cmp	 eax, DWORD PTR _x_fin$42[ebp]
  00539	7d 0c		 jge	 SHORT $LN46@convert_yv
  0053b	c7 85 d8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv312[ebp], 1
  00545	eb 0a		 jmp	 SHORT $LN47@convert_yv
$LN46@convert_yv:
  00547	c7 85 d8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv312[ebp], 0
$LN47@convert_yv:
  00551	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR tv312[ebp]
  00557	89 8d 54 ff ff
	ff		 mov	 DWORD PTR _cxplus$28[ebp], ecx

; 638  :                     int cy0x0 = srcP[-1*src_uv_pitch + 0];

  0055d	6b 55 a8 ff	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], -1
  00561	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  00564	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  00568	89 8d 50 ff ff
	ff		 mov	 DWORD PTR _cy0x0$27[ebp], ecx

; 639  :                     int cy2x0 = srcP[ 0*src_uv_pitch + 0];

  0056e	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  00572	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  00575	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  00579	89 8d 4c ff ff
	ff		 mov	 DWORD PTR _cy2x0$26[ebp], ecx

; 640  :                     int cy4x0 = srcP[ 0*src_uv_pitch + 0];

  0057f	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  00583	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  00586	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  0058a	89 8d 48 ff ff
	ff		 mov	 DWORD PTR _cy4x0$25[ebp], ecx

; 641  :                     int cy0x1 = srcP[-1*src_uv_pitch + cxplus];

  00590	6b 55 a8 ff	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], -1
  00594	03 95 54 ff ff
	ff		 add	 edx, DWORD PTR _cxplus$28[ebp]
  0059a	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  0059d	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  005a1	89 8d 44 ff ff
	ff		 mov	 DWORD PTR _cy0x1$24[ebp], ecx

; 642  :                     int cy2x1 = srcP[ 0*src_uv_pitch + cxplus];

  005a7	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  005ab	03 95 54 ff ff
	ff		 add	 edx, DWORD PTR _cxplus$28[ebp]
  005b1	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  005b4	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  005b8	89 8d 40 ff ff
	ff		 mov	 DWORD PTR _cy2x1$23[ebp], ecx

; 643  :                     int cy4x1 = srcP[ 0*src_uv_pitch + cxplus];

  005be	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  005c2	03 95 54 ff ff
	ff		 add	 edx, DWORD PTR _cxplus$28[ebp]
  005c8	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  005cb	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  005cf	89 8d 3c ff ff
	ff		 mov	 DWORD PTR _cy4x1$22[ebp], ecx

; 644  : 
; 645  :                     int cy1x0 = (cy0x0 * 1 + cy2x0 * 3 + 2);

  005d5	6b 95 4c ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x0$26[ebp], 3
  005dc	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _cy0x0$27[ebp]
  005e2	8d 4c 10 02	 lea	 ecx, DWORD PTR [eax+edx+2]
  005e6	89 8d 38 ff ff
	ff		 mov	 DWORD PTR _cy1x0$21[ebp], ecx

; 646  :                     int cy3x0 = (cy2x0 * 3 + cy4x0 * 1 + 2);

  005ec	6b 95 4c ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x0$26[ebp], 3
  005f3	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _cy4x0$25[ebp]
  005f9	8d 4c 02 02	 lea	 ecx, DWORD PTR [edx+eax+2]
  005fd	89 8d 34 ff ff
	ff		 mov	 DWORD PTR _cy3x0$20[ebp], ecx

; 647  :                     int cy1x1 = (cy0x1 * 1 + cy2x1 * 3 + 2);

  00603	6b 95 40 ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x1$23[ebp], 3
  0060a	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _cy0x1$24[ebp]
  00610	8d 4c 10 02	 lea	 ecx, DWORD PTR [eax+edx+2]
  00614	89 8d 30 ff ff
	ff		 mov	 DWORD PTR _cy1x1$19[ebp], ecx

; 648  :                     int cy3x1 = (cy2x1 * 3 + cy4x1 * 1 + 2);

  0061a	6b 95 40 ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x1$23[ebp], 3
  00621	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _cy4x1$22[ebp]
  00627	8d 4c 02 02	 lea	 ecx, DWORD PTR [edx+eax+2]
  0062b	89 8d 2c ff ff
	ff		 mov	 DWORD PTR _cy3x1$18[ebp], ecx

; 649  :                     CHANGE_BIT_DEPTH_4(cy1x0, cy3x0, cy1x1, cy3x1, 2);

  00631	33 d2		 xor	 edx, edx
  00633	74 3e		 je	 SHORT $LN37@convert_yv
  00635	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x0$21[ebp]
  0063b	c1 e0 f6	 shl	 eax, -10		; fffffff6H
  0063e	89 85 38 ff ff
	ff		 mov	 DWORD PTR _cy1x0$21[ebp], eax
  00644	8b 8d 34 ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x0$20[ebp]
  0064a	c1 e1 f6	 shl	 ecx, -10		; fffffff6H
  0064d	89 8d 34 ff ff
	ff		 mov	 DWORD PTR _cy3x0$20[ebp], ecx
  00653	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x1$19[ebp]
  00659	c1 e2 f6	 shl	 edx, -10		; fffffff6H
  0065c	89 95 30 ff ff
	ff		 mov	 DWORD PTR _cy1x1$19[ebp], edx
  00662	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR _cy3x1$18[ebp]
  00668	c1 e0 f6	 shl	 eax, -10		; fffffff6H
  0066b	89 85 2c ff ff
	ff		 mov	 DWORD PTR _cy3x1$18[ebp], eax
  00671	eb 45		 jmp	 SHORT $LN38@convert_yv
$LN37@convert_yv:
  00673	b9 01 00 00 00	 mov	 ecx, 1
  00678	85 c9		 test	 ecx, ecx
  0067a	74 3c		 je	 SHORT $LN38@convert_yv
  0067c	8b 95 38 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x0$21[ebp]
  00682	c1 fa 0a	 sar	 edx, 10			; 0000000aH
  00685	89 95 38 ff ff
	ff		 mov	 DWORD PTR _cy1x0$21[ebp], edx
  0068b	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$20[ebp]
  00691	c1 f8 0a	 sar	 eax, 10			; 0000000aH
  00694	89 85 34 ff ff
	ff		 mov	 DWORD PTR _cy3x0$20[ebp], eax
  0069a	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x1$19[ebp]
  006a0	c1 f9 0a	 sar	 ecx, 10			; 0000000aH
  006a3	89 8d 30 ff ff
	ff		 mov	 DWORD PTR _cy1x1$19[ebp], ecx
  006a9	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR _cy3x1$18[ebp]
  006af	c1 fa 0a	 sar	 edx, 10			; 0000000aH
  006b2	89 95 2c ff ff
	ff		 mov	 DWORD PTR _cy3x1$18[ebp], edx
$LN38@convert_yv:

; 650  : 
; 651  :                     dstC[0*dst_y_pitch   + 0] = (Tout)cy1x0;

  006b8	6b 45 e4 00	 imul	 eax, DWORD PTR _dst_y_pitch$[ebp], 0
  006bc	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$44[ebp]
  006bf	8a 95 38 ff ff
	ff		 mov	 dl, BYTE PTR _cy1x0$21[ebp]
  006c5	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 652  :                     dstC[0*dst_y_pitch   + 1] = (Tout)((cy1x0 + cy1x1 + 1) >> 1);

  006c8	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x1$19[ebp]
  006ce	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x0$21[ebp]
  006d4	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  006d8	d1 fa		 sar	 edx, 1
  006da	6b 45 e4 00	 imul	 eax, DWORD PTR _dst_y_pitch$[ebp], 0
  006de	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$44[ebp]
  006e1	88 54 01 01	 mov	 BYTE PTR [ecx+eax+1], dl

; 653  :                     dstC[1*dst_y_pitch   + 0] = (Tout)cy3x0;

  006e5	8b 55 94	 mov	 edx, DWORD PTR _dstC$44[ebp]
  006e8	03 55 e4	 add	 edx, DWORD PTR _dst_y_pitch$[ebp]
  006eb	8a 85 34 ff ff
	ff		 mov	 al, BYTE PTR _cy3x0$20[ebp]
  006f1	88 02		 mov	 BYTE PTR [edx], al

; 654  :                     dstC[1*dst_y_pitch   + 1] = (Tout)((cy3x0 + cy3x1 + 1) >> 1);

  006f3	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x1$18[ebp]
  006f9	8b 95 34 ff ff
	ff		 mov	 edx, DWORD PTR _cy3x0$20[ebp]
  006ff	8d 44 0a 01	 lea	 eax, DWORD PTR [edx+ecx+1]
  00703	d1 f8		 sar	 eax, 1
  00705	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$44[ebp]
  00708	03 4d e4	 add	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  0070b	88 41 01	 mov	 BYTE PTR [ecx+1], al

; 655  :                 }

  0070e	e9 ea fd ff ff	 jmp	 $LN17@convert_yv
$LN18@convert_yv:

; 656  :             } else {

  00713	e9 20 02 00 00	 jmp	 $LN31@convert_yv
$LN35@convert_yv:

; 657  :                 for (int x = 0; x < x_fin; x += 2, dstC += 2, srcP++) {

  00718	c7 85 28 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _x$17[ebp], 0
  00722	eb 21		 jmp	 SHORT $LN22@convert_yv
$LN20@convert_yv:
  00724	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR _x$17[ebp]
  0072a	83 c2 02	 add	 edx, 2
  0072d	89 95 28 ff ff
	ff		 mov	 DWORD PTR _x$17[ebp], edx
  00733	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  00736	83 c0 02	 add	 eax, 2
  00739	89 45 94	 mov	 DWORD PTR _dstC$44[ebp], eax
  0073c	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$43[ebp]
  0073f	83 c1 02	 add	 ecx, 2
  00742	89 4d 90	 mov	 DWORD PTR _srcP$43[ebp], ecx
$LN22@convert_yv:
  00745	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR _x$17[ebp]
  0074b	3b 55 8c	 cmp	 edx, DWORD PTR _x_fin$42[ebp]
  0074e	0f 8d e4 01 00
	00		 jge	 $LN31@convert_yv

; 658  :                     int cxplus = (x + 2 < x_fin);

  00754	8b 85 28 ff ff
	ff		 mov	 eax, DWORD PTR _x$17[ebp]
  0075a	83 c0 02	 add	 eax, 2
  0075d	3b 45 8c	 cmp	 eax, DWORD PTR _x_fin$42[ebp]
  00760	7d 0c		 jge	 SHORT $LN48@convert_yv
  00762	c7 85 d4 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv427[ebp], 1
  0076c	eb 0a		 jmp	 SHORT $LN49@convert_yv
$LN48@convert_yv:
  0076e	c7 85 d4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv427[ebp], 0
$LN49@convert_yv:
  00778	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR tv427[ebp]
  0077e	89 8d 24 ff ff
	ff		 mov	 DWORD PTR _cxplus$16[ebp], ecx

; 659  :                     int cy0x0 = srcP[-1*src_uv_pitch + 0];

  00784	6b 55 a8 ff	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], -1
  00788	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  0078b	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  0078f	89 8d 20 ff ff
	ff		 mov	 DWORD PTR _cy0x0$15[ebp], ecx

; 660  :                     int cy2x0 = srcP[ 0*src_uv_pitch + 0];

  00795	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  00799	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  0079c	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  007a0	89 8d 1c ff ff
	ff		 mov	 DWORD PTR _cy2x0$14[ebp], ecx

; 661  :                     int cy4x0 = srcP[ 1*src_uv_pitch + 0];

  007a6	8b 55 a8	 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  007a9	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  007ac	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  007b0	89 8d 18 ff ff
	ff		 mov	 DWORD PTR _cy4x0$13[ebp], ecx

; 662  :                     int cy0x1 = srcP[-1*src_uv_pitch + cxplus];

  007b6	6b 55 a8 ff	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], -1
  007ba	03 95 24 ff ff
	ff		 add	 edx, DWORD PTR _cxplus$16[ebp]
  007c0	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  007c3	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  007c7	89 8d 14 ff ff
	ff		 mov	 DWORD PTR _cy0x1$12[ebp], ecx

; 663  :                     int cy2x1 = srcP[ 0*src_uv_pitch + cxplus];

  007cd	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  007d1	03 95 24 ff ff
	ff		 add	 edx, DWORD PTR _cxplus$16[ebp]
  007d7	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  007da	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  007de	89 8d 10 ff ff
	ff		 mov	 DWORD PTR _cy2x1$11[ebp], ecx

; 664  :                     int cy4x1 = srcP[ 1*src_uv_pitch + cxplus];

  007e4	8b 95 24 ff ff
	ff		 mov	 edx, DWORD PTR _cxplus$16[ebp]
  007ea	03 55 a8	 add	 edx, DWORD PTR _src_uv_pitch$[ebp]
  007ed	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  007f0	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  007f4	89 8d 0c ff ff
	ff		 mov	 DWORD PTR _cy4x1$10[ebp], ecx

; 665  : 
; 666  :                     int cy1x0 = (cy0x0 * 1 + cy2x0 * 3 + 2);

  007fa	6b 95 1c ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x0$14[ebp], 3
  00801	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR _cy0x0$15[ebp]
  00807	8d 4c 10 02	 lea	 ecx, DWORD PTR [eax+edx+2]
  0080b	89 8d 08 ff ff
	ff		 mov	 DWORD PTR _cy1x0$9[ebp], ecx

; 667  :                     int cy3x0 = (cy2x0 * 3 + cy4x0 * 1 + 2);

  00811	6b 95 1c ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x0$14[ebp], 3
  00818	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _cy4x0$13[ebp]
  0081e	8d 4c 02 02	 lea	 ecx, DWORD PTR [edx+eax+2]
  00822	89 8d 04 ff ff
	ff		 mov	 DWORD PTR _cy3x0$8[ebp], ecx

; 668  :                     int cy1x1 = (cy0x1 * 1 + cy2x1 * 3 + 2);

  00828	6b 95 10 ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x1$11[ebp], 3
  0082f	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _cy0x1$12[ebp]
  00835	8d 4c 10 02	 lea	 ecx, DWORD PTR [eax+edx+2]
  00839	89 8d 00 ff ff
	ff		 mov	 DWORD PTR _cy1x1$7[ebp], ecx

; 669  :                     int cy3x1 = (cy2x1 * 3 + cy4x1 * 1 + 2);

  0083f	6b 95 10 ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x1$11[ebp], 3
  00846	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _cy4x1$10[ebp]
  0084c	8d 4c 02 02	 lea	 ecx, DWORD PTR [edx+eax+2]
  00850	89 8d fc fe ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], ecx

; 670  :                     CHANGE_BIT_DEPTH_4(cy1x0, cy3x0, cy1x1, cy3x1, 2);

  00856	33 d2		 xor	 edx, edx
  00858	74 3e		 je	 SHORT $LN40@convert_yv
  0085a	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x0$9[ebp]
  00860	c1 e0 f6	 shl	 eax, -10		; fffffff6H
  00863	89 85 08 ff ff
	ff		 mov	 DWORD PTR _cy1x0$9[ebp], eax
  00869	8b 8d 04 ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x0$8[ebp]
  0086f	c1 e1 f6	 shl	 ecx, -10		; fffffff6H
  00872	89 8d 04 ff ff
	ff		 mov	 DWORD PTR _cy3x0$8[ebp], ecx
  00878	8b 95 00 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x1$7[ebp]
  0087e	c1 e2 f6	 shl	 edx, -10		; fffffff6H
  00881	89 95 00 ff ff
	ff		 mov	 DWORD PTR _cy1x1$7[ebp], edx
  00887	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR _cy3x1$6[ebp]
  0088d	c1 e0 f6	 shl	 eax, -10		; fffffff6H
  00890	89 85 fc fe ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], eax
  00896	eb 45		 jmp	 SHORT $LN41@convert_yv
$LN40@convert_yv:
  00898	b9 01 00 00 00	 mov	 ecx, 1
  0089d	85 c9		 test	 ecx, ecx
  0089f	74 3c		 je	 SHORT $LN41@convert_yv
  008a1	8b 95 08 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x0$9[ebp]
  008a7	c1 fa 0a	 sar	 edx, 10			; 0000000aH
  008aa	89 95 08 ff ff
	ff		 mov	 DWORD PTR _cy1x0$9[ebp], edx
  008b0	8b 85 04 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$8[ebp]
  008b6	c1 f8 0a	 sar	 eax, 10			; 0000000aH
  008b9	89 85 04 ff ff
	ff		 mov	 DWORD PTR _cy3x0$8[ebp], eax
  008bf	8b 8d 00 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x1$7[ebp]
  008c5	c1 f9 0a	 sar	 ecx, 10			; 0000000aH
  008c8	89 8d 00 ff ff
	ff		 mov	 DWORD PTR _cy1x1$7[ebp], ecx
  008ce	8b 95 fc fe ff
	ff		 mov	 edx, DWORD PTR _cy3x1$6[ebp]
  008d4	c1 fa 0a	 sar	 edx, 10			; 0000000aH
  008d7	89 95 fc fe ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], edx
$LN41@convert_yv:

; 671  : 
; 672  :                     dstC[0*dst_y_pitch   + 0] = (Tout)cy1x0;

  008dd	6b 45 e4 00	 imul	 eax, DWORD PTR _dst_y_pitch$[ebp], 0
  008e1	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$44[ebp]
  008e4	8a 95 08 ff ff
	ff		 mov	 dl, BYTE PTR _cy1x0$9[ebp]
  008ea	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 673  :                     dstC[0*dst_y_pitch   + 1] = (Tout)((cy1x0 + cy1x1 + 1) >> 1);

  008ed	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x1$7[ebp]
  008f3	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x0$9[ebp]
  008f9	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  008fd	d1 fa		 sar	 edx, 1
  008ff	6b 45 e4 00	 imul	 eax, DWORD PTR _dst_y_pitch$[ebp], 0
  00903	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$44[ebp]
  00906	88 54 01 01	 mov	 BYTE PTR [ecx+eax+1], dl

; 674  :                     dstC[1*dst_y_pitch   + 0] = (Tout)cy3x0;

  0090a	8b 55 94	 mov	 edx, DWORD PTR _dstC$44[ebp]
  0090d	03 55 e4	 add	 edx, DWORD PTR _dst_y_pitch$[ebp]
  00910	8a 85 04 ff ff
	ff		 mov	 al, BYTE PTR _cy3x0$8[ebp]
  00916	88 02		 mov	 BYTE PTR [edx], al

; 675  :                     dstC[1*dst_y_pitch   + 1] = (Tout)((cy3x0 + cy3x1 + 1) >> 1);

  00918	8b 8d fc fe ff
	ff		 mov	 ecx, DWORD PTR _cy3x1$6[ebp]
  0091e	8b 95 04 ff ff
	ff		 mov	 edx, DWORD PTR _cy3x0$8[ebp]
  00924	8d 44 0a 01	 lea	 eax, DWORD PTR [edx+ecx+1]
  00928	d1 f8		 sar	 eax, 1
  0092a	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$44[ebp]
  0092d	03 4d e4	 add	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  00930	88 41 01	 mov	 BYTE PTR [ecx+1], al

; 676  :                 }

  00933	e9 ec fd ff ff	 jmp	 $LN20@convert_yv
$LN31@convert_yv:

; 677  :             }
; 678  :         }

  00938	e9 52 f9 ff ff	 jmp	 $LN11@convert_yv
$LN12@convert_yv:

; 679  :     }

  0093d	e9 03 f9 ff ff	 jmp	 $LN8@convert_yv
$LN1@convert_yv:

; 680  : }

  00942	52		 push	 edx
  00943	8b cd		 mov	 ecx, ebp
  00945	50		 push	 eax
  00946	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN52@convert_yv
  0094c	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00951	58		 pop	 eax
  00952	5a		 pop	 edx
  00953	5f		 pop	 edi
  00954	5b		 pop	 ebx
  00955	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00958	33 cd		 xor	 ecx, ebp
  0095a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0095f	81 c4 2c 01 00
	00		 add	 esp, 300		; 0000012cH
  00965	3b ec		 cmp	 ebp, esp
  00967	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0096c	8b e5		 mov	 esp, ebp
  0096e	5d		 pop	 ebp
  0096f	c3		 ret	 0
$LN52@convert_yv:
  00970	01 00 00 00	 DD	 1
  00974	00 00 00 00	 DD	 $LN51@convert_yv
$LN51@convert_yv:
  00978	d4 ff ff ff	 DD	 -44			; ffffffd4H
  0097c	0c 00 00 00	 DD	 12			; 0000000cH
  00980	00 00 00 00	 DD	 $LN50@convert_yv
$LN50@convert_yv:
  00984	79		 DB	 121			; 00000079H
  00985	5f		 DB	 95			; 0000005fH
  00986	72		 DB	 114			; 00000072H
  00987	61		 DB	 97			; 00000061H
  00988	6e		 DB	 110			; 0000006eH
  00989	67		 DB	 103			; 00000067H
  0098a	65		 DB	 101			; 00000065H
  0098b	00		 DB	 0
??$convert_yv12_p_to_yuv444_c@G$0BA@E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_p_to_yuv444_c<unsigned short,16,unsigned char,8,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yv12_16_p_to_yuv444@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_16_p_to_yuv444

; 793  : static void convert_yv12_16_p_to_yuv444(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 794  :     convert_yv12_p_to_yuv444_c<uint16_t, 16, uint8_t, 8, false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yv12_p_to_yuv444_c@G$0BA@E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_p_to_yuv444_c<unsigned short,16,unsigned char,8,0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 795  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yv12_16_p_to_yuv444@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_16_p_to_yuv444
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
tv295 = -280						; size = 4
tv233 = -276						; size = 4
tv234 = -272						; size = 4
tv228 = -268						; size = 4
tv225 = -264						; size = 4
tv222 = -260						; size = 4
tv220 = -256						; size = 4
$T1 = -252						; size = 4
$T2 = -248						; size = 4
$T3 = -244						; size = 4
$T4 = -240						; size = 4
$T5 = -236						; size = 12
_cy3x1$6 = -224						; size = 4
_cy2x1$7 = -220						; size = 4
_cy1x1$8 = -216						; size = 4
_cy0x1$9 = -212						; size = 4
_sy5x1$10 = -208					; size = 4
_sy4x1$11 = -204					; size = 4
_sy3x1$12 = -200					; size = 4
_sy2x1$13 = -196					; size = 4
_sy1x1$14 = -192					; size = 4
_sy0x1$15 = -188					; size = 4
_cxplus$16 = -184					; size = 4
_x$17 = -180						; size = 4
_cy3x0$18 = -176					; size = 4
_cy2x0$19 = -172					; size = 4
_cy1x0$20 = -168					; size = 4
_cy0x0$21 = -164					; size = 4
_sy5x0$22 = -160					; size = 4
_sy4x0$23 = -156					; size = 4
_sy3x0$24 = -152					; size = 4
_sy2x0$25 = -148					; size = 4
_sy1x0$26 = -144					; size = 4
_sy0x0$27 = -140					; size = 4
_y_p3$28 = -136						; size = 4
_y_p2$29 = -132						; size = 4
_y_p1$30 = -128						; size = 4
_y_m1$31 = -124						; size = 4
_y_m2$32 = -120						; size = 4
_x_fin$33 = -116					; size = 4
_srcP$34 = -112						; size = 4
_dstC$35 = -108						; size = 4
_y$36 = -104						; size = 4
_dstLine$37 = -100					; size = 4
_srcCLine$38 = -96					; size = 4
_ic$39 = -92						; size = 4
_src_uv_pitch$ = -88					; size = 4
_uv_fin$ = -84						; size = 4
_x$40 = -80						; size = 4
_y$41 = -76						; size = 4
_y_width$42 = -72					; size = 4
_dstLine$43 = -68					; size = 4
_srcYLine$44 = -64					; size = 4
$T45 = -60						; size = 12
_y_range$ = -44						; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yv12_i_to_yuv444_c@E$07G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_i_to_yuv444_c<unsigned char,8,unsigned short,16,0>

; 683  : static void __forceinline convert_yv12_i_to_yuv444_c(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8d bd e8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-280]
  00011	b9 46 00 00 00	 mov	 ecx, 70			; 00000046H
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 684  :     static_assert((sizeof(Tin)  == 1 && in_bit_depth  == 8) || (sizeof(Tin)  == 2 && 8 < in_bit_depth  && in_bit_depth  <= 16), "invalid input bit depth.");
; 685  :     static_assert((sizeof(Tout) == 1 && out_bit_depth == 8) || (sizeof(Tout) == 2 && 8 < out_bit_depth && out_bit_depth <= 16), "invalid output bit depth.");
; 686  :     const int crop_left   = crop[0];

  00027	b8 04 00 00 00	 mov	 eax, 4
  0002c	6b c8 00	 imul	 ecx, eax, 0
  0002f	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00032	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00035	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 687  :     const int crop_up     = crop[1];

  00038	b9 04 00 00 00	 mov	 ecx, 4
  0003d	c1 e1 00	 shl	 ecx, 0
  00040	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00043	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00046	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 688  :     const int crop_right  = crop[2];

  00049	b9 04 00 00 00	 mov	 ecx, 4
  0004e	d1 e1		 shl	 ecx, 1
  00050	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00053	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00056	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 689  :     const int crop_bottom = crop[3];

  00059	b9 04 00 00 00	 mov	 ecx, 4
  0005e	6b d1 03	 imul	 edx, ecx, 3
  00061	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00064	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00067	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 690  :     const int src_y_pitch = src_y_pitch_byte / sizeof(Tin);

  0006a	8b 55 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebp]
  0006d	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 691  :     const int dst_y_pitch = dst_y_pitch_byte / sizeof(Tout);

  00070	8b 45 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  00073	d1 e8		 shr	 eax, 1
  00075	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 692  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00078	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0007b	51		 push	 ecx
  0007c	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0007f	52		 push	 edx
  00080	8b 45 20	 mov	 eax, DWORD PTR _height$[ebp]
  00083	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  00086	50		 push	 eax
  00087	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  0008a	51		 push	 ecx
  0008b	8d 95 14 ff ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  00091	52		 push	 edx
  00092	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00097	83 c4 14	 add	 esp, 20			; 00000014H
  0009a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009c	89 4d c4	 mov	 DWORD PTR $T45[ebp], ecx
  0009f	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a2	89 55 c8	 mov	 DWORD PTR $T45[ebp+4], edx
  000a5	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000a8	89 45 cc	 mov	 DWORD PTR $T45[ebp+8], eax
  000ab	8b 4d c4	 mov	 ecx, DWORD PTR $T45[ebp]
  000ae	89 4d d4	 mov	 DWORD PTR _y_range$[ebp], ecx
  000b1	8b 55 c8	 mov	 edx, DWORD PTR $T45[ebp+4]
  000b4	89 55 d8	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000b7	8b 45 cc	 mov	 eax, DWORD PTR $T45[ebp+8]
  000ba	89 45 dc	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 693  :     //Y
; 694  :     if (!uv_only) {

  000bd	b9 01 00 00 00	 mov	 ecx, 1
  000c2	85 c9		 test	 ecx, ecx
  000c4	0f 84 63 01 00
	00		 je	 $LN17@convert_yv

; 695  :         Tin *srcYLine = (Tin *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000ca	ba 04 00 00 00	 mov	 edx, 4
  000cf	6b c2 00	 imul	 eax, edx, 0
  000d2	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  000d5	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  000d9	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  000dc	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  000df	03 c1		 add	 eax, ecx
  000e1	03 45 f8	 add	 eax, DWORD PTR _crop_left$[ebp]
  000e4	89 45 c0	 mov	 DWORD PTR _srcYLine$44[ebp], eax

; 696  :         Tout *dstLine = (Tout *)dst[0] + dst_y_pitch * y_range.start_dst;

  000e7	b9 04 00 00 00	 mov	 ecx, 4
  000ec	6b d1 00	 imul	 edx, ecx, 0
  000ef	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  000f2	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  000f6	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  000f9	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  000fc	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  000ff	89 45 bc	 mov	 DWORD PTR _dstLine$43[ebp], eax

; 697  :         const int y_width = width - crop_right - crop_left;

  00102	8b 4d 10	 mov	 ecx, DWORD PTR _width$[ebp]
  00105	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  00108	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  0010b	89 4d b8	 mov	 DWORD PTR _y_width$42[ebp], ecx

; 698  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  0010e	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _y$41[ebp], 0
  00115	eb 1e		 jmp	 SHORT $LN4@convert_yv
$LN2@convert_yv:
  00117	8b 55 b4	 mov	 edx, DWORD PTR _y$41[ebp]
  0011a	83 c2 01	 add	 edx, 1
  0011d	89 55 b4	 mov	 DWORD PTR _y$41[ebp], edx
  00120	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$44[ebp]
  00123	03 45 e8	 add	 eax, DWORD PTR _src_y_pitch$[ebp]
  00126	89 45 c0	 mov	 DWORD PTR _srcYLine$44[ebp], eax
  00129	8b 4d e4	 mov	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  0012c	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$43[ebp]
  0012f	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  00132	89 45 bc	 mov	 DWORD PTR _dstLine$43[ebp], eax
$LN4@convert_yv:
  00135	8b 4d b4	 mov	 ecx, DWORD PTR _y$41[ebp]
  00138	3b 4d dc	 cmp	 ecx, DWORD PTR _y_range$[ebp+8]
  0013b	0f 8d ec 00 00
	00		 jge	 $LN17@convert_yv

; 699  :             if (in_bit_depth == out_bit_depth) {

  00141	33 d2		 xor	 edx, edx
  00143	74 19		 je	 SHORT $LN18@convert_yv

; 700  :                 memcpy(dstLine, srcYLine, y_width * sizeof(Tin));

  00145	8b 45 b8	 mov	 eax, DWORD PTR _y_width$42[ebp]
  00148	50		 push	 eax
  00149	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$44[ebp]
  0014c	51		 push	 ecx
  0014d	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$43[ebp]
  00150	52		 push	 edx
  00151	e8 00 00 00 00	 call	 _memcpy
  00156	83 c4 0c	 add	 esp, 12			; 0000000cH

; 701  :             } else {

  00159	e9 ca 00 00 00	 jmp	 $LN19@convert_yv
$LN18@convert_yv:

; 702  :                 for (int x = 0; x < y_width; x++) {

  0015e	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _x$40[ebp], 0
  00165	eb 09		 jmp	 SHORT $LN7@convert_yv
$LN5@convert_yv:
  00167	8b 45 b0	 mov	 eax, DWORD PTR _x$40[ebp]
  0016a	83 c0 01	 add	 eax, 1
  0016d	89 45 b0	 mov	 DWORD PTR _x$40[ebp], eax
$LN7@convert_yv:
  00170	8b 4d b0	 mov	 ecx, DWORD PTR _x$40[ebp]
  00173	3b 4d b8	 cmp	 ecx, DWORD PTR _y_width$42[ebp]
  00176	0f 8d ac 00 00
	00		 jge	 $LN19@convert_yv

; 703  :                     if (out_bit_depth > in_bit_depth) {

  0017c	ba 01 00 00 00	 mov	 edx, 1
  00181	85 d2		 test	 edx, edx
  00183	74 43		 je	 SHORT $LN20@convert_yv

; 704  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) << std::max(out_bit_depth - in_bit_depth, 0));

  00185	c7 85 10 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], 0
  0018f	c7 85 0c ff ff
	ff 08 00 00 00	 mov	 DWORD PTR $T3[ebp], 8
  00199	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$44[ebp]
  0019c	03 45 b0	 add	 eax, DWORD PTR _x$40[ebp]
  0019f	0f b6 30	 movzx	 esi, BYTE PTR [eax]
  001a2	8d 8d 10 ff ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  001a8	51		 push	 ecx
  001a9	8d 95 0c ff ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  001af	52		 push	 edx
  001b0	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  001b5	83 c4 08	 add	 esp, 8
  001b8	8b 08		 mov	 ecx, DWORD PTR [eax]
  001ba	d3 e6		 shl	 esi, cl
  001bc	8b 45 b0	 mov	 eax, DWORD PTR _x$40[ebp]
  001bf	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$43[ebp]
  001c2	66 89 34 41	 mov	 WORD PTR [ecx+eax*2], si
  001c6	eb 5b		 jmp	 SHORT $LN21@convert_yv
$LN20@convert_yv:

; 705  :                     } else if (out_bit_depth < in_bit_depth) {

  001c8	33 d2		 xor	 edx, edx
  001ca	74 43		 je	 SHORT $LN22@convert_yv

; 706  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) >> std::max(in_bit_depth - out_bit_depth, 0));

  001cc	c7 85 08 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], 0
  001d6	c7 85 04 ff ff
	ff f8 ff ff ff	 mov	 DWORD PTR $T1[ebp], -8	; fffffff8H
  001e0	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$44[ebp]
  001e3	03 45 b0	 add	 eax, DWORD PTR _x$40[ebp]
  001e6	0f b6 30	 movzx	 esi, BYTE PTR [eax]
  001e9	8d 8d 08 ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  001ef	51		 push	 ecx
  001f0	8d 95 04 ff ff
	ff		 lea	 edx, DWORD PTR $T1[ebp]
  001f6	52		 push	 edx
  001f7	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  001fc	83 c4 08	 add	 esp, 8
  001ff	8b 08		 mov	 ecx, DWORD PTR [eax]
  00201	d3 fe		 sar	 esi, cl
  00203	8b 45 b0	 mov	 eax, DWORD PTR _x$40[ebp]
  00206	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$43[ebp]
  00209	66 89 34 41	 mov	 WORD PTR [ecx+eax*2], si

; 707  :                     } else {

  0020d	eb 14		 jmp	 SHORT $LN21@convert_yv
$LN22@convert_yv:

; 708  :                         dstLine[x] = (Tout)srcYLine[x];

  0020f	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$44[ebp]
  00212	03 55 b0	 add	 edx, DWORD PTR _x$40[ebp]
  00215	66 0f b6 02	 movzx	 ax, BYTE PTR [edx]
  00219	8b 4d b0	 mov	 ecx, DWORD PTR _x$40[ebp]
  0021c	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$43[ebp]
  0021f	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax
$LN21@convert_yv:

; 709  :                     }
; 710  :                 }

  00223	e9 3f ff ff ff	 jmp	 $LN5@convert_yv
$LN19@convert_yv:

; 711  :             }
; 712  :         }

  00228	e9 ea fe ff ff	 jmp	 $LN2@convert_yv
$LN17@convert_yv:

; 713  :     }
; 714  :     //UV
; 715  :     const int uv_fin = height - crop_bottom;

  0022d	8b 45 20	 mov	 eax, DWORD PTR _height$[ebp]
  00230	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  00233	89 45 ac	 mov	 DWORD PTR _uv_fin$[ebp], eax

; 716  :     const int src_uv_pitch = src_uv_pitch_byte / sizeof(Tin);

  00236	8b 4d 18	 mov	 ecx, DWORD PTR _src_uv_pitch_byte$[ebp]
  00239	89 4d a8	 mov	 DWORD PTR _src_uv_pitch$[ebp], ecx

; 717  :     for (int ic = 1; ic < 3; ic++) {

  0023c	c7 45 a4 01 00
	00 00		 mov	 DWORD PTR _ic$39[ebp], 1
  00243	eb 09		 jmp	 SHORT $LN10@convert_yv
$LN8@convert_yv:
  00245	8b 55 a4	 mov	 edx, DWORD PTR _ic$39[ebp]
  00248	83 c2 01	 add	 edx, 1
  0024b	89 55 a4	 mov	 DWORD PTR _ic$39[ebp], edx
$LN10@convert_yv:
  0024e	83 7d a4 03	 cmp	 DWORD PTR _ic$39[ebp], 3
  00252	0f 8d bf 05 00
	00		 jge	 $LN1@convert_yv

; 718  :         Tin *srcCLine = (Tin *)src[ic] + (((src_uv_pitch * y_range.start_src) + crop_left) >> 1);

  00258	8b 45 a8	 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  0025b	0f af 45 d4	 imul	 eax, DWORD PTR _y_range$[ebp]
  0025f	03 45 f8	 add	 eax, DWORD PTR _crop_left$[ebp]
  00262	d1 f8		 sar	 eax, 1
  00264	8b 4d a4	 mov	 ecx, DWORD PTR _ic$39[ebp]
  00267	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  0026a	03 04 8a	 add	 eax, DWORD PTR [edx+ecx*4]
  0026d	89 45 a0	 mov	 DWORD PTR _srcCLine$38[ebp], eax

; 719  :         Tout *dstLine = (Tout *)dst[ic] + dst_y_pitch * y_range.start_dst;

  00270	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  00273	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  00277	8b 4d a4	 mov	 ecx, DWORD PTR _ic$39[ebp]
  0027a	8b 55 08	 mov	 edx, DWORD PTR _dst$[ebp]
  0027d	8b 0c 8a	 mov	 ecx, DWORD PTR [edx+ecx*4]
  00280	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00283	89 55 9c	 mov	 DWORD PTR _dstLine$37[ebp], edx

; 720  :         for (int y = 0; y < y_range.len; y += 4, srcCLine += src_uv_pitch * 2, dstLine += dst_y_pitch * 4) {

  00286	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _y$36[ebp], 0
  0028d	eb 24		 jmp	 SHORT $LN13@convert_yv
$LN11@convert_yv:
  0028f	8b 45 98	 mov	 eax, DWORD PTR _y$36[ebp]
  00292	83 c0 04	 add	 eax, 4
  00295	89 45 98	 mov	 DWORD PTR _y$36[ebp], eax
  00298	8b 4d a8	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  0029b	8b 55 a0	 mov	 edx, DWORD PTR _srcCLine$38[ebp]
  0029e	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  002a1	89 45 a0	 mov	 DWORD PTR _srcCLine$38[ebp], eax
  002a4	8b 4d e4	 mov	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  002a7	c1 e1 02	 shl	 ecx, 2
  002aa	8b 55 9c	 mov	 edx, DWORD PTR _dstLine$37[ebp]
  002ad	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  002b0	89 45 9c	 mov	 DWORD PTR _dstLine$37[ebp], eax
$LN13@convert_yv:
  002b3	8b 4d 98	 mov	 ecx, DWORD PTR _y$36[ebp]
  002b6	3b 4d dc	 cmp	 ecx, DWORD PTR _y_range$[ebp+8]
  002b9	0f 8d 53 05 00
	00		 jge	 $LN12@convert_yv

; 721  :             Tout *dstC = dstLine;

  002bf	8b 55 9c	 mov	 edx, DWORD PTR _dstLine$37[ebp]
  002c2	89 55 94	 mov	 DWORD PTR _dstC$35[ebp], edx

; 722  :             Tin *srcP = srcCLine;

  002c5	8b 45 a0	 mov	 eax, DWORD PTR _srcCLine$38[ebp]
  002c8	89 45 90	 mov	 DWORD PTR _srcP$34[ebp], eax

; 723  :             const int x_fin = width - crop_right - crop_left;

  002cb	8b 4d 10	 mov	 ecx, DWORD PTR _width$[ebp]
  002ce	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  002d1	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  002d4	89 4d 8c	 mov	 DWORD PTR _x_fin$33[ebp], ecx

; 724  : 
; 725  :             int y_m2 = (y >= 4) ? -2 : 0;

  002d7	83 7d 98 04	 cmp	 DWORD PTR _y$36[ebp], 4
  002db	7c 0c		 jl	 SHORT $LN31@convert_yv
  002dd	c7 85 00 ff ff
	ff fe ff ff ff	 mov	 DWORD PTR tv220[ebp], -2 ; fffffffeH
  002e7	eb 0a		 jmp	 SHORT $LN32@convert_yv
$LN31@convert_yv:
  002e9	c7 85 00 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv220[ebp], 0
$LN32@convert_yv:
  002f3	8b 95 00 ff ff
	ff		 mov	 edx, DWORD PTR tv220[ebp]
  002f9	89 55 88	 mov	 DWORD PTR _y_m2$32[ebp], edx

; 726  :             int y_m1 = (y >= 2) ? -1 : 1;

  002fc	83 7d 98 02	 cmp	 DWORD PTR _y$36[ebp], 2
  00300	7c 0c		 jl	 SHORT $LN33@convert_yv
  00302	c7 85 fc fe ff
	ff ff ff ff ff	 mov	 DWORD PTR tv222[ebp], -1
  0030c	eb 0a		 jmp	 SHORT $LN34@convert_yv
$LN33@convert_yv:
  0030e	c7 85 fc fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv222[ebp], 1
$LN34@convert_yv:
  00318	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR tv222[ebp]
  0031e	89 45 84	 mov	 DWORD PTR _y_m1$31[ebp], eax

; 727  :             int y_p1 = (y < uv_fin - 2) ? 1 : -1;

  00321	8b 4d ac	 mov	 ecx, DWORD PTR _uv_fin$[ebp]
  00324	83 e9 02	 sub	 ecx, 2
  00327	39 4d 98	 cmp	 DWORD PTR _y$36[ebp], ecx
  0032a	7d 0c		 jge	 SHORT $LN35@convert_yv
  0032c	c7 85 f8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv225[ebp], 1
  00336	eb 0a		 jmp	 SHORT $LN36@convert_yv
$LN35@convert_yv:
  00338	c7 85 f8 fe ff
	ff ff ff ff ff	 mov	 DWORD PTR tv225[ebp], -1
$LN36@convert_yv:
  00342	8b 95 f8 fe ff
	ff		 mov	 edx, DWORD PTR tv225[ebp]
  00348	89 55 80	 mov	 DWORD PTR _y_p1$30[ebp], edx

; 728  :             int y_p2 = (y < uv_fin - 4) ? 2 :  0;

  0034b	8b 45 ac	 mov	 eax, DWORD PTR _uv_fin$[ebp]
  0034e	83 e8 04	 sub	 eax, 4
  00351	39 45 98	 cmp	 DWORD PTR _y$36[ebp], eax
  00354	7d 0c		 jge	 SHORT $LN37@convert_yv
  00356	c7 85 f4 fe ff
	ff 02 00 00 00	 mov	 DWORD PTR tv228[ebp], 2
  00360	eb 0a		 jmp	 SHORT $LN38@convert_yv
$LN37@convert_yv:
  00362	c7 85 f4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv228[ebp], 0
$LN38@convert_yv:
  0036c	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR tv228[ebp]
  00372	89 8d 7c ff ff
	ff		 mov	 DWORD PTR _y_p2$29[ebp], ecx

; 729  :             int y_p3 = (y < uv_fin - 6) ? 3 : ((y < uv_fin - 2) ? 1 : -1);

  00378	8b 55 ac	 mov	 edx, DWORD PTR _uv_fin$[ebp]
  0037b	83 ea 06	 sub	 edx, 6
  0037e	39 55 98	 cmp	 DWORD PTR _y$36[ebp], edx
  00381	7d 0c		 jge	 SHORT $LN41@convert_yv
  00383	c7 85 f0 fe ff
	ff 03 00 00 00	 mov	 DWORD PTR tv234[ebp], 3
  0038d	eb 2d		 jmp	 SHORT $LN42@convert_yv
$LN41@convert_yv:
  0038f	8b 45 ac	 mov	 eax, DWORD PTR _uv_fin$[ebp]
  00392	83 e8 02	 sub	 eax, 2
  00395	39 45 98	 cmp	 DWORD PTR _y$36[ebp], eax
  00398	7d 0c		 jge	 SHORT $LN39@convert_yv
  0039a	c7 85 ec fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv233[ebp], 1
  003a4	eb 0a		 jmp	 SHORT $LN40@convert_yv
$LN39@convert_yv:
  003a6	c7 85 ec fe ff
	ff ff ff ff ff	 mov	 DWORD PTR tv233[ebp], -1
$LN40@convert_yv:
  003b0	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR tv233[ebp]
  003b6	89 8d f0 fe ff
	ff		 mov	 DWORD PTR tv234[ebp], ecx
$LN42@convert_yv:
  003bc	8b 95 f0 fe ff
	ff		 mov	 edx, DWORD PTR tv234[ebp]
  003c2	89 95 78 ff ff
	ff		 mov	 DWORD PTR _y_p3$28[ebp], edx

; 730  : 
; 731  :             int sy0x0 = srcP[y_m2*src_uv_pitch + 0];

  003c8	8b 45 88	 mov	 eax, DWORD PTR _y_m2$32[ebp]
  003cb	0f af 45 a8	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp]
  003cf	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  003d2	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  003d6	89 95 74 ff ff
	ff		 mov	 DWORD PTR _sy0x0$27[ebp], edx

; 732  :             int sy1x0 = srcP[y_m1*src_uv_pitch + 0];

  003dc	8b 45 84	 mov	 eax, DWORD PTR _y_m1$31[ebp]
  003df	0f af 45 a8	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp]
  003e3	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  003e6	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  003ea	89 95 70 ff ff
	ff		 mov	 DWORD PTR _sy1x0$26[ebp], edx

; 733  :             int sy2x0 = srcP[   0*src_uv_pitch + 0];

  003f0	6b 45 a8 00	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp], 0
  003f4	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  003f7	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  003fb	89 95 6c ff ff
	ff		 mov	 DWORD PTR _sy2x0$25[ebp], edx

; 734  :             int sy3x0 = srcP[y_p1*src_uv_pitch + 0];

  00401	8b 45 80	 mov	 eax, DWORD PTR _y_p1$30[ebp]
  00404	0f af 45 a8	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp]
  00408	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  0040b	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  0040f	89 95 68 ff ff
	ff		 mov	 DWORD PTR _sy3x0$24[ebp], edx

; 735  :             int sy4x0 = srcP[y_p2*src_uv_pitch + 0];

  00415	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _y_p2$29[ebp]
  0041b	0f af 45 a8	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp]
  0041f	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  00422	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00426	89 95 64 ff ff
	ff		 mov	 DWORD PTR _sy4x0$23[ebp], edx

; 736  :             int sy5x0 = srcP[y_p3*src_uv_pitch + 0];

  0042c	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _y_p3$28[ebp]
  00432	0f af 45 a8	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp]
  00436	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  00439	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  0043d	89 95 60 ff ff
	ff		 mov	 DWORD PTR _sy5x0$22[ebp], edx

; 737  : 
; 738  :             int cy0x0 = (sy0x0 * 1 + sy2x0 * 7 + 4);

  00443	6b 85 6c ff ff
	ff 07		 imul	 eax, DWORD PTR _sy2x0$25[ebp], 7
  0044a	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _sy0x0$27[ebp]
  00450	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00454	89 95 5c ff ff
	ff		 mov	 DWORD PTR _cy0x0$21[ebp], edx

; 739  :             int cy1x0 = (sy1x0 * 3 + sy3x0 * 5 + 4);

  0045a	6b 85 70 ff ff
	ff 03		 imul	 eax, DWORD PTR _sy1x0$26[ebp], 3
  00461	6b 8d 68 ff ff
	ff 05		 imul	 ecx, DWORD PTR _sy3x0$24[ebp], 5
  00468	8d 54 08 04	 lea	 edx, DWORD PTR [eax+ecx+4]
  0046c	89 95 58 ff ff
	ff		 mov	 DWORD PTR _cy1x0$20[ebp], edx

; 740  :             int cy2x0 = (sy2x0 * 5 + sy4x0 * 3 + 4);

  00472	6b 85 6c ff ff
	ff 05		 imul	 eax, DWORD PTR _sy2x0$25[ebp], 5
  00479	6b 8d 64 ff ff
	ff 03		 imul	 ecx, DWORD PTR _sy4x0$23[ebp], 3
  00480	8d 54 08 04	 lea	 edx, DWORD PTR [eax+ecx+4]
  00484	89 95 54 ff ff
	ff		 mov	 DWORD PTR _cy2x0$19[ebp], edx

; 741  :             int cy3x0 = (sy3x0 * 7 + sy5x0 * 1 + 4);

  0048a	6b 85 68 ff ff
	ff 07		 imul	 eax, DWORD PTR _sy3x0$24[ebp], 7
  00491	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _sy5x0$22[ebp]
  00497	8d 54 08 04	 lea	 edx, DWORD PTR [eax+ecx+4]
  0049b	89 95 50 ff ff
	ff		 mov	 DWORD PTR _cy3x0$18[ebp], edx

; 742  :             CHANGE_BIT_DEPTH_4(cy0x0, cy1x0, cy2x0, cy3x0, 3);

  004a1	b8 01 00 00 00	 mov	 eax, 1
  004a6	85 c0		 test	 eax, eax
  004a8	74 3e		 je	 SHORT $LN24@convert_yv
  004aa	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _cy0x0$21[ebp]
  004b0	c1 e1 05	 shl	 ecx, 5
  004b3	89 8d 5c ff ff
	ff		 mov	 DWORD PTR _cy0x0$21[ebp], ecx
  004b9	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x0$20[ebp]
  004bf	c1 e2 05	 shl	 edx, 5
  004c2	89 95 58 ff ff
	ff		 mov	 DWORD PTR _cy1x0$20[ebp], edx
  004c8	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR _cy2x0$19[ebp]
  004ce	c1 e0 05	 shl	 eax, 5
  004d1	89 85 54 ff ff
	ff		 mov	 DWORD PTR _cy2x0$19[ebp], eax
  004d7	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x0$18[ebp]
  004dd	c1 e1 05	 shl	 ecx, 5
  004e0	89 8d 50 ff ff
	ff		 mov	 DWORD PTR _cy3x0$18[ebp], ecx
  004e6	eb 40		 jmp	 SHORT $LN25@convert_yv
$LN24@convert_yv:
  004e8	33 d2		 xor	 edx, edx
  004ea	74 3c		 je	 SHORT $LN25@convert_yv
  004ec	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _cy0x0$21[ebp]
  004f2	c1 f8 fb	 sar	 eax, -5			; fffffffbH
  004f5	89 85 5c ff ff
	ff		 mov	 DWORD PTR _cy0x0$21[ebp], eax
  004fb	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x0$20[ebp]
  00501	c1 f9 fb	 sar	 ecx, -5			; fffffffbH
  00504	89 8d 58 ff ff
	ff		 mov	 DWORD PTR _cy1x0$20[ebp], ecx
  0050a	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR _cy2x0$19[ebp]
  00510	c1 fa fb	 sar	 edx, -5			; fffffffbH
  00513	89 95 54 ff ff
	ff		 mov	 DWORD PTR _cy2x0$19[ebp], edx
  00519	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$18[ebp]
  0051f	c1 f8 fb	 sar	 eax, -5			; fffffffbH
  00522	89 85 50 ff ff
	ff		 mov	 DWORD PTR _cy3x0$18[ebp], eax
$LN25@convert_yv:

; 743  : 
; 744  :             for (int x = 0; x < x_fin; x += 2, dstC += 2, srcP++) {

  00528	c7 85 4c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _x$17[ebp], 0
  00532	eb 21		 jmp	 SHORT $LN16@convert_yv
$LN14@convert_yv:
  00534	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _x$17[ebp]
  0053a	83 c1 02	 add	 ecx, 2
  0053d	89 8d 4c ff ff
	ff		 mov	 DWORD PTR _x$17[ebp], ecx
  00543	8b 55 94	 mov	 edx, DWORD PTR _dstC$35[ebp]
  00546	83 c2 04	 add	 edx, 4
  00549	89 55 94	 mov	 DWORD PTR _dstC$35[ebp], edx
  0054c	8b 45 90	 mov	 eax, DWORD PTR _srcP$34[ebp]
  0054f	83 c0 01	 add	 eax, 1
  00552	89 45 90	 mov	 DWORD PTR _srcP$34[ebp], eax
$LN16@convert_yv:
  00555	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _x$17[ebp]
  0055b	3b 4d 8c	 cmp	 ecx, DWORD PTR _x_fin$33[ebp]
  0055e	0f 8d a9 02 00
	00		 jge	 $LN15@convert_yv

; 745  :                 int cxplus = (x + 2 < x_fin);

  00564	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR _x$17[ebp]
  0056a	83 c2 02	 add	 edx, 2
  0056d	3b 55 8c	 cmp	 edx, DWORD PTR _x_fin$33[ebp]
  00570	7d 0c		 jge	 SHORT $LN43@convert_yv
  00572	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv295[ebp], 1
  0057c	eb 0a		 jmp	 SHORT $LN44@convert_yv
$LN43@convert_yv:
  0057e	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv295[ebp], 0
$LN44@convert_yv:
  00588	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv295[ebp]
  0058e	89 85 48 ff ff
	ff		 mov	 DWORD PTR _cxplus$16[ebp], eax

; 746  :                 int sy0x1 = srcP[y_m2*src_uv_pitch + cxplus];

  00594	8b 4d 88	 mov	 ecx, DWORD PTR _y_m2$32[ebp]
  00597	0f af 4d a8	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  0059b	03 8d 48 ff ff
	ff		 add	 ecx, DWORD PTR _cxplus$16[ebp]
  005a1	8b 55 90	 mov	 edx, DWORD PTR _srcP$34[ebp]
  005a4	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  005a8	89 85 44 ff ff
	ff		 mov	 DWORD PTR _sy0x1$15[ebp], eax

; 747  :                 int sy1x1 = srcP[y_m1*src_uv_pitch + cxplus];

  005ae	8b 4d 84	 mov	 ecx, DWORD PTR _y_m1$31[ebp]
  005b1	0f af 4d a8	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  005b5	03 8d 48 ff ff
	ff		 add	 ecx, DWORD PTR _cxplus$16[ebp]
  005bb	8b 55 90	 mov	 edx, DWORD PTR _srcP$34[ebp]
  005be	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  005c2	89 85 40 ff ff
	ff		 mov	 DWORD PTR _sy1x1$14[ebp], eax

; 748  :                 int sy2x1 = srcP[   0*src_uv_pitch + cxplus];

  005c8	6b 4d a8 00	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 0
  005cc	03 8d 48 ff ff
	ff		 add	 ecx, DWORD PTR _cxplus$16[ebp]
  005d2	8b 55 90	 mov	 edx, DWORD PTR _srcP$34[ebp]
  005d5	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  005d9	89 85 3c ff ff
	ff		 mov	 DWORD PTR _sy2x1$13[ebp], eax

; 749  :                 int sy3x1 = srcP[y_p1*src_uv_pitch + cxplus];

  005df	8b 4d 80	 mov	 ecx, DWORD PTR _y_p1$30[ebp]
  005e2	0f af 4d a8	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  005e6	03 8d 48 ff ff
	ff		 add	 ecx, DWORD PTR _cxplus$16[ebp]
  005ec	8b 55 90	 mov	 edx, DWORD PTR _srcP$34[ebp]
  005ef	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  005f3	89 85 38 ff ff
	ff		 mov	 DWORD PTR _sy3x1$12[ebp], eax

; 750  :                 int sy4x1 = srcP[y_p2*src_uv_pitch + cxplus];

  005f9	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _y_p2$29[ebp]
  005ff	0f af 4d a8	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00603	03 8d 48 ff ff
	ff		 add	 ecx, DWORD PTR _cxplus$16[ebp]
  00609	8b 55 90	 mov	 edx, DWORD PTR _srcP$34[ebp]
  0060c	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  00610	89 85 34 ff ff
	ff		 mov	 DWORD PTR _sy4x1$11[ebp], eax

; 751  :                 int sy5x1 = srcP[y_p3*src_uv_pitch + cxplus];

  00616	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _y_p3$28[ebp]
  0061c	0f af 4d a8	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00620	03 8d 48 ff ff
	ff		 add	 ecx, DWORD PTR _cxplus$16[ebp]
  00626	8b 55 90	 mov	 edx, DWORD PTR _srcP$34[ebp]
  00629	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  0062d	89 85 30 ff ff
	ff		 mov	 DWORD PTR _sy5x1$10[ebp], eax

; 752  : 
; 753  :                 int cy0x1 = (sy0x1 * 1 + sy2x1 * 7 + 4);

  00633	6b 8d 3c ff ff
	ff 07		 imul	 ecx, DWORD PTR _sy2x1$13[ebp], 7
  0063a	8b 95 44 ff ff
	ff		 mov	 edx, DWORD PTR _sy0x1$15[ebp]
  00640	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  00644	89 85 2c ff ff
	ff		 mov	 DWORD PTR _cy0x1$9[ebp], eax

; 754  :                 int cy1x1 = (sy1x1 * 3 + sy3x1 * 5 + 4);

  0064a	6b 8d 40 ff ff
	ff 03		 imul	 ecx, DWORD PTR _sy1x1$14[ebp], 3
  00651	6b 95 38 ff ff
	ff 05		 imul	 edx, DWORD PTR _sy3x1$12[ebp], 5
  00658	8d 44 11 04	 lea	 eax, DWORD PTR [ecx+edx+4]
  0065c	89 85 28 ff ff
	ff		 mov	 DWORD PTR _cy1x1$8[ebp], eax

; 755  :                 int cy2x1 = (sy2x1 * 5 + sy4x1 * 3 + 4);

  00662	6b 8d 3c ff ff
	ff 05		 imul	 ecx, DWORD PTR _sy2x1$13[ebp], 5
  00669	6b 95 34 ff ff
	ff 03		 imul	 edx, DWORD PTR _sy4x1$11[ebp], 3
  00670	8d 44 11 04	 lea	 eax, DWORD PTR [ecx+edx+4]
  00674	89 85 24 ff ff
	ff		 mov	 DWORD PTR _cy2x1$7[ebp], eax

; 756  :                 int cy3x1 = (sy3x1 * 7 + sy5x1 * 1 + 4);

  0067a	6b 8d 38 ff ff
	ff 07		 imul	 ecx, DWORD PTR _sy3x1$12[ebp], 7
  00681	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR _sy5x1$10[ebp]
  00687	8d 44 11 04	 lea	 eax, DWORD PTR [ecx+edx+4]
  0068b	89 85 20 ff ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], eax

; 757  :                 CHANGE_BIT_DEPTH_4(cy0x1, cy1x1, cy2x1, cy3x1, 3);

  00691	b9 01 00 00 00	 mov	 ecx, 1
  00696	85 c9		 test	 ecx, ecx
  00698	74 3e		 je	 SHORT $LN27@convert_yv
  0069a	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR _cy0x1$9[ebp]
  006a0	c1 e2 05	 shl	 edx, 5
  006a3	89 95 2c ff ff
	ff		 mov	 DWORD PTR _cy0x1$9[ebp], edx
  006a9	8b 85 28 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x1$8[ebp]
  006af	c1 e0 05	 shl	 eax, 5
  006b2	89 85 28 ff ff
	ff		 mov	 DWORD PTR _cy1x1$8[ebp], eax
  006b8	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR _cy2x1$7[ebp]
  006be	c1 e1 05	 shl	 ecx, 5
  006c1	89 8d 24 ff ff
	ff		 mov	 DWORD PTR _cy2x1$7[ebp], ecx
  006c7	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR _cy3x1$6[ebp]
  006cd	c1 e2 05	 shl	 edx, 5
  006d0	89 95 20 ff ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], edx
  006d6	eb 40		 jmp	 SHORT $LN28@convert_yv
$LN27@convert_yv:
  006d8	33 c0		 xor	 eax, eax
  006da	74 3c		 je	 SHORT $LN28@convert_yv
  006dc	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR _cy0x1$9[ebp]
  006e2	c1 f9 fb	 sar	 ecx, -5			; fffffffbH
  006e5	89 8d 2c ff ff
	ff		 mov	 DWORD PTR _cy0x1$9[ebp], ecx
  006eb	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x1$8[ebp]
  006f1	c1 fa fb	 sar	 edx, -5			; fffffffbH
  006f4	89 95 28 ff ff
	ff		 mov	 DWORD PTR _cy1x1$8[ebp], edx
  006fa	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _cy2x1$7[ebp]
  00700	c1 f8 fb	 sar	 eax, -5			; fffffffbH
  00703	89 85 24 ff ff
	ff		 mov	 DWORD PTR _cy2x1$7[ebp], eax
  00709	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x1$6[ebp]
  0070f	c1 f9 fb	 sar	 ecx, -5			; fffffffbH
  00712	89 8d 20 ff ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], ecx
$LN28@convert_yv:

; 758  : 
; 759  :                 dstC[0*dst_y_pitch   + 0] = (Tout)cy0x0;

  00718	6b 55 e4 00	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 0
  0071c	8b 45 94	 mov	 eax, DWORD PTR _dstC$35[ebp]
  0071f	66 8b 8d 5c ff
	ff ff		 mov	 cx, WORD PTR _cy0x0$21[ebp]
  00726	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx

; 760  :                 dstC[0*dst_y_pitch   + 1] = (Tout)((cy0x0 + cy0x1 + 1) >> 1);

  0072a	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR _cy0x1$9[ebp]
  00730	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _cy0x0$21[ebp]
  00736	8d 4c 10 01	 lea	 ecx, DWORD PTR [eax+edx+1]
  0073a	d1 f9		 sar	 ecx, 1
  0073c	6b 55 e4 00	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 0
  00740	8b 45 94	 mov	 eax, DWORD PTR _dstC$35[ebp]
  00743	66 89 4c 50 02	 mov	 WORD PTR [eax+edx*2+2], cx

; 761  :                 dstC[1*dst_y_pitch   + 0] = (Tout)cy1x0;

  00748	8b 4d e4	 mov	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  0074b	8b 55 94	 mov	 edx, DWORD PTR _dstC$35[ebp]
  0074e	66 8b 85 58 ff
	ff ff		 mov	 ax, WORD PTR _cy1x0$20[ebp]
  00755	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax

; 762  :                 dstC[1*dst_y_pitch   + 1] = (Tout)((cy1x0 + cy1x1 + 1) >> 1);

  00759	8b 8d 28 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x1$8[ebp]
  0075f	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x0$20[ebp]
  00765	8d 44 0a 01	 lea	 eax, DWORD PTR [edx+ecx+1]
  00769	d1 f8		 sar	 eax, 1
  0076b	8b 4d e4	 mov	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  0076e	8b 55 94	 mov	 edx, DWORD PTR _dstC$35[ebp]
  00771	66 89 44 4a 02	 mov	 WORD PTR [edx+ecx*2+2], ax

; 763  :                 dstC[2*dst_y_pitch   + 0] = (Tout)cy2x0;

  00776	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  00779	d1 e0		 shl	 eax, 1
  0077b	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$35[ebp]
  0077e	66 8b 95 54 ff
	ff ff		 mov	 dx, WORD PTR _cy2x0$19[ebp]
  00785	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx

; 764  :                 dstC[2*dst_y_pitch   + 1] = (Tout)((cy2x0 + cy2x1 + 1) >> 1);

  00789	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _cy2x1$7[ebp]
  0078f	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _cy2x0$19[ebp]
  00795	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  00799	d1 fa		 sar	 edx, 1
  0079b	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  0079e	d1 e0		 shl	 eax, 1
  007a0	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$35[ebp]
  007a3	66 89 54 41 02	 mov	 WORD PTR [ecx+eax*2+2], dx

; 765  :                 dstC[3*dst_y_pitch   + 0] = (Tout)cy3x0;

  007a8	6b 55 e4 03	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 3
  007ac	8b 45 94	 mov	 eax, DWORD PTR _dstC$35[ebp]
  007af	66 8b 8d 50 ff
	ff ff		 mov	 cx, WORD PTR _cy3x0$18[ebp]
  007b6	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx

; 766  :                 dstC[3*dst_y_pitch   + 1] = (Tout)((cy3x0 + cy3x1 + 1) >> 1);

  007ba	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR _cy3x1$6[ebp]
  007c0	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$18[ebp]
  007c6	8d 4c 10 01	 lea	 ecx, DWORD PTR [eax+edx+1]
  007ca	d1 f9		 sar	 ecx, 1
  007cc	6b 55 e4 03	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 3
  007d0	8b 45 94	 mov	 eax, DWORD PTR _dstC$35[ebp]
  007d3	66 89 4c 50 02	 mov	 WORD PTR [eax+edx*2+2], cx

; 767  : 
; 768  :                 cy0x0 = cy0x1;

  007d8	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR _cy0x1$9[ebp]
  007de	89 8d 5c ff ff
	ff		 mov	 DWORD PTR _cy0x0$21[ebp], ecx

; 769  :                 cy1x0 = cy1x1;

  007e4	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x1$8[ebp]
  007ea	89 95 58 ff ff
	ff		 mov	 DWORD PTR _cy1x0$20[ebp], edx

; 770  :                 cy2x0 = cy2x1;

  007f0	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _cy2x1$7[ebp]
  007f6	89 85 54 ff ff
	ff		 mov	 DWORD PTR _cy2x0$19[ebp], eax

; 771  :                 cy3x0 = cy3x1;

  007fc	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x1$6[ebp]
  00802	89 8d 50 ff ff
	ff		 mov	 DWORD PTR _cy3x0$18[ebp], ecx

; 772  :             }

  00808	e9 27 fd ff ff	 jmp	 $LN14@convert_yv
$LN15@convert_yv:

; 773  :         }

  0080d	e9 7d fa ff ff	 jmp	 $LN11@convert_yv
$LN12@convert_yv:

; 774  :     }

  00812	e9 2e fa ff ff	 jmp	 $LN8@convert_yv
$LN1@convert_yv:

; 775  : }

  00817	52		 push	 edx
  00818	8b cd		 mov	 ecx, ebp
  0081a	50		 push	 eax
  0081b	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN47@convert_yv
  00821	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00826	58		 pop	 eax
  00827	5a		 pop	 edx
  00828	5f		 pop	 edi
  00829	5e		 pop	 esi
  0082a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0082d	33 cd		 xor	 ecx, ebp
  0082f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00834	81 c4 18 01 00
	00		 add	 esp, 280		; 00000118H
  0083a	3b ec		 cmp	 ebp, esp
  0083c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00841	8b e5		 mov	 esp, ebp
  00843	5d		 pop	 ebp
  00844	c3		 ret	 0
  00845	0f 1f 00	 npad	 3
$LN47@convert_yv:
  00848	01 00 00 00	 DD	 1
  0084c	00 00 00 00	 DD	 $LN46@convert_yv
$LN46@convert_yv:
  00850	d4 ff ff ff	 DD	 -44			; ffffffd4H
  00854	0c 00 00 00	 DD	 12			; 0000000cH
  00858	00 00 00 00	 DD	 $LN45@convert_yv
$LN45@convert_yv:
  0085c	79		 DB	 121			; 00000079H
  0085d	5f		 DB	 95			; 0000005fH
  0085e	72		 DB	 114			; 00000072H
  0085f	61		 DB	 97			; 00000061H
  00860	6e		 DB	 110			; 0000006eH
  00861	67		 DB	 103			; 00000067H
  00862	65		 DB	 101			; 00000065H
  00863	00		 DB	 0
??$convert_yv12_i_to_yuv444_c@E$07G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_i_to_yuv444_c<unsigned char,8,unsigned short,16,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yv12_i_to_yuv444_16bit@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_i_to_yuv444_16bit

; 789  : static void convert_yv12_i_to_yuv444_16bit(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 790  :     convert_yv12_i_to_yuv444_c<uint8_t, 8, uint16_t, 16, false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yv12_i_to_yuv444_c@E$07G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_i_to_yuv444_c<unsigned char,8,unsigned short,16,0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 791  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yv12_i_to_yuv444_16bit@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_i_to_yuv444_16bit
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
tv425 = -300						; size = 4
tv310 = -296						; size = 4
tv225 = -292						; size = 4
$T1 = -288						; size = 4
$T2 = -284						; size = 4
$T3 = -280						; size = 4
$T4 = -276						; size = 4
$T5 = -272						; size = 12
_cy3x1$6 = -260						; size = 4
_cy1x1$7 = -256						; size = 4
_cy3x0$8 = -252						; size = 4
_cy1x0$9 = -248						; size = 4
_cy4x1$10 = -244					; size = 4
_cy2x1$11 = -240					; size = 4
_cy0x1$12 = -236					; size = 4
_cy4x0$13 = -232					; size = 4
_cy2x0$14 = -228					; size = 4
_cy0x0$15 = -224					; size = 4
_cxplus$16 = -220					; size = 4
_x$17 = -216						; size = 4
_cy3x1$18 = -212					; size = 4
_cy1x1$19 = -208					; size = 4
_cy3x0$20 = -204					; size = 4
_cy1x0$21 = -200					; size = 4
_cy4x1$22 = -196					; size = 4
_cy2x1$23 = -192					; size = 4
_cy0x1$24 = -188					; size = 4
_cy4x0$25 = -184					; size = 4
_cy2x0$26 = -180					; size = 4
_cy0x0$27 = -176					; size = 4
_cxplus$28 = -172					; size = 4
_x$29 = -168						; size = 4
_cy3x1$30 = -164					; size = 4
_cy1x1$31 = -160					; size = 4
_cy3x0$32 = -156					; size = 4
_cy1x0$33 = -152					; size = 4
_cy4x1$34 = -148					; size = 4
_cy2x1$35 = -144					; size = 4
_cy0x1$36 = -140					; size = 4
_cy4x0$37 = -136					; size = 4
_cy2x0$38 = -132					; size = 4
_cy0x0$39 = -128					; size = 4
_cxplus$40 = -124					; size = 4
_x$41 = -120						; size = 4
_x_fin$42 = -116					; size = 4
_srcP$43 = -112						; size = 4
_dstC$44 = -108						; size = 4
_y$45 = -104						; size = 4
_dstLine$46 = -100					; size = 4
_srcCLine$47 = -96					; size = 4
_ic$48 = -92						; size = 4
_src_uv_pitch$ = -88					; size = 4
_x$49 = -84						; size = 4
_y$50 = -80						; size = 4
_y_width$51 = -76					; size = 4
_y_fin$52 = -72						; size = 4
_dstLine$53 = -68					; size = 4
_srcYLine$54 = -64					; size = 4
$T55 = -60						; size = 12
_y_range$ = -44						; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yv12_p_to_yuv444_c@E$07G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_p_to_yuv444_c<unsigned char,8,unsigned short,16,0>

; 573  : static void __forceinline convert_yv12_p_to_yuv444_c(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 2c 01 00
	00		 sub	 esp, 300		; 0000012cH
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8d bd d4 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-300]
  00011	b9 4b 00 00 00	 mov	 ecx, 75			; 0000004bH
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 574  :     static_assert((sizeof(Tin)  == 1 && in_bit_depth  == 8) || (sizeof(Tin)  == 2 && 8 < in_bit_depth  && in_bit_depth  <= 16), "invalid input bit depth.");
; 575  :     static_assert((sizeof(Tout) == 1 && out_bit_depth == 8) || (sizeof(Tout) == 2 && 8 < out_bit_depth && out_bit_depth <= 16), "invalid output bit depth.");
; 576  :     const int crop_left   = crop[0];

  00027	b8 04 00 00 00	 mov	 eax, 4
  0002c	6b c8 00	 imul	 ecx, eax, 0
  0002f	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00032	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00035	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 577  :     const int crop_up     = crop[1];

  00038	b9 04 00 00 00	 mov	 ecx, 4
  0003d	c1 e1 00	 shl	 ecx, 0
  00040	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00043	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00046	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 578  :     const int crop_right  = crop[2];

  00049	b9 04 00 00 00	 mov	 ecx, 4
  0004e	d1 e1		 shl	 ecx, 1
  00050	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00053	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00056	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 579  :     const int crop_bottom = crop[3];

  00059	b9 04 00 00 00	 mov	 ecx, 4
  0005e	6b d1 03	 imul	 edx, ecx, 3
  00061	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00064	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00067	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 580  :     const int src_y_pitch = src_y_pitch_byte / sizeof(Tin);

  0006a	8b 55 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebp]
  0006d	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 581  :     const int dst_y_pitch = dst_y_pitch_byte / sizeof(Tout);

  00070	8b 45 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  00073	d1 e8		 shr	 eax, 1
  00075	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 582  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00078	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0007b	51		 push	 ecx
  0007c	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0007f	52		 push	 edx
  00080	8b 45 20	 mov	 eax, DWORD PTR _height$[ebp]
  00083	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  00086	50		 push	 eax
  00087	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  0008a	51		 push	 ecx
  0008b	8d 95 f0 fe ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  00091	52		 push	 edx
  00092	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00097	83 c4 14	 add	 esp, 20			; 00000014H
  0009a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009c	89 4d c4	 mov	 DWORD PTR $T55[ebp], ecx
  0009f	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a2	89 55 c8	 mov	 DWORD PTR $T55[ebp+4], edx
  000a5	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000a8	89 45 cc	 mov	 DWORD PTR $T55[ebp+8], eax
  000ab	8b 4d c4	 mov	 ecx, DWORD PTR $T55[ebp]
  000ae	89 4d d4	 mov	 DWORD PTR _y_range$[ebp], ecx
  000b1	8b 55 c8	 mov	 edx, DWORD PTR $T55[ebp+4]
  000b4	89 55 d8	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000b7	8b 45 cc	 mov	 eax, DWORD PTR $T55[ebp+8]
  000ba	89 45 dc	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 583  :     //Y
; 584  :     if (!uv_only) {

  000bd	b9 01 00 00 00	 mov	 ecx, 1
  000c2	85 c9		 test	 ecx, ecx
  000c4	0f 84 6c 01 00
	00		 je	 $LN23@convert_yv

; 585  :         Tin *srcYLine = (Tin *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000ca	ba 04 00 00 00	 mov	 edx, 4
  000cf	6b c2 00	 imul	 eax, edx, 0
  000d2	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  000d5	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  000d9	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  000dc	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  000df	03 c1		 add	 eax, ecx
  000e1	03 45 f8	 add	 eax, DWORD PTR _crop_left$[ebp]
  000e4	89 45 c0	 mov	 DWORD PTR _srcYLine$54[ebp], eax

; 586  :         Tout *dstLine = (Tout *)dst[0] + dst_y_pitch * y_range.start_dst;

  000e7	b9 04 00 00 00	 mov	 ecx, 4
  000ec	6b d1 00	 imul	 edx, ecx, 0
  000ef	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  000f2	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  000f6	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  000f9	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  000fc	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  000ff	89 45 bc	 mov	 DWORD PTR _dstLine$53[ebp], eax

; 587  :         const int y_fin = height - crop_bottom;

  00102	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00105	2b 4d ec	 sub	 ecx, DWORD PTR _crop_bottom$[ebp]
  00108	89 4d b8	 mov	 DWORD PTR _y_fin$52[ebp], ecx

; 588  :         const int y_width = width - crop_right - crop_left;

  0010b	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  0010e	2b 55 f0	 sub	 edx, DWORD PTR _crop_right$[ebp]
  00111	2b 55 f8	 sub	 edx, DWORD PTR _crop_left$[ebp]
  00114	89 55 b4	 mov	 DWORD PTR _y_width$51[ebp], edx

; 589  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  00117	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _y$50[ebp], 0
  0011e	eb 1e		 jmp	 SHORT $LN4@convert_yv
$LN2@convert_yv:
  00120	8b 45 b0	 mov	 eax, DWORD PTR _y$50[ebp]
  00123	83 c0 01	 add	 eax, 1
  00126	89 45 b0	 mov	 DWORD PTR _y$50[ebp], eax
  00129	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$54[ebp]
  0012c	03 4d e8	 add	 ecx, DWORD PTR _src_y_pitch$[ebp]
  0012f	89 4d c0	 mov	 DWORD PTR _srcYLine$54[ebp], ecx
  00132	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  00135	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$53[ebp]
  00138	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  0013b	89 4d bc	 mov	 DWORD PTR _dstLine$53[ebp], ecx
$LN4@convert_yv:
  0013e	8b 55 b0	 mov	 edx, DWORD PTR _y$50[ebp]
  00141	3b 55 dc	 cmp	 edx, DWORD PTR _y_range$[ebp+8]
  00144	0f 8d ec 00 00
	00		 jge	 $LN23@convert_yv

; 590  :             if (in_bit_depth == out_bit_depth && sizeof(Tin) == sizeof(Tout)) {

  0014a	33 c0		 xor	 eax, eax
  0014c	74 19		 je	 SHORT $LN24@convert_yv

; 591  :                 memcpy(dstLine, srcYLine, y_width * sizeof(Tin));

  0014e	8b 4d b4	 mov	 ecx, DWORD PTR _y_width$51[ebp]
  00151	51		 push	 ecx
  00152	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$54[ebp]
  00155	52		 push	 edx
  00156	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$53[ebp]
  00159	50		 push	 eax
  0015a	e8 00 00 00 00	 call	 _memcpy
  0015f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 592  :             } else {

  00162	e9 ca 00 00 00	 jmp	 $LN25@convert_yv
$LN24@convert_yv:

; 593  :                 for (int x = 0; x < y_width; x++) {

  00167	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR _x$49[ebp], 0
  0016e	eb 09		 jmp	 SHORT $LN7@convert_yv
$LN5@convert_yv:
  00170	8b 4d ac	 mov	 ecx, DWORD PTR _x$49[ebp]
  00173	83 c1 01	 add	 ecx, 1
  00176	89 4d ac	 mov	 DWORD PTR _x$49[ebp], ecx
$LN7@convert_yv:
  00179	8b 55 ac	 mov	 edx, DWORD PTR _x$49[ebp]
  0017c	3b 55 b4	 cmp	 edx, DWORD PTR _y_width$51[ebp]
  0017f	0f 8d ac 00 00
	00		 jge	 $LN25@convert_yv

; 594  :                     if (out_bit_depth > in_bit_depth) {

  00185	b8 01 00 00 00	 mov	 eax, 1
  0018a	85 c0		 test	 eax, eax
  0018c	74 43		 je	 SHORT $LN26@convert_yv

; 595  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) << std::max(out_bit_depth - in_bit_depth, 0));

  0018e	c7 85 ec fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], 0
  00198	c7 85 e8 fe ff
	ff 08 00 00 00	 mov	 DWORD PTR $T3[ebp], 8
  001a2	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$54[ebp]
  001a5	03 4d ac	 add	 ecx, DWORD PTR _x$49[ebp]
  001a8	0f b6 31	 movzx	 esi, BYTE PTR [ecx]
  001ab	8d 95 ec fe ff
	ff		 lea	 edx, DWORD PTR $T4[ebp]
  001b1	52		 push	 edx
  001b2	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  001b8	50		 push	 eax
  001b9	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  001be	83 c4 08	 add	 esp, 8
  001c1	8b 08		 mov	 ecx, DWORD PTR [eax]
  001c3	d3 e6		 shl	 esi, cl
  001c5	8b 4d ac	 mov	 ecx, DWORD PTR _x$49[ebp]
  001c8	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$53[ebp]
  001cb	66 89 34 4a	 mov	 WORD PTR [edx+ecx*2], si
  001cf	eb 5b		 jmp	 SHORT $LN27@convert_yv
$LN26@convert_yv:

; 596  :                     } else if (out_bit_depth < in_bit_depth) {

  001d1	33 c0		 xor	 eax, eax
  001d3	74 43		 je	 SHORT $LN28@convert_yv

; 597  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) >> std::max(in_bit_depth - out_bit_depth, 0));

  001d5	c7 85 e4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], 0
  001df	c7 85 e0 fe ff
	ff f8 ff ff ff	 mov	 DWORD PTR $T1[ebp], -8	; fffffff8H
  001e9	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$54[ebp]
  001ec	03 4d ac	 add	 ecx, DWORD PTR _x$49[ebp]
  001ef	0f b6 31	 movzx	 esi, BYTE PTR [ecx]
  001f2	8d 95 e4 fe ff
	ff		 lea	 edx, DWORD PTR $T2[ebp]
  001f8	52		 push	 edx
  001f9	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  001ff	50		 push	 eax
  00200	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  00205	83 c4 08	 add	 esp, 8
  00208	8b 08		 mov	 ecx, DWORD PTR [eax]
  0020a	d3 fe		 sar	 esi, cl
  0020c	8b 4d ac	 mov	 ecx, DWORD PTR _x$49[ebp]
  0020f	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$53[ebp]
  00212	66 89 34 4a	 mov	 WORD PTR [edx+ecx*2], si

; 598  :                     } else {

  00216	eb 14		 jmp	 SHORT $LN27@convert_yv
$LN28@convert_yv:

; 599  :                         dstLine[x] = (Tout)srcYLine[x];

  00218	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$54[ebp]
  0021b	03 45 ac	 add	 eax, DWORD PTR _x$49[ebp]
  0021e	66 0f b6 08	 movzx	 cx, BYTE PTR [eax]
  00222	8b 55 ac	 mov	 edx, DWORD PTR _x$49[ebp]
  00225	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$53[ebp]
  00228	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx
$LN27@convert_yv:

; 600  :                     }
; 601  :                 }

  0022c	e9 3f ff ff ff	 jmp	 $LN5@convert_yv
$LN25@convert_yv:

; 602  :             }
; 603  :         }

  00231	e9 ea fe ff ff	 jmp	 $LN2@convert_yv
$LN23@convert_yv:

; 604  :     }
; 605  :     //UV
; 606  :     const int src_uv_pitch = src_uv_pitch_byte / sizeof(Tin);

  00236	8b 4d 18	 mov	 ecx, DWORD PTR _src_uv_pitch_byte$[ebp]
  00239	89 4d a8	 mov	 DWORD PTR _src_uv_pitch$[ebp], ecx

; 607  :     for (int ic = 1; ic < 3; ic++) {

  0023c	c7 45 a4 01 00
	00 00		 mov	 DWORD PTR _ic$48[ebp], 1
  00243	eb 09		 jmp	 SHORT $LN10@convert_yv
$LN8@convert_yv:
  00245	8b 55 a4	 mov	 edx, DWORD PTR _ic$48[ebp]
  00248	83 c2 01	 add	 edx, 1
  0024b	89 55 a4	 mov	 DWORD PTR _ic$48[ebp], edx
$LN10@convert_yv:
  0024e	83 7d a4 03	 cmp	 DWORD PTR _ic$48[ebp], 3
  00252	0f 8d ff 06 00
	00		 jge	 $LN1@convert_yv

; 608  :         Tin *srcCLine = (Tin *)src[ic] + (((src_uv_pitch * y_range.start_src) + crop_left) >> 1);

  00258	8b 45 a8	 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  0025b	0f af 45 d4	 imul	 eax, DWORD PTR _y_range$[ebp]
  0025f	03 45 f8	 add	 eax, DWORD PTR _crop_left$[ebp]
  00262	d1 f8		 sar	 eax, 1
  00264	8b 4d a4	 mov	 ecx, DWORD PTR _ic$48[ebp]
  00267	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  0026a	03 04 8a	 add	 eax, DWORD PTR [edx+ecx*4]
  0026d	89 45 a0	 mov	 DWORD PTR _srcCLine$47[ebp], eax

; 609  :         Tout *dstLine = (Tout *)dst[ic] + dst_y_pitch * y_range.start_dst;

  00270	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  00273	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  00277	8b 4d a4	 mov	 ecx, DWORD PTR _ic$48[ebp]
  0027a	8b 55 08	 mov	 edx, DWORD PTR _dst$[ebp]
  0027d	8b 0c 8a	 mov	 ecx, DWORD PTR [edx+ecx*4]
  00280	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00283	89 55 9c	 mov	 DWORD PTR _dstLine$46[ebp], edx

; 610  :         for (int y = 0; y < y_range.len; y += 2, srcCLine += src_uv_pitch, dstLine += dst_y_pitch * 2) {

  00286	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _y$45[ebp], 0
  0028d	eb 20		 jmp	 SHORT $LN13@convert_yv
$LN11@convert_yv:
  0028f	8b 45 98	 mov	 eax, DWORD PTR _y$45[ebp]
  00292	83 c0 02	 add	 eax, 2
  00295	89 45 98	 mov	 DWORD PTR _y$45[ebp], eax
  00298	8b 4d a0	 mov	 ecx, DWORD PTR _srcCLine$47[ebp]
  0029b	03 4d a8	 add	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  0029e	89 4d a0	 mov	 DWORD PTR _srcCLine$47[ebp], ecx
  002a1	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  002a4	d1 e2		 shl	 edx, 1
  002a6	8b 45 9c	 mov	 eax, DWORD PTR _dstLine$46[ebp]
  002a9	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  002ac	89 4d 9c	 mov	 DWORD PTR _dstLine$46[ebp], ecx
$LN13@convert_yv:
  002af	8b 55 98	 mov	 edx, DWORD PTR _y$45[ebp]
  002b2	3b 55 dc	 cmp	 edx, DWORD PTR _y_range$[ebp+8]
  002b5	0f 8d 97 06 00
	00		 jge	 $LN12@convert_yv

; 611  :             Tout *dstC = dstLine;

  002bb	8b 45 9c	 mov	 eax, DWORD PTR _dstLine$46[ebp]
  002be	89 45 94	 mov	 DWORD PTR _dstC$44[ebp], eax

; 612  :             Tin *srcP = srcCLine;

  002c1	8b 4d a0	 mov	 ecx, DWORD PTR _srcCLine$47[ebp]
  002c4	89 4d 90	 mov	 DWORD PTR _srcP$43[ebp], ecx

; 613  :             const int x_fin = width - crop_right - crop_left;

  002c7	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  002ca	2b 55 f0	 sub	 edx, DWORD PTR _crop_right$[ebp]
  002cd	2b 55 f8	 sub	 edx, DWORD PTR _crop_left$[ebp]
  002d0	89 55 8c	 mov	 DWORD PTR _x_fin$42[ebp], edx

; 614  :             if (y == 0) {

  002d3	83 7d 98 00	 cmp	 DWORD PTR _y$45[ebp], 0
  002d7	0f 85 0b 02 00
	00		 jne	 $LN30@convert_yv

; 615  :                 for (int x = 0; x < x_fin; x += 2, dstC += 2, srcP++) {

  002dd	c7 45 88 00 00
	00 00		 mov	 DWORD PTR _x$41[ebp], 0
  002e4	eb 1b		 jmp	 SHORT $LN16@convert_yv
$LN14@convert_yv:
  002e6	8b 45 88	 mov	 eax, DWORD PTR _x$41[ebp]
  002e9	83 c0 02	 add	 eax, 2
  002ec	89 45 88	 mov	 DWORD PTR _x$41[ebp], eax
  002ef	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$44[ebp]
  002f2	83 c1 04	 add	 ecx, 4
  002f5	89 4d 94	 mov	 DWORD PTR _dstC$44[ebp], ecx
  002f8	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  002fb	83 c2 01	 add	 edx, 1
  002fe	89 55 90	 mov	 DWORD PTR _srcP$43[ebp], edx
$LN16@convert_yv:
  00301	8b 45 88	 mov	 eax, DWORD PTR _x$41[ebp]
  00304	3b 45 8c	 cmp	 eax, DWORD PTR _x_fin$42[ebp]
  00307	0f 8d d6 01 00
	00		 jge	 $LN15@convert_yv

; 616  :                     int cxplus = (x + 2 < x_fin);

  0030d	8b 4d 88	 mov	 ecx, DWORD PTR _x$41[ebp]
  00310	83 c1 02	 add	 ecx, 2
  00313	3b 4d 8c	 cmp	 ecx, DWORD PTR _x_fin$42[ebp]
  00316	7d 0c		 jge	 SHORT $LN44@convert_yv
  00318	c7 85 dc fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv225[ebp], 1
  00322	eb 0a		 jmp	 SHORT $LN45@convert_yv
$LN44@convert_yv:
  00324	c7 85 dc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv225[ebp], 0
$LN45@convert_yv:
  0032e	8b 95 dc fe ff
	ff		 mov	 edx, DWORD PTR tv225[ebp]
  00334	89 55 84	 mov	 DWORD PTR _cxplus$40[ebp], edx

; 617  :                     int cy0x0 = srcP[ 0*src_uv_pitch + 0];

  00337	6b 45 a8 00	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp], 0
  0033b	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$43[ebp]
  0033e	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00342	89 55 80	 mov	 DWORD PTR _cy0x0$39[ebp], edx

; 618  :                     int cy2x0 = srcP[ 0*src_uv_pitch + 0];

  00345	6b 45 a8 00	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp], 0
  00349	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$43[ebp]
  0034c	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00350	89 95 7c ff ff
	ff		 mov	 DWORD PTR _cy2x0$38[ebp], edx

; 619  :                     int cy4x0 = srcP[ 1*src_uv_pitch + 0];

  00356	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  00359	03 45 a8	 add	 eax, DWORD PTR _src_uv_pitch$[ebp]
  0035c	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0035f	89 8d 78 ff ff
	ff		 mov	 DWORD PTR _cy4x0$37[ebp], ecx

; 620  :                     int cy0x1 = srcP[ 0*src_uv_pitch + cxplus];

  00365	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  00369	03 55 84	 add	 edx, DWORD PTR _cxplus$40[ebp]
  0036c	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  0036f	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  00373	89 8d 74 ff ff
	ff		 mov	 DWORD PTR _cy0x1$36[ebp], ecx

; 621  :                     int cy2x1 = srcP[ 0*src_uv_pitch + cxplus];

  00379	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  0037d	03 55 84	 add	 edx, DWORD PTR _cxplus$40[ebp]
  00380	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  00383	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  00387	89 8d 70 ff ff
	ff		 mov	 DWORD PTR _cy2x1$35[ebp], ecx

; 622  :                     int cy4x1 = srcP[ 1*src_uv_pitch + cxplus];

  0038d	8b 55 84	 mov	 edx, DWORD PTR _cxplus$40[ebp]
  00390	03 55 a8	 add	 edx, DWORD PTR _src_uv_pitch$[ebp]
  00393	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  00396	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  0039a	89 8d 6c ff ff
	ff		 mov	 DWORD PTR _cy4x1$34[ebp], ecx

; 623  : 
; 624  :                     int cy1x0 = (cy0x0 * 1 + cy2x0 * 3 + 2);

  003a0	6b 95 7c ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x0$38[ebp], 3
  003a7	8b 45 80	 mov	 eax, DWORD PTR _cy0x0$39[ebp]
  003aa	8d 4c 10 02	 lea	 ecx, DWORD PTR [eax+edx+2]
  003ae	89 8d 68 ff ff
	ff		 mov	 DWORD PTR _cy1x0$33[ebp], ecx

; 625  :                     int cy3x0 = (cy2x0 * 3 + cy4x0 * 1 + 2);

  003b4	6b 95 7c ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x0$38[ebp], 3
  003bb	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _cy4x0$37[ebp]
  003c1	8d 4c 02 02	 lea	 ecx, DWORD PTR [edx+eax+2]
  003c5	89 8d 64 ff ff
	ff		 mov	 DWORD PTR _cy3x0$32[ebp], ecx

; 626  :                     int cy1x1 = (cy0x1 * 1 + cy2x1 * 3 + 2);

  003cb	6b 95 70 ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x1$35[ebp], 3
  003d2	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _cy0x1$36[ebp]
  003d8	8d 4c 10 02	 lea	 ecx, DWORD PTR [eax+edx+2]
  003dc	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _cy1x1$31[ebp], ecx

; 627  :                     int cy3x1 = (cy2x1 * 3 + cy4x1 * 1 + 2);

  003e2	6b 95 70 ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x1$35[ebp], 3
  003e9	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _cy4x1$34[ebp]
  003ef	8d 4c 02 02	 lea	 ecx, DWORD PTR [edx+eax+2]
  003f3	89 8d 5c ff ff
	ff		 mov	 DWORD PTR _cy3x1$30[ebp], ecx

; 628  :                     CHANGE_BIT_DEPTH_4(cy1x0, cy3x0, cy1x1, cy3x1, 2);

  003f9	ba 01 00 00 00	 mov	 edx, 1
  003fe	85 d2		 test	 edx, edx
  00400	74 3e		 je	 SHORT $LN32@convert_yv
  00402	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x0$33[ebp]
  00408	c1 e0 06	 shl	 eax, 6
  0040b	89 85 68 ff ff
	ff		 mov	 DWORD PTR _cy1x0$33[ebp], eax
  00411	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x0$32[ebp]
  00417	c1 e1 06	 shl	 ecx, 6
  0041a	89 8d 64 ff ff
	ff		 mov	 DWORD PTR _cy3x0$32[ebp], ecx
  00420	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x1$31[ebp]
  00426	c1 e2 06	 shl	 edx, 6
  00429	89 95 60 ff ff
	ff		 mov	 DWORD PTR _cy1x1$31[ebp], edx
  0042f	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _cy3x1$30[ebp]
  00435	c1 e0 06	 shl	 eax, 6
  00438	89 85 5c ff ff
	ff		 mov	 DWORD PTR _cy3x1$30[ebp], eax
  0043e	eb 40		 jmp	 SHORT $LN33@convert_yv
$LN32@convert_yv:
  00440	33 c9		 xor	 ecx, ecx
  00442	74 3c		 je	 SHORT $LN33@convert_yv
  00444	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x0$33[ebp]
  0044a	c1 fa fa	 sar	 edx, -6			; fffffffaH
  0044d	89 95 68 ff ff
	ff		 mov	 DWORD PTR _cy1x0$33[ebp], edx
  00453	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$32[ebp]
  00459	c1 f8 fa	 sar	 eax, -6			; fffffffaH
  0045c	89 85 64 ff ff
	ff		 mov	 DWORD PTR _cy3x0$32[ebp], eax
  00462	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x1$31[ebp]
  00468	c1 f9 fa	 sar	 ecx, -6			; fffffffaH
  0046b	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _cy1x1$31[ebp], ecx
  00471	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR _cy3x1$30[ebp]
  00477	c1 fa fa	 sar	 edx, -6			; fffffffaH
  0047a	89 95 5c ff ff
	ff		 mov	 DWORD PTR _cy3x1$30[ebp], edx
$LN33@convert_yv:

; 629  : 
; 630  :                     dstC[0*dst_y_pitch   + 0] = (Tout)cy1x0;

  00480	6b 45 e4 00	 imul	 eax, DWORD PTR _dst_y_pitch$[ebp], 0
  00484	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$44[ebp]
  00487	66 8b 95 68 ff
	ff ff		 mov	 dx, WORD PTR _cy1x0$33[ebp]
  0048e	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx

; 631  :                     dstC[0*dst_y_pitch   + 1] = (Tout)((cy1x0 + cy1x1 + 1) >> 1);

  00492	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x1$31[ebp]
  00498	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x0$33[ebp]
  0049e	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  004a2	d1 fa		 sar	 edx, 1
  004a4	6b 45 e4 00	 imul	 eax, DWORD PTR _dst_y_pitch$[ebp], 0
  004a8	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$44[ebp]
  004ab	66 89 54 41 02	 mov	 WORD PTR [ecx+eax*2+2], dx

; 632  :                     dstC[1*dst_y_pitch   + 0] = (Tout)cy3x0;

  004b0	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  004b3	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  004b6	66 8b 8d 64 ff
	ff ff		 mov	 cx, WORD PTR _cy3x0$32[ebp]
  004bd	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx

; 633  :                     dstC[1*dst_y_pitch   + 1] = (Tout)((cy3x0 + cy3x1 + 1) >> 1);

  004c1	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR _cy3x1$30[ebp]
  004c7	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$32[ebp]
  004cd	8d 4c 10 01	 lea	 ecx, DWORD PTR [eax+edx+1]
  004d1	d1 f9		 sar	 ecx, 1
  004d3	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  004d6	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  004d9	66 89 4c 50 02	 mov	 WORD PTR [eax+edx*2+2], cx

; 634  :                 }

  004de	e9 03 fe ff ff	 jmp	 $LN14@convert_yv
$LN15@convert_yv:

; 635  :             } else if (y >= height-2) {

  004e3	e9 65 04 00 00	 jmp	 $LN31@convert_yv
$LN30@convert_yv:
  004e8	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  004eb	83 e9 02	 sub	 ecx, 2
  004ee	39 4d 98	 cmp	 DWORD PTR _y$45[ebp], ecx
  004f1	0f 8c 2f 02 00
	00		 jl	 $LN35@convert_yv

; 636  :                 for (int x = 0; x < x_fin; x += 2, dstC += 2, srcP++) {

  004f7	c7 85 58 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _x$29[ebp], 0
  00501	eb 21		 jmp	 SHORT $LN19@convert_yv
$LN17@convert_yv:
  00503	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _x$29[ebp]
  00509	83 c2 02	 add	 edx, 2
  0050c	89 95 58 ff ff
	ff		 mov	 DWORD PTR _x$29[ebp], edx
  00512	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  00515	83 c0 04	 add	 eax, 4
  00518	89 45 94	 mov	 DWORD PTR _dstC$44[ebp], eax
  0051b	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$43[ebp]
  0051e	83 c1 01	 add	 ecx, 1
  00521	89 4d 90	 mov	 DWORD PTR _srcP$43[ebp], ecx
$LN19@convert_yv:
  00524	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _x$29[ebp]
  0052a	3b 55 8c	 cmp	 edx, DWORD PTR _x_fin$42[ebp]
  0052d	0f 8d ee 01 00
	00		 jge	 $LN18@convert_yv

; 637  :                     int cxplus = (x + 2 < x_fin);

  00533	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _x$29[ebp]
  00539	83 c0 02	 add	 eax, 2
  0053c	3b 45 8c	 cmp	 eax, DWORD PTR _x_fin$42[ebp]
  0053f	7d 0c		 jge	 SHORT $LN46@convert_yv
  00541	c7 85 d8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv310[ebp], 1
  0054b	eb 0a		 jmp	 SHORT $LN47@convert_yv
$LN46@convert_yv:
  0054d	c7 85 d8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv310[ebp], 0
$LN47@convert_yv:
  00557	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR tv310[ebp]
  0055d	89 8d 54 ff ff
	ff		 mov	 DWORD PTR _cxplus$28[ebp], ecx

; 638  :                     int cy0x0 = srcP[-1*src_uv_pitch + 0];

  00563	6b 55 a8 ff	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], -1
  00567	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  0056a	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  0056e	89 8d 50 ff ff
	ff		 mov	 DWORD PTR _cy0x0$27[ebp], ecx

; 639  :                     int cy2x0 = srcP[ 0*src_uv_pitch + 0];

  00574	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  00578	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  0057b	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  0057f	89 8d 4c ff ff
	ff		 mov	 DWORD PTR _cy2x0$26[ebp], ecx

; 640  :                     int cy4x0 = srcP[ 0*src_uv_pitch + 0];

  00585	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  00589	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  0058c	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  00590	89 8d 48 ff ff
	ff		 mov	 DWORD PTR _cy4x0$25[ebp], ecx

; 641  :                     int cy0x1 = srcP[-1*src_uv_pitch + cxplus];

  00596	6b 55 a8 ff	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], -1
  0059a	03 95 54 ff ff
	ff		 add	 edx, DWORD PTR _cxplus$28[ebp]
  005a0	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  005a3	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  005a7	89 8d 44 ff ff
	ff		 mov	 DWORD PTR _cy0x1$24[ebp], ecx

; 642  :                     int cy2x1 = srcP[ 0*src_uv_pitch + cxplus];

  005ad	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  005b1	03 95 54 ff ff
	ff		 add	 edx, DWORD PTR _cxplus$28[ebp]
  005b7	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  005ba	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  005be	89 8d 40 ff ff
	ff		 mov	 DWORD PTR _cy2x1$23[ebp], ecx

; 643  :                     int cy4x1 = srcP[ 0*src_uv_pitch + cxplus];

  005c4	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  005c8	03 95 54 ff ff
	ff		 add	 edx, DWORD PTR _cxplus$28[ebp]
  005ce	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  005d1	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  005d5	89 8d 3c ff ff
	ff		 mov	 DWORD PTR _cy4x1$22[ebp], ecx

; 644  : 
; 645  :                     int cy1x0 = (cy0x0 * 1 + cy2x0 * 3 + 2);

  005db	6b 95 4c ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x0$26[ebp], 3
  005e2	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _cy0x0$27[ebp]
  005e8	8d 4c 10 02	 lea	 ecx, DWORD PTR [eax+edx+2]
  005ec	89 8d 38 ff ff
	ff		 mov	 DWORD PTR _cy1x0$21[ebp], ecx

; 646  :                     int cy3x0 = (cy2x0 * 3 + cy4x0 * 1 + 2);

  005f2	6b 95 4c ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x0$26[ebp], 3
  005f9	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _cy4x0$25[ebp]
  005ff	8d 4c 02 02	 lea	 ecx, DWORD PTR [edx+eax+2]
  00603	89 8d 34 ff ff
	ff		 mov	 DWORD PTR _cy3x0$20[ebp], ecx

; 647  :                     int cy1x1 = (cy0x1 * 1 + cy2x1 * 3 + 2);

  00609	6b 95 40 ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x1$23[ebp], 3
  00610	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _cy0x1$24[ebp]
  00616	8d 4c 10 02	 lea	 ecx, DWORD PTR [eax+edx+2]
  0061a	89 8d 30 ff ff
	ff		 mov	 DWORD PTR _cy1x1$19[ebp], ecx

; 648  :                     int cy3x1 = (cy2x1 * 3 + cy4x1 * 1 + 2);

  00620	6b 95 40 ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x1$23[ebp], 3
  00627	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _cy4x1$22[ebp]
  0062d	8d 4c 02 02	 lea	 ecx, DWORD PTR [edx+eax+2]
  00631	89 8d 2c ff ff
	ff		 mov	 DWORD PTR _cy3x1$18[ebp], ecx

; 649  :                     CHANGE_BIT_DEPTH_4(cy1x0, cy3x0, cy1x1, cy3x1, 2);

  00637	ba 01 00 00 00	 mov	 edx, 1
  0063c	85 d2		 test	 edx, edx
  0063e	74 3e		 je	 SHORT $LN37@convert_yv
  00640	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x0$21[ebp]
  00646	c1 e0 06	 shl	 eax, 6
  00649	89 85 38 ff ff
	ff		 mov	 DWORD PTR _cy1x0$21[ebp], eax
  0064f	8b 8d 34 ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x0$20[ebp]
  00655	c1 e1 06	 shl	 ecx, 6
  00658	89 8d 34 ff ff
	ff		 mov	 DWORD PTR _cy3x0$20[ebp], ecx
  0065e	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x1$19[ebp]
  00664	c1 e2 06	 shl	 edx, 6
  00667	89 95 30 ff ff
	ff		 mov	 DWORD PTR _cy1x1$19[ebp], edx
  0066d	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR _cy3x1$18[ebp]
  00673	c1 e0 06	 shl	 eax, 6
  00676	89 85 2c ff ff
	ff		 mov	 DWORD PTR _cy3x1$18[ebp], eax
  0067c	eb 40		 jmp	 SHORT $LN38@convert_yv
$LN37@convert_yv:
  0067e	33 c9		 xor	 ecx, ecx
  00680	74 3c		 je	 SHORT $LN38@convert_yv
  00682	8b 95 38 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x0$21[ebp]
  00688	c1 fa fa	 sar	 edx, -6			; fffffffaH
  0068b	89 95 38 ff ff
	ff		 mov	 DWORD PTR _cy1x0$21[ebp], edx
  00691	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$20[ebp]
  00697	c1 f8 fa	 sar	 eax, -6			; fffffffaH
  0069a	89 85 34 ff ff
	ff		 mov	 DWORD PTR _cy3x0$20[ebp], eax
  006a0	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x1$19[ebp]
  006a6	c1 f9 fa	 sar	 ecx, -6			; fffffffaH
  006a9	89 8d 30 ff ff
	ff		 mov	 DWORD PTR _cy1x1$19[ebp], ecx
  006af	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR _cy3x1$18[ebp]
  006b5	c1 fa fa	 sar	 edx, -6			; fffffffaH
  006b8	89 95 2c ff ff
	ff		 mov	 DWORD PTR _cy3x1$18[ebp], edx
$LN38@convert_yv:

; 650  : 
; 651  :                     dstC[0*dst_y_pitch   + 0] = (Tout)cy1x0;

  006be	6b 45 e4 00	 imul	 eax, DWORD PTR _dst_y_pitch$[ebp], 0
  006c2	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$44[ebp]
  006c5	66 8b 95 38 ff
	ff ff		 mov	 dx, WORD PTR _cy1x0$21[ebp]
  006cc	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx

; 652  :                     dstC[0*dst_y_pitch   + 1] = (Tout)((cy1x0 + cy1x1 + 1) >> 1);

  006d0	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x1$19[ebp]
  006d6	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x0$21[ebp]
  006dc	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  006e0	d1 fa		 sar	 edx, 1
  006e2	6b 45 e4 00	 imul	 eax, DWORD PTR _dst_y_pitch$[ebp], 0
  006e6	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$44[ebp]
  006e9	66 89 54 41 02	 mov	 WORD PTR [ecx+eax*2+2], dx

; 653  :                     dstC[1*dst_y_pitch   + 0] = (Tout)cy3x0;

  006ee	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  006f1	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  006f4	66 8b 8d 34 ff
	ff ff		 mov	 cx, WORD PTR _cy3x0$20[ebp]
  006fb	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx

; 654  :                     dstC[1*dst_y_pitch   + 1] = (Tout)((cy3x0 + cy3x1 + 1) >> 1);

  006ff	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR _cy3x1$18[ebp]
  00705	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$20[ebp]
  0070b	8d 4c 10 01	 lea	 ecx, DWORD PTR [eax+edx+1]
  0070f	d1 f9		 sar	 ecx, 1
  00711	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  00714	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  00717	66 89 4c 50 02	 mov	 WORD PTR [eax+edx*2+2], cx

; 655  :                 }

  0071c	e9 e2 fd ff ff	 jmp	 $LN17@convert_yv
$LN18@convert_yv:

; 656  :             } else {

  00721	e9 27 02 00 00	 jmp	 $LN31@convert_yv
$LN35@convert_yv:

; 657  :                 for (int x = 0; x < x_fin; x += 2, dstC += 2, srcP++) {

  00726	c7 85 28 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _x$17[ebp], 0
  00730	eb 21		 jmp	 SHORT $LN22@convert_yv
$LN20@convert_yv:
  00732	8b 8d 28 ff ff
	ff		 mov	 ecx, DWORD PTR _x$17[ebp]
  00738	83 c1 02	 add	 ecx, 2
  0073b	89 8d 28 ff ff
	ff		 mov	 DWORD PTR _x$17[ebp], ecx
  00741	8b 55 94	 mov	 edx, DWORD PTR _dstC$44[ebp]
  00744	83 c2 04	 add	 edx, 4
  00747	89 55 94	 mov	 DWORD PTR _dstC$44[ebp], edx
  0074a	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  0074d	83 c0 01	 add	 eax, 1
  00750	89 45 90	 mov	 DWORD PTR _srcP$43[ebp], eax
$LN22@convert_yv:
  00753	8b 8d 28 ff ff
	ff		 mov	 ecx, DWORD PTR _x$17[ebp]
  00759	3b 4d 8c	 cmp	 ecx, DWORD PTR _x_fin$42[ebp]
  0075c	0f 8d eb 01 00
	00		 jge	 $LN31@convert_yv

; 658  :                     int cxplus = (x + 2 < x_fin);

  00762	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR _x$17[ebp]
  00768	83 c2 02	 add	 edx, 2
  0076b	3b 55 8c	 cmp	 edx, DWORD PTR _x_fin$42[ebp]
  0076e	7d 0c		 jge	 SHORT $LN48@convert_yv
  00770	c7 85 d4 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv425[ebp], 1
  0077a	eb 0a		 jmp	 SHORT $LN49@convert_yv
$LN48@convert_yv:
  0077c	c7 85 d4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv425[ebp], 0
$LN49@convert_yv:
  00786	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR tv425[ebp]
  0078c	89 85 24 ff ff
	ff		 mov	 DWORD PTR _cxplus$16[ebp], eax

; 659  :                     int cy0x0 = srcP[-1*src_uv_pitch + 0];

  00792	6b 4d a8 ff	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], -1
  00796	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  00799	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  0079d	89 85 20 ff ff
	ff		 mov	 DWORD PTR _cy0x0$15[ebp], eax

; 660  :                     int cy2x0 = srcP[ 0*src_uv_pitch + 0];

  007a3	6b 4d a8 00	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 0
  007a7	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  007aa	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  007ae	89 85 1c ff ff
	ff		 mov	 DWORD PTR _cy2x0$14[ebp], eax

; 661  :                     int cy4x0 = srcP[ 1*src_uv_pitch + 0];

  007b4	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$43[ebp]
  007b7	03 4d a8	 add	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  007ba	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  007bd	89 95 18 ff ff
	ff		 mov	 DWORD PTR _cy4x0$13[ebp], edx

; 662  :                     int cy0x1 = srcP[-1*src_uv_pitch + cxplus];

  007c3	6b 45 a8 ff	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp], -1
  007c7	03 85 24 ff ff
	ff		 add	 eax, DWORD PTR _cxplus$16[ebp]
  007cd	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$43[ebp]
  007d0	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  007d4	89 95 14 ff ff
	ff		 mov	 DWORD PTR _cy0x1$12[ebp], edx

; 663  :                     int cy2x1 = srcP[ 0*src_uv_pitch + cxplus];

  007da	6b 45 a8 00	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp], 0
  007de	03 85 24 ff ff
	ff		 add	 eax, DWORD PTR _cxplus$16[ebp]
  007e4	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$43[ebp]
  007e7	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  007eb	89 95 10 ff ff
	ff		 mov	 DWORD PTR _cy2x1$11[ebp], edx

; 664  :                     int cy4x1 = srcP[ 1*src_uv_pitch + cxplus];

  007f1	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _cxplus$16[ebp]
  007f7	03 45 a8	 add	 eax, DWORD PTR _src_uv_pitch$[ebp]
  007fa	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$43[ebp]
  007fd	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00801	89 95 0c ff ff
	ff		 mov	 DWORD PTR _cy4x1$10[ebp], edx

; 665  : 
; 666  :                     int cy1x0 = (cy0x0 * 1 + cy2x0 * 3 + 2);

  00807	6b 85 1c ff ff
	ff 03		 imul	 eax, DWORD PTR _cy2x0$14[ebp], 3
  0080e	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR _cy0x0$15[ebp]
  00814	8d 54 01 02	 lea	 edx, DWORD PTR [ecx+eax+2]
  00818	89 95 08 ff ff
	ff		 mov	 DWORD PTR _cy1x0$9[ebp], edx

; 667  :                     int cy3x0 = (cy2x0 * 3 + cy4x0 * 1 + 2);

  0081e	6b 85 1c ff ff
	ff 03		 imul	 eax, DWORD PTR _cy2x0$14[ebp], 3
  00825	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR _cy4x0$13[ebp]
  0082b	8d 54 08 02	 lea	 edx, DWORD PTR [eax+ecx+2]
  0082f	89 95 04 ff ff
	ff		 mov	 DWORD PTR _cy3x0$8[ebp], edx

; 668  :                     int cy1x1 = (cy0x1 * 1 + cy2x1 * 3 + 2);

  00835	6b 85 10 ff ff
	ff 03		 imul	 eax, DWORD PTR _cy2x1$11[ebp], 3
  0083c	8b 8d 14 ff ff
	ff		 mov	 ecx, DWORD PTR _cy0x1$12[ebp]
  00842	8d 54 01 02	 lea	 edx, DWORD PTR [ecx+eax+2]
  00846	89 95 00 ff ff
	ff		 mov	 DWORD PTR _cy1x1$7[ebp], edx

; 669  :                     int cy3x1 = (cy2x1 * 3 + cy4x1 * 1 + 2);

  0084c	6b 85 10 ff ff
	ff 03		 imul	 eax, DWORD PTR _cy2x1$11[ebp], 3
  00853	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR _cy4x1$10[ebp]
  00859	8d 54 08 02	 lea	 edx, DWORD PTR [eax+ecx+2]
  0085d	89 95 fc fe ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], edx

; 670  :                     CHANGE_BIT_DEPTH_4(cy1x0, cy3x0, cy1x1, cy3x1, 2);

  00863	b8 01 00 00 00	 mov	 eax, 1
  00868	85 c0		 test	 eax, eax
  0086a	74 3e		 je	 SHORT $LN40@convert_yv
  0086c	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x0$9[ebp]
  00872	c1 e1 06	 shl	 ecx, 6
  00875	89 8d 08 ff ff
	ff		 mov	 DWORD PTR _cy1x0$9[ebp], ecx
  0087b	8b 95 04 ff ff
	ff		 mov	 edx, DWORD PTR _cy3x0$8[ebp]
  00881	c1 e2 06	 shl	 edx, 6
  00884	89 95 04 ff ff
	ff		 mov	 DWORD PTR _cy3x0$8[ebp], edx
  0088a	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x1$7[ebp]
  00890	c1 e0 06	 shl	 eax, 6
  00893	89 85 00 ff ff
	ff		 mov	 DWORD PTR _cy1x1$7[ebp], eax
  00899	8b 8d fc fe ff
	ff		 mov	 ecx, DWORD PTR _cy3x1$6[ebp]
  0089f	c1 e1 06	 shl	 ecx, 6
  008a2	89 8d fc fe ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], ecx
  008a8	eb 40		 jmp	 SHORT $LN41@convert_yv
$LN40@convert_yv:
  008aa	33 d2		 xor	 edx, edx
  008ac	74 3c		 je	 SHORT $LN41@convert_yv
  008ae	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x0$9[ebp]
  008b4	c1 f8 fa	 sar	 eax, -6			; fffffffaH
  008b7	89 85 08 ff ff
	ff		 mov	 DWORD PTR _cy1x0$9[ebp], eax
  008bd	8b 8d 04 ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x0$8[ebp]
  008c3	c1 f9 fa	 sar	 ecx, -6			; fffffffaH
  008c6	89 8d 04 ff ff
	ff		 mov	 DWORD PTR _cy3x0$8[ebp], ecx
  008cc	8b 95 00 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x1$7[ebp]
  008d2	c1 fa fa	 sar	 edx, -6			; fffffffaH
  008d5	89 95 00 ff ff
	ff		 mov	 DWORD PTR _cy1x1$7[ebp], edx
  008db	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR _cy3x1$6[ebp]
  008e1	c1 f8 fa	 sar	 eax, -6			; fffffffaH
  008e4	89 85 fc fe ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], eax
$LN41@convert_yv:

; 671  : 
; 672  :                     dstC[0*dst_y_pitch   + 0] = (Tout)cy1x0;

  008ea	6b 4d e4 00	 imul	 ecx, DWORD PTR _dst_y_pitch$[ebp], 0
  008ee	8b 55 94	 mov	 edx, DWORD PTR _dstC$44[ebp]
  008f1	66 8b 85 08 ff
	ff ff		 mov	 ax, WORD PTR _cy1x0$9[ebp]
  008f8	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax

; 673  :                     dstC[0*dst_y_pitch   + 1] = (Tout)((cy1x0 + cy1x1 + 1) >> 1);

  008fc	8b 8d 00 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x1$7[ebp]
  00902	8b 95 08 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x0$9[ebp]
  00908	8d 44 0a 01	 lea	 eax, DWORD PTR [edx+ecx+1]
  0090c	d1 f8		 sar	 eax, 1
  0090e	6b 4d e4 00	 imul	 ecx, DWORD PTR _dst_y_pitch$[ebp], 0
  00912	8b 55 94	 mov	 edx, DWORD PTR _dstC$44[ebp]
  00915	66 89 44 4a 02	 mov	 WORD PTR [edx+ecx*2+2], ax

; 674  :                     dstC[1*dst_y_pitch   + 0] = (Tout)cy3x0;

  0091a	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  0091d	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$44[ebp]
  00920	66 8b 95 04 ff
	ff ff		 mov	 dx, WORD PTR _cy3x0$8[ebp]
  00927	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx

; 675  :                     dstC[1*dst_y_pitch   + 1] = (Tout)((cy3x0 + cy3x1 + 1) >> 1);

  0092b	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR _cy3x1$6[ebp]
  00931	8b 8d 04 ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x0$8[ebp]
  00937	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  0093b	d1 fa		 sar	 edx, 1
  0093d	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  00940	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$44[ebp]
  00943	66 89 54 41 02	 mov	 WORD PTR [ecx+eax*2+2], dx

; 676  :                 }

  00948	e9 e5 fd ff ff	 jmp	 $LN20@convert_yv
$LN31@convert_yv:

; 677  :             }
; 678  :         }

  0094d	e9 3d f9 ff ff	 jmp	 $LN11@convert_yv
$LN12@convert_yv:

; 679  :     }

  00952	e9 ee f8 ff ff	 jmp	 $LN8@convert_yv
$LN1@convert_yv:

; 680  : }

  00957	52		 push	 edx
  00958	8b cd		 mov	 ecx, ebp
  0095a	50		 push	 eax
  0095b	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN52@convert_yv
  00961	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00966	58		 pop	 eax
  00967	5a		 pop	 edx
  00968	5f		 pop	 edi
  00969	5e		 pop	 esi
  0096a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0096d	33 cd		 xor	 ecx, ebp
  0096f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00974	81 c4 2c 01 00
	00		 add	 esp, 300		; 0000012cH
  0097a	3b ec		 cmp	 ebp, esp
  0097c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00981	8b e5		 mov	 esp, ebp
  00983	5d		 pop	 ebp
  00984	c3		 ret	 0
  00985	0f 1f 00	 npad	 3
$LN52@convert_yv:
  00988	01 00 00 00	 DD	 1
  0098c	00 00 00 00	 DD	 $LN51@convert_yv
$LN51@convert_yv:
  00990	d4 ff ff ff	 DD	 -44			; ffffffd4H
  00994	0c 00 00 00	 DD	 12			; 0000000cH
  00998	00 00 00 00	 DD	 $LN50@convert_yv
$LN50@convert_yv:
  0099c	79		 DB	 121			; 00000079H
  0099d	5f		 DB	 95			; 0000005fH
  0099e	72		 DB	 114			; 00000072H
  0099f	61		 DB	 97			; 00000061H
  009a0	6e		 DB	 110			; 0000006eH
  009a1	67		 DB	 103			; 00000067H
  009a2	65		 DB	 101			; 00000065H
  009a3	00		 DB	 0
??$convert_yv12_p_to_yuv444_c@E$07G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_p_to_yuv444_c<unsigned char,8,unsigned short,16,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yv12_p_to_yuv444_16bit@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_p_to_yuv444_16bit

; 785  : static void convert_yv12_p_to_yuv444_16bit(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 786  :     convert_yv12_p_to_yuv444_c<uint8_t, 8, uint16_t, 16, false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yv12_p_to_yuv444_c@E$07G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_p_to_yuv444_c<unsigned char,8,unsigned short,16,0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 787  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yv12_p_to_yuv444_16bit@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_p_to_yuv444_16bit
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
tv289 = -280						; size = 4
tv227 = -276						; size = 4
tv228 = -272						; size = 4
tv222 = -268						; size = 4
tv219 = -264						; size = 4
tv216 = -260						; size = 4
tv214 = -256						; size = 4
$T1 = -252						; size = 4
$T2 = -248						; size = 4
$T3 = -244						; size = 4
$T4 = -240						; size = 4
$T5 = -236						; size = 12
_cy3x1$6 = -224						; size = 4
_cy2x1$7 = -220						; size = 4
_cy1x1$8 = -216						; size = 4
_cy0x1$9 = -212						; size = 4
_sy5x1$10 = -208					; size = 4
_sy4x1$11 = -204					; size = 4
_sy3x1$12 = -200					; size = 4
_sy2x1$13 = -196					; size = 4
_sy1x1$14 = -192					; size = 4
_sy0x1$15 = -188					; size = 4
_cxplus$16 = -184					; size = 4
_x$17 = -180						; size = 4
_cy3x0$18 = -176					; size = 4
_cy2x0$19 = -172					; size = 4
_cy1x0$20 = -168					; size = 4
_cy0x0$21 = -164					; size = 4
_sy5x0$22 = -160					; size = 4
_sy4x0$23 = -156					; size = 4
_sy3x0$24 = -152					; size = 4
_sy2x0$25 = -148					; size = 4
_sy1x0$26 = -144					; size = 4
_sy0x0$27 = -140					; size = 4
_y_p3$28 = -136						; size = 4
_y_p2$29 = -132						; size = 4
_y_p1$30 = -128						; size = 4
_y_m1$31 = -124						; size = 4
_y_m2$32 = -120						; size = 4
_x_fin$33 = -116					; size = 4
_srcP$34 = -112						; size = 4
_dstC$35 = -108						; size = 4
_y$36 = -104						; size = 4
_dstLine$37 = -100					; size = 4
_srcCLine$38 = -96					; size = 4
_ic$39 = -92						; size = 4
_src_uv_pitch$ = -88					; size = 4
_uv_fin$ = -84						; size = 4
_x$40 = -80						; size = 4
_y$41 = -76						; size = 4
_y_width$42 = -72					; size = 4
_dstLine$43 = -68					; size = 4
_srcYLine$44 = -64					; size = 4
$T45 = -60						; size = 12
_y_range$ = -44						; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yv12_i_to_yuv444_c@E$07E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_i_to_yuv444_c<unsigned char,8,unsigned char,8,0>

; 683  : static void __forceinline convert_yv12_i_to_yuv444_c(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  00009	53		 push	 ebx
  0000a	57		 push	 edi
  0000b	8d bd e8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-280]
  00011	b9 46 00 00 00	 mov	 ecx, 70			; 00000046H
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 684  :     static_assert((sizeof(Tin)  == 1 && in_bit_depth  == 8) || (sizeof(Tin)  == 2 && 8 < in_bit_depth  && in_bit_depth  <= 16), "invalid input bit depth.");
; 685  :     static_assert((sizeof(Tout) == 1 && out_bit_depth == 8) || (sizeof(Tout) == 2 && 8 < out_bit_depth && out_bit_depth <= 16), "invalid output bit depth.");
; 686  :     const int crop_left   = crop[0];

  00027	b8 04 00 00 00	 mov	 eax, 4
  0002c	6b c8 00	 imul	 ecx, eax, 0
  0002f	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00032	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00035	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 687  :     const int crop_up     = crop[1];

  00038	b9 04 00 00 00	 mov	 ecx, 4
  0003d	c1 e1 00	 shl	 ecx, 0
  00040	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00043	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00046	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 688  :     const int crop_right  = crop[2];

  00049	b9 04 00 00 00	 mov	 ecx, 4
  0004e	d1 e1		 shl	 ecx, 1
  00050	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00053	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00056	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 689  :     const int crop_bottom = crop[3];

  00059	b9 04 00 00 00	 mov	 ecx, 4
  0005e	6b d1 03	 imul	 edx, ecx, 3
  00061	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00064	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00067	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 690  :     const int src_y_pitch = src_y_pitch_byte / sizeof(Tin);

  0006a	8b 55 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebp]
  0006d	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 691  :     const int dst_y_pitch = dst_y_pitch_byte / sizeof(Tout);

  00070	8b 45 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  00073	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 692  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00076	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  00079	51		 push	 ecx
  0007a	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0007d	52		 push	 edx
  0007e	8b 45 20	 mov	 eax, DWORD PTR _height$[ebp]
  00081	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  00084	50		 push	 eax
  00085	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  00088	51		 push	 ecx
  00089	8d 95 14 ff ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  0008f	52		 push	 edx
  00090	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00095	83 c4 14	 add	 esp, 20			; 00000014H
  00098	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009a	89 4d c4	 mov	 DWORD PTR $T45[ebp], ecx
  0009d	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a0	89 55 c8	 mov	 DWORD PTR $T45[ebp+4], edx
  000a3	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000a6	89 45 cc	 mov	 DWORD PTR $T45[ebp+8], eax
  000a9	8b 4d c4	 mov	 ecx, DWORD PTR $T45[ebp]
  000ac	89 4d d4	 mov	 DWORD PTR _y_range$[ebp], ecx
  000af	8b 55 c8	 mov	 edx, DWORD PTR $T45[ebp+4]
  000b2	89 55 d8	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000b5	8b 45 cc	 mov	 eax, DWORD PTR $T45[ebp+8]
  000b8	89 45 dc	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 693  :     //Y
; 694  :     if (!uv_only) {

  000bb	b9 01 00 00 00	 mov	 ecx, 1
  000c0	85 c9		 test	 ecx, ecx
  000c2	0f 84 55 01 00
	00		 je	 $LN17@convert_yv

; 695  :         Tin *srcYLine = (Tin *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000c8	ba 04 00 00 00	 mov	 edx, 4
  000cd	6b c2 00	 imul	 eax, edx, 0
  000d0	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  000d3	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  000d7	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  000da	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  000dd	03 c1		 add	 eax, ecx
  000df	03 45 f8	 add	 eax, DWORD PTR _crop_left$[ebp]
  000e2	89 45 c0	 mov	 DWORD PTR _srcYLine$44[ebp], eax

; 696  :         Tout *dstLine = (Tout *)dst[0] + dst_y_pitch * y_range.start_dst;

  000e5	b9 04 00 00 00	 mov	 ecx, 4
  000ea	6b d1 00	 imul	 edx, ecx, 0
  000ed	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  000f0	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  000f4	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  000f7	03 04 11	 add	 eax, DWORD PTR [ecx+edx]
  000fa	89 45 bc	 mov	 DWORD PTR _dstLine$43[ebp], eax

; 697  :         const int y_width = width - crop_right - crop_left;

  000fd	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00100	2b 55 f0	 sub	 edx, DWORD PTR _crop_right$[ebp]
  00103	2b 55 f8	 sub	 edx, DWORD PTR _crop_left$[ebp]
  00106	89 55 b8	 mov	 DWORD PTR _y_width$42[ebp], edx

; 698  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  00109	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _y$41[ebp], 0
  00110	eb 1b		 jmp	 SHORT $LN4@convert_yv
$LN2@convert_yv:
  00112	8b 45 b4	 mov	 eax, DWORD PTR _y$41[ebp]
  00115	83 c0 01	 add	 eax, 1
  00118	89 45 b4	 mov	 DWORD PTR _y$41[ebp], eax
  0011b	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$44[ebp]
  0011e	03 4d e8	 add	 ecx, DWORD PTR _src_y_pitch$[ebp]
  00121	89 4d c0	 mov	 DWORD PTR _srcYLine$44[ebp], ecx
  00124	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$43[ebp]
  00127	03 55 e4	 add	 edx, DWORD PTR _dst_y_pitch$[ebp]
  0012a	89 55 bc	 mov	 DWORD PTR _dstLine$43[ebp], edx
$LN4@convert_yv:
  0012d	8b 45 b4	 mov	 eax, DWORD PTR _y$41[ebp]
  00130	3b 45 dc	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  00133	0f 8d e4 00 00
	00		 jge	 $LN17@convert_yv

; 699  :             if (in_bit_depth == out_bit_depth) {

  00139	b9 01 00 00 00	 mov	 ecx, 1
  0013e	85 c9		 test	 ecx, ecx
  00140	74 19		 je	 SHORT $LN18@convert_yv

; 700  :                 memcpy(dstLine, srcYLine, y_width * sizeof(Tin));

  00142	8b 55 b8	 mov	 edx, DWORD PTR _y_width$42[ebp]
  00145	52		 push	 edx
  00146	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$44[ebp]
  00149	50		 push	 eax
  0014a	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$43[ebp]
  0014d	51		 push	 ecx
  0014e	e8 00 00 00 00	 call	 _memcpy
  00153	83 c4 0c	 add	 esp, 12			; 0000000cH

; 701  :             } else {

  00156	e9 bd 00 00 00	 jmp	 $LN19@convert_yv
$LN18@convert_yv:

; 702  :                 for (int x = 0; x < y_width; x++) {

  0015b	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _x$40[ebp], 0
  00162	eb 09		 jmp	 SHORT $LN7@convert_yv
$LN5@convert_yv:
  00164	8b 55 b0	 mov	 edx, DWORD PTR _x$40[ebp]
  00167	83 c2 01	 add	 edx, 1
  0016a	89 55 b0	 mov	 DWORD PTR _x$40[ebp], edx
$LN7@convert_yv:
  0016d	8b 45 b0	 mov	 eax, DWORD PTR _x$40[ebp]
  00170	3b 45 b8	 cmp	 eax, DWORD PTR _y_width$42[ebp]
  00173	0f 8d 9f 00 00
	00		 jge	 $LN19@convert_yv

; 703  :                     if (out_bit_depth > in_bit_depth) {

  00179	33 c9		 xor	 ecx, ecx
  0017b	74 41		 je	 SHORT $LN20@convert_yv

; 704  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) << std::max(out_bit_depth - in_bit_depth, 0));

  0017d	c7 85 10 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], 0
  00187	c7 85 0c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T3[ebp], 0
  00191	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$44[ebp]
  00194	03 55 b0	 add	 edx, DWORD PTR _x$40[ebp]
  00197	0f b6 1a	 movzx	 ebx, BYTE PTR [edx]
  0019a	8d 85 10 ff ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  001a0	50		 push	 eax
  001a1	8d 8d 0c ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  001a7	51		 push	 ecx
  001a8	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  001ad	83 c4 08	 add	 esp, 8
  001b0	8b 08		 mov	 ecx, DWORD PTR [eax]
  001b2	d3 e3		 shl	 ebx, cl
  001b4	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$43[ebp]
  001b7	03 55 b0	 add	 edx, DWORD PTR _x$40[ebp]
  001ba	88 1a		 mov	 BYTE PTR [edx], bl
  001bc	eb 55		 jmp	 SHORT $LN21@convert_yv
$LN20@convert_yv:

; 705  :                     } else if (out_bit_depth < in_bit_depth) {

  001be	33 c0		 xor	 eax, eax
  001c0	74 41		 je	 SHORT $LN22@convert_yv

; 706  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) >> std::max(in_bit_depth - out_bit_depth, 0));

  001c2	c7 85 08 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], 0
  001cc	c7 85 04 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T1[ebp], 0
  001d6	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$44[ebp]
  001d9	03 4d b0	 add	 ecx, DWORD PTR _x$40[ebp]
  001dc	0f b6 19	 movzx	 ebx, BYTE PTR [ecx]
  001df	8d 95 08 ff ff
	ff		 lea	 edx, DWORD PTR $T2[ebp]
  001e5	52		 push	 edx
  001e6	8d 85 04 ff ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  001ec	50		 push	 eax
  001ed	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  001f2	83 c4 08	 add	 esp, 8
  001f5	8b 08		 mov	 ecx, DWORD PTR [eax]
  001f7	d3 fb		 sar	 ebx, cl
  001f9	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$43[ebp]
  001fc	03 4d b0	 add	 ecx, DWORD PTR _x$40[ebp]
  001ff	88 19		 mov	 BYTE PTR [ecx], bl

; 707  :                     } else {

  00201	eb 10		 jmp	 SHORT $LN21@convert_yv
$LN22@convert_yv:

; 708  :                         dstLine[x] = (Tout)srcYLine[x];

  00203	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$43[ebp]
  00206	03 55 b0	 add	 edx, DWORD PTR _x$40[ebp]
  00209	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$44[ebp]
  0020c	03 45 b0	 add	 eax, DWORD PTR _x$40[ebp]
  0020f	8a 08		 mov	 cl, BYTE PTR [eax]
  00211	88 0a		 mov	 BYTE PTR [edx], cl
$LN21@convert_yv:

; 709  :                     }
; 710  :                 }

  00213	e9 4c ff ff ff	 jmp	 $LN5@convert_yv
$LN19@convert_yv:

; 711  :             }
; 712  :         }

  00218	e9 f5 fe ff ff	 jmp	 $LN2@convert_yv
$LN17@convert_yv:

; 713  :     }
; 714  :     //UV
; 715  :     const int uv_fin = height - crop_bottom;

  0021d	8b 55 20	 mov	 edx, DWORD PTR _height$[ebp]
  00220	2b 55 ec	 sub	 edx, DWORD PTR _crop_bottom$[ebp]
  00223	89 55 ac	 mov	 DWORD PTR _uv_fin$[ebp], edx

; 716  :     const int src_uv_pitch = src_uv_pitch_byte / sizeof(Tin);

  00226	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  00229	89 45 a8	 mov	 DWORD PTR _src_uv_pitch$[ebp], eax

; 717  :     for (int ic = 1; ic < 3; ic++) {

  0022c	c7 45 a4 01 00
	00 00		 mov	 DWORD PTR _ic$39[ebp], 1
  00233	eb 09		 jmp	 SHORT $LN10@convert_yv
$LN8@convert_yv:
  00235	8b 4d a4	 mov	 ecx, DWORD PTR _ic$39[ebp]
  00238	83 c1 01	 add	 ecx, 1
  0023b	89 4d a4	 mov	 DWORD PTR _ic$39[ebp], ecx
$LN10@convert_yv:
  0023e	83 7d a4 03	 cmp	 DWORD PTR _ic$39[ebp], 3
  00242	0f 8d a7 05 00
	00		 jge	 $LN1@convert_yv

; 718  :         Tin *srcCLine = (Tin *)src[ic] + (((src_uv_pitch * y_range.start_src) + crop_left) >> 1);

  00248	8b 55 a8	 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  0024b	0f af 55 d4	 imul	 edx, DWORD PTR _y_range$[ebp]
  0024f	03 55 f8	 add	 edx, DWORD PTR _crop_left$[ebp]
  00252	d1 fa		 sar	 edx, 1
  00254	8b 45 a4	 mov	 eax, DWORD PTR _ic$39[ebp]
  00257	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  0025a	03 14 81	 add	 edx, DWORD PTR [ecx+eax*4]
  0025d	89 55 a0	 mov	 DWORD PTR _srcCLine$38[ebp], edx

; 719  :         Tout *dstLine = (Tout *)dst[ic] + dst_y_pitch * y_range.start_dst;

  00260	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  00263	0f af 55 d8	 imul	 edx, DWORD PTR _y_range$[ebp+4]
  00267	8b 45 a4	 mov	 eax, DWORD PTR _ic$39[ebp]
  0026a	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0026d	03 14 81	 add	 edx, DWORD PTR [ecx+eax*4]
  00270	89 55 9c	 mov	 DWORD PTR _dstLine$37[ebp], edx

; 720  :         for (int y = 0; y < y_range.len; y += 4, srcCLine += src_uv_pitch * 2, dstLine += dst_y_pitch * 4) {

  00273	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _y$36[ebp], 0
  0027a	eb 21		 jmp	 SHORT $LN13@convert_yv
$LN11@convert_yv:
  0027c	8b 55 98	 mov	 edx, DWORD PTR _y$36[ebp]
  0027f	83 c2 04	 add	 edx, 4
  00282	89 55 98	 mov	 DWORD PTR _y$36[ebp], edx
  00285	8b 45 a8	 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  00288	8b 4d a0	 mov	 ecx, DWORD PTR _srcCLine$38[ebp]
  0028b	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  0028e	89 55 a0	 mov	 DWORD PTR _srcCLine$38[ebp], edx
  00291	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  00294	8b 4d 9c	 mov	 ecx, DWORD PTR _dstLine$37[ebp]
  00297	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  0029a	89 55 9c	 mov	 DWORD PTR _dstLine$37[ebp], edx
$LN13@convert_yv:
  0029d	8b 45 98	 mov	 eax, DWORD PTR _y$36[ebp]
  002a0	3b 45 dc	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  002a3	0f 8d 41 05 00
	00		 jge	 $LN12@convert_yv

; 721  :             Tout *dstC = dstLine;

  002a9	8b 4d 9c	 mov	 ecx, DWORD PTR _dstLine$37[ebp]
  002ac	89 4d 94	 mov	 DWORD PTR _dstC$35[ebp], ecx

; 722  :             Tin *srcP = srcCLine;

  002af	8b 55 a0	 mov	 edx, DWORD PTR _srcCLine$38[ebp]
  002b2	89 55 90	 mov	 DWORD PTR _srcP$34[ebp], edx

; 723  :             const int x_fin = width - crop_right - crop_left;

  002b5	8b 45 10	 mov	 eax, DWORD PTR _width$[ebp]
  002b8	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  002bb	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  002be	89 45 8c	 mov	 DWORD PTR _x_fin$33[ebp], eax

; 724  : 
; 725  :             int y_m2 = (y >= 4) ? -2 : 0;

  002c1	83 7d 98 04	 cmp	 DWORD PTR _y$36[ebp], 4
  002c5	7c 0c		 jl	 SHORT $LN31@convert_yv
  002c7	c7 85 00 ff ff
	ff fe ff ff ff	 mov	 DWORD PTR tv214[ebp], -2 ; fffffffeH
  002d1	eb 0a		 jmp	 SHORT $LN32@convert_yv
$LN31@convert_yv:
  002d3	c7 85 00 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv214[ebp], 0
$LN32@convert_yv:
  002dd	8b 8d 00 ff ff
	ff		 mov	 ecx, DWORD PTR tv214[ebp]
  002e3	89 4d 88	 mov	 DWORD PTR _y_m2$32[ebp], ecx

; 726  :             int y_m1 = (y >= 2) ? -1 : 1;

  002e6	83 7d 98 02	 cmp	 DWORD PTR _y$36[ebp], 2
  002ea	7c 0c		 jl	 SHORT $LN33@convert_yv
  002ec	c7 85 fc fe ff
	ff ff ff ff ff	 mov	 DWORD PTR tv216[ebp], -1
  002f6	eb 0a		 jmp	 SHORT $LN34@convert_yv
$LN33@convert_yv:
  002f8	c7 85 fc fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv216[ebp], 1
$LN34@convert_yv:
  00302	8b 95 fc fe ff
	ff		 mov	 edx, DWORD PTR tv216[ebp]
  00308	89 55 84	 mov	 DWORD PTR _y_m1$31[ebp], edx

; 727  :             int y_p1 = (y < uv_fin - 2) ? 1 : -1;

  0030b	8b 45 ac	 mov	 eax, DWORD PTR _uv_fin$[ebp]
  0030e	83 e8 02	 sub	 eax, 2
  00311	39 45 98	 cmp	 DWORD PTR _y$36[ebp], eax
  00314	7d 0c		 jge	 SHORT $LN35@convert_yv
  00316	c7 85 f8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv219[ebp], 1
  00320	eb 0a		 jmp	 SHORT $LN36@convert_yv
$LN35@convert_yv:
  00322	c7 85 f8 fe ff
	ff ff ff ff ff	 mov	 DWORD PTR tv219[ebp], -1
$LN36@convert_yv:
  0032c	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR tv219[ebp]
  00332	89 4d 80	 mov	 DWORD PTR _y_p1$30[ebp], ecx

; 728  :             int y_p2 = (y < uv_fin - 4) ? 2 :  0;

  00335	8b 55 ac	 mov	 edx, DWORD PTR _uv_fin$[ebp]
  00338	83 ea 04	 sub	 edx, 4
  0033b	39 55 98	 cmp	 DWORD PTR _y$36[ebp], edx
  0033e	7d 0c		 jge	 SHORT $LN37@convert_yv
  00340	c7 85 f4 fe ff
	ff 02 00 00 00	 mov	 DWORD PTR tv222[ebp], 2
  0034a	eb 0a		 jmp	 SHORT $LN38@convert_yv
$LN37@convert_yv:
  0034c	c7 85 f4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv222[ebp], 0
$LN38@convert_yv:
  00356	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR tv222[ebp]
  0035c	89 85 7c ff ff
	ff		 mov	 DWORD PTR _y_p2$29[ebp], eax

; 729  :             int y_p3 = (y < uv_fin - 6) ? 3 : ((y < uv_fin - 2) ? 1 : -1);

  00362	8b 4d ac	 mov	 ecx, DWORD PTR _uv_fin$[ebp]
  00365	83 e9 06	 sub	 ecx, 6
  00368	39 4d 98	 cmp	 DWORD PTR _y$36[ebp], ecx
  0036b	7d 0c		 jge	 SHORT $LN41@convert_yv
  0036d	c7 85 f0 fe ff
	ff 03 00 00 00	 mov	 DWORD PTR tv228[ebp], 3
  00377	eb 2d		 jmp	 SHORT $LN42@convert_yv
$LN41@convert_yv:
  00379	8b 55 ac	 mov	 edx, DWORD PTR _uv_fin$[ebp]
  0037c	83 ea 02	 sub	 edx, 2
  0037f	39 55 98	 cmp	 DWORD PTR _y$36[ebp], edx
  00382	7d 0c		 jge	 SHORT $LN39@convert_yv
  00384	c7 85 ec fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv227[ebp], 1
  0038e	eb 0a		 jmp	 SHORT $LN40@convert_yv
$LN39@convert_yv:
  00390	c7 85 ec fe ff
	ff ff ff ff ff	 mov	 DWORD PTR tv227[ebp], -1
$LN40@convert_yv:
  0039a	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR tv227[ebp]
  003a0	89 85 f0 fe ff
	ff		 mov	 DWORD PTR tv228[ebp], eax
$LN42@convert_yv:
  003a6	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR tv228[ebp]
  003ac	89 8d 78 ff ff
	ff		 mov	 DWORD PTR _y_p3$28[ebp], ecx

; 730  : 
; 731  :             int sy0x0 = srcP[y_m2*src_uv_pitch + 0];

  003b2	8b 55 88	 mov	 edx, DWORD PTR _y_m2$32[ebp]
  003b5	0f af 55 a8	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp]
  003b9	8b 45 90	 mov	 eax, DWORD PTR _srcP$34[ebp]
  003bc	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  003c0	89 8d 74 ff ff
	ff		 mov	 DWORD PTR _sy0x0$27[ebp], ecx

; 732  :             int sy1x0 = srcP[y_m1*src_uv_pitch + 0];

  003c6	8b 55 84	 mov	 edx, DWORD PTR _y_m1$31[ebp]
  003c9	0f af 55 a8	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp]
  003cd	8b 45 90	 mov	 eax, DWORD PTR _srcP$34[ebp]
  003d0	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  003d4	89 8d 70 ff ff
	ff		 mov	 DWORD PTR _sy1x0$26[ebp], ecx

; 733  :             int sy2x0 = srcP[   0*src_uv_pitch + 0];

  003da	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  003de	8b 45 90	 mov	 eax, DWORD PTR _srcP$34[ebp]
  003e1	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  003e5	89 8d 6c ff ff
	ff		 mov	 DWORD PTR _sy2x0$25[ebp], ecx

; 734  :             int sy3x0 = srcP[y_p1*src_uv_pitch + 0];

  003eb	8b 55 80	 mov	 edx, DWORD PTR _y_p1$30[ebp]
  003ee	0f af 55 a8	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp]
  003f2	8b 45 90	 mov	 eax, DWORD PTR _srcP$34[ebp]
  003f5	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  003f9	89 8d 68 ff ff
	ff		 mov	 DWORD PTR _sy3x0$24[ebp], ecx

; 735  :             int sy4x0 = srcP[y_p2*src_uv_pitch + 0];

  003ff	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR _y_p2$29[ebp]
  00405	0f af 55 a8	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp]
  00409	8b 45 90	 mov	 eax, DWORD PTR _srcP$34[ebp]
  0040c	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  00410	89 8d 64 ff ff
	ff		 mov	 DWORD PTR _sy4x0$23[ebp], ecx

; 736  :             int sy5x0 = srcP[y_p3*src_uv_pitch + 0];

  00416	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _y_p3$28[ebp]
  0041c	0f af 55 a8	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp]
  00420	8b 45 90	 mov	 eax, DWORD PTR _srcP$34[ebp]
  00423	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  00427	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _sy5x0$22[ebp], ecx

; 737  : 
; 738  :             int cy0x0 = (sy0x0 * 1 + sy2x0 * 7 + 4);

  0042d	6b 95 6c ff ff
	ff 07		 imul	 edx, DWORD PTR _sy2x0$25[ebp], 7
  00434	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _sy0x0$27[ebp]
  0043a	8d 4c 10 04	 lea	 ecx, DWORD PTR [eax+edx+4]
  0043e	89 8d 5c ff ff
	ff		 mov	 DWORD PTR _cy0x0$21[ebp], ecx

; 739  :             int cy1x0 = (sy1x0 * 3 + sy3x0 * 5 + 4);

  00444	6b 95 70 ff ff
	ff 03		 imul	 edx, DWORD PTR _sy1x0$26[ebp], 3
  0044b	6b 85 68 ff ff
	ff 05		 imul	 eax, DWORD PTR _sy3x0$24[ebp], 5
  00452	8d 4c 02 04	 lea	 ecx, DWORD PTR [edx+eax+4]
  00456	89 8d 58 ff ff
	ff		 mov	 DWORD PTR _cy1x0$20[ebp], ecx

; 740  :             int cy2x0 = (sy2x0 * 5 + sy4x0 * 3 + 4);

  0045c	6b 95 6c ff ff
	ff 05		 imul	 edx, DWORD PTR _sy2x0$25[ebp], 5
  00463	6b 85 64 ff ff
	ff 03		 imul	 eax, DWORD PTR _sy4x0$23[ebp], 3
  0046a	8d 4c 02 04	 lea	 ecx, DWORD PTR [edx+eax+4]
  0046e	89 8d 54 ff ff
	ff		 mov	 DWORD PTR _cy2x0$19[ebp], ecx

; 741  :             int cy3x0 = (sy3x0 * 7 + sy5x0 * 1 + 4);

  00474	6b 95 68 ff ff
	ff 07		 imul	 edx, DWORD PTR _sy3x0$24[ebp], 7
  0047b	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _sy5x0$22[ebp]
  00481	8d 4c 02 04	 lea	 ecx, DWORD PTR [edx+eax+4]
  00485	89 8d 50 ff ff
	ff		 mov	 DWORD PTR _cy3x0$18[ebp], ecx

; 742  :             CHANGE_BIT_DEPTH_4(cy0x0, cy1x0, cy2x0, cy3x0, 3);

  0048b	33 d2		 xor	 edx, edx
  0048d	74 3e		 je	 SHORT $LN24@convert_yv
  0048f	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _cy0x0$21[ebp]
  00495	c1 e0 fd	 shl	 eax, -3			; fffffffdH
  00498	89 85 5c ff ff
	ff		 mov	 DWORD PTR _cy0x0$21[ebp], eax
  0049e	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x0$20[ebp]
  004a4	c1 e1 fd	 shl	 ecx, -3			; fffffffdH
  004a7	89 8d 58 ff ff
	ff		 mov	 DWORD PTR _cy1x0$20[ebp], ecx
  004ad	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR _cy2x0$19[ebp]
  004b3	c1 e2 fd	 shl	 edx, -3			; fffffffdH
  004b6	89 95 54 ff ff
	ff		 mov	 DWORD PTR _cy2x0$19[ebp], edx
  004bc	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$18[ebp]
  004c2	c1 e0 fd	 shl	 eax, -3			; fffffffdH
  004c5	89 85 50 ff ff
	ff		 mov	 DWORD PTR _cy3x0$18[ebp], eax
  004cb	eb 45		 jmp	 SHORT $LN25@convert_yv
$LN24@convert_yv:
  004cd	b9 01 00 00 00	 mov	 ecx, 1
  004d2	85 c9		 test	 ecx, ecx
  004d4	74 3c		 je	 SHORT $LN25@convert_yv
  004d6	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR _cy0x0$21[ebp]
  004dc	c1 fa 03	 sar	 edx, 3
  004df	89 95 5c ff ff
	ff		 mov	 DWORD PTR _cy0x0$21[ebp], edx
  004e5	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x0$20[ebp]
  004eb	c1 f8 03	 sar	 eax, 3
  004ee	89 85 58 ff ff
	ff		 mov	 DWORD PTR _cy1x0$20[ebp], eax
  004f4	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _cy2x0$19[ebp]
  004fa	c1 f9 03	 sar	 ecx, 3
  004fd	89 8d 54 ff ff
	ff		 mov	 DWORD PTR _cy2x0$19[ebp], ecx
  00503	8b 95 50 ff ff
	ff		 mov	 edx, DWORD PTR _cy3x0$18[ebp]
  00509	c1 fa 03	 sar	 edx, 3
  0050c	89 95 50 ff ff
	ff		 mov	 DWORD PTR _cy3x0$18[ebp], edx
$LN25@convert_yv:

; 743  : 
; 744  :             for (int x = 0; x < x_fin; x += 2, dstC += 2, srcP++) {

  00512	c7 85 4c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _x$17[ebp], 0
  0051c	eb 21		 jmp	 SHORT $LN16@convert_yv
$LN14@convert_yv:
  0051e	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _x$17[ebp]
  00524	83 c0 02	 add	 eax, 2
  00527	89 85 4c ff ff
	ff		 mov	 DWORD PTR _x$17[ebp], eax
  0052d	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$35[ebp]
  00530	83 c1 02	 add	 ecx, 2
  00533	89 4d 94	 mov	 DWORD PTR _dstC$35[ebp], ecx
  00536	8b 55 90	 mov	 edx, DWORD PTR _srcP$34[ebp]
  00539	83 c2 01	 add	 edx, 1
  0053c	89 55 90	 mov	 DWORD PTR _srcP$34[ebp], edx
$LN16@convert_yv:
  0053f	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _x$17[ebp]
  00545	3b 45 8c	 cmp	 eax, DWORD PTR _x_fin$33[ebp]
  00548	0f 8d 97 02 00
	00		 jge	 $LN15@convert_yv

; 745  :                 int cxplus = (x + 2 < x_fin);

  0054e	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _x$17[ebp]
  00554	83 c1 02	 add	 ecx, 2
  00557	3b 4d 8c	 cmp	 ecx, DWORD PTR _x_fin$33[ebp]
  0055a	7d 0c		 jge	 SHORT $LN43@convert_yv
  0055c	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv289[ebp], 1
  00566	eb 0a		 jmp	 SHORT $LN44@convert_yv
$LN43@convert_yv:
  00568	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv289[ebp], 0
$LN44@convert_yv:
  00572	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR tv289[ebp]
  00578	89 95 48 ff ff
	ff		 mov	 DWORD PTR _cxplus$16[ebp], edx

; 746  :                 int sy0x1 = srcP[y_m2*src_uv_pitch + cxplus];

  0057e	8b 45 88	 mov	 eax, DWORD PTR _y_m2$32[ebp]
  00581	0f af 45 a8	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp]
  00585	03 85 48 ff ff
	ff		 add	 eax, DWORD PTR _cxplus$16[ebp]
  0058b	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  0058e	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00592	89 95 44 ff ff
	ff		 mov	 DWORD PTR _sy0x1$15[ebp], edx

; 747  :                 int sy1x1 = srcP[y_m1*src_uv_pitch + cxplus];

  00598	8b 45 84	 mov	 eax, DWORD PTR _y_m1$31[ebp]
  0059b	0f af 45 a8	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp]
  0059f	03 85 48 ff ff
	ff		 add	 eax, DWORD PTR _cxplus$16[ebp]
  005a5	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  005a8	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  005ac	89 95 40 ff ff
	ff		 mov	 DWORD PTR _sy1x1$14[ebp], edx

; 748  :                 int sy2x1 = srcP[   0*src_uv_pitch + cxplus];

  005b2	6b 45 a8 00	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp], 0
  005b6	03 85 48 ff ff
	ff		 add	 eax, DWORD PTR _cxplus$16[ebp]
  005bc	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  005bf	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  005c3	89 95 3c ff ff
	ff		 mov	 DWORD PTR _sy2x1$13[ebp], edx

; 749  :                 int sy3x1 = srcP[y_p1*src_uv_pitch + cxplus];

  005c9	8b 45 80	 mov	 eax, DWORD PTR _y_p1$30[ebp]
  005cc	0f af 45 a8	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp]
  005d0	03 85 48 ff ff
	ff		 add	 eax, DWORD PTR _cxplus$16[ebp]
  005d6	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  005d9	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  005dd	89 95 38 ff ff
	ff		 mov	 DWORD PTR _sy3x1$12[ebp], edx

; 750  :                 int sy4x1 = srcP[y_p2*src_uv_pitch + cxplus];

  005e3	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _y_p2$29[ebp]
  005e9	0f af 45 a8	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp]
  005ed	03 85 48 ff ff
	ff		 add	 eax, DWORD PTR _cxplus$16[ebp]
  005f3	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  005f6	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  005fa	89 95 34 ff ff
	ff		 mov	 DWORD PTR _sy4x1$11[ebp], edx

; 751  :                 int sy5x1 = srcP[y_p3*src_uv_pitch + cxplus];

  00600	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _y_p3$28[ebp]
  00606	0f af 45 a8	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp]
  0060a	03 85 48 ff ff
	ff		 add	 eax, DWORD PTR _cxplus$16[ebp]
  00610	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$34[ebp]
  00613	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00617	89 95 30 ff ff
	ff		 mov	 DWORD PTR _sy5x1$10[ebp], edx

; 752  : 
; 753  :                 int cy0x1 = (sy0x1 * 1 + sy2x1 * 7 + 4);

  0061d	6b 85 3c ff ff
	ff 07		 imul	 eax, DWORD PTR _sy2x1$13[ebp], 7
  00624	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _sy0x1$15[ebp]
  0062a	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0062e	89 95 2c ff ff
	ff		 mov	 DWORD PTR _cy0x1$9[ebp], edx

; 754  :                 int cy1x1 = (sy1x1 * 3 + sy3x1 * 5 + 4);

  00634	6b 85 40 ff ff
	ff 03		 imul	 eax, DWORD PTR _sy1x1$14[ebp], 3
  0063b	6b 8d 38 ff ff
	ff 05		 imul	 ecx, DWORD PTR _sy3x1$12[ebp], 5
  00642	8d 54 08 04	 lea	 edx, DWORD PTR [eax+ecx+4]
  00646	89 95 28 ff ff
	ff		 mov	 DWORD PTR _cy1x1$8[ebp], edx

; 755  :                 int cy2x1 = (sy2x1 * 5 + sy4x1 * 3 + 4);

  0064c	6b 85 3c ff ff
	ff 05		 imul	 eax, DWORD PTR _sy2x1$13[ebp], 5
  00653	6b 8d 34 ff ff
	ff 03		 imul	 ecx, DWORD PTR _sy4x1$11[ebp], 3
  0065a	8d 54 08 04	 lea	 edx, DWORD PTR [eax+ecx+4]
  0065e	89 95 24 ff ff
	ff		 mov	 DWORD PTR _cy2x1$7[ebp], edx

; 756  :                 int cy3x1 = (sy3x1 * 7 + sy5x1 * 1 + 4);

  00664	6b 85 38 ff ff
	ff 07		 imul	 eax, DWORD PTR _sy3x1$12[ebp], 7
  0066b	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR _sy5x1$10[ebp]
  00671	8d 54 08 04	 lea	 edx, DWORD PTR [eax+ecx+4]
  00675	89 95 20 ff ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], edx

; 757  :                 CHANGE_BIT_DEPTH_4(cy0x1, cy1x1, cy2x1, cy3x1, 3);

  0067b	33 c0		 xor	 eax, eax
  0067d	74 3e		 je	 SHORT $LN27@convert_yv
  0067f	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR _cy0x1$9[ebp]
  00685	c1 e1 fd	 shl	 ecx, -3			; fffffffdH
  00688	89 8d 2c ff ff
	ff		 mov	 DWORD PTR _cy0x1$9[ebp], ecx
  0068e	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x1$8[ebp]
  00694	c1 e2 fd	 shl	 edx, -3			; fffffffdH
  00697	89 95 28 ff ff
	ff		 mov	 DWORD PTR _cy1x1$8[ebp], edx
  0069d	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _cy2x1$7[ebp]
  006a3	c1 e0 fd	 shl	 eax, -3			; fffffffdH
  006a6	89 85 24 ff ff
	ff		 mov	 DWORD PTR _cy2x1$7[ebp], eax
  006ac	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x1$6[ebp]
  006b2	c1 e1 fd	 shl	 ecx, -3			; fffffffdH
  006b5	89 8d 20 ff ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], ecx
  006bb	eb 45		 jmp	 SHORT $LN28@convert_yv
$LN27@convert_yv:
  006bd	ba 01 00 00 00	 mov	 edx, 1
  006c2	85 d2		 test	 edx, edx
  006c4	74 3c		 je	 SHORT $LN28@convert_yv
  006c6	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR _cy0x1$9[ebp]
  006cc	c1 f8 03	 sar	 eax, 3
  006cf	89 85 2c ff ff
	ff		 mov	 DWORD PTR _cy0x1$9[ebp], eax
  006d5	8b 8d 28 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x1$8[ebp]
  006db	c1 f9 03	 sar	 ecx, 3
  006de	89 8d 28 ff ff
	ff		 mov	 DWORD PTR _cy1x1$8[ebp], ecx
  006e4	8b 95 24 ff ff
	ff		 mov	 edx, DWORD PTR _cy2x1$7[ebp]
  006ea	c1 fa 03	 sar	 edx, 3
  006ed	89 95 24 ff ff
	ff		 mov	 DWORD PTR _cy2x1$7[ebp], edx
  006f3	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x1$6[ebp]
  006f9	c1 f8 03	 sar	 eax, 3
  006fc	89 85 20 ff ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], eax
$LN28@convert_yv:

; 758  : 
; 759  :                 dstC[0*dst_y_pitch   + 0] = (Tout)cy0x0;

  00702	6b 4d e4 00	 imul	 ecx, DWORD PTR _dst_y_pitch$[ebp], 0
  00706	8b 55 94	 mov	 edx, DWORD PTR _dstC$35[ebp]
  00709	8a 85 5c ff ff
	ff		 mov	 al, BYTE PTR _cy0x0$21[ebp]
  0070f	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 760  :                 dstC[0*dst_y_pitch   + 1] = (Tout)((cy0x0 + cy0x1 + 1) >> 1);

  00712	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR _cy0x1$9[ebp]
  00718	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR _cy0x0$21[ebp]
  0071e	8d 44 0a 01	 lea	 eax, DWORD PTR [edx+ecx+1]
  00722	d1 f8		 sar	 eax, 1
  00724	6b 4d e4 00	 imul	 ecx, DWORD PTR _dst_y_pitch$[ebp], 0
  00728	8b 55 94	 mov	 edx, DWORD PTR _dstC$35[ebp]
  0072b	88 44 0a 01	 mov	 BYTE PTR [edx+ecx+1], al

; 761  :                 dstC[1*dst_y_pitch   + 0] = (Tout)cy1x0;

  0072f	8b 45 94	 mov	 eax, DWORD PTR _dstC$35[ebp]
  00732	03 45 e4	 add	 eax, DWORD PTR _dst_y_pitch$[ebp]
  00735	8a 8d 58 ff ff
	ff		 mov	 cl, BYTE PTR _cy1x0$20[ebp]
  0073b	88 08		 mov	 BYTE PTR [eax], cl

; 762  :                 dstC[1*dst_y_pitch   + 1] = (Tout)((cy1x0 + cy1x1 + 1) >> 1);

  0073d	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x1$8[ebp]
  00743	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x0$20[ebp]
  00749	8d 4c 10 01	 lea	 ecx, DWORD PTR [eax+edx+1]
  0074d	d1 f9		 sar	 ecx, 1
  0074f	8b 55 94	 mov	 edx, DWORD PTR _dstC$35[ebp]
  00752	03 55 e4	 add	 edx, DWORD PTR _dst_y_pitch$[ebp]
  00755	88 4a 01	 mov	 BYTE PTR [edx+1], cl

; 763  :                 dstC[2*dst_y_pitch   + 0] = (Tout)cy2x0;

  00758	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  0075b	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$35[ebp]
  0075e	8a 95 54 ff ff
	ff		 mov	 dl, BYTE PTR _cy2x0$19[ebp]
  00764	88 14 41	 mov	 BYTE PTR [ecx+eax*2], dl

; 764  :                 dstC[2*dst_y_pitch   + 1] = (Tout)((cy2x0 + cy2x1 + 1) >> 1);

  00767	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _cy2x1$7[ebp]
  0076d	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _cy2x0$19[ebp]
  00773	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  00777	d1 fa		 sar	 edx, 1
  00779	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  0077c	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$35[ebp]
  0077f	88 54 41 01	 mov	 BYTE PTR [ecx+eax*2+1], dl

; 765  :                 dstC[3*dst_y_pitch   + 0] = (Tout)cy3x0;

  00783	6b 55 e4 03	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 3
  00787	8b 45 94	 mov	 eax, DWORD PTR _dstC$35[ebp]
  0078a	8a 8d 50 ff ff
	ff		 mov	 cl, BYTE PTR _cy3x0$18[ebp]
  00790	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 766  :                 dstC[3*dst_y_pitch   + 1] = (Tout)((cy3x0 + cy3x1 + 1) >> 1);

  00793	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR _cy3x1$6[ebp]
  00799	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$18[ebp]
  0079f	8d 4c 10 01	 lea	 ecx, DWORD PTR [eax+edx+1]
  007a3	d1 f9		 sar	 ecx, 1
  007a5	6b 55 e4 03	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 3
  007a9	8b 45 94	 mov	 eax, DWORD PTR _dstC$35[ebp]
  007ac	88 4c 10 01	 mov	 BYTE PTR [eax+edx+1], cl

; 767  : 
; 768  :                 cy0x0 = cy0x1;

  007b0	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR _cy0x1$9[ebp]
  007b6	89 8d 5c ff ff
	ff		 mov	 DWORD PTR _cy0x0$21[ebp], ecx

; 769  :                 cy1x0 = cy1x1;

  007bc	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x1$8[ebp]
  007c2	89 95 58 ff ff
	ff		 mov	 DWORD PTR _cy1x0$20[ebp], edx

; 770  :                 cy2x0 = cy2x1;

  007c8	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _cy2x1$7[ebp]
  007ce	89 85 54 ff ff
	ff		 mov	 DWORD PTR _cy2x0$19[ebp], eax

; 771  :                 cy3x0 = cy3x1;

  007d4	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x1$6[ebp]
  007da	89 8d 50 ff ff
	ff		 mov	 DWORD PTR _cy3x0$18[ebp], ecx

; 772  :             }

  007e0	e9 39 fd ff ff	 jmp	 $LN14@convert_yv
$LN15@convert_yv:

; 773  :         }

  007e5	e9 92 fa ff ff	 jmp	 $LN11@convert_yv
$LN12@convert_yv:

; 774  :     }

  007ea	e9 46 fa ff ff	 jmp	 $LN8@convert_yv
$LN1@convert_yv:

; 775  : }

  007ef	52		 push	 edx
  007f0	8b cd		 mov	 ecx, ebp
  007f2	50		 push	 eax
  007f3	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN47@convert_yv
  007f9	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  007fe	58		 pop	 eax
  007ff	5a		 pop	 edx
  00800	5f		 pop	 edi
  00801	5b		 pop	 ebx
  00802	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00805	33 cd		 xor	 ecx, ebp
  00807	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0080c	81 c4 18 01 00
	00		 add	 esp, 280		; 00000118H
  00812	3b ec		 cmp	 ebp, esp
  00814	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00819	8b e5		 mov	 esp, ebp
  0081b	5d		 pop	 ebp
  0081c	c3		 ret	 0
  0081d	0f 1f 00	 npad	 3
$LN47@convert_yv:
  00820	01 00 00 00	 DD	 1
  00824	00 00 00 00	 DD	 $LN46@convert_yv
$LN46@convert_yv:
  00828	d4 ff ff ff	 DD	 -44			; ffffffd4H
  0082c	0c 00 00 00	 DD	 12			; 0000000cH
  00830	00 00 00 00	 DD	 $LN45@convert_yv
$LN45@convert_yv:
  00834	79		 DB	 121			; 00000079H
  00835	5f		 DB	 95			; 0000005fH
  00836	72		 DB	 114			; 00000072H
  00837	61		 DB	 97			; 00000061H
  00838	6e		 DB	 110			; 0000006eH
  00839	67		 DB	 103			; 00000067H
  0083a	65		 DB	 101			; 00000065H
  0083b	00		 DB	 0
??$convert_yv12_i_to_yuv444_c@E$07E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_i_to_yuv444_c<unsigned char,8,unsigned char,8,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yv12_i_to_yuv444@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_i_to_yuv444

; 781  : static void convert_yv12_i_to_yuv444(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 782  :     convert_yv12_i_to_yuv444_c<uint8_t, 8, uint8_t, 8, false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yv12_i_to_yuv444_c@E$07E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_i_to_yuv444_c<unsigned char,8,unsigned char,8,0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 783  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yv12_i_to_yuv444@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_i_to_yuv444
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
tv419 = -300						; size = 4
tv304 = -296						; size = 4
tv219 = -292						; size = 4
$T1 = -288						; size = 4
$T2 = -284						; size = 4
$T3 = -280						; size = 4
$T4 = -276						; size = 4
$T5 = -272						; size = 12
_cy3x1$6 = -260						; size = 4
_cy1x1$7 = -256						; size = 4
_cy3x0$8 = -252						; size = 4
_cy1x0$9 = -248						; size = 4
_cy4x1$10 = -244					; size = 4
_cy2x1$11 = -240					; size = 4
_cy0x1$12 = -236					; size = 4
_cy4x0$13 = -232					; size = 4
_cy2x0$14 = -228					; size = 4
_cy0x0$15 = -224					; size = 4
_cxplus$16 = -220					; size = 4
_x$17 = -216						; size = 4
_cy3x1$18 = -212					; size = 4
_cy1x1$19 = -208					; size = 4
_cy3x0$20 = -204					; size = 4
_cy1x0$21 = -200					; size = 4
_cy4x1$22 = -196					; size = 4
_cy2x1$23 = -192					; size = 4
_cy0x1$24 = -188					; size = 4
_cy4x0$25 = -184					; size = 4
_cy2x0$26 = -180					; size = 4
_cy0x0$27 = -176					; size = 4
_cxplus$28 = -172					; size = 4
_x$29 = -168						; size = 4
_cy3x1$30 = -164					; size = 4
_cy1x1$31 = -160					; size = 4
_cy3x0$32 = -156					; size = 4
_cy1x0$33 = -152					; size = 4
_cy4x1$34 = -148					; size = 4
_cy2x1$35 = -144					; size = 4
_cy0x1$36 = -140					; size = 4
_cy4x0$37 = -136					; size = 4
_cy2x0$38 = -132					; size = 4
_cy0x0$39 = -128					; size = 4
_cxplus$40 = -124					; size = 4
_x$41 = -120						; size = 4
_x_fin$42 = -116					; size = 4
_srcP$43 = -112						; size = 4
_dstC$44 = -108						; size = 4
_y$45 = -104						; size = 4
_dstLine$46 = -100					; size = 4
_srcCLine$47 = -96					; size = 4
_ic$48 = -92						; size = 4
_src_uv_pitch$ = -88					; size = 4
_x$49 = -84						; size = 4
_y$50 = -80						; size = 4
_y_width$51 = -76					; size = 4
_y_fin$52 = -72						; size = 4
_dstLine$53 = -68					; size = 4
_srcYLine$54 = -64					; size = 4
$T55 = -60						; size = 12
_y_range$ = -44						; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yv12_p_to_yuv444_c@E$07E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_p_to_yuv444_c<unsigned char,8,unsigned char,8,0>

; 573  : static void __forceinline convert_yv12_p_to_yuv444_c(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 2c 01 00
	00		 sub	 esp, 300		; 0000012cH
  00009	53		 push	 ebx
  0000a	57		 push	 edi
  0000b	8d bd d4 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-300]
  00011	b9 4b 00 00 00	 mov	 ecx, 75			; 0000004bH
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 574  :     static_assert((sizeof(Tin)  == 1 && in_bit_depth  == 8) || (sizeof(Tin)  == 2 && 8 < in_bit_depth  && in_bit_depth  <= 16), "invalid input bit depth.");
; 575  :     static_assert((sizeof(Tout) == 1 && out_bit_depth == 8) || (sizeof(Tout) == 2 && 8 < out_bit_depth && out_bit_depth <= 16), "invalid output bit depth.");
; 576  :     const int crop_left   = crop[0];

  00027	b8 04 00 00 00	 mov	 eax, 4
  0002c	6b c8 00	 imul	 ecx, eax, 0
  0002f	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00032	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00035	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 577  :     const int crop_up     = crop[1];

  00038	b9 04 00 00 00	 mov	 ecx, 4
  0003d	c1 e1 00	 shl	 ecx, 0
  00040	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00043	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00046	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 578  :     const int crop_right  = crop[2];

  00049	b9 04 00 00 00	 mov	 ecx, 4
  0004e	d1 e1		 shl	 ecx, 1
  00050	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00053	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00056	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 579  :     const int crop_bottom = crop[3];

  00059	b9 04 00 00 00	 mov	 ecx, 4
  0005e	6b d1 03	 imul	 edx, ecx, 3
  00061	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00064	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00067	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 580  :     const int src_y_pitch = src_y_pitch_byte / sizeof(Tin);

  0006a	8b 55 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebp]
  0006d	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 581  :     const int dst_y_pitch = dst_y_pitch_byte / sizeof(Tout);

  00070	8b 45 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  00073	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 582  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00076	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  00079	51		 push	 ecx
  0007a	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0007d	52		 push	 edx
  0007e	8b 45 20	 mov	 eax, DWORD PTR _height$[ebp]
  00081	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  00084	50		 push	 eax
  00085	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  00088	51		 push	 ecx
  00089	8d 95 f0 fe ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  0008f	52		 push	 edx
  00090	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00095	83 c4 14	 add	 esp, 20			; 00000014H
  00098	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009a	89 4d c4	 mov	 DWORD PTR $T55[ebp], ecx
  0009d	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a0	89 55 c8	 mov	 DWORD PTR $T55[ebp+4], edx
  000a3	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000a6	89 45 cc	 mov	 DWORD PTR $T55[ebp+8], eax
  000a9	8b 4d c4	 mov	 ecx, DWORD PTR $T55[ebp]
  000ac	89 4d d4	 mov	 DWORD PTR _y_range$[ebp], ecx
  000af	8b 55 c8	 mov	 edx, DWORD PTR $T55[ebp+4]
  000b2	89 55 d8	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000b5	8b 45 cc	 mov	 eax, DWORD PTR $T55[ebp+8]
  000b8	89 45 dc	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 583  :     //Y
; 584  :     if (!uv_only) {

  000bb	b9 01 00 00 00	 mov	 ecx, 1
  000c0	85 c9		 test	 ecx, ecx
  000c2	0f 84 5e 01 00
	00		 je	 $LN23@convert_yv

; 585  :         Tin *srcYLine = (Tin *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000c8	ba 04 00 00 00	 mov	 edx, 4
  000cd	6b c2 00	 imul	 eax, edx, 0
  000d0	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  000d3	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  000d7	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  000da	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  000dd	03 c1		 add	 eax, ecx
  000df	03 45 f8	 add	 eax, DWORD PTR _crop_left$[ebp]
  000e2	89 45 c0	 mov	 DWORD PTR _srcYLine$54[ebp], eax

; 586  :         Tout *dstLine = (Tout *)dst[0] + dst_y_pitch * y_range.start_dst;

  000e5	b9 04 00 00 00	 mov	 ecx, 4
  000ea	6b d1 00	 imul	 edx, ecx, 0
  000ed	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  000f0	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  000f4	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  000f7	03 04 11	 add	 eax, DWORD PTR [ecx+edx]
  000fa	89 45 bc	 mov	 DWORD PTR _dstLine$53[ebp], eax

; 587  :         const int y_fin = height - crop_bottom;

  000fd	8b 55 20	 mov	 edx, DWORD PTR _height$[ebp]
  00100	2b 55 ec	 sub	 edx, DWORD PTR _crop_bottom$[ebp]
  00103	89 55 b8	 mov	 DWORD PTR _y_fin$52[ebp], edx

; 588  :         const int y_width = width - crop_right - crop_left;

  00106	8b 45 10	 mov	 eax, DWORD PTR _width$[ebp]
  00109	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  0010c	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  0010f	89 45 b4	 mov	 DWORD PTR _y_width$51[ebp], eax

; 589  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  00112	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _y$50[ebp], 0
  00119	eb 1b		 jmp	 SHORT $LN4@convert_yv
$LN2@convert_yv:
  0011b	8b 4d b0	 mov	 ecx, DWORD PTR _y$50[ebp]
  0011e	83 c1 01	 add	 ecx, 1
  00121	89 4d b0	 mov	 DWORD PTR _y$50[ebp], ecx
  00124	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$54[ebp]
  00127	03 55 e8	 add	 edx, DWORD PTR _src_y_pitch$[ebp]
  0012a	89 55 c0	 mov	 DWORD PTR _srcYLine$54[ebp], edx
  0012d	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$53[ebp]
  00130	03 45 e4	 add	 eax, DWORD PTR _dst_y_pitch$[ebp]
  00133	89 45 bc	 mov	 DWORD PTR _dstLine$53[ebp], eax
$LN4@convert_yv:
  00136	8b 4d b0	 mov	 ecx, DWORD PTR _y$50[ebp]
  00139	3b 4d dc	 cmp	 ecx, DWORD PTR _y_range$[ebp+8]
  0013c	0f 8d e4 00 00
	00		 jge	 $LN23@convert_yv

; 590  :             if (in_bit_depth == out_bit_depth && sizeof(Tin) == sizeof(Tout)) {

  00142	ba 01 00 00 00	 mov	 edx, 1
  00147	85 d2		 test	 edx, edx
  00149	74 19		 je	 SHORT $LN24@convert_yv

; 591  :                 memcpy(dstLine, srcYLine, y_width * sizeof(Tin));

  0014b	8b 45 b4	 mov	 eax, DWORD PTR _y_width$51[ebp]
  0014e	50		 push	 eax
  0014f	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$54[ebp]
  00152	51		 push	 ecx
  00153	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$53[ebp]
  00156	52		 push	 edx
  00157	e8 00 00 00 00	 call	 _memcpy
  0015c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 592  :             } else {

  0015f	e9 bd 00 00 00	 jmp	 $LN25@convert_yv
$LN24@convert_yv:

; 593  :                 for (int x = 0; x < y_width; x++) {

  00164	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR _x$49[ebp], 0
  0016b	eb 09		 jmp	 SHORT $LN7@convert_yv
$LN5@convert_yv:
  0016d	8b 45 ac	 mov	 eax, DWORD PTR _x$49[ebp]
  00170	83 c0 01	 add	 eax, 1
  00173	89 45 ac	 mov	 DWORD PTR _x$49[ebp], eax
$LN7@convert_yv:
  00176	8b 4d ac	 mov	 ecx, DWORD PTR _x$49[ebp]
  00179	3b 4d b4	 cmp	 ecx, DWORD PTR _y_width$51[ebp]
  0017c	0f 8d 9f 00 00
	00		 jge	 $LN25@convert_yv

; 594  :                     if (out_bit_depth > in_bit_depth) {

  00182	33 d2		 xor	 edx, edx
  00184	74 41		 je	 SHORT $LN26@convert_yv

; 595  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) << std::max(out_bit_depth - in_bit_depth, 0));

  00186	c7 85 ec fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], 0
  00190	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T3[ebp], 0
  0019a	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$54[ebp]
  0019d	03 45 ac	 add	 eax, DWORD PTR _x$49[ebp]
  001a0	0f b6 18	 movzx	 ebx, BYTE PTR [eax]
  001a3	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  001a9	51		 push	 ecx
  001aa	8d 95 e8 fe ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  001b0	52		 push	 edx
  001b1	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  001b6	83 c4 08	 add	 esp, 8
  001b9	8b 08		 mov	 ecx, DWORD PTR [eax]
  001bb	d3 e3		 shl	 ebx, cl
  001bd	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$53[ebp]
  001c0	03 45 ac	 add	 eax, DWORD PTR _x$49[ebp]
  001c3	88 18		 mov	 BYTE PTR [eax], bl
  001c5	eb 55		 jmp	 SHORT $LN27@convert_yv
$LN26@convert_yv:

; 596  :                     } else if (out_bit_depth < in_bit_depth) {

  001c7	33 c9		 xor	 ecx, ecx
  001c9	74 41		 je	 SHORT $LN28@convert_yv

; 597  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) >> std::max(in_bit_depth - out_bit_depth, 0));

  001cb	c7 85 e4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], 0
  001d5	c7 85 e0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T1[ebp], 0
  001df	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$54[ebp]
  001e2	03 55 ac	 add	 edx, DWORD PTR _x$49[ebp]
  001e5	0f b6 1a	 movzx	 ebx, BYTE PTR [edx]
  001e8	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  001ee	50		 push	 eax
  001ef	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  001f5	51		 push	 ecx
  001f6	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  001fb	83 c4 08	 add	 esp, 8
  001fe	8b 08		 mov	 ecx, DWORD PTR [eax]
  00200	d3 fb		 sar	 ebx, cl
  00202	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$53[ebp]
  00205	03 55 ac	 add	 edx, DWORD PTR _x$49[ebp]
  00208	88 1a		 mov	 BYTE PTR [edx], bl

; 598  :                     } else {

  0020a	eb 10		 jmp	 SHORT $LN27@convert_yv
$LN28@convert_yv:

; 599  :                         dstLine[x] = (Tout)srcYLine[x];

  0020c	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$53[ebp]
  0020f	03 45 ac	 add	 eax, DWORD PTR _x$49[ebp]
  00212	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$54[ebp]
  00215	03 4d ac	 add	 ecx, DWORD PTR _x$49[ebp]
  00218	8a 11		 mov	 dl, BYTE PTR [ecx]
  0021a	88 10		 mov	 BYTE PTR [eax], dl
$LN27@convert_yv:

; 600  :                     }
; 601  :                 }

  0021c	e9 4c ff ff ff	 jmp	 $LN5@convert_yv
$LN25@convert_yv:

; 602  :             }
; 603  :         }

  00221	e9 f5 fe ff ff	 jmp	 $LN2@convert_yv
$LN23@convert_yv:

; 604  :     }
; 605  :     //UV
; 606  :     const int src_uv_pitch = src_uv_pitch_byte / sizeof(Tin);

  00226	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  00229	89 45 a8	 mov	 DWORD PTR _src_uv_pitch$[ebp], eax

; 607  :     for (int ic = 1; ic < 3; ic++) {

  0022c	c7 45 a4 01 00
	00 00		 mov	 DWORD PTR _ic$48[ebp], 1
  00233	eb 09		 jmp	 SHORT $LN10@convert_yv
$LN8@convert_yv:
  00235	8b 4d a4	 mov	 ecx, DWORD PTR _ic$48[ebp]
  00238	83 c1 01	 add	 ecx, 1
  0023b	89 4d a4	 mov	 DWORD PTR _ic$48[ebp], ecx
$LN10@convert_yv:
  0023e	83 7d a4 03	 cmp	 DWORD PTR _ic$48[ebp], 3
  00242	0f 8d e2 06 00
	00		 jge	 $LN1@convert_yv

; 608  :         Tin *srcCLine = (Tin *)src[ic] + (((src_uv_pitch * y_range.start_src) + crop_left) >> 1);

  00248	8b 55 a8	 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  0024b	0f af 55 d4	 imul	 edx, DWORD PTR _y_range$[ebp]
  0024f	03 55 f8	 add	 edx, DWORD PTR _crop_left$[ebp]
  00252	d1 fa		 sar	 edx, 1
  00254	8b 45 a4	 mov	 eax, DWORD PTR _ic$48[ebp]
  00257	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  0025a	03 14 81	 add	 edx, DWORD PTR [ecx+eax*4]
  0025d	89 55 a0	 mov	 DWORD PTR _srcCLine$47[ebp], edx

; 609  :         Tout *dstLine = (Tout *)dst[ic] + dst_y_pitch * y_range.start_dst;

  00260	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  00263	0f af 55 d8	 imul	 edx, DWORD PTR _y_range$[ebp+4]
  00267	8b 45 a4	 mov	 eax, DWORD PTR _ic$48[ebp]
  0026a	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0026d	03 14 81	 add	 edx, DWORD PTR [ecx+eax*4]
  00270	89 55 9c	 mov	 DWORD PTR _dstLine$46[ebp], edx

; 610  :         for (int y = 0; y < y_range.len; y += 2, srcCLine += src_uv_pitch, dstLine += dst_y_pitch * 2) {

  00273	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _y$45[ebp], 0
  0027a	eb 1e		 jmp	 SHORT $LN13@convert_yv
$LN11@convert_yv:
  0027c	8b 55 98	 mov	 edx, DWORD PTR _y$45[ebp]
  0027f	83 c2 02	 add	 edx, 2
  00282	89 55 98	 mov	 DWORD PTR _y$45[ebp], edx
  00285	8b 45 a0	 mov	 eax, DWORD PTR _srcCLine$47[ebp]
  00288	03 45 a8	 add	 eax, DWORD PTR _src_uv_pitch$[ebp]
  0028b	89 45 a0	 mov	 DWORD PTR _srcCLine$47[ebp], eax
  0028e	8b 4d e4	 mov	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  00291	8b 55 9c	 mov	 edx, DWORD PTR _dstLine$46[ebp]
  00294	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  00297	89 45 9c	 mov	 DWORD PTR _dstLine$46[ebp], eax
$LN13@convert_yv:
  0029a	8b 4d 98	 mov	 ecx, DWORD PTR _y$45[ebp]
  0029d	3b 4d dc	 cmp	 ecx, DWORD PTR _y_range$[ebp+8]
  002a0	0f 8d 7f 06 00
	00		 jge	 $LN12@convert_yv

; 611  :             Tout *dstC = dstLine;

  002a6	8b 55 9c	 mov	 edx, DWORD PTR _dstLine$46[ebp]
  002a9	89 55 94	 mov	 DWORD PTR _dstC$44[ebp], edx

; 612  :             Tin *srcP = srcCLine;

  002ac	8b 45 a0	 mov	 eax, DWORD PTR _srcCLine$47[ebp]
  002af	89 45 90	 mov	 DWORD PTR _srcP$43[ebp], eax

; 613  :             const int x_fin = width - crop_right - crop_left;

  002b2	8b 4d 10	 mov	 ecx, DWORD PTR _width$[ebp]
  002b5	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  002b8	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  002bb	89 4d 8c	 mov	 DWORD PTR _x_fin$42[ebp], ecx

; 614  :             if (y == 0) {

  002be	83 7d 98 00	 cmp	 DWORD PTR _y$45[ebp], 0
  002c2	0f 85 03 02 00
	00		 jne	 $LN30@convert_yv

; 615  :                 for (int x = 0; x < x_fin; x += 2, dstC += 2, srcP++) {

  002c8	c7 45 88 00 00
	00 00		 mov	 DWORD PTR _x$41[ebp], 0
  002cf	eb 1b		 jmp	 SHORT $LN16@convert_yv
$LN14@convert_yv:
  002d1	8b 55 88	 mov	 edx, DWORD PTR _x$41[ebp]
  002d4	83 c2 02	 add	 edx, 2
  002d7	89 55 88	 mov	 DWORD PTR _x$41[ebp], edx
  002da	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  002dd	83 c0 02	 add	 eax, 2
  002e0	89 45 94	 mov	 DWORD PTR _dstC$44[ebp], eax
  002e3	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$43[ebp]
  002e6	83 c1 01	 add	 ecx, 1
  002e9	89 4d 90	 mov	 DWORD PTR _srcP$43[ebp], ecx
$LN16@convert_yv:
  002ec	8b 55 88	 mov	 edx, DWORD PTR _x$41[ebp]
  002ef	3b 55 8c	 cmp	 edx, DWORD PTR _x_fin$42[ebp]
  002f2	0f 8d ce 01 00
	00		 jge	 $LN15@convert_yv

; 616  :                     int cxplus = (x + 2 < x_fin);

  002f8	8b 45 88	 mov	 eax, DWORD PTR _x$41[ebp]
  002fb	83 c0 02	 add	 eax, 2
  002fe	3b 45 8c	 cmp	 eax, DWORD PTR _x_fin$42[ebp]
  00301	7d 0c		 jge	 SHORT $LN44@convert_yv
  00303	c7 85 dc fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv219[ebp], 1
  0030d	eb 0a		 jmp	 SHORT $LN45@convert_yv
$LN44@convert_yv:
  0030f	c7 85 dc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv219[ebp], 0
$LN45@convert_yv:
  00319	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR tv219[ebp]
  0031f	89 4d 84	 mov	 DWORD PTR _cxplus$40[ebp], ecx

; 617  :                     int cy0x0 = srcP[ 0*src_uv_pitch + 0];

  00322	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  00326	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  00329	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  0032d	89 4d 80	 mov	 DWORD PTR _cy0x0$39[ebp], ecx

; 618  :                     int cy2x0 = srcP[ 0*src_uv_pitch + 0];

  00330	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  00334	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  00337	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  0033b	89 8d 7c ff ff
	ff		 mov	 DWORD PTR _cy2x0$38[ebp], ecx

; 619  :                     int cy4x0 = srcP[ 1*src_uv_pitch + 0];

  00341	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  00344	03 55 a8	 add	 edx, DWORD PTR _src_uv_pitch$[ebp]
  00347	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0034a	89 85 78 ff ff
	ff		 mov	 DWORD PTR _cy4x0$37[ebp], eax

; 620  :                     int cy0x1 = srcP[ 0*src_uv_pitch + cxplus];

  00350	6b 4d a8 00	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 0
  00354	03 4d 84	 add	 ecx, DWORD PTR _cxplus$40[ebp]
  00357	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  0035a	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  0035e	89 85 74 ff ff
	ff		 mov	 DWORD PTR _cy0x1$36[ebp], eax

; 621  :                     int cy2x1 = srcP[ 0*src_uv_pitch + cxplus];

  00364	6b 4d a8 00	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 0
  00368	03 4d 84	 add	 ecx, DWORD PTR _cxplus$40[ebp]
  0036b	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  0036e	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  00372	89 85 70 ff ff
	ff		 mov	 DWORD PTR _cy2x1$35[ebp], eax

; 622  :                     int cy4x1 = srcP[ 1*src_uv_pitch + cxplus];

  00378	8b 4d 84	 mov	 ecx, DWORD PTR _cxplus$40[ebp]
  0037b	03 4d a8	 add	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  0037e	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  00381	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  00385	89 85 6c ff ff
	ff		 mov	 DWORD PTR _cy4x1$34[ebp], eax

; 623  : 
; 624  :                     int cy1x0 = (cy0x0 * 1 + cy2x0 * 3 + 2);

  0038b	6b 8d 7c ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy2x0$38[ebp], 3
  00392	8b 55 80	 mov	 edx, DWORD PTR _cy0x0$39[ebp]
  00395	8d 44 0a 02	 lea	 eax, DWORD PTR [edx+ecx+2]
  00399	89 85 68 ff ff
	ff		 mov	 DWORD PTR _cy1x0$33[ebp], eax

; 625  :                     int cy3x0 = (cy2x0 * 3 + cy4x0 * 1 + 2);

  0039f	6b 8d 7c ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy2x0$38[ebp], 3
  003a6	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _cy4x0$37[ebp]
  003ac	8d 44 11 02	 lea	 eax, DWORD PTR [ecx+edx+2]
  003b0	89 85 64 ff ff
	ff		 mov	 DWORD PTR _cy3x0$32[ebp], eax

; 626  :                     int cy1x1 = (cy0x1 * 1 + cy2x1 * 3 + 2);

  003b6	6b 8d 70 ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy2x1$35[ebp], 3
  003bd	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _cy0x1$36[ebp]
  003c3	8d 44 0a 02	 lea	 eax, DWORD PTR [edx+ecx+2]
  003c7	89 85 60 ff ff
	ff		 mov	 DWORD PTR _cy1x1$31[ebp], eax

; 627  :                     int cy3x1 = (cy2x1 * 3 + cy4x1 * 1 + 2);

  003cd	6b 8d 70 ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy2x1$35[ebp], 3
  003d4	8b 95 6c ff ff
	ff		 mov	 edx, DWORD PTR _cy4x1$34[ebp]
  003da	8d 44 11 02	 lea	 eax, DWORD PTR [ecx+edx+2]
  003de	89 85 5c ff ff
	ff		 mov	 DWORD PTR _cy3x1$30[ebp], eax

; 628  :                     CHANGE_BIT_DEPTH_4(cy1x0, cy3x0, cy1x1, cy3x1, 2);

  003e4	33 c9		 xor	 ecx, ecx
  003e6	74 3e		 je	 SHORT $LN32@convert_yv
  003e8	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x0$33[ebp]
  003ee	c1 e2 fe	 shl	 edx, -2			; fffffffeH
  003f1	89 95 68 ff ff
	ff		 mov	 DWORD PTR _cy1x0$33[ebp], edx
  003f7	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$32[ebp]
  003fd	c1 e0 fe	 shl	 eax, -2			; fffffffeH
  00400	89 85 64 ff ff
	ff		 mov	 DWORD PTR _cy3x0$32[ebp], eax
  00406	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x1$31[ebp]
  0040c	c1 e1 fe	 shl	 ecx, -2			; fffffffeH
  0040f	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _cy1x1$31[ebp], ecx
  00415	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR _cy3x1$30[ebp]
  0041b	c1 e2 fe	 shl	 edx, -2			; fffffffeH
  0041e	89 95 5c ff ff
	ff		 mov	 DWORD PTR _cy3x1$30[ebp], edx
  00424	eb 45		 jmp	 SHORT $LN33@convert_yv
$LN32@convert_yv:
  00426	b8 01 00 00 00	 mov	 eax, 1
  0042b	85 c0		 test	 eax, eax
  0042d	74 3c		 je	 SHORT $LN33@convert_yv
  0042f	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x0$33[ebp]
  00435	c1 f9 02	 sar	 ecx, 2
  00438	89 8d 68 ff ff
	ff		 mov	 DWORD PTR _cy1x0$33[ebp], ecx
  0043e	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR _cy3x0$32[ebp]
  00444	c1 fa 02	 sar	 edx, 2
  00447	89 95 64 ff ff
	ff		 mov	 DWORD PTR _cy3x0$32[ebp], edx
  0044d	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x1$31[ebp]
  00453	c1 f8 02	 sar	 eax, 2
  00456	89 85 60 ff ff
	ff		 mov	 DWORD PTR _cy1x1$31[ebp], eax
  0045c	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x1$30[ebp]
  00462	c1 f9 02	 sar	 ecx, 2
  00465	89 8d 5c ff ff
	ff		 mov	 DWORD PTR _cy3x1$30[ebp], ecx
$LN33@convert_yv:

; 629  : 
; 630  :                     dstC[0*dst_y_pitch   + 0] = (Tout)cy1x0;

  0046b	6b 55 e4 00	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 0
  0046f	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  00472	8a 8d 68 ff ff
	ff		 mov	 cl, BYTE PTR _cy1x0$33[ebp]
  00478	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 631  :                     dstC[0*dst_y_pitch   + 1] = (Tout)((cy1x0 + cy1x1 + 1) >> 1);

  0047b	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x1$31[ebp]
  00481	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x0$33[ebp]
  00487	8d 4c 10 01	 lea	 ecx, DWORD PTR [eax+edx+1]
  0048b	d1 f9		 sar	 ecx, 1
  0048d	6b 55 e4 00	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 0
  00491	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  00494	88 4c 10 01	 mov	 BYTE PTR [eax+edx+1], cl

; 632  :                     dstC[1*dst_y_pitch   + 0] = (Tout)cy3x0;

  00498	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$44[ebp]
  0049b	03 4d e4	 add	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  0049e	8a 95 64 ff ff
	ff		 mov	 dl, BYTE PTR _cy3x0$32[ebp]
  004a4	88 11		 mov	 BYTE PTR [ecx], dl

; 633  :                     dstC[1*dst_y_pitch   + 1] = (Tout)((cy3x0 + cy3x1 + 1) >> 1);

  004a6	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _cy3x1$30[ebp]
  004ac	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x0$32[ebp]
  004b2	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  004b6	d1 fa		 sar	 edx, 1
  004b8	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  004bb	03 45 e4	 add	 eax, DWORD PTR _dst_y_pitch$[ebp]
  004be	88 50 01	 mov	 BYTE PTR [eax+1], dl

; 634  :                 }

  004c1	e9 0b fe ff ff	 jmp	 $LN14@convert_yv
$LN15@convert_yv:

; 635  :             } else if (y >= height-2) {

  004c6	e9 55 04 00 00	 jmp	 $LN31@convert_yv
$LN30@convert_yv:
  004cb	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  004ce	83 e9 02	 sub	 ecx, 2
  004d1	39 4d 98	 cmp	 DWORD PTR _y$45[ebp], ecx
  004d4	0f 8c 27 02 00
	00		 jl	 $LN35@convert_yv

; 636  :                 for (int x = 0; x < x_fin; x += 2, dstC += 2, srcP++) {

  004da	c7 85 58 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _x$29[ebp], 0
  004e4	eb 21		 jmp	 SHORT $LN19@convert_yv
$LN17@convert_yv:
  004e6	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _x$29[ebp]
  004ec	83 c2 02	 add	 edx, 2
  004ef	89 95 58 ff ff
	ff		 mov	 DWORD PTR _x$29[ebp], edx
  004f5	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  004f8	83 c0 02	 add	 eax, 2
  004fb	89 45 94	 mov	 DWORD PTR _dstC$44[ebp], eax
  004fe	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$43[ebp]
  00501	83 c1 01	 add	 ecx, 1
  00504	89 4d 90	 mov	 DWORD PTR _srcP$43[ebp], ecx
$LN19@convert_yv:
  00507	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _x$29[ebp]
  0050d	3b 55 8c	 cmp	 edx, DWORD PTR _x_fin$42[ebp]
  00510	0f 8d e6 01 00
	00		 jge	 $LN18@convert_yv

; 637  :                     int cxplus = (x + 2 < x_fin);

  00516	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _x$29[ebp]
  0051c	83 c0 02	 add	 eax, 2
  0051f	3b 45 8c	 cmp	 eax, DWORD PTR _x_fin$42[ebp]
  00522	7d 0c		 jge	 SHORT $LN46@convert_yv
  00524	c7 85 d8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv304[ebp], 1
  0052e	eb 0a		 jmp	 SHORT $LN47@convert_yv
$LN46@convert_yv:
  00530	c7 85 d8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv304[ebp], 0
$LN47@convert_yv:
  0053a	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR tv304[ebp]
  00540	89 8d 54 ff ff
	ff		 mov	 DWORD PTR _cxplus$28[ebp], ecx

; 638  :                     int cy0x0 = srcP[-1*src_uv_pitch + 0];

  00546	6b 55 a8 ff	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], -1
  0054a	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  0054d	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  00551	89 8d 50 ff ff
	ff		 mov	 DWORD PTR _cy0x0$27[ebp], ecx

; 639  :                     int cy2x0 = srcP[ 0*src_uv_pitch + 0];

  00557	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  0055b	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  0055e	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  00562	89 8d 4c ff ff
	ff		 mov	 DWORD PTR _cy2x0$26[ebp], ecx

; 640  :                     int cy4x0 = srcP[ 0*src_uv_pitch + 0];

  00568	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  0056c	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  0056f	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  00573	89 8d 48 ff ff
	ff		 mov	 DWORD PTR _cy4x0$25[ebp], ecx

; 641  :                     int cy0x1 = srcP[-1*src_uv_pitch + cxplus];

  00579	6b 55 a8 ff	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], -1
  0057d	03 95 54 ff ff
	ff		 add	 edx, DWORD PTR _cxplus$28[ebp]
  00583	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  00586	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  0058a	89 8d 44 ff ff
	ff		 mov	 DWORD PTR _cy0x1$24[ebp], ecx

; 642  :                     int cy2x1 = srcP[ 0*src_uv_pitch + cxplus];

  00590	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  00594	03 95 54 ff ff
	ff		 add	 edx, DWORD PTR _cxplus$28[ebp]
  0059a	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  0059d	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  005a1	89 8d 40 ff ff
	ff		 mov	 DWORD PTR _cy2x1$23[ebp], ecx

; 643  :                     int cy4x1 = srcP[ 0*src_uv_pitch + cxplus];

  005a7	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  005ab	03 95 54 ff ff
	ff		 add	 edx, DWORD PTR _cxplus$28[ebp]
  005b1	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  005b4	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  005b8	89 8d 3c ff ff
	ff		 mov	 DWORD PTR _cy4x1$22[ebp], ecx

; 644  : 
; 645  :                     int cy1x0 = (cy0x0 * 1 + cy2x0 * 3 + 2);

  005be	6b 95 4c ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x0$26[ebp], 3
  005c5	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _cy0x0$27[ebp]
  005cb	8d 4c 10 02	 lea	 ecx, DWORD PTR [eax+edx+2]
  005cf	89 8d 38 ff ff
	ff		 mov	 DWORD PTR _cy1x0$21[ebp], ecx

; 646  :                     int cy3x0 = (cy2x0 * 3 + cy4x0 * 1 + 2);

  005d5	6b 95 4c ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x0$26[ebp], 3
  005dc	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _cy4x0$25[ebp]
  005e2	8d 4c 02 02	 lea	 ecx, DWORD PTR [edx+eax+2]
  005e6	89 8d 34 ff ff
	ff		 mov	 DWORD PTR _cy3x0$20[ebp], ecx

; 647  :                     int cy1x1 = (cy0x1 * 1 + cy2x1 * 3 + 2);

  005ec	6b 95 40 ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x1$23[ebp], 3
  005f3	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _cy0x1$24[ebp]
  005f9	8d 4c 10 02	 lea	 ecx, DWORD PTR [eax+edx+2]
  005fd	89 8d 30 ff ff
	ff		 mov	 DWORD PTR _cy1x1$19[ebp], ecx

; 648  :                     int cy3x1 = (cy2x1 * 3 + cy4x1 * 1 + 2);

  00603	6b 95 40 ff ff
	ff 03		 imul	 edx, DWORD PTR _cy2x1$23[ebp], 3
  0060a	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _cy4x1$22[ebp]
  00610	8d 4c 02 02	 lea	 ecx, DWORD PTR [edx+eax+2]
  00614	89 8d 2c ff ff
	ff		 mov	 DWORD PTR _cy3x1$18[ebp], ecx

; 649  :                     CHANGE_BIT_DEPTH_4(cy1x0, cy3x0, cy1x1, cy3x1, 2);

  0061a	33 d2		 xor	 edx, edx
  0061c	74 3e		 je	 SHORT $LN37@convert_yv
  0061e	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x0$21[ebp]
  00624	c1 e0 fe	 shl	 eax, -2			; fffffffeH
  00627	89 85 38 ff ff
	ff		 mov	 DWORD PTR _cy1x0$21[ebp], eax
  0062d	8b 8d 34 ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x0$20[ebp]
  00633	c1 e1 fe	 shl	 ecx, -2			; fffffffeH
  00636	89 8d 34 ff ff
	ff		 mov	 DWORD PTR _cy3x0$20[ebp], ecx
  0063c	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x1$19[ebp]
  00642	c1 e2 fe	 shl	 edx, -2			; fffffffeH
  00645	89 95 30 ff ff
	ff		 mov	 DWORD PTR _cy1x1$19[ebp], edx
  0064b	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR _cy3x1$18[ebp]
  00651	c1 e0 fe	 shl	 eax, -2			; fffffffeH
  00654	89 85 2c ff ff
	ff		 mov	 DWORD PTR _cy3x1$18[ebp], eax
  0065a	eb 45		 jmp	 SHORT $LN38@convert_yv
$LN37@convert_yv:
  0065c	b9 01 00 00 00	 mov	 ecx, 1
  00661	85 c9		 test	 ecx, ecx
  00663	74 3c		 je	 SHORT $LN38@convert_yv
  00665	8b 95 38 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x0$21[ebp]
  0066b	c1 fa 02	 sar	 edx, 2
  0066e	89 95 38 ff ff
	ff		 mov	 DWORD PTR _cy1x0$21[ebp], edx
  00674	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$20[ebp]
  0067a	c1 f8 02	 sar	 eax, 2
  0067d	89 85 34 ff ff
	ff		 mov	 DWORD PTR _cy3x0$20[ebp], eax
  00683	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x1$19[ebp]
  00689	c1 f9 02	 sar	 ecx, 2
  0068c	89 8d 30 ff ff
	ff		 mov	 DWORD PTR _cy1x1$19[ebp], ecx
  00692	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR _cy3x1$18[ebp]
  00698	c1 fa 02	 sar	 edx, 2
  0069b	89 95 2c ff ff
	ff		 mov	 DWORD PTR _cy3x1$18[ebp], edx
$LN38@convert_yv:

; 650  : 
; 651  :                     dstC[0*dst_y_pitch   + 0] = (Tout)cy1x0;

  006a1	6b 45 e4 00	 imul	 eax, DWORD PTR _dst_y_pitch$[ebp], 0
  006a5	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$44[ebp]
  006a8	8a 95 38 ff ff
	ff		 mov	 dl, BYTE PTR _cy1x0$21[ebp]
  006ae	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 652  :                     dstC[0*dst_y_pitch   + 1] = (Tout)((cy1x0 + cy1x1 + 1) >> 1);

  006b1	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x1$19[ebp]
  006b7	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x0$21[ebp]
  006bd	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  006c1	d1 fa		 sar	 edx, 1
  006c3	6b 45 e4 00	 imul	 eax, DWORD PTR _dst_y_pitch$[ebp], 0
  006c7	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$44[ebp]
  006ca	88 54 01 01	 mov	 BYTE PTR [ecx+eax+1], dl

; 653  :                     dstC[1*dst_y_pitch   + 0] = (Tout)cy3x0;

  006ce	8b 55 94	 mov	 edx, DWORD PTR _dstC$44[ebp]
  006d1	03 55 e4	 add	 edx, DWORD PTR _dst_y_pitch$[ebp]
  006d4	8a 85 34 ff ff
	ff		 mov	 al, BYTE PTR _cy3x0$20[ebp]
  006da	88 02		 mov	 BYTE PTR [edx], al

; 654  :                     dstC[1*dst_y_pitch   + 1] = (Tout)((cy3x0 + cy3x1 + 1) >> 1);

  006dc	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x1$18[ebp]
  006e2	8b 95 34 ff ff
	ff		 mov	 edx, DWORD PTR _cy3x0$20[ebp]
  006e8	8d 44 0a 01	 lea	 eax, DWORD PTR [edx+ecx+1]
  006ec	d1 f8		 sar	 eax, 1
  006ee	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$44[ebp]
  006f1	03 4d e4	 add	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  006f4	88 41 01	 mov	 BYTE PTR [ecx+1], al

; 655  :                 }

  006f7	e9 ea fd ff ff	 jmp	 $LN17@convert_yv
$LN18@convert_yv:

; 656  :             } else {

  006fc	e9 1f 02 00 00	 jmp	 $LN31@convert_yv
$LN35@convert_yv:

; 657  :                 for (int x = 0; x < x_fin; x += 2, dstC += 2, srcP++) {

  00701	c7 85 28 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _x$17[ebp], 0
  0070b	eb 21		 jmp	 SHORT $LN22@convert_yv
$LN20@convert_yv:
  0070d	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR _x$17[ebp]
  00713	83 c2 02	 add	 edx, 2
  00716	89 95 28 ff ff
	ff		 mov	 DWORD PTR _x$17[ebp], edx
  0071c	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  0071f	83 c0 02	 add	 eax, 2
  00722	89 45 94	 mov	 DWORD PTR _dstC$44[ebp], eax
  00725	8b 4d 90	 mov	 ecx, DWORD PTR _srcP$43[ebp]
  00728	83 c1 01	 add	 ecx, 1
  0072b	89 4d 90	 mov	 DWORD PTR _srcP$43[ebp], ecx
$LN22@convert_yv:
  0072e	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR _x$17[ebp]
  00734	3b 55 8c	 cmp	 edx, DWORD PTR _x_fin$42[ebp]
  00737	0f 8d e3 01 00
	00		 jge	 $LN31@convert_yv

; 658  :                     int cxplus = (x + 2 < x_fin);

  0073d	8b 85 28 ff ff
	ff		 mov	 eax, DWORD PTR _x$17[ebp]
  00743	83 c0 02	 add	 eax, 2
  00746	3b 45 8c	 cmp	 eax, DWORD PTR _x_fin$42[ebp]
  00749	7d 0c		 jge	 SHORT $LN48@convert_yv
  0074b	c7 85 d4 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv419[ebp], 1
  00755	eb 0a		 jmp	 SHORT $LN49@convert_yv
$LN48@convert_yv:
  00757	c7 85 d4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv419[ebp], 0
$LN49@convert_yv:
  00761	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR tv419[ebp]
  00767	89 8d 24 ff ff
	ff		 mov	 DWORD PTR _cxplus$16[ebp], ecx

; 659  :                     int cy0x0 = srcP[-1*src_uv_pitch + 0];

  0076d	6b 55 a8 ff	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], -1
  00771	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  00774	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  00778	89 8d 20 ff ff
	ff		 mov	 DWORD PTR _cy0x0$15[ebp], ecx

; 660  :                     int cy2x0 = srcP[ 0*src_uv_pitch + 0];

  0077e	6b 55 a8 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  00782	8b 45 90	 mov	 eax, DWORD PTR _srcP$43[ebp]
  00785	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  00789	89 8d 1c ff ff
	ff		 mov	 DWORD PTR _cy2x0$14[ebp], ecx

; 661  :                     int cy4x0 = srcP[ 1*src_uv_pitch + 0];

  0078f	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  00792	03 55 a8	 add	 edx, DWORD PTR _src_uv_pitch$[ebp]
  00795	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00798	89 85 18 ff ff
	ff		 mov	 DWORD PTR _cy4x0$13[ebp], eax

; 662  :                     int cy0x1 = srcP[-1*src_uv_pitch + cxplus];

  0079e	6b 4d a8 ff	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], -1
  007a2	03 8d 24 ff ff
	ff		 add	 ecx, DWORD PTR _cxplus$16[ebp]
  007a8	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  007ab	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  007af	89 85 14 ff ff
	ff		 mov	 DWORD PTR _cy0x1$12[ebp], eax

; 663  :                     int cy2x1 = srcP[ 0*src_uv_pitch + cxplus];

  007b5	6b 4d a8 00	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 0
  007b9	03 8d 24 ff ff
	ff		 add	 ecx, DWORD PTR _cxplus$16[ebp]
  007bf	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  007c2	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  007c6	89 85 10 ff ff
	ff		 mov	 DWORD PTR _cy2x1$11[ebp], eax

; 664  :                     int cy4x1 = srcP[ 1*src_uv_pitch + cxplus];

  007cc	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR _cxplus$16[ebp]
  007d2	03 4d a8	 add	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  007d5	8b 55 90	 mov	 edx, DWORD PTR _srcP$43[ebp]
  007d8	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  007dc	89 85 0c ff ff
	ff		 mov	 DWORD PTR _cy4x1$10[ebp], eax

; 665  : 
; 666  :                     int cy1x0 = (cy0x0 * 1 + cy2x0 * 3 + 2);

  007e2	6b 8d 1c ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy2x0$14[ebp], 3
  007e9	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR _cy0x0$15[ebp]
  007ef	8d 44 0a 02	 lea	 eax, DWORD PTR [edx+ecx+2]
  007f3	89 85 08 ff ff
	ff		 mov	 DWORD PTR _cy1x0$9[ebp], eax

; 667  :                     int cy3x0 = (cy2x0 * 3 + cy4x0 * 1 + 2);

  007f9	6b 8d 1c ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy2x0$14[ebp], 3
  00800	8b 95 18 ff ff
	ff		 mov	 edx, DWORD PTR _cy4x0$13[ebp]
  00806	8d 44 11 02	 lea	 eax, DWORD PTR [ecx+edx+2]
  0080a	89 85 04 ff ff
	ff		 mov	 DWORD PTR _cy3x0$8[ebp], eax

; 668  :                     int cy1x1 = (cy0x1 * 1 + cy2x1 * 3 + 2);

  00810	6b 8d 10 ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy2x1$11[ebp], 3
  00817	8b 95 14 ff ff
	ff		 mov	 edx, DWORD PTR _cy0x1$12[ebp]
  0081d	8d 44 0a 02	 lea	 eax, DWORD PTR [edx+ecx+2]
  00821	89 85 00 ff ff
	ff		 mov	 DWORD PTR _cy1x1$7[ebp], eax

; 669  :                     int cy3x1 = (cy2x1 * 3 + cy4x1 * 1 + 2);

  00827	6b 8d 10 ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy2x1$11[ebp], 3
  0082e	8b 95 0c ff ff
	ff		 mov	 edx, DWORD PTR _cy4x1$10[ebp]
  00834	8d 44 11 02	 lea	 eax, DWORD PTR [ecx+edx+2]
  00838	89 85 fc fe ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], eax

; 670  :                     CHANGE_BIT_DEPTH_4(cy1x0, cy3x0, cy1x1, cy3x1, 2);

  0083e	33 c9		 xor	 ecx, ecx
  00840	74 3e		 je	 SHORT $LN40@convert_yv
  00842	8b 95 08 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x0$9[ebp]
  00848	c1 e2 fe	 shl	 edx, -2			; fffffffeH
  0084b	89 95 08 ff ff
	ff		 mov	 DWORD PTR _cy1x0$9[ebp], edx
  00851	8b 85 04 ff ff
	ff		 mov	 eax, DWORD PTR _cy3x0$8[ebp]
  00857	c1 e0 fe	 shl	 eax, -2			; fffffffeH
  0085a	89 85 04 ff ff
	ff		 mov	 DWORD PTR _cy3x0$8[ebp], eax
  00860	8b 8d 00 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x1$7[ebp]
  00866	c1 e1 fe	 shl	 ecx, -2			; fffffffeH
  00869	89 8d 00 ff ff
	ff		 mov	 DWORD PTR _cy1x1$7[ebp], ecx
  0086f	8b 95 fc fe ff
	ff		 mov	 edx, DWORD PTR _cy3x1$6[ebp]
  00875	c1 e2 fe	 shl	 edx, -2			; fffffffeH
  00878	89 95 fc fe ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], edx
  0087e	eb 45		 jmp	 SHORT $LN41@convert_yv
$LN40@convert_yv:
  00880	b8 01 00 00 00	 mov	 eax, 1
  00885	85 c0		 test	 eax, eax
  00887	74 3c		 je	 SHORT $LN41@convert_yv
  00889	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1x0$9[ebp]
  0088f	c1 f9 02	 sar	 ecx, 2
  00892	89 8d 08 ff ff
	ff		 mov	 DWORD PTR _cy1x0$9[ebp], ecx
  00898	8b 95 04 ff ff
	ff		 mov	 edx, DWORD PTR _cy3x0$8[ebp]
  0089e	c1 fa 02	 sar	 edx, 2
  008a1	89 95 04 ff ff
	ff		 mov	 DWORD PTR _cy3x0$8[ebp], edx
  008a7	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x1$7[ebp]
  008ad	c1 f8 02	 sar	 eax, 2
  008b0	89 85 00 ff ff
	ff		 mov	 DWORD PTR _cy1x1$7[ebp], eax
  008b6	8b 8d fc fe ff
	ff		 mov	 ecx, DWORD PTR _cy3x1$6[ebp]
  008bc	c1 f9 02	 sar	 ecx, 2
  008bf	89 8d fc fe ff
	ff		 mov	 DWORD PTR _cy3x1$6[ebp], ecx
$LN41@convert_yv:

; 671  : 
; 672  :                     dstC[0*dst_y_pitch   + 0] = (Tout)cy1x0;

  008c5	6b 55 e4 00	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 0
  008c9	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  008cc	8a 8d 08 ff ff
	ff		 mov	 cl, BYTE PTR _cy1x0$9[ebp]
  008d2	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 673  :                     dstC[0*dst_y_pitch   + 1] = (Tout)((cy1x0 + cy1x1 + 1) >> 1);

  008d5	8b 95 00 ff ff
	ff		 mov	 edx, DWORD PTR _cy1x1$7[ebp]
  008db	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR _cy1x0$9[ebp]
  008e1	8d 4c 10 01	 lea	 ecx, DWORD PTR [eax+edx+1]
  008e5	d1 f9		 sar	 ecx, 1
  008e7	6b 55 e4 00	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 0
  008eb	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  008ee	88 4c 10 01	 mov	 BYTE PTR [eax+edx+1], cl

; 674  :                     dstC[1*dst_y_pitch   + 0] = (Tout)cy3x0;

  008f2	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$44[ebp]
  008f5	03 4d e4	 add	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  008f8	8a 95 04 ff ff
	ff		 mov	 dl, BYTE PTR _cy3x0$8[ebp]
  008fe	88 11		 mov	 BYTE PTR [ecx], dl

; 675  :                     dstC[1*dst_y_pitch   + 1] = (Tout)((cy3x0 + cy3x1 + 1) >> 1);

  00900	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR _cy3x1$6[ebp]
  00906	8b 8d 04 ff ff
	ff		 mov	 ecx, DWORD PTR _cy3x0$8[ebp]
  0090c	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  00910	d1 fa		 sar	 edx, 1
  00912	8b 45 94	 mov	 eax, DWORD PTR _dstC$44[ebp]
  00915	03 45 e4	 add	 eax, DWORD PTR _dst_y_pitch$[ebp]
  00918	88 50 01	 mov	 BYTE PTR [eax+1], dl

; 676  :                 }

  0091b	e9 ed fd ff ff	 jmp	 $LN20@convert_yv
$LN31@convert_yv:

; 677  :             }
; 678  :         }

  00920	e9 57 f9 ff ff	 jmp	 $LN11@convert_yv
$LN12@convert_yv:

; 679  :     }

  00925	e9 0b f9 ff ff	 jmp	 $LN8@convert_yv
$LN1@convert_yv:

; 680  : }

  0092a	52		 push	 edx
  0092b	8b cd		 mov	 ecx, ebp
  0092d	50		 push	 eax
  0092e	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN52@convert_yv
  00934	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00939	58		 pop	 eax
  0093a	5a		 pop	 edx
  0093b	5f		 pop	 edi
  0093c	5b		 pop	 ebx
  0093d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00940	33 cd		 xor	 ecx, ebp
  00942	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00947	81 c4 2c 01 00
	00		 add	 esp, 300		; 0000012cH
  0094d	3b ec		 cmp	 ebp, esp
  0094f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00954	8b e5		 mov	 esp, ebp
  00956	5d		 pop	 ebp
  00957	c3		 ret	 0
$LN52@convert_yv:
  00958	01 00 00 00	 DD	 1
  0095c	00 00 00 00	 DD	 $LN51@convert_yv
$LN51@convert_yv:
  00960	d4 ff ff ff	 DD	 -44			; ffffffd4H
  00964	0c 00 00 00	 DD	 12			; 0000000cH
  00968	00 00 00 00	 DD	 $LN50@convert_yv
$LN50@convert_yv:
  0096c	79		 DB	 121			; 00000079H
  0096d	5f		 DB	 95			; 0000005fH
  0096e	72		 DB	 114			; 00000072H
  0096f	61		 DB	 97			; 00000061H
  00970	6e		 DB	 110			; 0000006eH
  00971	67		 DB	 103			; 00000067H
  00972	65		 DB	 101			; 00000065H
  00973	00		 DB	 0
??$convert_yv12_p_to_yuv444_c@E$07E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_p_to_yuv444_c<unsigned char,8,unsigned char,8,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yv12_p_to_yuv444@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_p_to_yuv444

; 777  : static void convert_yv12_p_to_yuv444(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 778  :     convert_yv12_p_to_yuv444_c<uint8_t, 8, uint8_t, 8, false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yv12_p_to_yuv444_c@E$07E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_p_to_yuv444_c<unsigned char,8,unsigned char,8,0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 779  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yv12_p_to_yuv444@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_p_to_yuv444
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
tv148 = -136						; size = 4
$T1 = -132						; size = 12
_vx2$2 = -120						; size = 4
_ux2$3 = -116						; size = 4
_vx0$4 = -112						; size = 4
_ux0$5 = -108						; size = 4
_cxplus$6 = -104					; size = 4
_x$7 = -100						; size = 4
_x_fin$8 = -96						; size = 4
_dstV$9 = -92						; size = 4
_dstU$10 = -88						; size = 4
_dstY$11 = -84						; size = 4
_srcP$12 = -80						; size = 4
_y$13 = -76						; size = 4
_y_width$ = -72						; size = 4
_dstVLine$ = -68					; size = 4
_dstULine$ = -64					; size = 4
_dstYLine$ = -60					; size = 4
_srcLine$ = -56						; size = 4
$T14 = -52						; size = 12
_y_range$ = -36						; size = 12
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuy2_to_yuv444@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuy2_to_yuv444

; 538  : static void convert_yuy2_to_yuv444(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 88 00 00
	00		 sub	 esp, 136		; 00000088H
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8d bd 78 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-136]
  00011	b9 22 00 00 00	 mov	 ecx, 34			; 00000022H
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 539  :     const int crop_left   = crop[0];

  00027	b8 04 00 00 00	 mov	 eax, 4
  0002c	6b c8 00	 imul	 ecx, eax, 0
  0002f	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00032	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00035	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 540  :     const int crop_up     = crop[1];

  00038	b9 04 00 00 00	 mov	 ecx, 4
  0003d	c1 e1 00	 shl	 ecx, 0
  00040	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00043	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00046	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 541  :     const int crop_right  = crop[2];

  00049	b9 04 00 00 00	 mov	 ecx, 4
  0004e	d1 e1		 shl	 ecx, 1
  00050	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00053	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00056	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 542  :     const int crop_bottom = crop[3];

  00059	b9 04 00 00 00	 mov	 ecx, 4
  0005e	6b d1 03	 imul	 edx, ecx, 3
  00061	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00064	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00067	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 543  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  0006a	8b 55 2c	 mov	 edx, DWORD PTR _thread_n$[ebp]
  0006d	52		 push	 edx
  0006e	8b 45 28	 mov	 eax, DWORD PTR _thread_id$[ebp]
  00071	50		 push	 eax
  00072	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00075	2b 4d ec	 sub	 ecx, DWORD PTR _crop_bottom$[ebp]
  00078	51		 push	 ecx
  00079	8b 55 f4	 mov	 edx, DWORD PTR _crop_up$[ebp]
  0007c	52		 push	 edx
  0007d	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  00083	50		 push	 eax
  00084	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00089	83 c4 14	 add	 esp, 20			; 00000014H
  0008c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0008e	89 4d cc	 mov	 DWORD PTR $T14[ebp], ecx
  00091	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00094	89 55 d0	 mov	 DWORD PTR $T14[ebp+4], edx
  00097	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0009a	89 45 d4	 mov	 DWORD PTR $T14[ebp+8], eax
  0009d	8b 4d cc	 mov	 ecx, DWORD PTR $T14[ebp]
  000a0	89 4d dc	 mov	 DWORD PTR _y_range$[ebp], ecx
  000a3	8b 55 d0	 mov	 edx, DWORD PTR $T14[ebp+4]
  000a6	89 55 e0	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000a9	8b 45 d4	 mov	 eax, DWORD PTR $T14[ebp+8]
  000ac	89 45 e4	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 544  :     uint8_t *srcLine = (uint8_t *)src[0] + src_y_pitch_byte * y_range.start_src + crop_left * 2;

  000af	b9 04 00 00 00	 mov	 ecx, 4
  000b4	6b d1 00	 imul	 edx, ecx, 0
  000b7	8b 45 14	 mov	 eax, DWORD PTR _src_y_pitch_byte$[ebp]
  000ba	0f af 45 dc	 imul	 eax, DWORD PTR _y_range$[ebp]
  000be	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  000c1	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  000c4	03 d0		 add	 edx, eax
  000c6	8b 45 f8	 mov	 eax, DWORD PTR _crop_left$[ebp]
  000c9	8d 0c 42	 lea	 ecx, DWORD PTR [edx+eax*2]
  000cc	89 4d c8	 mov	 DWORD PTR _srcLine$[ebp], ecx

; 545  :     uint8_t *dstYLine = (uint8_t *)dst[0] + dst_y_pitch_byte * y_range.start_dst;

  000cf	ba 04 00 00 00	 mov	 edx, 4
  000d4	6b c2 00	 imul	 eax, edx, 0
  000d7	8b 4d 1c	 mov	 ecx, DWORD PTR _dst_y_pitch_byte$[ebp]
  000da	0f af 4d e0	 imul	 ecx, DWORD PTR _y_range$[ebp+4]
  000de	8b 55 08	 mov	 edx, DWORD PTR _dst$[ebp]
  000e1	03 0c 02	 add	 ecx, DWORD PTR [edx+eax]
  000e4	89 4d c4	 mov	 DWORD PTR _dstYLine$[ebp], ecx

; 546  :     uint8_t *dstULine = (uint8_t *)dst[1] + dst_y_pitch_byte * y_range.start_dst;

  000e7	b8 04 00 00 00	 mov	 eax, 4
  000ec	c1 e0 00	 shl	 eax, 0
  000ef	8b 4d 1c	 mov	 ecx, DWORD PTR _dst_y_pitch_byte$[ebp]
  000f2	0f af 4d e0	 imul	 ecx, DWORD PTR _y_range$[ebp+4]
  000f6	8b 55 08	 mov	 edx, DWORD PTR _dst$[ebp]
  000f9	03 0c 02	 add	 ecx, DWORD PTR [edx+eax]
  000fc	89 4d c0	 mov	 DWORD PTR _dstULine$[ebp], ecx

; 547  :     uint8_t *dstVLine = (uint8_t *)dst[2] + dst_y_pitch_byte * y_range.start_dst;

  000ff	b8 04 00 00 00	 mov	 eax, 4
  00104	d1 e0		 shl	 eax, 1
  00106	8b 4d 1c	 mov	 ecx, DWORD PTR _dst_y_pitch_byte$[ebp]
  00109	0f af 4d e0	 imul	 ecx, DWORD PTR _y_range$[ebp+4]
  0010d	8b 55 08	 mov	 edx, DWORD PTR _dst$[ebp]
  00110	03 0c 02	 add	 ecx, DWORD PTR [edx+eax]
  00113	89 4d bc	 mov	 DWORD PTR _dstVLine$[ebp], ecx

; 548  :     const int y_width = width - crop_right - crop_left;

  00116	8b 45 10	 mov	 eax, DWORD PTR _width$[ebp]
  00119	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  0011c	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  0011f	89 45 b8	 mov	 DWORD PTR _y_width$[ebp], eax

; 549  :     for (int y = 0; y < y_range.len; y++, srcLine += src_y_pitch_byte, dstYLine += dst_y_pitch_byte, dstULine += dst_y_pitch_byte, dstVLine += dst_y_pitch_byte) {

  00122	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _y$13[ebp], 0
  00129	eb 2d		 jmp	 SHORT $LN4@convert_yu
$LN2@convert_yu:
  0012b	8b 4d b4	 mov	 ecx, DWORD PTR _y$13[ebp]
  0012e	83 c1 01	 add	 ecx, 1
  00131	89 4d b4	 mov	 DWORD PTR _y$13[ebp], ecx
  00134	8b 55 c8	 mov	 edx, DWORD PTR _srcLine$[ebp]
  00137	03 55 14	 add	 edx, DWORD PTR _src_y_pitch_byte$[ebp]
  0013a	89 55 c8	 mov	 DWORD PTR _srcLine$[ebp], edx
  0013d	8b 45 c4	 mov	 eax, DWORD PTR _dstYLine$[ebp]
  00140	03 45 1c	 add	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  00143	89 45 c4	 mov	 DWORD PTR _dstYLine$[ebp], eax
  00146	8b 4d c0	 mov	 ecx, DWORD PTR _dstULine$[ebp]
  00149	03 4d 1c	 add	 ecx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0014c	89 4d c0	 mov	 DWORD PTR _dstULine$[ebp], ecx
  0014f	8b 55 bc	 mov	 edx, DWORD PTR _dstVLine$[ebp]
  00152	03 55 1c	 add	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  00155	89 55 bc	 mov	 DWORD PTR _dstVLine$[ebp], edx
$LN4@convert_yu:
  00158	8b 45 b4	 mov	 eax, DWORD PTR _y$13[ebp]
  0015b	3b 45 e4	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  0015e	0f 8d 65 01 00
	00		 jge	 $LN1@convert_yu

; 550  :         uint8_t *srcP = srcLine;

  00164	8b 4d c8	 mov	 ecx, DWORD PTR _srcLine$[ebp]
  00167	89 4d b0	 mov	 DWORD PTR _srcP$12[ebp], ecx

; 551  :         uint8_t *dstY = dstYLine;

  0016a	8b 55 c4	 mov	 edx, DWORD PTR _dstYLine$[ebp]
  0016d	89 55 ac	 mov	 DWORD PTR _dstY$11[ebp], edx

; 552  :         uint8_t *dstU = dstULine;

  00170	8b 45 c0	 mov	 eax, DWORD PTR _dstULine$[ebp]
  00173	89 45 a8	 mov	 DWORD PTR _dstU$10[ebp], eax

; 553  :         uint8_t *dstV = dstVLine;

  00176	8b 4d bc	 mov	 ecx, DWORD PTR _dstVLine$[ebp]
  00179	89 4d a4	 mov	 DWORD PTR _dstV$9[ebp], ecx

; 554  :         const int x_fin = width - crop_right - crop_left;

  0017c	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  0017f	2b 55 f0	 sub	 edx, DWORD PTR _crop_right$[ebp]
  00182	2b 55 f8	 sub	 edx, DWORD PTR _crop_left$[ebp]
  00185	89 55 a0	 mov	 DWORD PTR _x_fin$8[ebp], edx

; 555  :         for (int x = 0; x < x_fin; x += 2, srcP += 4, dstY += 2, dstU += 2, dstV += 2) {

  00188	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR _x$7[ebp], 0
  0018f	eb 2d		 jmp	 SHORT $LN7@convert_yu
$LN5@convert_yu:
  00191	8b 45 9c	 mov	 eax, DWORD PTR _x$7[ebp]
  00194	83 c0 02	 add	 eax, 2
  00197	89 45 9c	 mov	 DWORD PTR _x$7[ebp], eax
  0019a	8b 4d b0	 mov	 ecx, DWORD PTR _srcP$12[ebp]
  0019d	83 c1 04	 add	 ecx, 4
  001a0	89 4d b0	 mov	 DWORD PTR _srcP$12[ebp], ecx
  001a3	8b 55 ac	 mov	 edx, DWORD PTR _dstY$11[ebp]
  001a6	83 c2 02	 add	 edx, 2
  001a9	89 55 ac	 mov	 DWORD PTR _dstY$11[ebp], edx
  001ac	8b 45 a8	 mov	 eax, DWORD PTR _dstU$10[ebp]
  001af	83 c0 02	 add	 eax, 2
  001b2	89 45 a8	 mov	 DWORD PTR _dstU$10[ebp], eax
  001b5	8b 4d a4	 mov	 ecx, DWORD PTR _dstV$9[ebp]
  001b8	83 c1 02	 add	 ecx, 2
  001bb	89 4d a4	 mov	 DWORD PTR _dstV$9[ebp], ecx
$LN7@convert_yu:
  001be	8b 55 9c	 mov	 edx, DWORD PTR _x$7[ebp]
  001c1	3b 55 a0	 cmp	 edx, DWORD PTR _x_fin$8[ebp]
  001c4	0f 8d fa 00 00
	00		 jge	 $LN6@convert_yu

; 556  :             int cxplus = (x + 2 < x_fin) ? 4 : 0;

  001ca	8b 45 9c	 mov	 eax, DWORD PTR _x$7[ebp]
  001cd	83 c0 02	 add	 eax, 2
  001d0	3b 45 a0	 cmp	 eax, DWORD PTR _x_fin$8[ebp]
  001d3	7d 0c		 jge	 SHORT $LN9@convert_yu
  001d5	c7 85 78 ff ff
	ff 04 00 00 00	 mov	 DWORD PTR tv148[ebp], 4
  001df	eb 0a		 jmp	 SHORT $LN10@convert_yu
$LN9@convert_yu:
  001e1	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv148[ebp], 0
$LN10@convert_yu:
  001eb	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR tv148[ebp]
  001f1	89 4d 98	 mov	 DWORD PTR _cxplus$6[ebp], ecx

; 557  :             dstY[0] = srcP[0];

  001f4	ba 01 00 00 00	 mov	 edx, 1
  001f9	6b c2 00	 imul	 eax, edx, 0
  001fc	b9 01 00 00 00	 mov	 ecx, 1
  00201	6b d1 00	 imul	 edx, ecx, 0
  00204	8b 4d ac	 mov	 ecx, DWORD PTR _dstY$11[ebp]
  00207	8b 75 b0	 mov	 esi, DWORD PTR _srcP$12[ebp]
  0020a	8a 04 06	 mov	 al, BYTE PTR [esi+eax]
  0020d	88 04 11	 mov	 BYTE PTR [ecx+edx], al

; 558  :             dstY[1] = srcP[2];

  00210	b9 01 00 00 00	 mov	 ecx, 1
  00215	d1 e1		 shl	 ecx, 1
  00217	ba 01 00 00 00	 mov	 edx, 1
  0021c	c1 e2 00	 shl	 edx, 0
  0021f	8b 45 ac	 mov	 eax, DWORD PTR _dstY$11[ebp]
  00222	8b 75 b0	 mov	 esi, DWORD PTR _srcP$12[ebp]
  00225	8a 0c 0e	 mov	 cl, BYTE PTR [esi+ecx]
  00228	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 559  : 
; 560  :             int ux0 = srcP[1];

  0022b	ba 01 00 00 00	 mov	 edx, 1
  00230	c1 e2 00	 shl	 edx, 0
  00233	8b 45 b0	 mov	 eax, DWORD PTR _srcP$12[ebp]
  00236	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  0023a	89 4d 94	 mov	 DWORD PTR _ux0$5[ebp], ecx

; 561  :             int vx0 = srcP[3];

  0023d	ba 01 00 00 00	 mov	 edx, 1
  00242	6b c2 03	 imul	 eax, edx, 3
  00245	8b 4d b0	 mov	 ecx, DWORD PTR _srcP$12[ebp]
  00248	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  0024c	89 55 90	 mov	 DWORD PTR _vx0$4[ebp], edx

; 562  :             int ux2 = srcP[1+cxplus];

  0024f	8b 45 b0	 mov	 eax, DWORD PTR _srcP$12[ebp]
  00252	03 45 98	 add	 eax, DWORD PTR _cxplus$6[ebp]
  00255	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  00259	89 4d 8c	 mov	 DWORD PTR _ux2$3[ebp], ecx

; 563  :             int vx2 = srcP[3+cxplus];

  0025c	8b 55 b0	 mov	 edx, DWORD PTR _srcP$12[ebp]
  0025f	03 55 98	 add	 edx, DWORD PTR _cxplus$6[ebp]
  00262	0f b6 42 03	 movzx	 eax, BYTE PTR [edx+3]
  00266	89 45 88	 mov	 DWORD PTR _vx2$2[ebp], eax

; 564  :             dstU[0] = (uint8_t)ux0;

  00269	b9 01 00 00 00	 mov	 ecx, 1
  0026e	6b d1 00	 imul	 edx, ecx, 0
  00271	8b 45 a8	 mov	 eax, DWORD PTR _dstU$10[ebp]
  00274	8a 4d 94	 mov	 cl, BYTE PTR _ux0$5[ebp]
  00277	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 565  :             dstU[1] = (uint8_t)((ux0 + ux2 + 1) >> 1);

  0027a	8b 55 8c	 mov	 edx, DWORD PTR _ux2$3[ebp]
  0027d	8b 45 94	 mov	 eax, DWORD PTR _ux0$5[ebp]
  00280	8d 4c 10 01	 lea	 ecx, DWORD PTR [eax+edx+1]
  00284	d1 f9		 sar	 ecx, 1
  00286	ba 01 00 00 00	 mov	 edx, 1
  0028b	c1 e2 00	 shl	 edx, 0
  0028e	8b 45 a8	 mov	 eax, DWORD PTR _dstU$10[ebp]
  00291	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 566  :             dstV[0] = (uint8_t)vx0;

  00294	b9 01 00 00 00	 mov	 ecx, 1
  00299	6b d1 00	 imul	 edx, ecx, 0
  0029c	8b 45 a4	 mov	 eax, DWORD PTR _dstV$9[ebp]
  0029f	8a 4d 90	 mov	 cl, BYTE PTR _vx0$4[ebp]
  002a2	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 567  :             dstV[1] = (uint8_t)((vx2 + vx2 + 1) >> 1);

  002a5	8b 55 88	 mov	 edx, DWORD PTR _vx2$2[ebp]
  002a8	8b 45 88	 mov	 eax, DWORD PTR _vx2$2[ebp]
  002ab	8d 4c 10 01	 lea	 ecx, DWORD PTR [eax+edx+1]
  002af	d1 f9		 sar	 ecx, 1
  002b1	ba 01 00 00 00	 mov	 edx, 1
  002b6	c1 e2 00	 shl	 edx, 0
  002b9	8b 45 a4	 mov	 eax, DWORD PTR _dstV$9[ebp]
  002bc	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 568  :         }

  002bf	e9 cd fe ff ff	 jmp	 $LN5@convert_yu
$LN6@convert_yu:

; 569  :     }

  002c4	e9 62 fe ff ff	 jmp	 $LN2@convert_yu
$LN1@convert_yu:

; 570  : }

  002c9	52		 push	 edx
  002ca	8b cd		 mov	 ecx, ebp
  002cc	50		 push	 eax
  002cd	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN13@convert_yu
  002d3	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  002d8	58		 pop	 eax
  002d9	5a		 pop	 edx
  002da	5f		 pop	 edi
  002db	5e		 pop	 esi
  002dc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002df	33 cd		 xor	 ecx, ebp
  002e1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002e6	81 c4 88 00 00
	00		 add	 esp, 136		; 00000088H
  002ec	3b ec		 cmp	 ebp, esp
  002ee	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002f3	8b e5		 mov	 esp, ebp
  002f5	5d		 pop	 ebp
  002f6	c3		 ret	 0
  002f7	90		 npad	 1
$LN13@convert_yu:
  002f8	01 00 00 00	 DD	 1
  002fc	00 00 00 00	 DD	 $LN12@convert_yu
$LN12@convert_yu:
  00300	dc ff ff ff	 DD	 -36			; ffffffdcH
  00304	0c 00 00 00	 DD	 12			; 0000000cH
  00308	00 00 00 00	 DD	 $LN11@convert_yu
$LN11@convert_yu:
  0030c	79		 DB	 121			; 00000079H
  0030d	5f		 DB	 95			; 0000005fH
  0030e	72		 DB	 114			; 00000072H
  0030f	61		 DB	 97			; 00000061H
  00310	6e		 DB	 110			; 0000006eH
  00311	67		 DB	 103			; 00000067H
  00312	65		 DB	 101			; 00000065H
  00313	00		 DB	 0
?convert_yuy2_to_yuv444@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuy2_to_yuv444
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
tv155 = -128						; size = 4
$T1 = -124						; size = 12
_cy1x1$2 = -112						; size = 4
_cy1x0$3 = -108						; size = 4
_cxplus$4 = -104					; size = 4
_x$5 = -100						; size = 4
_x_fin$6 = -96						; size = 4
_srcP$7 = -92						; size = 4
_dstC$8 = -88						; size = 4
_y$9 = -84						; size = 4
_dstLine$10 = -80					; size = 4
_srcCLine$11 = -76					; size = 4
_ic$12 = -72						; size = 4
_y$13 = -68						; size = 4
_y_width$14 = -64					; size = 4
_dstLine$15 = -60					; size = 4
_srcYLine$16 = -56					; size = 4
$T17 = -52						; size = 12
_y_range$ = -36						; size = 12
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuv422_to_yuv444@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv422_to_yuv444

; 504  : static void convert_yuv422_to_yuv444(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00009	57		 push	 edi
  0000a	8d 7d 80	 lea	 edi, DWORD PTR [ebp-128]
  0000d	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 505  :     const int crop_left   = crop[0];

  00023	b8 04 00 00 00	 mov	 eax, 4
  00028	6b c8 00	 imul	 ecx, eax, 0
  0002b	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  0002e	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00031	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 506  :     const int crop_up     = crop[1];

  00034	b9 04 00 00 00	 mov	 ecx, 4
  00039	c1 e1 00	 shl	 ecx, 0
  0003c	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  0003f	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00042	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 507  :     const int crop_right  = crop[2];

  00045	b9 04 00 00 00	 mov	 ecx, 4
  0004a	d1 e1		 shl	 ecx, 1
  0004c	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  0004f	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00052	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 508  :     const int crop_bottom = crop[3];

  00055	b9 04 00 00 00	 mov	 ecx, 4
  0005a	6b d1 03	 imul	 edx, ecx, 3
  0005d	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00060	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00063	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 509  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00066	8b 55 2c	 mov	 edx, DWORD PTR _thread_n$[ebp]
  00069	52		 push	 edx
  0006a	8b 45 28	 mov	 eax, DWORD PTR _thread_id$[ebp]
  0006d	50		 push	 eax
  0006e	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00071	2b 4d ec	 sub	 ecx, DWORD PTR _crop_bottom$[ebp]
  00074	51		 push	 ecx
  00075	8b 55 f4	 mov	 edx, DWORD PTR _crop_up$[ebp]
  00078	52		 push	 edx
  00079	8d 45 84	 lea	 eax, DWORD PTR $T1[ebp]
  0007c	50		 push	 eax
  0007d	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00082	83 c4 14	 add	 esp, 20			; 00000014H
  00085	8b 08		 mov	 ecx, DWORD PTR [eax]
  00087	89 4d cc	 mov	 DWORD PTR $T17[ebp], ecx
  0008a	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0008d	89 55 d0	 mov	 DWORD PTR $T17[ebp+4], edx
  00090	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00093	89 45 d4	 mov	 DWORD PTR $T17[ebp+8], eax
  00096	8b 4d cc	 mov	 ecx, DWORD PTR $T17[ebp]
  00099	89 4d dc	 mov	 DWORD PTR _y_range$[ebp], ecx
  0009c	8b 55 d0	 mov	 edx, DWORD PTR $T17[ebp+4]
  0009f	89 55 e0	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000a2	8b 45 d4	 mov	 eax, DWORD PTR $T17[ebp+8]
  000a5	89 45 e4	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 510  :     //Y
; 511  :     if (true) {

  000a8	b9 01 00 00 00	 mov	 ecx, 1
  000ad	85 c9		 test	 ecx, ecx
  000af	0f 84 82 00 00
	00		 je	 $LN14@convert_yu

; 512  :         uint8_t *srcYLine = (uint8_t *)src[0] + src_y_pitch_byte * y_range.start_src + crop_left;

  000b5	ba 04 00 00 00	 mov	 edx, 4
  000ba	6b c2 00	 imul	 eax, edx, 0
  000bd	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  000c0	0f af 4d dc	 imul	 ecx, DWORD PTR _y_range$[ebp]
  000c4	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  000c7	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  000ca	03 c1		 add	 eax, ecx
  000cc	03 45 f8	 add	 eax, DWORD PTR _crop_left$[ebp]
  000cf	89 45 c8	 mov	 DWORD PTR _srcYLine$16[ebp], eax

; 513  :         uint8_t *dstLine = (uint8_t *)dst[0] + dst_y_pitch_byte * y_range.start_dst;

  000d2	b9 04 00 00 00	 mov	 ecx, 4
  000d7	6b d1 00	 imul	 edx, ecx, 0
  000da	8b 45 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  000dd	0f af 45 e0	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  000e1	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  000e4	03 04 11	 add	 eax, DWORD PTR [ecx+edx]
  000e7	89 45 c4	 mov	 DWORD PTR _dstLine$15[ebp], eax

; 514  :         const int y_width = width - crop_right - crop_left;

  000ea	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  000ed	2b 55 f0	 sub	 edx, DWORD PTR _crop_right$[ebp]
  000f0	2b 55 f8	 sub	 edx, DWORD PTR _crop_left$[ebp]
  000f3	89 55 c0	 mov	 DWORD PTR _y_width$14[ebp], edx

; 515  :         for (int y = crop_up; y < y_range.len; y++, srcYLine += src_y_pitch_byte, dstLine += dst_y_pitch_byte) {

  000f6	8b 45 f4	 mov	 eax, DWORD PTR _crop_up$[ebp]
  000f9	89 45 bc	 mov	 DWORD PTR _y$13[ebp], eax
  000fc	eb 1b		 jmp	 SHORT $LN4@convert_yu
$LN2@convert_yu:
  000fe	8b 4d bc	 mov	 ecx, DWORD PTR _y$13[ebp]
  00101	83 c1 01	 add	 ecx, 1
  00104	89 4d bc	 mov	 DWORD PTR _y$13[ebp], ecx
  00107	8b 55 c8	 mov	 edx, DWORD PTR _srcYLine$16[ebp]
  0010a	03 55 14	 add	 edx, DWORD PTR _src_y_pitch_byte$[ebp]
  0010d	89 55 c8	 mov	 DWORD PTR _srcYLine$16[ebp], edx
  00110	8b 45 c4	 mov	 eax, DWORD PTR _dstLine$15[ebp]
  00113	03 45 1c	 add	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  00116	89 45 c4	 mov	 DWORD PTR _dstLine$15[ebp], eax
$LN4@convert_yu:
  00119	8b 4d bc	 mov	 ecx, DWORD PTR _y$13[ebp]
  0011c	3b 4d e4	 cmp	 ecx, DWORD PTR _y_range$[ebp+8]
  0011f	7d 16		 jge	 SHORT $LN14@convert_yu

; 516  :             memcpy(dstLine, srcYLine, y_width);

  00121	8b 55 c0	 mov	 edx, DWORD PTR _y_width$14[ebp]
  00124	52		 push	 edx
  00125	8b 45 c8	 mov	 eax, DWORD PTR _srcYLine$16[ebp]
  00128	50		 push	 eax
  00129	8b 4d c4	 mov	 ecx, DWORD PTR _dstLine$15[ebp]
  0012c	51		 push	 ecx
  0012d	e8 00 00 00 00	 call	 _memcpy
  00132	83 c4 0c	 add	 esp, 12			; 0000000cH

; 517  :         }

  00135	eb c7		 jmp	 SHORT $LN2@convert_yu
$LN14@convert_yu:

; 518  :     }
; 519  :     //UV
; 520  :     for (int ic = 1; ic < 3; ic++) {

  00137	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR _ic$12[ebp], 1
  0013e	eb 09		 jmp	 SHORT $LN7@convert_yu
$LN5@convert_yu:
  00140	8b 55 b8	 mov	 edx, DWORD PTR _ic$12[ebp]
  00143	83 c2 01	 add	 edx, 1
  00146	89 55 b8	 mov	 DWORD PTR _ic$12[ebp], edx
$LN7@convert_yu:
  00149	83 7d b8 03	 cmp	 DWORD PTR _ic$12[ebp], 3
  0014d	0f 8d 16 01 00
	00		 jge	 $LN1@convert_yu

; 521  :         uint8_t *srcCLine = (uint8_t *)src[ic] + src_uv_pitch_byte * y_range.start_src + (crop_left >> 1);

  00153	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  00156	0f af 45 dc	 imul	 eax, DWORD PTR _y_range$[ebp]
  0015a	8b 4d b8	 mov	 ecx, DWORD PTR _ic$12[ebp]
  0015d	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  00160	8b 0c 8a	 mov	 ecx, DWORD PTR [edx+ecx*4]
  00163	03 c8		 add	 ecx, eax
  00165	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  00168	d1 fa		 sar	 edx, 1
  0016a	03 ca		 add	 ecx, edx
  0016c	89 4d b4	 mov	 DWORD PTR _srcCLine$11[ebp], ecx

; 522  :         uint8_t *dstLine = (uint8_t *)dst[ic] + dst_y_pitch_byte * y_range.start_dst;

  0016f	8b 45 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  00172	0f af 45 e0	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  00176	8b 4d b8	 mov	 ecx, DWORD PTR _ic$12[ebp]
  00179	8b 55 08	 mov	 edx, DWORD PTR _dst$[ebp]
  0017c	03 04 8a	 add	 eax, DWORD PTR [edx+ecx*4]
  0017f	89 45 b0	 mov	 DWORD PTR _dstLine$10[ebp], eax

; 523  :         for (int y = 0; y < y_range.len; y++, srcCLine += src_uv_pitch_byte, dstLine += dst_y_pitch_byte) {

  00182	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR _y$9[ebp], 0
  00189	eb 1b		 jmp	 SHORT $LN10@convert_yu
$LN8@convert_yu:
  0018b	8b 45 ac	 mov	 eax, DWORD PTR _y$9[ebp]
  0018e	83 c0 01	 add	 eax, 1
  00191	89 45 ac	 mov	 DWORD PTR _y$9[ebp], eax
  00194	8b 4d b4	 mov	 ecx, DWORD PTR _srcCLine$11[ebp]
  00197	03 4d 18	 add	 ecx, DWORD PTR _src_uv_pitch_byte$[ebp]
  0019a	89 4d b4	 mov	 DWORD PTR _srcCLine$11[ebp], ecx
  0019d	8b 55 b0	 mov	 edx, DWORD PTR _dstLine$10[ebp]
  001a0	03 55 1c	 add	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  001a3	89 55 b0	 mov	 DWORD PTR _dstLine$10[ebp], edx
$LN10@convert_yu:
  001a6	8b 45 ac	 mov	 eax, DWORD PTR _y$9[ebp]
  001a9	3b 45 e4	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  001ac	0f 8d b2 00 00
	00		 jge	 $LN9@convert_yu

; 524  :             uint8_t *dstC = dstLine;

  001b2	8b 4d b0	 mov	 ecx, DWORD PTR _dstLine$10[ebp]
  001b5	89 4d a8	 mov	 DWORD PTR _dstC$8[ebp], ecx

; 525  :             uint8_t *srcP = srcCLine;

  001b8	8b 55 b4	 mov	 edx, DWORD PTR _srcCLine$11[ebp]
  001bb	89 55 a4	 mov	 DWORD PTR _srcP$7[ebp], edx

; 526  :             const int x_fin = width - crop_right - crop_left;

  001be	8b 45 10	 mov	 eax, DWORD PTR _width$[ebp]
  001c1	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  001c4	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  001c7	89 45 a0	 mov	 DWORD PTR _x_fin$6[ebp], eax

; 527  :             for (int x = 0; x < x_fin; x += 2, dstC += 2, srcP++) {

  001ca	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR _x$5[ebp], 0
  001d1	eb 1b		 jmp	 SHORT $LN13@convert_yu
$LN11@convert_yu:
  001d3	8b 4d 9c	 mov	 ecx, DWORD PTR _x$5[ebp]
  001d6	83 c1 02	 add	 ecx, 2
  001d9	89 4d 9c	 mov	 DWORD PTR _x$5[ebp], ecx
  001dc	8b 55 a8	 mov	 edx, DWORD PTR _dstC$8[ebp]
  001df	83 c2 02	 add	 edx, 2
  001e2	89 55 a8	 mov	 DWORD PTR _dstC$8[ebp], edx
  001e5	8b 45 a4	 mov	 eax, DWORD PTR _srcP$7[ebp]
  001e8	83 c0 01	 add	 eax, 1
  001eb	89 45 a4	 mov	 DWORD PTR _srcP$7[ebp], eax
$LN13@convert_yu:
  001ee	8b 4d 9c	 mov	 ecx, DWORD PTR _x$5[ebp]
  001f1	3b 4d a0	 cmp	 ecx, DWORD PTR _x_fin$6[ebp]
  001f4	7d 69		 jge	 SHORT $LN12@convert_yu

; 528  :                 int cxplus = (x + 2 < x_fin);

  001f6	8b 55 9c	 mov	 edx, DWORD PTR _x$5[ebp]
  001f9	83 c2 02	 add	 edx, 2
  001fc	3b 55 a0	 cmp	 edx, DWORD PTR _x_fin$6[ebp]
  001ff	7d 09		 jge	 SHORT $LN16@convert_yu
  00201	c7 45 80 01 00
	00 00		 mov	 DWORD PTR tv155[ebp], 1
  00208	eb 07		 jmp	 SHORT $LN17@convert_yu
$LN16@convert_yu:
  0020a	c7 45 80 00 00
	00 00		 mov	 DWORD PTR tv155[ebp], 0
$LN17@convert_yu:
  00211	8b 45 80	 mov	 eax, DWORD PTR tv155[ebp]
  00214	89 45 98	 mov	 DWORD PTR _cxplus$4[ebp], eax

; 529  :                 int cy1x0 = srcP[0*src_uv_pitch_byte + 0];

  00217	6b 4d 18 00	 imul	 ecx, DWORD PTR _src_uv_pitch_byte$[ebp], 0
  0021b	8b 55 a4	 mov	 edx, DWORD PTR _srcP$7[ebp]
  0021e	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  00222	89 45 94	 mov	 DWORD PTR _cy1x0$3[ebp], eax

; 530  :                 int cy1x1 = srcP[0*src_uv_pitch_byte + cxplus];

  00225	6b 4d 18 00	 imul	 ecx, DWORD PTR _src_uv_pitch_byte$[ebp], 0
  00229	03 4d 98	 add	 ecx, DWORD PTR _cxplus$4[ebp]
  0022c	8b 55 a4	 mov	 edx, DWORD PTR _srcP$7[ebp]
  0022f	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  00233	89 45 90	 mov	 DWORD PTR _cy1x1$2[ebp], eax

; 531  :                 dstC[0*dst_y_pitch_byte   + 0] = (uint8_t)cy1x0;

  00236	6b 4d 1c 00	 imul	 ecx, DWORD PTR _dst_y_pitch_byte$[ebp], 0
  0023a	8b 55 a8	 mov	 edx, DWORD PTR _dstC$8[ebp]
  0023d	8a 45 94	 mov	 al, BYTE PTR _cy1x0$3[ebp]
  00240	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 532  :                 dstC[0*dst_y_pitch_byte   + 1] = (uint8_t)((cy1x0 + cy1x1 + 1) >> 1);

  00243	8b 4d 90	 mov	 ecx, DWORD PTR _cy1x1$2[ebp]
  00246	8b 55 94	 mov	 edx, DWORD PTR _cy1x0$3[ebp]
  00249	8d 44 0a 01	 lea	 eax, DWORD PTR [edx+ecx+1]
  0024d	d1 f8		 sar	 eax, 1
  0024f	6b 4d 1c 00	 imul	 ecx, DWORD PTR _dst_y_pitch_byte$[ebp], 0
  00253	8b 55 a8	 mov	 edx, DWORD PTR _dstC$8[ebp]
  00256	88 44 0a 01	 mov	 BYTE PTR [edx+ecx+1], al

; 533  :             }

  0025a	e9 74 ff ff ff	 jmp	 $LN11@convert_yu
$LN12@convert_yu:

; 534  :         }

  0025f	e9 27 ff ff ff	 jmp	 $LN8@convert_yu
$LN9@convert_yu:

; 535  :     }

  00264	e9 d7 fe ff ff	 jmp	 $LN5@convert_yu
$LN1@convert_yu:

; 536  : }

  00269	52		 push	 edx
  0026a	8b cd		 mov	 ecx, ebp
  0026c	50		 push	 eax
  0026d	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN20@convert_yu
  00273	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00278	58		 pop	 eax
  00279	5a		 pop	 edx
  0027a	5f		 pop	 edi
  0027b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0027e	33 cd		 xor	 ecx, ebp
  00280	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00285	81 c4 80 00 00
	00		 add	 esp, 128		; 00000080H
  0028b	3b ec		 cmp	 ebp, esp
  0028d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00292	8b e5		 mov	 esp, ebp
  00294	5d		 pop	 ebp
  00295	c3		 ret	 0
  00296	66 90		 npad	 2
$LN20@convert_yu:
  00298	01 00 00 00	 DD	 1
  0029c	00 00 00 00	 DD	 $LN19@convert_yu
$LN19@convert_yu:
  002a0	dc ff ff ff	 DD	 -36			; ffffffdcH
  002a4	0c 00 00 00	 DD	 12			; 0000000cH
  002a8	00 00 00 00	 DD	 $LN18@convert_yu
$LN18@convert_yu:
  002ac	79		 DB	 121			; 00000079H
  002ad	5f		 DB	 95			; 0000005fH
  002ae	72		 DB	 114			; 00000072H
  002af	61		 DB	 97			; 00000061H
  002b0	6e		 DB	 110			; 0000006eH
  002b1	67		 DB	 103			; 00000067H
  002b2	65		 DB	 101			; 00000065H
  002b3	00		 DB	 0
?convert_yuv422_to_yuv444@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv422_to_yuv444
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
$T1 = -200						; size = 4
$T2 = -196						; size = 4
$T3 = -192						; size = 4
$T4 = -188						; size = 4
$T5 = -184						; size = 12
_cv_y1$6 = -172						; size = 4
_cv_y0$7 = -168						; size = 4
_cu_y1$8 = -164						; size = 4
_cu_y0$9 = -160						; size = 4
_cy3v$10 = -156						; size = 4
_cy3u$11 = -152						; size = 4
_cy2v$12 = -148						; size = 4
_cy2u$13 = -144						; size = 4
_cy1v$14 = -140						; size = 4
_cy1u$15 = -136						; size = 4
_cy0v$16 = -132						; size = 4
_cy0u$17 = -128						; size = 4
_x$18 = -124						; size = 4
_x_fin$19 = -120					; size = 4
_srcV$20 = -116						; size = 4
_srcU$21 = -112						; size = 4
_dstC$22 = -108						; size = 4
_y$23 = -104						; size = 4
_uv_fin$ = -100						; size = 4
_dstLine$ = -96						; size = 4
_srcVLine$ = -92					; size = 4
_srcULine$ = -88					; size = 4
_src_uv_pitch$ = -84					; size = 4
_x$24 = -80						; size = 4
_y$25 = -76						; size = 4
_y_width$26 = -72					; size = 4
_dstLine$27 = -68					; size = 4
_srcYLine$28 = -64					; size = 4
$T29 = -60						; size = 12
_y_range$ = -44						; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yuv444_to_nv12_i_c@G$08G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_to_nv12_i_c<unsigned short,9,unsigned short,16,0>

; 342  : static void __forceinline convert_yuv444_to_nv12_i_c(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8d bd 38 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-200]
  00011	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 343  :     static_assert((sizeof(Tin)  == 1 && in_bit_depth  == 8) || (sizeof(Tin)  == 2 && 8 < in_bit_depth  && in_bit_depth  <= 16), "invalid input bit depth.");
; 344  :     static_assert((sizeof(Tout) == 1 && out_bit_depth == 8) || (sizeof(Tout) == 2 && 8 < out_bit_depth && out_bit_depth <= 16), "invalid output bit depth.");
; 345  :     const int crop_left   = crop[0];

  00027	b8 04 00 00 00	 mov	 eax, 4
  0002c	6b c8 00	 imul	 ecx, eax, 0
  0002f	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00032	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00035	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 346  :     const int crop_up     = crop[1];

  00038	b9 04 00 00 00	 mov	 ecx, 4
  0003d	c1 e1 00	 shl	 ecx, 0
  00040	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00043	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00046	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 347  :     const int crop_right  = crop[2];

  00049	b9 04 00 00 00	 mov	 ecx, 4
  0004e	d1 e1		 shl	 ecx, 1
  00050	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00053	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00056	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 348  :     const int crop_bottom = crop[3];

  00059	b9 04 00 00 00	 mov	 ecx, 4
  0005e	6b d1 03	 imul	 edx, ecx, 3
  00061	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00064	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00067	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 349  :     const int src_y_pitch = src_y_pitch_byte / sizeof(Tin);

  0006a	8b 55 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebp]
  0006d	d1 ea		 shr	 edx, 1
  0006f	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 350  :     const int dst_y_pitch = dst_y_pitch_byte / sizeof(Tout);

  00072	8b 45 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  00075	d1 e8		 shr	 eax, 1
  00077	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 351  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  0007a	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0007d	51		 push	 ecx
  0007e	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  00081	52		 push	 edx
  00082	8b 45 20	 mov	 eax, DWORD PTR _height$[ebp]
  00085	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  00088	50		 push	 eax
  00089	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  0008c	51		 push	 ecx
  0008d	8d 95 48 ff ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  00093	52		 push	 edx
  00094	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00099	83 c4 14	 add	 esp, 20			; 00000014H
  0009c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009e	89 4d c4	 mov	 DWORD PTR $T29[ebp], ecx
  000a1	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a4	89 55 c8	 mov	 DWORD PTR $T29[ebp+4], edx
  000a7	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000aa	89 45 cc	 mov	 DWORD PTR $T29[ebp+8], eax
  000ad	8b 4d c4	 mov	 ecx, DWORD PTR $T29[ebp]
  000b0	89 4d d4	 mov	 DWORD PTR _y_range$[ebp], ecx
  000b3	8b 55 c8	 mov	 edx, DWORD PTR $T29[ebp+4]
  000b6	89 55 d8	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000b9	8b 45 cc	 mov	 eax, DWORD PTR $T29[ebp+8]
  000bc	89 45 dc	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 352  :     //Y
; 353  :     if (!uv_only) {

  000bf	b9 01 00 00 00	 mov	 ecx, 1
  000c4	85 c9		 test	 ecx, ecx
  000c6	0f 84 6e 01 00
	00		 je	 $LN14@convert_yu

; 354  :         Tin *srcYLine = (Tin *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000cc	ba 04 00 00 00	 mov	 edx, 4
  000d1	6b c2 00	 imul	 eax, edx, 0
  000d4	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  000d7	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  000db	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  000de	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  000e1	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  000e4	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  000e7	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  000ea	89 45 c0	 mov	 DWORD PTR _srcYLine$28[ebp], eax

; 355  :         Tout *dstLine = (Tout *)dst[0] + dst_y_pitch * y_range.start_dst;

  000ed	b9 04 00 00 00	 mov	 ecx, 4
  000f2	6b d1 00	 imul	 edx, ecx, 0
  000f5	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  000f8	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  000fc	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  000ff	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  00102	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  00105	89 45 bc	 mov	 DWORD PTR _dstLine$27[ebp], eax

; 356  :         const int y_width = width - crop_right - crop_left;

  00108	8b 4d 10	 mov	 ecx, DWORD PTR _width$[ebp]
  0010b	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  0010e	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  00111	89 4d b8	 mov	 DWORD PTR _y_width$26[ebp], ecx

; 357  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  00114	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _y$25[ebp], 0
  0011b	eb 21		 jmp	 SHORT $LN4@convert_yu
$LN2@convert_yu:
  0011d	8b 55 b4	 mov	 edx, DWORD PTR _y$25[ebp]
  00120	83 c2 01	 add	 edx, 1
  00123	89 55 b4	 mov	 DWORD PTR _y$25[ebp], edx
  00126	8b 45 e8	 mov	 eax, DWORD PTR _src_y_pitch$[ebp]
  00129	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$28[ebp]
  0012c	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  0012f	89 55 c0	 mov	 DWORD PTR _srcYLine$28[ebp], edx
  00132	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  00135	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$27[ebp]
  00138	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  0013b	89 55 bc	 mov	 DWORD PTR _dstLine$27[ebp], edx
$LN4@convert_yu:
  0013e	8b 45 b4	 mov	 eax, DWORD PTR _y$25[ebp]
  00141	3b 45 dc	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  00144	0f 8d f0 00 00
	00		 jge	 $LN14@convert_yu

; 358  :             if (in_bit_depth == out_bit_depth && sizeof(Tin) == sizeof(Tout)) {

  0014a	33 c9		 xor	 ecx, ecx
  0014c	74 1b		 je	 SHORT $LN15@convert_yu

; 359  :                 memcpy(dstLine, srcYLine, y_width * sizeof(Tin));

  0014e	8b 55 b8	 mov	 edx, DWORD PTR _y_width$26[ebp]
  00151	d1 e2		 shl	 edx, 1
  00153	52		 push	 edx
  00154	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$28[ebp]
  00157	50		 push	 eax
  00158	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$27[ebp]
  0015b	51		 push	 ecx
  0015c	e8 00 00 00 00	 call	 _memcpy
  00161	83 c4 0c	 add	 esp, 12			; 0000000cH

; 360  :             } else {

  00164	e9 cc 00 00 00	 jmp	 $LN16@convert_yu
$LN15@convert_yu:

; 361  :                 for (int x = 0; x < y_width; x++) {

  00169	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _x$24[ebp], 0
  00170	eb 09		 jmp	 SHORT $LN7@convert_yu
$LN5@convert_yu:
  00172	8b 55 b0	 mov	 edx, DWORD PTR _x$24[ebp]
  00175	83 c2 01	 add	 edx, 1
  00178	89 55 b0	 mov	 DWORD PTR _x$24[ebp], edx
$LN7@convert_yu:
  0017b	8b 45 b0	 mov	 eax, DWORD PTR _x$24[ebp]
  0017e	3b 45 b8	 cmp	 eax, DWORD PTR _y_width$26[ebp]
  00181	0f 8d ae 00 00
	00		 jge	 $LN16@convert_yu

; 362  :                     if (out_bit_depth > in_bit_depth) {

  00187	b9 01 00 00 00	 mov	 ecx, 1
  0018c	85 c9		 test	 ecx, ecx
  0018e	74 44		 je	 SHORT $LN17@convert_yu

; 363  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) << std::max(out_bit_depth - in_bit_depth, 0));

  00190	c7 85 44 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], 0
  0019a	c7 85 40 ff ff
	ff 07 00 00 00	 mov	 DWORD PTR $T3[ebp], 7
  001a4	8b 55 b0	 mov	 edx, DWORD PTR _x$24[ebp]
  001a7	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$28[ebp]
  001aa	0f b7 34 50	 movzx	 esi, WORD PTR [eax+edx*2]
  001ae	8d 8d 44 ff ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  001b4	51		 push	 ecx
  001b5	8d 95 40 ff ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  001bb	52		 push	 edx
  001bc	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  001c1	83 c4 08	 add	 esp, 8
  001c4	8b 08		 mov	 ecx, DWORD PTR [eax]
  001c6	d3 e6		 shl	 esi, cl
  001c8	8b 45 b0	 mov	 eax, DWORD PTR _x$24[ebp]
  001cb	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$27[ebp]
  001ce	66 89 34 41	 mov	 WORD PTR [ecx+eax*2], si
  001d2	eb 5c		 jmp	 SHORT $LN18@convert_yu
$LN17@convert_yu:

; 364  :                     } else if (out_bit_depth < in_bit_depth) {

  001d4	33 d2		 xor	 edx, edx
  001d6	74 44		 je	 SHORT $LN19@convert_yu

; 365  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) >> std::max(in_bit_depth - out_bit_depth, 0));

  001d8	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], 0
  001e2	c7 85 38 ff ff
	ff f9 ff ff ff	 mov	 DWORD PTR $T1[ebp], -7	; fffffff9H
  001ec	8b 45 b0	 mov	 eax, DWORD PTR _x$24[ebp]
  001ef	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$28[ebp]
  001f2	0f b7 34 41	 movzx	 esi, WORD PTR [ecx+eax*2]
  001f6	8d 95 3c ff ff
	ff		 lea	 edx, DWORD PTR $T2[ebp]
  001fc	52		 push	 edx
  001fd	8d 85 38 ff ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  00203	50		 push	 eax
  00204	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  00209	83 c4 08	 add	 esp, 8
  0020c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0020e	d3 fe		 sar	 esi, cl
  00210	8b 4d b0	 mov	 ecx, DWORD PTR _x$24[ebp]
  00213	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$27[ebp]
  00216	66 89 34 4a	 mov	 WORD PTR [edx+ecx*2], si

; 366  :                     } else {

  0021a	eb 14		 jmp	 SHORT $LN18@convert_yu
$LN19@convert_yu:

; 367  :                         dstLine[x] = (Tout)srcYLine[x];

  0021c	8b 45 b0	 mov	 eax, DWORD PTR _x$24[ebp]
  0021f	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$27[ebp]
  00222	8b 55 b0	 mov	 edx, DWORD PTR _x$24[ebp]
  00225	8b 75 c0	 mov	 esi, DWORD PTR _srcYLine$28[ebp]
  00228	66 8b 14 56	 mov	 dx, WORD PTR [esi+edx*2]
  0022c	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx
$LN18@convert_yu:

; 368  :                     }
; 369  :                 }

  00230	e9 3d ff ff ff	 jmp	 $LN5@convert_yu
$LN16@convert_yu:

; 370  :             }
; 371  :         }

  00235	e9 e3 fe ff ff	 jmp	 $LN2@convert_yu
$LN14@convert_yu:

; 372  :     }
; 373  :     //UV
; 374  :     const int src_uv_pitch = src_uv_pitch_byte / sizeof(Tin);

  0023a	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0023d	d1 e8		 shr	 eax, 1
  0023f	89 45 ac	 mov	 DWORD PTR _src_uv_pitch$[ebp], eax

; 375  :     Tin *srcULine = (Tin *)src[1] + ((src_uv_pitch * y_range.start_src) + crop_left);

  00242	b9 04 00 00 00	 mov	 ecx, 4
  00247	c1 e1 00	 shl	 ecx, 0
  0024a	8b 55 ac	 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  0024d	0f af 55 d4	 imul	 edx, DWORD PTR _y_range$[ebp]
  00251	03 55 f8	 add	 edx, DWORD PTR _crop_left$[ebp]
  00254	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  00257	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  0025a	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  0025d	89 55 a8	 mov	 DWORD PTR _srcULine$[ebp], edx

; 376  :     Tin *srcVLine = (Tin *)src[2] + ((src_uv_pitch * y_range.start_src) + crop_left);

  00260	b8 04 00 00 00	 mov	 eax, 4
  00265	d1 e0		 shl	 eax, 1
  00267	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  0026a	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  0026e	03 4d f8	 add	 ecx, DWORD PTR _crop_left$[ebp]
  00271	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  00274	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  00277	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  0027a	89 4d a4	 mov	 DWORD PTR _srcVLine$[ebp], ecx

; 377  :     Tout *dstLine = (Tout *)dst[1] + (dst_y_pitch >> 1) * y_range.start_dst;

  0027d	ba 04 00 00 00	 mov	 edx, 4
  00282	c1 e2 00	 shl	 edx, 0
  00285	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  00288	d1 f8		 sar	 eax, 1
  0028a	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  0028e	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  00291	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  00294	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  00297	89 45 a0	 mov	 DWORD PTR _dstLine$[ebp], eax

; 378  :     const int uv_fin = height - crop_bottom - crop_up;

  0029a	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  0029d	2b 4d ec	 sub	 ecx, DWORD PTR _crop_bottom$[ebp]
  002a0	2b 4d f4	 sub	 ecx, DWORD PTR _crop_up$[ebp]
  002a3	89 4d 9c	 mov	 DWORD PTR _uv_fin$[ebp], ecx

; 379  :     for (int y = 0; y < y_range.len; y += 4, srcULine += src_uv_pitch * 4, srcVLine += src_uv_pitch * 4, dstLine += dst_y_pitch * 2) {

  002a6	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _y$23[ebp], 0
  002ad	eb 35		 jmp	 SHORT $LN10@convert_yu
$LN8@convert_yu:
  002af	8b 55 98	 mov	 edx, DWORD PTR _y$23[ebp]
  002b2	83 c2 04	 add	 edx, 4
  002b5	89 55 98	 mov	 DWORD PTR _y$23[ebp], edx
  002b8	8b 45 ac	 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  002bb	c1 e0 02	 shl	 eax, 2
  002be	8b 4d a8	 mov	 ecx, DWORD PTR _srcULine$[ebp]
  002c1	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  002c4	89 55 a8	 mov	 DWORD PTR _srcULine$[ebp], edx
  002c7	8b 45 ac	 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  002ca	c1 e0 02	 shl	 eax, 2
  002cd	8b 4d a4	 mov	 ecx, DWORD PTR _srcVLine$[ebp]
  002d0	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  002d3	89 55 a4	 mov	 DWORD PTR _srcVLine$[ebp], edx
  002d6	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  002d9	d1 e0		 shl	 eax, 1
  002db	8b 4d a0	 mov	 ecx, DWORD PTR _dstLine$[ebp]
  002de	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  002e1	89 55 a0	 mov	 DWORD PTR _dstLine$[ebp], edx
$LN10@convert_yu:
  002e4	8b 45 98	 mov	 eax, DWORD PTR _y$23[ebp]
  002e7	3b 45 dc	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  002ea	0f 8d 0e 02 00
	00		 jge	 $LN1@convert_yu

; 380  :         Tout *dstC = dstLine;

  002f0	8b 4d a0	 mov	 ecx, DWORD PTR _dstLine$[ebp]
  002f3	89 4d 94	 mov	 DWORD PTR _dstC$22[ebp], ecx

; 381  :         Tin *srcU = srcULine;

  002f6	8b 55 a8	 mov	 edx, DWORD PTR _srcULine$[ebp]
  002f9	89 55 90	 mov	 DWORD PTR _srcU$21[ebp], edx

; 382  :         Tin *srcV = srcVLine;

  002fc	8b 45 a4	 mov	 eax, DWORD PTR _srcVLine$[ebp]
  002ff	89 45 8c	 mov	 DWORD PTR _srcV$20[ebp], eax

; 383  :         const int x_fin = width - crop_right - crop_left;

  00302	8b 4d 10	 mov	 ecx, DWORD PTR _width$[ebp]
  00305	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  00308	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  0030b	89 4d 88	 mov	 DWORD PTR _x_fin$19[ebp], ecx

; 384  :         for (int x = 0; x < x_fin; x += 2, dstC += 2, srcU += 2, srcV += 2) {

  0030e	c7 45 84 00 00
	00 00		 mov	 DWORD PTR _x$18[ebp], 0
  00315	eb 24		 jmp	 SHORT $LN13@convert_yu
$LN11@convert_yu:
  00317	8b 55 84	 mov	 edx, DWORD PTR _x$18[ebp]
  0031a	83 c2 02	 add	 edx, 2
  0031d	89 55 84	 mov	 DWORD PTR _x$18[ebp], edx
  00320	8b 45 94	 mov	 eax, DWORD PTR _dstC$22[ebp]
  00323	83 c0 04	 add	 eax, 4
  00326	89 45 94	 mov	 DWORD PTR _dstC$22[ebp], eax
  00329	8b 4d 90	 mov	 ecx, DWORD PTR _srcU$21[ebp]
  0032c	83 c1 04	 add	 ecx, 4
  0032f	89 4d 90	 mov	 DWORD PTR _srcU$21[ebp], ecx
  00332	8b 55 8c	 mov	 edx, DWORD PTR _srcV$20[ebp]
  00335	83 c2 04	 add	 edx, 4
  00338	89 55 8c	 mov	 DWORD PTR _srcV$20[ebp], edx
$LN13@convert_yu:
  0033b	8b 45 84	 mov	 eax, DWORD PTR _x$18[ebp]
  0033e	3b 45 88	 cmp	 eax, DWORD PTR _x_fin$19[ebp]
  00341	0f 8d b2 01 00
	00		 jge	 $LN12@convert_yu

; 385  :             int cy0u = srcU[0*src_uv_pitch + 0];

  00347	6b 4d ac 00	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 0
  0034b	8b 55 90	 mov	 edx, DWORD PTR _srcU$21[ebp]
  0034e	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00352	89 45 80	 mov	 DWORD PTR _cy0u$17[ebp], eax

; 386  :             int cy0v = srcV[0*src_uv_pitch + 0];

  00355	6b 4d ac 00	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 0
  00359	8b 55 8c	 mov	 edx, DWORD PTR _srcV$20[ebp]
  0035c	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00360	89 85 7c ff ff
	ff		 mov	 DWORD PTR _cy0v$16[ebp], eax

; 387  :             int cy1u = srcU[1*src_uv_pitch + 0];

  00366	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00369	8b 55 90	 mov	 edx, DWORD PTR _srcU$21[ebp]
  0036c	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00370	89 85 78 ff ff
	ff		 mov	 DWORD PTR _cy1u$15[ebp], eax

; 388  :             int cy1v = srcV[1*src_uv_pitch + 0];

  00376	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00379	8b 55 8c	 mov	 edx, DWORD PTR _srcV$20[ebp]
  0037c	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00380	89 85 74 ff ff
	ff		 mov	 DWORD PTR _cy1v$14[ebp], eax

; 389  :             int cy2u = srcU[2*src_uv_pitch + 0];

  00386	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00389	d1 e1		 shl	 ecx, 1
  0038b	8b 55 90	 mov	 edx, DWORD PTR _srcU$21[ebp]
  0038e	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00392	89 85 70 ff ff
	ff		 mov	 DWORD PTR _cy2u$13[ebp], eax

; 390  :             int cy2v = srcV[2*src_uv_pitch + 0];

  00398	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  0039b	d1 e1		 shl	 ecx, 1
  0039d	8b 55 8c	 mov	 edx, DWORD PTR _srcV$20[ebp]
  003a0	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  003a4	89 85 6c ff ff
	ff		 mov	 DWORD PTR _cy2v$12[ebp], eax

; 391  :             int cy3u = srcU[3*src_uv_pitch + 0];

  003aa	6b 4d ac 03	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 3
  003ae	8b 55 90	 mov	 edx, DWORD PTR _srcU$21[ebp]
  003b1	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  003b5	89 85 68 ff ff
	ff		 mov	 DWORD PTR _cy3u$11[ebp], eax

; 392  :             int cy3v = srcV[3*src_uv_pitch + 0];

  003bb	6b 4d ac 03	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 3
  003bf	8b 55 8c	 mov	 edx, DWORD PTR _srcV$20[ebp]
  003c2	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  003c6	89 85 64 ff ff
	ff		 mov	 DWORD PTR _cy3v$10[ebp], eax

; 393  : 
; 394  :             int cu_y0 = cy0u * 3 + cy2u * 1 + 2;

  003cc	6b 4d 80 03	 imul	 ecx, DWORD PTR _cy0u$17[ebp], 3
  003d0	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR _cy2u$13[ebp]
  003d6	8d 44 11 02	 lea	 eax, DWORD PTR [ecx+edx+2]
  003da	89 85 60 ff ff
	ff		 mov	 DWORD PTR _cu_y0$9[ebp], eax

; 395  :             int cu_y1 = cy1u * 1 + cy3u * 3 + 2;

  003e0	6b 8d 68 ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy3u$11[ebp], 3
  003e7	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _cy1u$15[ebp]
  003ed	8d 44 0a 02	 lea	 eax, DWORD PTR [edx+ecx+2]
  003f1	89 85 5c ff ff
	ff		 mov	 DWORD PTR _cu_y1$8[ebp], eax

; 396  :             int cv_y0 = cy0v * 3 + cy2v * 1 + 2;

  003f7	6b 8d 7c ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy0v$16[ebp], 3
  003fe	8b 95 6c ff ff
	ff		 mov	 edx, DWORD PTR _cy2v$12[ebp]
  00404	8d 44 11 02	 lea	 eax, DWORD PTR [ecx+edx+2]
  00408	89 85 58 ff ff
	ff		 mov	 DWORD PTR _cv_y0$7[ebp], eax

; 397  :             int cv_y1 = cy1v * 1 + cy3v * 3 + 2;

  0040e	6b 8d 64 ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy3v$10[ebp], 3
  00415	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _cy1v$14[ebp]
  0041b	8d 44 0a 02	 lea	 eax, DWORD PTR [edx+ecx+2]
  0041f	89 85 54 ff ff
	ff		 mov	 DWORD PTR _cv_y1$6[ebp], eax

; 398  :             CHANGE_BIT_DEPTH_4(cu_y0, cu_y1, cv_y0, cv_y1, 2);

  00425	b9 01 00 00 00	 mov	 ecx, 1
  0042a	85 c9		 test	 ecx, ecx
  0042c	74 3e		 je	 SHORT $LN21@convert_yu
  0042e	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _cu_y0$9[ebp]
  00434	c1 e2 05	 shl	 edx, 5
  00437	89 95 60 ff ff
	ff		 mov	 DWORD PTR _cu_y0$9[ebp], edx
  0043d	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _cu_y1$8[ebp]
  00443	c1 e0 05	 shl	 eax, 5
  00446	89 85 5c ff ff
	ff		 mov	 DWORD PTR _cu_y1$8[ebp], eax
  0044c	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _cv_y0$7[ebp]
  00452	c1 e1 05	 shl	 ecx, 5
  00455	89 8d 58 ff ff
	ff		 mov	 DWORD PTR _cv_y0$7[ebp], ecx
  0045b	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR _cv_y1$6[ebp]
  00461	c1 e2 05	 shl	 edx, 5
  00464	89 95 54 ff ff
	ff		 mov	 DWORD PTR _cv_y1$6[ebp], edx
  0046a	eb 40		 jmp	 SHORT $LN22@convert_yu
$LN21@convert_yu:
  0046c	33 c0		 xor	 eax, eax
  0046e	74 3c		 je	 SHORT $LN22@convert_yu
  00470	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _cu_y0$9[ebp]
  00476	c1 f9 fb	 sar	 ecx, -5			; fffffffbH
  00479	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _cu_y0$9[ebp], ecx
  0047f	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR _cu_y1$8[ebp]
  00485	c1 fa fb	 sar	 edx, -5			; fffffffbH
  00488	89 95 5c ff ff
	ff		 mov	 DWORD PTR _cu_y1$8[ebp], edx
  0048e	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _cv_y0$7[ebp]
  00494	c1 f8 fb	 sar	 eax, -5			; fffffffbH
  00497	89 85 58 ff ff
	ff		 mov	 DWORD PTR _cv_y0$7[ebp], eax
  0049d	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _cv_y1$6[ebp]
  004a3	c1 f9 fb	 sar	 ecx, -5			; fffffffbH
  004a6	89 8d 54 ff ff
	ff		 mov	 DWORD PTR _cv_y1$6[ebp], ecx
$LN22@convert_yu:

; 399  : 
; 400  :             dstC[0*dst_y_pitch + 0] = (Tout)cu_y0;

  004ac	6b 55 e4 00	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 0
  004b0	8b 45 94	 mov	 eax, DWORD PTR _dstC$22[ebp]
  004b3	66 8b 8d 60 ff
	ff ff		 mov	 cx, WORD PTR _cu_y0$9[ebp]
  004ba	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx

; 401  :             dstC[0*dst_y_pitch + 1] = (Tout)cv_y0;

  004be	6b 55 e4 00	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 0
  004c2	8b 45 94	 mov	 eax, DWORD PTR _dstC$22[ebp]
  004c5	66 8b 8d 58 ff
	ff ff		 mov	 cx, WORD PTR _cv_y0$7[ebp]
  004cc	66 89 4c 50 02	 mov	 WORD PTR [eax+edx*2+2], cx

; 402  :             dstC[1*dst_y_pitch + 0] = (Tout)cu_y1;

  004d1	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  004d4	8b 45 94	 mov	 eax, DWORD PTR _dstC$22[ebp]
  004d7	66 8b 8d 5c ff
	ff ff		 mov	 cx, WORD PTR _cu_y1$8[ebp]
  004de	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx

; 403  :             dstC[1*dst_y_pitch + 1] = (Tout)cv_y1;

  004e2	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  004e5	8b 45 94	 mov	 eax, DWORD PTR _dstC$22[ebp]
  004e8	66 8b 8d 54 ff
	ff ff		 mov	 cx, WORD PTR _cv_y1$6[ebp]
  004ef	66 89 4c 50 02	 mov	 WORD PTR [eax+edx*2+2], cx

; 404  :         }

  004f4	e9 1e fe ff ff	 jmp	 $LN11@convert_yu
$LN12@convert_yu:

; 405  :     }

  004f9	e9 b1 fd ff ff	 jmp	 $LN8@convert_yu
$LN1@convert_yu:

; 406  : }

  004fe	52		 push	 edx
  004ff	8b cd		 mov	 ecx, ebp
  00501	50		 push	 eax
  00502	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN27@convert_yu
  00508	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0050d	58		 pop	 eax
  0050e	5a		 pop	 edx
  0050f	5f		 pop	 edi
  00510	5e		 pop	 esi
  00511	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00514	33 cd		 xor	 ecx, ebp
  00516	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0051b	81 c4 c8 00 00
	00		 add	 esp, 200		; 000000c8H
  00521	3b ec		 cmp	 ebp, esp
  00523	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00528	8b e5		 mov	 esp, ebp
  0052a	5d		 pop	 ebp
  0052b	c3		 ret	 0
$LN27@convert_yu:
  0052c	01 00 00 00	 DD	 1
  00530	00 00 00 00	 DD	 $LN26@convert_yu
$LN26@convert_yu:
  00534	d4 ff ff ff	 DD	 -44			; ffffffd4H
  00538	0c 00 00 00	 DD	 12			; 0000000cH
  0053c	00 00 00 00	 DD	 $LN25@convert_yu
$LN25@convert_yu:
  00540	79		 DB	 121			; 00000079H
  00541	5f		 DB	 95			; 0000005fH
  00542	72		 DB	 114			; 00000072H
  00543	61		 DB	 97			; 00000061H
  00544	6e		 DB	 110			; 0000006eH
  00545	67		 DB	 103			; 00000067H
  00546	65		 DB	 101			; 00000065H
  00547	00		 DB	 0
??$convert_yuv444_to_nv12_i_c@G$08G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_to_nv12_i_c<unsigned short,9,unsigned short,16,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuv444_09_to_p010_i@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_09_to_p010_i

; 500  : static void convert_yuv444_09_to_p010_i(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 501  :     convert_yuv444_to_nv12_i_c<uint16_t, 9, uint16_t, 16, false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yuv444_to_nv12_i_c@G$08G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_to_nv12_i_c<unsigned short,9,unsigned short,16,0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 502  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yuv444_09_to_p010_i@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_09_to_p010_i
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
$T1 = -172						; size = 4
$T2 = -168						; size = 4
$T3 = -164						; size = 4
$T4 = -160						; size = 4
$T5 = -156						; size = 12
_cv$6 = -144						; size = 4
_cu$7 = -140						; size = 4
_cy1v$8 = -136						; size = 4
_cy1u$9 = -132						; size = 4
_cy0v$10 = -128						; size = 4
_cy0u$11 = -124						; size = 4
_x$12 = -120						; size = 4
_x_fin$13 = -116					; size = 4
_srcV$14 = -112						; size = 4
_srcU$15 = -108						; size = 4
_dstC$16 = -104						; size = 4
_y$17 = -100						; size = 4
_dstLine$ = -96						; size = 4
_srcVLine$ = -92					; size = 4
_srcULine$ = -88					; size = 4
_src_uv_pitch$ = -84					; size = 4
_x$18 = -80						; size = 4
_y$19 = -76						; size = 4
_y_width$20 = -72					; size = 4
_dstLine$21 = -68					; size = 4
_srcYLine$22 = -64					; size = 4
$T23 = -60						; size = 12
_y_range$ = -44						; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yuv444_to_nv12_p_c@G$08G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_to_nv12_p_c<unsigned short,9,unsigned short,16,0>

; 284  : static void __forceinline convert_yuv444_to_nv12_p_c(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec ac 00 00
	00		 sub	 esp, 172		; 000000acH
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8d bd 54 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-172]
  00011	b9 2b 00 00 00	 mov	 ecx, 43			; 0000002bH
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 285  :     static_assert((sizeof(Tin)  == 1 && in_bit_depth  == 8) || (sizeof(Tin)  == 2 && 8 < in_bit_depth  && in_bit_depth  <= 16), "invalid input bit depth.");
; 286  :     static_assert((sizeof(Tout) == 1 && out_bit_depth == 8) || (sizeof(Tout) == 2 && 8 < out_bit_depth && out_bit_depth <= 16), "invalid output bit depth.");
; 287  :     const int crop_left   = crop[0];

  00027	b8 04 00 00 00	 mov	 eax, 4
  0002c	6b c8 00	 imul	 ecx, eax, 0
  0002f	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00032	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00035	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 288  :     const int crop_up     = crop[1];

  00038	b9 04 00 00 00	 mov	 ecx, 4
  0003d	c1 e1 00	 shl	 ecx, 0
  00040	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00043	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00046	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 289  :     const int crop_right  = crop[2];

  00049	b9 04 00 00 00	 mov	 ecx, 4
  0004e	d1 e1		 shl	 ecx, 1
  00050	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00053	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00056	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 290  :     const int crop_bottom = crop[3];

  00059	b9 04 00 00 00	 mov	 ecx, 4
  0005e	6b d1 03	 imul	 edx, ecx, 3
  00061	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00064	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00067	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 291  :     const int src_y_pitch = src_y_pitch_byte / sizeof(Tin);

  0006a	8b 55 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebp]
  0006d	d1 ea		 shr	 edx, 1
  0006f	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 292  :     const int dst_y_pitch = dst_y_pitch_byte / sizeof(Tout);

  00072	8b 45 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  00075	d1 e8		 shr	 eax, 1
  00077	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 293  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  0007a	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0007d	51		 push	 ecx
  0007e	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  00081	52		 push	 edx
  00082	8b 45 20	 mov	 eax, DWORD PTR _height$[ebp]
  00085	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  00088	50		 push	 eax
  00089	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  0008c	51		 push	 ecx
  0008d	8d 95 64 ff ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  00093	52		 push	 edx
  00094	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00099	83 c4 14	 add	 esp, 20			; 00000014H
  0009c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009e	89 4d c4	 mov	 DWORD PTR $T23[ebp], ecx
  000a1	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a4	89 55 c8	 mov	 DWORD PTR $T23[ebp+4], edx
  000a7	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000aa	89 45 cc	 mov	 DWORD PTR $T23[ebp+8], eax
  000ad	8b 4d c4	 mov	 ecx, DWORD PTR $T23[ebp]
  000b0	89 4d d4	 mov	 DWORD PTR _y_range$[ebp], ecx
  000b3	8b 55 c8	 mov	 edx, DWORD PTR $T23[ebp+4]
  000b6	89 55 d8	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000b9	8b 45 cc	 mov	 eax, DWORD PTR $T23[ebp+8]
  000bc	89 45 dc	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 294  :     //Y
; 295  :     if (!uv_only) {

  000bf	b9 01 00 00 00	 mov	 ecx, 1
  000c4	85 c9		 test	 ecx, ecx
  000c6	0f 84 6e 01 00
	00		 je	 $LN14@convert_yu

; 296  :         Tin *srcYLine = (Tin *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000cc	ba 04 00 00 00	 mov	 edx, 4
  000d1	6b c2 00	 imul	 eax, edx, 0
  000d4	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  000d7	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  000db	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  000de	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  000e1	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  000e4	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  000e7	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  000ea	89 45 c0	 mov	 DWORD PTR _srcYLine$22[ebp], eax

; 297  :         Tout *dstLine = (Tout *)dst[0] + dst_y_pitch * y_range.start_dst;

  000ed	b9 04 00 00 00	 mov	 ecx, 4
  000f2	6b d1 00	 imul	 edx, ecx, 0
  000f5	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  000f8	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  000fc	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  000ff	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  00102	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  00105	89 45 bc	 mov	 DWORD PTR _dstLine$21[ebp], eax

; 298  :         const int y_width = width - crop_right - crop_left;

  00108	8b 4d 10	 mov	 ecx, DWORD PTR _width$[ebp]
  0010b	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  0010e	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  00111	89 4d b8	 mov	 DWORD PTR _y_width$20[ebp], ecx

; 299  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  00114	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _y$19[ebp], 0
  0011b	eb 21		 jmp	 SHORT $LN4@convert_yu
$LN2@convert_yu:
  0011d	8b 55 b4	 mov	 edx, DWORD PTR _y$19[ebp]
  00120	83 c2 01	 add	 edx, 1
  00123	89 55 b4	 mov	 DWORD PTR _y$19[ebp], edx
  00126	8b 45 e8	 mov	 eax, DWORD PTR _src_y_pitch$[ebp]
  00129	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$22[ebp]
  0012c	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  0012f	89 55 c0	 mov	 DWORD PTR _srcYLine$22[ebp], edx
  00132	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  00135	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$21[ebp]
  00138	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  0013b	89 55 bc	 mov	 DWORD PTR _dstLine$21[ebp], edx
$LN4@convert_yu:
  0013e	8b 45 b4	 mov	 eax, DWORD PTR _y$19[ebp]
  00141	3b 45 dc	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  00144	0f 8d f0 00 00
	00		 jge	 $LN14@convert_yu

; 300  :             if (in_bit_depth == out_bit_depth && sizeof(Tin) == sizeof(Tout)) {

  0014a	33 c9		 xor	 ecx, ecx
  0014c	74 1b		 je	 SHORT $LN15@convert_yu

; 301  :                 memcpy(dstLine, srcYLine, y_width * sizeof(Tin));

  0014e	8b 55 b8	 mov	 edx, DWORD PTR _y_width$20[ebp]
  00151	d1 e2		 shl	 edx, 1
  00153	52		 push	 edx
  00154	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$22[ebp]
  00157	50		 push	 eax
  00158	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$21[ebp]
  0015b	51		 push	 ecx
  0015c	e8 00 00 00 00	 call	 _memcpy
  00161	83 c4 0c	 add	 esp, 12			; 0000000cH

; 302  :             } else {

  00164	e9 cc 00 00 00	 jmp	 $LN16@convert_yu
$LN15@convert_yu:

; 303  :                 for (int x = 0; x < y_width; x++) {

  00169	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _x$18[ebp], 0
  00170	eb 09		 jmp	 SHORT $LN7@convert_yu
$LN5@convert_yu:
  00172	8b 55 b0	 mov	 edx, DWORD PTR _x$18[ebp]
  00175	83 c2 01	 add	 edx, 1
  00178	89 55 b0	 mov	 DWORD PTR _x$18[ebp], edx
$LN7@convert_yu:
  0017b	8b 45 b0	 mov	 eax, DWORD PTR _x$18[ebp]
  0017e	3b 45 b8	 cmp	 eax, DWORD PTR _y_width$20[ebp]
  00181	0f 8d ae 00 00
	00		 jge	 $LN16@convert_yu

; 304  :                     if (out_bit_depth > in_bit_depth) {

  00187	b9 01 00 00 00	 mov	 ecx, 1
  0018c	85 c9		 test	 ecx, ecx
  0018e	74 44		 je	 SHORT $LN17@convert_yu

; 305  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) << std::max(out_bit_depth - in_bit_depth, 0));

  00190	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], 0
  0019a	c7 85 5c ff ff
	ff 07 00 00 00	 mov	 DWORD PTR $T3[ebp], 7
  001a4	8b 55 b0	 mov	 edx, DWORD PTR _x$18[ebp]
  001a7	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$22[ebp]
  001aa	0f b7 34 50	 movzx	 esi, WORD PTR [eax+edx*2]
  001ae	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  001b4	51		 push	 ecx
  001b5	8d 95 5c ff ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  001bb	52		 push	 edx
  001bc	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  001c1	83 c4 08	 add	 esp, 8
  001c4	8b 08		 mov	 ecx, DWORD PTR [eax]
  001c6	d3 e6		 shl	 esi, cl
  001c8	8b 45 b0	 mov	 eax, DWORD PTR _x$18[ebp]
  001cb	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$21[ebp]
  001ce	66 89 34 41	 mov	 WORD PTR [ecx+eax*2], si
  001d2	eb 5c		 jmp	 SHORT $LN18@convert_yu
$LN17@convert_yu:

; 306  :                     } else if (out_bit_depth < in_bit_depth) {

  001d4	33 d2		 xor	 edx, edx
  001d6	74 44		 je	 SHORT $LN19@convert_yu

; 307  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) >> std::max(in_bit_depth - out_bit_depth, 0));

  001d8	c7 85 58 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], 0
  001e2	c7 85 54 ff ff
	ff f9 ff ff ff	 mov	 DWORD PTR $T1[ebp], -7	; fffffff9H
  001ec	8b 45 b0	 mov	 eax, DWORD PTR _x$18[ebp]
  001ef	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$22[ebp]
  001f2	0f b7 34 41	 movzx	 esi, WORD PTR [ecx+eax*2]
  001f6	8d 95 58 ff ff
	ff		 lea	 edx, DWORD PTR $T2[ebp]
  001fc	52		 push	 edx
  001fd	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  00203	50		 push	 eax
  00204	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  00209	83 c4 08	 add	 esp, 8
  0020c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0020e	d3 fe		 sar	 esi, cl
  00210	8b 4d b0	 mov	 ecx, DWORD PTR _x$18[ebp]
  00213	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$21[ebp]
  00216	66 89 34 4a	 mov	 WORD PTR [edx+ecx*2], si

; 308  :                     } else {

  0021a	eb 14		 jmp	 SHORT $LN18@convert_yu
$LN19@convert_yu:

; 309  :                         dstLine[x] = (Tout)srcYLine[x];

  0021c	8b 45 b0	 mov	 eax, DWORD PTR _x$18[ebp]
  0021f	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$21[ebp]
  00222	8b 55 b0	 mov	 edx, DWORD PTR _x$18[ebp]
  00225	8b 75 c0	 mov	 esi, DWORD PTR _srcYLine$22[ebp]
  00228	66 8b 14 56	 mov	 dx, WORD PTR [esi+edx*2]
  0022c	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx
$LN18@convert_yu:

; 310  :                     }
; 311  :                 }

  00230	e9 3d ff ff ff	 jmp	 $LN5@convert_yu
$LN16@convert_yu:

; 312  :             }
; 313  :         }

  00235	e9 e3 fe ff ff	 jmp	 $LN2@convert_yu
$LN14@convert_yu:

; 314  :     }
; 315  :     //UV
; 316  :     const int src_uv_pitch = src_uv_pitch_byte / sizeof(Tin);

  0023a	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0023d	d1 e8		 shr	 eax, 1
  0023f	89 45 ac	 mov	 DWORD PTR _src_uv_pitch$[ebp], eax

; 317  :     Tin *srcULine = (Tin *)src[1] + ((src_uv_pitch * y_range.start_src) + crop_left);

  00242	b9 04 00 00 00	 mov	 ecx, 4
  00247	c1 e1 00	 shl	 ecx, 0
  0024a	8b 55 ac	 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  0024d	0f af 55 d4	 imul	 edx, DWORD PTR _y_range$[ebp]
  00251	03 55 f8	 add	 edx, DWORD PTR _crop_left$[ebp]
  00254	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  00257	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  0025a	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  0025d	89 55 a8	 mov	 DWORD PTR _srcULine$[ebp], edx

; 318  :     Tin *srcVLine = (Tin *)src[2] + ((src_uv_pitch * y_range.start_src) + crop_left);

  00260	b8 04 00 00 00	 mov	 eax, 4
  00265	d1 e0		 shl	 eax, 1
  00267	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  0026a	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  0026e	03 4d f8	 add	 ecx, DWORD PTR _crop_left$[ebp]
  00271	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  00274	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  00277	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  0027a	89 4d a4	 mov	 DWORD PTR _srcVLine$[ebp], ecx

; 319  :     Tout *dstLine = (Tout *)dst[1] + (dst_y_pitch >> 1) * y_range.start_dst;

  0027d	ba 04 00 00 00	 mov	 edx, 4
  00282	c1 e2 00	 shl	 edx, 0
  00285	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  00288	d1 f8		 sar	 eax, 1
  0028a	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  0028e	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  00291	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  00294	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  00297	89 45 a0	 mov	 DWORD PTR _dstLine$[ebp], eax

; 320  :     for (int y = 0; y < y_range.len; y += 2, srcULine += src_uv_pitch * 2, srcVLine += src_uv_pitch * 2, dstLine += dst_y_pitch) {

  0029a	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR _y$17[ebp], 0
  002a1	eb 31		 jmp	 SHORT $LN10@convert_yu
$LN8@convert_yu:
  002a3	8b 4d 9c	 mov	 ecx, DWORD PTR _y$17[ebp]
  002a6	83 c1 02	 add	 ecx, 2
  002a9	89 4d 9c	 mov	 DWORD PTR _y$17[ebp], ecx
  002ac	8b 55 ac	 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  002af	d1 e2		 shl	 edx, 1
  002b1	8b 45 a8	 mov	 eax, DWORD PTR _srcULine$[ebp]
  002b4	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  002b7	89 4d a8	 mov	 DWORD PTR _srcULine$[ebp], ecx
  002ba	8b 55 ac	 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  002bd	d1 e2		 shl	 edx, 1
  002bf	8b 45 a4	 mov	 eax, DWORD PTR _srcVLine$[ebp]
  002c2	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  002c5	89 4d a4	 mov	 DWORD PTR _srcVLine$[ebp], ecx
  002c8	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  002cb	8b 45 a0	 mov	 eax, DWORD PTR _dstLine$[ebp]
  002ce	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  002d1	89 4d a0	 mov	 DWORD PTR _dstLine$[ebp], ecx
$LN10@convert_yu:
  002d4	8b 55 9c	 mov	 edx, DWORD PTR _y$17[ebp]
  002d7	3b 55 dc	 cmp	 edx, DWORD PTR _y_range$[ebp+8]
  002da	0f 8d 3a 01 00
	00		 jge	 $LN1@convert_yu

; 321  :         Tout *dstC = dstLine;

  002e0	8b 45 a0	 mov	 eax, DWORD PTR _dstLine$[ebp]
  002e3	89 45 98	 mov	 DWORD PTR _dstC$16[ebp], eax

; 322  :         Tin *srcU = srcULine;

  002e6	8b 4d a8	 mov	 ecx, DWORD PTR _srcULine$[ebp]
  002e9	89 4d 94	 mov	 DWORD PTR _srcU$15[ebp], ecx

; 323  :         Tin *srcV = srcVLine;

  002ec	8b 55 a4	 mov	 edx, DWORD PTR _srcVLine$[ebp]
  002ef	89 55 90	 mov	 DWORD PTR _srcV$14[ebp], edx

; 324  :         const int x_fin = width - crop_right - crop_left;

  002f2	8b 45 10	 mov	 eax, DWORD PTR _width$[ebp]
  002f5	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  002f8	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  002fb	89 45 8c	 mov	 DWORD PTR _x_fin$13[ebp], eax

; 325  :         for (int x = 0; x < x_fin; x += 2, dstC += 2, srcU += 2, srcV += 2) {

  002fe	c7 45 88 00 00
	00 00		 mov	 DWORD PTR _x$12[ebp], 0
  00305	eb 24		 jmp	 SHORT $LN13@convert_yu
$LN11@convert_yu:
  00307	8b 4d 88	 mov	 ecx, DWORD PTR _x$12[ebp]
  0030a	83 c1 02	 add	 ecx, 2
  0030d	89 4d 88	 mov	 DWORD PTR _x$12[ebp], ecx
  00310	8b 55 98	 mov	 edx, DWORD PTR _dstC$16[ebp]
  00313	83 c2 04	 add	 edx, 4
  00316	89 55 98	 mov	 DWORD PTR _dstC$16[ebp], edx
  00319	8b 45 94	 mov	 eax, DWORD PTR _srcU$15[ebp]
  0031c	83 c0 04	 add	 eax, 4
  0031f	89 45 94	 mov	 DWORD PTR _srcU$15[ebp], eax
  00322	8b 4d 90	 mov	 ecx, DWORD PTR _srcV$14[ebp]
  00325	83 c1 04	 add	 ecx, 4
  00328	89 4d 90	 mov	 DWORD PTR _srcV$14[ebp], ecx
$LN13@convert_yu:
  0032b	8b 55 88	 mov	 edx, DWORD PTR _x$12[ebp]
  0032e	3b 55 8c	 cmp	 edx, DWORD PTR _x_fin$13[ebp]
  00331	0f 8d de 00 00
	00		 jge	 $LN12@convert_yu

; 326  :             int cy0u = srcU[0*src_uv_pitch + 0];

  00337	6b 45 ac 00	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp], 0
  0033b	8b 4d 94	 mov	 ecx, DWORD PTR _srcU$15[ebp]
  0033e	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  00342	89 55 84	 mov	 DWORD PTR _cy0u$11[ebp], edx

; 327  :             int cy0v = srcV[0*src_uv_pitch + 0];

  00345	6b 45 ac 00	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp], 0
  00349	8b 4d 90	 mov	 ecx, DWORD PTR _srcV$14[ebp]
  0034c	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  00350	89 55 80	 mov	 DWORD PTR _cy0v$10[ebp], edx

; 328  :             int cy1u = srcU[1*src_uv_pitch + 0];

  00353	8b 45 ac	 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  00356	8b 4d 94	 mov	 ecx, DWORD PTR _srcU$15[ebp]
  00359	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  0035d	89 95 7c ff ff
	ff		 mov	 DWORD PTR _cy1u$9[ebp], edx

; 329  :             int cy1v = srcV[1*src_uv_pitch + 0];

  00363	8b 45 ac	 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  00366	8b 4d 90	 mov	 ecx, DWORD PTR _srcV$14[ebp]
  00369	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  0036d	89 95 78 ff ff
	ff		 mov	 DWORD PTR _cy1v$8[ebp], edx

; 330  : 
; 331  :             int cu = cy0u + cy1u + 1;

  00373	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _cy1u$9[ebp]
  00379	8b 4d 84	 mov	 ecx, DWORD PTR _cy0u$11[ebp]
  0037c	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  00380	89 95 74 ff ff
	ff		 mov	 DWORD PTR _cu$7[ebp], edx

; 332  :             int cv = cy0v + cy1v + 1;

  00386	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _cy1v$8[ebp]
  0038c	8b 4d 80	 mov	 ecx, DWORD PTR _cy0v$10[ebp]
  0038f	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  00393	89 95 70 ff ff
	ff		 mov	 DWORD PTR _cv$6[ebp], edx

; 333  :             CHANGE_BIT_DEPTH_2(cu, cv, 1);

  00399	b8 01 00 00 00	 mov	 eax, 1
  0039e	85 c0		 test	 eax, eax
  003a0	74 20		 je	 SHORT $LN21@convert_yu
  003a2	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _cu$7[ebp]
  003a8	c1 e1 06	 shl	 ecx, 6
  003ab	89 8d 74 ff ff
	ff		 mov	 DWORD PTR _cu$7[ebp], ecx
  003b1	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR _cv$6[ebp]
  003b7	c1 e2 06	 shl	 edx, 6
  003ba	89 95 70 ff ff
	ff		 mov	 DWORD PTR _cv$6[ebp], edx
  003c0	eb 22		 jmp	 SHORT $LN22@convert_yu
$LN21@convert_yu:
  003c2	33 c0		 xor	 eax, eax
  003c4	74 1e		 je	 SHORT $LN22@convert_yu
  003c6	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _cu$7[ebp]
  003cc	c1 f9 fa	 sar	 ecx, -6			; fffffffaH
  003cf	89 8d 74 ff ff
	ff		 mov	 DWORD PTR _cu$7[ebp], ecx
  003d5	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR _cv$6[ebp]
  003db	c1 fa fa	 sar	 edx, -6			; fffffffaH
  003de	89 95 70 ff ff
	ff		 mov	 DWORD PTR _cv$6[ebp], edx
$LN22@convert_yu:

; 334  : 
; 335  :             dstC[0] = (Tout)cu;

  003e4	b8 02 00 00 00	 mov	 eax, 2
  003e9	6b c8 00	 imul	 ecx, eax, 0
  003ec	8b 55 98	 mov	 edx, DWORD PTR _dstC$16[ebp]
  003ef	66 8b 85 74 ff
	ff ff		 mov	 ax, WORD PTR _cu$7[ebp]
  003f6	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax

; 336  :             dstC[1] = (Tout)cv;

  003fa	b9 02 00 00 00	 mov	 ecx, 2
  003ff	c1 e1 00	 shl	 ecx, 0
  00402	8b 55 98	 mov	 edx, DWORD PTR _dstC$16[ebp]
  00405	66 8b 85 70 ff
	ff ff		 mov	 ax, WORD PTR _cv$6[ebp]
  0040c	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax

; 337  :         }

  00410	e9 f2 fe ff ff	 jmp	 $LN11@convert_yu
$LN12@convert_yu:

; 338  :     }

  00415	e9 89 fe ff ff	 jmp	 $LN8@convert_yu
$LN1@convert_yu:

; 339  : }

  0041a	52		 push	 edx
  0041b	8b cd		 mov	 ecx, ebp
  0041d	50		 push	 eax
  0041e	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN27@convert_yu
  00424	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00429	58		 pop	 eax
  0042a	5a		 pop	 edx
  0042b	5f		 pop	 edi
  0042c	5e		 pop	 esi
  0042d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00430	33 cd		 xor	 ecx, ebp
  00432	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00437	81 c4 ac 00 00
	00		 add	 esp, 172		; 000000acH
  0043d	3b ec		 cmp	 ebp, esp
  0043f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00444	8b e5		 mov	 esp, ebp
  00446	5d		 pop	 ebp
  00447	c3		 ret	 0
$LN27@convert_yu:
  00448	01 00 00 00	 DD	 1
  0044c	00 00 00 00	 DD	 $LN26@convert_yu
$LN26@convert_yu:
  00450	d4 ff ff ff	 DD	 -44			; ffffffd4H
  00454	0c 00 00 00	 DD	 12			; 0000000cH
  00458	00 00 00 00	 DD	 $LN25@convert_yu
$LN25@convert_yu:
  0045c	79		 DB	 121			; 00000079H
  0045d	5f		 DB	 95			; 0000005fH
  0045e	72		 DB	 114			; 00000072H
  0045f	61		 DB	 97			; 00000061H
  00460	6e		 DB	 110			; 0000006eH
  00461	67		 DB	 103			; 00000067H
  00462	65		 DB	 101			; 00000065H
  00463	00		 DB	 0
??$convert_yuv444_to_nv12_p_c@G$08G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_to_nv12_p_c<unsigned short,9,unsigned short,16,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuv444_09_to_p010_p@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_09_to_p010_p

; 496  : static void convert_yuv444_09_to_p010_p(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 497  :     convert_yuv444_to_nv12_p_c<uint16_t, 9, uint16_t, 16, false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yuv444_to_nv12_p_c@G$08G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_to_nv12_p_c<unsigned short,9,unsigned short,16,0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 498  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yuv444_09_to_p010_p@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_09_to_p010_p
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
$T1 = -200						; size = 4
$T2 = -196						; size = 4
$T3 = -192						; size = 4
$T4 = -188						; size = 4
$T5 = -184						; size = 12
_cv_y1$6 = -172						; size = 4
_cv_y0$7 = -168						; size = 4
_cu_y1$8 = -164						; size = 4
_cu_y0$9 = -160						; size = 4
_cy3v$10 = -156						; size = 4
_cy3u$11 = -152						; size = 4
_cy2v$12 = -148						; size = 4
_cy2u$13 = -144						; size = 4
_cy1v$14 = -140						; size = 4
_cy1u$15 = -136						; size = 4
_cy0v$16 = -132						; size = 4
_cy0u$17 = -128						; size = 4
_x$18 = -124						; size = 4
_x_fin$19 = -120					; size = 4
_srcV$20 = -116						; size = 4
_srcU$21 = -112						; size = 4
_dstC$22 = -108						; size = 4
_y$23 = -104						; size = 4
_uv_fin$ = -100						; size = 4
_dstLine$ = -96						; size = 4
_srcVLine$ = -92					; size = 4
_srcULine$ = -88					; size = 4
_src_uv_pitch$ = -84					; size = 4
_x$24 = -80						; size = 4
_y$25 = -76						; size = 4
_y_width$26 = -72					; size = 4
_dstLine$27 = -68					; size = 4
_srcYLine$28 = -64					; size = 4
$T29 = -60						; size = 12
_y_range$ = -44						; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yuv444_to_nv12_i_c@G$09G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_to_nv12_i_c<unsigned short,10,unsigned short,16,0>

; 342  : static void __forceinline convert_yuv444_to_nv12_i_c(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8d bd 38 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-200]
  00011	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 343  :     static_assert((sizeof(Tin)  == 1 && in_bit_depth  == 8) || (sizeof(Tin)  == 2 && 8 < in_bit_depth  && in_bit_depth  <= 16), "invalid input bit depth.");
; 344  :     static_assert((sizeof(Tout) == 1 && out_bit_depth == 8) || (sizeof(Tout) == 2 && 8 < out_bit_depth && out_bit_depth <= 16), "invalid output bit depth.");
; 345  :     const int crop_left   = crop[0];

  00027	b8 04 00 00 00	 mov	 eax, 4
  0002c	6b c8 00	 imul	 ecx, eax, 0
  0002f	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00032	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00035	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 346  :     const int crop_up     = crop[1];

  00038	b9 04 00 00 00	 mov	 ecx, 4
  0003d	c1 e1 00	 shl	 ecx, 0
  00040	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00043	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00046	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 347  :     const int crop_right  = crop[2];

  00049	b9 04 00 00 00	 mov	 ecx, 4
  0004e	d1 e1		 shl	 ecx, 1
  00050	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00053	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00056	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 348  :     const int crop_bottom = crop[3];

  00059	b9 04 00 00 00	 mov	 ecx, 4
  0005e	6b d1 03	 imul	 edx, ecx, 3
  00061	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00064	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00067	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 349  :     const int src_y_pitch = src_y_pitch_byte / sizeof(Tin);

  0006a	8b 55 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebp]
  0006d	d1 ea		 shr	 edx, 1
  0006f	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 350  :     const int dst_y_pitch = dst_y_pitch_byte / sizeof(Tout);

  00072	8b 45 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  00075	d1 e8		 shr	 eax, 1
  00077	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 351  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  0007a	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0007d	51		 push	 ecx
  0007e	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  00081	52		 push	 edx
  00082	8b 45 20	 mov	 eax, DWORD PTR _height$[ebp]
  00085	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  00088	50		 push	 eax
  00089	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  0008c	51		 push	 ecx
  0008d	8d 95 48 ff ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  00093	52		 push	 edx
  00094	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00099	83 c4 14	 add	 esp, 20			; 00000014H
  0009c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009e	89 4d c4	 mov	 DWORD PTR $T29[ebp], ecx
  000a1	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a4	89 55 c8	 mov	 DWORD PTR $T29[ebp+4], edx
  000a7	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000aa	89 45 cc	 mov	 DWORD PTR $T29[ebp+8], eax
  000ad	8b 4d c4	 mov	 ecx, DWORD PTR $T29[ebp]
  000b0	89 4d d4	 mov	 DWORD PTR _y_range$[ebp], ecx
  000b3	8b 55 c8	 mov	 edx, DWORD PTR $T29[ebp+4]
  000b6	89 55 d8	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000b9	8b 45 cc	 mov	 eax, DWORD PTR $T29[ebp+8]
  000bc	89 45 dc	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 352  :     //Y
; 353  :     if (!uv_only) {

  000bf	b9 01 00 00 00	 mov	 ecx, 1
  000c4	85 c9		 test	 ecx, ecx
  000c6	0f 84 6e 01 00
	00		 je	 $LN14@convert_yu

; 354  :         Tin *srcYLine = (Tin *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000cc	ba 04 00 00 00	 mov	 edx, 4
  000d1	6b c2 00	 imul	 eax, edx, 0
  000d4	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  000d7	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  000db	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  000de	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  000e1	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  000e4	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  000e7	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  000ea	89 45 c0	 mov	 DWORD PTR _srcYLine$28[ebp], eax

; 355  :         Tout *dstLine = (Tout *)dst[0] + dst_y_pitch * y_range.start_dst;

  000ed	b9 04 00 00 00	 mov	 ecx, 4
  000f2	6b d1 00	 imul	 edx, ecx, 0
  000f5	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  000f8	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  000fc	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  000ff	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  00102	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  00105	89 45 bc	 mov	 DWORD PTR _dstLine$27[ebp], eax

; 356  :         const int y_width = width - crop_right - crop_left;

  00108	8b 4d 10	 mov	 ecx, DWORD PTR _width$[ebp]
  0010b	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  0010e	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  00111	89 4d b8	 mov	 DWORD PTR _y_width$26[ebp], ecx

; 357  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  00114	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _y$25[ebp], 0
  0011b	eb 21		 jmp	 SHORT $LN4@convert_yu
$LN2@convert_yu:
  0011d	8b 55 b4	 mov	 edx, DWORD PTR _y$25[ebp]
  00120	83 c2 01	 add	 edx, 1
  00123	89 55 b4	 mov	 DWORD PTR _y$25[ebp], edx
  00126	8b 45 e8	 mov	 eax, DWORD PTR _src_y_pitch$[ebp]
  00129	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$28[ebp]
  0012c	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  0012f	89 55 c0	 mov	 DWORD PTR _srcYLine$28[ebp], edx
  00132	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  00135	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$27[ebp]
  00138	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  0013b	89 55 bc	 mov	 DWORD PTR _dstLine$27[ebp], edx
$LN4@convert_yu:
  0013e	8b 45 b4	 mov	 eax, DWORD PTR _y$25[ebp]
  00141	3b 45 dc	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  00144	0f 8d f0 00 00
	00		 jge	 $LN14@convert_yu

; 358  :             if (in_bit_depth == out_bit_depth && sizeof(Tin) == sizeof(Tout)) {

  0014a	33 c9		 xor	 ecx, ecx
  0014c	74 1b		 je	 SHORT $LN15@convert_yu

; 359  :                 memcpy(dstLine, srcYLine, y_width * sizeof(Tin));

  0014e	8b 55 b8	 mov	 edx, DWORD PTR _y_width$26[ebp]
  00151	d1 e2		 shl	 edx, 1
  00153	52		 push	 edx
  00154	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$28[ebp]
  00157	50		 push	 eax
  00158	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$27[ebp]
  0015b	51		 push	 ecx
  0015c	e8 00 00 00 00	 call	 _memcpy
  00161	83 c4 0c	 add	 esp, 12			; 0000000cH

; 360  :             } else {

  00164	e9 cc 00 00 00	 jmp	 $LN16@convert_yu
$LN15@convert_yu:

; 361  :                 for (int x = 0; x < y_width; x++) {

  00169	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _x$24[ebp], 0
  00170	eb 09		 jmp	 SHORT $LN7@convert_yu
$LN5@convert_yu:
  00172	8b 55 b0	 mov	 edx, DWORD PTR _x$24[ebp]
  00175	83 c2 01	 add	 edx, 1
  00178	89 55 b0	 mov	 DWORD PTR _x$24[ebp], edx
$LN7@convert_yu:
  0017b	8b 45 b0	 mov	 eax, DWORD PTR _x$24[ebp]
  0017e	3b 45 b8	 cmp	 eax, DWORD PTR _y_width$26[ebp]
  00181	0f 8d ae 00 00
	00		 jge	 $LN16@convert_yu

; 362  :                     if (out_bit_depth > in_bit_depth) {

  00187	b9 01 00 00 00	 mov	 ecx, 1
  0018c	85 c9		 test	 ecx, ecx
  0018e	74 44		 je	 SHORT $LN17@convert_yu

; 363  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) << std::max(out_bit_depth - in_bit_depth, 0));

  00190	c7 85 44 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], 0
  0019a	c7 85 40 ff ff
	ff 06 00 00 00	 mov	 DWORD PTR $T3[ebp], 6
  001a4	8b 55 b0	 mov	 edx, DWORD PTR _x$24[ebp]
  001a7	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$28[ebp]
  001aa	0f b7 34 50	 movzx	 esi, WORD PTR [eax+edx*2]
  001ae	8d 8d 44 ff ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  001b4	51		 push	 ecx
  001b5	8d 95 40 ff ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  001bb	52		 push	 edx
  001bc	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  001c1	83 c4 08	 add	 esp, 8
  001c4	8b 08		 mov	 ecx, DWORD PTR [eax]
  001c6	d3 e6		 shl	 esi, cl
  001c8	8b 45 b0	 mov	 eax, DWORD PTR _x$24[ebp]
  001cb	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$27[ebp]
  001ce	66 89 34 41	 mov	 WORD PTR [ecx+eax*2], si
  001d2	eb 5c		 jmp	 SHORT $LN18@convert_yu
$LN17@convert_yu:

; 364  :                     } else if (out_bit_depth < in_bit_depth) {

  001d4	33 d2		 xor	 edx, edx
  001d6	74 44		 je	 SHORT $LN19@convert_yu

; 365  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) >> std::max(in_bit_depth - out_bit_depth, 0));

  001d8	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], 0
  001e2	c7 85 38 ff ff
	ff fa ff ff ff	 mov	 DWORD PTR $T1[ebp], -6	; fffffffaH
  001ec	8b 45 b0	 mov	 eax, DWORD PTR _x$24[ebp]
  001ef	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$28[ebp]
  001f2	0f b7 34 41	 movzx	 esi, WORD PTR [ecx+eax*2]
  001f6	8d 95 3c ff ff
	ff		 lea	 edx, DWORD PTR $T2[ebp]
  001fc	52		 push	 edx
  001fd	8d 85 38 ff ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  00203	50		 push	 eax
  00204	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  00209	83 c4 08	 add	 esp, 8
  0020c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0020e	d3 fe		 sar	 esi, cl
  00210	8b 4d b0	 mov	 ecx, DWORD PTR _x$24[ebp]
  00213	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$27[ebp]
  00216	66 89 34 4a	 mov	 WORD PTR [edx+ecx*2], si

; 366  :                     } else {

  0021a	eb 14		 jmp	 SHORT $LN18@convert_yu
$LN19@convert_yu:

; 367  :                         dstLine[x] = (Tout)srcYLine[x];

  0021c	8b 45 b0	 mov	 eax, DWORD PTR _x$24[ebp]
  0021f	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$27[ebp]
  00222	8b 55 b0	 mov	 edx, DWORD PTR _x$24[ebp]
  00225	8b 75 c0	 mov	 esi, DWORD PTR _srcYLine$28[ebp]
  00228	66 8b 14 56	 mov	 dx, WORD PTR [esi+edx*2]
  0022c	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx
$LN18@convert_yu:

; 368  :                     }
; 369  :                 }

  00230	e9 3d ff ff ff	 jmp	 $LN5@convert_yu
$LN16@convert_yu:

; 370  :             }
; 371  :         }

  00235	e9 e3 fe ff ff	 jmp	 $LN2@convert_yu
$LN14@convert_yu:

; 372  :     }
; 373  :     //UV
; 374  :     const int src_uv_pitch = src_uv_pitch_byte / sizeof(Tin);

  0023a	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0023d	d1 e8		 shr	 eax, 1
  0023f	89 45 ac	 mov	 DWORD PTR _src_uv_pitch$[ebp], eax

; 375  :     Tin *srcULine = (Tin *)src[1] + ((src_uv_pitch * y_range.start_src) + crop_left);

  00242	b9 04 00 00 00	 mov	 ecx, 4
  00247	c1 e1 00	 shl	 ecx, 0
  0024a	8b 55 ac	 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  0024d	0f af 55 d4	 imul	 edx, DWORD PTR _y_range$[ebp]
  00251	03 55 f8	 add	 edx, DWORD PTR _crop_left$[ebp]
  00254	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  00257	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  0025a	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  0025d	89 55 a8	 mov	 DWORD PTR _srcULine$[ebp], edx

; 376  :     Tin *srcVLine = (Tin *)src[2] + ((src_uv_pitch * y_range.start_src) + crop_left);

  00260	b8 04 00 00 00	 mov	 eax, 4
  00265	d1 e0		 shl	 eax, 1
  00267	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  0026a	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  0026e	03 4d f8	 add	 ecx, DWORD PTR _crop_left$[ebp]
  00271	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  00274	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  00277	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  0027a	89 4d a4	 mov	 DWORD PTR _srcVLine$[ebp], ecx

; 377  :     Tout *dstLine = (Tout *)dst[1] + (dst_y_pitch >> 1) * y_range.start_dst;

  0027d	ba 04 00 00 00	 mov	 edx, 4
  00282	c1 e2 00	 shl	 edx, 0
  00285	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  00288	d1 f8		 sar	 eax, 1
  0028a	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  0028e	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  00291	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  00294	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  00297	89 45 a0	 mov	 DWORD PTR _dstLine$[ebp], eax

; 378  :     const int uv_fin = height - crop_bottom - crop_up;

  0029a	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  0029d	2b 4d ec	 sub	 ecx, DWORD PTR _crop_bottom$[ebp]
  002a0	2b 4d f4	 sub	 ecx, DWORD PTR _crop_up$[ebp]
  002a3	89 4d 9c	 mov	 DWORD PTR _uv_fin$[ebp], ecx

; 379  :     for (int y = 0; y < y_range.len; y += 4, srcULine += src_uv_pitch * 4, srcVLine += src_uv_pitch * 4, dstLine += dst_y_pitch * 2) {

  002a6	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _y$23[ebp], 0
  002ad	eb 35		 jmp	 SHORT $LN10@convert_yu
$LN8@convert_yu:
  002af	8b 55 98	 mov	 edx, DWORD PTR _y$23[ebp]
  002b2	83 c2 04	 add	 edx, 4
  002b5	89 55 98	 mov	 DWORD PTR _y$23[ebp], edx
  002b8	8b 45 ac	 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  002bb	c1 e0 02	 shl	 eax, 2
  002be	8b 4d a8	 mov	 ecx, DWORD PTR _srcULine$[ebp]
  002c1	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  002c4	89 55 a8	 mov	 DWORD PTR _srcULine$[ebp], edx
  002c7	8b 45 ac	 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  002ca	c1 e0 02	 shl	 eax, 2
  002cd	8b 4d a4	 mov	 ecx, DWORD PTR _srcVLine$[ebp]
  002d0	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  002d3	89 55 a4	 mov	 DWORD PTR _srcVLine$[ebp], edx
  002d6	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  002d9	d1 e0		 shl	 eax, 1
  002db	8b 4d a0	 mov	 ecx, DWORD PTR _dstLine$[ebp]
  002de	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  002e1	89 55 a0	 mov	 DWORD PTR _dstLine$[ebp], edx
$LN10@convert_yu:
  002e4	8b 45 98	 mov	 eax, DWORD PTR _y$23[ebp]
  002e7	3b 45 dc	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  002ea	0f 8d 0e 02 00
	00		 jge	 $LN1@convert_yu

; 380  :         Tout *dstC = dstLine;

  002f0	8b 4d a0	 mov	 ecx, DWORD PTR _dstLine$[ebp]
  002f3	89 4d 94	 mov	 DWORD PTR _dstC$22[ebp], ecx

; 381  :         Tin *srcU = srcULine;

  002f6	8b 55 a8	 mov	 edx, DWORD PTR _srcULine$[ebp]
  002f9	89 55 90	 mov	 DWORD PTR _srcU$21[ebp], edx

; 382  :         Tin *srcV = srcVLine;

  002fc	8b 45 a4	 mov	 eax, DWORD PTR _srcVLine$[ebp]
  002ff	89 45 8c	 mov	 DWORD PTR _srcV$20[ebp], eax

; 383  :         const int x_fin = width - crop_right - crop_left;

  00302	8b 4d 10	 mov	 ecx, DWORD PTR _width$[ebp]
  00305	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  00308	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  0030b	89 4d 88	 mov	 DWORD PTR _x_fin$19[ebp], ecx

; 384  :         for (int x = 0; x < x_fin; x += 2, dstC += 2, srcU += 2, srcV += 2) {

  0030e	c7 45 84 00 00
	00 00		 mov	 DWORD PTR _x$18[ebp], 0
  00315	eb 24		 jmp	 SHORT $LN13@convert_yu
$LN11@convert_yu:
  00317	8b 55 84	 mov	 edx, DWORD PTR _x$18[ebp]
  0031a	83 c2 02	 add	 edx, 2
  0031d	89 55 84	 mov	 DWORD PTR _x$18[ebp], edx
  00320	8b 45 94	 mov	 eax, DWORD PTR _dstC$22[ebp]
  00323	83 c0 04	 add	 eax, 4
  00326	89 45 94	 mov	 DWORD PTR _dstC$22[ebp], eax
  00329	8b 4d 90	 mov	 ecx, DWORD PTR _srcU$21[ebp]
  0032c	83 c1 04	 add	 ecx, 4
  0032f	89 4d 90	 mov	 DWORD PTR _srcU$21[ebp], ecx
  00332	8b 55 8c	 mov	 edx, DWORD PTR _srcV$20[ebp]
  00335	83 c2 04	 add	 edx, 4
  00338	89 55 8c	 mov	 DWORD PTR _srcV$20[ebp], edx
$LN13@convert_yu:
  0033b	8b 45 84	 mov	 eax, DWORD PTR _x$18[ebp]
  0033e	3b 45 88	 cmp	 eax, DWORD PTR _x_fin$19[ebp]
  00341	0f 8d b2 01 00
	00		 jge	 $LN12@convert_yu

; 385  :             int cy0u = srcU[0*src_uv_pitch + 0];

  00347	6b 4d ac 00	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 0
  0034b	8b 55 90	 mov	 edx, DWORD PTR _srcU$21[ebp]
  0034e	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00352	89 45 80	 mov	 DWORD PTR _cy0u$17[ebp], eax

; 386  :             int cy0v = srcV[0*src_uv_pitch + 0];

  00355	6b 4d ac 00	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 0
  00359	8b 55 8c	 mov	 edx, DWORD PTR _srcV$20[ebp]
  0035c	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00360	89 85 7c ff ff
	ff		 mov	 DWORD PTR _cy0v$16[ebp], eax

; 387  :             int cy1u = srcU[1*src_uv_pitch + 0];

  00366	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00369	8b 55 90	 mov	 edx, DWORD PTR _srcU$21[ebp]
  0036c	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00370	89 85 78 ff ff
	ff		 mov	 DWORD PTR _cy1u$15[ebp], eax

; 388  :             int cy1v = srcV[1*src_uv_pitch + 0];

  00376	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00379	8b 55 8c	 mov	 edx, DWORD PTR _srcV$20[ebp]
  0037c	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00380	89 85 74 ff ff
	ff		 mov	 DWORD PTR _cy1v$14[ebp], eax

; 389  :             int cy2u = srcU[2*src_uv_pitch + 0];

  00386	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00389	d1 e1		 shl	 ecx, 1
  0038b	8b 55 90	 mov	 edx, DWORD PTR _srcU$21[ebp]
  0038e	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00392	89 85 70 ff ff
	ff		 mov	 DWORD PTR _cy2u$13[ebp], eax

; 390  :             int cy2v = srcV[2*src_uv_pitch + 0];

  00398	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  0039b	d1 e1		 shl	 ecx, 1
  0039d	8b 55 8c	 mov	 edx, DWORD PTR _srcV$20[ebp]
  003a0	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  003a4	89 85 6c ff ff
	ff		 mov	 DWORD PTR _cy2v$12[ebp], eax

; 391  :             int cy3u = srcU[3*src_uv_pitch + 0];

  003aa	6b 4d ac 03	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 3
  003ae	8b 55 90	 mov	 edx, DWORD PTR _srcU$21[ebp]
  003b1	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  003b5	89 85 68 ff ff
	ff		 mov	 DWORD PTR _cy3u$11[ebp], eax

; 392  :             int cy3v = srcV[3*src_uv_pitch + 0];

  003bb	6b 4d ac 03	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 3
  003bf	8b 55 8c	 mov	 edx, DWORD PTR _srcV$20[ebp]
  003c2	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  003c6	89 85 64 ff ff
	ff		 mov	 DWORD PTR _cy3v$10[ebp], eax

; 393  : 
; 394  :             int cu_y0 = cy0u * 3 + cy2u * 1 + 2;

  003cc	6b 4d 80 03	 imul	 ecx, DWORD PTR _cy0u$17[ebp], 3
  003d0	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR _cy2u$13[ebp]
  003d6	8d 44 11 02	 lea	 eax, DWORD PTR [ecx+edx+2]
  003da	89 85 60 ff ff
	ff		 mov	 DWORD PTR _cu_y0$9[ebp], eax

; 395  :             int cu_y1 = cy1u * 1 + cy3u * 3 + 2;

  003e0	6b 8d 68 ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy3u$11[ebp], 3
  003e7	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _cy1u$15[ebp]
  003ed	8d 44 0a 02	 lea	 eax, DWORD PTR [edx+ecx+2]
  003f1	89 85 5c ff ff
	ff		 mov	 DWORD PTR _cu_y1$8[ebp], eax

; 396  :             int cv_y0 = cy0v * 3 + cy2v * 1 + 2;

  003f7	6b 8d 7c ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy0v$16[ebp], 3
  003fe	8b 95 6c ff ff
	ff		 mov	 edx, DWORD PTR _cy2v$12[ebp]
  00404	8d 44 11 02	 lea	 eax, DWORD PTR [ecx+edx+2]
  00408	89 85 58 ff ff
	ff		 mov	 DWORD PTR _cv_y0$7[ebp], eax

; 397  :             int cv_y1 = cy1v * 1 + cy3v * 3 + 2;

  0040e	6b 8d 64 ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy3v$10[ebp], 3
  00415	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _cy1v$14[ebp]
  0041b	8d 44 0a 02	 lea	 eax, DWORD PTR [edx+ecx+2]
  0041f	89 85 54 ff ff
	ff		 mov	 DWORD PTR _cv_y1$6[ebp], eax

; 398  :             CHANGE_BIT_DEPTH_4(cu_y0, cu_y1, cv_y0, cv_y1, 2);

  00425	b9 01 00 00 00	 mov	 ecx, 1
  0042a	85 c9		 test	 ecx, ecx
  0042c	74 3e		 je	 SHORT $LN21@convert_yu
  0042e	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _cu_y0$9[ebp]
  00434	c1 e2 04	 shl	 edx, 4
  00437	89 95 60 ff ff
	ff		 mov	 DWORD PTR _cu_y0$9[ebp], edx
  0043d	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _cu_y1$8[ebp]
  00443	c1 e0 04	 shl	 eax, 4
  00446	89 85 5c ff ff
	ff		 mov	 DWORD PTR _cu_y1$8[ebp], eax
  0044c	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _cv_y0$7[ebp]
  00452	c1 e1 04	 shl	 ecx, 4
  00455	89 8d 58 ff ff
	ff		 mov	 DWORD PTR _cv_y0$7[ebp], ecx
  0045b	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR _cv_y1$6[ebp]
  00461	c1 e2 04	 shl	 edx, 4
  00464	89 95 54 ff ff
	ff		 mov	 DWORD PTR _cv_y1$6[ebp], edx
  0046a	eb 40		 jmp	 SHORT $LN22@convert_yu
$LN21@convert_yu:
  0046c	33 c0		 xor	 eax, eax
  0046e	74 3c		 je	 SHORT $LN22@convert_yu
  00470	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _cu_y0$9[ebp]
  00476	c1 f9 fc	 sar	 ecx, -4			; fffffffcH
  00479	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _cu_y0$9[ebp], ecx
  0047f	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR _cu_y1$8[ebp]
  00485	c1 fa fc	 sar	 edx, -4			; fffffffcH
  00488	89 95 5c ff ff
	ff		 mov	 DWORD PTR _cu_y1$8[ebp], edx
  0048e	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _cv_y0$7[ebp]
  00494	c1 f8 fc	 sar	 eax, -4			; fffffffcH
  00497	89 85 58 ff ff
	ff		 mov	 DWORD PTR _cv_y0$7[ebp], eax
  0049d	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _cv_y1$6[ebp]
  004a3	c1 f9 fc	 sar	 ecx, -4			; fffffffcH
  004a6	89 8d 54 ff ff
	ff		 mov	 DWORD PTR _cv_y1$6[ebp], ecx
$LN22@convert_yu:

; 399  : 
; 400  :             dstC[0*dst_y_pitch + 0] = (Tout)cu_y0;

  004ac	6b 55 e4 00	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 0
  004b0	8b 45 94	 mov	 eax, DWORD PTR _dstC$22[ebp]
  004b3	66 8b 8d 60 ff
	ff ff		 mov	 cx, WORD PTR _cu_y0$9[ebp]
  004ba	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx

; 401  :             dstC[0*dst_y_pitch + 1] = (Tout)cv_y0;

  004be	6b 55 e4 00	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 0
  004c2	8b 45 94	 mov	 eax, DWORD PTR _dstC$22[ebp]
  004c5	66 8b 8d 58 ff
	ff ff		 mov	 cx, WORD PTR _cv_y0$7[ebp]
  004cc	66 89 4c 50 02	 mov	 WORD PTR [eax+edx*2+2], cx

; 402  :             dstC[1*dst_y_pitch + 0] = (Tout)cu_y1;

  004d1	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  004d4	8b 45 94	 mov	 eax, DWORD PTR _dstC$22[ebp]
  004d7	66 8b 8d 5c ff
	ff ff		 mov	 cx, WORD PTR _cu_y1$8[ebp]
  004de	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx

; 403  :             dstC[1*dst_y_pitch + 1] = (Tout)cv_y1;

  004e2	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  004e5	8b 45 94	 mov	 eax, DWORD PTR _dstC$22[ebp]
  004e8	66 8b 8d 54 ff
	ff ff		 mov	 cx, WORD PTR _cv_y1$6[ebp]
  004ef	66 89 4c 50 02	 mov	 WORD PTR [eax+edx*2+2], cx

; 404  :         }

  004f4	e9 1e fe ff ff	 jmp	 $LN11@convert_yu
$LN12@convert_yu:

; 405  :     }

  004f9	e9 b1 fd ff ff	 jmp	 $LN8@convert_yu
$LN1@convert_yu:

; 406  : }

  004fe	52		 push	 edx
  004ff	8b cd		 mov	 ecx, ebp
  00501	50		 push	 eax
  00502	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN27@convert_yu
  00508	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0050d	58		 pop	 eax
  0050e	5a		 pop	 edx
  0050f	5f		 pop	 edi
  00510	5e		 pop	 esi
  00511	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00514	33 cd		 xor	 ecx, ebp
  00516	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0051b	81 c4 c8 00 00
	00		 add	 esp, 200		; 000000c8H
  00521	3b ec		 cmp	 ebp, esp
  00523	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00528	8b e5		 mov	 esp, ebp
  0052a	5d		 pop	 ebp
  0052b	c3		 ret	 0
$LN27@convert_yu:
  0052c	01 00 00 00	 DD	 1
  00530	00 00 00 00	 DD	 $LN26@convert_yu
$LN26@convert_yu:
  00534	d4 ff ff ff	 DD	 -44			; ffffffd4H
  00538	0c 00 00 00	 DD	 12			; 0000000cH
  0053c	00 00 00 00	 DD	 $LN25@convert_yu
$LN25@convert_yu:
  00540	79		 DB	 121			; 00000079H
  00541	5f		 DB	 95			; 0000005fH
  00542	72		 DB	 114			; 00000072H
  00543	61		 DB	 97			; 00000061H
  00544	6e		 DB	 110			; 0000006eH
  00545	67		 DB	 103			; 00000067H
  00546	65		 DB	 101			; 00000065H
  00547	00		 DB	 0
??$convert_yuv444_to_nv12_i_c@G$09G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_to_nv12_i_c<unsigned short,10,unsigned short,16,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuv444_10_to_p010_i@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_10_to_p010_i

; 492  : static void convert_yuv444_10_to_p010_i(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 493  :     convert_yuv444_to_nv12_i_c<uint16_t, 10, uint16_t, 16, false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yuv444_to_nv12_i_c@G$09G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_to_nv12_i_c<unsigned short,10,unsigned short,16,0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 494  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yuv444_10_to_p010_i@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_10_to_p010_i
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
$T1 = -172						; size = 4
$T2 = -168						; size = 4
$T3 = -164						; size = 4
$T4 = -160						; size = 4
$T5 = -156						; size = 12
_cv$6 = -144						; size = 4
_cu$7 = -140						; size = 4
_cy1v$8 = -136						; size = 4
_cy1u$9 = -132						; size = 4
_cy0v$10 = -128						; size = 4
_cy0u$11 = -124						; size = 4
_x$12 = -120						; size = 4
_x_fin$13 = -116					; size = 4
_srcV$14 = -112						; size = 4
_srcU$15 = -108						; size = 4
_dstC$16 = -104						; size = 4
_y$17 = -100						; size = 4
_dstLine$ = -96						; size = 4
_srcVLine$ = -92					; size = 4
_srcULine$ = -88					; size = 4
_src_uv_pitch$ = -84					; size = 4
_x$18 = -80						; size = 4
_y$19 = -76						; size = 4
_y_width$20 = -72					; size = 4
_dstLine$21 = -68					; size = 4
_srcYLine$22 = -64					; size = 4
$T23 = -60						; size = 12
_y_range$ = -44						; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yuv444_to_nv12_p_c@G$09G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_to_nv12_p_c<unsigned short,10,unsigned short,16,0>

; 284  : static void __forceinline convert_yuv444_to_nv12_p_c(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec ac 00 00
	00		 sub	 esp, 172		; 000000acH
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8d bd 54 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-172]
  00011	b9 2b 00 00 00	 mov	 ecx, 43			; 0000002bH
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 285  :     static_assert((sizeof(Tin)  == 1 && in_bit_depth  == 8) || (sizeof(Tin)  == 2 && 8 < in_bit_depth  && in_bit_depth  <= 16), "invalid input bit depth.");
; 286  :     static_assert((sizeof(Tout) == 1 && out_bit_depth == 8) || (sizeof(Tout) == 2 && 8 < out_bit_depth && out_bit_depth <= 16), "invalid output bit depth.");
; 287  :     const int crop_left   = crop[0];

  00027	b8 04 00 00 00	 mov	 eax, 4
  0002c	6b c8 00	 imul	 ecx, eax, 0
  0002f	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00032	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00035	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 288  :     const int crop_up     = crop[1];

  00038	b9 04 00 00 00	 mov	 ecx, 4
  0003d	c1 e1 00	 shl	 ecx, 0
  00040	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00043	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00046	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 289  :     const int crop_right  = crop[2];

  00049	b9 04 00 00 00	 mov	 ecx, 4
  0004e	d1 e1		 shl	 ecx, 1
  00050	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00053	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00056	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 290  :     const int crop_bottom = crop[3];

  00059	b9 04 00 00 00	 mov	 ecx, 4
  0005e	6b d1 03	 imul	 edx, ecx, 3
  00061	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00064	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00067	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 291  :     const int src_y_pitch = src_y_pitch_byte / sizeof(Tin);

  0006a	8b 55 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebp]
  0006d	d1 ea		 shr	 edx, 1
  0006f	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 292  :     const int dst_y_pitch = dst_y_pitch_byte / sizeof(Tout);

  00072	8b 45 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  00075	d1 e8		 shr	 eax, 1
  00077	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 293  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  0007a	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0007d	51		 push	 ecx
  0007e	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  00081	52		 push	 edx
  00082	8b 45 20	 mov	 eax, DWORD PTR _height$[ebp]
  00085	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  00088	50		 push	 eax
  00089	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  0008c	51		 push	 ecx
  0008d	8d 95 64 ff ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  00093	52		 push	 edx
  00094	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00099	83 c4 14	 add	 esp, 20			; 00000014H
  0009c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009e	89 4d c4	 mov	 DWORD PTR $T23[ebp], ecx
  000a1	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a4	89 55 c8	 mov	 DWORD PTR $T23[ebp+4], edx
  000a7	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000aa	89 45 cc	 mov	 DWORD PTR $T23[ebp+8], eax
  000ad	8b 4d c4	 mov	 ecx, DWORD PTR $T23[ebp]
  000b0	89 4d d4	 mov	 DWORD PTR _y_range$[ebp], ecx
  000b3	8b 55 c8	 mov	 edx, DWORD PTR $T23[ebp+4]
  000b6	89 55 d8	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000b9	8b 45 cc	 mov	 eax, DWORD PTR $T23[ebp+8]
  000bc	89 45 dc	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 294  :     //Y
; 295  :     if (!uv_only) {

  000bf	b9 01 00 00 00	 mov	 ecx, 1
  000c4	85 c9		 test	 ecx, ecx
  000c6	0f 84 6e 01 00
	00		 je	 $LN14@convert_yu

; 296  :         Tin *srcYLine = (Tin *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000cc	ba 04 00 00 00	 mov	 edx, 4
  000d1	6b c2 00	 imul	 eax, edx, 0
  000d4	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  000d7	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  000db	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  000de	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  000e1	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  000e4	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  000e7	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  000ea	89 45 c0	 mov	 DWORD PTR _srcYLine$22[ebp], eax

; 297  :         Tout *dstLine = (Tout *)dst[0] + dst_y_pitch * y_range.start_dst;

  000ed	b9 04 00 00 00	 mov	 ecx, 4
  000f2	6b d1 00	 imul	 edx, ecx, 0
  000f5	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  000f8	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  000fc	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  000ff	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  00102	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  00105	89 45 bc	 mov	 DWORD PTR _dstLine$21[ebp], eax

; 298  :         const int y_width = width - crop_right - crop_left;

  00108	8b 4d 10	 mov	 ecx, DWORD PTR _width$[ebp]
  0010b	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  0010e	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  00111	89 4d b8	 mov	 DWORD PTR _y_width$20[ebp], ecx

; 299  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  00114	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _y$19[ebp], 0
  0011b	eb 21		 jmp	 SHORT $LN4@convert_yu
$LN2@convert_yu:
  0011d	8b 55 b4	 mov	 edx, DWORD PTR _y$19[ebp]
  00120	83 c2 01	 add	 edx, 1
  00123	89 55 b4	 mov	 DWORD PTR _y$19[ebp], edx
  00126	8b 45 e8	 mov	 eax, DWORD PTR _src_y_pitch$[ebp]
  00129	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$22[ebp]
  0012c	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  0012f	89 55 c0	 mov	 DWORD PTR _srcYLine$22[ebp], edx
  00132	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  00135	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$21[ebp]
  00138	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  0013b	89 55 bc	 mov	 DWORD PTR _dstLine$21[ebp], edx
$LN4@convert_yu:
  0013e	8b 45 b4	 mov	 eax, DWORD PTR _y$19[ebp]
  00141	3b 45 dc	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  00144	0f 8d f0 00 00
	00		 jge	 $LN14@convert_yu

; 300  :             if (in_bit_depth == out_bit_depth && sizeof(Tin) == sizeof(Tout)) {

  0014a	33 c9		 xor	 ecx, ecx
  0014c	74 1b		 je	 SHORT $LN15@convert_yu

; 301  :                 memcpy(dstLine, srcYLine, y_width * sizeof(Tin));

  0014e	8b 55 b8	 mov	 edx, DWORD PTR _y_width$20[ebp]
  00151	d1 e2		 shl	 edx, 1
  00153	52		 push	 edx
  00154	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$22[ebp]
  00157	50		 push	 eax
  00158	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$21[ebp]
  0015b	51		 push	 ecx
  0015c	e8 00 00 00 00	 call	 _memcpy
  00161	83 c4 0c	 add	 esp, 12			; 0000000cH

; 302  :             } else {

  00164	e9 cc 00 00 00	 jmp	 $LN16@convert_yu
$LN15@convert_yu:

; 303  :                 for (int x = 0; x < y_width; x++) {

  00169	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _x$18[ebp], 0
  00170	eb 09		 jmp	 SHORT $LN7@convert_yu
$LN5@convert_yu:
  00172	8b 55 b0	 mov	 edx, DWORD PTR _x$18[ebp]
  00175	83 c2 01	 add	 edx, 1
  00178	89 55 b0	 mov	 DWORD PTR _x$18[ebp], edx
$LN7@convert_yu:
  0017b	8b 45 b0	 mov	 eax, DWORD PTR _x$18[ebp]
  0017e	3b 45 b8	 cmp	 eax, DWORD PTR _y_width$20[ebp]
  00181	0f 8d ae 00 00
	00		 jge	 $LN16@convert_yu

; 304  :                     if (out_bit_depth > in_bit_depth) {

  00187	b9 01 00 00 00	 mov	 ecx, 1
  0018c	85 c9		 test	 ecx, ecx
  0018e	74 44		 je	 SHORT $LN17@convert_yu

; 305  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) << std::max(out_bit_depth - in_bit_depth, 0));

  00190	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], 0
  0019a	c7 85 5c ff ff
	ff 06 00 00 00	 mov	 DWORD PTR $T3[ebp], 6
  001a4	8b 55 b0	 mov	 edx, DWORD PTR _x$18[ebp]
  001a7	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$22[ebp]
  001aa	0f b7 34 50	 movzx	 esi, WORD PTR [eax+edx*2]
  001ae	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  001b4	51		 push	 ecx
  001b5	8d 95 5c ff ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  001bb	52		 push	 edx
  001bc	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  001c1	83 c4 08	 add	 esp, 8
  001c4	8b 08		 mov	 ecx, DWORD PTR [eax]
  001c6	d3 e6		 shl	 esi, cl
  001c8	8b 45 b0	 mov	 eax, DWORD PTR _x$18[ebp]
  001cb	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$21[ebp]
  001ce	66 89 34 41	 mov	 WORD PTR [ecx+eax*2], si
  001d2	eb 5c		 jmp	 SHORT $LN18@convert_yu
$LN17@convert_yu:

; 306  :                     } else if (out_bit_depth < in_bit_depth) {

  001d4	33 d2		 xor	 edx, edx
  001d6	74 44		 je	 SHORT $LN19@convert_yu

; 307  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) >> std::max(in_bit_depth - out_bit_depth, 0));

  001d8	c7 85 58 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], 0
  001e2	c7 85 54 ff ff
	ff fa ff ff ff	 mov	 DWORD PTR $T1[ebp], -6	; fffffffaH
  001ec	8b 45 b0	 mov	 eax, DWORD PTR _x$18[ebp]
  001ef	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$22[ebp]
  001f2	0f b7 34 41	 movzx	 esi, WORD PTR [ecx+eax*2]
  001f6	8d 95 58 ff ff
	ff		 lea	 edx, DWORD PTR $T2[ebp]
  001fc	52		 push	 edx
  001fd	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  00203	50		 push	 eax
  00204	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  00209	83 c4 08	 add	 esp, 8
  0020c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0020e	d3 fe		 sar	 esi, cl
  00210	8b 4d b0	 mov	 ecx, DWORD PTR _x$18[ebp]
  00213	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$21[ebp]
  00216	66 89 34 4a	 mov	 WORD PTR [edx+ecx*2], si

; 308  :                     } else {

  0021a	eb 14		 jmp	 SHORT $LN18@convert_yu
$LN19@convert_yu:

; 309  :                         dstLine[x] = (Tout)srcYLine[x];

  0021c	8b 45 b0	 mov	 eax, DWORD PTR _x$18[ebp]
  0021f	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$21[ebp]
  00222	8b 55 b0	 mov	 edx, DWORD PTR _x$18[ebp]
  00225	8b 75 c0	 mov	 esi, DWORD PTR _srcYLine$22[ebp]
  00228	66 8b 14 56	 mov	 dx, WORD PTR [esi+edx*2]
  0022c	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx
$LN18@convert_yu:

; 310  :                     }
; 311  :                 }

  00230	e9 3d ff ff ff	 jmp	 $LN5@convert_yu
$LN16@convert_yu:

; 312  :             }
; 313  :         }

  00235	e9 e3 fe ff ff	 jmp	 $LN2@convert_yu
$LN14@convert_yu:

; 314  :     }
; 315  :     //UV
; 316  :     const int src_uv_pitch = src_uv_pitch_byte / sizeof(Tin);

  0023a	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0023d	d1 e8		 shr	 eax, 1
  0023f	89 45 ac	 mov	 DWORD PTR _src_uv_pitch$[ebp], eax

; 317  :     Tin *srcULine = (Tin *)src[1] + ((src_uv_pitch * y_range.start_src) + crop_left);

  00242	b9 04 00 00 00	 mov	 ecx, 4
  00247	c1 e1 00	 shl	 ecx, 0
  0024a	8b 55 ac	 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  0024d	0f af 55 d4	 imul	 edx, DWORD PTR _y_range$[ebp]
  00251	03 55 f8	 add	 edx, DWORD PTR _crop_left$[ebp]
  00254	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  00257	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  0025a	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  0025d	89 55 a8	 mov	 DWORD PTR _srcULine$[ebp], edx

; 318  :     Tin *srcVLine = (Tin *)src[2] + ((src_uv_pitch * y_range.start_src) + crop_left);

  00260	b8 04 00 00 00	 mov	 eax, 4
  00265	d1 e0		 shl	 eax, 1
  00267	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  0026a	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  0026e	03 4d f8	 add	 ecx, DWORD PTR _crop_left$[ebp]
  00271	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  00274	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  00277	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  0027a	89 4d a4	 mov	 DWORD PTR _srcVLine$[ebp], ecx

; 319  :     Tout *dstLine = (Tout *)dst[1] + (dst_y_pitch >> 1) * y_range.start_dst;

  0027d	ba 04 00 00 00	 mov	 edx, 4
  00282	c1 e2 00	 shl	 edx, 0
  00285	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  00288	d1 f8		 sar	 eax, 1
  0028a	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  0028e	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  00291	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  00294	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  00297	89 45 a0	 mov	 DWORD PTR _dstLine$[ebp], eax

; 320  :     for (int y = 0; y < y_range.len; y += 2, srcULine += src_uv_pitch * 2, srcVLine += src_uv_pitch * 2, dstLine += dst_y_pitch) {

  0029a	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR _y$17[ebp], 0
  002a1	eb 31		 jmp	 SHORT $LN10@convert_yu
$LN8@convert_yu:
  002a3	8b 4d 9c	 mov	 ecx, DWORD PTR _y$17[ebp]
  002a6	83 c1 02	 add	 ecx, 2
  002a9	89 4d 9c	 mov	 DWORD PTR _y$17[ebp], ecx
  002ac	8b 55 ac	 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  002af	d1 e2		 shl	 edx, 1
  002b1	8b 45 a8	 mov	 eax, DWORD PTR _srcULine$[ebp]
  002b4	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  002b7	89 4d a8	 mov	 DWORD PTR _srcULine$[ebp], ecx
  002ba	8b 55 ac	 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  002bd	d1 e2		 shl	 edx, 1
  002bf	8b 45 a4	 mov	 eax, DWORD PTR _srcVLine$[ebp]
  002c2	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  002c5	89 4d a4	 mov	 DWORD PTR _srcVLine$[ebp], ecx
  002c8	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  002cb	8b 45 a0	 mov	 eax, DWORD PTR _dstLine$[ebp]
  002ce	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  002d1	89 4d a0	 mov	 DWORD PTR _dstLine$[ebp], ecx
$LN10@convert_yu:
  002d4	8b 55 9c	 mov	 edx, DWORD PTR _y$17[ebp]
  002d7	3b 55 dc	 cmp	 edx, DWORD PTR _y_range$[ebp+8]
  002da	0f 8d 3a 01 00
	00		 jge	 $LN1@convert_yu

; 321  :         Tout *dstC = dstLine;

  002e0	8b 45 a0	 mov	 eax, DWORD PTR _dstLine$[ebp]
  002e3	89 45 98	 mov	 DWORD PTR _dstC$16[ebp], eax

; 322  :         Tin *srcU = srcULine;

  002e6	8b 4d a8	 mov	 ecx, DWORD PTR _srcULine$[ebp]
  002e9	89 4d 94	 mov	 DWORD PTR _srcU$15[ebp], ecx

; 323  :         Tin *srcV = srcVLine;

  002ec	8b 55 a4	 mov	 edx, DWORD PTR _srcVLine$[ebp]
  002ef	89 55 90	 mov	 DWORD PTR _srcV$14[ebp], edx

; 324  :         const int x_fin = width - crop_right - crop_left;

  002f2	8b 45 10	 mov	 eax, DWORD PTR _width$[ebp]
  002f5	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  002f8	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  002fb	89 45 8c	 mov	 DWORD PTR _x_fin$13[ebp], eax

; 325  :         for (int x = 0; x < x_fin; x += 2, dstC += 2, srcU += 2, srcV += 2) {

  002fe	c7 45 88 00 00
	00 00		 mov	 DWORD PTR _x$12[ebp], 0
  00305	eb 24		 jmp	 SHORT $LN13@convert_yu
$LN11@convert_yu:
  00307	8b 4d 88	 mov	 ecx, DWORD PTR _x$12[ebp]
  0030a	83 c1 02	 add	 ecx, 2
  0030d	89 4d 88	 mov	 DWORD PTR _x$12[ebp], ecx
  00310	8b 55 98	 mov	 edx, DWORD PTR _dstC$16[ebp]
  00313	83 c2 04	 add	 edx, 4
  00316	89 55 98	 mov	 DWORD PTR _dstC$16[ebp], edx
  00319	8b 45 94	 mov	 eax, DWORD PTR _srcU$15[ebp]
  0031c	83 c0 04	 add	 eax, 4
  0031f	89 45 94	 mov	 DWORD PTR _srcU$15[ebp], eax
  00322	8b 4d 90	 mov	 ecx, DWORD PTR _srcV$14[ebp]
  00325	83 c1 04	 add	 ecx, 4
  00328	89 4d 90	 mov	 DWORD PTR _srcV$14[ebp], ecx
$LN13@convert_yu:
  0032b	8b 55 88	 mov	 edx, DWORD PTR _x$12[ebp]
  0032e	3b 55 8c	 cmp	 edx, DWORD PTR _x_fin$13[ebp]
  00331	0f 8d de 00 00
	00		 jge	 $LN12@convert_yu

; 326  :             int cy0u = srcU[0*src_uv_pitch + 0];

  00337	6b 45 ac 00	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp], 0
  0033b	8b 4d 94	 mov	 ecx, DWORD PTR _srcU$15[ebp]
  0033e	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  00342	89 55 84	 mov	 DWORD PTR _cy0u$11[ebp], edx

; 327  :             int cy0v = srcV[0*src_uv_pitch + 0];

  00345	6b 45 ac 00	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp], 0
  00349	8b 4d 90	 mov	 ecx, DWORD PTR _srcV$14[ebp]
  0034c	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  00350	89 55 80	 mov	 DWORD PTR _cy0v$10[ebp], edx

; 328  :             int cy1u = srcU[1*src_uv_pitch + 0];

  00353	8b 45 ac	 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  00356	8b 4d 94	 mov	 ecx, DWORD PTR _srcU$15[ebp]
  00359	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  0035d	89 95 7c ff ff
	ff		 mov	 DWORD PTR _cy1u$9[ebp], edx

; 329  :             int cy1v = srcV[1*src_uv_pitch + 0];

  00363	8b 45 ac	 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  00366	8b 4d 90	 mov	 ecx, DWORD PTR _srcV$14[ebp]
  00369	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  0036d	89 95 78 ff ff
	ff		 mov	 DWORD PTR _cy1v$8[ebp], edx

; 330  : 
; 331  :             int cu = cy0u + cy1u + 1;

  00373	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _cy1u$9[ebp]
  00379	8b 4d 84	 mov	 ecx, DWORD PTR _cy0u$11[ebp]
  0037c	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  00380	89 95 74 ff ff
	ff		 mov	 DWORD PTR _cu$7[ebp], edx

; 332  :             int cv = cy0v + cy1v + 1;

  00386	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _cy1v$8[ebp]
  0038c	8b 4d 80	 mov	 ecx, DWORD PTR _cy0v$10[ebp]
  0038f	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  00393	89 95 70 ff ff
	ff		 mov	 DWORD PTR _cv$6[ebp], edx

; 333  :             CHANGE_BIT_DEPTH_2(cu, cv, 1);

  00399	b8 01 00 00 00	 mov	 eax, 1
  0039e	85 c0		 test	 eax, eax
  003a0	74 20		 je	 SHORT $LN21@convert_yu
  003a2	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _cu$7[ebp]
  003a8	c1 e1 05	 shl	 ecx, 5
  003ab	89 8d 74 ff ff
	ff		 mov	 DWORD PTR _cu$7[ebp], ecx
  003b1	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR _cv$6[ebp]
  003b7	c1 e2 05	 shl	 edx, 5
  003ba	89 95 70 ff ff
	ff		 mov	 DWORD PTR _cv$6[ebp], edx
  003c0	eb 22		 jmp	 SHORT $LN22@convert_yu
$LN21@convert_yu:
  003c2	33 c0		 xor	 eax, eax
  003c4	74 1e		 je	 SHORT $LN22@convert_yu
  003c6	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _cu$7[ebp]
  003cc	c1 f9 fb	 sar	 ecx, -5			; fffffffbH
  003cf	89 8d 74 ff ff
	ff		 mov	 DWORD PTR _cu$7[ebp], ecx
  003d5	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR _cv$6[ebp]
  003db	c1 fa fb	 sar	 edx, -5			; fffffffbH
  003de	89 95 70 ff ff
	ff		 mov	 DWORD PTR _cv$6[ebp], edx
$LN22@convert_yu:

; 334  : 
; 335  :             dstC[0] = (Tout)cu;

  003e4	b8 02 00 00 00	 mov	 eax, 2
  003e9	6b c8 00	 imul	 ecx, eax, 0
  003ec	8b 55 98	 mov	 edx, DWORD PTR _dstC$16[ebp]
  003ef	66 8b 85 74 ff
	ff ff		 mov	 ax, WORD PTR _cu$7[ebp]
  003f6	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax

; 336  :             dstC[1] = (Tout)cv;

  003fa	b9 02 00 00 00	 mov	 ecx, 2
  003ff	c1 e1 00	 shl	 ecx, 0
  00402	8b 55 98	 mov	 edx, DWORD PTR _dstC$16[ebp]
  00405	66 8b 85 70 ff
	ff ff		 mov	 ax, WORD PTR _cv$6[ebp]
  0040c	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax

; 337  :         }

  00410	e9 f2 fe ff ff	 jmp	 $LN11@convert_yu
$LN12@convert_yu:

; 338  :     }

  00415	e9 89 fe ff ff	 jmp	 $LN8@convert_yu
$LN1@convert_yu:

; 339  : }

  0041a	52		 push	 edx
  0041b	8b cd		 mov	 ecx, ebp
  0041d	50		 push	 eax
  0041e	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN27@convert_yu
  00424	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00429	58		 pop	 eax
  0042a	5a		 pop	 edx
  0042b	5f		 pop	 edi
  0042c	5e		 pop	 esi
  0042d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00430	33 cd		 xor	 ecx, ebp
  00432	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00437	81 c4 ac 00 00
	00		 add	 esp, 172		; 000000acH
  0043d	3b ec		 cmp	 ebp, esp
  0043f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00444	8b e5		 mov	 esp, ebp
  00446	5d		 pop	 ebp
  00447	c3		 ret	 0
$LN27@convert_yu:
  00448	01 00 00 00	 DD	 1
  0044c	00 00 00 00	 DD	 $LN26@convert_yu
$LN26@convert_yu:
  00450	d4 ff ff ff	 DD	 -44			; ffffffd4H
  00454	0c 00 00 00	 DD	 12			; 0000000cH
  00458	00 00 00 00	 DD	 $LN25@convert_yu
$LN25@convert_yu:
  0045c	79		 DB	 121			; 00000079H
  0045d	5f		 DB	 95			; 0000005fH
  0045e	72		 DB	 114			; 00000072H
  0045f	61		 DB	 97			; 00000061H
  00460	6e		 DB	 110			; 0000006eH
  00461	67		 DB	 103			; 00000067H
  00462	65		 DB	 101			; 00000065H
  00463	00		 DB	 0
??$convert_yuv444_to_nv12_p_c@G$09G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_to_nv12_p_c<unsigned short,10,unsigned short,16,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuv444_10_to_p010_p@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_10_to_p010_p

; 488  : static void convert_yuv444_10_to_p010_p(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 489  :     convert_yuv444_to_nv12_p_c<uint16_t, 10, uint16_t, 16, false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yuv444_to_nv12_p_c@G$09G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_to_nv12_p_c<unsigned short,10,unsigned short,16,0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 490  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yuv444_10_to_p010_p@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_10_to_p010_p
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
$T1 = -200						; size = 4
$T2 = -196						; size = 4
$T3 = -192						; size = 4
$T4 = -188						; size = 4
$T5 = -184						; size = 12
_cv_y1$6 = -172						; size = 4
_cv_y0$7 = -168						; size = 4
_cu_y1$8 = -164						; size = 4
_cu_y0$9 = -160						; size = 4
_cy3v$10 = -156						; size = 4
_cy3u$11 = -152						; size = 4
_cy2v$12 = -148						; size = 4
_cy2u$13 = -144						; size = 4
_cy1v$14 = -140						; size = 4
_cy1u$15 = -136						; size = 4
_cy0v$16 = -132						; size = 4
_cy0u$17 = -128						; size = 4
_x$18 = -124						; size = 4
_x_fin$19 = -120					; size = 4
_srcV$20 = -116						; size = 4
_srcU$21 = -112						; size = 4
_dstC$22 = -108						; size = 4
_y$23 = -104						; size = 4
_uv_fin$ = -100						; size = 4
_dstLine$ = -96						; size = 4
_srcVLine$ = -92					; size = 4
_srcULine$ = -88					; size = 4
_src_uv_pitch$ = -84					; size = 4
_x$24 = -80						; size = 4
_y$25 = -76						; size = 4
_y_width$26 = -72					; size = 4
_dstLine$27 = -68					; size = 4
_srcYLine$28 = -64					; size = 4
$T29 = -60						; size = 12
_y_range$ = -44						; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yuv444_to_nv12_i_c@G$0M@G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_to_nv12_i_c<unsigned short,12,unsigned short,16,0>

; 342  : static void __forceinline convert_yuv444_to_nv12_i_c(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8d bd 38 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-200]
  00011	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 343  :     static_assert((sizeof(Tin)  == 1 && in_bit_depth  == 8) || (sizeof(Tin)  == 2 && 8 < in_bit_depth  && in_bit_depth  <= 16), "invalid input bit depth.");
; 344  :     static_assert((sizeof(Tout) == 1 && out_bit_depth == 8) || (sizeof(Tout) == 2 && 8 < out_bit_depth && out_bit_depth <= 16), "invalid output bit depth.");
; 345  :     const int crop_left   = crop[0];

  00027	b8 04 00 00 00	 mov	 eax, 4
  0002c	6b c8 00	 imul	 ecx, eax, 0
  0002f	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00032	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00035	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 346  :     const int crop_up     = crop[1];

  00038	b9 04 00 00 00	 mov	 ecx, 4
  0003d	c1 e1 00	 shl	 ecx, 0
  00040	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00043	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00046	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 347  :     const int crop_right  = crop[2];

  00049	b9 04 00 00 00	 mov	 ecx, 4
  0004e	d1 e1		 shl	 ecx, 1
  00050	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00053	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00056	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 348  :     const int crop_bottom = crop[3];

  00059	b9 04 00 00 00	 mov	 ecx, 4
  0005e	6b d1 03	 imul	 edx, ecx, 3
  00061	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00064	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00067	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 349  :     const int src_y_pitch = src_y_pitch_byte / sizeof(Tin);

  0006a	8b 55 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebp]
  0006d	d1 ea		 shr	 edx, 1
  0006f	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 350  :     const int dst_y_pitch = dst_y_pitch_byte / sizeof(Tout);

  00072	8b 45 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  00075	d1 e8		 shr	 eax, 1
  00077	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 351  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  0007a	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0007d	51		 push	 ecx
  0007e	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  00081	52		 push	 edx
  00082	8b 45 20	 mov	 eax, DWORD PTR _height$[ebp]
  00085	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  00088	50		 push	 eax
  00089	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  0008c	51		 push	 ecx
  0008d	8d 95 48 ff ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  00093	52		 push	 edx
  00094	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00099	83 c4 14	 add	 esp, 20			; 00000014H
  0009c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009e	89 4d c4	 mov	 DWORD PTR $T29[ebp], ecx
  000a1	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a4	89 55 c8	 mov	 DWORD PTR $T29[ebp+4], edx
  000a7	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000aa	89 45 cc	 mov	 DWORD PTR $T29[ebp+8], eax
  000ad	8b 4d c4	 mov	 ecx, DWORD PTR $T29[ebp]
  000b0	89 4d d4	 mov	 DWORD PTR _y_range$[ebp], ecx
  000b3	8b 55 c8	 mov	 edx, DWORD PTR $T29[ebp+4]
  000b6	89 55 d8	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000b9	8b 45 cc	 mov	 eax, DWORD PTR $T29[ebp+8]
  000bc	89 45 dc	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 352  :     //Y
; 353  :     if (!uv_only) {

  000bf	b9 01 00 00 00	 mov	 ecx, 1
  000c4	85 c9		 test	 ecx, ecx
  000c6	0f 84 6e 01 00
	00		 je	 $LN14@convert_yu

; 354  :         Tin *srcYLine = (Tin *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000cc	ba 04 00 00 00	 mov	 edx, 4
  000d1	6b c2 00	 imul	 eax, edx, 0
  000d4	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  000d7	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  000db	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  000de	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  000e1	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  000e4	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  000e7	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  000ea	89 45 c0	 mov	 DWORD PTR _srcYLine$28[ebp], eax

; 355  :         Tout *dstLine = (Tout *)dst[0] + dst_y_pitch * y_range.start_dst;

  000ed	b9 04 00 00 00	 mov	 ecx, 4
  000f2	6b d1 00	 imul	 edx, ecx, 0
  000f5	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  000f8	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  000fc	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  000ff	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  00102	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  00105	89 45 bc	 mov	 DWORD PTR _dstLine$27[ebp], eax

; 356  :         const int y_width = width - crop_right - crop_left;

  00108	8b 4d 10	 mov	 ecx, DWORD PTR _width$[ebp]
  0010b	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  0010e	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  00111	89 4d b8	 mov	 DWORD PTR _y_width$26[ebp], ecx

; 357  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  00114	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _y$25[ebp], 0
  0011b	eb 21		 jmp	 SHORT $LN4@convert_yu
$LN2@convert_yu:
  0011d	8b 55 b4	 mov	 edx, DWORD PTR _y$25[ebp]
  00120	83 c2 01	 add	 edx, 1
  00123	89 55 b4	 mov	 DWORD PTR _y$25[ebp], edx
  00126	8b 45 e8	 mov	 eax, DWORD PTR _src_y_pitch$[ebp]
  00129	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$28[ebp]
  0012c	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  0012f	89 55 c0	 mov	 DWORD PTR _srcYLine$28[ebp], edx
  00132	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  00135	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$27[ebp]
  00138	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  0013b	89 55 bc	 mov	 DWORD PTR _dstLine$27[ebp], edx
$LN4@convert_yu:
  0013e	8b 45 b4	 mov	 eax, DWORD PTR _y$25[ebp]
  00141	3b 45 dc	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  00144	0f 8d f0 00 00
	00		 jge	 $LN14@convert_yu

; 358  :             if (in_bit_depth == out_bit_depth && sizeof(Tin) == sizeof(Tout)) {

  0014a	33 c9		 xor	 ecx, ecx
  0014c	74 1b		 je	 SHORT $LN15@convert_yu

; 359  :                 memcpy(dstLine, srcYLine, y_width * sizeof(Tin));

  0014e	8b 55 b8	 mov	 edx, DWORD PTR _y_width$26[ebp]
  00151	d1 e2		 shl	 edx, 1
  00153	52		 push	 edx
  00154	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$28[ebp]
  00157	50		 push	 eax
  00158	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$27[ebp]
  0015b	51		 push	 ecx
  0015c	e8 00 00 00 00	 call	 _memcpy
  00161	83 c4 0c	 add	 esp, 12			; 0000000cH

; 360  :             } else {

  00164	e9 cc 00 00 00	 jmp	 $LN16@convert_yu
$LN15@convert_yu:

; 361  :                 for (int x = 0; x < y_width; x++) {

  00169	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _x$24[ebp], 0
  00170	eb 09		 jmp	 SHORT $LN7@convert_yu
$LN5@convert_yu:
  00172	8b 55 b0	 mov	 edx, DWORD PTR _x$24[ebp]
  00175	83 c2 01	 add	 edx, 1
  00178	89 55 b0	 mov	 DWORD PTR _x$24[ebp], edx
$LN7@convert_yu:
  0017b	8b 45 b0	 mov	 eax, DWORD PTR _x$24[ebp]
  0017e	3b 45 b8	 cmp	 eax, DWORD PTR _y_width$26[ebp]
  00181	0f 8d ae 00 00
	00		 jge	 $LN16@convert_yu

; 362  :                     if (out_bit_depth > in_bit_depth) {

  00187	b9 01 00 00 00	 mov	 ecx, 1
  0018c	85 c9		 test	 ecx, ecx
  0018e	74 44		 je	 SHORT $LN17@convert_yu

; 363  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) << std::max(out_bit_depth - in_bit_depth, 0));

  00190	c7 85 44 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], 0
  0019a	c7 85 40 ff ff
	ff 04 00 00 00	 mov	 DWORD PTR $T3[ebp], 4
  001a4	8b 55 b0	 mov	 edx, DWORD PTR _x$24[ebp]
  001a7	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$28[ebp]
  001aa	0f b7 34 50	 movzx	 esi, WORD PTR [eax+edx*2]
  001ae	8d 8d 44 ff ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  001b4	51		 push	 ecx
  001b5	8d 95 40 ff ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  001bb	52		 push	 edx
  001bc	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  001c1	83 c4 08	 add	 esp, 8
  001c4	8b 08		 mov	 ecx, DWORD PTR [eax]
  001c6	d3 e6		 shl	 esi, cl
  001c8	8b 45 b0	 mov	 eax, DWORD PTR _x$24[ebp]
  001cb	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$27[ebp]
  001ce	66 89 34 41	 mov	 WORD PTR [ecx+eax*2], si
  001d2	eb 5c		 jmp	 SHORT $LN18@convert_yu
$LN17@convert_yu:

; 364  :                     } else if (out_bit_depth < in_bit_depth) {

  001d4	33 d2		 xor	 edx, edx
  001d6	74 44		 je	 SHORT $LN19@convert_yu

; 365  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) >> std::max(in_bit_depth - out_bit_depth, 0));

  001d8	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], 0
  001e2	c7 85 38 ff ff
	ff fc ff ff ff	 mov	 DWORD PTR $T1[ebp], -4	; fffffffcH
  001ec	8b 45 b0	 mov	 eax, DWORD PTR _x$24[ebp]
  001ef	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$28[ebp]
  001f2	0f b7 34 41	 movzx	 esi, WORD PTR [ecx+eax*2]
  001f6	8d 95 3c ff ff
	ff		 lea	 edx, DWORD PTR $T2[ebp]
  001fc	52		 push	 edx
  001fd	8d 85 38 ff ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  00203	50		 push	 eax
  00204	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  00209	83 c4 08	 add	 esp, 8
  0020c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0020e	d3 fe		 sar	 esi, cl
  00210	8b 4d b0	 mov	 ecx, DWORD PTR _x$24[ebp]
  00213	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$27[ebp]
  00216	66 89 34 4a	 mov	 WORD PTR [edx+ecx*2], si

; 366  :                     } else {

  0021a	eb 14		 jmp	 SHORT $LN18@convert_yu
$LN19@convert_yu:

; 367  :                         dstLine[x] = (Tout)srcYLine[x];

  0021c	8b 45 b0	 mov	 eax, DWORD PTR _x$24[ebp]
  0021f	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$27[ebp]
  00222	8b 55 b0	 mov	 edx, DWORD PTR _x$24[ebp]
  00225	8b 75 c0	 mov	 esi, DWORD PTR _srcYLine$28[ebp]
  00228	66 8b 14 56	 mov	 dx, WORD PTR [esi+edx*2]
  0022c	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx
$LN18@convert_yu:

; 368  :                     }
; 369  :                 }

  00230	e9 3d ff ff ff	 jmp	 $LN5@convert_yu
$LN16@convert_yu:

; 370  :             }
; 371  :         }

  00235	e9 e3 fe ff ff	 jmp	 $LN2@convert_yu
$LN14@convert_yu:

; 372  :     }
; 373  :     //UV
; 374  :     const int src_uv_pitch = src_uv_pitch_byte / sizeof(Tin);

  0023a	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0023d	d1 e8		 shr	 eax, 1
  0023f	89 45 ac	 mov	 DWORD PTR _src_uv_pitch$[ebp], eax

; 375  :     Tin *srcULine = (Tin *)src[1] + ((src_uv_pitch * y_range.start_src) + crop_left);

  00242	b9 04 00 00 00	 mov	 ecx, 4
  00247	c1 e1 00	 shl	 ecx, 0
  0024a	8b 55 ac	 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  0024d	0f af 55 d4	 imul	 edx, DWORD PTR _y_range$[ebp]
  00251	03 55 f8	 add	 edx, DWORD PTR _crop_left$[ebp]
  00254	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  00257	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  0025a	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  0025d	89 55 a8	 mov	 DWORD PTR _srcULine$[ebp], edx

; 376  :     Tin *srcVLine = (Tin *)src[2] + ((src_uv_pitch * y_range.start_src) + crop_left);

  00260	b8 04 00 00 00	 mov	 eax, 4
  00265	d1 e0		 shl	 eax, 1
  00267	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  0026a	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  0026e	03 4d f8	 add	 ecx, DWORD PTR _crop_left$[ebp]
  00271	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  00274	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  00277	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  0027a	89 4d a4	 mov	 DWORD PTR _srcVLine$[ebp], ecx

; 377  :     Tout *dstLine = (Tout *)dst[1] + (dst_y_pitch >> 1) * y_range.start_dst;

  0027d	ba 04 00 00 00	 mov	 edx, 4
  00282	c1 e2 00	 shl	 edx, 0
  00285	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  00288	d1 f8		 sar	 eax, 1
  0028a	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  0028e	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  00291	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  00294	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  00297	89 45 a0	 mov	 DWORD PTR _dstLine$[ebp], eax

; 378  :     const int uv_fin = height - crop_bottom - crop_up;

  0029a	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  0029d	2b 4d ec	 sub	 ecx, DWORD PTR _crop_bottom$[ebp]
  002a0	2b 4d f4	 sub	 ecx, DWORD PTR _crop_up$[ebp]
  002a3	89 4d 9c	 mov	 DWORD PTR _uv_fin$[ebp], ecx

; 379  :     for (int y = 0; y < y_range.len; y += 4, srcULine += src_uv_pitch * 4, srcVLine += src_uv_pitch * 4, dstLine += dst_y_pitch * 2) {

  002a6	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _y$23[ebp], 0
  002ad	eb 35		 jmp	 SHORT $LN10@convert_yu
$LN8@convert_yu:
  002af	8b 55 98	 mov	 edx, DWORD PTR _y$23[ebp]
  002b2	83 c2 04	 add	 edx, 4
  002b5	89 55 98	 mov	 DWORD PTR _y$23[ebp], edx
  002b8	8b 45 ac	 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  002bb	c1 e0 02	 shl	 eax, 2
  002be	8b 4d a8	 mov	 ecx, DWORD PTR _srcULine$[ebp]
  002c1	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  002c4	89 55 a8	 mov	 DWORD PTR _srcULine$[ebp], edx
  002c7	8b 45 ac	 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  002ca	c1 e0 02	 shl	 eax, 2
  002cd	8b 4d a4	 mov	 ecx, DWORD PTR _srcVLine$[ebp]
  002d0	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  002d3	89 55 a4	 mov	 DWORD PTR _srcVLine$[ebp], edx
  002d6	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  002d9	d1 e0		 shl	 eax, 1
  002db	8b 4d a0	 mov	 ecx, DWORD PTR _dstLine$[ebp]
  002de	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  002e1	89 55 a0	 mov	 DWORD PTR _dstLine$[ebp], edx
$LN10@convert_yu:
  002e4	8b 45 98	 mov	 eax, DWORD PTR _y$23[ebp]
  002e7	3b 45 dc	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  002ea	0f 8d 0e 02 00
	00		 jge	 $LN1@convert_yu

; 380  :         Tout *dstC = dstLine;

  002f0	8b 4d a0	 mov	 ecx, DWORD PTR _dstLine$[ebp]
  002f3	89 4d 94	 mov	 DWORD PTR _dstC$22[ebp], ecx

; 381  :         Tin *srcU = srcULine;

  002f6	8b 55 a8	 mov	 edx, DWORD PTR _srcULine$[ebp]
  002f9	89 55 90	 mov	 DWORD PTR _srcU$21[ebp], edx

; 382  :         Tin *srcV = srcVLine;

  002fc	8b 45 a4	 mov	 eax, DWORD PTR _srcVLine$[ebp]
  002ff	89 45 8c	 mov	 DWORD PTR _srcV$20[ebp], eax

; 383  :         const int x_fin = width - crop_right - crop_left;

  00302	8b 4d 10	 mov	 ecx, DWORD PTR _width$[ebp]
  00305	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  00308	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  0030b	89 4d 88	 mov	 DWORD PTR _x_fin$19[ebp], ecx

; 384  :         for (int x = 0; x < x_fin; x += 2, dstC += 2, srcU += 2, srcV += 2) {

  0030e	c7 45 84 00 00
	00 00		 mov	 DWORD PTR _x$18[ebp], 0
  00315	eb 24		 jmp	 SHORT $LN13@convert_yu
$LN11@convert_yu:
  00317	8b 55 84	 mov	 edx, DWORD PTR _x$18[ebp]
  0031a	83 c2 02	 add	 edx, 2
  0031d	89 55 84	 mov	 DWORD PTR _x$18[ebp], edx
  00320	8b 45 94	 mov	 eax, DWORD PTR _dstC$22[ebp]
  00323	83 c0 04	 add	 eax, 4
  00326	89 45 94	 mov	 DWORD PTR _dstC$22[ebp], eax
  00329	8b 4d 90	 mov	 ecx, DWORD PTR _srcU$21[ebp]
  0032c	83 c1 04	 add	 ecx, 4
  0032f	89 4d 90	 mov	 DWORD PTR _srcU$21[ebp], ecx
  00332	8b 55 8c	 mov	 edx, DWORD PTR _srcV$20[ebp]
  00335	83 c2 04	 add	 edx, 4
  00338	89 55 8c	 mov	 DWORD PTR _srcV$20[ebp], edx
$LN13@convert_yu:
  0033b	8b 45 84	 mov	 eax, DWORD PTR _x$18[ebp]
  0033e	3b 45 88	 cmp	 eax, DWORD PTR _x_fin$19[ebp]
  00341	0f 8d b2 01 00
	00		 jge	 $LN12@convert_yu

; 385  :             int cy0u = srcU[0*src_uv_pitch + 0];

  00347	6b 4d ac 00	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 0
  0034b	8b 55 90	 mov	 edx, DWORD PTR _srcU$21[ebp]
  0034e	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00352	89 45 80	 mov	 DWORD PTR _cy0u$17[ebp], eax

; 386  :             int cy0v = srcV[0*src_uv_pitch + 0];

  00355	6b 4d ac 00	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 0
  00359	8b 55 8c	 mov	 edx, DWORD PTR _srcV$20[ebp]
  0035c	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00360	89 85 7c ff ff
	ff		 mov	 DWORD PTR _cy0v$16[ebp], eax

; 387  :             int cy1u = srcU[1*src_uv_pitch + 0];

  00366	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00369	8b 55 90	 mov	 edx, DWORD PTR _srcU$21[ebp]
  0036c	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00370	89 85 78 ff ff
	ff		 mov	 DWORD PTR _cy1u$15[ebp], eax

; 388  :             int cy1v = srcV[1*src_uv_pitch + 0];

  00376	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00379	8b 55 8c	 mov	 edx, DWORD PTR _srcV$20[ebp]
  0037c	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00380	89 85 74 ff ff
	ff		 mov	 DWORD PTR _cy1v$14[ebp], eax

; 389  :             int cy2u = srcU[2*src_uv_pitch + 0];

  00386	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00389	d1 e1		 shl	 ecx, 1
  0038b	8b 55 90	 mov	 edx, DWORD PTR _srcU$21[ebp]
  0038e	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00392	89 85 70 ff ff
	ff		 mov	 DWORD PTR _cy2u$13[ebp], eax

; 390  :             int cy2v = srcV[2*src_uv_pitch + 0];

  00398	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  0039b	d1 e1		 shl	 ecx, 1
  0039d	8b 55 8c	 mov	 edx, DWORD PTR _srcV$20[ebp]
  003a0	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  003a4	89 85 6c ff ff
	ff		 mov	 DWORD PTR _cy2v$12[ebp], eax

; 391  :             int cy3u = srcU[3*src_uv_pitch + 0];

  003aa	6b 4d ac 03	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 3
  003ae	8b 55 90	 mov	 edx, DWORD PTR _srcU$21[ebp]
  003b1	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  003b5	89 85 68 ff ff
	ff		 mov	 DWORD PTR _cy3u$11[ebp], eax

; 392  :             int cy3v = srcV[3*src_uv_pitch + 0];

  003bb	6b 4d ac 03	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 3
  003bf	8b 55 8c	 mov	 edx, DWORD PTR _srcV$20[ebp]
  003c2	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  003c6	89 85 64 ff ff
	ff		 mov	 DWORD PTR _cy3v$10[ebp], eax

; 393  : 
; 394  :             int cu_y0 = cy0u * 3 + cy2u * 1 + 2;

  003cc	6b 4d 80 03	 imul	 ecx, DWORD PTR _cy0u$17[ebp], 3
  003d0	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR _cy2u$13[ebp]
  003d6	8d 44 11 02	 lea	 eax, DWORD PTR [ecx+edx+2]
  003da	89 85 60 ff ff
	ff		 mov	 DWORD PTR _cu_y0$9[ebp], eax

; 395  :             int cu_y1 = cy1u * 1 + cy3u * 3 + 2;

  003e0	6b 8d 68 ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy3u$11[ebp], 3
  003e7	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _cy1u$15[ebp]
  003ed	8d 44 0a 02	 lea	 eax, DWORD PTR [edx+ecx+2]
  003f1	89 85 5c ff ff
	ff		 mov	 DWORD PTR _cu_y1$8[ebp], eax

; 396  :             int cv_y0 = cy0v * 3 + cy2v * 1 + 2;

  003f7	6b 8d 7c ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy0v$16[ebp], 3
  003fe	8b 95 6c ff ff
	ff		 mov	 edx, DWORD PTR _cy2v$12[ebp]
  00404	8d 44 11 02	 lea	 eax, DWORD PTR [ecx+edx+2]
  00408	89 85 58 ff ff
	ff		 mov	 DWORD PTR _cv_y0$7[ebp], eax

; 397  :             int cv_y1 = cy1v * 1 + cy3v * 3 + 2;

  0040e	6b 8d 64 ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy3v$10[ebp], 3
  00415	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _cy1v$14[ebp]
  0041b	8d 44 0a 02	 lea	 eax, DWORD PTR [edx+ecx+2]
  0041f	89 85 54 ff ff
	ff		 mov	 DWORD PTR _cv_y1$6[ebp], eax

; 398  :             CHANGE_BIT_DEPTH_4(cu_y0, cu_y1, cv_y0, cv_y1, 2);

  00425	b9 01 00 00 00	 mov	 ecx, 1
  0042a	85 c9		 test	 ecx, ecx
  0042c	74 3e		 je	 SHORT $LN21@convert_yu
  0042e	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _cu_y0$9[ebp]
  00434	c1 e2 02	 shl	 edx, 2
  00437	89 95 60 ff ff
	ff		 mov	 DWORD PTR _cu_y0$9[ebp], edx
  0043d	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _cu_y1$8[ebp]
  00443	c1 e0 02	 shl	 eax, 2
  00446	89 85 5c ff ff
	ff		 mov	 DWORD PTR _cu_y1$8[ebp], eax
  0044c	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _cv_y0$7[ebp]
  00452	c1 e1 02	 shl	 ecx, 2
  00455	89 8d 58 ff ff
	ff		 mov	 DWORD PTR _cv_y0$7[ebp], ecx
  0045b	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR _cv_y1$6[ebp]
  00461	c1 e2 02	 shl	 edx, 2
  00464	89 95 54 ff ff
	ff		 mov	 DWORD PTR _cv_y1$6[ebp], edx
  0046a	eb 40		 jmp	 SHORT $LN22@convert_yu
$LN21@convert_yu:
  0046c	33 c0		 xor	 eax, eax
  0046e	74 3c		 je	 SHORT $LN22@convert_yu
  00470	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _cu_y0$9[ebp]
  00476	c1 f9 fe	 sar	 ecx, -2			; fffffffeH
  00479	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _cu_y0$9[ebp], ecx
  0047f	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR _cu_y1$8[ebp]
  00485	c1 fa fe	 sar	 edx, -2			; fffffffeH
  00488	89 95 5c ff ff
	ff		 mov	 DWORD PTR _cu_y1$8[ebp], edx
  0048e	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _cv_y0$7[ebp]
  00494	c1 f8 fe	 sar	 eax, -2			; fffffffeH
  00497	89 85 58 ff ff
	ff		 mov	 DWORD PTR _cv_y0$7[ebp], eax
  0049d	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _cv_y1$6[ebp]
  004a3	c1 f9 fe	 sar	 ecx, -2			; fffffffeH
  004a6	89 8d 54 ff ff
	ff		 mov	 DWORD PTR _cv_y1$6[ebp], ecx
$LN22@convert_yu:

; 399  : 
; 400  :             dstC[0*dst_y_pitch + 0] = (Tout)cu_y0;

  004ac	6b 55 e4 00	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 0
  004b0	8b 45 94	 mov	 eax, DWORD PTR _dstC$22[ebp]
  004b3	66 8b 8d 60 ff
	ff ff		 mov	 cx, WORD PTR _cu_y0$9[ebp]
  004ba	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx

; 401  :             dstC[0*dst_y_pitch + 1] = (Tout)cv_y0;

  004be	6b 55 e4 00	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 0
  004c2	8b 45 94	 mov	 eax, DWORD PTR _dstC$22[ebp]
  004c5	66 8b 8d 58 ff
	ff ff		 mov	 cx, WORD PTR _cv_y0$7[ebp]
  004cc	66 89 4c 50 02	 mov	 WORD PTR [eax+edx*2+2], cx

; 402  :             dstC[1*dst_y_pitch + 0] = (Tout)cu_y1;

  004d1	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  004d4	8b 45 94	 mov	 eax, DWORD PTR _dstC$22[ebp]
  004d7	66 8b 8d 5c ff
	ff ff		 mov	 cx, WORD PTR _cu_y1$8[ebp]
  004de	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx

; 403  :             dstC[1*dst_y_pitch + 1] = (Tout)cv_y1;

  004e2	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  004e5	8b 45 94	 mov	 eax, DWORD PTR _dstC$22[ebp]
  004e8	66 8b 8d 54 ff
	ff ff		 mov	 cx, WORD PTR _cv_y1$6[ebp]
  004ef	66 89 4c 50 02	 mov	 WORD PTR [eax+edx*2+2], cx

; 404  :         }

  004f4	e9 1e fe ff ff	 jmp	 $LN11@convert_yu
$LN12@convert_yu:

; 405  :     }

  004f9	e9 b1 fd ff ff	 jmp	 $LN8@convert_yu
$LN1@convert_yu:

; 406  : }

  004fe	52		 push	 edx
  004ff	8b cd		 mov	 ecx, ebp
  00501	50		 push	 eax
  00502	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN27@convert_yu
  00508	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0050d	58		 pop	 eax
  0050e	5a		 pop	 edx
  0050f	5f		 pop	 edi
  00510	5e		 pop	 esi
  00511	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00514	33 cd		 xor	 ecx, ebp
  00516	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0051b	81 c4 c8 00 00
	00		 add	 esp, 200		; 000000c8H
  00521	3b ec		 cmp	 ebp, esp
  00523	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00528	8b e5		 mov	 esp, ebp
  0052a	5d		 pop	 ebp
  0052b	c3		 ret	 0
$LN27@convert_yu:
  0052c	01 00 00 00	 DD	 1
  00530	00 00 00 00	 DD	 $LN26@convert_yu
$LN26@convert_yu:
  00534	d4 ff ff ff	 DD	 -44			; ffffffd4H
  00538	0c 00 00 00	 DD	 12			; 0000000cH
  0053c	00 00 00 00	 DD	 $LN25@convert_yu
$LN25@convert_yu:
  00540	79		 DB	 121			; 00000079H
  00541	5f		 DB	 95			; 0000005fH
  00542	72		 DB	 114			; 00000072H
  00543	61		 DB	 97			; 00000061H
  00544	6e		 DB	 110			; 0000006eH
  00545	67		 DB	 103			; 00000067H
  00546	65		 DB	 101			; 00000065H
  00547	00		 DB	 0
??$convert_yuv444_to_nv12_i_c@G$0M@G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_to_nv12_i_c<unsigned short,12,unsigned short,16,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuv444_12_to_p010_i@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_12_to_p010_i

; 484  : static void convert_yuv444_12_to_p010_i(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 485  :     convert_yuv444_to_nv12_i_c<uint16_t, 12, uint16_t, 16, false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yuv444_to_nv12_i_c@G$0M@G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_to_nv12_i_c<unsigned short,12,unsigned short,16,0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 486  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yuv444_12_to_p010_i@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_12_to_p010_i
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
$T1 = -172						; size = 4
$T2 = -168						; size = 4
$T3 = -164						; size = 4
$T4 = -160						; size = 4
$T5 = -156						; size = 12
_cv$6 = -144						; size = 4
_cu$7 = -140						; size = 4
_cy1v$8 = -136						; size = 4
_cy1u$9 = -132						; size = 4
_cy0v$10 = -128						; size = 4
_cy0u$11 = -124						; size = 4
_x$12 = -120						; size = 4
_x_fin$13 = -116					; size = 4
_srcV$14 = -112						; size = 4
_srcU$15 = -108						; size = 4
_dstC$16 = -104						; size = 4
_y$17 = -100						; size = 4
_dstLine$ = -96						; size = 4
_srcVLine$ = -92					; size = 4
_srcULine$ = -88					; size = 4
_src_uv_pitch$ = -84					; size = 4
_x$18 = -80						; size = 4
_y$19 = -76						; size = 4
_y_width$20 = -72					; size = 4
_dstLine$21 = -68					; size = 4
_srcYLine$22 = -64					; size = 4
$T23 = -60						; size = 12
_y_range$ = -44						; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yuv444_to_nv12_p_c@G$0M@G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_to_nv12_p_c<unsigned short,12,unsigned short,16,0>

; 284  : static void __forceinline convert_yuv444_to_nv12_p_c(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec ac 00 00
	00		 sub	 esp, 172		; 000000acH
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8d bd 54 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-172]
  00011	b9 2b 00 00 00	 mov	 ecx, 43			; 0000002bH
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 285  :     static_assert((sizeof(Tin)  == 1 && in_bit_depth  == 8) || (sizeof(Tin)  == 2 && 8 < in_bit_depth  && in_bit_depth  <= 16), "invalid input bit depth.");
; 286  :     static_assert((sizeof(Tout) == 1 && out_bit_depth == 8) || (sizeof(Tout) == 2 && 8 < out_bit_depth && out_bit_depth <= 16), "invalid output bit depth.");
; 287  :     const int crop_left   = crop[0];

  00027	b8 04 00 00 00	 mov	 eax, 4
  0002c	6b c8 00	 imul	 ecx, eax, 0
  0002f	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00032	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00035	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 288  :     const int crop_up     = crop[1];

  00038	b9 04 00 00 00	 mov	 ecx, 4
  0003d	c1 e1 00	 shl	 ecx, 0
  00040	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00043	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00046	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 289  :     const int crop_right  = crop[2];

  00049	b9 04 00 00 00	 mov	 ecx, 4
  0004e	d1 e1		 shl	 ecx, 1
  00050	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00053	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00056	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 290  :     const int crop_bottom = crop[3];

  00059	b9 04 00 00 00	 mov	 ecx, 4
  0005e	6b d1 03	 imul	 edx, ecx, 3
  00061	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00064	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00067	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 291  :     const int src_y_pitch = src_y_pitch_byte / sizeof(Tin);

  0006a	8b 55 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebp]
  0006d	d1 ea		 shr	 edx, 1
  0006f	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 292  :     const int dst_y_pitch = dst_y_pitch_byte / sizeof(Tout);

  00072	8b 45 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  00075	d1 e8		 shr	 eax, 1
  00077	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 293  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  0007a	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0007d	51		 push	 ecx
  0007e	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  00081	52		 push	 edx
  00082	8b 45 20	 mov	 eax, DWORD PTR _height$[ebp]
  00085	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  00088	50		 push	 eax
  00089	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  0008c	51		 push	 ecx
  0008d	8d 95 64 ff ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  00093	52		 push	 edx
  00094	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00099	83 c4 14	 add	 esp, 20			; 00000014H
  0009c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009e	89 4d c4	 mov	 DWORD PTR $T23[ebp], ecx
  000a1	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a4	89 55 c8	 mov	 DWORD PTR $T23[ebp+4], edx
  000a7	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000aa	89 45 cc	 mov	 DWORD PTR $T23[ebp+8], eax
  000ad	8b 4d c4	 mov	 ecx, DWORD PTR $T23[ebp]
  000b0	89 4d d4	 mov	 DWORD PTR _y_range$[ebp], ecx
  000b3	8b 55 c8	 mov	 edx, DWORD PTR $T23[ebp+4]
  000b6	89 55 d8	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000b9	8b 45 cc	 mov	 eax, DWORD PTR $T23[ebp+8]
  000bc	89 45 dc	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 294  :     //Y
; 295  :     if (!uv_only) {

  000bf	b9 01 00 00 00	 mov	 ecx, 1
  000c4	85 c9		 test	 ecx, ecx
  000c6	0f 84 6e 01 00
	00		 je	 $LN14@convert_yu

; 296  :         Tin *srcYLine = (Tin *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000cc	ba 04 00 00 00	 mov	 edx, 4
  000d1	6b c2 00	 imul	 eax, edx, 0
  000d4	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  000d7	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  000db	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  000de	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  000e1	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  000e4	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  000e7	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  000ea	89 45 c0	 mov	 DWORD PTR _srcYLine$22[ebp], eax

; 297  :         Tout *dstLine = (Tout *)dst[0] + dst_y_pitch * y_range.start_dst;

  000ed	b9 04 00 00 00	 mov	 ecx, 4
  000f2	6b d1 00	 imul	 edx, ecx, 0
  000f5	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  000f8	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  000fc	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  000ff	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  00102	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  00105	89 45 bc	 mov	 DWORD PTR _dstLine$21[ebp], eax

; 298  :         const int y_width = width - crop_right - crop_left;

  00108	8b 4d 10	 mov	 ecx, DWORD PTR _width$[ebp]
  0010b	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  0010e	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  00111	89 4d b8	 mov	 DWORD PTR _y_width$20[ebp], ecx

; 299  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  00114	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _y$19[ebp], 0
  0011b	eb 21		 jmp	 SHORT $LN4@convert_yu
$LN2@convert_yu:
  0011d	8b 55 b4	 mov	 edx, DWORD PTR _y$19[ebp]
  00120	83 c2 01	 add	 edx, 1
  00123	89 55 b4	 mov	 DWORD PTR _y$19[ebp], edx
  00126	8b 45 e8	 mov	 eax, DWORD PTR _src_y_pitch$[ebp]
  00129	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$22[ebp]
  0012c	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  0012f	89 55 c0	 mov	 DWORD PTR _srcYLine$22[ebp], edx
  00132	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  00135	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$21[ebp]
  00138	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  0013b	89 55 bc	 mov	 DWORD PTR _dstLine$21[ebp], edx
$LN4@convert_yu:
  0013e	8b 45 b4	 mov	 eax, DWORD PTR _y$19[ebp]
  00141	3b 45 dc	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  00144	0f 8d f0 00 00
	00		 jge	 $LN14@convert_yu

; 300  :             if (in_bit_depth == out_bit_depth && sizeof(Tin) == sizeof(Tout)) {

  0014a	33 c9		 xor	 ecx, ecx
  0014c	74 1b		 je	 SHORT $LN15@convert_yu

; 301  :                 memcpy(dstLine, srcYLine, y_width * sizeof(Tin));

  0014e	8b 55 b8	 mov	 edx, DWORD PTR _y_width$20[ebp]
  00151	d1 e2		 shl	 edx, 1
  00153	52		 push	 edx
  00154	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$22[ebp]
  00157	50		 push	 eax
  00158	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$21[ebp]
  0015b	51		 push	 ecx
  0015c	e8 00 00 00 00	 call	 _memcpy
  00161	83 c4 0c	 add	 esp, 12			; 0000000cH

; 302  :             } else {

  00164	e9 cc 00 00 00	 jmp	 $LN16@convert_yu
$LN15@convert_yu:

; 303  :                 for (int x = 0; x < y_width; x++) {

  00169	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _x$18[ebp], 0
  00170	eb 09		 jmp	 SHORT $LN7@convert_yu
$LN5@convert_yu:
  00172	8b 55 b0	 mov	 edx, DWORD PTR _x$18[ebp]
  00175	83 c2 01	 add	 edx, 1
  00178	89 55 b0	 mov	 DWORD PTR _x$18[ebp], edx
$LN7@convert_yu:
  0017b	8b 45 b0	 mov	 eax, DWORD PTR _x$18[ebp]
  0017e	3b 45 b8	 cmp	 eax, DWORD PTR _y_width$20[ebp]
  00181	0f 8d ae 00 00
	00		 jge	 $LN16@convert_yu

; 304  :                     if (out_bit_depth > in_bit_depth) {

  00187	b9 01 00 00 00	 mov	 ecx, 1
  0018c	85 c9		 test	 ecx, ecx
  0018e	74 44		 je	 SHORT $LN17@convert_yu

; 305  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) << std::max(out_bit_depth - in_bit_depth, 0));

  00190	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], 0
  0019a	c7 85 5c ff ff
	ff 04 00 00 00	 mov	 DWORD PTR $T3[ebp], 4
  001a4	8b 55 b0	 mov	 edx, DWORD PTR _x$18[ebp]
  001a7	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$22[ebp]
  001aa	0f b7 34 50	 movzx	 esi, WORD PTR [eax+edx*2]
  001ae	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  001b4	51		 push	 ecx
  001b5	8d 95 5c ff ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  001bb	52		 push	 edx
  001bc	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  001c1	83 c4 08	 add	 esp, 8
  001c4	8b 08		 mov	 ecx, DWORD PTR [eax]
  001c6	d3 e6		 shl	 esi, cl
  001c8	8b 45 b0	 mov	 eax, DWORD PTR _x$18[ebp]
  001cb	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$21[ebp]
  001ce	66 89 34 41	 mov	 WORD PTR [ecx+eax*2], si
  001d2	eb 5c		 jmp	 SHORT $LN18@convert_yu
$LN17@convert_yu:

; 306  :                     } else if (out_bit_depth < in_bit_depth) {

  001d4	33 d2		 xor	 edx, edx
  001d6	74 44		 je	 SHORT $LN19@convert_yu

; 307  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) >> std::max(in_bit_depth - out_bit_depth, 0));

  001d8	c7 85 58 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], 0
  001e2	c7 85 54 ff ff
	ff fc ff ff ff	 mov	 DWORD PTR $T1[ebp], -4	; fffffffcH
  001ec	8b 45 b0	 mov	 eax, DWORD PTR _x$18[ebp]
  001ef	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$22[ebp]
  001f2	0f b7 34 41	 movzx	 esi, WORD PTR [ecx+eax*2]
  001f6	8d 95 58 ff ff
	ff		 lea	 edx, DWORD PTR $T2[ebp]
  001fc	52		 push	 edx
  001fd	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  00203	50		 push	 eax
  00204	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  00209	83 c4 08	 add	 esp, 8
  0020c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0020e	d3 fe		 sar	 esi, cl
  00210	8b 4d b0	 mov	 ecx, DWORD PTR _x$18[ebp]
  00213	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$21[ebp]
  00216	66 89 34 4a	 mov	 WORD PTR [edx+ecx*2], si

; 308  :                     } else {

  0021a	eb 14		 jmp	 SHORT $LN18@convert_yu
$LN19@convert_yu:

; 309  :                         dstLine[x] = (Tout)srcYLine[x];

  0021c	8b 45 b0	 mov	 eax, DWORD PTR _x$18[ebp]
  0021f	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$21[ebp]
  00222	8b 55 b0	 mov	 edx, DWORD PTR _x$18[ebp]
  00225	8b 75 c0	 mov	 esi, DWORD PTR _srcYLine$22[ebp]
  00228	66 8b 14 56	 mov	 dx, WORD PTR [esi+edx*2]
  0022c	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx
$LN18@convert_yu:

; 310  :                     }
; 311  :                 }

  00230	e9 3d ff ff ff	 jmp	 $LN5@convert_yu
$LN16@convert_yu:

; 312  :             }
; 313  :         }

  00235	e9 e3 fe ff ff	 jmp	 $LN2@convert_yu
$LN14@convert_yu:

; 314  :     }
; 315  :     //UV
; 316  :     const int src_uv_pitch = src_uv_pitch_byte / sizeof(Tin);

  0023a	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0023d	d1 e8		 shr	 eax, 1
  0023f	89 45 ac	 mov	 DWORD PTR _src_uv_pitch$[ebp], eax

; 317  :     Tin *srcULine = (Tin *)src[1] + ((src_uv_pitch * y_range.start_src) + crop_left);

  00242	b9 04 00 00 00	 mov	 ecx, 4
  00247	c1 e1 00	 shl	 ecx, 0
  0024a	8b 55 ac	 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  0024d	0f af 55 d4	 imul	 edx, DWORD PTR _y_range$[ebp]
  00251	03 55 f8	 add	 edx, DWORD PTR _crop_left$[ebp]
  00254	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  00257	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  0025a	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  0025d	89 55 a8	 mov	 DWORD PTR _srcULine$[ebp], edx

; 318  :     Tin *srcVLine = (Tin *)src[2] + ((src_uv_pitch * y_range.start_src) + crop_left);

  00260	b8 04 00 00 00	 mov	 eax, 4
  00265	d1 e0		 shl	 eax, 1
  00267	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  0026a	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  0026e	03 4d f8	 add	 ecx, DWORD PTR _crop_left$[ebp]
  00271	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  00274	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  00277	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  0027a	89 4d a4	 mov	 DWORD PTR _srcVLine$[ebp], ecx

; 319  :     Tout *dstLine = (Tout *)dst[1] + (dst_y_pitch >> 1) * y_range.start_dst;

  0027d	ba 04 00 00 00	 mov	 edx, 4
  00282	c1 e2 00	 shl	 edx, 0
  00285	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  00288	d1 f8		 sar	 eax, 1
  0028a	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  0028e	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  00291	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  00294	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  00297	89 45 a0	 mov	 DWORD PTR _dstLine$[ebp], eax

; 320  :     for (int y = 0; y < y_range.len; y += 2, srcULine += src_uv_pitch * 2, srcVLine += src_uv_pitch * 2, dstLine += dst_y_pitch) {

  0029a	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR _y$17[ebp], 0
  002a1	eb 31		 jmp	 SHORT $LN10@convert_yu
$LN8@convert_yu:
  002a3	8b 4d 9c	 mov	 ecx, DWORD PTR _y$17[ebp]
  002a6	83 c1 02	 add	 ecx, 2
  002a9	89 4d 9c	 mov	 DWORD PTR _y$17[ebp], ecx
  002ac	8b 55 ac	 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  002af	d1 e2		 shl	 edx, 1
  002b1	8b 45 a8	 mov	 eax, DWORD PTR _srcULine$[ebp]
  002b4	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  002b7	89 4d a8	 mov	 DWORD PTR _srcULine$[ebp], ecx
  002ba	8b 55 ac	 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  002bd	d1 e2		 shl	 edx, 1
  002bf	8b 45 a4	 mov	 eax, DWORD PTR _srcVLine$[ebp]
  002c2	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  002c5	89 4d a4	 mov	 DWORD PTR _srcVLine$[ebp], ecx
  002c8	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  002cb	8b 45 a0	 mov	 eax, DWORD PTR _dstLine$[ebp]
  002ce	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  002d1	89 4d a0	 mov	 DWORD PTR _dstLine$[ebp], ecx
$LN10@convert_yu:
  002d4	8b 55 9c	 mov	 edx, DWORD PTR _y$17[ebp]
  002d7	3b 55 dc	 cmp	 edx, DWORD PTR _y_range$[ebp+8]
  002da	0f 8d 3a 01 00
	00		 jge	 $LN1@convert_yu

; 321  :         Tout *dstC = dstLine;

  002e0	8b 45 a0	 mov	 eax, DWORD PTR _dstLine$[ebp]
  002e3	89 45 98	 mov	 DWORD PTR _dstC$16[ebp], eax

; 322  :         Tin *srcU = srcULine;

  002e6	8b 4d a8	 mov	 ecx, DWORD PTR _srcULine$[ebp]
  002e9	89 4d 94	 mov	 DWORD PTR _srcU$15[ebp], ecx

; 323  :         Tin *srcV = srcVLine;

  002ec	8b 55 a4	 mov	 edx, DWORD PTR _srcVLine$[ebp]
  002ef	89 55 90	 mov	 DWORD PTR _srcV$14[ebp], edx

; 324  :         const int x_fin = width - crop_right - crop_left;

  002f2	8b 45 10	 mov	 eax, DWORD PTR _width$[ebp]
  002f5	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  002f8	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  002fb	89 45 8c	 mov	 DWORD PTR _x_fin$13[ebp], eax

; 325  :         for (int x = 0; x < x_fin; x += 2, dstC += 2, srcU += 2, srcV += 2) {

  002fe	c7 45 88 00 00
	00 00		 mov	 DWORD PTR _x$12[ebp], 0
  00305	eb 24		 jmp	 SHORT $LN13@convert_yu
$LN11@convert_yu:
  00307	8b 4d 88	 mov	 ecx, DWORD PTR _x$12[ebp]
  0030a	83 c1 02	 add	 ecx, 2
  0030d	89 4d 88	 mov	 DWORD PTR _x$12[ebp], ecx
  00310	8b 55 98	 mov	 edx, DWORD PTR _dstC$16[ebp]
  00313	83 c2 04	 add	 edx, 4
  00316	89 55 98	 mov	 DWORD PTR _dstC$16[ebp], edx
  00319	8b 45 94	 mov	 eax, DWORD PTR _srcU$15[ebp]
  0031c	83 c0 04	 add	 eax, 4
  0031f	89 45 94	 mov	 DWORD PTR _srcU$15[ebp], eax
  00322	8b 4d 90	 mov	 ecx, DWORD PTR _srcV$14[ebp]
  00325	83 c1 04	 add	 ecx, 4
  00328	89 4d 90	 mov	 DWORD PTR _srcV$14[ebp], ecx
$LN13@convert_yu:
  0032b	8b 55 88	 mov	 edx, DWORD PTR _x$12[ebp]
  0032e	3b 55 8c	 cmp	 edx, DWORD PTR _x_fin$13[ebp]
  00331	0f 8d de 00 00
	00		 jge	 $LN12@convert_yu

; 326  :             int cy0u = srcU[0*src_uv_pitch + 0];

  00337	6b 45 ac 00	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp], 0
  0033b	8b 4d 94	 mov	 ecx, DWORD PTR _srcU$15[ebp]
  0033e	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  00342	89 55 84	 mov	 DWORD PTR _cy0u$11[ebp], edx

; 327  :             int cy0v = srcV[0*src_uv_pitch + 0];

  00345	6b 45 ac 00	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp], 0
  00349	8b 4d 90	 mov	 ecx, DWORD PTR _srcV$14[ebp]
  0034c	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  00350	89 55 80	 mov	 DWORD PTR _cy0v$10[ebp], edx

; 328  :             int cy1u = srcU[1*src_uv_pitch + 0];

  00353	8b 45 ac	 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  00356	8b 4d 94	 mov	 ecx, DWORD PTR _srcU$15[ebp]
  00359	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  0035d	89 95 7c ff ff
	ff		 mov	 DWORD PTR _cy1u$9[ebp], edx

; 329  :             int cy1v = srcV[1*src_uv_pitch + 0];

  00363	8b 45 ac	 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  00366	8b 4d 90	 mov	 ecx, DWORD PTR _srcV$14[ebp]
  00369	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  0036d	89 95 78 ff ff
	ff		 mov	 DWORD PTR _cy1v$8[ebp], edx

; 330  : 
; 331  :             int cu = cy0u + cy1u + 1;

  00373	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _cy1u$9[ebp]
  00379	8b 4d 84	 mov	 ecx, DWORD PTR _cy0u$11[ebp]
  0037c	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  00380	89 95 74 ff ff
	ff		 mov	 DWORD PTR _cu$7[ebp], edx

; 332  :             int cv = cy0v + cy1v + 1;

  00386	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _cy1v$8[ebp]
  0038c	8b 4d 80	 mov	 ecx, DWORD PTR _cy0v$10[ebp]
  0038f	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  00393	89 95 70 ff ff
	ff		 mov	 DWORD PTR _cv$6[ebp], edx

; 333  :             CHANGE_BIT_DEPTH_2(cu, cv, 1);

  00399	b8 01 00 00 00	 mov	 eax, 1
  0039e	85 c0		 test	 eax, eax
  003a0	74 20		 je	 SHORT $LN21@convert_yu
  003a2	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _cu$7[ebp]
  003a8	c1 e1 03	 shl	 ecx, 3
  003ab	89 8d 74 ff ff
	ff		 mov	 DWORD PTR _cu$7[ebp], ecx
  003b1	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR _cv$6[ebp]
  003b7	c1 e2 03	 shl	 edx, 3
  003ba	89 95 70 ff ff
	ff		 mov	 DWORD PTR _cv$6[ebp], edx
  003c0	eb 22		 jmp	 SHORT $LN22@convert_yu
$LN21@convert_yu:
  003c2	33 c0		 xor	 eax, eax
  003c4	74 1e		 je	 SHORT $LN22@convert_yu
  003c6	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _cu$7[ebp]
  003cc	c1 f9 fd	 sar	 ecx, -3			; fffffffdH
  003cf	89 8d 74 ff ff
	ff		 mov	 DWORD PTR _cu$7[ebp], ecx
  003d5	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR _cv$6[ebp]
  003db	c1 fa fd	 sar	 edx, -3			; fffffffdH
  003de	89 95 70 ff ff
	ff		 mov	 DWORD PTR _cv$6[ebp], edx
$LN22@convert_yu:

; 334  : 
; 335  :             dstC[0] = (Tout)cu;

  003e4	b8 02 00 00 00	 mov	 eax, 2
  003e9	6b c8 00	 imul	 ecx, eax, 0
  003ec	8b 55 98	 mov	 edx, DWORD PTR _dstC$16[ebp]
  003ef	66 8b 85 74 ff
	ff ff		 mov	 ax, WORD PTR _cu$7[ebp]
  003f6	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax

; 336  :             dstC[1] = (Tout)cv;

  003fa	b9 02 00 00 00	 mov	 ecx, 2
  003ff	c1 e1 00	 shl	 ecx, 0
  00402	8b 55 98	 mov	 edx, DWORD PTR _dstC$16[ebp]
  00405	66 8b 85 70 ff
	ff ff		 mov	 ax, WORD PTR _cv$6[ebp]
  0040c	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax

; 337  :         }

  00410	e9 f2 fe ff ff	 jmp	 $LN11@convert_yu
$LN12@convert_yu:

; 338  :     }

  00415	e9 89 fe ff ff	 jmp	 $LN8@convert_yu
$LN1@convert_yu:

; 339  : }

  0041a	52		 push	 edx
  0041b	8b cd		 mov	 ecx, ebp
  0041d	50		 push	 eax
  0041e	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN27@convert_yu
  00424	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00429	58		 pop	 eax
  0042a	5a		 pop	 edx
  0042b	5f		 pop	 edi
  0042c	5e		 pop	 esi
  0042d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00430	33 cd		 xor	 ecx, ebp
  00432	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00437	81 c4 ac 00 00
	00		 add	 esp, 172		; 000000acH
  0043d	3b ec		 cmp	 ebp, esp
  0043f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00444	8b e5		 mov	 esp, ebp
  00446	5d		 pop	 ebp
  00447	c3		 ret	 0
$LN27@convert_yu:
  00448	01 00 00 00	 DD	 1
  0044c	00 00 00 00	 DD	 $LN26@convert_yu
$LN26@convert_yu:
  00450	d4 ff ff ff	 DD	 -44			; ffffffd4H
  00454	0c 00 00 00	 DD	 12			; 0000000cH
  00458	00 00 00 00	 DD	 $LN25@convert_yu
$LN25@convert_yu:
  0045c	79		 DB	 121			; 00000079H
  0045d	5f		 DB	 95			; 0000005fH
  0045e	72		 DB	 114			; 00000072H
  0045f	61		 DB	 97			; 00000061H
  00460	6e		 DB	 110			; 0000006eH
  00461	67		 DB	 103			; 00000067H
  00462	65		 DB	 101			; 00000065H
  00463	00		 DB	 0
??$convert_yuv444_to_nv12_p_c@G$0M@G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_to_nv12_p_c<unsigned short,12,unsigned short,16,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuv444_12_to_p010_p@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_12_to_p010_p

; 480  : static void convert_yuv444_12_to_p010_p(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 481  :     convert_yuv444_to_nv12_p_c<uint16_t, 12, uint16_t, 16, false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yuv444_to_nv12_p_c@G$0M@G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_to_nv12_p_c<unsigned short,12,unsigned short,16,0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 482  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yuv444_12_to_p010_p@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_12_to_p010_p
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
$T1 = -200						; size = 4
$T2 = -196						; size = 4
$T3 = -192						; size = 4
$T4 = -188						; size = 4
$T5 = -184						; size = 12
_cv_y1$6 = -172						; size = 4
_cv_y0$7 = -168						; size = 4
_cu_y1$8 = -164						; size = 4
_cu_y0$9 = -160						; size = 4
_cy3v$10 = -156						; size = 4
_cy3u$11 = -152						; size = 4
_cy2v$12 = -148						; size = 4
_cy2u$13 = -144						; size = 4
_cy1v$14 = -140						; size = 4
_cy1u$15 = -136						; size = 4
_cy0v$16 = -132						; size = 4
_cy0u$17 = -128						; size = 4
_x$18 = -124						; size = 4
_x_fin$19 = -120					; size = 4
_srcV$20 = -116						; size = 4
_srcU$21 = -112						; size = 4
_dstC$22 = -108						; size = 4
_y$23 = -104						; size = 4
_uv_fin$ = -100						; size = 4
_dstLine$ = -96						; size = 4
_srcVLine$ = -92					; size = 4
_srcULine$ = -88					; size = 4
_src_uv_pitch$ = -84					; size = 4
_x$24 = -80						; size = 4
_y$25 = -76						; size = 4
_y_width$26 = -72					; size = 4
_dstLine$27 = -68					; size = 4
_srcYLine$28 = -64					; size = 4
$T29 = -60						; size = 12
_y_range$ = -44						; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yuv444_to_nv12_i_c@G$0O@G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_to_nv12_i_c<unsigned short,14,unsigned short,16,0>

; 342  : static void __forceinline convert_yuv444_to_nv12_i_c(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8d bd 38 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-200]
  00011	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 343  :     static_assert((sizeof(Tin)  == 1 && in_bit_depth  == 8) || (sizeof(Tin)  == 2 && 8 < in_bit_depth  && in_bit_depth  <= 16), "invalid input bit depth.");
; 344  :     static_assert((sizeof(Tout) == 1 && out_bit_depth == 8) || (sizeof(Tout) == 2 && 8 < out_bit_depth && out_bit_depth <= 16), "invalid output bit depth.");
; 345  :     const int crop_left   = crop[0];

  00027	b8 04 00 00 00	 mov	 eax, 4
  0002c	6b c8 00	 imul	 ecx, eax, 0
  0002f	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00032	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00035	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 346  :     const int crop_up     = crop[1];

  00038	b9 04 00 00 00	 mov	 ecx, 4
  0003d	c1 e1 00	 shl	 ecx, 0
  00040	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00043	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00046	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 347  :     const int crop_right  = crop[2];

  00049	b9 04 00 00 00	 mov	 ecx, 4
  0004e	d1 e1		 shl	 ecx, 1
  00050	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00053	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00056	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 348  :     const int crop_bottom = crop[3];

  00059	b9 04 00 00 00	 mov	 ecx, 4
  0005e	6b d1 03	 imul	 edx, ecx, 3
  00061	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00064	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00067	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 349  :     const int src_y_pitch = src_y_pitch_byte / sizeof(Tin);

  0006a	8b 55 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebp]
  0006d	d1 ea		 shr	 edx, 1
  0006f	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 350  :     const int dst_y_pitch = dst_y_pitch_byte / sizeof(Tout);

  00072	8b 45 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  00075	d1 e8		 shr	 eax, 1
  00077	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 351  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  0007a	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0007d	51		 push	 ecx
  0007e	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  00081	52		 push	 edx
  00082	8b 45 20	 mov	 eax, DWORD PTR _height$[ebp]
  00085	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  00088	50		 push	 eax
  00089	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  0008c	51		 push	 ecx
  0008d	8d 95 48 ff ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  00093	52		 push	 edx
  00094	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00099	83 c4 14	 add	 esp, 20			; 00000014H
  0009c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009e	89 4d c4	 mov	 DWORD PTR $T29[ebp], ecx
  000a1	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a4	89 55 c8	 mov	 DWORD PTR $T29[ebp+4], edx
  000a7	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000aa	89 45 cc	 mov	 DWORD PTR $T29[ebp+8], eax
  000ad	8b 4d c4	 mov	 ecx, DWORD PTR $T29[ebp]
  000b0	89 4d d4	 mov	 DWORD PTR _y_range$[ebp], ecx
  000b3	8b 55 c8	 mov	 edx, DWORD PTR $T29[ebp+4]
  000b6	89 55 d8	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000b9	8b 45 cc	 mov	 eax, DWORD PTR $T29[ebp+8]
  000bc	89 45 dc	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 352  :     //Y
; 353  :     if (!uv_only) {

  000bf	b9 01 00 00 00	 mov	 ecx, 1
  000c4	85 c9		 test	 ecx, ecx
  000c6	0f 84 6e 01 00
	00		 je	 $LN14@convert_yu

; 354  :         Tin *srcYLine = (Tin *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000cc	ba 04 00 00 00	 mov	 edx, 4
  000d1	6b c2 00	 imul	 eax, edx, 0
  000d4	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  000d7	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  000db	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  000de	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  000e1	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  000e4	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  000e7	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  000ea	89 45 c0	 mov	 DWORD PTR _srcYLine$28[ebp], eax

; 355  :         Tout *dstLine = (Tout *)dst[0] + dst_y_pitch * y_range.start_dst;

  000ed	b9 04 00 00 00	 mov	 ecx, 4
  000f2	6b d1 00	 imul	 edx, ecx, 0
  000f5	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  000f8	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  000fc	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  000ff	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  00102	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  00105	89 45 bc	 mov	 DWORD PTR _dstLine$27[ebp], eax

; 356  :         const int y_width = width - crop_right - crop_left;

  00108	8b 4d 10	 mov	 ecx, DWORD PTR _width$[ebp]
  0010b	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  0010e	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  00111	89 4d b8	 mov	 DWORD PTR _y_width$26[ebp], ecx

; 357  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  00114	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _y$25[ebp], 0
  0011b	eb 21		 jmp	 SHORT $LN4@convert_yu
$LN2@convert_yu:
  0011d	8b 55 b4	 mov	 edx, DWORD PTR _y$25[ebp]
  00120	83 c2 01	 add	 edx, 1
  00123	89 55 b4	 mov	 DWORD PTR _y$25[ebp], edx
  00126	8b 45 e8	 mov	 eax, DWORD PTR _src_y_pitch$[ebp]
  00129	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$28[ebp]
  0012c	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  0012f	89 55 c0	 mov	 DWORD PTR _srcYLine$28[ebp], edx
  00132	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  00135	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$27[ebp]
  00138	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  0013b	89 55 bc	 mov	 DWORD PTR _dstLine$27[ebp], edx
$LN4@convert_yu:
  0013e	8b 45 b4	 mov	 eax, DWORD PTR _y$25[ebp]
  00141	3b 45 dc	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  00144	0f 8d f0 00 00
	00		 jge	 $LN14@convert_yu

; 358  :             if (in_bit_depth == out_bit_depth && sizeof(Tin) == sizeof(Tout)) {

  0014a	33 c9		 xor	 ecx, ecx
  0014c	74 1b		 je	 SHORT $LN15@convert_yu

; 359  :                 memcpy(dstLine, srcYLine, y_width * sizeof(Tin));

  0014e	8b 55 b8	 mov	 edx, DWORD PTR _y_width$26[ebp]
  00151	d1 e2		 shl	 edx, 1
  00153	52		 push	 edx
  00154	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$28[ebp]
  00157	50		 push	 eax
  00158	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$27[ebp]
  0015b	51		 push	 ecx
  0015c	e8 00 00 00 00	 call	 _memcpy
  00161	83 c4 0c	 add	 esp, 12			; 0000000cH

; 360  :             } else {

  00164	e9 cc 00 00 00	 jmp	 $LN16@convert_yu
$LN15@convert_yu:

; 361  :                 for (int x = 0; x < y_width; x++) {

  00169	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _x$24[ebp], 0
  00170	eb 09		 jmp	 SHORT $LN7@convert_yu
$LN5@convert_yu:
  00172	8b 55 b0	 mov	 edx, DWORD PTR _x$24[ebp]
  00175	83 c2 01	 add	 edx, 1
  00178	89 55 b0	 mov	 DWORD PTR _x$24[ebp], edx
$LN7@convert_yu:
  0017b	8b 45 b0	 mov	 eax, DWORD PTR _x$24[ebp]
  0017e	3b 45 b8	 cmp	 eax, DWORD PTR _y_width$26[ebp]
  00181	0f 8d ae 00 00
	00		 jge	 $LN16@convert_yu

; 362  :                     if (out_bit_depth > in_bit_depth) {

  00187	b9 01 00 00 00	 mov	 ecx, 1
  0018c	85 c9		 test	 ecx, ecx
  0018e	74 44		 je	 SHORT $LN17@convert_yu

; 363  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) << std::max(out_bit_depth - in_bit_depth, 0));

  00190	c7 85 44 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], 0
  0019a	c7 85 40 ff ff
	ff 02 00 00 00	 mov	 DWORD PTR $T3[ebp], 2
  001a4	8b 55 b0	 mov	 edx, DWORD PTR _x$24[ebp]
  001a7	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$28[ebp]
  001aa	0f b7 34 50	 movzx	 esi, WORD PTR [eax+edx*2]
  001ae	8d 8d 44 ff ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  001b4	51		 push	 ecx
  001b5	8d 95 40 ff ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  001bb	52		 push	 edx
  001bc	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  001c1	83 c4 08	 add	 esp, 8
  001c4	8b 08		 mov	 ecx, DWORD PTR [eax]
  001c6	d3 e6		 shl	 esi, cl
  001c8	8b 45 b0	 mov	 eax, DWORD PTR _x$24[ebp]
  001cb	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$27[ebp]
  001ce	66 89 34 41	 mov	 WORD PTR [ecx+eax*2], si
  001d2	eb 5c		 jmp	 SHORT $LN18@convert_yu
$LN17@convert_yu:

; 364  :                     } else if (out_bit_depth < in_bit_depth) {

  001d4	33 d2		 xor	 edx, edx
  001d6	74 44		 je	 SHORT $LN19@convert_yu

; 365  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) >> std::max(in_bit_depth - out_bit_depth, 0));

  001d8	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], 0
  001e2	c7 85 38 ff ff
	ff fe ff ff ff	 mov	 DWORD PTR $T1[ebp], -2	; fffffffeH
  001ec	8b 45 b0	 mov	 eax, DWORD PTR _x$24[ebp]
  001ef	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$28[ebp]
  001f2	0f b7 34 41	 movzx	 esi, WORD PTR [ecx+eax*2]
  001f6	8d 95 3c ff ff
	ff		 lea	 edx, DWORD PTR $T2[ebp]
  001fc	52		 push	 edx
  001fd	8d 85 38 ff ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  00203	50		 push	 eax
  00204	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  00209	83 c4 08	 add	 esp, 8
  0020c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0020e	d3 fe		 sar	 esi, cl
  00210	8b 4d b0	 mov	 ecx, DWORD PTR _x$24[ebp]
  00213	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$27[ebp]
  00216	66 89 34 4a	 mov	 WORD PTR [edx+ecx*2], si

; 366  :                     } else {

  0021a	eb 14		 jmp	 SHORT $LN18@convert_yu
$LN19@convert_yu:

; 367  :                         dstLine[x] = (Tout)srcYLine[x];

  0021c	8b 45 b0	 mov	 eax, DWORD PTR _x$24[ebp]
  0021f	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$27[ebp]
  00222	8b 55 b0	 mov	 edx, DWORD PTR _x$24[ebp]
  00225	8b 75 c0	 mov	 esi, DWORD PTR _srcYLine$28[ebp]
  00228	66 8b 14 56	 mov	 dx, WORD PTR [esi+edx*2]
  0022c	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx
$LN18@convert_yu:

; 368  :                     }
; 369  :                 }

  00230	e9 3d ff ff ff	 jmp	 $LN5@convert_yu
$LN16@convert_yu:

; 370  :             }
; 371  :         }

  00235	e9 e3 fe ff ff	 jmp	 $LN2@convert_yu
$LN14@convert_yu:

; 372  :     }
; 373  :     //UV
; 374  :     const int src_uv_pitch = src_uv_pitch_byte / sizeof(Tin);

  0023a	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0023d	d1 e8		 shr	 eax, 1
  0023f	89 45 ac	 mov	 DWORD PTR _src_uv_pitch$[ebp], eax

; 375  :     Tin *srcULine = (Tin *)src[1] + ((src_uv_pitch * y_range.start_src) + crop_left);

  00242	b9 04 00 00 00	 mov	 ecx, 4
  00247	c1 e1 00	 shl	 ecx, 0
  0024a	8b 55 ac	 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  0024d	0f af 55 d4	 imul	 edx, DWORD PTR _y_range$[ebp]
  00251	03 55 f8	 add	 edx, DWORD PTR _crop_left$[ebp]
  00254	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  00257	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  0025a	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  0025d	89 55 a8	 mov	 DWORD PTR _srcULine$[ebp], edx

; 376  :     Tin *srcVLine = (Tin *)src[2] + ((src_uv_pitch * y_range.start_src) + crop_left);

  00260	b8 04 00 00 00	 mov	 eax, 4
  00265	d1 e0		 shl	 eax, 1
  00267	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  0026a	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  0026e	03 4d f8	 add	 ecx, DWORD PTR _crop_left$[ebp]
  00271	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  00274	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  00277	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  0027a	89 4d a4	 mov	 DWORD PTR _srcVLine$[ebp], ecx

; 377  :     Tout *dstLine = (Tout *)dst[1] + (dst_y_pitch >> 1) * y_range.start_dst;

  0027d	ba 04 00 00 00	 mov	 edx, 4
  00282	c1 e2 00	 shl	 edx, 0
  00285	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  00288	d1 f8		 sar	 eax, 1
  0028a	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  0028e	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  00291	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  00294	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  00297	89 45 a0	 mov	 DWORD PTR _dstLine$[ebp], eax

; 378  :     const int uv_fin = height - crop_bottom - crop_up;

  0029a	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  0029d	2b 4d ec	 sub	 ecx, DWORD PTR _crop_bottom$[ebp]
  002a0	2b 4d f4	 sub	 ecx, DWORD PTR _crop_up$[ebp]
  002a3	89 4d 9c	 mov	 DWORD PTR _uv_fin$[ebp], ecx

; 379  :     for (int y = 0; y < y_range.len; y += 4, srcULine += src_uv_pitch * 4, srcVLine += src_uv_pitch * 4, dstLine += dst_y_pitch * 2) {

  002a6	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _y$23[ebp], 0
  002ad	eb 35		 jmp	 SHORT $LN10@convert_yu
$LN8@convert_yu:
  002af	8b 55 98	 mov	 edx, DWORD PTR _y$23[ebp]
  002b2	83 c2 04	 add	 edx, 4
  002b5	89 55 98	 mov	 DWORD PTR _y$23[ebp], edx
  002b8	8b 45 ac	 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  002bb	c1 e0 02	 shl	 eax, 2
  002be	8b 4d a8	 mov	 ecx, DWORD PTR _srcULine$[ebp]
  002c1	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  002c4	89 55 a8	 mov	 DWORD PTR _srcULine$[ebp], edx
  002c7	8b 45 ac	 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  002ca	c1 e0 02	 shl	 eax, 2
  002cd	8b 4d a4	 mov	 ecx, DWORD PTR _srcVLine$[ebp]
  002d0	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  002d3	89 55 a4	 mov	 DWORD PTR _srcVLine$[ebp], edx
  002d6	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  002d9	d1 e0		 shl	 eax, 1
  002db	8b 4d a0	 mov	 ecx, DWORD PTR _dstLine$[ebp]
  002de	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  002e1	89 55 a0	 mov	 DWORD PTR _dstLine$[ebp], edx
$LN10@convert_yu:
  002e4	8b 45 98	 mov	 eax, DWORD PTR _y$23[ebp]
  002e7	3b 45 dc	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  002ea	0f 8d f1 01 00
	00		 jge	 $LN1@convert_yu

; 380  :         Tout *dstC = dstLine;

  002f0	8b 4d a0	 mov	 ecx, DWORD PTR _dstLine$[ebp]
  002f3	89 4d 94	 mov	 DWORD PTR _dstC$22[ebp], ecx

; 381  :         Tin *srcU = srcULine;

  002f6	8b 55 a8	 mov	 edx, DWORD PTR _srcULine$[ebp]
  002f9	89 55 90	 mov	 DWORD PTR _srcU$21[ebp], edx

; 382  :         Tin *srcV = srcVLine;

  002fc	8b 45 a4	 mov	 eax, DWORD PTR _srcVLine$[ebp]
  002ff	89 45 8c	 mov	 DWORD PTR _srcV$20[ebp], eax

; 383  :         const int x_fin = width - crop_right - crop_left;

  00302	8b 4d 10	 mov	 ecx, DWORD PTR _width$[ebp]
  00305	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  00308	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  0030b	89 4d 88	 mov	 DWORD PTR _x_fin$19[ebp], ecx

; 384  :         for (int x = 0; x < x_fin; x += 2, dstC += 2, srcU += 2, srcV += 2) {

  0030e	c7 45 84 00 00
	00 00		 mov	 DWORD PTR _x$18[ebp], 0
  00315	eb 24		 jmp	 SHORT $LN13@convert_yu
$LN11@convert_yu:
  00317	8b 55 84	 mov	 edx, DWORD PTR _x$18[ebp]
  0031a	83 c2 02	 add	 edx, 2
  0031d	89 55 84	 mov	 DWORD PTR _x$18[ebp], edx
  00320	8b 45 94	 mov	 eax, DWORD PTR _dstC$22[ebp]
  00323	83 c0 04	 add	 eax, 4
  00326	89 45 94	 mov	 DWORD PTR _dstC$22[ebp], eax
  00329	8b 4d 90	 mov	 ecx, DWORD PTR _srcU$21[ebp]
  0032c	83 c1 04	 add	 ecx, 4
  0032f	89 4d 90	 mov	 DWORD PTR _srcU$21[ebp], ecx
  00332	8b 55 8c	 mov	 edx, DWORD PTR _srcV$20[ebp]
  00335	83 c2 04	 add	 edx, 4
  00338	89 55 8c	 mov	 DWORD PTR _srcV$20[ebp], edx
$LN13@convert_yu:
  0033b	8b 45 84	 mov	 eax, DWORD PTR _x$18[ebp]
  0033e	3b 45 88	 cmp	 eax, DWORD PTR _x_fin$19[ebp]
  00341	0f 8d 95 01 00
	00		 jge	 $LN12@convert_yu

; 385  :             int cy0u = srcU[0*src_uv_pitch + 0];

  00347	6b 4d ac 00	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 0
  0034b	8b 55 90	 mov	 edx, DWORD PTR _srcU$21[ebp]
  0034e	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00352	89 45 80	 mov	 DWORD PTR _cy0u$17[ebp], eax

; 386  :             int cy0v = srcV[0*src_uv_pitch + 0];

  00355	6b 4d ac 00	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 0
  00359	8b 55 8c	 mov	 edx, DWORD PTR _srcV$20[ebp]
  0035c	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00360	89 85 7c ff ff
	ff		 mov	 DWORD PTR _cy0v$16[ebp], eax

; 387  :             int cy1u = srcU[1*src_uv_pitch + 0];

  00366	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00369	8b 55 90	 mov	 edx, DWORD PTR _srcU$21[ebp]
  0036c	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00370	89 85 78 ff ff
	ff		 mov	 DWORD PTR _cy1u$15[ebp], eax

; 388  :             int cy1v = srcV[1*src_uv_pitch + 0];

  00376	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00379	8b 55 8c	 mov	 edx, DWORD PTR _srcV$20[ebp]
  0037c	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00380	89 85 74 ff ff
	ff		 mov	 DWORD PTR _cy1v$14[ebp], eax

; 389  :             int cy2u = srcU[2*src_uv_pitch + 0];

  00386	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00389	d1 e1		 shl	 ecx, 1
  0038b	8b 55 90	 mov	 edx, DWORD PTR _srcU$21[ebp]
  0038e	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00392	89 85 70 ff ff
	ff		 mov	 DWORD PTR _cy2u$13[ebp], eax

; 390  :             int cy2v = srcV[2*src_uv_pitch + 0];

  00398	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  0039b	d1 e1		 shl	 ecx, 1
  0039d	8b 55 8c	 mov	 edx, DWORD PTR _srcV$20[ebp]
  003a0	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  003a4	89 85 6c ff ff
	ff		 mov	 DWORD PTR _cy2v$12[ebp], eax

; 391  :             int cy3u = srcU[3*src_uv_pitch + 0];

  003aa	6b 4d ac 03	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 3
  003ae	8b 55 90	 mov	 edx, DWORD PTR _srcU$21[ebp]
  003b1	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  003b5	89 85 68 ff ff
	ff		 mov	 DWORD PTR _cy3u$11[ebp], eax

; 392  :             int cy3v = srcV[3*src_uv_pitch + 0];

  003bb	6b 4d ac 03	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 3
  003bf	8b 55 8c	 mov	 edx, DWORD PTR _srcV$20[ebp]
  003c2	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  003c6	89 85 64 ff ff
	ff		 mov	 DWORD PTR _cy3v$10[ebp], eax

; 393  : 
; 394  :             int cu_y0 = cy0u * 3 + cy2u * 1 + 2;

  003cc	6b 4d 80 03	 imul	 ecx, DWORD PTR _cy0u$17[ebp], 3
  003d0	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR _cy2u$13[ebp]
  003d6	8d 44 11 02	 lea	 eax, DWORD PTR [ecx+edx+2]
  003da	89 85 60 ff ff
	ff		 mov	 DWORD PTR _cu_y0$9[ebp], eax

; 395  :             int cu_y1 = cy1u * 1 + cy3u * 3 + 2;

  003e0	6b 8d 68 ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy3u$11[ebp], 3
  003e7	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _cy1u$15[ebp]
  003ed	8d 44 0a 02	 lea	 eax, DWORD PTR [edx+ecx+2]
  003f1	89 85 5c ff ff
	ff		 mov	 DWORD PTR _cu_y1$8[ebp], eax

; 396  :             int cv_y0 = cy0v * 3 + cy2v * 1 + 2;

  003f7	6b 8d 7c ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy0v$16[ebp], 3
  003fe	8b 95 6c ff ff
	ff		 mov	 edx, DWORD PTR _cy2v$12[ebp]
  00404	8d 44 11 02	 lea	 eax, DWORD PTR [ecx+edx+2]
  00408	89 85 58 ff ff
	ff		 mov	 DWORD PTR _cv_y0$7[ebp], eax

; 397  :             int cv_y1 = cy1v * 1 + cy3v * 3 + 2;

  0040e	6b 8d 64 ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy3v$10[ebp], 3
  00415	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _cy1v$14[ebp]
  0041b	8d 44 0a 02	 lea	 eax, DWORD PTR [edx+ecx+2]
  0041f	89 85 54 ff ff
	ff		 mov	 DWORD PTR _cv_y1$6[ebp], eax

; 398  :             CHANGE_BIT_DEPTH_4(cu_y0, cu_y1, cv_y0, cv_y1, 2);

  00425	33 c9		 xor	 ecx, ecx
  00427	74 32		 je	 SHORT $LN21@convert_yu
  00429	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _cu_y0$9[ebp]
  0042f	89 95 60 ff ff
	ff		 mov	 DWORD PTR _cu_y0$9[ebp], edx
  00435	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _cu_y1$8[ebp]
  0043b	89 85 5c ff ff
	ff		 mov	 DWORD PTR _cu_y1$8[ebp], eax
  00441	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _cv_y0$7[ebp]
  00447	89 8d 58 ff ff
	ff		 mov	 DWORD PTR _cv_y0$7[ebp], ecx
  0044d	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR _cv_y1$6[ebp]
  00453	89 95 54 ff ff
	ff		 mov	 DWORD PTR _cv_y1$6[ebp], edx
  00459	eb 34		 jmp	 SHORT $LN22@convert_yu
$LN21@convert_yu:
  0045b	33 c0		 xor	 eax, eax
  0045d	74 30		 je	 SHORT $LN22@convert_yu
  0045f	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _cu_y0$9[ebp]
  00465	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _cu_y0$9[ebp], ecx
  0046b	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR _cu_y1$8[ebp]
  00471	89 95 5c ff ff
	ff		 mov	 DWORD PTR _cu_y1$8[ebp], edx
  00477	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _cv_y0$7[ebp]
  0047d	89 85 58 ff ff
	ff		 mov	 DWORD PTR _cv_y0$7[ebp], eax
  00483	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _cv_y1$6[ebp]
  00489	89 8d 54 ff ff
	ff		 mov	 DWORD PTR _cv_y1$6[ebp], ecx
$LN22@convert_yu:

; 399  : 
; 400  :             dstC[0*dst_y_pitch + 0] = (Tout)cu_y0;

  0048f	6b 55 e4 00	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 0
  00493	8b 45 94	 mov	 eax, DWORD PTR _dstC$22[ebp]
  00496	66 8b 8d 60 ff
	ff ff		 mov	 cx, WORD PTR _cu_y0$9[ebp]
  0049d	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx

; 401  :             dstC[0*dst_y_pitch + 1] = (Tout)cv_y0;

  004a1	6b 55 e4 00	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 0
  004a5	8b 45 94	 mov	 eax, DWORD PTR _dstC$22[ebp]
  004a8	66 8b 8d 58 ff
	ff ff		 mov	 cx, WORD PTR _cv_y0$7[ebp]
  004af	66 89 4c 50 02	 mov	 WORD PTR [eax+edx*2+2], cx

; 402  :             dstC[1*dst_y_pitch + 0] = (Tout)cu_y1;

  004b4	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  004b7	8b 45 94	 mov	 eax, DWORD PTR _dstC$22[ebp]
  004ba	66 8b 8d 5c ff
	ff ff		 mov	 cx, WORD PTR _cu_y1$8[ebp]
  004c1	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx

; 403  :             dstC[1*dst_y_pitch + 1] = (Tout)cv_y1;

  004c5	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  004c8	8b 45 94	 mov	 eax, DWORD PTR _dstC$22[ebp]
  004cb	66 8b 8d 54 ff
	ff ff		 mov	 cx, WORD PTR _cv_y1$6[ebp]
  004d2	66 89 4c 50 02	 mov	 WORD PTR [eax+edx*2+2], cx

; 404  :         }

  004d7	e9 3b fe ff ff	 jmp	 $LN11@convert_yu
$LN12@convert_yu:

; 405  :     }

  004dc	e9 ce fd ff ff	 jmp	 $LN8@convert_yu
$LN1@convert_yu:

; 406  : }

  004e1	52		 push	 edx
  004e2	8b cd		 mov	 ecx, ebp
  004e4	50		 push	 eax
  004e5	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN27@convert_yu
  004eb	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  004f0	58		 pop	 eax
  004f1	5a		 pop	 edx
  004f2	5f		 pop	 edi
  004f3	5e		 pop	 esi
  004f4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004f7	33 cd		 xor	 ecx, ebp
  004f9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004fe	81 c4 c8 00 00
	00		 add	 esp, 200		; 000000c8H
  00504	3b ec		 cmp	 ebp, esp
  00506	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0050b	8b e5		 mov	 esp, ebp
  0050d	5d		 pop	 ebp
  0050e	c3		 ret	 0
  0050f	90		 npad	 1
$LN27@convert_yu:
  00510	01 00 00 00	 DD	 1
  00514	00 00 00 00	 DD	 $LN26@convert_yu
$LN26@convert_yu:
  00518	d4 ff ff ff	 DD	 -44			; ffffffd4H
  0051c	0c 00 00 00	 DD	 12			; 0000000cH
  00520	00 00 00 00	 DD	 $LN25@convert_yu
$LN25@convert_yu:
  00524	79		 DB	 121			; 00000079H
  00525	5f		 DB	 95			; 0000005fH
  00526	72		 DB	 114			; 00000072H
  00527	61		 DB	 97			; 00000061H
  00528	6e		 DB	 110			; 0000006eH
  00529	67		 DB	 103			; 00000067H
  0052a	65		 DB	 101			; 00000065H
  0052b	00		 DB	 0
??$convert_yuv444_to_nv12_i_c@G$0O@G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_to_nv12_i_c<unsigned short,14,unsigned short,16,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuv444_14_to_p010_i@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_14_to_p010_i

; 476  : static void convert_yuv444_14_to_p010_i(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 477  :     convert_yuv444_to_nv12_i_c<uint16_t, 14, uint16_t, 16, false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yuv444_to_nv12_i_c@G$0O@G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_to_nv12_i_c<unsigned short,14,unsigned short,16,0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 478  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yuv444_14_to_p010_i@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_14_to_p010_i
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
$T1 = -172						; size = 4
$T2 = -168						; size = 4
$T3 = -164						; size = 4
$T4 = -160						; size = 4
$T5 = -156						; size = 12
_cv$6 = -144						; size = 4
_cu$7 = -140						; size = 4
_cy1v$8 = -136						; size = 4
_cy1u$9 = -132						; size = 4
_cy0v$10 = -128						; size = 4
_cy0u$11 = -124						; size = 4
_x$12 = -120						; size = 4
_x_fin$13 = -116					; size = 4
_srcV$14 = -112						; size = 4
_srcU$15 = -108						; size = 4
_dstC$16 = -104						; size = 4
_y$17 = -100						; size = 4
_dstLine$ = -96						; size = 4
_srcVLine$ = -92					; size = 4
_srcULine$ = -88					; size = 4
_src_uv_pitch$ = -84					; size = 4
_x$18 = -80						; size = 4
_y$19 = -76						; size = 4
_y_width$20 = -72					; size = 4
_dstLine$21 = -68					; size = 4
_srcYLine$22 = -64					; size = 4
$T23 = -60						; size = 12
_y_range$ = -44						; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yuv444_to_nv12_p_c@G$0O@G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_to_nv12_p_c<unsigned short,14,unsigned short,16,0>

; 284  : static void __forceinline convert_yuv444_to_nv12_p_c(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec ac 00 00
	00		 sub	 esp, 172		; 000000acH
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8d bd 54 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-172]
  00011	b9 2b 00 00 00	 mov	 ecx, 43			; 0000002bH
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 285  :     static_assert((sizeof(Tin)  == 1 && in_bit_depth  == 8) || (sizeof(Tin)  == 2 && 8 < in_bit_depth  && in_bit_depth  <= 16), "invalid input bit depth.");
; 286  :     static_assert((sizeof(Tout) == 1 && out_bit_depth == 8) || (sizeof(Tout) == 2 && 8 < out_bit_depth && out_bit_depth <= 16), "invalid output bit depth.");
; 287  :     const int crop_left   = crop[0];

  00027	b8 04 00 00 00	 mov	 eax, 4
  0002c	6b c8 00	 imul	 ecx, eax, 0
  0002f	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00032	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00035	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 288  :     const int crop_up     = crop[1];

  00038	b9 04 00 00 00	 mov	 ecx, 4
  0003d	c1 e1 00	 shl	 ecx, 0
  00040	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00043	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00046	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 289  :     const int crop_right  = crop[2];

  00049	b9 04 00 00 00	 mov	 ecx, 4
  0004e	d1 e1		 shl	 ecx, 1
  00050	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00053	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00056	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 290  :     const int crop_bottom = crop[3];

  00059	b9 04 00 00 00	 mov	 ecx, 4
  0005e	6b d1 03	 imul	 edx, ecx, 3
  00061	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00064	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00067	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 291  :     const int src_y_pitch = src_y_pitch_byte / sizeof(Tin);

  0006a	8b 55 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebp]
  0006d	d1 ea		 shr	 edx, 1
  0006f	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 292  :     const int dst_y_pitch = dst_y_pitch_byte / sizeof(Tout);

  00072	8b 45 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  00075	d1 e8		 shr	 eax, 1
  00077	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 293  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  0007a	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0007d	51		 push	 ecx
  0007e	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  00081	52		 push	 edx
  00082	8b 45 20	 mov	 eax, DWORD PTR _height$[ebp]
  00085	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  00088	50		 push	 eax
  00089	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  0008c	51		 push	 ecx
  0008d	8d 95 64 ff ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  00093	52		 push	 edx
  00094	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00099	83 c4 14	 add	 esp, 20			; 00000014H
  0009c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009e	89 4d c4	 mov	 DWORD PTR $T23[ebp], ecx
  000a1	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a4	89 55 c8	 mov	 DWORD PTR $T23[ebp+4], edx
  000a7	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000aa	89 45 cc	 mov	 DWORD PTR $T23[ebp+8], eax
  000ad	8b 4d c4	 mov	 ecx, DWORD PTR $T23[ebp]
  000b0	89 4d d4	 mov	 DWORD PTR _y_range$[ebp], ecx
  000b3	8b 55 c8	 mov	 edx, DWORD PTR $T23[ebp+4]
  000b6	89 55 d8	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000b9	8b 45 cc	 mov	 eax, DWORD PTR $T23[ebp+8]
  000bc	89 45 dc	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 294  :     //Y
; 295  :     if (!uv_only) {

  000bf	b9 01 00 00 00	 mov	 ecx, 1
  000c4	85 c9		 test	 ecx, ecx
  000c6	0f 84 6e 01 00
	00		 je	 $LN14@convert_yu

; 296  :         Tin *srcYLine = (Tin *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000cc	ba 04 00 00 00	 mov	 edx, 4
  000d1	6b c2 00	 imul	 eax, edx, 0
  000d4	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  000d7	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  000db	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  000de	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  000e1	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  000e4	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  000e7	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  000ea	89 45 c0	 mov	 DWORD PTR _srcYLine$22[ebp], eax

; 297  :         Tout *dstLine = (Tout *)dst[0] + dst_y_pitch * y_range.start_dst;

  000ed	b9 04 00 00 00	 mov	 ecx, 4
  000f2	6b d1 00	 imul	 edx, ecx, 0
  000f5	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  000f8	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  000fc	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  000ff	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  00102	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  00105	89 45 bc	 mov	 DWORD PTR _dstLine$21[ebp], eax

; 298  :         const int y_width = width - crop_right - crop_left;

  00108	8b 4d 10	 mov	 ecx, DWORD PTR _width$[ebp]
  0010b	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  0010e	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  00111	89 4d b8	 mov	 DWORD PTR _y_width$20[ebp], ecx

; 299  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  00114	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _y$19[ebp], 0
  0011b	eb 21		 jmp	 SHORT $LN4@convert_yu
$LN2@convert_yu:
  0011d	8b 55 b4	 mov	 edx, DWORD PTR _y$19[ebp]
  00120	83 c2 01	 add	 edx, 1
  00123	89 55 b4	 mov	 DWORD PTR _y$19[ebp], edx
  00126	8b 45 e8	 mov	 eax, DWORD PTR _src_y_pitch$[ebp]
  00129	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$22[ebp]
  0012c	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  0012f	89 55 c0	 mov	 DWORD PTR _srcYLine$22[ebp], edx
  00132	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  00135	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$21[ebp]
  00138	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  0013b	89 55 bc	 mov	 DWORD PTR _dstLine$21[ebp], edx
$LN4@convert_yu:
  0013e	8b 45 b4	 mov	 eax, DWORD PTR _y$19[ebp]
  00141	3b 45 dc	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  00144	0f 8d f0 00 00
	00		 jge	 $LN14@convert_yu

; 300  :             if (in_bit_depth == out_bit_depth && sizeof(Tin) == sizeof(Tout)) {

  0014a	33 c9		 xor	 ecx, ecx
  0014c	74 1b		 je	 SHORT $LN15@convert_yu

; 301  :                 memcpy(dstLine, srcYLine, y_width * sizeof(Tin));

  0014e	8b 55 b8	 mov	 edx, DWORD PTR _y_width$20[ebp]
  00151	d1 e2		 shl	 edx, 1
  00153	52		 push	 edx
  00154	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$22[ebp]
  00157	50		 push	 eax
  00158	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$21[ebp]
  0015b	51		 push	 ecx
  0015c	e8 00 00 00 00	 call	 _memcpy
  00161	83 c4 0c	 add	 esp, 12			; 0000000cH

; 302  :             } else {

  00164	e9 cc 00 00 00	 jmp	 $LN16@convert_yu
$LN15@convert_yu:

; 303  :                 for (int x = 0; x < y_width; x++) {

  00169	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _x$18[ebp], 0
  00170	eb 09		 jmp	 SHORT $LN7@convert_yu
$LN5@convert_yu:
  00172	8b 55 b0	 mov	 edx, DWORD PTR _x$18[ebp]
  00175	83 c2 01	 add	 edx, 1
  00178	89 55 b0	 mov	 DWORD PTR _x$18[ebp], edx
$LN7@convert_yu:
  0017b	8b 45 b0	 mov	 eax, DWORD PTR _x$18[ebp]
  0017e	3b 45 b8	 cmp	 eax, DWORD PTR _y_width$20[ebp]
  00181	0f 8d ae 00 00
	00		 jge	 $LN16@convert_yu

; 304  :                     if (out_bit_depth > in_bit_depth) {

  00187	b9 01 00 00 00	 mov	 ecx, 1
  0018c	85 c9		 test	 ecx, ecx
  0018e	74 44		 je	 SHORT $LN17@convert_yu

; 305  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) << std::max(out_bit_depth - in_bit_depth, 0));

  00190	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], 0
  0019a	c7 85 5c ff ff
	ff 02 00 00 00	 mov	 DWORD PTR $T3[ebp], 2
  001a4	8b 55 b0	 mov	 edx, DWORD PTR _x$18[ebp]
  001a7	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$22[ebp]
  001aa	0f b7 34 50	 movzx	 esi, WORD PTR [eax+edx*2]
  001ae	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  001b4	51		 push	 ecx
  001b5	8d 95 5c ff ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  001bb	52		 push	 edx
  001bc	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  001c1	83 c4 08	 add	 esp, 8
  001c4	8b 08		 mov	 ecx, DWORD PTR [eax]
  001c6	d3 e6		 shl	 esi, cl
  001c8	8b 45 b0	 mov	 eax, DWORD PTR _x$18[ebp]
  001cb	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$21[ebp]
  001ce	66 89 34 41	 mov	 WORD PTR [ecx+eax*2], si
  001d2	eb 5c		 jmp	 SHORT $LN18@convert_yu
$LN17@convert_yu:

; 306  :                     } else if (out_bit_depth < in_bit_depth) {

  001d4	33 d2		 xor	 edx, edx
  001d6	74 44		 je	 SHORT $LN19@convert_yu

; 307  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) >> std::max(in_bit_depth - out_bit_depth, 0));

  001d8	c7 85 58 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], 0
  001e2	c7 85 54 ff ff
	ff fe ff ff ff	 mov	 DWORD PTR $T1[ebp], -2	; fffffffeH
  001ec	8b 45 b0	 mov	 eax, DWORD PTR _x$18[ebp]
  001ef	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$22[ebp]
  001f2	0f b7 34 41	 movzx	 esi, WORD PTR [ecx+eax*2]
  001f6	8d 95 58 ff ff
	ff		 lea	 edx, DWORD PTR $T2[ebp]
  001fc	52		 push	 edx
  001fd	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  00203	50		 push	 eax
  00204	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  00209	83 c4 08	 add	 esp, 8
  0020c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0020e	d3 fe		 sar	 esi, cl
  00210	8b 4d b0	 mov	 ecx, DWORD PTR _x$18[ebp]
  00213	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$21[ebp]
  00216	66 89 34 4a	 mov	 WORD PTR [edx+ecx*2], si

; 308  :                     } else {

  0021a	eb 14		 jmp	 SHORT $LN18@convert_yu
$LN19@convert_yu:

; 309  :                         dstLine[x] = (Tout)srcYLine[x];

  0021c	8b 45 b0	 mov	 eax, DWORD PTR _x$18[ebp]
  0021f	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$21[ebp]
  00222	8b 55 b0	 mov	 edx, DWORD PTR _x$18[ebp]
  00225	8b 75 c0	 mov	 esi, DWORD PTR _srcYLine$22[ebp]
  00228	66 8b 14 56	 mov	 dx, WORD PTR [esi+edx*2]
  0022c	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx
$LN18@convert_yu:

; 310  :                     }
; 311  :                 }

  00230	e9 3d ff ff ff	 jmp	 $LN5@convert_yu
$LN16@convert_yu:

; 312  :             }
; 313  :         }

  00235	e9 e3 fe ff ff	 jmp	 $LN2@convert_yu
$LN14@convert_yu:

; 314  :     }
; 315  :     //UV
; 316  :     const int src_uv_pitch = src_uv_pitch_byte / sizeof(Tin);

  0023a	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0023d	d1 e8		 shr	 eax, 1
  0023f	89 45 ac	 mov	 DWORD PTR _src_uv_pitch$[ebp], eax

; 317  :     Tin *srcULine = (Tin *)src[1] + ((src_uv_pitch * y_range.start_src) + crop_left);

  00242	b9 04 00 00 00	 mov	 ecx, 4
  00247	c1 e1 00	 shl	 ecx, 0
  0024a	8b 55 ac	 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  0024d	0f af 55 d4	 imul	 edx, DWORD PTR _y_range$[ebp]
  00251	03 55 f8	 add	 edx, DWORD PTR _crop_left$[ebp]
  00254	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  00257	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  0025a	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  0025d	89 55 a8	 mov	 DWORD PTR _srcULine$[ebp], edx

; 318  :     Tin *srcVLine = (Tin *)src[2] + ((src_uv_pitch * y_range.start_src) + crop_left);

  00260	b8 04 00 00 00	 mov	 eax, 4
  00265	d1 e0		 shl	 eax, 1
  00267	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  0026a	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  0026e	03 4d f8	 add	 ecx, DWORD PTR _crop_left$[ebp]
  00271	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  00274	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  00277	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  0027a	89 4d a4	 mov	 DWORD PTR _srcVLine$[ebp], ecx

; 319  :     Tout *dstLine = (Tout *)dst[1] + (dst_y_pitch >> 1) * y_range.start_dst;

  0027d	ba 04 00 00 00	 mov	 edx, 4
  00282	c1 e2 00	 shl	 edx, 0
  00285	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  00288	d1 f8		 sar	 eax, 1
  0028a	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  0028e	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  00291	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  00294	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  00297	89 45 a0	 mov	 DWORD PTR _dstLine$[ebp], eax

; 320  :     for (int y = 0; y < y_range.len; y += 2, srcULine += src_uv_pitch * 2, srcVLine += src_uv_pitch * 2, dstLine += dst_y_pitch) {

  0029a	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR _y$17[ebp], 0
  002a1	eb 31		 jmp	 SHORT $LN10@convert_yu
$LN8@convert_yu:
  002a3	8b 4d 9c	 mov	 ecx, DWORD PTR _y$17[ebp]
  002a6	83 c1 02	 add	 ecx, 2
  002a9	89 4d 9c	 mov	 DWORD PTR _y$17[ebp], ecx
  002ac	8b 55 ac	 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  002af	d1 e2		 shl	 edx, 1
  002b1	8b 45 a8	 mov	 eax, DWORD PTR _srcULine$[ebp]
  002b4	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  002b7	89 4d a8	 mov	 DWORD PTR _srcULine$[ebp], ecx
  002ba	8b 55 ac	 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  002bd	d1 e2		 shl	 edx, 1
  002bf	8b 45 a4	 mov	 eax, DWORD PTR _srcVLine$[ebp]
  002c2	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  002c5	89 4d a4	 mov	 DWORD PTR _srcVLine$[ebp], ecx
  002c8	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  002cb	8b 45 a0	 mov	 eax, DWORD PTR _dstLine$[ebp]
  002ce	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  002d1	89 4d a0	 mov	 DWORD PTR _dstLine$[ebp], ecx
$LN10@convert_yu:
  002d4	8b 55 9c	 mov	 edx, DWORD PTR _y$17[ebp]
  002d7	3b 55 dc	 cmp	 edx, DWORD PTR _y_range$[ebp+8]
  002da	0f 8d 38 01 00
	00		 jge	 $LN1@convert_yu

; 321  :         Tout *dstC = dstLine;

  002e0	8b 45 a0	 mov	 eax, DWORD PTR _dstLine$[ebp]
  002e3	89 45 98	 mov	 DWORD PTR _dstC$16[ebp], eax

; 322  :         Tin *srcU = srcULine;

  002e6	8b 4d a8	 mov	 ecx, DWORD PTR _srcULine$[ebp]
  002e9	89 4d 94	 mov	 DWORD PTR _srcU$15[ebp], ecx

; 323  :         Tin *srcV = srcVLine;

  002ec	8b 55 a4	 mov	 edx, DWORD PTR _srcVLine$[ebp]
  002ef	89 55 90	 mov	 DWORD PTR _srcV$14[ebp], edx

; 324  :         const int x_fin = width - crop_right - crop_left;

  002f2	8b 45 10	 mov	 eax, DWORD PTR _width$[ebp]
  002f5	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  002f8	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  002fb	89 45 8c	 mov	 DWORD PTR _x_fin$13[ebp], eax

; 325  :         for (int x = 0; x < x_fin; x += 2, dstC += 2, srcU += 2, srcV += 2) {

  002fe	c7 45 88 00 00
	00 00		 mov	 DWORD PTR _x$12[ebp], 0
  00305	eb 24		 jmp	 SHORT $LN13@convert_yu
$LN11@convert_yu:
  00307	8b 4d 88	 mov	 ecx, DWORD PTR _x$12[ebp]
  0030a	83 c1 02	 add	 ecx, 2
  0030d	89 4d 88	 mov	 DWORD PTR _x$12[ebp], ecx
  00310	8b 55 98	 mov	 edx, DWORD PTR _dstC$16[ebp]
  00313	83 c2 04	 add	 edx, 4
  00316	89 55 98	 mov	 DWORD PTR _dstC$16[ebp], edx
  00319	8b 45 94	 mov	 eax, DWORD PTR _srcU$15[ebp]
  0031c	83 c0 04	 add	 eax, 4
  0031f	89 45 94	 mov	 DWORD PTR _srcU$15[ebp], eax
  00322	8b 4d 90	 mov	 ecx, DWORD PTR _srcV$14[ebp]
  00325	83 c1 04	 add	 ecx, 4
  00328	89 4d 90	 mov	 DWORD PTR _srcV$14[ebp], ecx
$LN13@convert_yu:
  0032b	8b 55 88	 mov	 edx, DWORD PTR _x$12[ebp]
  0032e	3b 55 8c	 cmp	 edx, DWORD PTR _x_fin$13[ebp]
  00331	0f 8d dc 00 00
	00		 jge	 $LN12@convert_yu

; 326  :             int cy0u = srcU[0*src_uv_pitch + 0];

  00337	6b 45 ac 00	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp], 0
  0033b	8b 4d 94	 mov	 ecx, DWORD PTR _srcU$15[ebp]
  0033e	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  00342	89 55 84	 mov	 DWORD PTR _cy0u$11[ebp], edx

; 327  :             int cy0v = srcV[0*src_uv_pitch + 0];

  00345	6b 45 ac 00	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp], 0
  00349	8b 4d 90	 mov	 ecx, DWORD PTR _srcV$14[ebp]
  0034c	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  00350	89 55 80	 mov	 DWORD PTR _cy0v$10[ebp], edx

; 328  :             int cy1u = srcU[1*src_uv_pitch + 0];

  00353	8b 45 ac	 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  00356	8b 4d 94	 mov	 ecx, DWORD PTR _srcU$15[ebp]
  00359	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  0035d	89 95 7c ff ff
	ff		 mov	 DWORD PTR _cy1u$9[ebp], edx

; 329  :             int cy1v = srcV[1*src_uv_pitch + 0];

  00363	8b 45 ac	 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  00366	8b 4d 90	 mov	 ecx, DWORD PTR _srcV$14[ebp]
  00369	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  0036d	89 95 78 ff ff
	ff		 mov	 DWORD PTR _cy1v$8[ebp], edx

; 330  : 
; 331  :             int cu = cy0u + cy1u + 1;

  00373	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _cy1u$9[ebp]
  00379	8b 4d 84	 mov	 ecx, DWORD PTR _cy0u$11[ebp]
  0037c	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  00380	89 95 74 ff ff
	ff		 mov	 DWORD PTR _cu$7[ebp], edx

; 332  :             int cv = cy0v + cy1v + 1;

  00386	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _cy1v$8[ebp]
  0038c	8b 4d 80	 mov	 ecx, DWORD PTR _cy0v$10[ebp]
  0038f	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  00393	89 95 70 ff ff
	ff		 mov	 DWORD PTR _cv$6[ebp], edx

; 333  :             CHANGE_BIT_DEPTH_2(cu, cv, 1);

  00399	b8 01 00 00 00	 mov	 eax, 1
  0039e	85 c0		 test	 eax, eax
  003a0	74 1e		 je	 SHORT $LN21@convert_yu
  003a2	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _cu$7[ebp]
  003a8	d1 e1		 shl	 ecx, 1
  003aa	89 8d 74 ff ff
	ff		 mov	 DWORD PTR _cu$7[ebp], ecx
  003b0	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR _cv$6[ebp]
  003b6	d1 e2		 shl	 edx, 1
  003b8	89 95 70 ff ff
	ff		 mov	 DWORD PTR _cv$6[ebp], edx
  003be	eb 22		 jmp	 SHORT $LN22@convert_yu
$LN21@convert_yu:
  003c0	33 c0		 xor	 eax, eax
  003c2	74 1e		 je	 SHORT $LN22@convert_yu
  003c4	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _cu$7[ebp]
  003ca	c1 f9 ff	 sar	 ecx, -1
  003cd	89 8d 74 ff ff
	ff		 mov	 DWORD PTR _cu$7[ebp], ecx
  003d3	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR _cv$6[ebp]
  003d9	c1 fa ff	 sar	 edx, -1
  003dc	89 95 70 ff ff
	ff		 mov	 DWORD PTR _cv$6[ebp], edx
$LN22@convert_yu:

; 334  : 
; 335  :             dstC[0] = (Tout)cu;

  003e2	b8 02 00 00 00	 mov	 eax, 2
  003e7	6b c8 00	 imul	 ecx, eax, 0
  003ea	8b 55 98	 mov	 edx, DWORD PTR _dstC$16[ebp]
  003ed	66 8b 85 74 ff
	ff ff		 mov	 ax, WORD PTR _cu$7[ebp]
  003f4	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax

; 336  :             dstC[1] = (Tout)cv;

  003f8	b9 02 00 00 00	 mov	 ecx, 2
  003fd	c1 e1 00	 shl	 ecx, 0
  00400	8b 55 98	 mov	 edx, DWORD PTR _dstC$16[ebp]
  00403	66 8b 85 70 ff
	ff ff		 mov	 ax, WORD PTR _cv$6[ebp]
  0040a	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax

; 337  :         }

  0040e	e9 f4 fe ff ff	 jmp	 $LN11@convert_yu
$LN12@convert_yu:

; 338  :     }

  00413	e9 8b fe ff ff	 jmp	 $LN8@convert_yu
$LN1@convert_yu:

; 339  : }

  00418	52		 push	 edx
  00419	8b cd		 mov	 ecx, ebp
  0041b	50		 push	 eax
  0041c	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN27@convert_yu
  00422	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00427	58		 pop	 eax
  00428	5a		 pop	 edx
  00429	5f		 pop	 edi
  0042a	5e		 pop	 esi
  0042b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0042e	33 cd		 xor	 ecx, ebp
  00430	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00435	81 c4 ac 00 00
	00		 add	 esp, 172		; 000000acH
  0043b	3b ec		 cmp	 ebp, esp
  0043d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00442	8b e5		 mov	 esp, ebp
  00444	5d		 pop	 ebp
  00445	c3		 ret	 0
  00446	66 90		 npad	 2
$LN27@convert_yu:
  00448	01 00 00 00	 DD	 1
  0044c	00 00 00 00	 DD	 $LN26@convert_yu
$LN26@convert_yu:
  00450	d4 ff ff ff	 DD	 -44			; ffffffd4H
  00454	0c 00 00 00	 DD	 12			; 0000000cH
  00458	00 00 00 00	 DD	 $LN25@convert_yu
$LN25@convert_yu:
  0045c	79		 DB	 121			; 00000079H
  0045d	5f		 DB	 95			; 0000005fH
  0045e	72		 DB	 114			; 00000072H
  0045f	61		 DB	 97			; 00000061H
  00460	6e		 DB	 110			; 0000006eH
  00461	67		 DB	 103			; 00000067H
  00462	65		 DB	 101			; 00000065H
  00463	00		 DB	 0
??$convert_yuv444_to_nv12_p_c@G$0O@G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_to_nv12_p_c<unsigned short,14,unsigned short,16,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuv444_14_to_p010_p@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_14_to_p010_p

; 472  : static void convert_yuv444_14_to_p010_p(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 473  :     convert_yuv444_to_nv12_p_c<uint16_t, 14, uint16_t, 16, false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yuv444_to_nv12_p_c@G$0O@G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_to_nv12_p_c<unsigned short,14,unsigned short,16,0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 474  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yuv444_14_to_p010_p@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_14_to_p010_p
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
$T1 = -200						; size = 4
$T2 = -196						; size = 4
$T3 = -192						; size = 4
$T4 = -188						; size = 4
$T5 = -184						; size = 12
_cv_y1$6 = -172						; size = 4
_cv_y0$7 = -168						; size = 4
_cu_y1$8 = -164						; size = 4
_cu_y0$9 = -160						; size = 4
_cy3v$10 = -156						; size = 4
_cy3u$11 = -152						; size = 4
_cy2v$12 = -148						; size = 4
_cy2u$13 = -144						; size = 4
_cy1v$14 = -140						; size = 4
_cy1u$15 = -136						; size = 4
_cy0v$16 = -132						; size = 4
_cy0u$17 = -128						; size = 4
_x$18 = -124						; size = 4
_x_fin$19 = -120					; size = 4
_srcV$20 = -116						; size = 4
_srcU$21 = -112						; size = 4
_dstC$22 = -108						; size = 4
_y$23 = -104						; size = 4
_uv_fin$ = -100						; size = 4
_dstLine$ = -96						; size = 4
_srcVLine$ = -92					; size = 4
_srcULine$ = -88					; size = 4
_src_uv_pitch$ = -84					; size = 4
_x$24 = -80						; size = 4
_y$25 = -76						; size = 4
_y_width$26 = -72					; size = 4
_dstLine$27 = -68					; size = 4
_srcYLine$28 = -64					; size = 4
$T29 = -60						; size = 12
_y_range$ = -44						; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yuv444_to_nv12_i_c@G$0BA@G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_to_nv12_i_c<unsigned short,16,unsigned short,16,0>

; 342  : static void __forceinline convert_yuv444_to_nv12_i_c(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8d bd 38 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-200]
  00011	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 343  :     static_assert((sizeof(Tin)  == 1 && in_bit_depth  == 8) || (sizeof(Tin)  == 2 && 8 < in_bit_depth  && in_bit_depth  <= 16), "invalid input bit depth.");
; 344  :     static_assert((sizeof(Tout) == 1 && out_bit_depth == 8) || (sizeof(Tout) == 2 && 8 < out_bit_depth && out_bit_depth <= 16), "invalid output bit depth.");
; 345  :     const int crop_left   = crop[0];

  00027	b8 04 00 00 00	 mov	 eax, 4
  0002c	6b c8 00	 imul	 ecx, eax, 0
  0002f	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00032	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00035	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 346  :     const int crop_up     = crop[1];

  00038	b9 04 00 00 00	 mov	 ecx, 4
  0003d	c1 e1 00	 shl	 ecx, 0
  00040	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00043	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00046	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 347  :     const int crop_right  = crop[2];

  00049	b9 04 00 00 00	 mov	 ecx, 4
  0004e	d1 e1		 shl	 ecx, 1
  00050	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00053	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00056	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 348  :     const int crop_bottom = crop[3];

  00059	b9 04 00 00 00	 mov	 ecx, 4
  0005e	6b d1 03	 imul	 edx, ecx, 3
  00061	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00064	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00067	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 349  :     const int src_y_pitch = src_y_pitch_byte / sizeof(Tin);

  0006a	8b 55 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebp]
  0006d	d1 ea		 shr	 edx, 1
  0006f	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 350  :     const int dst_y_pitch = dst_y_pitch_byte / sizeof(Tout);

  00072	8b 45 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  00075	d1 e8		 shr	 eax, 1
  00077	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 351  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  0007a	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0007d	51		 push	 ecx
  0007e	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  00081	52		 push	 edx
  00082	8b 45 20	 mov	 eax, DWORD PTR _height$[ebp]
  00085	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  00088	50		 push	 eax
  00089	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  0008c	51		 push	 ecx
  0008d	8d 95 48 ff ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  00093	52		 push	 edx
  00094	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00099	83 c4 14	 add	 esp, 20			; 00000014H
  0009c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009e	89 4d c4	 mov	 DWORD PTR $T29[ebp], ecx
  000a1	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a4	89 55 c8	 mov	 DWORD PTR $T29[ebp+4], edx
  000a7	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000aa	89 45 cc	 mov	 DWORD PTR $T29[ebp+8], eax
  000ad	8b 4d c4	 mov	 ecx, DWORD PTR $T29[ebp]
  000b0	89 4d d4	 mov	 DWORD PTR _y_range$[ebp], ecx
  000b3	8b 55 c8	 mov	 edx, DWORD PTR $T29[ebp+4]
  000b6	89 55 d8	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000b9	8b 45 cc	 mov	 eax, DWORD PTR $T29[ebp+8]
  000bc	89 45 dc	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 352  :     //Y
; 353  :     if (!uv_only) {

  000bf	b9 01 00 00 00	 mov	 ecx, 1
  000c4	85 c9		 test	 ecx, ecx
  000c6	0f 84 6e 01 00
	00		 je	 $LN14@convert_yu

; 354  :         Tin *srcYLine = (Tin *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000cc	ba 04 00 00 00	 mov	 edx, 4
  000d1	6b c2 00	 imul	 eax, edx, 0
  000d4	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  000d7	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  000db	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  000de	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  000e1	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  000e4	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  000e7	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  000ea	89 45 c0	 mov	 DWORD PTR _srcYLine$28[ebp], eax

; 355  :         Tout *dstLine = (Tout *)dst[0] + dst_y_pitch * y_range.start_dst;

  000ed	b9 04 00 00 00	 mov	 ecx, 4
  000f2	6b d1 00	 imul	 edx, ecx, 0
  000f5	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  000f8	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  000fc	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  000ff	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  00102	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  00105	89 45 bc	 mov	 DWORD PTR _dstLine$27[ebp], eax

; 356  :         const int y_width = width - crop_right - crop_left;

  00108	8b 4d 10	 mov	 ecx, DWORD PTR _width$[ebp]
  0010b	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  0010e	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  00111	89 4d b8	 mov	 DWORD PTR _y_width$26[ebp], ecx

; 357  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  00114	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _y$25[ebp], 0
  0011b	eb 21		 jmp	 SHORT $LN4@convert_yu
$LN2@convert_yu:
  0011d	8b 55 b4	 mov	 edx, DWORD PTR _y$25[ebp]
  00120	83 c2 01	 add	 edx, 1
  00123	89 55 b4	 mov	 DWORD PTR _y$25[ebp], edx
  00126	8b 45 e8	 mov	 eax, DWORD PTR _src_y_pitch$[ebp]
  00129	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$28[ebp]
  0012c	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  0012f	89 55 c0	 mov	 DWORD PTR _srcYLine$28[ebp], edx
  00132	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  00135	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$27[ebp]
  00138	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  0013b	89 55 bc	 mov	 DWORD PTR _dstLine$27[ebp], edx
$LN4@convert_yu:
  0013e	8b 45 b4	 mov	 eax, DWORD PTR _y$25[ebp]
  00141	3b 45 dc	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  00144	0f 8d f0 00 00
	00		 jge	 $LN14@convert_yu

; 358  :             if (in_bit_depth == out_bit_depth && sizeof(Tin) == sizeof(Tout)) {

  0014a	b9 01 00 00 00	 mov	 ecx, 1
  0014f	85 c9		 test	 ecx, ecx
  00151	74 1b		 je	 SHORT $LN15@convert_yu

; 359  :                 memcpy(dstLine, srcYLine, y_width * sizeof(Tin));

  00153	8b 55 b8	 mov	 edx, DWORD PTR _y_width$26[ebp]
  00156	d1 e2		 shl	 edx, 1
  00158	52		 push	 edx
  00159	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$28[ebp]
  0015c	50		 push	 eax
  0015d	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$27[ebp]
  00160	51		 push	 ecx
  00161	e8 00 00 00 00	 call	 _memcpy
  00166	83 c4 0c	 add	 esp, 12			; 0000000cH

; 360  :             } else {

  00169	e9 c7 00 00 00	 jmp	 $LN16@convert_yu
$LN15@convert_yu:

; 361  :                 for (int x = 0; x < y_width; x++) {

  0016e	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _x$24[ebp], 0
  00175	eb 09		 jmp	 SHORT $LN7@convert_yu
$LN5@convert_yu:
  00177	8b 55 b0	 mov	 edx, DWORD PTR _x$24[ebp]
  0017a	83 c2 01	 add	 edx, 1
  0017d	89 55 b0	 mov	 DWORD PTR _x$24[ebp], edx
$LN7@convert_yu:
  00180	8b 45 b0	 mov	 eax, DWORD PTR _x$24[ebp]
  00183	3b 45 b8	 cmp	 eax, DWORD PTR _y_width$26[ebp]
  00186	0f 8d a9 00 00
	00		 jge	 $LN16@convert_yu

; 362  :                     if (out_bit_depth > in_bit_depth) {

  0018c	33 c9		 xor	 ecx, ecx
  0018e	74 44		 je	 SHORT $LN17@convert_yu

; 363  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) << std::max(out_bit_depth - in_bit_depth, 0));

  00190	c7 85 44 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], 0
  0019a	c7 85 40 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T3[ebp], 0
  001a4	8b 55 b0	 mov	 edx, DWORD PTR _x$24[ebp]
  001a7	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$28[ebp]
  001aa	0f b7 34 50	 movzx	 esi, WORD PTR [eax+edx*2]
  001ae	8d 8d 44 ff ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  001b4	51		 push	 ecx
  001b5	8d 95 40 ff ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  001bb	52		 push	 edx
  001bc	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  001c1	83 c4 08	 add	 esp, 8
  001c4	8b 08		 mov	 ecx, DWORD PTR [eax]
  001c6	d3 e6		 shl	 esi, cl
  001c8	8b 45 b0	 mov	 eax, DWORD PTR _x$24[ebp]
  001cb	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$27[ebp]
  001ce	66 89 34 41	 mov	 WORD PTR [ecx+eax*2], si
  001d2	eb 5c		 jmp	 SHORT $LN18@convert_yu
$LN17@convert_yu:

; 364  :                     } else if (out_bit_depth < in_bit_depth) {

  001d4	33 d2		 xor	 edx, edx
  001d6	74 44		 je	 SHORT $LN19@convert_yu

; 365  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) >> std::max(in_bit_depth - out_bit_depth, 0));

  001d8	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], 0
  001e2	c7 85 38 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T1[ebp], 0
  001ec	8b 45 b0	 mov	 eax, DWORD PTR _x$24[ebp]
  001ef	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$28[ebp]
  001f2	0f b7 34 41	 movzx	 esi, WORD PTR [ecx+eax*2]
  001f6	8d 95 3c ff ff
	ff		 lea	 edx, DWORD PTR $T2[ebp]
  001fc	52		 push	 edx
  001fd	8d 85 38 ff ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  00203	50		 push	 eax
  00204	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  00209	83 c4 08	 add	 esp, 8
  0020c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0020e	d3 fe		 sar	 esi, cl
  00210	8b 4d b0	 mov	 ecx, DWORD PTR _x$24[ebp]
  00213	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$27[ebp]
  00216	66 89 34 4a	 mov	 WORD PTR [edx+ecx*2], si

; 366  :                     } else {

  0021a	eb 14		 jmp	 SHORT $LN18@convert_yu
$LN19@convert_yu:

; 367  :                         dstLine[x] = (Tout)srcYLine[x];

  0021c	8b 45 b0	 mov	 eax, DWORD PTR _x$24[ebp]
  0021f	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$27[ebp]
  00222	8b 55 b0	 mov	 edx, DWORD PTR _x$24[ebp]
  00225	8b 75 c0	 mov	 esi, DWORD PTR _srcYLine$28[ebp]
  00228	66 8b 14 56	 mov	 dx, WORD PTR [esi+edx*2]
  0022c	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx
$LN18@convert_yu:

; 368  :                     }
; 369  :                 }

  00230	e9 42 ff ff ff	 jmp	 $LN5@convert_yu
$LN16@convert_yu:

; 370  :             }
; 371  :         }

  00235	e9 e3 fe ff ff	 jmp	 $LN2@convert_yu
$LN14@convert_yu:

; 372  :     }
; 373  :     //UV
; 374  :     const int src_uv_pitch = src_uv_pitch_byte / sizeof(Tin);

  0023a	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0023d	d1 e8		 shr	 eax, 1
  0023f	89 45 ac	 mov	 DWORD PTR _src_uv_pitch$[ebp], eax

; 375  :     Tin *srcULine = (Tin *)src[1] + ((src_uv_pitch * y_range.start_src) + crop_left);

  00242	b9 04 00 00 00	 mov	 ecx, 4
  00247	c1 e1 00	 shl	 ecx, 0
  0024a	8b 55 ac	 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  0024d	0f af 55 d4	 imul	 edx, DWORD PTR _y_range$[ebp]
  00251	03 55 f8	 add	 edx, DWORD PTR _crop_left$[ebp]
  00254	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  00257	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  0025a	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  0025d	89 55 a8	 mov	 DWORD PTR _srcULine$[ebp], edx

; 376  :     Tin *srcVLine = (Tin *)src[2] + ((src_uv_pitch * y_range.start_src) + crop_left);

  00260	b8 04 00 00 00	 mov	 eax, 4
  00265	d1 e0		 shl	 eax, 1
  00267	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  0026a	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  0026e	03 4d f8	 add	 ecx, DWORD PTR _crop_left$[ebp]
  00271	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  00274	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  00277	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  0027a	89 4d a4	 mov	 DWORD PTR _srcVLine$[ebp], ecx

; 377  :     Tout *dstLine = (Tout *)dst[1] + (dst_y_pitch >> 1) * y_range.start_dst;

  0027d	ba 04 00 00 00	 mov	 edx, 4
  00282	c1 e2 00	 shl	 edx, 0
  00285	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  00288	d1 f8		 sar	 eax, 1
  0028a	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  0028e	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  00291	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  00294	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  00297	89 45 a0	 mov	 DWORD PTR _dstLine$[ebp], eax

; 378  :     const int uv_fin = height - crop_bottom - crop_up;

  0029a	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  0029d	2b 4d ec	 sub	 ecx, DWORD PTR _crop_bottom$[ebp]
  002a0	2b 4d f4	 sub	 ecx, DWORD PTR _crop_up$[ebp]
  002a3	89 4d 9c	 mov	 DWORD PTR _uv_fin$[ebp], ecx

; 379  :     for (int y = 0; y < y_range.len; y += 4, srcULine += src_uv_pitch * 4, srcVLine += src_uv_pitch * 4, dstLine += dst_y_pitch * 2) {

  002a6	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _y$23[ebp], 0
  002ad	eb 35		 jmp	 SHORT $LN10@convert_yu
$LN8@convert_yu:
  002af	8b 55 98	 mov	 edx, DWORD PTR _y$23[ebp]
  002b2	83 c2 04	 add	 edx, 4
  002b5	89 55 98	 mov	 DWORD PTR _y$23[ebp], edx
  002b8	8b 45 ac	 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  002bb	c1 e0 02	 shl	 eax, 2
  002be	8b 4d a8	 mov	 ecx, DWORD PTR _srcULine$[ebp]
  002c1	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  002c4	89 55 a8	 mov	 DWORD PTR _srcULine$[ebp], edx
  002c7	8b 45 ac	 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  002ca	c1 e0 02	 shl	 eax, 2
  002cd	8b 4d a4	 mov	 ecx, DWORD PTR _srcVLine$[ebp]
  002d0	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  002d3	89 55 a4	 mov	 DWORD PTR _srcVLine$[ebp], edx
  002d6	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  002d9	d1 e0		 shl	 eax, 1
  002db	8b 4d a0	 mov	 ecx, DWORD PTR _dstLine$[ebp]
  002de	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  002e1	89 55 a0	 mov	 DWORD PTR _dstLine$[ebp], edx
$LN10@convert_yu:
  002e4	8b 45 98	 mov	 eax, DWORD PTR _y$23[ebp]
  002e7	3b 45 dc	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  002ea	0f 8d 0e 02 00
	00		 jge	 $LN1@convert_yu

; 380  :         Tout *dstC = dstLine;

  002f0	8b 4d a0	 mov	 ecx, DWORD PTR _dstLine$[ebp]
  002f3	89 4d 94	 mov	 DWORD PTR _dstC$22[ebp], ecx

; 381  :         Tin *srcU = srcULine;

  002f6	8b 55 a8	 mov	 edx, DWORD PTR _srcULine$[ebp]
  002f9	89 55 90	 mov	 DWORD PTR _srcU$21[ebp], edx

; 382  :         Tin *srcV = srcVLine;

  002fc	8b 45 a4	 mov	 eax, DWORD PTR _srcVLine$[ebp]
  002ff	89 45 8c	 mov	 DWORD PTR _srcV$20[ebp], eax

; 383  :         const int x_fin = width - crop_right - crop_left;

  00302	8b 4d 10	 mov	 ecx, DWORD PTR _width$[ebp]
  00305	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  00308	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  0030b	89 4d 88	 mov	 DWORD PTR _x_fin$19[ebp], ecx

; 384  :         for (int x = 0; x < x_fin; x += 2, dstC += 2, srcU += 2, srcV += 2) {

  0030e	c7 45 84 00 00
	00 00		 mov	 DWORD PTR _x$18[ebp], 0
  00315	eb 24		 jmp	 SHORT $LN13@convert_yu
$LN11@convert_yu:
  00317	8b 55 84	 mov	 edx, DWORD PTR _x$18[ebp]
  0031a	83 c2 02	 add	 edx, 2
  0031d	89 55 84	 mov	 DWORD PTR _x$18[ebp], edx
  00320	8b 45 94	 mov	 eax, DWORD PTR _dstC$22[ebp]
  00323	83 c0 04	 add	 eax, 4
  00326	89 45 94	 mov	 DWORD PTR _dstC$22[ebp], eax
  00329	8b 4d 90	 mov	 ecx, DWORD PTR _srcU$21[ebp]
  0032c	83 c1 04	 add	 ecx, 4
  0032f	89 4d 90	 mov	 DWORD PTR _srcU$21[ebp], ecx
  00332	8b 55 8c	 mov	 edx, DWORD PTR _srcV$20[ebp]
  00335	83 c2 04	 add	 edx, 4
  00338	89 55 8c	 mov	 DWORD PTR _srcV$20[ebp], edx
$LN13@convert_yu:
  0033b	8b 45 84	 mov	 eax, DWORD PTR _x$18[ebp]
  0033e	3b 45 88	 cmp	 eax, DWORD PTR _x_fin$19[ebp]
  00341	0f 8d b2 01 00
	00		 jge	 $LN12@convert_yu

; 385  :             int cy0u = srcU[0*src_uv_pitch + 0];

  00347	6b 4d ac 00	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 0
  0034b	8b 55 90	 mov	 edx, DWORD PTR _srcU$21[ebp]
  0034e	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00352	89 45 80	 mov	 DWORD PTR _cy0u$17[ebp], eax

; 386  :             int cy0v = srcV[0*src_uv_pitch + 0];

  00355	6b 4d ac 00	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 0
  00359	8b 55 8c	 mov	 edx, DWORD PTR _srcV$20[ebp]
  0035c	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00360	89 85 7c ff ff
	ff		 mov	 DWORD PTR _cy0v$16[ebp], eax

; 387  :             int cy1u = srcU[1*src_uv_pitch + 0];

  00366	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00369	8b 55 90	 mov	 edx, DWORD PTR _srcU$21[ebp]
  0036c	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00370	89 85 78 ff ff
	ff		 mov	 DWORD PTR _cy1u$15[ebp], eax

; 388  :             int cy1v = srcV[1*src_uv_pitch + 0];

  00376	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00379	8b 55 8c	 mov	 edx, DWORD PTR _srcV$20[ebp]
  0037c	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00380	89 85 74 ff ff
	ff		 mov	 DWORD PTR _cy1v$14[ebp], eax

; 389  :             int cy2u = srcU[2*src_uv_pitch + 0];

  00386	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00389	d1 e1		 shl	 ecx, 1
  0038b	8b 55 90	 mov	 edx, DWORD PTR _srcU$21[ebp]
  0038e	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00392	89 85 70 ff ff
	ff		 mov	 DWORD PTR _cy2u$13[ebp], eax

; 390  :             int cy2v = srcV[2*src_uv_pitch + 0];

  00398	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  0039b	d1 e1		 shl	 ecx, 1
  0039d	8b 55 8c	 mov	 edx, DWORD PTR _srcV$20[ebp]
  003a0	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  003a4	89 85 6c ff ff
	ff		 mov	 DWORD PTR _cy2v$12[ebp], eax

; 391  :             int cy3u = srcU[3*src_uv_pitch + 0];

  003aa	6b 4d ac 03	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 3
  003ae	8b 55 90	 mov	 edx, DWORD PTR _srcU$21[ebp]
  003b1	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  003b5	89 85 68 ff ff
	ff		 mov	 DWORD PTR _cy3u$11[ebp], eax

; 392  :             int cy3v = srcV[3*src_uv_pitch + 0];

  003bb	6b 4d ac 03	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 3
  003bf	8b 55 8c	 mov	 edx, DWORD PTR _srcV$20[ebp]
  003c2	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  003c6	89 85 64 ff ff
	ff		 mov	 DWORD PTR _cy3v$10[ebp], eax

; 393  : 
; 394  :             int cu_y0 = cy0u * 3 + cy2u * 1 + 2;

  003cc	6b 4d 80 03	 imul	 ecx, DWORD PTR _cy0u$17[ebp], 3
  003d0	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR _cy2u$13[ebp]
  003d6	8d 44 11 02	 lea	 eax, DWORD PTR [ecx+edx+2]
  003da	89 85 60 ff ff
	ff		 mov	 DWORD PTR _cu_y0$9[ebp], eax

; 395  :             int cu_y1 = cy1u * 1 + cy3u * 3 + 2;

  003e0	6b 8d 68 ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy3u$11[ebp], 3
  003e7	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _cy1u$15[ebp]
  003ed	8d 44 0a 02	 lea	 eax, DWORD PTR [edx+ecx+2]
  003f1	89 85 5c ff ff
	ff		 mov	 DWORD PTR _cu_y1$8[ebp], eax

; 396  :             int cv_y0 = cy0v * 3 + cy2v * 1 + 2;

  003f7	6b 8d 7c ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy0v$16[ebp], 3
  003fe	8b 95 6c ff ff
	ff		 mov	 edx, DWORD PTR _cy2v$12[ebp]
  00404	8d 44 11 02	 lea	 eax, DWORD PTR [ecx+edx+2]
  00408	89 85 58 ff ff
	ff		 mov	 DWORD PTR _cv_y0$7[ebp], eax

; 397  :             int cv_y1 = cy1v * 1 + cy3v * 3 + 2;

  0040e	6b 8d 64 ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy3v$10[ebp], 3
  00415	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _cy1v$14[ebp]
  0041b	8d 44 0a 02	 lea	 eax, DWORD PTR [edx+ecx+2]
  0041f	89 85 54 ff ff
	ff		 mov	 DWORD PTR _cv_y1$6[ebp], eax

; 398  :             CHANGE_BIT_DEPTH_4(cu_y0, cu_y1, cv_y0, cv_y1, 2);

  00425	33 c9		 xor	 ecx, ecx
  00427	74 3e		 je	 SHORT $LN21@convert_yu
  00429	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _cu_y0$9[ebp]
  0042f	c1 e2 fe	 shl	 edx, -2			; fffffffeH
  00432	89 95 60 ff ff
	ff		 mov	 DWORD PTR _cu_y0$9[ebp], edx
  00438	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _cu_y1$8[ebp]
  0043e	c1 e0 fe	 shl	 eax, -2			; fffffffeH
  00441	89 85 5c ff ff
	ff		 mov	 DWORD PTR _cu_y1$8[ebp], eax
  00447	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _cv_y0$7[ebp]
  0044d	c1 e1 fe	 shl	 ecx, -2			; fffffffeH
  00450	89 8d 58 ff ff
	ff		 mov	 DWORD PTR _cv_y0$7[ebp], ecx
  00456	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR _cv_y1$6[ebp]
  0045c	c1 e2 fe	 shl	 edx, -2			; fffffffeH
  0045f	89 95 54 ff ff
	ff		 mov	 DWORD PTR _cv_y1$6[ebp], edx
  00465	eb 45		 jmp	 SHORT $LN22@convert_yu
$LN21@convert_yu:
  00467	b8 01 00 00 00	 mov	 eax, 1
  0046c	85 c0		 test	 eax, eax
  0046e	74 3c		 je	 SHORT $LN22@convert_yu
  00470	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _cu_y0$9[ebp]
  00476	c1 f9 02	 sar	 ecx, 2
  00479	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _cu_y0$9[ebp], ecx
  0047f	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR _cu_y1$8[ebp]
  00485	c1 fa 02	 sar	 edx, 2
  00488	89 95 5c ff ff
	ff		 mov	 DWORD PTR _cu_y1$8[ebp], edx
  0048e	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _cv_y0$7[ebp]
  00494	c1 f8 02	 sar	 eax, 2
  00497	89 85 58 ff ff
	ff		 mov	 DWORD PTR _cv_y0$7[ebp], eax
  0049d	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _cv_y1$6[ebp]
  004a3	c1 f9 02	 sar	 ecx, 2
  004a6	89 8d 54 ff ff
	ff		 mov	 DWORD PTR _cv_y1$6[ebp], ecx
$LN22@convert_yu:

; 399  : 
; 400  :             dstC[0*dst_y_pitch + 0] = (Tout)cu_y0;

  004ac	6b 55 e4 00	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 0
  004b0	8b 45 94	 mov	 eax, DWORD PTR _dstC$22[ebp]
  004b3	66 8b 8d 60 ff
	ff ff		 mov	 cx, WORD PTR _cu_y0$9[ebp]
  004ba	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx

; 401  :             dstC[0*dst_y_pitch + 1] = (Tout)cv_y0;

  004be	6b 55 e4 00	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 0
  004c2	8b 45 94	 mov	 eax, DWORD PTR _dstC$22[ebp]
  004c5	66 8b 8d 58 ff
	ff ff		 mov	 cx, WORD PTR _cv_y0$7[ebp]
  004cc	66 89 4c 50 02	 mov	 WORD PTR [eax+edx*2+2], cx

; 402  :             dstC[1*dst_y_pitch + 0] = (Tout)cu_y1;

  004d1	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  004d4	8b 45 94	 mov	 eax, DWORD PTR _dstC$22[ebp]
  004d7	66 8b 8d 5c ff
	ff ff		 mov	 cx, WORD PTR _cu_y1$8[ebp]
  004de	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx

; 403  :             dstC[1*dst_y_pitch + 1] = (Tout)cv_y1;

  004e2	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  004e5	8b 45 94	 mov	 eax, DWORD PTR _dstC$22[ebp]
  004e8	66 8b 8d 54 ff
	ff ff		 mov	 cx, WORD PTR _cv_y1$6[ebp]
  004ef	66 89 4c 50 02	 mov	 WORD PTR [eax+edx*2+2], cx

; 404  :         }

  004f4	e9 1e fe ff ff	 jmp	 $LN11@convert_yu
$LN12@convert_yu:

; 405  :     }

  004f9	e9 b1 fd ff ff	 jmp	 $LN8@convert_yu
$LN1@convert_yu:

; 406  : }

  004fe	52		 push	 edx
  004ff	8b cd		 mov	 ecx, ebp
  00501	50		 push	 eax
  00502	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN27@convert_yu
  00508	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0050d	58		 pop	 eax
  0050e	5a		 pop	 edx
  0050f	5f		 pop	 edi
  00510	5e		 pop	 esi
  00511	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00514	33 cd		 xor	 ecx, ebp
  00516	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0051b	81 c4 c8 00 00
	00		 add	 esp, 200		; 000000c8H
  00521	3b ec		 cmp	 ebp, esp
  00523	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00528	8b e5		 mov	 esp, ebp
  0052a	5d		 pop	 ebp
  0052b	c3		 ret	 0
$LN27@convert_yu:
  0052c	01 00 00 00	 DD	 1
  00530	00 00 00 00	 DD	 $LN26@convert_yu
$LN26@convert_yu:
  00534	d4 ff ff ff	 DD	 -44			; ffffffd4H
  00538	0c 00 00 00	 DD	 12			; 0000000cH
  0053c	00 00 00 00	 DD	 $LN25@convert_yu
$LN25@convert_yu:
  00540	79		 DB	 121			; 00000079H
  00541	5f		 DB	 95			; 0000005fH
  00542	72		 DB	 114			; 00000072H
  00543	61		 DB	 97			; 00000061H
  00544	6e		 DB	 110			; 0000006eH
  00545	67		 DB	 103			; 00000067H
  00546	65		 DB	 101			; 00000065H
  00547	00		 DB	 0
??$convert_yuv444_to_nv12_i_c@G$0BA@G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_to_nv12_i_c<unsigned short,16,unsigned short,16,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuv444_16_to_p010_i@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_16_to_p010_i

; 468  : static void convert_yuv444_16_to_p010_i(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 469  :     convert_yuv444_to_nv12_i_c<uint16_t, 16, uint16_t, 16, false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yuv444_to_nv12_i_c@G$0BA@G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_to_nv12_i_c<unsigned short,16,unsigned short,16,0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 470  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yuv444_16_to_p010_i@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_16_to_p010_i
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
$T1 = -172						; size = 4
$T2 = -168						; size = 4
$T3 = -164						; size = 4
$T4 = -160						; size = 4
$T5 = -156						; size = 12
_cv$6 = -144						; size = 4
_cu$7 = -140						; size = 4
_cy1v$8 = -136						; size = 4
_cy1u$9 = -132						; size = 4
_cy0v$10 = -128						; size = 4
_cy0u$11 = -124						; size = 4
_x$12 = -120						; size = 4
_x_fin$13 = -116					; size = 4
_srcV$14 = -112						; size = 4
_srcU$15 = -108						; size = 4
_dstC$16 = -104						; size = 4
_y$17 = -100						; size = 4
_dstLine$ = -96						; size = 4
_srcVLine$ = -92					; size = 4
_srcULine$ = -88					; size = 4
_src_uv_pitch$ = -84					; size = 4
_x$18 = -80						; size = 4
_y$19 = -76						; size = 4
_y_width$20 = -72					; size = 4
_dstLine$21 = -68					; size = 4
_srcYLine$22 = -64					; size = 4
$T23 = -60						; size = 12
_y_range$ = -44						; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yuv444_to_nv12_p_c@G$0BA@G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_to_nv12_p_c<unsigned short,16,unsigned short,16,0>

; 284  : static void __forceinline convert_yuv444_to_nv12_p_c(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec ac 00 00
	00		 sub	 esp, 172		; 000000acH
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8d bd 54 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-172]
  00011	b9 2b 00 00 00	 mov	 ecx, 43			; 0000002bH
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 285  :     static_assert((sizeof(Tin)  == 1 && in_bit_depth  == 8) || (sizeof(Tin)  == 2 && 8 < in_bit_depth  && in_bit_depth  <= 16), "invalid input bit depth.");
; 286  :     static_assert((sizeof(Tout) == 1 && out_bit_depth == 8) || (sizeof(Tout) == 2 && 8 < out_bit_depth && out_bit_depth <= 16), "invalid output bit depth.");
; 287  :     const int crop_left   = crop[0];

  00027	b8 04 00 00 00	 mov	 eax, 4
  0002c	6b c8 00	 imul	 ecx, eax, 0
  0002f	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00032	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00035	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 288  :     const int crop_up     = crop[1];

  00038	b9 04 00 00 00	 mov	 ecx, 4
  0003d	c1 e1 00	 shl	 ecx, 0
  00040	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00043	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00046	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 289  :     const int crop_right  = crop[2];

  00049	b9 04 00 00 00	 mov	 ecx, 4
  0004e	d1 e1		 shl	 ecx, 1
  00050	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00053	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00056	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 290  :     const int crop_bottom = crop[3];

  00059	b9 04 00 00 00	 mov	 ecx, 4
  0005e	6b d1 03	 imul	 edx, ecx, 3
  00061	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00064	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00067	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 291  :     const int src_y_pitch = src_y_pitch_byte / sizeof(Tin);

  0006a	8b 55 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebp]
  0006d	d1 ea		 shr	 edx, 1
  0006f	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 292  :     const int dst_y_pitch = dst_y_pitch_byte / sizeof(Tout);

  00072	8b 45 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  00075	d1 e8		 shr	 eax, 1
  00077	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 293  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  0007a	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0007d	51		 push	 ecx
  0007e	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  00081	52		 push	 edx
  00082	8b 45 20	 mov	 eax, DWORD PTR _height$[ebp]
  00085	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  00088	50		 push	 eax
  00089	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  0008c	51		 push	 ecx
  0008d	8d 95 64 ff ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  00093	52		 push	 edx
  00094	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00099	83 c4 14	 add	 esp, 20			; 00000014H
  0009c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009e	89 4d c4	 mov	 DWORD PTR $T23[ebp], ecx
  000a1	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a4	89 55 c8	 mov	 DWORD PTR $T23[ebp+4], edx
  000a7	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000aa	89 45 cc	 mov	 DWORD PTR $T23[ebp+8], eax
  000ad	8b 4d c4	 mov	 ecx, DWORD PTR $T23[ebp]
  000b0	89 4d d4	 mov	 DWORD PTR _y_range$[ebp], ecx
  000b3	8b 55 c8	 mov	 edx, DWORD PTR $T23[ebp+4]
  000b6	89 55 d8	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000b9	8b 45 cc	 mov	 eax, DWORD PTR $T23[ebp+8]
  000bc	89 45 dc	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 294  :     //Y
; 295  :     if (!uv_only) {

  000bf	b9 01 00 00 00	 mov	 ecx, 1
  000c4	85 c9		 test	 ecx, ecx
  000c6	0f 84 6e 01 00
	00		 je	 $LN14@convert_yu

; 296  :         Tin *srcYLine = (Tin *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000cc	ba 04 00 00 00	 mov	 edx, 4
  000d1	6b c2 00	 imul	 eax, edx, 0
  000d4	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  000d7	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  000db	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  000de	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  000e1	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  000e4	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  000e7	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  000ea	89 45 c0	 mov	 DWORD PTR _srcYLine$22[ebp], eax

; 297  :         Tout *dstLine = (Tout *)dst[0] + dst_y_pitch * y_range.start_dst;

  000ed	b9 04 00 00 00	 mov	 ecx, 4
  000f2	6b d1 00	 imul	 edx, ecx, 0
  000f5	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  000f8	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  000fc	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  000ff	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  00102	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  00105	89 45 bc	 mov	 DWORD PTR _dstLine$21[ebp], eax

; 298  :         const int y_width = width - crop_right - crop_left;

  00108	8b 4d 10	 mov	 ecx, DWORD PTR _width$[ebp]
  0010b	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  0010e	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  00111	89 4d b8	 mov	 DWORD PTR _y_width$20[ebp], ecx

; 299  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  00114	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _y$19[ebp], 0
  0011b	eb 21		 jmp	 SHORT $LN4@convert_yu
$LN2@convert_yu:
  0011d	8b 55 b4	 mov	 edx, DWORD PTR _y$19[ebp]
  00120	83 c2 01	 add	 edx, 1
  00123	89 55 b4	 mov	 DWORD PTR _y$19[ebp], edx
  00126	8b 45 e8	 mov	 eax, DWORD PTR _src_y_pitch$[ebp]
  00129	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$22[ebp]
  0012c	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  0012f	89 55 c0	 mov	 DWORD PTR _srcYLine$22[ebp], edx
  00132	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  00135	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$21[ebp]
  00138	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  0013b	89 55 bc	 mov	 DWORD PTR _dstLine$21[ebp], edx
$LN4@convert_yu:
  0013e	8b 45 b4	 mov	 eax, DWORD PTR _y$19[ebp]
  00141	3b 45 dc	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  00144	0f 8d f0 00 00
	00		 jge	 $LN14@convert_yu

; 300  :             if (in_bit_depth == out_bit_depth && sizeof(Tin) == sizeof(Tout)) {

  0014a	b9 01 00 00 00	 mov	 ecx, 1
  0014f	85 c9		 test	 ecx, ecx
  00151	74 1b		 je	 SHORT $LN15@convert_yu

; 301  :                 memcpy(dstLine, srcYLine, y_width * sizeof(Tin));

  00153	8b 55 b8	 mov	 edx, DWORD PTR _y_width$20[ebp]
  00156	d1 e2		 shl	 edx, 1
  00158	52		 push	 edx
  00159	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$22[ebp]
  0015c	50		 push	 eax
  0015d	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$21[ebp]
  00160	51		 push	 ecx
  00161	e8 00 00 00 00	 call	 _memcpy
  00166	83 c4 0c	 add	 esp, 12			; 0000000cH

; 302  :             } else {

  00169	e9 c7 00 00 00	 jmp	 $LN16@convert_yu
$LN15@convert_yu:

; 303  :                 for (int x = 0; x < y_width; x++) {

  0016e	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _x$18[ebp], 0
  00175	eb 09		 jmp	 SHORT $LN7@convert_yu
$LN5@convert_yu:
  00177	8b 55 b0	 mov	 edx, DWORD PTR _x$18[ebp]
  0017a	83 c2 01	 add	 edx, 1
  0017d	89 55 b0	 mov	 DWORD PTR _x$18[ebp], edx
$LN7@convert_yu:
  00180	8b 45 b0	 mov	 eax, DWORD PTR _x$18[ebp]
  00183	3b 45 b8	 cmp	 eax, DWORD PTR _y_width$20[ebp]
  00186	0f 8d a9 00 00
	00		 jge	 $LN16@convert_yu

; 304  :                     if (out_bit_depth > in_bit_depth) {

  0018c	33 c9		 xor	 ecx, ecx
  0018e	74 44		 je	 SHORT $LN17@convert_yu

; 305  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) << std::max(out_bit_depth - in_bit_depth, 0));

  00190	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], 0
  0019a	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T3[ebp], 0
  001a4	8b 55 b0	 mov	 edx, DWORD PTR _x$18[ebp]
  001a7	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$22[ebp]
  001aa	0f b7 34 50	 movzx	 esi, WORD PTR [eax+edx*2]
  001ae	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  001b4	51		 push	 ecx
  001b5	8d 95 5c ff ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  001bb	52		 push	 edx
  001bc	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  001c1	83 c4 08	 add	 esp, 8
  001c4	8b 08		 mov	 ecx, DWORD PTR [eax]
  001c6	d3 e6		 shl	 esi, cl
  001c8	8b 45 b0	 mov	 eax, DWORD PTR _x$18[ebp]
  001cb	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$21[ebp]
  001ce	66 89 34 41	 mov	 WORD PTR [ecx+eax*2], si
  001d2	eb 5c		 jmp	 SHORT $LN18@convert_yu
$LN17@convert_yu:

; 306  :                     } else if (out_bit_depth < in_bit_depth) {

  001d4	33 d2		 xor	 edx, edx
  001d6	74 44		 je	 SHORT $LN19@convert_yu

; 307  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) >> std::max(in_bit_depth - out_bit_depth, 0));

  001d8	c7 85 58 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], 0
  001e2	c7 85 54 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T1[ebp], 0
  001ec	8b 45 b0	 mov	 eax, DWORD PTR _x$18[ebp]
  001ef	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$22[ebp]
  001f2	0f b7 34 41	 movzx	 esi, WORD PTR [ecx+eax*2]
  001f6	8d 95 58 ff ff
	ff		 lea	 edx, DWORD PTR $T2[ebp]
  001fc	52		 push	 edx
  001fd	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  00203	50		 push	 eax
  00204	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  00209	83 c4 08	 add	 esp, 8
  0020c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0020e	d3 fe		 sar	 esi, cl
  00210	8b 4d b0	 mov	 ecx, DWORD PTR _x$18[ebp]
  00213	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$21[ebp]
  00216	66 89 34 4a	 mov	 WORD PTR [edx+ecx*2], si

; 308  :                     } else {

  0021a	eb 14		 jmp	 SHORT $LN18@convert_yu
$LN19@convert_yu:

; 309  :                         dstLine[x] = (Tout)srcYLine[x];

  0021c	8b 45 b0	 mov	 eax, DWORD PTR _x$18[ebp]
  0021f	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$21[ebp]
  00222	8b 55 b0	 mov	 edx, DWORD PTR _x$18[ebp]
  00225	8b 75 c0	 mov	 esi, DWORD PTR _srcYLine$22[ebp]
  00228	66 8b 14 56	 mov	 dx, WORD PTR [esi+edx*2]
  0022c	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx
$LN18@convert_yu:

; 310  :                     }
; 311  :                 }

  00230	e9 42 ff ff ff	 jmp	 $LN5@convert_yu
$LN16@convert_yu:

; 312  :             }
; 313  :         }

  00235	e9 e3 fe ff ff	 jmp	 $LN2@convert_yu
$LN14@convert_yu:

; 314  :     }
; 315  :     //UV
; 316  :     const int src_uv_pitch = src_uv_pitch_byte / sizeof(Tin);

  0023a	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0023d	d1 e8		 shr	 eax, 1
  0023f	89 45 ac	 mov	 DWORD PTR _src_uv_pitch$[ebp], eax

; 317  :     Tin *srcULine = (Tin *)src[1] + ((src_uv_pitch * y_range.start_src) + crop_left);

  00242	b9 04 00 00 00	 mov	 ecx, 4
  00247	c1 e1 00	 shl	 ecx, 0
  0024a	8b 55 ac	 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  0024d	0f af 55 d4	 imul	 edx, DWORD PTR _y_range$[ebp]
  00251	03 55 f8	 add	 edx, DWORD PTR _crop_left$[ebp]
  00254	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  00257	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  0025a	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  0025d	89 55 a8	 mov	 DWORD PTR _srcULine$[ebp], edx

; 318  :     Tin *srcVLine = (Tin *)src[2] + ((src_uv_pitch * y_range.start_src) + crop_left);

  00260	b8 04 00 00 00	 mov	 eax, 4
  00265	d1 e0		 shl	 eax, 1
  00267	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  0026a	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  0026e	03 4d f8	 add	 ecx, DWORD PTR _crop_left$[ebp]
  00271	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  00274	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  00277	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  0027a	89 4d a4	 mov	 DWORD PTR _srcVLine$[ebp], ecx

; 319  :     Tout *dstLine = (Tout *)dst[1] + (dst_y_pitch >> 1) * y_range.start_dst;

  0027d	ba 04 00 00 00	 mov	 edx, 4
  00282	c1 e2 00	 shl	 edx, 0
  00285	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  00288	d1 f8		 sar	 eax, 1
  0028a	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  0028e	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  00291	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  00294	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  00297	89 45 a0	 mov	 DWORD PTR _dstLine$[ebp], eax

; 320  :     for (int y = 0; y < y_range.len; y += 2, srcULine += src_uv_pitch * 2, srcVLine += src_uv_pitch * 2, dstLine += dst_y_pitch) {

  0029a	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR _y$17[ebp], 0
  002a1	eb 31		 jmp	 SHORT $LN10@convert_yu
$LN8@convert_yu:
  002a3	8b 4d 9c	 mov	 ecx, DWORD PTR _y$17[ebp]
  002a6	83 c1 02	 add	 ecx, 2
  002a9	89 4d 9c	 mov	 DWORD PTR _y$17[ebp], ecx
  002ac	8b 55 ac	 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  002af	d1 e2		 shl	 edx, 1
  002b1	8b 45 a8	 mov	 eax, DWORD PTR _srcULine$[ebp]
  002b4	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  002b7	89 4d a8	 mov	 DWORD PTR _srcULine$[ebp], ecx
  002ba	8b 55 ac	 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  002bd	d1 e2		 shl	 edx, 1
  002bf	8b 45 a4	 mov	 eax, DWORD PTR _srcVLine$[ebp]
  002c2	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  002c5	89 4d a4	 mov	 DWORD PTR _srcVLine$[ebp], ecx
  002c8	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  002cb	8b 45 a0	 mov	 eax, DWORD PTR _dstLine$[ebp]
  002ce	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  002d1	89 4d a0	 mov	 DWORD PTR _dstLine$[ebp], ecx
$LN10@convert_yu:
  002d4	8b 55 9c	 mov	 edx, DWORD PTR _y$17[ebp]
  002d7	3b 55 dc	 cmp	 edx, DWORD PTR _y_range$[ebp+8]
  002da	0f 8d 38 01 00
	00		 jge	 $LN1@convert_yu

; 321  :         Tout *dstC = dstLine;

  002e0	8b 45 a0	 mov	 eax, DWORD PTR _dstLine$[ebp]
  002e3	89 45 98	 mov	 DWORD PTR _dstC$16[ebp], eax

; 322  :         Tin *srcU = srcULine;

  002e6	8b 4d a8	 mov	 ecx, DWORD PTR _srcULine$[ebp]
  002e9	89 4d 94	 mov	 DWORD PTR _srcU$15[ebp], ecx

; 323  :         Tin *srcV = srcVLine;

  002ec	8b 55 a4	 mov	 edx, DWORD PTR _srcVLine$[ebp]
  002ef	89 55 90	 mov	 DWORD PTR _srcV$14[ebp], edx

; 324  :         const int x_fin = width - crop_right - crop_left;

  002f2	8b 45 10	 mov	 eax, DWORD PTR _width$[ebp]
  002f5	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  002f8	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  002fb	89 45 8c	 mov	 DWORD PTR _x_fin$13[ebp], eax

; 325  :         for (int x = 0; x < x_fin; x += 2, dstC += 2, srcU += 2, srcV += 2) {

  002fe	c7 45 88 00 00
	00 00		 mov	 DWORD PTR _x$12[ebp], 0
  00305	eb 24		 jmp	 SHORT $LN13@convert_yu
$LN11@convert_yu:
  00307	8b 4d 88	 mov	 ecx, DWORD PTR _x$12[ebp]
  0030a	83 c1 02	 add	 ecx, 2
  0030d	89 4d 88	 mov	 DWORD PTR _x$12[ebp], ecx
  00310	8b 55 98	 mov	 edx, DWORD PTR _dstC$16[ebp]
  00313	83 c2 04	 add	 edx, 4
  00316	89 55 98	 mov	 DWORD PTR _dstC$16[ebp], edx
  00319	8b 45 94	 mov	 eax, DWORD PTR _srcU$15[ebp]
  0031c	83 c0 04	 add	 eax, 4
  0031f	89 45 94	 mov	 DWORD PTR _srcU$15[ebp], eax
  00322	8b 4d 90	 mov	 ecx, DWORD PTR _srcV$14[ebp]
  00325	83 c1 04	 add	 ecx, 4
  00328	89 4d 90	 mov	 DWORD PTR _srcV$14[ebp], ecx
$LN13@convert_yu:
  0032b	8b 55 88	 mov	 edx, DWORD PTR _x$12[ebp]
  0032e	3b 55 8c	 cmp	 edx, DWORD PTR _x_fin$13[ebp]
  00331	0f 8d dc 00 00
	00		 jge	 $LN12@convert_yu

; 326  :             int cy0u = srcU[0*src_uv_pitch + 0];

  00337	6b 45 ac 00	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp], 0
  0033b	8b 4d 94	 mov	 ecx, DWORD PTR _srcU$15[ebp]
  0033e	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  00342	89 55 84	 mov	 DWORD PTR _cy0u$11[ebp], edx

; 327  :             int cy0v = srcV[0*src_uv_pitch + 0];

  00345	6b 45 ac 00	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp], 0
  00349	8b 4d 90	 mov	 ecx, DWORD PTR _srcV$14[ebp]
  0034c	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  00350	89 55 80	 mov	 DWORD PTR _cy0v$10[ebp], edx

; 328  :             int cy1u = srcU[1*src_uv_pitch + 0];

  00353	8b 45 ac	 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  00356	8b 4d 94	 mov	 ecx, DWORD PTR _srcU$15[ebp]
  00359	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  0035d	89 95 7c ff ff
	ff		 mov	 DWORD PTR _cy1u$9[ebp], edx

; 329  :             int cy1v = srcV[1*src_uv_pitch + 0];

  00363	8b 45 ac	 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  00366	8b 4d 90	 mov	 ecx, DWORD PTR _srcV$14[ebp]
  00369	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  0036d	89 95 78 ff ff
	ff		 mov	 DWORD PTR _cy1v$8[ebp], edx

; 330  : 
; 331  :             int cu = cy0u + cy1u + 1;

  00373	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _cy1u$9[ebp]
  00379	8b 4d 84	 mov	 ecx, DWORD PTR _cy0u$11[ebp]
  0037c	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  00380	89 95 74 ff ff
	ff		 mov	 DWORD PTR _cu$7[ebp], edx

; 332  :             int cv = cy0v + cy1v + 1;

  00386	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _cy1v$8[ebp]
  0038c	8b 4d 80	 mov	 ecx, DWORD PTR _cy0v$10[ebp]
  0038f	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  00393	89 95 70 ff ff
	ff		 mov	 DWORD PTR _cv$6[ebp], edx

; 333  :             CHANGE_BIT_DEPTH_2(cu, cv, 1);

  00399	33 c0		 xor	 eax, eax
  0039b	74 20		 je	 SHORT $LN21@convert_yu
  0039d	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _cu$7[ebp]
  003a3	c1 e1 ff	 shl	 ecx, -1
  003a6	89 8d 74 ff ff
	ff		 mov	 DWORD PTR _cu$7[ebp], ecx
  003ac	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR _cv$6[ebp]
  003b2	c1 e2 ff	 shl	 edx, -1
  003b5	89 95 70 ff ff
	ff		 mov	 DWORD PTR _cv$6[ebp], edx
  003bb	eb 25		 jmp	 SHORT $LN22@convert_yu
$LN21@convert_yu:
  003bd	b8 01 00 00 00	 mov	 eax, 1
  003c2	85 c0		 test	 eax, eax
  003c4	74 1c		 je	 SHORT $LN22@convert_yu
  003c6	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _cu$7[ebp]
  003cc	d1 f9		 sar	 ecx, 1
  003ce	89 8d 74 ff ff
	ff		 mov	 DWORD PTR _cu$7[ebp], ecx
  003d4	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR _cv$6[ebp]
  003da	d1 fa		 sar	 edx, 1
  003dc	89 95 70 ff ff
	ff		 mov	 DWORD PTR _cv$6[ebp], edx
$LN22@convert_yu:

; 334  : 
; 335  :             dstC[0] = (Tout)cu;

  003e2	b8 02 00 00 00	 mov	 eax, 2
  003e7	6b c8 00	 imul	 ecx, eax, 0
  003ea	8b 55 98	 mov	 edx, DWORD PTR _dstC$16[ebp]
  003ed	66 8b 85 74 ff
	ff ff		 mov	 ax, WORD PTR _cu$7[ebp]
  003f4	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax

; 336  :             dstC[1] = (Tout)cv;

  003f8	b9 02 00 00 00	 mov	 ecx, 2
  003fd	c1 e1 00	 shl	 ecx, 0
  00400	8b 55 98	 mov	 edx, DWORD PTR _dstC$16[ebp]
  00403	66 8b 85 70 ff
	ff ff		 mov	 ax, WORD PTR _cv$6[ebp]
  0040a	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax

; 337  :         }

  0040e	e9 f4 fe ff ff	 jmp	 $LN11@convert_yu
$LN12@convert_yu:

; 338  :     }

  00413	e9 8b fe ff ff	 jmp	 $LN8@convert_yu
$LN1@convert_yu:

; 339  : }

  00418	52		 push	 edx
  00419	8b cd		 mov	 ecx, ebp
  0041b	50		 push	 eax
  0041c	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN27@convert_yu
  00422	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00427	58		 pop	 eax
  00428	5a		 pop	 edx
  00429	5f		 pop	 edi
  0042a	5e		 pop	 esi
  0042b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0042e	33 cd		 xor	 ecx, ebp
  00430	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00435	81 c4 ac 00 00
	00		 add	 esp, 172		; 000000acH
  0043b	3b ec		 cmp	 ebp, esp
  0043d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00442	8b e5		 mov	 esp, ebp
  00444	5d		 pop	 ebp
  00445	c3		 ret	 0
  00446	66 90		 npad	 2
$LN27@convert_yu:
  00448	01 00 00 00	 DD	 1
  0044c	00 00 00 00	 DD	 $LN26@convert_yu
$LN26@convert_yu:
  00450	d4 ff ff ff	 DD	 -44			; ffffffd4H
  00454	0c 00 00 00	 DD	 12			; 0000000cH
  00458	00 00 00 00	 DD	 $LN25@convert_yu
$LN25@convert_yu:
  0045c	79		 DB	 121			; 00000079H
  0045d	5f		 DB	 95			; 0000005fH
  0045e	72		 DB	 114			; 00000072H
  0045f	61		 DB	 97			; 00000061H
  00460	6e		 DB	 110			; 0000006eH
  00461	67		 DB	 103			; 00000067H
  00462	65		 DB	 101			; 00000065H
  00463	00		 DB	 0
??$convert_yuv444_to_nv12_p_c@G$0BA@G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_to_nv12_p_c<unsigned short,16,unsigned short,16,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuv444_16_to_p010_p@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_16_to_p010_p

; 464  : static void convert_yuv444_16_to_p010_p(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 465  :     convert_yuv444_to_nv12_p_c<uint16_t, 16, uint16_t, 16, false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yuv444_to_nv12_p_c@G$0BA@G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_to_nv12_p_c<unsigned short,16,unsigned short,16,0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 466  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yuv444_16_to_p010_p@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_16_to_p010_p
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
$T1 = -200						; size = 4
$T2 = -196						; size = 4
$T3 = -192						; size = 4
$T4 = -188						; size = 4
$T5 = -184						; size = 12
_cv_y1$6 = -172						; size = 4
_cv_y0$7 = -168						; size = 4
_cu_y1$8 = -164						; size = 4
_cu_y0$9 = -160						; size = 4
_cy3v$10 = -156						; size = 4
_cy3u$11 = -152						; size = 4
_cy2v$12 = -148						; size = 4
_cy2u$13 = -144						; size = 4
_cy1v$14 = -140						; size = 4
_cy1u$15 = -136						; size = 4
_cy0v$16 = -132						; size = 4
_cy0u$17 = -128						; size = 4
_x$18 = -124						; size = 4
_x_fin$19 = -120					; size = 4
_srcV$20 = -116						; size = 4
_srcU$21 = -112						; size = 4
_dstC$22 = -108						; size = 4
_y$23 = -104						; size = 4
_uv_fin$ = -100						; size = 4
_dstLine$ = -96						; size = 4
_srcVLine$ = -92					; size = 4
_srcULine$ = -88					; size = 4
_src_uv_pitch$ = -84					; size = 4
_x$24 = -80						; size = 4
_y$25 = -76						; size = 4
_y_width$26 = -72					; size = 4
_dstLine$27 = -68					; size = 4
_srcYLine$28 = -64					; size = 4
$T29 = -60						; size = 12
_y_range$ = -44						; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yuv444_to_nv12_i_c@G$08E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_to_nv12_i_c<unsigned short,9,unsigned char,8,0>

; 342  : static void __forceinline convert_yuv444_to_nv12_i_c(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  00009	53		 push	 ebx
  0000a	57		 push	 edi
  0000b	8d bd 38 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-200]
  00011	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 343  :     static_assert((sizeof(Tin)  == 1 && in_bit_depth  == 8) || (sizeof(Tin)  == 2 && 8 < in_bit_depth  && in_bit_depth  <= 16), "invalid input bit depth.");
; 344  :     static_assert((sizeof(Tout) == 1 && out_bit_depth == 8) || (sizeof(Tout) == 2 && 8 < out_bit_depth && out_bit_depth <= 16), "invalid output bit depth.");
; 345  :     const int crop_left   = crop[0];

  00027	b8 04 00 00 00	 mov	 eax, 4
  0002c	6b c8 00	 imul	 ecx, eax, 0
  0002f	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00032	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00035	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 346  :     const int crop_up     = crop[1];

  00038	b9 04 00 00 00	 mov	 ecx, 4
  0003d	c1 e1 00	 shl	 ecx, 0
  00040	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00043	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00046	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 347  :     const int crop_right  = crop[2];

  00049	b9 04 00 00 00	 mov	 ecx, 4
  0004e	d1 e1		 shl	 ecx, 1
  00050	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00053	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00056	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 348  :     const int crop_bottom = crop[3];

  00059	b9 04 00 00 00	 mov	 ecx, 4
  0005e	6b d1 03	 imul	 edx, ecx, 3
  00061	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00064	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00067	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 349  :     const int src_y_pitch = src_y_pitch_byte / sizeof(Tin);

  0006a	8b 55 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebp]
  0006d	d1 ea		 shr	 edx, 1
  0006f	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 350  :     const int dst_y_pitch = dst_y_pitch_byte / sizeof(Tout);

  00072	8b 45 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  00075	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 351  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00078	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0007b	51		 push	 ecx
  0007c	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0007f	52		 push	 edx
  00080	8b 45 20	 mov	 eax, DWORD PTR _height$[ebp]
  00083	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  00086	50		 push	 eax
  00087	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  0008a	51		 push	 ecx
  0008b	8d 95 48 ff ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  00091	52		 push	 edx
  00092	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00097	83 c4 14	 add	 esp, 20			; 00000014H
  0009a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009c	89 4d c4	 mov	 DWORD PTR $T29[ebp], ecx
  0009f	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a2	89 55 c8	 mov	 DWORD PTR $T29[ebp+4], edx
  000a5	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000a8	89 45 cc	 mov	 DWORD PTR $T29[ebp+8], eax
  000ab	8b 4d c4	 mov	 ecx, DWORD PTR $T29[ebp]
  000ae	89 4d d4	 mov	 DWORD PTR _y_range$[ebp], ecx
  000b1	8b 55 c8	 mov	 edx, DWORD PTR $T29[ebp+4]
  000b4	89 55 d8	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000b7	8b 45 cc	 mov	 eax, DWORD PTR $T29[ebp+8]
  000ba	89 45 dc	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 352  :     //Y
; 353  :     if (!uv_only) {

  000bd	b9 01 00 00 00	 mov	 ecx, 1
  000c2	85 c9		 test	 ecx, ecx
  000c4	0f 84 61 01 00
	00		 je	 $LN14@convert_yu

; 354  :         Tin *srcYLine = (Tin *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000ca	ba 04 00 00 00	 mov	 edx, 4
  000cf	6b c2 00	 imul	 eax, edx, 0
  000d2	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  000d5	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  000d9	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  000dc	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  000df	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  000e2	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  000e5	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  000e8	89 45 c0	 mov	 DWORD PTR _srcYLine$28[ebp], eax

; 355  :         Tout *dstLine = (Tout *)dst[0] + dst_y_pitch * y_range.start_dst;

  000eb	b9 04 00 00 00	 mov	 ecx, 4
  000f0	6b d1 00	 imul	 edx, ecx, 0
  000f3	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  000f6	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  000fa	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  000fd	03 04 11	 add	 eax, DWORD PTR [ecx+edx]
  00100	89 45 bc	 mov	 DWORD PTR _dstLine$27[ebp], eax

; 356  :         const int y_width = width - crop_right - crop_left;

  00103	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00106	2b 55 f0	 sub	 edx, DWORD PTR _crop_right$[ebp]
  00109	2b 55 f8	 sub	 edx, DWORD PTR _crop_left$[ebp]
  0010c	89 55 b8	 mov	 DWORD PTR _y_width$26[ebp], edx

; 357  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  0010f	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _y$25[ebp], 0
  00116	eb 1e		 jmp	 SHORT $LN4@convert_yu
$LN2@convert_yu:
  00118	8b 45 b4	 mov	 eax, DWORD PTR _y$25[ebp]
  0011b	83 c0 01	 add	 eax, 1
  0011e	89 45 b4	 mov	 DWORD PTR _y$25[ebp], eax
  00121	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  00124	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$28[ebp]
  00127	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  0012a	89 45 c0	 mov	 DWORD PTR _srcYLine$28[ebp], eax
  0012d	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$27[ebp]
  00130	03 4d e4	 add	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  00133	89 4d bc	 mov	 DWORD PTR _dstLine$27[ebp], ecx
$LN4@convert_yu:
  00136	8b 55 b4	 mov	 edx, DWORD PTR _y$25[ebp]
  00139	3b 55 dc	 cmp	 edx, DWORD PTR _y_range$[ebp+8]
  0013c	0f 8d e9 00 00
	00		 jge	 $LN14@convert_yu

; 358  :             if (in_bit_depth == out_bit_depth && sizeof(Tin) == sizeof(Tout)) {

  00142	33 c0		 xor	 eax, eax
  00144	74 1b		 je	 SHORT $LN15@convert_yu

; 359  :                 memcpy(dstLine, srcYLine, y_width * sizeof(Tin));

  00146	8b 4d b8	 mov	 ecx, DWORD PTR _y_width$26[ebp]
  00149	d1 e1		 shl	 ecx, 1
  0014b	51		 push	 ecx
  0014c	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$28[ebp]
  0014f	52		 push	 edx
  00150	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$27[ebp]
  00153	50		 push	 eax
  00154	e8 00 00 00 00	 call	 _memcpy
  00159	83 c4 0c	 add	 esp, 12			; 0000000cH

; 360  :             } else {

  0015c	e9 c5 00 00 00	 jmp	 $LN16@convert_yu
$LN15@convert_yu:

; 361  :                 for (int x = 0; x < y_width; x++) {

  00161	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _x$24[ebp], 0
  00168	eb 09		 jmp	 SHORT $LN7@convert_yu
$LN5@convert_yu:
  0016a	8b 4d b0	 mov	 ecx, DWORD PTR _x$24[ebp]
  0016d	83 c1 01	 add	 ecx, 1
  00170	89 4d b0	 mov	 DWORD PTR _x$24[ebp], ecx
$LN7@convert_yu:
  00173	8b 55 b0	 mov	 edx, DWORD PTR _x$24[ebp]
  00176	3b 55 b8	 cmp	 edx, DWORD PTR _y_width$26[ebp]
  00179	0f 8d a7 00 00
	00		 jge	 $LN16@convert_yu

; 362  :                     if (out_bit_depth > in_bit_depth) {

  0017f	33 c0		 xor	 eax, eax
  00181	74 42		 je	 SHORT $LN17@convert_yu

; 363  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) << std::max(out_bit_depth - in_bit_depth, 0));

  00183	c7 85 44 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], 0
  0018d	c7 85 40 ff ff
	ff ff ff ff ff	 mov	 DWORD PTR $T3[ebp], -1
  00197	8b 4d b0	 mov	 ecx, DWORD PTR _x$24[ebp]
  0019a	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$28[ebp]
  0019d	0f b7 1c 4a	 movzx	 ebx, WORD PTR [edx+ecx*2]
  001a1	8d 85 44 ff ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  001a7	50		 push	 eax
  001a8	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  001ae	51		 push	 ecx
  001af	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  001b4	83 c4 08	 add	 esp, 8
  001b7	8b 08		 mov	 ecx, DWORD PTR [eax]
  001b9	d3 e3		 shl	 ebx, cl
  001bb	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$27[ebp]
  001be	03 55 b0	 add	 edx, DWORD PTR _x$24[ebp]
  001c1	88 1a		 mov	 BYTE PTR [edx], bl
  001c3	eb 5c		 jmp	 SHORT $LN18@convert_yu
$LN17@convert_yu:

; 364  :                     } else if (out_bit_depth < in_bit_depth) {

  001c5	b8 01 00 00 00	 mov	 eax, 1
  001ca	85 c0		 test	 eax, eax
  001cc	74 42		 je	 SHORT $LN19@convert_yu

; 365  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) >> std::max(in_bit_depth - out_bit_depth, 0));

  001ce	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], 0
  001d8	c7 85 38 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR $T1[ebp], 1
  001e2	8b 4d b0	 mov	 ecx, DWORD PTR _x$24[ebp]
  001e5	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$28[ebp]
  001e8	0f b7 1c 4a	 movzx	 ebx, WORD PTR [edx+ecx*2]
  001ec	8d 85 3c ff ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  001f2	50		 push	 eax
  001f3	8d 8d 38 ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  001f9	51		 push	 ecx
  001fa	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  001ff	83 c4 08	 add	 esp, 8
  00202	8b 08		 mov	 ecx, DWORD PTR [eax]
  00204	d3 fb		 sar	 ebx, cl
  00206	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$27[ebp]
  00209	03 55 b0	 add	 edx, DWORD PTR _x$24[ebp]
  0020c	88 1a		 mov	 BYTE PTR [edx], bl

; 366  :                     } else {

  0020e	eb 11		 jmp	 SHORT $LN18@convert_yu
$LN19@convert_yu:

; 367  :                         dstLine[x] = (Tout)srcYLine[x];

  00210	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$27[ebp]
  00213	03 45 b0	 add	 eax, DWORD PTR _x$24[ebp]
  00216	8b 4d b0	 mov	 ecx, DWORD PTR _x$24[ebp]
  00219	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$28[ebp]
  0021c	8a 0c 4a	 mov	 cl, BYTE PTR [edx+ecx*2]
  0021f	88 08		 mov	 BYTE PTR [eax], cl
$LN18@convert_yu:

; 368  :                     }
; 369  :                 }

  00221	e9 44 ff ff ff	 jmp	 $LN5@convert_yu
$LN16@convert_yu:

; 370  :             }
; 371  :         }

  00226	e9 ed fe ff ff	 jmp	 $LN2@convert_yu
$LN14@convert_yu:

; 372  :     }
; 373  :     //UV
; 374  :     const int src_uv_pitch = src_uv_pitch_byte / sizeof(Tin);

  0022b	8b 55 18	 mov	 edx, DWORD PTR _src_uv_pitch_byte$[ebp]
  0022e	d1 ea		 shr	 edx, 1
  00230	89 55 ac	 mov	 DWORD PTR _src_uv_pitch$[ebp], edx

; 375  :     Tin *srcULine = (Tin *)src[1] + ((src_uv_pitch * y_range.start_src) + crop_left);

  00233	b8 04 00 00 00	 mov	 eax, 4
  00238	c1 e0 00	 shl	 eax, 0
  0023b	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  0023e	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  00242	03 4d f8	 add	 ecx, DWORD PTR _crop_left$[ebp]
  00245	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  00248	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  0024b	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  0024e	89 4d a8	 mov	 DWORD PTR _srcULine$[ebp], ecx

; 376  :     Tin *srcVLine = (Tin *)src[2] + ((src_uv_pitch * y_range.start_src) + crop_left);

  00251	ba 04 00 00 00	 mov	 edx, 4
  00256	d1 e2		 shl	 edx, 1
  00258	8b 45 ac	 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  0025b	0f af 45 d4	 imul	 eax, DWORD PTR _y_range$[ebp]
  0025f	03 45 f8	 add	 eax, DWORD PTR _crop_left$[ebp]
  00262	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  00265	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  00268	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  0026b	89 45 a4	 mov	 DWORD PTR _srcVLine$[ebp], eax

; 377  :     Tout *dstLine = (Tout *)dst[1] + (dst_y_pitch >> 1) * y_range.start_dst;

  0026e	b9 04 00 00 00	 mov	 ecx, 4
  00273	c1 e1 00	 shl	 ecx, 0
  00276	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  00279	d1 fa		 sar	 edx, 1
  0027b	0f af 55 d8	 imul	 edx, DWORD PTR _y_range$[ebp+4]
  0027f	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
  00282	03 14 08	 add	 edx, DWORD PTR [eax+ecx]
  00285	89 55 a0	 mov	 DWORD PTR _dstLine$[ebp], edx

; 378  :     const int uv_fin = height - crop_bottom - crop_up;

  00288	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  0028b	2b 4d ec	 sub	 ecx, DWORD PTR _crop_bottom$[ebp]
  0028e	2b 4d f4	 sub	 ecx, DWORD PTR _crop_up$[ebp]
  00291	89 4d 9c	 mov	 DWORD PTR _uv_fin$[ebp], ecx

; 379  :     for (int y = 0; y < y_range.len; y += 4, srcULine += src_uv_pitch * 4, srcVLine += src_uv_pitch * 4, dstLine += dst_y_pitch * 2) {

  00294	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _y$23[ebp], 0
  0029b	eb 33		 jmp	 SHORT $LN10@convert_yu
$LN8@convert_yu:
  0029d	8b 55 98	 mov	 edx, DWORD PTR _y$23[ebp]
  002a0	83 c2 04	 add	 edx, 4
  002a3	89 55 98	 mov	 DWORD PTR _y$23[ebp], edx
  002a6	8b 45 ac	 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  002a9	c1 e0 02	 shl	 eax, 2
  002ac	8b 4d a8	 mov	 ecx, DWORD PTR _srcULine$[ebp]
  002af	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  002b2	89 55 a8	 mov	 DWORD PTR _srcULine$[ebp], edx
  002b5	8b 45 ac	 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  002b8	c1 e0 02	 shl	 eax, 2
  002bb	8b 4d a4	 mov	 ecx, DWORD PTR _srcVLine$[ebp]
  002be	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  002c1	89 55 a4	 mov	 DWORD PTR _srcVLine$[ebp], edx
  002c4	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  002c7	8b 4d a0	 mov	 ecx, DWORD PTR _dstLine$[ebp]
  002ca	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  002cd	89 55 a0	 mov	 DWORD PTR _dstLine$[ebp], edx
$LN10@convert_yu:
  002d0	8b 45 98	 mov	 eax, DWORD PTR _y$23[ebp]
  002d3	3b 45 dc	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  002d6	0f 8d 04 02 00
	00		 jge	 $LN1@convert_yu

; 380  :         Tout *dstC = dstLine;

  002dc	8b 4d a0	 mov	 ecx, DWORD PTR _dstLine$[ebp]
  002df	89 4d 94	 mov	 DWORD PTR _dstC$22[ebp], ecx

; 381  :         Tin *srcU = srcULine;

  002e2	8b 55 a8	 mov	 edx, DWORD PTR _srcULine$[ebp]
  002e5	89 55 90	 mov	 DWORD PTR _srcU$21[ebp], edx

; 382  :         Tin *srcV = srcVLine;

  002e8	8b 45 a4	 mov	 eax, DWORD PTR _srcVLine$[ebp]
  002eb	89 45 8c	 mov	 DWORD PTR _srcV$20[ebp], eax

; 383  :         const int x_fin = width - crop_right - crop_left;

  002ee	8b 4d 10	 mov	 ecx, DWORD PTR _width$[ebp]
  002f1	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  002f4	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  002f7	89 4d 88	 mov	 DWORD PTR _x_fin$19[ebp], ecx

; 384  :         for (int x = 0; x < x_fin; x += 2, dstC += 2, srcU += 2, srcV += 2) {

  002fa	c7 45 84 00 00
	00 00		 mov	 DWORD PTR _x$18[ebp], 0
  00301	eb 24		 jmp	 SHORT $LN13@convert_yu
$LN11@convert_yu:
  00303	8b 55 84	 mov	 edx, DWORD PTR _x$18[ebp]
  00306	83 c2 02	 add	 edx, 2
  00309	89 55 84	 mov	 DWORD PTR _x$18[ebp], edx
  0030c	8b 45 94	 mov	 eax, DWORD PTR _dstC$22[ebp]
  0030f	83 c0 02	 add	 eax, 2
  00312	89 45 94	 mov	 DWORD PTR _dstC$22[ebp], eax
  00315	8b 4d 90	 mov	 ecx, DWORD PTR _srcU$21[ebp]
  00318	83 c1 04	 add	 ecx, 4
  0031b	89 4d 90	 mov	 DWORD PTR _srcU$21[ebp], ecx
  0031e	8b 55 8c	 mov	 edx, DWORD PTR _srcV$20[ebp]
  00321	83 c2 04	 add	 edx, 4
  00324	89 55 8c	 mov	 DWORD PTR _srcV$20[ebp], edx
$LN13@convert_yu:
  00327	8b 45 84	 mov	 eax, DWORD PTR _x$18[ebp]
  0032a	3b 45 88	 cmp	 eax, DWORD PTR _x_fin$19[ebp]
  0032d	0f 8d a8 01 00
	00		 jge	 $LN12@convert_yu

; 385  :             int cy0u = srcU[0*src_uv_pitch + 0];

  00333	6b 4d ac 00	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 0
  00337	8b 55 90	 mov	 edx, DWORD PTR _srcU$21[ebp]
  0033a	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  0033e	89 45 80	 mov	 DWORD PTR _cy0u$17[ebp], eax

; 386  :             int cy0v = srcV[0*src_uv_pitch + 0];

  00341	6b 4d ac 00	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 0
  00345	8b 55 8c	 mov	 edx, DWORD PTR _srcV$20[ebp]
  00348	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  0034c	89 85 7c ff ff
	ff		 mov	 DWORD PTR _cy0v$16[ebp], eax

; 387  :             int cy1u = srcU[1*src_uv_pitch + 0];

  00352	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00355	8b 55 90	 mov	 edx, DWORD PTR _srcU$21[ebp]
  00358	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  0035c	89 85 78 ff ff
	ff		 mov	 DWORD PTR _cy1u$15[ebp], eax

; 388  :             int cy1v = srcV[1*src_uv_pitch + 0];

  00362	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00365	8b 55 8c	 mov	 edx, DWORD PTR _srcV$20[ebp]
  00368	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  0036c	89 85 74 ff ff
	ff		 mov	 DWORD PTR _cy1v$14[ebp], eax

; 389  :             int cy2u = srcU[2*src_uv_pitch + 0];

  00372	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00375	d1 e1		 shl	 ecx, 1
  00377	8b 55 90	 mov	 edx, DWORD PTR _srcU$21[ebp]
  0037a	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  0037e	89 85 70 ff ff
	ff		 mov	 DWORD PTR _cy2u$13[ebp], eax

; 390  :             int cy2v = srcV[2*src_uv_pitch + 0];

  00384	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00387	d1 e1		 shl	 ecx, 1
  00389	8b 55 8c	 mov	 edx, DWORD PTR _srcV$20[ebp]
  0038c	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00390	89 85 6c ff ff
	ff		 mov	 DWORD PTR _cy2v$12[ebp], eax

; 391  :             int cy3u = srcU[3*src_uv_pitch + 0];

  00396	6b 4d ac 03	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 3
  0039a	8b 55 90	 mov	 edx, DWORD PTR _srcU$21[ebp]
  0039d	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  003a1	89 85 68 ff ff
	ff		 mov	 DWORD PTR _cy3u$11[ebp], eax

; 392  :             int cy3v = srcV[3*src_uv_pitch + 0];

  003a7	6b 4d ac 03	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 3
  003ab	8b 55 8c	 mov	 edx, DWORD PTR _srcV$20[ebp]
  003ae	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  003b2	89 85 64 ff ff
	ff		 mov	 DWORD PTR _cy3v$10[ebp], eax

; 393  : 
; 394  :             int cu_y0 = cy0u * 3 + cy2u * 1 + 2;

  003b8	6b 4d 80 03	 imul	 ecx, DWORD PTR _cy0u$17[ebp], 3
  003bc	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR _cy2u$13[ebp]
  003c2	8d 44 11 02	 lea	 eax, DWORD PTR [ecx+edx+2]
  003c6	89 85 60 ff ff
	ff		 mov	 DWORD PTR _cu_y0$9[ebp], eax

; 395  :             int cu_y1 = cy1u * 1 + cy3u * 3 + 2;

  003cc	6b 8d 68 ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy3u$11[ebp], 3
  003d3	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _cy1u$15[ebp]
  003d9	8d 44 0a 02	 lea	 eax, DWORD PTR [edx+ecx+2]
  003dd	89 85 5c ff ff
	ff		 mov	 DWORD PTR _cu_y1$8[ebp], eax

; 396  :             int cv_y0 = cy0v * 3 + cy2v * 1 + 2;

  003e3	6b 8d 7c ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy0v$16[ebp], 3
  003ea	8b 95 6c ff ff
	ff		 mov	 edx, DWORD PTR _cy2v$12[ebp]
  003f0	8d 44 11 02	 lea	 eax, DWORD PTR [ecx+edx+2]
  003f4	89 85 58 ff ff
	ff		 mov	 DWORD PTR _cv_y0$7[ebp], eax

; 397  :             int cv_y1 = cy1v * 1 + cy3v * 3 + 2;

  003fa	6b 8d 64 ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy3v$10[ebp], 3
  00401	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _cy1v$14[ebp]
  00407	8d 44 0a 02	 lea	 eax, DWORD PTR [edx+ecx+2]
  0040b	89 85 54 ff ff
	ff		 mov	 DWORD PTR _cv_y1$6[ebp], eax

; 398  :             CHANGE_BIT_DEPTH_4(cu_y0, cu_y1, cv_y0, cv_y1, 2);

  00411	33 c9		 xor	 ecx, ecx
  00413	74 3e		 je	 SHORT $LN21@convert_yu
  00415	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _cu_y0$9[ebp]
  0041b	c1 e2 fd	 shl	 edx, -3			; fffffffdH
  0041e	89 95 60 ff ff
	ff		 mov	 DWORD PTR _cu_y0$9[ebp], edx
  00424	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _cu_y1$8[ebp]
  0042a	c1 e0 fd	 shl	 eax, -3			; fffffffdH
  0042d	89 85 5c ff ff
	ff		 mov	 DWORD PTR _cu_y1$8[ebp], eax
  00433	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _cv_y0$7[ebp]
  00439	c1 e1 fd	 shl	 ecx, -3			; fffffffdH
  0043c	89 8d 58 ff ff
	ff		 mov	 DWORD PTR _cv_y0$7[ebp], ecx
  00442	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR _cv_y1$6[ebp]
  00448	c1 e2 fd	 shl	 edx, -3			; fffffffdH
  0044b	89 95 54 ff ff
	ff		 mov	 DWORD PTR _cv_y1$6[ebp], edx
  00451	eb 45		 jmp	 SHORT $LN22@convert_yu
$LN21@convert_yu:
  00453	b8 01 00 00 00	 mov	 eax, 1
  00458	85 c0		 test	 eax, eax
  0045a	74 3c		 je	 SHORT $LN22@convert_yu
  0045c	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _cu_y0$9[ebp]
  00462	c1 f9 03	 sar	 ecx, 3
  00465	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _cu_y0$9[ebp], ecx
  0046b	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR _cu_y1$8[ebp]
  00471	c1 fa 03	 sar	 edx, 3
  00474	89 95 5c ff ff
	ff		 mov	 DWORD PTR _cu_y1$8[ebp], edx
  0047a	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _cv_y0$7[ebp]
  00480	c1 f8 03	 sar	 eax, 3
  00483	89 85 58 ff ff
	ff		 mov	 DWORD PTR _cv_y0$7[ebp], eax
  00489	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _cv_y1$6[ebp]
  0048f	c1 f9 03	 sar	 ecx, 3
  00492	89 8d 54 ff ff
	ff		 mov	 DWORD PTR _cv_y1$6[ebp], ecx
$LN22@convert_yu:

; 399  : 
; 400  :             dstC[0*dst_y_pitch + 0] = (Tout)cu_y0;

  00498	6b 55 e4 00	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 0
  0049c	8b 45 94	 mov	 eax, DWORD PTR _dstC$22[ebp]
  0049f	8a 8d 60 ff ff
	ff		 mov	 cl, BYTE PTR _cu_y0$9[ebp]
  004a5	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 401  :             dstC[0*dst_y_pitch + 1] = (Tout)cv_y0;

  004a8	6b 55 e4 00	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 0
  004ac	8b 45 94	 mov	 eax, DWORD PTR _dstC$22[ebp]
  004af	8a 8d 58 ff ff
	ff		 mov	 cl, BYTE PTR _cv_y0$7[ebp]
  004b5	88 4c 10 01	 mov	 BYTE PTR [eax+edx+1], cl

; 402  :             dstC[1*dst_y_pitch + 0] = (Tout)cu_y1;

  004b9	8b 55 94	 mov	 edx, DWORD PTR _dstC$22[ebp]
  004bc	03 55 e4	 add	 edx, DWORD PTR _dst_y_pitch$[ebp]
  004bf	8a 85 5c ff ff
	ff		 mov	 al, BYTE PTR _cu_y1$8[ebp]
  004c5	88 02		 mov	 BYTE PTR [edx], al

; 403  :             dstC[1*dst_y_pitch + 1] = (Tout)cv_y1;

  004c7	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$22[ebp]
  004ca	03 4d e4	 add	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  004cd	8a 95 54 ff ff
	ff		 mov	 dl, BYTE PTR _cv_y1$6[ebp]
  004d3	88 51 01	 mov	 BYTE PTR [ecx+1], dl

; 404  :         }

  004d6	e9 28 fe ff ff	 jmp	 $LN11@convert_yu
$LN12@convert_yu:

; 405  :     }

  004db	e9 bd fd ff ff	 jmp	 $LN8@convert_yu
$LN1@convert_yu:

; 406  : }

  004e0	52		 push	 edx
  004e1	8b cd		 mov	 ecx, ebp
  004e3	50		 push	 eax
  004e4	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN27@convert_yu
  004ea	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  004ef	58		 pop	 eax
  004f0	5a		 pop	 edx
  004f1	5f		 pop	 edi
  004f2	5b		 pop	 ebx
  004f3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004f6	33 cd		 xor	 ecx, ebp
  004f8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004fd	81 c4 c8 00 00
	00		 add	 esp, 200		; 000000c8H
  00503	3b ec		 cmp	 ebp, esp
  00505	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0050a	8b e5		 mov	 esp, ebp
  0050c	5d		 pop	 ebp
  0050d	c3		 ret	 0
  0050e	66 90		 npad	 2
$LN27@convert_yu:
  00510	01 00 00 00	 DD	 1
  00514	00 00 00 00	 DD	 $LN26@convert_yu
$LN26@convert_yu:
  00518	d4 ff ff ff	 DD	 -44			; ffffffd4H
  0051c	0c 00 00 00	 DD	 12			; 0000000cH
  00520	00 00 00 00	 DD	 $LN25@convert_yu
$LN25@convert_yu:
  00524	79		 DB	 121			; 00000079H
  00525	5f		 DB	 95			; 0000005fH
  00526	72		 DB	 114			; 00000072H
  00527	61		 DB	 97			; 00000061H
  00528	6e		 DB	 110			; 0000006eH
  00529	67		 DB	 103			; 00000067H
  0052a	65		 DB	 101			; 00000065H
  0052b	00		 DB	 0
??$convert_yuv444_to_nv12_i_c@G$08E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_to_nv12_i_c<unsigned short,9,unsigned char,8,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuv444_09_to_nv12_i@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_09_to_nv12_i

; 460  : static void convert_yuv444_09_to_nv12_i(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 461  :     convert_yuv444_to_nv12_i_c<uint16_t, 9, uint8_t, 8, false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yuv444_to_nv12_i_c@G$08E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_to_nv12_i_c<unsigned short,9,unsigned char,8,0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 462  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yuv444_09_to_nv12_i@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_09_to_nv12_i
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
$T1 = -172						; size = 4
$T2 = -168						; size = 4
$T3 = -164						; size = 4
$T4 = -160						; size = 4
$T5 = -156						; size = 12
_cv$6 = -144						; size = 4
_cu$7 = -140						; size = 4
_cy1v$8 = -136						; size = 4
_cy1u$9 = -132						; size = 4
_cy0v$10 = -128						; size = 4
_cy0u$11 = -124						; size = 4
_x$12 = -120						; size = 4
_x_fin$13 = -116					; size = 4
_srcV$14 = -112						; size = 4
_srcU$15 = -108						; size = 4
_dstC$16 = -104						; size = 4
_y$17 = -100						; size = 4
_dstLine$ = -96						; size = 4
_srcVLine$ = -92					; size = 4
_srcULine$ = -88					; size = 4
_src_uv_pitch$ = -84					; size = 4
_x$18 = -80						; size = 4
_y$19 = -76						; size = 4
_y_width$20 = -72					; size = 4
_dstLine$21 = -68					; size = 4
_srcYLine$22 = -64					; size = 4
$T23 = -60						; size = 12
_y_range$ = -44						; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yuv444_to_nv12_p_c@G$08E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_to_nv12_p_c<unsigned short,9,unsigned char,8,0>

; 284  : static void __forceinline convert_yuv444_to_nv12_p_c(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec ac 00 00
	00		 sub	 esp, 172		; 000000acH
  00009	53		 push	 ebx
  0000a	57		 push	 edi
  0000b	8d bd 54 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-172]
  00011	b9 2b 00 00 00	 mov	 ecx, 43			; 0000002bH
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 285  :     static_assert((sizeof(Tin)  == 1 && in_bit_depth  == 8) || (sizeof(Tin)  == 2 && 8 < in_bit_depth  && in_bit_depth  <= 16), "invalid input bit depth.");
; 286  :     static_assert((sizeof(Tout) == 1 && out_bit_depth == 8) || (sizeof(Tout) == 2 && 8 < out_bit_depth && out_bit_depth <= 16), "invalid output bit depth.");
; 287  :     const int crop_left   = crop[0];

  00027	b8 04 00 00 00	 mov	 eax, 4
  0002c	6b c8 00	 imul	 ecx, eax, 0
  0002f	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00032	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00035	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 288  :     const int crop_up     = crop[1];

  00038	b9 04 00 00 00	 mov	 ecx, 4
  0003d	c1 e1 00	 shl	 ecx, 0
  00040	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00043	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00046	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 289  :     const int crop_right  = crop[2];

  00049	b9 04 00 00 00	 mov	 ecx, 4
  0004e	d1 e1		 shl	 ecx, 1
  00050	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00053	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00056	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 290  :     const int crop_bottom = crop[3];

  00059	b9 04 00 00 00	 mov	 ecx, 4
  0005e	6b d1 03	 imul	 edx, ecx, 3
  00061	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00064	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00067	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 291  :     const int src_y_pitch = src_y_pitch_byte / sizeof(Tin);

  0006a	8b 55 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebp]
  0006d	d1 ea		 shr	 edx, 1
  0006f	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 292  :     const int dst_y_pitch = dst_y_pitch_byte / sizeof(Tout);

  00072	8b 45 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  00075	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 293  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00078	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0007b	51		 push	 ecx
  0007c	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0007f	52		 push	 edx
  00080	8b 45 20	 mov	 eax, DWORD PTR _height$[ebp]
  00083	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  00086	50		 push	 eax
  00087	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  0008a	51		 push	 ecx
  0008b	8d 95 64 ff ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  00091	52		 push	 edx
  00092	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00097	83 c4 14	 add	 esp, 20			; 00000014H
  0009a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009c	89 4d c4	 mov	 DWORD PTR $T23[ebp], ecx
  0009f	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a2	89 55 c8	 mov	 DWORD PTR $T23[ebp+4], edx
  000a5	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000a8	89 45 cc	 mov	 DWORD PTR $T23[ebp+8], eax
  000ab	8b 4d c4	 mov	 ecx, DWORD PTR $T23[ebp]
  000ae	89 4d d4	 mov	 DWORD PTR _y_range$[ebp], ecx
  000b1	8b 55 c8	 mov	 edx, DWORD PTR $T23[ebp+4]
  000b4	89 55 d8	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000b7	8b 45 cc	 mov	 eax, DWORD PTR $T23[ebp+8]
  000ba	89 45 dc	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 294  :     //Y
; 295  :     if (!uv_only) {

  000bd	b9 01 00 00 00	 mov	 ecx, 1
  000c2	85 c9		 test	 ecx, ecx
  000c4	0f 84 61 01 00
	00		 je	 $LN14@convert_yu

; 296  :         Tin *srcYLine = (Tin *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000ca	ba 04 00 00 00	 mov	 edx, 4
  000cf	6b c2 00	 imul	 eax, edx, 0
  000d2	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  000d5	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  000d9	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  000dc	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  000df	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  000e2	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  000e5	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  000e8	89 45 c0	 mov	 DWORD PTR _srcYLine$22[ebp], eax

; 297  :         Tout *dstLine = (Tout *)dst[0] + dst_y_pitch * y_range.start_dst;

  000eb	b9 04 00 00 00	 mov	 ecx, 4
  000f0	6b d1 00	 imul	 edx, ecx, 0
  000f3	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  000f6	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  000fa	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  000fd	03 04 11	 add	 eax, DWORD PTR [ecx+edx]
  00100	89 45 bc	 mov	 DWORD PTR _dstLine$21[ebp], eax

; 298  :         const int y_width = width - crop_right - crop_left;

  00103	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00106	2b 55 f0	 sub	 edx, DWORD PTR _crop_right$[ebp]
  00109	2b 55 f8	 sub	 edx, DWORD PTR _crop_left$[ebp]
  0010c	89 55 b8	 mov	 DWORD PTR _y_width$20[ebp], edx

; 299  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  0010f	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _y$19[ebp], 0
  00116	eb 1e		 jmp	 SHORT $LN4@convert_yu
$LN2@convert_yu:
  00118	8b 45 b4	 mov	 eax, DWORD PTR _y$19[ebp]
  0011b	83 c0 01	 add	 eax, 1
  0011e	89 45 b4	 mov	 DWORD PTR _y$19[ebp], eax
  00121	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  00124	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$22[ebp]
  00127	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  0012a	89 45 c0	 mov	 DWORD PTR _srcYLine$22[ebp], eax
  0012d	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$21[ebp]
  00130	03 4d e4	 add	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  00133	89 4d bc	 mov	 DWORD PTR _dstLine$21[ebp], ecx
$LN4@convert_yu:
  00136	8b 55 b4	 mov	 edx, DWORD PTR _y$19[ebp]
  00139	3b 55 dc	 cmp	 edx, DWORD PTR _y_range$[ebp+8]
  0013c	0f 8d e9 00 00
	00		 jge	 $LN14@convert_yu

; 300  :             if (in_bit_depth == out_bit_depth && sizeof(Tin) == sizeof(Tout)) {

  00142	33 c0		 xor	 eax, eax
  00144	74 1b		 je	 SHORT $LN15@convert_yu

; 301  :                 memcpy(dstLine, srcYLine, y_width * sizeof(Tin));

  00146	8b 4d b8	 mov	 ecx, DWORD PTR _y_width$20[ebp]
  00149	d1 e1		 shl	 ecx, 1
  0014b	51		 push	 ecx
  0014c	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$22[ebp]
  0014f	52		 push	 edx
  00150	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$21[ebp]
  00153	50		 push	 eax
  00154	e8 00 00 00 00	 call	 _memcpy
  00159	83 c4 0c	 add	 esp, 12			; 0000000cH

; 302  :             } else {

  0015c	e9 c5 00 00 00	 jmp	 $LN16@convert_yu
$LN15@convert_yu:

; 303  :                 for (int x = 0; x < y_width; x++) {

  00161	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _x$18[ebp], 0
  00168	eb 09		 jmp	 SHORT $LN7@convert_yu
$LN5@convert_yu:
  0016a	8b 4d b0	 mov	 ecx, DWORD PTR _x$18[ebp]
  0016d	83 c1 01	 add	 ecx, 1
  00170	89 4d b0	 mov	 DWORD PTR _x$18[ebp], ecx
$LN7@convert_yu:
  00173	8b 55 b0	 mov	 edx, DWORD PTR _x$18[ebp]
  00176	3b 55 b8	 cmp	 edx, DWORD PTR _y_width$20[ebp]
  00179	0f 8d a7 00 00
	00		 jge	 $LN16@convert_yu

; 304  :                     if (out_bit_depth > in_bit_depth) {

  0017f	33 c0		 xor	 eax, eax
  00181	74 42		 je	 SHORT $LN17@convert_yu

; 305  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) << std::max(out_bit_depth - in_bit_depth, 0));

  00183	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], 0
  0018d	c7 85 5c ff ff
	ff ff ff ff ff	 mov	 DWORD PTR $T3[ebp], -1
  00197	8b 4d b0	 mov	 ecx, DWORD PTR _x$18[ebp]
  0019a	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$22[ebp]
  0019d	0f b7 1c 4a	 movzx	 ebx, WORD PTR [edx+ecx*2]
  001a1	8d 85 60 ff ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  001a7	50		 push	 eax
  001a8	8d 8d 5c ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  001ae	51		 push	 ecx
  001af	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  001b4	83 c4 08	 add	 esp, 8
  001b7	8b 08		 mov	 ecx, DWORD PTR [eax]
  001b9	d3 e3		 shl	 ebx, cl
  001bb	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$21[ebp]
  001be	03 55 b0	 add	 edx, DWORD PTR _x$18[ebp]
  001c1	88 1a		 mov	 BYTE PTR [edx], bl
  001c3	eb 5c		 jmp	 SHORT $LN18@convert_yu
$LN17@convert_yu:

; 306  :                     } else if (out_bit_depth < in_bit_depth) {

  001c5	b8 01 00 00 00	 mov	 eax, 1
  001ca	85 c0		 test	 eax, eax
  001cc	74 42		 je	 SHORT $LN19@convert_yu

; 307  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) >> std::max(in_bit_depth - out_bit_depth, 0));

  001ce	c7 85 58 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], 0
  001d8	c7 85 54 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR $T1[ebp], 1
  001e2	8b 4d b0	 mov	 ecx, DWORD PTR _x$18[ebp]
  001e5	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$22[ebp]
  001e8	0f b7 1c 4a	 movzx	 ebx, WORD PTR [edx+ecx*2]
  001ec	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  001f2	50		 push	 eax
  001f3	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  001f9	51		 push	 ecx
  001fa	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  001ff	83 c4 08	 add	 esp, 8
  00202	8b 08		 mov	 ecx, DWORD PTR [eax]
  00204	d3 fb		 sar	 ebx, cl
  00206	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$21[ebp]
  00209	03 55 b0	 add	 edx, DWORD PTR _x$18[ebp]
  0020c	88 1a		 mov	 BYTE PTR [edx], bl

; 308  :                     } else {

  0020e	eb 11		 jmp	 SHORT $LN18@convert_yu
$LN19@convert_yu:

; 309  :                         dstLine[x] = (Tout)srcYLine[x];

  00210	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$21[ebp]
  00213	03 45 b0	 add	 eax, DWORD PTR _x$18[ebp]
  00216	8b 4d b0	 mov	 ecx, DWORD PTR _x$18[ebp]
  00219	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$22[ebp]
  0021c	8a 0c 4a	 mov	 cl, BYTE PTR [edx+ecx*2]
  0021f	88 08		 mov	 BYTE PTR [eax], cl
$LN18@convert_yu:

; 310  :                     }
; 311  :                 }

  00221	e9 44 ff ff ff	 jmp	 $LN5@convert_yu
$LN16@convert_yu:

; 312  :             }
; 313  :         }

  00226	e9 ed fe ff ff	 jmp	 $LN2@convert_yu
$LN14@convert_yu:

; 314  :     }
; 315  :     //UV
; 316  :     const int src_uv_pitch = src_uv_pitch_byte / sizeof(Tin);

  0022b	8b 55 18	 mov	 edx, DWORD PTR _src_uv_pitch_byte$[ebp]
  0022e	d1 ea		 shr	 edx, 1
  00230	89 55 ac	 mov	 DWORD PTR _src_uv_pitch$[ebp], edx

; 317  :     Tin *srcULine = (Tin *)src[1] + ((src_uv_pitch * y_range.start_src) + crop_left);

  00233	b8 04 00 00 00	 mov	 eax, 4
  00238	c1 e0 00	 shl	 eax, 0
  0023b	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  0023e	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  00242	03 4d f8	 add	 ecx, DWORD PTR _crop_left$[ebp]
  00245	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  00248	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  0024b	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  0024e	89 4d a8	 mov	 DWORD PTR _srcULine$[ebp], ecx

; 318  :     Tin *srcVLine = (Tin *)src[2] + ((src_uv_pitch * y_range.start_src) + crop_left);

  00251	ba 04 00 00 00	 mov	 edx, 4
  00256	d1 e2		 shl	 edx, 1
  00258	8b 45 ac	 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  0025b	0f af 45 d4	 imul	 eax, DWORD PTR _y_range$[ebp]
  0025f	03 45 f8	 add	 eax, DWORD PTR _crop_left$[ebp]
  00262	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  00265	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  00268	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  0026b	89 45 a4	 mov	 DWORD PTR _srcVLine$[ebp], eax

; 319  :     Tout *dstLine = (Tout *)dst[1] + (dst_y_pitch >> 1) * y_range.start_dst;

  0026e	b9 04 00 00 00	 mov	 ecx, 4
  00273	c1 e1 00	 shl	 ecx, 0
  00276	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  00279	d1 fa		 sar	 edx, 1
  0027b	0f af 55 d8	 imul	 edx, DWORD PTR _y_range$[ebp+4]
  0027f	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
  00282	03 14 08	 add	 edx, DWORD PTR [eax+ecx]
  00285	89 55 a0	 mov	 DWORD PTR _dstLine$[ebp], edx

; 320  :     for (int y = 0; y < y_range.len; y += 2, srcULine += src_uv_pitch * 2, srcVLine += src_uv_pitch * 2, dstLine += dst_y_pitch) {

  00288	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR _y$17[ebp], 0
  0028f	eb 2e		 jmp	 SHORT $LN10@convert_yu
$LN8@convert_yu:
  00291	8b 4d 9c	 mov	 ecx, DWORD PTR _y$17[ebp]
  00294	83 c1 02	 add	 ecx, 2
  00297	89 4d 9c	 mov	 DWORD PTR _y$17[ebp], ecx
  0029a	8b 55 ac	 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  0029d	d1 e2		 shl	 edx, 1
  0029f	8b 45 a8	 mov	 eax, DWORD PTR _srcULine$[ebp]
  002a2	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  002a5	89 4d a8	 mov	 DWORD PTR _srcULine$[ebp], ecx
  002a8	8b 55 ac	 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  002ab	d1 e2		 shl	 edx, 1
  002ad	8b 45 a4	 mov	 eax, DWORD PTR _srcVLine$[ebp]
  002b0	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  002b3	89 4d a4	 mov	 DWORD PTR _srcVLine$[ebp], ecx
  002b6	8b 55 a0	 mov	 edx, DWORD PTR _dstLine$[ebp]
  002b9	03 55 e4	 add	 edx, DWORD PTR _dst_y_pitch$[ebp]
  002bc	89 55 a0	 mov	 DWORD PTR _dstLine$[ebp], edx
$LN10@convert_yu:
  002bf	8b 45 9c	 mov	 eax, DWORD PTR _y$17[ebp]
  002c2	3b 45 dc	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  002c5	0f 8d 36 01 00
	00		 jge	 $LN1@convert_yu

; 321  :         Tout *dstC = dstLine;

  002cb	8b 4d a0	 mov	 ecx, DWORD PTR _dstLine$[ebp]
  002ce	89 4d 98	 mov	 DWORD PTR _dstC$16[ebp], ecx

; 322  :         Tin *srcU = srcULine;

  002d1	8b 55 a8	 mov	 edx, DWORD PTR _srcULine$[ebp]
  002d4	89 55 94	 mov	 DWORD PTR _srcU$15[ebp], edx

; 323  :         Tin *srcV = srcVLine;

  002d7	8b 45 a4	 mov	 eax, DWORD PTR _srcVLine$[ebp]
  002da	89 45 90	 mov	 DWORD PTR _srcV$14[ebp], eax

; 324  :         const int x_fin = width - crop_right - crop_left;

  002dd	8b 4d 10	 mov	 ecx, DWORD PTR _width$[ebp]
  002e0	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  002e3	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  002e6	89 4d 8c	 mov	 DWORD PTR _x_fin$13[ebp], ecx

; 325  :         for (int x = 0; x < x_fin; x += 2, dstC += 2, srcU += 2, srcV += 2) {

  002e9	c7 45 88 00 00
	00 00		 mov	 DWORD PTR _x$12[ebp], 0
  002f0	eb 24		 jmp	 SHORT $LN13@convert_yu
$LN11@convert_yu:
  002f2	8b 55 88	 mov	 edx, DWORD PTR _x$12[ebp]
  002f5	83 c2 02	 add	 edx, 2
  002f8	89 55 88	 mov	 DWORD PTR _x$12[ebp], edx
  002fb	8b 45 98	 mov	 eax, DWORD PTR _dstC$16[ebp]
  002fe	83 c0 02	 add	 eax, 2
  00301	89 45 98	 mov	 DWORD PTR _dstC$16[ebp], eax
  00304	8b 4d 94	 mov	 ecx, DWORD PTR _srcU$15[ebp]
  00307	83 c1 04	 add	 ecx, 4
  0030a	89 4d 94	 mov	 DWORD PTR _srcU$15[ebp], ecx
  0030d	8b 55 90	 mov	 edx, DWORD PTR _srcV$14[ebp]
  00310	83 c2 04	 add	 edx, 4
  00313	89 55 90	 mov	 DWORD PTR _srcV$14[ebp], edx
$LN13@convert_yu:
  00316	8b 45 88	 mov	 eax, DWORD PTR _x$12[ebp]
  00319	3b 45 8c	 cmp	 eax, DWORD PTR _x_fin$13[ebp]
  0031c	0f 8d da 00 00
	00		 jge	 $LN12@convert_yu

; 326  :             int cy0u = srcU[0*src_uv_pitch + 0];

  00322	6b 4d ac 00	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 0
  00326	8b 55 94	 mov	 edx, DWORD PTR _srcU$15[ebp]
  00329	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  0032d	89 45 84	 mov	 DWORD PTR _cy0u$11[ebp], eax

; 327  :             int cy0v = srcV[0*src_uv_pitch + 0];

  00330	6b 4d ac 00	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 0
  00334	8b 55 90	 mov	 edx, DWORD PTR _srcV$14[ebp]
  00337	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  0033b	89 45 80	 mov	 DWORD PTR _cy0v$10[ebp], eax

; 328  :             int cy1u = srcU[1*src_uv_pitch + 0];

  0033e	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00341	8b 55 94	 mov	 edx, DWORD PTR _srcU$15[ebp]
  00344	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00348	89 85 7c ff ff
	ff		 mov	 DWORD PTR _cy1u$9[ebp], eax

; 329  :             int cy1v = srcV[1*src_uv_pitch + 0];

  0034e	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00351	8b 55 90	 mov	 edx, DWORD PTR _srcV$14[ebp]
  00354	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00358	89 85 78 ff ff
	ff		 mov	 DWORD PTR _cy1v$8[ebp], eax

; 330  : 
; 331  :             int cu = cy0u + cy1u + 1;

  0035e	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _cy1u$9[ebp]
  00364	8b 55 84	 mov	 edx, DWORD PTR _cy0u$11[ebp]
  00367	8d 44 0a 01	 lea	 eax, DWORD PTR [edx+ecx+1]
  0036b	89 85 74 ff ff
	ff		 mov	 DWORD PTR _cu$7[ebp], eax

; 332  :             int cv = cy0v + cy1v + 1;

  00371	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1v$8[ebp]
  00377	8b 55 80	 mov	 edx, DWORD PTR _cy0v$10[ebp]
  0037a	8d 44 0a 01	 lea	 eax, DWORD PTR [edx+ecx+1]
  0037e	89 85 70 ff ff
	ff		 mov	 DWORD PTR _cv$6[ebp], eax

; 333  :             CHANGE_BIT_DEPTH_2(cu, cv, 1);

  00384	33 c9		 xor	 ecx, ecx
  00386	74 20		 je	 SHORT $LN21@convert_yu
  00388	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _cu$7[ebp]
  0038e	c1 e2 fe	 shl	 edx, -2			; fffffffeH
  00391	89 95 74 ff ff
	ff		 mov	 DWORD PTR _cu$7[ebp], edx
  00397	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _cv$6[ebp]
  0039d	c1 e0 fe	 shl	 eax, -2			; fffffffeH
  003a0	89 85 70 ff ff
	ff		 mov	 DWORD PTR _cv$6[ebp], eax
  003a6	eb 27		 jmp	 SHORT $LN22@convert_yu
$LN21@convert_yu:
  003a8	b9 01 00 00 00	 mov	 ecx, 1
  003ad	85 c9		 test	 ecx, ecx
  003af	74 1e		 je	 SHORT $LN22@convert_yu
  003b1	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _cu$7[ebp]
  003b7	c1 fa 02	 sar	 edx, 2
  003ba	89 95 74 ff ff
	ff		 mov	 DWORD PTR _cu$7[ebp], edx
  003c0	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _cv$6[ebp]
  003c6	c1 f8 02	 sar	 eax, 2
  003c9	89 85 70 ff ff
	ff		 mov	 DWORD PTR _cv$6[ebp], eax
$LN22@convert_yu:

; 334  : 
; 335  :             dstC[0] = (Tout)cu;

  003cf	b9 01 00 00 00	 mov	 ecx, 1
  003d4	6b d1 00	 imul	 edx, ecx, 0
  003d7	8b 45 98	 mov	 eax, DWORD PTR _dstC$16[ebp]
  003da	8a 8d 74 ff ff
	ff		 mov	 cl, BYTE PTR _cu$7[ebp]
  003e0	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 336  :             dstC[1] = (Tout)cv;

  003e3	ba 01 00 00 00	 mov	 edx, 1
  003e8	c1 e2 00	 shl	 edx, 0
  003eb	8b 45 98	 mov	 eax, DWORD PTR _dstC$16[ebp]
  003ee	8a 8d 70 ff ff
	ff		 mov	 cl, BYTE PTR _cv$6[ebp]
  003f4	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 337  :         }

  003f7	e9 f6 fe ff ff	 jmp	 $LN11@convert_yu
$LN12@convert_yu:

; 338  :     }

  003fc	e9 90 fe ff ff	 jmp	 $LN8@convert_yu
$LN1@convert_yu:

; 339  : }

  00401	52		 push	 edx
  00402	8b cd		 mov	 ecx, ebp
  00404	50		 push	 eax
  00405	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN27@convert_yu
  0040b	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00410	58		 pop	 eax
  00411	5a		 pop	 edx
  00412	5f		 pop	 edi
  00413	5b		 pop	 ebx
  00414	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00417	33 cd		 xor	 ecx, ebp
  00419	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0041e	81 c4 ac 00 00
	00		 add	 esp, 172		; 000000acH
  00424	3b ec		 cmp	 ebp, esp
  00426	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0042b	8b e5		 mov	 esp, ebp
  0042d	5d		 pop	 ebp
  0042e	c3		 ret	 0
  0042f	90		 npad	 1
$LN27@convert_yu:
  00430	01 00 00 00	 DD	 1
  00434	00 00 00 00	 DD	 $LN26@convert_yu
$LN26@convert_yu:
  00438	d4 ff ff ff	 DD	 -44			; ffffffd4H
  0043c	0c 00 00 00	 DD	 12			; 0000000cH
  00440	00 00 00 00	 DD	 $LN25@convert_yu
$LN25@convert_yu:
  00444	79		 DB	 121			; 00000079H
  00445	5f		 DB	 95			; 0000005fH
  00446	72		 DB	 114			; 00000072H
  00447	61		 DB	 97			; 00000061H
  00448	6e		 DB	 110			; 0000006eH
  00449	67		 DB	 103			; 00000067H
  0044a	65		 DB	 101			; 00000065H
  0044b	00		 DB	 0
??$convert_yuv444_to_nv12_p_c@G$08E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_to_nv12_p_c<unsigned short,9,unsigned char,8,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuv444_09_to_nv12_p@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_09_to_nv12_p

; 456  : static void convert_yuv444_09_to_nv12_p(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 457  :     convert_yuv444_to_nv12_p_c<uint16_t, 9, uint8_t, 8, false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yuv444_to_nv12_p_c@G$08E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_to_nv12_p_c<unsigned short,9,unsigned char,8,0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 458  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yuv444_09_to_nv12_p@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_09_to_nv12_p
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
$T1 = -200						; size = 4
$T2 = -196						; size = 4
$T3 = -192						; size = 4
$T4 = -188						; size = 4
$T5 = -184						; size = 12
_cv_y1$6 = -172						; size = 4
_cv_y0$7 = -168						; size = 4
_cu_y1$8 = -164						; size = 4
_cu_y0$9 = -160						; size = 4
_cy3v$10 = -156						; size = 4
_cy3u$11 = -152						; size = 4
_cy2v$12 = -148						; size = 4
_cy2u$13 = -144						; size = 4
_cy1v$14 = -140						; size = 4
_cy1u$15 = -136						; size = 4
_cy0v$16 = -132						; size = 4
_cy0u$17 = -128						; size = 4
_x$18 = -124						; size = 4
_x_fin$19 = -120					; size = 4
_srcV$20 = -116						; size = 4
_srcU$21 = -112						; size = 4
_dstC$22 = -108						; size = 4
_y$23 = -104						; size = 4
_uv_fin$ = -100						; size = 4
_dstLine$ = -96						; size = 4
_srcVLine$ = -92					; size = 4
_srcULine$ = -88					; size = 4
_src_uv_pitch$ = -84					; size = 4
_x$24 = -80						; size = 4
_y$25 = -76						; size = 4
_y_width$26 = -72					; size = 4
_dstLine$27 = -68					; size = 4
_srcYLine$28 = -64					; size = 4
$T29 = -60						; size = 12
_y_range$ = -44						; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yuv444_to_nv12_i_c@G$09E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_to_nv12_i_c<unsigned short,10,unsigned char,8,0>

; 342  : static void __forceinline convert_yuv444_to_nv12_i_c(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  00009	53		 push	 ebx
  0000a	57		 push	 edi
  0000b	8d bd 38 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-200]
  00011	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 343  :     static_assert((sizeof(Tin)  == 1 && in_bit_depth  == 8) || (sizeof(Tin)  == 2 && 8 < in_bit_depth  && in_bit_depth  <= 16), "invalid input bit depth.");
; 344  :     static_assert((sizeof(Tout) == 1 && out_bit_depth == 8) || (sizeof(Tout) == 2 && 8 < out_bit_depth && out_bit_depth <= 16), "invalid output bit depth.");
; 345  :     const int crop_left   = crop[0];

  00027	b8 04 00 00 00	 mov	 eax, 4
  0002c	6b c8 00	 imul	 ecx, eax, 0
  0002f	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00032	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00035	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 346  :     const int crop_up     = crop[1];

  00038	b9 04 00 00 00	 mov	 ecx, 4
  0003d	c1 e1 00	 shl	 ecx, 0
  00040	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00043	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00046	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 347  :     const int crop_right  = crop[2];

  00049	b9 04 00 00 00	 mov	 ecx, 4
  0004e	d1 e1		 shl	 ecx, 1
  00050	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00053	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00056	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 348  :     const int crop_bottom = crop[3];

  00059	b9 04 00 00 00	 mov	 ecx, 4
  0005e	6b d1 03	 imul	 edx, ecx, 3
  00061	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00064	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00067	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 349  :     const int src_y_pitch = src_y_pitch_byte / sizeof(Tin);

  0006a	8b 55 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebp]
  0006d	d1 ea		 shr	 edx, 1
  0006f	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 350  :     const int dst_y_pitch = dst_y_pitch_byte / sizeof(Tout);

  00072	8b 45 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  00075	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 351  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00078	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0007b	51		 push	 ecx
  0007c	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0007f	52		 push	 edx
  00080	8b 45 20	 mov	 eax, DWORD PTR _height$[ebp]
  00083	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  00086	50		 push	 eax
  00087	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  0008a	51		 push	 ecx
  0008b	8d 95 48 ff ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  00091	52		 push	 edx
  00092	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00097	83 c4 14	 add	 esp, 20			; 00000014H
  0009a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009c	89 4d c4	 mov	 DWORD PTR $T29[ebp], ecx
  0009f	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a2	89 55 c8	 mov	 DWORD PTR $T29[ebp+4], edx
  000a5	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000a8	89 45 cc	 mov	 DWORD PTR $T29[ebp+8], eax
  000ab	8b 4d c4	 mov	 ecx, DWORD PTR $T29[ebp]
  000ae	89 4d d4	 mov	 DWORD PTR _y_range$[ebp], ecx
  000b1	8b 55 c8	 mov	 edx, DWORD PTR $T29[ebp+4]
  000b4	89 55 d8	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000b7	8b 45 cc	 mov	 eax, DWORD PTR $T29[ebp+8]
  000ba	89 45 dc	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 352  :     //Y
; 353  :     if (!uv_only) {

  000bd	b9 01 00 00 00	 mov	 ecx, 1
  000c2	85 c9		 test	 ecx, ecx
  000c4	0f 84 61 01 00
	00		 je	 $LN14@convert_yu

; 354  :         Tin *srcYLine = (Tin *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000ca	ba 04 00 00 00	 mov	 edx, 4
  000cf	6b c2 00	 imul	 eax, edx, 0
  000d2	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  000d5	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  000d9	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  000dc	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  000df	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  000e2	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  000e5	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  000e8	89 45 c0	 mov	 DWORD PTR _srcYLine$28[ebp], eax

; 355  :         Tout *dstLine = (Tout *)dst[0] + dst_y_pitch * y_range.start_dst;

  000eb	b9 04 00 00 00	 mov	 ecx, 4
  000f0	6b d1 00	 imul	 edx, ecx, 0
  000f3	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  000f6	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  000fa	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  000fd	03 04 11	 add	 eax, DWORD PTR [ecx+edx]
  00100	89 45 bc	 mov	 DWORD PTR _dstLine$27[ebp], eax

; 356  :         const int y_width = width - crop_right - crop_left;

  00103	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00106	2b 55 f0	 sub	 edx, DWORD PTR _crop_right$[ebp]
  00109	2b 55 f8	 sub	 edx, DWORD PTR _crop_left$[ebp]
  0010c	89 55 b8	 mov	 DWORD PTR _y_width$26[ebp], edx

; 357  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  0010f	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _y$25[ebp], 0
  00116	eb 1e		 jmp	 SHORT $LN4@convert_yu
$LN2@convert_yu:
  00118	8b 45 b4	 mov	 eax, DWORD PTR _y$25[ebp]
  0011b	83 c0 01	 add	 eax, 1
  0011e	89 45 b4	 mov	 DWORD PTR _y$25[ebp], eax
  00121	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  00124	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$28[ebp]
  00127	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  0012a	89 45 c0	 mov	 DWORD PTR _srcYLine$28[ebp], eax
  0012d	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$27[ebp]
  00130	03 4d e4	 add	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  00133	89 4d bc	 mov	 DWORD PTR _dstLine$27[ebp], ecx
$LN4@convert_yu:
  00136	8b 55 b4	 mov	 edx, DWORD PTR _y$25[ebp]
  00139	3b 55 dc	 cmp	 edx, DWORD PTR _y_range$[ebp+8]
  0013c	0f 8d e9 00 00
	00		 jge	 $LN14@convert_yu

; 358  :             if (in_bit_depth == out_bit_depth && sizeof(Tin) == sizeof(Tout)) {

  00142	33 c0		 xor	 eax, eax
  00144	74 1b		 je	 SHORT $LN15@convert_yu

; 359  :                 memcpy(dstLine, srcYLine, y_width * sizeof(Tin));

  00146	8b 4d b8	 mov	 ecx, DWORD PTR _y_width$26[ebp]
  00149	d1 e1		 shl	 ecx, 1
  0014b	51		 push	 ecx
  0014c	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$28[ebp]
  0014f	52		 push	 edx
  00150	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$27[ebp]
  00153	50		 push	 eax
  00154	e8 00 00 00 00	 call	 _memcpy
  00159	83 c4 0c	 add	 esp, 12			; 0000000cH

; 360  :             } else {

  0015c	e9 c5 00 00 00	 jmp	 $LN16@convert_yu
$LN15@convert_yu:

; 361  :                 for (int x = 0; x < y_width; x++) {

  00161	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _x$24[ebp], 0
  00168	eb 09		 jmp	 SHORT $LN7@convert_yu
$LN5@convert_yu:
  0016a	8b 4d b0	 mov	 ecx, DWORD PTR _x$24[ebp]
  0016d	83 c1 01	 add	 ecx, 1
  00170	89 4d b0	 mov	 DWORD PTR _x$24[ebp], ecx
$LN7@convert_yu:
  00173	8b 55 b0	 mov	 edx, DWORD PTR _x$24[ebp]
  00176	3b 55 b8	 cmp	 edx, DWORD PTR _y_width$26[ebp]
  00179	0f 8d a7 00 00
	00		 jge	 $LN16@convert_yu

; 362  :                     if (out_bit_depth > in_bit_depth) {

  0017f	33 c0		 xor	 eax, eax
  00181	74 42		 je	 SHORT $LN17@convert_yu

; 363  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) << std::max(out_bit_depth - in_bit_depth, 0));

  00183	c7 85 44 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], 0
  0018d	c7 85 40 ff ff
	ff fe ff ff ff	 mov	 DWORD PTR $T3[ebp], -2	; fffffffeH
  00197	8b 4d b0	 mov	 ecx, DWORD PTR _x$24[ebp]
  0019a	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$28[ebp]
  0019d	0f b7 1c 4a	 movzx	 ebx, WORD PTR [edx+ecx*2]
  001a1	8d 85 44 ff ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  001a7	50		 push	 eax
  001a8	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  001ae	51		 push	 ecx
  001af	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  001b4	83 c4 08	 add	 esp, 8
  001b7	8b 08		 mov	 ecx, DWORD PTR [eax]
  001b9	d3 e3		 shl	 ebx, cl
  001bb	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$27[ebp]
  001be	03 55 b0	 add	 edx, DWORD PTR _x$24[ebp]
  001c1	88 1a		 mov	 BYTE PTR [edx], bl
  001c3	eb 5c		 jmp	 SHORT $LN18@convert_yu
$LN17@convert_yu:

; 364  :                     } else if (out_bit_depth < in_bit_depth) {

  001c5	b8 01 00 00 00	 mov	 eax, 1
  001ca	85 c0		 test	 eax, eax
  001cc	74 42		 je	 SHORT $LN19@convert_yu

; 365  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) >> std::max(in_bit_depth - out_bit_depth, 0));

  001ce	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], 0
  001d8	c7 85 38 ff ff
	ff 02 00 00 00	 mov	 DWORD PTR $T1[ebp], 2
  001e2	8b 4d b0	 mov	 ecx, DWORD PTR _x$24[ebp]
  001e5	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$28[ebp]
  001e8	0f b7 1c 4a	 movzx	 ebx, WORD PTR [edx+ecx*2]
  001ec	8d 85 3c ff ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  001f2	50		 push	 eax
  001f3	8d 8d 38 ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  001f9	51		 push	 ecx
  001fa	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  001ff	83 c4 08	 add	 esp, 8
  00202	8b 08		 mov	 ecx, DWORD PTR [eax]
  00204	d3 fb		 sar	 ebx, cl
  00206	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$27[ebp]
  00209	03 55 b0	 add	 edx, DWORD PTR _x$24[ebp]
  0020c	88 1a		 mov	 BYTE PTR [edx], bl

; 366  :                     } else {

  0020e	eb 11		 jmp	 SHORT $LN18@convert_yu
$LN19@convert_yu:

; 367  :                         dstLine[x] = (Tout)srcYLine[x];

  00210	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$27[ebp]
  00213	03 45 b0	 add	 eax, DWORD PTR _x$24[ebp]
  00216	8b 4d b0	 mov	 ecx, DWORD PTR _x$24[ebp]
  00219	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$28[ebp]
  0021c	8a 0c 4a	 mov	 cl, BYTE PTR [edx+ecx*2]
  0021f	88 08		 mov	 BYTE PTR [eax], cl
$LN18@convert_yu:

; 368  :                     }
; 369  :                 }

  00221	e9 44 ff ff ff	 jmp	 $LN5@convert_yu
$LN16@convert_yu:

; 370  :             }
; 371  :         }

  00226	e9 ed fe ff ff	 jmp	 $LN2@convert_yu
$LN14@convert_yu:

; 372  :     }
; 373  :     //UV
; 374  :     const int src_uv_pitch = src_uv_pitch_byte / sizeof(Tin);

  0022b	8b 55 18	 mov	 edx, DWORD PTR _src_uv_pitch_byte$[ebp]
  0022e	d1 ea		 shr	 edx, 1
  00230	89 55 ac	 mov	 DWORD PTR _src_uv_pitch$[ebp], edx

; 375  :     Tin *srcULine = (Tin *)src[1] + ((src_uv_pitch * y_range.start_src) + crop_left);

  00233	b8 04 00 00 00	 mov	 eax, 4
  00238	c1 e0 00	 shl	 eax, 0
  0023b	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  0023e	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  00242	03 4d f8	 add	 ecx, DWORD PTR _crop_left$[ebp]
  00245	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  00248	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  0024b	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  0024e	89 4d a8	 mov	 DWORD PTR _srcULine$[ebp], ecx

; 376  :     Tin *srcVLine = (Tin *)src[2] + ((src_uv_pitch * y_range.start_src) + crop_left);

  00251	ba 04 00 00 00	 mov	 edx, 4
  00256	d1 e2		 shl	 edx, 1
  00258	8b 45 ac	 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  0025b	0f af 45 d4	 imul	 eax, DWORD PTR _y_range$[ebp]
  0025f	03 45 f8	 add	 eax, DWORD PTR _crop_left$[ebp]
  00262	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  00265	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  00268	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  0026b	89 45 a4	 mov	 DWORD PTR _srcVLine$[ebp], eax

; 377  :     Tout *dstLine = (Tout *)dst[1] + (dst_y_pitch >> 1) * y_range.start_dst;

  0026e	b9 04 00 00 00	 mov	 ecx, 4
  00273	c1 e1 00	 shl	 ecx, 0
  00276	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  00279	d1 fa		 sar	 edx, 1
  0027b	0f af 55 d8	 imul	 edx, DWORD PTR _y_range$[ebp+4]
  0027f	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
  00282	03 14 08	 add	 edx, DWORD PTR [eax+ecx]
  00285	89 55 a0	 mov	 DWORD PTR _dstLine$[ebp], edx

; 378  :     const int uv_fin = height - crop_bottom - crop_up;

  00288	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  0028b	2b 4d ec	 sub	 ecx, DWORD PTR _crop_bottom$[ebp]
  0028e	2b 4d f4	 sub	 ecx, DWORD PTR _crop_up$[ebp]
  00291	89 4d 9c	 mov	 DWORD PTR _uv_fin$[ebp], ecx

; 379  :     for (int y = 0; y < y_range.len; y += 4, srcULine += src_uv_pitch * 4, srcVLine += src_uv_pitch * 4, dstLine += dst_y_pitch * 2) {

  00294	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _y$23[ebp], 0
  0029b	eb 33		 jmp	 SHORT $LN10@convert_yu
$LN8@convert_yu:
  0029d	8b 55 98	 mov	 edx, DWORD PTR _y$23[ebp]
  002a0	83 c2 04	 add	 edx, 4
  002a3	89 55 98	 mov	 DWORD PTR _y$23[ebp], edx
  002a6	8b 45 ac	 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  002a9	c1 e0 02	 shl	 eax, 2
  002ac	8b 4d a8	 mov	 ecx, DWORD PTR _srcULine$[ebp]
  002af	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  002b2	89 55 a8	 mov	 DWORD PTR _srcULine$[ebp], edx
  002b5	8b 45 ac	 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  002b8	c1 e0 02	 shl	 eax, 2
  002bb	8b 4d a4	 mov	 ecx, DWORD PTR _srcVLine$[ebp]
  002be	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  002c1	89 55 a4	 mov	 DWORD PTR _srcVLine$[ebp], edx
  002c4	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  002c7	8b 4d a0	 mov	 ecx, DWORD PTR _dstLine$[ebp]
  002ca	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  002cd	89 55 a0	 mov	 DWORD PTR _dstLine$[ebp], edx
$LN10@convert_yu:
  002d0	8b 45 98	 mov	 eax, DWORD PTR _y$23[ebp]
  002d3	3b 45 dc	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  002d6	0f 8d 04 02 00
	00		 jge	 $LN1@convert_yu

; 380  :         Tout *dstC = dstLine;

  002dc	8b 4d a0	 mov	 ecx, DWORD PTR _dstLine$[ebp]
  002df	89 4d 94	 mov	 DWORD PTR _dstC$22[ebp], ecx

; 381  :         Tin *srcU = srcULine;

  002e2	8b 55 a8	 mov	 edx, DWORD PTR _srcULine$[ebp]
  002e5	89 55 90	 mov	 DWORD PTR _srcU$21[ebp], edx

; 382  :         Tin *srcV = srcVLine;

  002e8	8b 45 a4	 mov	 eax, DWORD PTR _srcVLine$[ebp]
  002eb	89 45 8c	 mov	 DWORD PTR _srcV$20[ebp], eax

; 383  :         const int x_fin = width - crop_right - crop_left;

  002ee	8b 4d 10	 mov	 ecx, DWORD PTR _width$[ebp]
  002f1	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  002f4	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  002f7	89 4d 88	 mov	 DWORD PTR _x_fin$19[ebp], ecx

; 384  :         for (int x = 0; x < x_fin; x += 2, dstC += 2, srcU += 2, srcV += 2) {

  002fa	c7 45 84 00 00
	00 00		 mov	 DWORD PTR _x$18[ebp], 0
  00301	eb 24		 jmp	 SHORT $LN13@convert_yu
$LN11@convert_yu:
  00303	8b 55 84	 mov	 edx, DWORD PTR _x$18[ebp]
  00306	83 c2 02	 add	 edx, 2
  00309	89 55 84	 mov	 DWORD PTR _x$18[ebp], edx
  0030c	8b 45 94	 mov	 eax, DWORD PTR _dstC$22[ebp]
  0030f	83 c0 02	 add	 eax, 2
  00312	89 45 94	 mov	 DWORD PTR _dstC$22[ebp], eax
  00315	8b 4d 90	 mov	 ecx, DWORD PTR _srcU$21[ebp]
  00318	83 c1 04	 add	 ecx, 4
  0031b	89 4d 90	 mov	 DWORD PTR _srcU$21[ebp], ecx
  0031e	8b 55 8c	 mov	 edx, DWORD PTR _srcV$20[ebp]
  00321	83 c2 04	 add	 edx, 4
  00324	89 55 8c	 mov	 DWORD PTR _srcV$20[ebp], edx
$LN13@convert_yu:
  00327	8b 45 84	 mov	 eax, DWORD PTR _x$18[ebp]
  0032a	3b 45 88	 cmp	 eax, DWORD PTR _x_fin$19[ebp]
  0032d	0f 8d a8 01 00
	00		 jge	 $LN12@convert_yu

; 385  :             int cy0u = srcU[0*src_uv_pitch + 0];

  00333	6b 4d ac 00	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 0
  00337	8b 55 90	 mov	 edx, DWORD PTR _srcU$21[ebp]
  0033a	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  0033e	89 45 80	 mov	 DWORD PTR _cy0u$17[ebp], eax

; 386  :             int cy0v = srcV[0*src_uv_pitch + 0];

  00341	6b 4d ac 00	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 0
  00345	8b 55 8c	 mov	 edx, DWORD PTR _srcV$20[ebp]
  00348	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  0034c	89 85 7c ff ff
	ff		 mov	 DWORD PTR _cy0v$16[ebp], eax

; 387  :             int cy1u = srcU[1*src_uv_pitch + 0];

  00352	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00355	8b 55 90	 mov	 edx, DWORD PTR _srcU$21[ebp]
  00358	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  0035c	89 85 78 ff ff
	ff		 mov	 DWORD PTR _cy1u$15[ebp], eax

; 388  :             int cy1v = srcV[1*src_uv_pitch + 0];

  00362	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00365	8b 55 8c	 mov	 edx, DWORD PTR _srcV$20[ebp]
  00368	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  0036c	89 85 74 ff ff
	ff		 mov	 DWORD PTR _cy1v$14[ebp], eax

; 389  :             int cy2u = srcU[2*src_uv_pitch + 0];

  00372	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00375	d1 e1		 shl	 ecx, 1
  00377	8b 55 90	 mov	 edx, DWORD PTR _srcU$21[ebp]
  0037a	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  0037e	89 85 70 ff ff
	ff		 mov	 DWORD PTR _cy2u$13[ebp], eax

; 390  :             int cy2v = srcV[2*src_uv_pitch + 0];

  00384	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00387	d1 e1		 shl	 ecx, 1
  00389	8b 55 8c	 mov	 edx, DWORD PTR _srcV$20[ebp]
  0038c	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00390	89 85 6c ff ff
	ff		 mov	 DWORD PTR _cy2v$12[ebp], eax

; 391  :             int cy3u = srcU[3*src_uv_pitch + 0];

  00396	6b 4d ac 03	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 3
  0039a	8b 55 90	 mov	 edx, DWORD PTR _srcU$21[ebp]
  0039d	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  003a1	89 85 68 ff ff
	ff		 mov	 DWORD PTR _cy3u$11[ebp], eax

; 392  :             int cy3v = srcV[3*src_uv_pitch + 0];

  003a7	6b 4d ac 03	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 3
  003ab	8b 55 8c	 mov	 edx, DWORD PTR _srcV$20[ebp]
  003ae	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  003b2	89 85 64 ff ff
	ff		 mov	 DWORD PTR _cy3v$10[ebp], eax

; 393  : 
; 394  :             int cu_y0 = cy0u * 3 + cy2u * 1 + 2;

  003b8	6b 4d 80 03	 imul	 ecx, DWORD PTR _cy0u$17[ebp], 3
  003bc	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR _cy2u$13[ebp]
  003c2	8d 44 11 02	 lea	 eax, DWORD PTR [ecx+edx+2]
  003c6	89 85 60 ff ff
	ff		 mov	 DWORD PTR _cu_y0$9[ebp], eax

; 395  :             int cu_y1 = cy1u * 1 + cy3u * 3 + 2;

  003cc	6b 8d 68 ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy3u$11[ebp], 3
  003d3	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _cy1u$15[ebp]
  003d9	8d 44 0a 02	 lea	 eax, DWORD PTR [edx+ecx+2]
  003dd	89 85 5c ff ff
	ff		 mov	 DWORD PTR _cu_y1$8[ebp], eax

; 396  :             int cv_y0 = cy0v * 3 + cy2v * 1 + 2;

  003e3	6b 8d 7c ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy0v$16[ebp], 3
  003ea	8b 95 6c ff ff
	ff		 mov	 edx, DWORD PTR _cy2v$12[ebp]
  003f0	8d 44 11 02	 lea	 eax, DWORD PTR [ecx+edx+2]
  003f4	89 85 58 ff ff
	ff		 mov	 DWORD PTR _cv_y0$7[ebp], eax

; 397  :             int cv_y1 = cy1v * 1 + cy3v * 3 + 2;

  003fa	6b 8d 64 ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy3v$10[ebp], 3
  00401	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _cy1v$14[ebp]
  00407	8d 44 0a 02	 lea	 eax, DWORD PTR [edx+ecx+2]
  0040b	89 85 54 ff ff
	ff		 mov	 DWORD PTR _cv_y1$6[ebp], eax

; 398  :             CHANGE_BIT_DEPTH_4(cu_y0, cu_y1, cv_y0, cv_y1, 2);

  00411	33 c9		 xor	 ecx, ecx
  00413	74 3e		 je	 SHORT $LN21@convert_yu
  00415	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _cu_y0$9[ebp]
  0041b	c1 e2 fc	 shl	 edx, -4			; fffffffcH
  0041e	89 95 60 ff ff
	ff		 mov	 DWORD PTR _cu_y0$9[ebp], edx
  00424	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _cu_y1$8[ebp]
  0042a	c1 e0 fc	 shl	 eax, -4			; fffffffcH
  0042d	89 85 5c ff ff
	ff		 mov	 DWORD PTR _cu_y1$8[ebp], eax
  00433	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _cv_y0$7[ebp]
  00439	c1 e1 fc	 shl	 ecx, -4			; fffffffcH
  0043c	89 8d 58 ff ff
	ff		 mov	 DWORD PTR _cv_y0$7[ebp], ecx
  00442	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR _cv_y1$6[ebp]
  00448	c1 e2 fc	 shl	 edx, -4			; fffffffcH
  0044b	89 95 54 ff ff
	ff		 mov	 DWORD PTR _cv_y1$6[ebp], edx
  00451	eb 45		 jmp	 SHORT $LN22@convert_yu
$LN21@convert_yu:
  00453	b8 01 00 00 00	 mov	 eax, 1
  00458	85 c0		 test	 eax, eax
  0045a	74 3c		 je	 SHORT $LN22@convert_yu
  0045c	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _cu_y0$9[ebp]
  00462	c1 f9 04	 sar	 ecx, 4
  00465	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _cu_y0$9[ebp], ecx
  0046b	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR _cu_y1$8[ebp]
  00471	c1 fa 04	 sar	 edx, 4
  00474	89 95 5c ff ff
	ff		 mov	 DWORD PTR _cu_y1$8[ebp], edx
  0047a	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _cv_y0$7[ebp]
  00480	c1 f8 04	 sar	 eax, 4
  00483	89 85 58 ff ff
	ff		 mov	 DWORD PTR _cv_y0$7[ebp], eax
  00489	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _cv_y1$6[ebp]
  0048f	c1 f9 04	 sar	 ecx, 4
  00492	89 8d 54 ff ff
	ff		 mov	 DWORD PTR _cv_y1$6[ebp], ecx
$LN22@convert_yu:

; 399  : 
; 400  :             dstC[0*dst_y_pitch + 0] = (Tout)cu_y0;

  00498	6b 55 e4 00	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 0
  0049c	8b 45 94	 mov	 eax, DWORD PTR _dstC$22[ebp]
  0049f	8a 8d 60 ff ff
	ff		 mov	 cl, BYTE PTR _cu_y0$9[ebp]
  004a5	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 401  :             dstC[0*dst_y_pitch + 1] = (Tout)cv_y0;

  004a8	6b 55 e4 00	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 0
  004ac	8b 45 94	 mov	 eax, DWORD PTR _dstC$22[ebp]
  004af	8a 8d 58 ff ff
	ff		 mov	 cl, BYTE PTR _cv_y0$7[ebp]
  004b5	88 4c 10 01	 mov	 BYTE PTR [eax+edx+1], cl

; 402  :             dstC[1*dst_y_pitch + 0] = (Tout)cu_y1;

  004b9	8b 55 94	 mov	 edx, DWORD PTR _dstC$22[ebp]
  004bc	03 55 e4	 add	 edx, DWORD PTR _dst_y_pitch$[ebp]
  004bf	8a 85 5c ff ff
	ff		 mov	 al, BYTE PTR _cu_y1$8[ebp]
  004c5	88 02		 mov	 BYTE PTR [edx], al

; 403  :             dstC[1*dst_y_pitch + 1] = (Tout)cv_y1;

  004c7	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$22[ebp]
  004ca	03 4d e4	 add	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  004cd	8a 95 54 ff ff
	ff		 mov	 dl, BYTE PTR _cv_y1$6[ebp]
  004d3	88 51 01	 mov	 BYTE PTR [ecx+1], dl

; 404  :         }

  004d6	e9 28 fe ff ff	 jmp	 $LN11@convert_yu
$LN12@convert_yu:

; 405  :     }

  004db	e9 bd fd ff ff	 jmp	 $LN8@convert_yu
$LN1@convert_yu:

; 406  : }

  004e0	52		 push	 edx
  004e1	8b cd		 mov	 ecx, ebp
  004e3	50		 push	 eax
  004e4	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN27@convert_yu
  004ea	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  004ef	58		 pop	 eax
  004f0	5a		 pop	 edx
  004f1	5f		 pop	 edi
  004f2	5b		 pop	 ebx
  004f3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004f6	33 cd		 xor	 ecx, ebp
  004f8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004fd	81 c4 c8 00 00
	00		 add	 esp, 200		; 000000c8H
  00503	3b ec		 cmp	 ebp, esp
  00505	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0050a	8b e5		 mov	 esp, ebp
  0050c	5d		 pop	 ebp
  0050d	c3		 ret	 0
  0050e	66 90		 npad	 2
$LN27@convert_yu:
  00510	01 00 00 00	 DD	 1
  00514	00 00 00 00	 DD	 $LN26@convert_yu
$LN26@convert_yu:
  00518	d4 ff ff ff	 DD	 -44			; ffffffd4H
  0051c	0c 00 00 00	 DD	 12			; 0000000cH
  00520	00 00 00 00	 DD	 $LN25@convert_yu
$LN25@convert_yu:
  00524	79		 DB	 121			; 00000079H
  00525	5f		 DB	 95			; 0000005fH
  00526	72		 DB	 114			; 00000072H
  00527	61		 DB	 97			; 00000061H
  00528	6e		 DB	 110			; 0000006eH
  00529	67		 DB	 103			; 00000067H
  0052a	65		 DB	 101			; 00000065H
  0052b	00		 DB	 0
??$convert_yuv444_to_nv12_i_c@G$09E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_to_nv12_i_c<unsigned short,10,unsigned char,8,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuv444_10_to_nv12_i@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_10_to_nv12_i

; 452  : static void convert_yuv444_10_to_nv12_i(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 453  :     convert_yuv444_to_nv12_i_c<uint16_t, 10, uint8_t, 8, false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yuv444_to_nv12_i_c@G$09E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_to_nv12_i_c<unsigned short,10,unsigned char,8,0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 454  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yuv444_10_to_nv12_i@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_10_to_nv12_i
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
$T1 = -172						; size = 4
$T2 = -168						; size = 4
$T3 = -164						; size = 4
$T4 = -160						; size = 4
$T5 = -156						; size = 12
_cv$6 = -144						; size = 4
_cu$7 = -140						; size = 4
_cy1v$8 = -136						; size = 4
_cy1u$9 = -132						; size = 4
_cy0v$10 = -128						; size = 4
_cy0u$11 = -124						; size = 4
_x$12 = -120						; size = 4
_x_fin$13 = -116					; size = 4
_srcV$14 = -112						; size = 4
_srcU$15 = -108						; size = 4
_dstC$16 = -104						; size = 4
_y$17 = -100						; size = 4
_dstLine$ = -96						; size = 4
_srcVLine$ = -92					; size = 4
_srcULine$ = -88					; size = 4
_src_uv_pitch$ = -84					; size = 4
_x$18 = -80						; size = 4
_y$19 = -76						; size = 4
_y_width$20 = -72					; size = 4
_dstLine$21 = -68					; size = 4
_srcYLine$22 = -64					; size = 4
$T23 = -60						; size = 12
_y_range$ = -44						; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yuv444_to_nv12_p_c@G$09E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_to_nv12_p_c<unsigned short,10,unsigned char,8,0>

; 284  : static void __forceinline convert_yuv444_to_nv12_p_c(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec ac 00 00
	00		 sub	 esp, 172		; 000000acH
  00009	53		 push	 ebx
  0000a	57		 push	 edi
  0000b	8d bd 54 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-172]
  00011	b9 2b 00 00 00	 mov	 ecx, 43			; 0000002bH
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 285  :     static_assert((sizeof(Tin)  == 1 && in_bit_depth  == 8) || (sizeof(Tin)  == 2 && 8 < in_bit_depth  && in_bit_depth  <= 16), "invalid input bit depth.");
; 286  :     static_assert((sizeof(Tout) == 1 && out_bit_depth == 8) || (sizeof(Tout) == 2 && 8 < out_bit_depth && out_bit_depth <= 16), "invalid output bit depth.");
; 287  :     const int crop_left   = crop[0];

  00027	b8 04 00 00 00	 mov	 eax, 4
  0002c	6b c8 00	 imul	 ecx, eax, 0
  0002f	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00032	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00035	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 288  :     const int crop_up     = crop[1];

  00038	b9 04 00 00 00	 mov	 ecx, 4
  0003d	c1 e1 00	 shl	 ecx, 0
  00040	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00043	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00046	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 289  :     const int crop_right  = crop[2];

  00049	b9 04 00 00 00	 mov	 ecx, 4
  0004e	d1 e1		 shl	 ecx, 1
  00050	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00053	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00056	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 290  :     const int crop_bottom = crop[3];

  00059	b9 04 00 00 00	 mov	 ecx, 4
  0005e	6b d1 03	 imul	 edx, ecx, 3
  00061	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00064	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00067	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 291  :     const int src_y_pitch = src_y_pitch_byte / sizeof(Tin);

  0006a	8b 55 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebp]
  0006d	d1 ea		 shr	 edx, 1
  0006f	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 292  :     const int dst_y_pitch = dst_y_pitch_byte / sizeof(Tout);

  00072	8b 45 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  00075	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 293  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00078	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0007b	51		 push	 ecx
  0007c	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0007f	52		 push	 edx
  00080	8b 45 20	 mov	 eax, DWORD PTR _height$[ebp]
  00083	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  00086	50		 push	 eax
  00087	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  0008a	51		 push	 ecx
  0008b	8d 95 64 ff ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  00091	52		 push	 edx
  00092	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00097	83 c4 14	 add	 esp, 20			; 00000014H
  0009a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009c	89 4d c4	 mov	 DWORD PTR $T23[ebp], ecx
  0009f	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a2	89 55 c8	 mov	 DWORD PTR $T23[ebp+4], edx
  000a5	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000a8	89 45 cc	 mov	 DWORD PTR $T23[ebp+8], eax
  000ab	8b 4d c4	 mov	 ecx, DWORD PTR $T23[ebp]
  000ae	89 4d d4	 mov	 DWORD PTR _y_range$[ebp], ecx
  000b1	8b 55 c8	 mov	 edx, DWORD PTR $T23[ebp+4]
  000b4	89 55 d8	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000b7	8b 45 cc	 mov	 eax, DWORD PTR $T23[ebp+8]
  000ba	89 45 dc	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 294  :     //Y
; 295  :     if (!uv_only) {

  000bd	b9 01 00 00 00	 mov	 ecx, 1
  000c2	85 c9		 test	 ecx, ecx
  000c4	0f 84 61 01 00
	00		 je	 $LN14@convert_yu

; 296  :         Tin *srcYLine = (Tin *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000ca	ba 04 00 00 00	 mov	 edx, 4
  000cf	6b c2 00	 imul	 eax, edx, 0
  000d2	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  000d5	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  000d9	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  000dc	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  000df	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  000e2	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  000e5	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  000e8	89 45 c0	 mov	 DWORD PTR _srcYLine$22[ebp], eax

; 297  :         Tout *dstLine = (Tout *)dst[0] + dst_y_pitch * y_range.start_dst;

  000eb	b9 04 00 00 00	 mov	 ecx, 4
  000f0	6b d1 00	 imul	 edx, ecx, 0
  000f3	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  000f6	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  000fa	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  000fd	03 04 11	 add	 eax, DWORD PTR [ecx+edx]
  00100	89 45 bc	 mov	 DWORD PTR _dstLine$21[ebp], eax

; 298  :         const int y_width = width - crop_right - crop_left;

  00103	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00106	2b 55 f0	 sub	 edx, DWORD PTR _crop_right$[ebp]
  00109	2b 55 f8	 sub	 edx, DWORD PTR _crop_left$[ebp]
  0010c	89 55 b8	 mov	 DWORD PTR _y_width$20[ebp], edx

; 299  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  0010f	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _y$19[ebp], 0
  00116	eb 1e		 jmp	 SHORT $LN4@convert_yu
$LN2@convert_yu:
  00118	8b 45 b4	 mov	 eax, DWORD PTR _y$19[ebp]
  0011b	83 c0 01	 add	 eax, 1
  0011e	89 45 b4	 mov	 DWORD PTR _y$19[ebp], eax
  00121	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  00124	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$22[ebp]
  00127	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  0012a	89 45 c0	 mov	 DWORD PTR _srcYLine$22[ebp], eax
  0012d	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$21[ebp]
  00130	03 4d e4	 add	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  00133	89 4d bc	 mov	 DWORD PTR _dstLine$21[ebp], ecx
$LN4@convert_yu:
  00136	8b 55 b4	 mov	 edx, DWORD PTR _y$19[ebp]
  00139	3b 55 dc	 cmp	 edx, DWORD PTR _y_range$[ebp+8]
  0013c	0f 8d e9 00 00
	00		 jge	 $LN14@convert_yu

; 300  :             if (in_bit_depth == out_bit_depth && sizeof(Tin) == sizeof(Tout)) {

  00142	33 c0		 xor	 eax, eax
  00144	74 1b		 je	 SHORT $LN15@convert_yu

; 301  :                 memcpy(dstLine, srcYLine, y_width * sizeof(Tin));

  00146	8b 4d b8	 mov	 ecx, DWORD PTR _y_width$20[ebp]
  00149	d1 e1		 shl	 ecx, 1
  0014b	51		 push	 ecx
  0014c	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$22[ebp]
  0014f	52		 push	 edx
  00150	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$21[ebp]
  00153	50		 push	 eax
  00154	e8 00 00 00 00	 call	 _memcpy
  00159	83 c4 0c	 add	 esp, 12			; 0000000cH

; 302  :             } else {

  0015c	e9 c5 00 00 00	 jmp	 $LN16@convert_yu
$LN15@convert_yu:

; 303  :                 for (int x = 0; x < y_width; x++) {

  00161	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _x$18[ebp], 0
  00168	eb 09		 jmp	 SHORT $LN7@convert_yu
$LN5@convert_yu:
  0016a	8b 4d b0	 mov	 ecx, DWORD PTR _x$18[ebp]
  0016d	83 c1 01	 add	 ecx, 1
  00170	89 4d b0	 mov	 DWORD PTR _x$18[ebp], ecx
$LN7@convert_yu:
  00173	8b 55 b0	 mov	 edx, DWORD PTR _x$18[ebp]
  00176	3b 55 b8	 cmp	 edx, DWORD PTR _y_width$20[ebp]
  00179	0f 8d a7 00 00
	00		 jge	 $LN16@convert_yu

; 304  :                     if (out_bit_depth > in_bit_depth) {

  0017f	33 c0		 xor	 eax, eax
  00181	74 42		 je	 SHORT $LN17@convert_yu

; 305  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) << std::max(out_bit_depth - in_bit_depth, 0));

  00183	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], 0
  0018d	c7 85 5c ff ff
	ff fe ff ff ff	 mov	 DWORD PTR $T3[ebp], -2	; fffffffeH
  00197	8b 4d b0	 mov	 ecx, DWORD PTR _x$18[ebp]
  0019a	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$22[ebp]
  0019d	0f b7 1c 4a	 movzx	 ebx, WORD PTR [edx+ecx*2]
  001a1	8d 85 60 ff ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  001a7	50		 push	 eax
  001a8	8d 8d 5c ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  001ae	51		 push	 ecx
  001af	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  001b4	83 c4 08	 add	 esp, 8
  001b7	8b 08		 mov	 ecx, DWORD PTR [eax]
  001b9	d3 e3		 shl	 ebx, cl
  001bb	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$21[ebp]
  001be	03 55 b0	 add	 edx, DWORD PTR _x$18[ebp]
  001c1	88 1a		 mov	 BYTE PTR [edx], bl
  001c3	eb 5c		 jmp	 SHORT $LN18@convert_yu
$LN17@convert_yu:

; 306  :                     } else if (out_bit_depth < in_bit_depth) {

  001c5	b8 01 00 00 00	 mov	 eax, 1
  001ca	85 c0		 test	 eax, eax
  001cc	74 42		 je	 SHORT $LN19@convert_yu

; 307  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) >> std::max(in_bit_depth - out_bit_depth, 0));

  001ce	c7 85 58 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], 0
  001d8	c7 85 54 ff ff
	ff 02 00 00 00	 mov	 DWORD PTR $T1[ebp], 2
  001e2	8b 4d b0	 mov	 ecx, DWORD PTR _x$18[ebp]
  001e5	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$22[ebp]
  001e8	0f b7 1c 4a	 movzx	 ebx, WORD PTR [edx+ecx*2]
  001ec	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  001f2	50		 push	 eax
  001f3	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  001f9	51		 push	 ecx
  001fa	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  001ff	83 c4 08	 add	 esp, 8
  00202	8b 08		 mov	 ecx, DWORD PTR [eax]
  00204	d3 fb		 sar	 ebx, cl
  00206	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$21[ebp]
  00209	03 55 b0	 add	 edx, DWORD PTR _x$18[ebp]
  0020c	88 1a		 mov	 BYTE PTR [edx], bl

; 308  :                     } else {

  0020e	eb 11		 jmp	 SHORT $LN18@convert_yu
$LN19@convert_yu:

; 309  :                         dstLine[x] = (Tout)srcYLine[x];

  00210	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$21[ebp]
  00213	03 45 b0	 add	 eax, DWORD PTR _x$18[ebp]
  00216	8b 4d b0	 mov	 ecx, DWORD PTR _x$18[ebp]
  00219	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$22[ebp]
  0021c	8a 0c 4a	 mov	 cl, BYTE PTR [edx+ecx*2]
  0021f	88 08		 mov	 BYTE PTR [eax], cl
$LN18@convert_yu:

; 310  :                     }
; 311  :                 }

  00221	e9 44 ff ff ff	 jmp	 $LN5@convert_yu
$LN16@convert_yu:

; 312  :             }
; 313  :         }

  00226	e9 ed fe ff ff	 jmp	 $LN2@convert_yu
$LN14@convert_yu:

; 314  :     }
; 315  :     //UV
; 316  :     const int src_uv_pitch = src_uv_pitch_byte / sizeof(Tin);

  0022b	8b 55 18	 mov	 edx, DWORD PTR _src_uv_pitch_byte$[ebp]
  0022e	d1 ea		 shr	 edx, 1
  00230	89 55 ac	 mov	 DWORD PTR _src_uv_pitch$[ebp], edx

; 317  :     Tin *srcULine = (Tin *)src[1] + ((src_uv_pitch * y_range.start_src) + crop_left);

  00233	b8 04 00 00 00	 mov	 eax, 4
  00238	c1 e0 00	 shl	 eax, 0
  0023b	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  0023e	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  00242	03 4d f8	 add	 ecx, DWORD PTR _crop_left$[ebp]
  00245	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  00248	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  0024b	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  0024e	89 4d a8	 mov	 DWORD PTR _srcULine$[ebp], ecx

; 318  :     Tin *srcVLine = (Tin *)src[2] + ((src_uv_pitch * y_range.start_src) + crop_left);

  00251	ba 04 00 00 00	 mov	 edx, 4
  00256	d1 e2		 shl	 edx, 1
  00258	8b 45 ac	 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  0025b	0f af 45 d4	 imul	 eax, DWORD PTR _y_range$[ebp]
  0025f	03 45 f8	 add	 eax, DWORD PTR _crop_left$[ebp]
  00262	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  00265	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  00268	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  0026b	89 45 a4	 mov	 DWORD PTR _srcVLine$[ebp], eax

; 319  :     Tout *dstLine = (Tout *)dst[1] + (dst_y_pitch >> 1) * y_range.start_dst;

  0026e	b9 04 00 00 00	 mov	 ecx, 4
  00273	c1 e1 00	 shl	 ecx, 0
  00276	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  00279	d1 fa		 sar	 edx, 1
  0027b	0f af 55 d8	 imul	 edx, DWORD PTR _y_range$[ebp+4]
  0027f	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
  00282	03 14 08	 add	 edx, DWORD PTR [eax+ecx]
  00285	89 55 a0	 mov	 DWORD PTR _dstLine$[ebp], edx

; 320  :     for (int y = 0; y < y_range.len; y += 2, srcULine += src_uv_pitch * 2, srcVLine += src_uv_pitch * 2, dstLine += dst_y_pitch) {

  00288	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR _y$17[ebp], 0
  0028f	eb 2e		 jmp	 SHORT $LN10@convert_yu
$LN8@convert_yu:
  00291	8b 4d 9c	 mov	 ecx, DWORD PTR _y$17[ebp]
  00294	83 c1 02	 add	 ecx, 2
  00297	89 4d 9c	 mov	 DWORD PTR _y$17[ebp], ecx
  0029a	8b 55 ac	 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  0029d	d1 e2		 shl	 edx, 1
  0029f	8b 45 a8	 mov	 eax, DWORD PTR _srcULine$[ebp]
  002a2	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  002a5	89 4d a8	 mov	 DWORD PTR _srcULine$[ebp], ecx
  002a8	8b 55 ac	 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  002ab	d1 e2		 shl	 edx, 1
  002ad	8b 45 a4	 mov	 eax, DWORD PTR _srcVLine$[ebp]
  002b0	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  002b3	89 4d a4	 mov	 DWORD PTR _srcVLine$[ebp], ecx
  002b6	8b 55 a0	 mov	 edx, DWORD PTR _dstLine$[ebp]
  002b9	03 55 e4	 add	 edx, DWORD PTR _dst_y_pitch$[ebp]
  002bc	89 55 a0	 mov	 DWORD PTR _dstLine$[ebp], edx
$LN10@convert_yu:
  002bf	8b 45 9c	 mov	 eax, DWORD PTR _y$17[ebp]
  002c2	3b 45 dc	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  002c5	0f 8d 36 01 00
	00		 jge	 $LN1@convert_yu

; 321  :         Tout *dstC = dstLine;

  002cb	8b 4d a0	 mov	 ecx, DWORD PTR _dstLine$[ebp]
  002ce	89 4d 98	 mov	 DWORD PTR _dstC$16[ebp], ecx

; 322  :         Tin *srcU = srcULine;

  002d1	8b 55 a8	 mov	 edx, DWORD PTR _srcULine$[ebp]
  002d4	89 55 94	 mov	 DWORD PTR _srcU$15[ebp], edx

; 323  :         Tin *srcV = srcVLine;

  002d7	8b 45 a4	 mov	 eax, DWORD PTR _srcVLine$[ebp]
  002da	89 45 90	 mov	 DWORD PTR _srcV$14[ebp], eax

; 324  :         const int x_fin = width - crop_right - crop_left;

  002dd	8b 4d 10	 mov	 ecx, DWORD PTR _width$[ebp]
  002e0	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  002e3	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  002e6	89 4d 8c	 mov	 DWORD PTR _x_fin$13[ebp], ecx

; 325  :         for (int x = 0; x < x_fin; x += 2, dstC += 2, srcU += 2, srcV += 2) {

  002e9	c7 45 88 00 00
	00 00		 mov	 DWORD PTR _x$12[ebp], 0
  002f0	eb 24		 jmp	 SHORT $LN13@convert_yu
$LN11@convert_yu:
  002f2	8b 55 88	 mov	 edx, DWORD PTR _x$12[ebp]
  002f5	83 c2 02	 add	 edx, 2
  002f8	89 55 88	 mov	 DWORD PTR _x$12[ebp], edx
  002fb	8b 45 98	 mov	 eax, DWORD PTR _dstC$16[ebp]
  002fe	83 c0 02	 add	 eax, 2
  00301	89 45 98	 mov	 DWORD PTR _dstC$16[ebp], eax
  00304	8b 4d 94	 mov	 ecx, DWORD PTR _srcU$15[ebp]
  00307	83 c1 04	 add	 ecx, 4
  0030a	89 4d 94	 mov	 DWORD PTR _srcU$15[ebp], ecx
  0030d	8b 55 90	 mov	 edx, DWORD PTR _srcV$14[ebp]
  00310	83 c2 04	 add	 edx, 4
  00313	89 55 90	 mov	 DWORD PTR _srcV$14[ebp], edx
$LN13@convert_yu:
  00316	8b 45 88	 mov	 eax, DWORD PTR _x$12[ebp]
  00319	3b 45 8c	 cmp	 eax, DWORD PTR _x_fin$13[ebp]
  0031c	0f 8d da 00 00
	00		 jge	 $LN12@convert_yu

; 326  :             int cy0u = srcU[0*src_uv_pitch + 0];

  00322	6b 4d ac 00	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 0
  00326	8b 55 94	 mov	 edx, DWORD PTR _srcU$15[ebp]
  00329	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  0032d	89 45 84	 mov	 DWORD PTR _cy0u$11[ebp], eax

; 327  :             int cy0v = srcV[0*src_uv_pitch + 0];

  00330	6b 4d ac 00	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 0
  00334	8b 55 90	 mov	 edx, DWORD PTR _srcV$14[ebp]
  00337	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  0033b	89 45 80	 mov	 DWORD PTR _cy0v$10[ebp], eax

; 328  :             int cy1u = srcU[1*src_uv_pitch + 0];

  0033e	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00341	8b 55 94	 mov	 edx, DWORD PTR _srcU$15[ebp]
  00344	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00348	89 85 7c ff ff
	ff		 mov	 DWORD PTR _cy1u$9[ebp], eax

; 329  :             int cy1v = srcV[1*src_uv_pitch + 0];

  0034e	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00351	8b 55 90	 mov	 edx, DWORD PTR _srcV$14[ebp]
  00354	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00358	89 85 78 ff ff
	ff		 mov	 DWORD PTR _cy1v$8[ebp], eax

; 330  : 
; 331  :             int cu = cy0u + cy1u + 1;

  0035e	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _cy1u$9[ebp]
  00364	8b 55 84	 mov	 edx, DWORD PTR _cy0u$11[ebp]
  00367	8d 44 0a 01	 lea	 eax, DWORD PTR [edx+ecx+1]
  0036b	89 85 74 ff ff
	ff		 mov	 DWORD PTR _cu$7[ebp], eax

; 332  :             int cv = cy0v + cy1v + 1;

  00371	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1v$8[ebp]
  00377	8b 55 80	 mov	 edx, DWORD PTR _cy0v$10[ebp]
  0037a	8d 44 0a 01	 lea	 eax, DWORD PTR [edx+ecx+1]
  0037e	89 85 70 ff ff
	ff		 mov	 DWORD PTR _cv$6[ebp], eax

; 333  :             CHANGE_BIT_DEPTH_2(cu, cv, 1);

  00384	33 c9		 xor	 ecx, ecx
  00386	74 20		 je	 SHORT $LN21@convert_yu
  00388	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _cu$7[ebp]
  0038e	c1 e2 fd	 shl	 edx, -3			; fffffffdH
  00391	89 95 74 ff ff
	ff		 mov	 DWORD PTR _cu$7[ebp], edx
  00397	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _cv$6[ebp]
  0039d	c1 e0 fd	 shl	 eax, -3			; fffffffdH
  003a0	89 85 70 ff ff
	ff		 mov	 DWORD PTR _cv$6[ebp], eax
  003a6	eb 27		 jmp	 SHORT $LN22@convert_yu
$LN21@convert_yu:
  003a8	b9 01 00 00 00	 mov	 ecx, 1
  003ad	85 c9		 test	 ecx, ecx
  003af	74 1e		 je	 SHORT $LN22@convert_yu
  003b1	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _cu$7[ebp]
  003b7	c1 fa 03	 sar	 edx, 3
  003ba	89 95 74 ff ff
	ff		 mov	 DWORD PTR _cu$7[ebp], edx
  003c0	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _cv$6[ebp]
  003c6	c1 f8 03	 sar	 eax, 3
  003c9	89 85 70 ff ff
	ff		 mov	 DWORD PTR _cv$6[ebp], eax
$LN22@convert_yu:

; 334  : 
; 335  :             dstC[0] = (Tout)cu;

  003cf	b9 01 00 00 00	 mov	 ecx, 1
  003d4	6b d1 00	 imul	 edx, ecx, 0
  003d7	8b 45 98	 mov	 eax, DWORD PTR _dstC$16[ebp]
  003da	8a 8d 74 ff ff
	ff		 mov	 cl, BYTE PTR _cu$7[ebp]
  003e0	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 336  :             dstC[1] = (Tout)cv;

  003e3	ba 01 00 00 00	 mov	 edx, 1
  003e8	c1 e2 00	 shl	 edx, 0
  003eb	8b 45 98	 mov	 eax, DWORD PTR _dstC$16[ebp]
  003ee	8a 8d 70 ff ff
	ff		 mov	 cl, BYTE PTR _cv$6[ebp]
  003f4	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 337  :         }

  003f7	e9 f6 fe ff ff	 jmp	 $LN11@convert_yu
$LN12@convert_yu:

; 338  :     }

  003fc	e9 90 fe ff ff	 jmp	 $LN8@convert_yu
$LN1@convert_yu:

; 339  : }

  00401	52		 push	 edx
  00402	8b cd		 mov	 ecx, ebp
  00404	50		 push	 eax
  00405	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN27@convert_yu
  0040b	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00410	58		 pop	 eax
  00411	5a		 pop	 edx
  00412	5f		 pop	 edi
  00413	5b		 pop	 ebx
  00414	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00417	33 cd		 xor	 ecx, ebp
  00419	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0041e	81 c4 ac 00 00
	00		 add	 esp, 172		; 000000acH
  00424	3b ec		 cmp	 ebp, esp
  00426	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0042b	8b e5		 mov	 esp, ebp
  0042d	5d		 pop	 ebp
  0042e	c3		 ret	 0
  0042f	90		 npad	 1
$LN27@convert_yu:
  00430	01 00 00 00	 DD	 1
  00434	00 00 00 00	 DD	 $LN26@convert_yu
$LN26@convert_yu:
  00438	d4 ff ff ff	 DD	 -44			; ffffffd4H
  0043c	0c 00 00 00	 DD	 12			; 0000000cH
  00440	00 00 00 00	 DD	 $LN25@convert_yu
$LN25@convert_yu:
  00444	79		 DB	 121			; 00000079H
  00445	5f		 DB	 95			; 0000005fH
  00446	72		 DB	 114			; 00000072H
  00447	61		 DB	 97			; 00000061H
  00448	6e		 DB	 110			; 0000006eH
  00449	67		 DB	 103			; 00000067H
  0044a	65		 DB	 101			; 00000065H
  0044b	00		 DB	 0
??$convert_yuv444_to_nv12_p_c@G$09E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_to_nv12_p_c<unsigned short,10,unsigned char,8,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuv444_10_to_nv12_p@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_10_to_nv12_p

; 448  : static void convert_yuv444_10_to_nv12_p(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 449  :     convert_yuv444_to_nv12_p_c<uint16_t, 10, uint8_t, 8, false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yuv444_to_nv12_p_c@G$09E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_to_nv12_p_c<unsigned short,10,unsigned char,8,0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 450  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yuv444_10_to_nv12_p@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_10_to_nv12_p
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
$T1 = -200						; size = 4
$T2 = -196						; size = 4
$T3 = -192						; size = 4
$T4 = -188						; size = 4
$T5 = -184						; size = 12
_cv_y1$6 = -172						; size = 4
_cv_y0$7 = -168						; size = 4
_cu_y1$8 = -164						; size = 4
_cu_y0$9 = -160						; size = 4
_cy3v$10 = -156						; size = 4
_cy3u$11 = -152						; size = 4
_cy2v$12 = -148						; size = 4
_cy2u$13 = -144						; size = 4
_cy1v$14 = -140						; size = 4
_cy1u$15 = -136						; size = 4
_cy0v$16 = -132						; size = 4
_cy0u$17 = -128						; size = 4
_x$18 = -124						; size = 4
_x_fin$19 = -120					; size = 4
_srcV$20 = -116						; size = 4
_srcU$21 = -112						; size = 4
_dstC$22 = -108						; size = 4
_y$23 = -104						; size = 4
_uv_fin$ = -100						; size = 4
_dstLine$ = -96						; size = 4
_srcVLine$ = -92					; size = 4
_srcULine$ = -88					; size = 4
_src_uv_pitch$ = -84					; size = 4
_x$24 = -80						; size = 4
_y$25 = -76						; size = 4
_y_width$26 = -72					; size = 4
_dstLine$27 = -68					; size = 4
_srcYLine$28 = -64					; size = 4
$T29 = -60						; size = 12
_y_range$ = -44						; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yuv444_to_nv12_i_c@G$0M@E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_to_nv12_i_c<unsigned short,12,unsigned char,8,0>

; 342  : static void __forceinline convert_yuv444_to_nv12_i_c(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  00009	53		 push	 ebx
  0000a	57		 push	 edi
  0000b	8d bd 38 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-200]
  00011	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 343  :     static_assert((sizeof(Tin)  == 1 && in_bit_depth  == 8) || (sizeof(Tin)  == 2 && 8 < in_bit_depth  && in_bit_depth  <= 16), "invalid input bit depth.");
; 344  :     static_assert((sizeof(Tout) == 1 && out_bit_depth == 8) || (sizeof(Tout) == 2 && 8 < out_bit_depth && out_bit_depth <= 16), "invalid output bit depth.");
; 345  :     const int crop_left   = crop[0];

  00027	b8 04 00 00 00	 mov	 eax, 4
  0002c	6b c8 00	 imul	 ecx, eax, 0
  0002f	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00032	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00035	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 346  :     const int crop_up     = crop[1];

  00038	b9 04 00 00 00	 mov	 ecx, 4
  0003d	c1 e1 00	 shl	 ecx, 0
  00040	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00043	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00046	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 347  :     const int crop_right  = crop[2];

  00049	b9 04 00 00 00	 mov	 ecx, 4
  0004e	d1 e1		 shl	 ecx, 1
  00050	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00053	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00056	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 348  :     const int crop_bottom = crop[3];

  00059	b9 04 00 00 00	 mov	 ecx, 4
  0005e	6b d1 03	 imul	 edx, ecx, 3
  00061	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00064	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00067	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 349  :     const int src_y_pitch = src_y_pitch_byte / sizeof(Tin);

  0006a	8b 55 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebp]
  0006d	d1 ea		 shr	 edx, 1
  0006f	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 350  :     const int dst_y_pitch = dst_y_pitch_byte / sizeof(Tout);

  00072	8b 45 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  00075	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 351  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00078	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0007b	51		 push	 ecx
  0007c	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0007f	52		 push	 edx
  00080	8b 45 20	 mov	 eax, DWORD PTR _height$[ebp]
  00083	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  00086	50		 push	 eax
  00087	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  0008a	51		 push	 ecx
  0008b	8d 95 48 ff ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  00091	52		 push	 edx
  00092	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00097	83 c4 14	 add	 esp, 20			; 00000014H
  0009a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009c	89 4d c4	 mov	 DWORD PTR $T29[ebp], ecx
  0009f	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a2	89 55 c8	 mov	 DWORD PTR $T29[ebp+4], edx
  000a5	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000a8	89 45 cc	 mov	 DWORD PTR $T29[ebp+8], eax
  000ab	8b 4d c4	 mov	 ecx, DWORD PTR $T29[ebp]
  000ae	89 4d d4	 mov	 DWORD PTR _y_range$[ebp], ecx
  000b1	8b 55 c8	 mov	 edx, DWORD PTR $T29[ebp+4]
  000b4	89 55 d8	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000b7	8b 45 cc	 mov	 eax, DWORD PTR $T29[ebp+8]
  000ba	89 45 dc	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 352  :     //Y
; 353  :     if (!uv_only) {

  000bd	b9 01 00 00 00	 mov	 ecx, 1
  000c2	85 c9		 test	 ecx, ecx
  000c4	0f 84 61 01 00
	00		 je	 $LN14@convert_yu

; 354  :         Tin *srcYLine = (Tin *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000ca	ba 04 00 00 00	 mov	 edx, 4
  000cf	6b c2 00	 imul	 eax, edx, 0
  000d2	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  000d5	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  000d9	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  000dc	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  000df	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  000e2	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  000e5	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  000e8	89 45 c0	 mov	 DWORD PTR _srcYLine$28[ebp], eax

; 355  :         Tout *dstLine = (Tout *)dst[0] + dst_y_pitch * y_range.start_dst;

  000eb	b9 04 00 00 00	 mov	 ecx, 4
  000f0	6b d1 00	 imul	 edx, ecx, 0
  000f3	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  000f6	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  000fa	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  000fd	03 04 11	 add	 eax, DWORD PTR [ecx+edx]
  00100	89 45 bc	 mov	 DWORD PTR _dstLine$27[ebp], eax

; 356  :         const int y_width = width - crop_right - crop_left;

  00103	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00106	2b 55 f0	 sub	 edx, DWORD PTR _crop_right$[ebp]
  00109	2b 55 f8	 sub	 edx, DWORD PTR _crop_left$[ebp]
  0010c	89 55 b8	 mov	 DWORD PTR _y_width$26[ebp], edx

; 357  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  0010f	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _y$25[ebp], 0
  00116	eb 1e		 jmp	 SHORT $LN4@convert_yu
$LN2@convert_yu:
  00118	8b 45 b4	 mov	 eax, DWORD PTR _y$25[ebp]
  0011b	83 c0 01	 add	 eax, 1
  0011e	89 45 b4	 mov	 DWORD PTR _y$25[ebp], eax
  00121	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  00124	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$28[ebp]
  00127	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  0012a	89 45 c0	 mov	 DWORD PTR _srcYLine$28[ebp], eax
  0012d	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$27[ebp]
  00130	03 4d e4	 add	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  00133	89 4d bc	 mov	 DWORD PTR _dstLine$27[ebp], ecx
$LN4@convert_yu:
  00136	8b 55 b4	 mov	 edx, DWORD PTR _y$25[ebp]
  00139	3b 55 dc	 cmp	 edx, DWORD PTR _y_range$[ebp+8]
  0013c	0f 8d e9 00 00
	00		 jge	 $LN14@convert_yu

; 358  :             if (in_bit_depth == out_bit_depth && sizeof(Tin) == sizeof(Tout)) {

  00142	33 c0		 xor	 eax, eax
  00144	74 1b		 je	 SHORT $LN15@convert_yu

; 359  :                 memcpy(dstLine, srcYLine, y_width * sizeof(Tin));

  00146	8b 4d b8	 mov	 ecx, DWORD PTR _y_width$26[ebp]
  00149	d1 e1		 shl	 ecx, 1
  0014b	51		 push	 ecx
  0014c	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$28[ebp]
  0014f	52		 push	 edx
  00150	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$27[ebp]
  00153	50		 push	 eax
  00154	e8 00 00 00 00	 call	 _memcpy
  00159	83 c4 0c	 add	 esp, 12			; 0000000cH

; 360  :             } else {

  0015c	e9 c5 00 00 00	 jmp	 $LN16@convert_yu
$LN15@convert_yu:

; 361  :                 for (int x = 0; x < y_width; x++) {

  00161	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _x$24[ebp], 0
  00168	eb 09		 jmp	 SHORT $LN7@convert_yu
$LN5@convert_yu:
  0016a	8b 4d b0	 mov	 ecx, DWORD PTR _x$24[ebp]
  0016d	83 c1 01	 add	 ecx, 1
  00170	89 4d b0	 mov	 DWORD PTR _x$24[ebp], ecx
$LN7@convert_yu:
  00173	8b 55 b0	 mov	 edx, DWORD PTR _x$24[ebp]
  00176	3b 55 b8	 cmp	 edx, DWORD PTR _y_width$26[ebp]
  00179	0f 8d a7 00 00
	00		 jge	 $LN16@convert_yu

; 362  :                     if (out_bit_depth > in_bit_depth) {

  0017f	33 c0		 xor	 eax, eax
  00181	74 42		 je	 SHORT $LN17@convert_yu

; 363  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) << std::max(out_bit_depth - in_bit_depth, 0));

  00183	c7 85 44 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], 0
  0018d	c7 85 40 ff ff
	ff fc ff ff ff	 mov	 DWORD PTR $T3[ebp], -4	; fffffffcH
  00197	8b 4d b0	 mov	 ecx, DWORD PTR _x$24[ebp]
  0019a	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$28[ebp]
  0019d	0f b7 1c 4a	 movzx	 ebx, WORD PTR [edx+ecx*2]
  001a1	8d 85 44 ff ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  001a7	50		 push	 eax
  001a8	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  001ae	51		 push	 ecx
  001af	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  001b4	83 c4 08	 add	 esp, 8
  001b7	8b 08		 mov	 ecx, DWORD PTR [eax]
  001b9	d3 e3		 shl	 ebx, cl
  001bb	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$27[ebp]
  001be	03 55 b0	 add	 edx, DWORD PTR _x$24[ebp]
  001c1	88 1a		 mov	 BYTE PTR [edx], bl
  001c3	eb 5c		 jmp	 SHORT $LN18@convert_yu
$LN17@convert_yu:

; 364  :                     } else if (out_bit_depth < in_bit_depth) {

  001c5	b8 01 00 00 00	 mov	 eax, 1
  001ca	85 c0		 test	 eax, eax
  001cc	74 42		 je	 SHORT $LN19@convert_yu

; 365  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) >> std::max(in_bit_depth - out_bit_depth, 0));

  001ce	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], 0
  001d8	c7 85 38 ff ff
	ff 04 00 00 00	 mov	 DWORD PTR $T1[ebp], 4
  001e2	8b 4d b0	 mov	 ecx, DWORD PTR _x$24[ebp]
  001e5	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$28[ebp]
  001e8	0f b7 1c 4a	 movzx	 ebx, WORD PTR [edx+ecx*2]
  001ec	8d 85 3c ff ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  001f2	50		 push	 eax
  001f3	8d 8d 38 ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  001f9	51		 push	 ecx
  001fa	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  001ff	83 c4 08	 add	 esp, 8
  00202	8b 08		 mov	 ecx, DWORD PTR [eax]
  00204	d3 fb		 sar	 ebx, cl
  00206	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$27[ebp]
  00209	03 55 b0	 add	 edx, DWORD PTR _x$24[ebp]
  0020c	88 1a		 mov	 BYTE PTR [edx], bl

; 366  :                     } else {

  0020e	eb 11		 jmp	 SHORT $LN18@convert_yu
$LN19@convert_yu:

; 367  :                         dstLine[x] = (Tout)srcYLine[x];

  00210	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$27[ebp]
  00213	03 45 b0	 add	 eax, DWORD PTR _x$24[ebp]
  00216	8b 4d b0	 mov	 ecx, DWORD PTR _x$24[ebp]
  00219	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$28[ebp]
  0021c	8a 0c 4a	 mov	 cl, BYTE PTR [edx+ecx*2]
  0021f	88 08		 mov	 BYTE PTR [eax], cl
$LN18@convert_yu:

; 368  :                     }
; 369  :                 }

  00221	e9 44 ff ff ff	 jmp	 $LN5@convert_yu
$LN16@convert_yu:

; 370  :             }
; 371  :         }

  00226	e9 ed fe ff ff	 jmp	 $LN2@convert_yu
$LN14@convert_yu:

; 372  :     }
; 373  :     //UV
; 374  :     const int src_uv_pitch = src_uv_pitch_byte / sizeof(Tin);

  0022b	8b 55 18	 mov	 edx, DWORD PTR _src_uv_pitch_byte$[ebp]
  0022e	d1 ea		 shr	 edx, 1
  00230	89 55 ac	 mov	 DWORD PTR _src_uv_pitch$[ebp], edx

; 375  :     Tin *srcULine = (Tin *)src[1] + ((src_uv_pitch * y_range.start_src) + crop_left);

  00233	b8 04 00 00 00	 mov	 eax, 4
  00238	c1 e0 00	 shl	 eax, 0
  0023b	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  0023e	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  00242	03 4d f8	 add	 ecx, DWORD PTR _crop_left$[ebp]
  00245	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  00248	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  0024b	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  0024e	89 4d a8	 mov	 DWORD PTR _srcULine$[ebp], ecx

; 376  :     Tin *srcVLine = (Tin *)src[2] + ((src_uv_pitch * y_range.start_src) + crop_left);

  00251	ba 04 00 00 00	 mov	 edx, 4
  00256	d1 e2		 shl	 edx, 1
  00258	8b 45 ac	 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  0025b	0f af 45 d4	 imul	 eax, DWORD PTR _y_range$[ebp]
  0025f	03 45 f8	 add	 eax, DWORD PTR _crop_left$[ebp]
  00262	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  00265	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  00268	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  0026b	89 45 a4	 mov	 DWORD PTR _srcVLine$[ebp], eax

; 377  :     Tout *dstLine = (Tout *)dst[1] + (dst_y_pitch >> 1) * y_range.start_dst;

  0026e	b9 04 00 00 00	 mov	 ecx, 4
  00273	c1 e1 00	 shl	 ecx, 0
  00276	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  00279	d1 fa		 sar	 edx, 1
  0027b	0f af 55 d8	 imul	 edx, DWORD PTR _y_range$[ebp+4]
  0027f	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
  00282	03 14 08	 add	 edx, DWORD PTR [eax+ecx]
  00285	89 55 a0	 mov	 DWORD PTR _dstLine$[ebp], edx

; 378  :     const int uv_fin = height - crop_bottom - crop_up;

  00288	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  0028b	2b 4d ec	 sub	 ecx, DWORD PTR _crop_bottom$[ebp]
  0028e	2b 4d f4	 sub	 ecx, DWORD PTR _crop_up$[ebp]
  00291	89 4d 9c	 mov	 DWORD PTR _uv_fin$[ebp], ecx

; 379  :     for (int y = 0; y < y_range.len; y += 4, srcULine += src_uv_pitch * 4, srcVLine += src_uv_pitch * 4, dstLine += dst_y_pitch * 2) {

  00294	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _y$23[ebp], 0
  0029b	eb 33		 jmp	 SHORT $LN10@convert_yu
$LN8@convert_yu:
  0029d	8b 55 98	 mov	 edx, DWORD PTR _y$23[ebp]
  002a0	83 c2 04	 add	 edx, 4
  002a3	89 55 98	 mov	 DWORD PTR _y$23[ebp], edx
  002a6	8b 45 ac	 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  002a9	c1 e0 02	 shl	 eax, 2
  002ac	8b 4d a8	 mov	 ecx, DWORD PTR _srcULine$[ebp]
  002af	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  002b2	89 55 a8	 mov	 DWORD PTR _srcULine$[ebp], edx
  002b5	8b 45 ac	 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  002b8	c1 e0 02	 shl	 eax, 2
  002bb	8b 4d a4	 mov	 ecx, DWORD PTR _srcVLine$[ebp]
  002be	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  002c1	89 55 a4	 mov	 DWORD PTR _srcVLine$[ebp], edx
  002c4	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  002c7	8b 4d a0	 mov	 ecx, DWORD PTR _dstLine$[ebp]
  002ca	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  002cd	89 55 a0	 mov	 DWORD PTR _dstLine$[ebp], edx
$LN10@convert_yu:
  002d0	8b 45 98	 mov	 eax, DWORD PTR _y$23[ebp]
  002d3	3b 45 dc	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  002d6	0f 8d 04 02 00
	00		 jge	 $LN1@convert_yu

; 380  :         Tout *dstC = dstLine;

  002dc	8b 4d a0	 mov	 ecx, DWORD PTR _dstLine$[ebp]
  002df	89 4d 94	 mov	 DWORD PTR _dstC$22[ebp], ecx

; 381  :         Tin *srcU = srcULine;

  002e2	8b 55 a8	 mov	 edx, DWORD PTR _srcULine$[ebp]
  002e5	89 55 90	 mov	 DWORD PTR _srcU$21[ebp], edx

; 382  :         Tin *srcV = srcVLine;

  002e8	8b 45 a4	 mov	 eax, DWORD PTR _srcVLine$[ebp]
  002eb	89 45 8c	 mov	 DWORD PTR _srcV$20[ebp], eax

; 383  :         const int x_fin = width - crop_right - crop_left;

  002ee	8b 4d 10	 mov	 ecx, DWORD PTR _width$[ebp]
  002f1	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  002f4	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  002f7	89 4d 88	 mov	 DWORD PTR _x_fin$19[ebp], ecx

; 384  :         for (int x = 0; x < x_fin; x += 2, dstC += 2, srcU += 2, srcV += 2) {

  002fa	c7 45 84 00 00
	00 00		 mov	 DWORD PTR _x$18[ebp], 0
  00301	eb 24		 jmp	 SHORT $LN13@convert_yu
$LN11@convert_yu:
  00303	8b 55 84	 mov	 edx, DWORD PTR _x$18[ebp]
  00306	83 c2 02	 add	 edx, 2
  00309	89 55 84	 mov	 DWORD PTR _x$18[ebp], edx
  0030c	8b 45 94	 mov	 eax, DWORD PTR _dstC$22[ebp]
  0030f	83 c0 02	 add	 eax, 2
  00312	89 45 94	 mov	 DWORD PTR _dstC$22[ebp], eax
  00315	8b 4d 90	 mov	 ecx, DWORD PTR _srcU$21[ebp]
  00318	83 c1 04	 add	 ecx, 4
  0031b	89 4d 90	 mov	 DWORD PTR _srcU$21[ebp], ecx
  0031e	8b 55 8c	 mov	 edx, DWORD PTR _srcV$20[ebp]
  00321	83 c2 04	 add	 edx, 4
  00324	89 55 8c	 mov	 DWORD PTR _srcV$20[ebp], edx
$LN13@convert_yu:
  00327	8b 45 84	 mov	 eax, DWORD PTR _x$18[ebp]
  0032a	3b 45 88	 cmp	 eax, DWORD PTR _x_fin$19[ebp]
  0032d	0f 8d a8 01 00
	00		 jge	 $LN12@convert_yu

; 385  :             int cy0u = srcU[0*src_uv_pitch + 0];

  00333	6b 4d ac 00	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 0
  00337	8b 55 90	 mov	 edx, DWORD PTR _srcU$21[ebp]
  0033a	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  0033e	89 45 80	 mov	 DWORD PTR _cy0u$17[ebp], eax

; 386  :             int cy0v = srcV[0*src_uv_pitch + 0];

  00341	6b 4d ac 00	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 0
  00345	8b 55 8c	 mov	 edx, DWORD PTR _srcV$20[ebp]
  00348	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  0034c	89 85 7c ff ff
	ff		 mov	 DWORD PTR _cy0v$16[ebp], eax

; 387  :             int cy1u = srcU[1*src_uv_pitch + 0];

  00352	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00355	8b 55 90	 mov	 edx, DWORD PTR _srcU$21[ebp]
  00358	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  0035c	89 85 78 ff ff
	ff		 mov	 DWORD PTR _cy1u$15[ebp], eax

; 388  :             int cy1v = srcV[1*src_uv_pitch + 0];

  00362	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00365	8b 55 8c	 mov	 edx, DWORD PTR _srcV$20[ebp]
  00368	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  0036c	89 85 74 ff ff
	ff		 mov	 DWORD PTR _cy1v$14[ebp], eax

; 389  :             int cy2u = srcU[2*src_uv_pitch + 0];

  00372	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00375	d1 e1		 shl	 ecx, 1
  00377	8b 55 90	 mov	 edx, DWORD PTR _srcU$21[ebp]
  0037a	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  0037e	89 85 70 ff ff
	ff		 mov	 DWORD PTR _cy2u$13[ebp], eax

; 390  :             int cy2v = srcV[2*src_uv_pitch + 0];

  00384	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00387	d1 e1		 shl	 ecx, 1
  00389	8b 55 8c	 mov	 edx, DWORD PTR _srcV$20[ebp]
  0038c	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00390	89 85 6c ff ff
	ff		 mov	 DWORD PTR _cy2v$12[ebp], eax

; 391  :             int cy3u = srcU[3*src_uv_pitch + 0];

  00396	6b 4d ac 03	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 3
  0039a	8b 55 90	 mov	 edx, DWORD PTR _srcU$21[ebp]
  0039d	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  003a1	89 85 68 ff ff
	ff		 mov	 DWORD PTR _cy3u$11[ebp], eax

; 392  :             int cy3v = srcV[3*src_uv_pitch + 0];

  003a7	6b 4d ac 03	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 3
  003ab	8b 55 8c	 mov	 edx, DWORD PTR _srcV$20[ebp]
  003ae	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  003b2	89 85 64 ff ff
	ff		 mov	 DWORD PTR _cy3v$10[ebp], eax

; 393  : 
; 394  :             int cu_y0 = cy0u * 3 + cy2u * 1 + 2;

  003b8	6b 4d 80 03	 imul	 ecx, DWORD PTR _cy0u$17[ebp], 3
  003bc	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR _cy2u$13[ebp]
  003c2	8d 44 11 02	 lea	 eax, DWORD PTR [ecx+edx+2]
  003c6	89 85 60 ff ff
	ff		 mov	 DWORD PTR _cu_y0$9[ebp], eax

; 395  :             int cu_y1 = cy1u * 1 + cy3u * 3 + 2;

  003cc	6b 8d 68 ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy3u$11[ebp], 3
  003d3	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _cy1u$15[ebp]
  003d9	8d 44 0a 02	 lea	 eax, DWORD PTR [edx+ecx+2]
  003dd	89 85 5c ff ff
	ff		 mov	 DWORD PTR _cu_y1$8[ebp], eax

; 396  :             int cv_y0 = cy0v * 3 + cy2v * 1 + 2;

  003e3	6b 8d 7c ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy0v$16[ebp], 3
  003ea	8b 95 6c ff ff
	ff		 mov	 edx, DWORD PTR _cy2v$12[ebp]
  003f0	8d 44 11 02	 lea	 eax, DWORD PTR [ecx+edx+2]
  003f4	89 85 58 ff ff
	ff		 mov	 DWORD PTR _cv_y0$7[ebp], eax

; 397  :             int cv_y1 = cy1v * 1 + cy3v * 3 + 2;

  003fa	6b 8d 64 ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy3v$10[ebp], 3
  00401	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _cy1v$14[ebp]
  00407	8d 44 0a 02	 lea	 eax, DWORD PTR [edx+ecx+2]
  0040b	89 85 54 ff ff
	ff		 mov	 DWORD PTR _cv_y1$6[ebp], eax

; 398  :             CHANGE_BIT_DEPTH_4(cu_y0, cu_y1, cv_y0, cv_y1, 2);

  00411	33 c9		 xor	 ecx, ecx
  00413	74 3e		 je	 SHORT $LN21@convert_yu
  00415	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _cu_y0$9[ebp]
  0041b	c1 e2 fa	 shl	 edx, -6			; fffffffaH
  0041e	89 95 60 ff ff
	ff		 mov	 DWORD PTR _cu_y0$9[ebp], edx
  00424	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _cu_y1$8[ebp]
  0042a	c1 e0 fa	 shl	 eax, -6			; fffffffaH
  0042d	89 85 5c ff ff
	ff		 mov	 DWORD PTR _cu_y1$8[ebp], eax
  00433	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _cv_y0$7[ebp]
  00439	c1 e1 fa	 shl	 ecx, -6			; fffffffaH
  0043c	89 8d 58 ff ff
	ff		 mov	 DWORD PTR _cv_y0$7[ebp], ecx
  00442	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR _cv_y1$6[ebp]
  00448	c1 e2 fa	 shl	 edx, -6			; fffffffaH
  0044b	89 95 54 ff ff
	ff		 mov	 DWORD PTR _cv_y1$6[ebp], edx
  00451	eb 45		 jmp	 SHORT $LN22@convert_yu
$LN21@convert_yu:
  00453	b8 01 00 00 00	 mov	 eax, 1
  00458	85 c0		 test	 eax, eax
  0045a	74 3c		 je	 SHORT $LN22@convert_yu
  0045c	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _cu_y0$9[ebp]
  00462	c1 f9 06	 sar	 ecx, 6
  00465	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _cu_y0$9[ebp], ecx
  0046b	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR _cu_y1$8[ebp]
  00471	c1 fa 06	 sar	 edx, 6
  00474	89 95 5c ff ff
	ff		 mov	 DWORD PTR _cu_y1$8[ebp], edx
  0047a	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _cv_y0$7[ebp]
  00480	c1 f8 06	 sar	 eax, 6
  00483	89 85 58 ff ff
	ff		 mov	 DWORD PTR _cv_y0$7[ebp], eax
  00489	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _cv_y1$6[ebp]
  0048f	c1 f9 06	 sar	 ecx, 6
  00492	89 8d 54 ff ff
	ff		 mov	 DWORD PTR _cv_y1$6[ebp], ecx
$LN22@convert_yu:

; 399  : 
; 400  :             dstC[0*dst_y_pitch + 0] = (Tout)cu_y0;

  00498	6b 55 e4 00	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 0
  0049c	8b 45 94	 mov	 eax, DWORD PTR _dstC$22[ebp]
  0049f	8a 8d 60 ff ff
	ff		 mov	 cl, BYTE PTR _cu_y0$9[ebp]
  004a5	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 401  :             dstC[0*dst_y_pitch + 1] = (Tout)cv_y0;

  004a8	6b 55 e4 00	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 0
  004ac	8b 45 94	 mov	 eax, DWORD PTR _dstC$22[ebp]
  004af	8a 8d 58 ff ff
	ff		 mov	 cl, BYTE PTR _cv_y0$7[ebp]
  004b5	88 4c 10 01	 mov	 BYTE PTR [eax+edx+1], cl

; 402  :             dstC[1*dst_y_pitch + 0] = (Tout)cu_y1;

  004b9	8b 55 94	 mov	 edx, DWORD PTR _dstC$22[ebp]
  004bc	03 55 e4	 add	 edx, DWORD PTR _dst_y_pitch$[ebp]
  004bf	8a 85 5c ff ff
	ff		 mov	 al, BYTE PTR _cu_y1$8[ebp]
  004c5	88 02		 mov	 BYTE PTR [edx], al

; 403  :             dstC[1*dst_y_pitch + 1] = (Tout)cv_y1;

  004c7	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$22[ebp]
  004ca	03 4d e4	 add	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  004cd	8a 95 54 ff ff
	ff		 mov	 dl, BYTE PTR _cv_y1$6[ebp]
  004d3	88 51 01	 mov	 BYTE PTR [ecx+1], dl

; 404  :         }

  004d6	e9 28 fe ff ff	 jmp	 $LN11@convert_yu
$LN12@convert_yu:

; 405  :     }

  004db	e9 bd fd ff ff	 jmp	 $LN8@convert_yu
$LN1@convert_yu:

; 406  : }

  004e0	52		 push	 edx
  004e1	8b cd		 mov	 ecx, ebp
  004e3	50		 push	 eax
  004e4	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN27@convert_yu
  004ea	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  004ef	58		 pop	 eax
  004f0	5a		 pop	 edx
  004f1	5f		 pop	 edi
  004f2	5b		 pop	 ebx
  004f3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004f6	33 cd		 xor	 ecx, ebp
  004f8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004fd	81 c4 c8 00 00
	00		 add	 esp, 200		; 000000c8H
  00503	3b ec		 cmp	 ebp, esp
  00505	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0050a	8b e5		 mov	 esp, ebp
  0050c	5d		 pop	 ebp
  0050d	c3		 ret	 0
  0050e	66 90		 npad	 2
$LN27@convert_yu:
  00510	01 00 00 00	 DD	 1
  00514	00 00 00 00	 DD	 $LN26@convert_yu
$LN26@convert_yu:
  00518	d4 ff ff ff	 DD	 -44			; ffffffd4H
  0051c	0c 00 00 00	 DD	 12			; 0000000cH
  00520	00 00 00 00	 DD	 $LN25@convert_yu
$LN25@convert_yu:
  00524	79		 DB	 121			; 00000079H
  00525	5f		 DB	 95			; 0000005fH
  00526	72		 DB	 114			; 00000072H
  00527	61		 DB	 97			; 00000061H
  00528	6e		 DB	 110			; 0000006eH
  00529	67		 DB	 103			; 00000067H
  0052a	65		 DB	 101			; 00000065H
  0052b	00		 DB	 0
??$convert_yuv444_to_nv12_i_c@G$0M@E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_to_nv12_i_c<unsigned short,12,unsigned char,8,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuv444_12_to_nv12_i@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_12_to_nv12_i

; 444  : static void convert_yuv444_12_to_nv12_i(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 445  :     convert_yuv444_to_nv12_i_c<uint16_t, 12, uint8_t, 8, false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yuv444_to_nv12_i_c@G$0M@E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_to_nv12_i_c<unsigned short,12,unsigned char,8,0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 446  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yuv444_12_to_nv12_i@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_12_to_nv12_i
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
$T1 = -172						; size = 4
$T2 = -168						; size = 4
$T3 = -164						; size = 4
$T4 = -160						; size = 4
$T5 = -156						; size = 12
_cv$6 = -144						; size = 4
_cu$7 = -140						; size = 4
_cy1v$8 = -136						; size = 4
_cy1u$9 = -132						; size = 4
_cy0v$10 = -128						; size = 4
_cy0u$11 = -124						; size = 4
_x$12 = -120						; size = 4
_x_fin$13 = -116					; size = 4
_srcV$14 = -112						; size = 4
_srcU$15 = -108						; size = 4
_dstC$16 = -104						; size = 4
_y$17 = -100						; size = 4
_dstLine$ = -96						; size = 4
_srcVLine$ = -92					; size = 4
_srcULine$ = -88					; size = 4
_src_uv_pitch$ = -84					; size = 4
_x$18 = -80						; size = 4
_y$19 = -76						; size = 4
_y_width$20 = -72					; size = 4
_dstLine$21 = -68					; size = 4
_srcYLine$22 = -64					; size = 4
$T23 = -60						; size = 12
_y_range$ = -44						; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yuv444_to_nv12_p_c@G$0M@E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_to_nv12_p_c<unsigned short,12,unsigned char,8,0>

; 284  : static void __forceinline convert_yuv444_to_nv12_p_c(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec ac 00 00
	00		 sub	 esp, 172		; 000000acH
  00009	53		 push	 ebx
  0000a	57		 push	 edi
  0000b	8d bd 54 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-172]
  00011	b9 2b 00 00 00	 mov	 ecx, 43			; 0000002bH
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 285  :     static_assert((sizeof(Tin)  == 1 && in_bit_depth  == 8) || (sizeof(Tin)  == 2 && 8 < in_bit_depth  && in_bit_depth  <= 16), "invalid input bit depth.");
; 286  :     static_assert((sizeof(Tout) == 1 && out_bit_depth == 8) || (sizeof(Tout) == 2 && 8 < out_bit_depth && out_bit_depth <= 16), "invalid output bit depth.");
; 287  :     const int crop_left   = crop[0];

  00027	b8 04 00 00 00	 mov	 eax, 4
  0002c	6b c8 00	 imul	 ecx, eax, 0
  0002f	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00032	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00035	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 288  :     const int crop_up     = crop[1];

  00038	b9 04 00 00 00	 mov	 ecx, 4
  0003d	c1 e1 00	 shl	 ecx, 0
  00040	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00043	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00046	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 289  :     const int crop_right  = crop[2];

  00049	b9 04 00 00 00	 mov	 ecx, 4
  0004e	d1 e1		 shl	 ecx, 1
  00050	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00053	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00056	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 290  :     const int crop_bottom = crop[3];

  00059	b9 04 00 00 00	 mov	 ecx, 4
  0005e	6b d1 03	 imul	 edx, ecx, 3
  00061	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00064	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00067	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 291  :     const int src_y_pitch = src_y_pitch_byte / sizeof(Tin);

  0006a	8b 55 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebp]
  0006d	d1 ea		 shr	 edx, 1
  0006f	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 292  :     const int dst_y_pitch = dst_y_pitch_byte / sizeof(Tout);

  00072	8b 45 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  00075	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 293  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00078	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0007b	51		 push	 ecx
  0007c	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0007f	52		 push	 edx
  00080	8b 45 20	 mov	 eax, DWORD PTR _height$[ebp]
  00083	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  00086	50		 push	 eax
  00087	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  0008a	51		 push	 ecx
  0008b	8d 95 64 ff ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  00091	52		 push	 edx
  00092	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00097	83 c4 14	 add	 esp, 20			; 00000014H
  0009a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009c	89 4d c4	 mov	 DWORD PTR $T23[ebp], ecx
  0009f	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a2	89 55 c8	 mov	 DWORD PTR $T23[ebp+4], edx
  000a5	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000a8	89 45 cc	 mov	 DWORD PTR $T23[ebp+8], eax
  000ab	8b 4d c4	 mov	 ecx, DWORD PTR $T23[ebp]
  000ae	89 4d d4	 mov	 DWORD PTR _y_range$[ebp], ecx
  000b1	8b 55 c8	 mov	 edx, DWORD PTR $T23[ebp+4]
  000b4	89 55 d8	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000b7	8b 45 cc	 mov	 eax, DWORD PTR $T23[ebp+8]
  000ba	89 45 dc	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 294  :     //Y
; 295  :     if (!uv_only) {

  000bd	b9 01 00 00 00	 mov	 ecx, 1
  000c2	85 c9		 test	 ecx, ecx
  000c4	0f 84 61 01 00
	00		 je	 $LN14@convert_yu

; 296  :         Tin *srcYLine = (Tin *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000ca	ba 04 00 00 00	 mov	 edx, 4
  000cf	6b c2 00	 imul	 eax, edx, 0
  000d2	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  000d5	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  000d9	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  000dc	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  000df	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  000e2	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  000e5	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  000e8	89 45 c0	 mov	 DWORD PTR _srcYLine$22[ebp], eax

; 297  :         Tout *dstLine = (Tout *)dst[0] + dst_y_pitch * y_range.start_dst;

  000eb	b9 04 00 00 00	 mov	 ecx, 4
  000f0	6b d1 00	 imul	 edx, ecx, 0
  000f3	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  000f6	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  000fa	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  000fd	03 04 11	 add	 eax, DWORD PTR [ecx+edx]
  00100	89 45 bc	 mov	 DWORD PTR _dstLine$21[ebp], eax

; 298  :         const int y_width = width - crop_right - crop_left;

  00103	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00106	2b 55 f0	 sub	 edx, DWORD PTR _crop_right$[ebp]
  00109	2b 55 f8	 sub	 edx, DWORD PTR _crop_left$[ebp]
  0010c	89 55 b8	 mov	 DWORD PTR _y_width$20[ebp], edx

; 299  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  0010f	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _y$19[ebp], 0
  00116	eb 1e		 jmp	 SHORT $LN4@convert_yu
$LN2@convert_yu:
  00118	8b 45 b4	 mov	 eax, DWORD PTR _y$19[ebp]
  0011b	83 c0 01	 add	 eax, 1
  0011e	89 45 b4	 mov	 DWORD PTR _y$19[ebp], eax
  00121	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  00124	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$22[ebp]
  00127	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  0012a	89 45 c0	 mov	 DWORD PTR _srcYLine$22[ebp], eax
  0012d	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$21[ebp]
  00130	03 4d e4	 add	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  00133	89 4d bc	 mov	 DWORD PTR _dstLine$21[ebp], ecx
$LN4@convert_yu:
  00136	8b 55 b4	 mov	 edx, DWORD PTR _y$19[ebp]
  00139	3b 55 dc	 cmp	 edx, DWORD PTR _y_range$[ebp+8]
  0013c	0f 8d e9 00 00
	00		 jge	 $LN14@convert_yu

; 300  :             if (in_bit_depth == out_bit_depth && sizeof(Tin) == sizeof(Tout)) {

  00142	33 c0		 xor	 eax, eax
  00144	74 1b		 je	 SHORT $LN15@convert_yu

; 301  :                 memcpy(dstLine, srcYLine, y_width * sizeof(Tin));

  00146	8b 4d b8	 mov	 ecx, DWORD PTR _y_width$20[ebp]
  00149	d1 e1		 shl	 ecx, 1
  0014b	51		 push	 ecx
  0014c	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$22[ebp]
  0014f	52		 push	 edx
  00150	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$21[ebp]
  00153	50		 push	 eax
  00154	e8 00 00 00 00	 call	 _memcpy
  00159	83 c4 0c	 add	 esp, 12			; 0000000cH

; 302  :             } else {

  0015c	e9 c5 00 00 00	 jmp	 $LN16@convert_yu
$LN15@convert_yu:

; 303  :                 for (int x = 0; x < y_width; x++) {

  00161	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _x$18[ebp], 0
  00168	eb 09		 jmp	 SHORT $LN7@convert_yu
$LN5@convert_yu:
  0016a	8b 4d b0	 mov	 ecx, DWORD PTR _x$18[ebp]
  0016d	83 c1 01	 add	 ecx, 1
  00170	89 4d b0	 mov	 DWORD PTR _x$18[ebp], ecx
$LN7@convert_yu:
  00173	8b 55 b0	 mov	 edx, DWORD PTR _x$18[ebp]
  00176	3b 55 b8	 cmp	 edx, DWORD PTR _y_width$20[ebp]
  00179	0f 8d a7 00 00
	00		 jge	 $LN16@convert_yu

; 304  :                     if (out_bit_depth > in_bit_depth) {

  0017f	33 c0		 xor	 eax, eax
  00181	74 42		 je	 SHORT $LN17@convert_yu

; 305  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) << std::max(out_bit_depth - in_bit_depth, 0));

  00183	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], 0
  0018d	c7 85 5c ff ff
	ff fc ff ff ff	 mov	 DWORD PTR $T3[ebp], -4	; fffffffcH
  00197	8b 4d b0	 mov	 ecx, DWORD PTR _x$18[ebp]
  0019a	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$22[ebp]
  0019d	0f b7 1c 4a	 movzx	 ebx, WORD PTR [edx+ecx*2]
  001a1	8d 85 60 ff ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  001a7	50		 push	 eax
  001a8	8d 8d 5c ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  001ae	51		 push	 ecx
  001af	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  001b4	83 c4 08	 add	 esp, 8
  001b7	8b 08		 mov	 ecx, DWORD PTR [eax]
  001b9	d3 e3		 shl	 ebx, cl
  001bb	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$21[ebp]
  001be	03 55 b0	 add	 edx, DWORD PTR _x$18[ebp]
  001c1	88 1a		 mov	 BYTE PTR [edx], bl
  001c3	eb 5c		 jmp	 SHORT $LN18@convert_yu
$LN17@convert_yu:

; 306  :                     } else if (out_bit_depth < in_bit_depth) {

  001c5	b8 01 00 00 00	 mov	 eax, 1
  001ca	85 c0		 test	 eax, eax
  001cc	74 42		 je	 SHORT $LN19@convert_yu

; 307  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) >> std::max(in_bit_depth - out_bit_depth, 0));

  001ce	c7 85 58 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], 0
  001d8	c7 85 54 ff ff
	ff 04 00 00 00	 mov	 DWORD PTR $T1[ebp], 4
  001e2	8b 4d b0	 mov	 ecx, DWORD PTR _x$18[ebp]
  001e5	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$22[ebp]
  001e8	0f b7 1c 4a	 movzx	 ebx, WORD PTR [edx+ecx*2]
  001ec	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  001f2	50		 push	 eax
  001f3	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  001f9	51		 push	 ecx
  001fa	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  001ff	83 c4 08	 add	 esp, 8
  00202	8b 08		 mov	 ecx, DWORD PTR [eax]
  00204	d3 fb		 sar	 ebx, cl
  00206	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$21[ebp]
  00209	03 55 b0	 add	 edx, DWORD PTR _x$18[ebp]
  0020c	88 1a		 mov	 BYTE PTR [edx], bl

; 308  :                     } else {

  0020e	eb 11		 jmp	 SHORT $LN18@convert_yu
$LN19@convert_yu:

; 309  :                         dstLine[x] = (Tout)srcYLine[x];

  00210	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$21[ebp]
  00213	03 45 b0	 add	 eax, DWORD PTR _x$18[ebp]
  00216	8b 4d b0	 mov	 ecx, DWORD PTR _x$18[ebp]
  00219	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$22[ebp]
  0021c	8a 0c 4a	 mov	 cl, BYTE PTR [edx+ecx*2]
  0021f	88 08		 mov	 BYTE PTR [eax], cl
$LN18@convert_yu:

; 310  :                     }
; 311  :                 }

  00221	e9 44 ff ff ff	 jmp	 $LN5@convert_yu
$LN16@convert_yu:

; 312  :             }
; 313  :         }

  00226	e9 ed fe ff ff	 jmp	 $LN2@convert_yu
$LN14@convert_yu:

; 314  :     }
; 315  :     //UV
; 316  :     const int src_uv_pitch = src_uv_pitch_byte / sizeof(Tin);

  0022b	8b 55 18	 mov	 edx, DWORD PTR _src_uv_pitch_byte$[ebp]
  0022e	d1 ea		 shr	 edx, 1
  00230	89 55 ac	 mov	 DWORD PTR _src_uv_pitch$[ebp], edx

; 317  :     Tin *srcULine = (Tin *)src[1] + ((src_uv_pitch * y_range.start_src) + crop_left);

  00233	b8 04 00 00 00	 mov	 eax, 4
  00238	c1 e0 00	 shl	 eax, 0
  0023b	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  0023e	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  00242	03 4d f8	 add	 ecx, DWORD PTR _crop_left$[ebp]
  00245	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  00248	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  0024b	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  0024e	89 4d a8	 mov	 DWORD PTR _srcULine$[ebp], ecx

; 318  :     Tin *srcVLine = (Tin *)src[2] + ((src_uv_pitch * y_range.start_src) + crop_left);

  00251	ba 04 00 00 00	 mov	 edx, 4
  00256	d1 e2		 shl	 edx, 1
  00258	8b 45 ac	 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  0025b	0f af 45 d4	 imul	 eax, DWORD PTR _y_range$[ebp]
  0025f	03 45 f8	 add	 eax, DWORD PTR _crop_left$[ebp]
  00262	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  00265	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  00268	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  0026b	89 45 a4	 mov	 DWORD PTR _srcVLine$[ebp], eax

; 319  :     Tout *dstLine = (Tout *)dst[1] + (dst_y_pitch >> 1) * y_range.start_dst;

  0026e	b9 04 00 00 00	 mov	 ecx, 4
  00273	c1 e1 00	 shl	 ecx, 0
  00276	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  00279	d1 fa		 sar	 edx, 1
  0027b	0f af 55 d8	 imul	 edx, DWORD PTR _y_range$[ebp+4]
  0027f	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
  00282	03 14 08	 add	 edx, DWORD PTR [eax+ecx]
  00285	89 55 a0	 mov	 DWORD PTR _dstLine$[ebp], edx

; 320  :     for (int y = 0; y < y_range.len; y += 2, srcULine += src_uv_pitch * 2, srcVLine += src_uv_pitch * 2, dstLine += dst_y_pitch) {

  00288	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR _y$17[ebp], 0
  0028f	eb 2e		 jmp	 SHORT $LN10@convert_yu
$LN8@convert_yu:
  00291	8b 4d 9c	 mov	 ecx, DWORD PTR _y$17[ebp]
  00294	83 c1 02	 add	 ecx, 2
  00297	89 4d 9c	 mov	 DWORD PTR _y$17[ebp], ecx
  0029a	8b 55 ac	 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  0029d	d1 e2		 shl	 edx, 1
  0029f	8b 45 a8	 mov	 eax, DWORD PTR _srcULine$[ebp]
  002a2	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  002a5	89 4d a8	 mov	 DWORD PTR _srcULine$[ebp], ecx
  002a8	8b 55 ac	 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  002ab	d1 e2		 shl	 edx, 1
  002ad	8b 45 a4	 mov	 eax, DWORD PTR _srcVLine$[ebp]
  002b0	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  002b3	89 4d a4	 mov	 DWORD PTR _srcVLine$[ebp], ecx
  002b6	8b 55 a0	 mov	 edx, DWORD PTR _dstLine$[ebp]
  002b9	03 55 e4	 add	 edx, DWORD PTR _dst_y_pitch$[ebp]
  002bc	89 55 a0	 mov	 DWORD PTR _dstLine$[ebp], edx
$LN10@convert_yu:
  002bf	8b 45 9c	 mov	 eax, DWORD PTR _y$17[ebp]
  002c2	3b 45 dc	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  002c5	0f 8d 36 01 00
	00		 jge	 $LN1@convert_yu

; 321  :         Tout *dstC = dstLine;

  002cb	8b 4d a0	 mov	 ecx, DWORD PTR _dstLine$[ebp]
  002ce	89 4d 98	 mov	 DWORD PTR _dstC$16[ebp], ecx

; 322  :         Tin *srcU = srcULine;

  002d1	8b 55 a8	 mov	 edx, DWORD PTR _srcULine$[ebp]
  002d4	89 55 94	 mov	 DWORD PTR _srcU$15[ebp], edx

; 323  :         Tin *srcV = srcVLine;

  002d7	8b 45 a4	 mov	 eax, DWORD PTR _srcVLine$[ebp]
  002da	89 45 90	 mov	 DWORD PTR _srcV$14[ebp], eax

; 324  :         const int x_fin = width - crop_right - crop_left;

  002dd	8b 4d 10	 mov	 ecx, DWORD PTR _width$[ebp]
  002e0	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  002e3	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  002e6	89 4d 8c	 mov	 DWORD PTR _x_fin$13[ebp], ecx

; 325  :         for (int x = 0; x < x_fin; x += 2, dstC += 2, srcU += 2, srcV += 2) {

  002e9	c7 45 88 00 00
	00 00		 mov	 DWORD PTR _x$12[ebp], 0
  002f0	eb 24		 jmp	 SHORT $LN13@convert_yu
$LN11@convert_yu:
  002f2	8b 55 88	 mov	 edx, DWORD PTR _x$12[ebp]
  002f5	83 c2 02	 add	 edx, 2
  002f8	89 55 88	 mov	 DWORD PTR _x$12[ebp], edx
  002fb	8b 45 98	 mov	 eax, DWORD PTR _dstC$16[ebp]
  002fe	83 c0 02	 add	 eax, 2
  00301	89 45 98	 mov	 DWORD PTR _dstC$16[ebp], eax
  00304	8b 4d 94	 mov	 ecx, DWORD PTR _srcU$15[ebp]
  00307	83 c1 04	 add	 ecx, 4
  0030a	89 4d 94	 mov	 DWORD PTR _srcU$15[ebp], ecx
  0030d	8b 55 90	 mov	 edx, DWORD PTR _srcV$14[ebp]
  00310	83 c2 04	 add	 edx, 4
  00313	89 55 90	 mov	 DWORD PTR _srcV$14[ebp], edx
$LN13@convert_yu:
  00316	8b 45 88	 mov	 eax, DWORD PTR _x$12[ebp]
  00319	3b 45 8c	 cmp	 eax, DWORD PTR _x_fin$13[ebp]
  0031c	0f 8d da 00 00
	00		 jge	 $LN12@convert_yu

; 326  :             int cy0u = srcU[0*src_uv_pitch + 0];

  00322	6b 4d ac 00	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 0
  00326	8b 55 94	 mov	 edx, DWORD PTR _srcU$15[ebp]
  00329	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  0032d	89 45 84	 mov	 DWORD PTR _cy0u$11[ebp], eax

; 327  :             int cy0v = srcV[0*src_uv_pitch + 0];

  00330	6b 4d ac 00	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 0
  00334	8b 55 90	 mov	 edx, DWORD PTR _srcV$14[ebp]
  00337	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  0033b	89 45 80	 mov	 DWORD PTR _cy0v$10[ebp], eax

; 328  :             int cy1u = srcU[1*src_uv_pitch + 0];

  0033e	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00341	8b 55 94	 mov	 edx, DWORD PTR _srcU$15[ebp]
  00344	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00348	89 85 7c ff ff
	ff		 mov	 DWORD PTR _cy1u$9[ebp], eax

; 329  :             int cy1v = srcV[1*src_uv_pitch + 0];

  0034e	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00351	8b 55 90	 mov	 edx, DWORD PTR _srcV$14[ebp]
  00354	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00358	89 85 78 ff ff
	ff		 mov	 DWORD PTR _cy1v$8[ebp], eax

; 330  : 
; 331  :             int cu = cy0u + cy1u + 1;

  0035e	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _cy1u$9[ebp]
  00364	8b 55 84	 mov	 edx, DWORD PTR _cy0u$11[ebp]
  00367	8d 44 0a 01	 lea	 eax, DWORD PTR [edx+ecx+1]
  0036b	89 85 74 ff ff
	ff		 mov	 DWORD PTR _cu$7[ebp], eax

; 332  :             int cv = cy0v + cy1v + 1;

  00371	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1v$8[ebp]
  00377	8b 55 80	 mov	 edx, DWORD PTR _cy0v$10[ebp]
  0037a	8d 44 0a 01	 lea	 eax, DWORD PTR [edx+ecx+1]
  0037e	89 85 70 ff ff
	ff		 mov	 DWORD PTR _cv$6[ebp], eax

; 333  :             CHANGE_BIT_DEPTH_2(cu, cv, 1);

  00384	33 c9		 xor	 ecx, ecx
  00386	74 20		 je	 SHORT $LN21@convert_yu
  00388	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _cu$7[ebp]
  0038e	c1 e2 fb	 shl	 edx, -5			; fffffffbH
  00391	89 95 74 ff ff
	ff		 mov	 DWORD PTR _cu$7[ebp], edx
  00397	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _cv$6[ebp]
  0039d	c1 e0 fb	 shl	 eax, -5			; fffffffbH
  003a0	89 85 70 ff ff
	ff		 mov	 DWORD PTR _cv$6[ebp], eax
  003a6	eb 27		 jmp	 SHORT $LN22@convert_yu
$LN21@convert_yu:
  003a8	b9 01 00 00 00	 mov	 ecx, 1
  003ad	85 c9		 test	 ecx, ecx
  003af	74 1e		 je	 SHORT $LN22@convert_yu
  003b1	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _cu$7[ebp]
  003b7	c1 fa 05	 sar	 edx, 5
  003ba	89 95 74 ff ff
	ff		 mov	 DWORD PTR _cu$7[ebp], edx
  003c0	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _cv$6[ebp]
  003c6	c1 f8 05	 sar	 eax, 5
  003c9	89 85 70 ff ff
	ff		 mov	 DWORD PTR _cv$6[ebp], eax
$LN22@convert_yu:

; 334  : 
; 335  :             dstC[0] = (Tout)cu;

  003cf	b9 01 00 00 00	 mov	 ecx, 1
  003d4	6b d1 00	 imul	 edx, ecx, 0
  003d7	8b 45 98	 mov	 eax, DWORD PTR _dstC$16[ebp]
  003da	8a 8d 74 ff ff
	ff		 mov	 cl, BYTE PTR _cu$7[ebp]
  003e0	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 336  :             dstC[1] = (Tout)cv;

  003e3	ba 01 00 00 00	 mov	 edx, 1
  003e8	c1 e2 00	 shl	 edx, 0
  003eb	8b 45 98	 mov	 eax, DWORD PTR _dstC$16[ebp]
  003ee	8a 8d 70 ff ff
	ff		 mov	 cl, BYTE PTR _cv$6[ebp]
  003f4	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 337  :         }

  003f7	e9 f6 fe ff ff	 jmp	 $LN11@convert_yu
$LN12@convert_yu:

; 338  :     }

  003fc	e9 90 fe ff ff	 jmp	 $LN8@convert_yu
$LN1@convert_yu:

; 339  : }

  00401	52		 push	 edx
  00402	8b cd		 mov	 ecx, ebp
  00404	50		 push	 eax
  00405	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN27@convert_yu
  0040b	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00410	58		 pop	 eax
  00411	5a		 pop	 edx
  00412	5f		 pop	 edi
  00413	5b		 pop	 ebx
  00414	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00417	33 cd		 xor	 ecx, ebp
  00419	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0041e	81 c4 ac 00 00
	00		 add	 esp, 172		; 000000acH
  00424	3b ec		 cmp	 ebp, esp
  00426	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0042b	8b e5		 mov	 esp, ebp
  0042d	5d		 pop	 ebp
  0042e	c3		 ret	 0
  0042f	90		 npad	 1
$LN27@convert_yu:
  00430	01 00 00 00	 DD	 1
  00434	00 00 00 00	 DD	 $LN26@convert_yu
$LN26@convert_yu:
  00438	d4 ff ff ff	 DD	 -44			; ffffffd4H
  0043c	0c 00 00 00	 DD	 12			; 0000000cH
  00440	00 00 00 00	 DD	 $LN25@convert_yu
$LN25@convert_yu:
  00444	79		 DB	 121			; 00000079H
  00445	5f		 DB	 95			; 0000005fH
  00446	72		 DB	 114			; 00000072H
  00447	61		 DB	 97			; 00000061H
  00448	6e		 DB	 110			; 0000006eH
  00449	67		 DB	 103			; 00000067H
  0044a	65		 DB	 101			; 00000065H
  0044b	00		 DB	 0
??$convert_yuv444_to_nv12_p_c@G$0M@E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_to_nv12_p_c<unsigned short,12,unsigned char,8,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuv444_12_to_nv12_p@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_12_to_nv12_p

; 440  : static void convert_yuv444_12_to_nv12_p(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 441  :     convert_yuv444_to_nv12_p_c<uint16_t, 12, uint8_t, 8, false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yuv444_to_nv12_p_c@G$0M@E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_to_nv12_p_c<unsigned short,12,unsigned char,8,0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 442  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yuv444_12_to_nv12_p@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_12_to_nv12_p
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
$T1 = -200						; size = 4
$T2 = -196						; size = 4
$T3 = -192						; size = 4
$T4 = -188						; size = 4
$T5 = -184						; size = 12
_cv_y1$6 = -172						; size = 4
_cv_y0$7 = -168						; size = 4
_cu_y1$8 = -164						; size = 4
_cu_y0$9 = -160						; size = 4
_cy3v$10 = -156						; size = 4
_cy3u$11 = -152						; size = 4
_cy2v$12 = -148						; size = 4
_cy2u$13 = -144						; size = 4
_cy1v$14 = -140						; size = 4
_cy1u$15 = -136						; size = 4
_cy0v$16 = -132						; size = 4
_cy0u$17 = -128						; size = 4
_x$18 = -124						; size = 4
_x_fin$19 = -120					; size = 4
_srcV$20 = -116						; size = 4
_srcU$21 = -112						; size = 4
_dstC$22 = -108						; size = 4
_y$23 = -104						; size = 4
_uv_fin$ = -100						; size = 4
_dstLine$ = -96						; size = 4
_srcVLine$ = -92					; size = 4
_srcULine$ = -88					; size = 4
_src_uv_pitch$ = -84					; size = 4
_x$24 = -80						; size = 4
_y$25 = -76						; size = 4
_y_width$26 = -72					; size = 4
_dstLine$27 = -68					; size = 4
_srcYLine$28 = -64					; size = 4
$T29 = -60						; size = 12
_y_range$ = -44						; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yuv444_to_nv12_i_c@G$0O@E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_to_nv12_i_c<unsigned short,14,unsigned char,8,0>

; 342  : static void __forceinline convert_yuv444_to_nv12_i_c(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  00009	53		 push	 ebx
  0000a	57		 push	 edi
  0000b	8d bd 38 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-200]
  00011	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 343  :     static_assert((sizeof(Tin)  == 1 && in_bit_depth  == 8) || (sizeof(Tin)  == 2 && 8 < in_bit_depth  && in_bit_depth  <= 16), "invalid input bit depth.");
; 344  :     static_assert((sizeof(Tout) == 1 && out_bit_depth == 8) || (sizeof(Tout) == 2 && 8 < out_bit_depth && out_bit_depth <= 16), "invalid output bit depth.");
; 345  :     const int crop_left   = crop[0];

  00027	b8 04 00 00 00	 mov	 eax, 4
  0002c	6b c8 00	 imul	 ecx, eax, 0
  0002f	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00032	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00035	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 346  :     const int crop_up     = crop[1];

  00038	b9 04 00 00 00	 mov	 ecx, 4
  0003d	c1 e1 00	 shl	 ecx, 0
  00040	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00043	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00046	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 347  :     const int crop_right  = crop[2];

  00049	b9 04 00 00 00	 mov	 ecx, 4
  0004e	d1 e1		 shl	 ecx, 1
  00050	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00053	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00056	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 348  :     const int crop_bottom = crop[3];

  00059	b9 04 00 00 00	 mov	 ecx, 4
  0005e	6b d1 03	 imul	 edx, ecx, 3
  00061	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00064	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00067	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 349  :     const int src_y_pitch = src_y_pitch_byte / sizeof(Tin);

  0006a	8b 55 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebp]
  0006d	d1 ea		 shr	 edx, 1
  0006f	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 350  :     const int dst_y_pitch = dst_y_pitch_byte / sizeof(Tout);

  00072	8b 45 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  00075	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 351  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00078	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0007b	51		 push	 ecx
  0007c	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0007f	52		 push	 edx
  00080	8b 45 20	 mov	 eax, DWORD PTR _height$[ebp]
  00083	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  00086	50		 push	 eax
  00087	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  0008a	51		 push	 ecx
  0008b	8d 95 48 ff ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  00091	52		 push	 edx
  00092	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00097	83 c4 14	 add	 esp, 20			; 00000014H
  0009a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009c	89 4d c4	 mov	 DWORD PTR $T29[ebp], ecx
  0009f	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a2	89 55 c8	 mov	 DWORD PTR $T29[ebp+4], edx
  000a5	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000a8	89 45 cc	 mov	 DWORD PTR $T29[ebp+8], eax
  000ab	8b 4d c4	 mov	 ecx, DWORD PTR $T29[ebp]
  000ae	89 4d d4	 mov	 DWORD PTR _y_range$[ebp], ecx
  000b1	8b 55 c8	 mov	 edx, DWORD PTR $T29[ebp+4]
  000b4	89 55 d8	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000b7	8b 45 cc	 mov	 eax, DWORD PTR $T29[ebp+8]
  000ba	89 45 dc	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 352  :     //Y
; 353  :     if (!uv_only) {

  000bd	b9 01 00 00 00	 mov	 ecx, 1
  000c2	85 c9		 test	 ecx, ecx
  000c4	0f 84 61 01 00
	00		 je	 $LN14@convert_yu

; 354  :         Tin *srcYLine = (Tin *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000ca	ba 04 00 00 00	 mov	 edx, 4
  000cf	6b c2 00	 imul	 eax, edx, 0
  000d2	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  000d5	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  000d9	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  000dc	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  000df	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  000e2	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  000e5	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  000e8	89 45 c0	 mov	 DWORD PTR _srcYLine$28[ebp], eax

; 355  :         Tout *dstLine = (Tout *)dst[0] + dst_y_pitch * y_range.start_dst;

  000eb	b9 04 00 00 00	 mov	 ecx, 4
  000f0	6b d1 00	 imul	 edx, ecx, 0
  000f3	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  000f6	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  000fa	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  000fd	03 04 11	 add	 eax, DWORD PTR [ecx+edx]
  00100	89 45 bc	 mov	 DWORD PTR _dstLine$27[ebp], eax

; 356  :         const int y_width = width - crop_right - crop_left;

  00103	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00106	2b 55 f0	 sub	 edx, DWORD PTR _crop_right$[ebp]
  00109	2b 55 f8	 sub	 edx, DWORD PTR _crop_left$[ebp]
  0010c	89 55 b8	 mov	 DWORD PTR _y_width$26[ebp], edx

; 357  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  0010f	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _y$25[ebp], 0
  00116	eb 1e		 jmp	 SHORT $LN4@convert_yu
$LN2@convert_yu:
  00118	8b 45 b4	 mov	 eax, DWORD PTR _y$25[ebp]
  0011b	83 c0 01	 add	 eax, 1
  0011e	89 45 b4	 mov	 DWORD PTR _y$25[ebp], eax
  00121	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  00124	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$28[ebp]
  00127	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  0012a	89 45 c0	 mov	 DWORD PTR _srcYLine$28[ebp], eax
  0012d	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$27[ebp]
  00130	03 4d e4	 add	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  00133	89 4d bc	 mov	 DWORD PTR _dstLine$27[ebp], ecx
$LN4@convert_yu:
  00136	8b 55 b4	 mov	 edx, DWORD PTR _y$25[ebp]
  00139	3b 55 dc	 cmp	 edx, DWORD PTR _y_range$[ebp+8]
  0013c	0f 8d e9 00 00
	00		 jge	 $LN14@convert_yu

; 358  :             if (in_bit_depth == out_bit_depth && sizeof(Tin) == sizeof(Tout)) {

  00142	33 c0		 xor	 eax, eax
  00144	74 1b		 je	 SHORT $LN15@convert_yu

; 359  :                 memcpy(dstLine, srcYLine, y_width * sizeof(Tin));

  00146	8b 4d b8	 mov	 ecx, DWORD PTR _y_width$26[ebp]
  00149	d1 e1		 shl	 ecx, 1
  0014b	51		 push	 ecx
  0014c	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$28[ebp]
  0014f	52		 push	 edx
  00150	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$27[ebp]
  00153	50		 push	 eax
  00154	e8 00 00 00 00	 call	 _memcpy
  00159	83 c4 0c	 add	 esp, 12			; 0000000cH

; 360  :             } else {

  0015c	e9 c5 00 00 00	 jmp	 $LN16@convert_yu
$LN15@convert_yu:

; 361  :                 for (int x = 0; x < y_width; x++) {

  00161	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _x$24[ebp], 0
  00168	eb 09		 jmp	 SHORT $LN7@convert_yu
$LN5@convert_yu:
  0016a	8b 4d b0	 mov	 ecx, DWORD PTR _x$24[ebp]
  0016d	83 c1 01	 add	 ecx, 1
  00170	89 4d b0	 mov	 DWORD PTR _x$24[ebp], ecx
$LN7@convert_yu:
  00173	8b 55 b0	 mov	 edx, DWORD PTR _x$24[ebp]
  00176	3b 55 b8	 cmp	 edx, DWORD PTR _y_width$26[ebp]
  00179	0f 8d a7 00 00
	00		 jge	 $LN16@convert_yu

; 362  :                     if (out_bit_depth > in_bit_depth) {

  0017f	33 c0		 xor	 eax, eax
  00181	74 42		 je	 SHORT $LN17@convert_yu

; 363  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) << std::max(out_bit_depth - in_bit_depth, 0));

  00183	c7 85 44 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], 0
  0018d	c7 85 40 ff ff
	ff fa ff ff ff	 mov	 DWORD PTR $T3[ebp], -6	; fffffffaH
  00197	8b 4d b0	 mov	 ecx, DWORD PTR _x$24[ebp]
  0019a	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$28[ebp]
  0019d	0f b7 1c 4a	 movzx	 ebx, WORD PTR [edx+ecx*2]
  001a1	8d 85 44 ff ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  001a7	50		 push	 eax
  001a8	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  001ae	51		 push	 ecx
  001af	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  001b4	83 c4 08	 add	 esp, 8
  001b7	8b 08		 mov	 ecx, DWORD PTR [eax]
  001b9	d3 e3		 shl	 ebx, cl
  001bb	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$27[ebp]
  001be	03 55 b0	 add	 edx, DWORD PTR _x$24[ebp]
  001c1	88 1a		 mov	 BYTE PTR [edx], bl
  001c3	eb 5c		 jmp	 SHORT $LN18@convert_yu
$LN17@convert_yu:

; 364  :                     } else if (out_bit_depth < in_bit_depth) {

  001c5	b8 01 00 00 00	 mov	 eax, 1
  001ca	85 c0		 test	 eax, eax
  001cc	74 42		 je	 SHORT $LN19@convert_yu

; 365  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) >> std::max(in_bit_depth - out_bit_depth, 0));

  001ce	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], 0
  001d8	c7 85 38 ff ff
	ff 06 00 00 00	 mov	 DWORD PTR $T1[ebp], 6
  001e2	8b 4d b0	 mov	 ecx, DWORD PTR _x$24[ebp]
  001e5	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$28[ebp]
  001e8	0f b7 1c 4a	 movzx	 ebx, WORD PTR [edx+ecx*2]
  001ec	8d 85 3c ff ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  001f2	50		 push	 eax
  001f3	8d 8d 38 ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  001f9	51		 push	 ecx
  001fa	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  001ff	83 c4 08	 add	 esp, 8
  00202	8b 08		 mov	 ecx, DWORD PTR [eax]
  00204	d3 fb		 sar	 ebx, cl
  00206	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$27[ebp]
  00209	03 55 b0	 add	 edx, DWORD PTR _x$24[ebp]
  0020c	88 1a		 mov	 BYTE PTR [edx], bl

; 366  :                     } else {

  0020e	eb 11		 jmp	 SHORT $LN18@convert_yu
$LN19@convert_yu:

; 367  :                         dstLine[x] = (Tout)srcYLine[x];

  00210	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$27[ebp]
  00213	03 45 b0	 add	 eax, DWORD PTR _x$24[ebp]
  00216	8b 4d b0	 mov	 ecx, DWORD PTR _x$24[ebp]
  00219	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$28[ebp]
  0021c	8a 0c 4a	 mov	 cl, BYTE PTR [edx+ecx*2]
  0021f	88 08		 mov	 BYTE PTR [eax], cl
$LN18@convert_yu:

; 368  :                     }
; 369  :                 }

  00221	e9 44 ff ff ff	 jmp	 $LN5@convert_yu
$LN16@convert_yu:

; 370  :             }
; 371  :         }

  00226	e9 ed fe ff ff	 jmp	 $LN2@convert_yu
$LN14@convert_yu:

; 372  :     }
; 373  :     //UV
; 374  :     const int src_uv_pitch = src_uv_pitch_byte / sizeof(Tin);

  0022b	8b 55 18	 mov	 edx, DWORD PTR _src_uv_pitch_byte$[ebp]
  0022e	d1 ea		 shr	 edx, 1
  00230	89 55 ac	 mov	 DWORD PTR _src_uv_pitch$[ebp], edx

; 375  :     Tin *srcULine = (Tin *)src[1] + ((src_uv_pitch * y_range.start_src) + crop_left);

  00233	b8 04 00 00 00	 mov	 eax, 4
  00238	c1 e0 00	 shl	 eax, 0
  0023b	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  0023e	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  00242	03 4d f8	 add	 ecx, DWORD PTR _crop_left$[ebp]
  00245	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  00248	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  0024b	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  0024e	89 4d a8	 mov	 DWORD PTR _srcULine$[ebp], ecx

; 376  :     Tin *srcVLine = (Tin *)src[2] + ((src_uv_pitch * y_range.start_src) + crop_left);

  00251	ba 04 00 00 00	 mov	 edx, 4
  00256	d1 e2		 shl	 edx, 1
  00258	8b 45 ac	 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  0025b	0f af 45 d4	 imul	 eax, DWORD PTR _y_range$[ebp]
  0025f	03 45 f8	 add	 eax, DWORD PTR _crop_left$[ebp]
  00262	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  00265	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  00268	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  0026b	89 45 a4	 mov	 DWORD PTR _srcVLine$[ebp], eax

; 377  :     Tout *dstLine = (Tout *)dst[1] + (dst_y_pitch >> 1) * y_range.start_dst;

  0026e	b9 04 00 00 00	 mov	 ecx, 4
  00273	c1 e1 00	 shl	 ecx, 0
  00276	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  00279	d1 fa		 sar	 edx, 1
  0027b	0f af 55 d8	 imul	 edx, DWORD PTR _y_range$[ebp+4]
  0027f	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
  00282	03 14 08	 add	 edx, DWORD PTR [eax+ecx]
  00285	89 55 a0	 mov	 DWORD PTR _dstLine$[ebp], edx

; 378  :     const int uv_fin = height - crop_bottom - crop_up;

  00288	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  0028b	2b 4d ec	 sub	 ecx, DWORD PTR _crop_bottom$[ebp]
  0028e	2b 4d f4	 sub	 ecx, DWORD PTR _crop_up$[ebp]
  00291	89 4d 9c	 mov	 DWORD PTR _uv_fin$[ebp], ecx

; 379  :     for (int y = 0; y < y_range.len; y += 4, srcULine += src_uv_pitch * 4, srcVLine += src_uv_pitch * 4, dstLine += dst_y_pitch * 2) {

  00294	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _y$23[ebp], 0
  0029b	eb 33		 jmp	 SHORT $LN10@convert_yu
$LN8@convert_yu:
  0029d	8b 55 98	 mov	 edx, DWORD PTR _y$23[ebp]
  002a0	83 c2 04	 add	 edx, 4
  002a3	89 55 98	 mov	 DWORD PTR _y$23[ebp], edx
  002a6	8b 45 ac	 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  002a9	c1 e0 02	 shl	 eax, 2
  002ac	8b 4d a8	 mov	 ecx, DWORD PTR _srcULine$[ebp]
  002af	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  002b2	89 55 a8	 mov	 DWORD PTR _srcULine$[ebp], edx
  002b5	8b 45 ac	 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  002b8	c1 e0 02	 shl	 eax, 2
  002bb	8b 4d a4	 mov	 ecx, DWORD PTR _srcVLine$[ebp]
  002be	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  002c1	89 55 a4	 mov	 DWORD PTR _srcVLine$[ebp], edx
  002c4	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  002c7	8b 4d a0	 mov	 ecx, DWORD PTR _dstLine$[ebp]
  002ca	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  002cd	89 55 a0	 mov	 DWORD PTR _dstLine$[ebp], edx
$LN10@convert_yu:
  002d0	8b 45 98	 mov	 eax, DWORD PTR _y$23[ebp]
  002d3	3b 45 dc	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  002d6	0f 8d 04 02 00
	00		 jge	 $LN1@convert_yu

; 380  :         Tout *dstC = dstLine;

  002dc	8b 4d a0	 mov	 ecx, DWORD PTR _dstLine$[ebp]
  002df	89 4d 94	 mov	 DWORD PTR _dstC$22[ebp], ecx

; 381  :         Tin *srcU = srcULine;

  002e2	8b 55 a8	 mov	 edx, DWORD PTR _srcULine$[ebp]
  002e5	89 55 90	 mov	 DWORD PTR _srcU$21[ebp], edx

; 382  :         Tin *srcV = srcVLine;

  002e8	8b 45 a4	 mov	 eax, DWORD PTR _srcVLine$[ebp]
  002eb	89 45 8c	 mov	 DWORD PTR _srcV$20[ebp], eax

; 383  :         const int x_fin = width - crop_right - crop_left;

  002ee	8b 4d 10	 mov	 ecx, DWORD PTR _width$[ebp]
  002f1	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  002f4	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  002f7	89 4d 88	 mov	 DWORD PTR _x_fin$19[ebp], ecx

; 384  :         for (int x = 0; x < x_fin; x += 2, dstC += 2, srcU += 2, srcV += 2) {

  002fa	c7 45 84 00 00
	00 00		 mov	 DWORD PTR _x$18[ebp], 0
  00301	eb 24		 jmp	 SHORT $LN13@convert_yu
$LN11@convert_yu:
  00303	8b 55 84	 mov	 edx, DWORD PTR _x$18[ebp]
  00306	83 c2 02	 add	 edx, 2
  00309	89 55 84	 mov	 DWORD PTR _x$18[ebp], edx
  0030c	8b 45 94	 mov	 eax, DWORD PTR _dstC$22[ebp]
  0030f	83 c0 02	 add	 eax, 2
  00312	89 45 94	 mov	 DWORD PTR _dstC$22[ebp], eax
  00315	8b 4d 90	 mov	 ecx, DWORD PTR _srcU$21[ebp]
  00318	83 c1 04	 add	 ecx, 4
  0031b	89 4d 90	 mov	 DWORD PTR _srcU$21[ebp], ecx
  0031e	8b 55 8c	 mov	 edx, DWORD PTR _srcV$20[ebp]
  00321	83 c2 04	 add	 edx, 4
  00324	89 55 8c	 mov	 DWORD PTR _srcV$20[ebp], edx
$LN13@convert_yu:
  00327	8b 45 84	 mov	 eax, DWORD PTR _x$18[ebp]
  0032a	3b 45 88	 cmp	 eax, DWORD PTR _x_fin$19[ebp]
  0032d	0f 8d a8 01 00
	00		 jge	 $LN12@convert_yu

; 385  :             int cy0u = srcU[0*src_uv_pitch + 0];

  00333	6b 4d ac 00	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 0
  00337	8b 55 90	 mov	 edx, DWORD PTR _srcU$21[ebp]
  0033a	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  0033e	89 45 80	 mov	 DWORD PTR _cy0u$17[ebp], eax

; 386  :             int cy0v = srcV[0*src_uv_pitch + 0];

  00341	6b 4d ac 00	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 0
  00345	8b 55 8c	 mov	 edx, DWORD PTR _srcV$20[ebp]
  00348	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  0034c	89 85 7c ff ff
	ff		 mov	 DWORD PTR _cy0v$16[ebp], eax

; 387  :             int cy1u = srcU[1*src_uv_pitch + 0];

  00352	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00355	8b 55 90	 mov	 edx, DWORD PTR _srcU$21[ebp]
  00358	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  0035c	89 85 78 ff ff
	ff		 mov	 DWORD PTR _cy1u$15[ebp], eax

; 388  :             int cy1v = srcV[1*src_uv_pitch + 0];

  00362	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00365	8b 55 8c	 mov	 edx, DWORD PTR _srcV$20[ebp]
  00368	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  0036c	89 85 74 ff ff
	ff		 mov	 DWORD PTR _cy1v$14[ebp], eax

; 389  :             int cy2u = srcU[2*src_uv_pitch + 0];

  00372	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00375	d1 e1		 shl	 ecx, 1
  00377	8b 55 90	 mov	 edx, DWORD PTR _srcU$21[ebp]
  0037a	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  0037e	89 85 70 ff ff
	ff		 mov	 DWORD PTR _cy2u$13[ebp], eax

; 390  :             int cy2v = srcV[2*src_uv_pitch + 0];

  00384	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00387	d1 e1		 shl	 ecx, 1
  00389	8b 55 8c	 mov	 edx, DWORD PTR _srcV$20[ebp]
  0038c	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00390	89 85 6c ff ff
	ff		 mov	 DWORD PTR _cy2v$12[ebp], eax

; 391  :             int cy3u = srcU[3*src_uv_pitch + 0];

  00396	6b 4d ac 03	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 3
  0039a	8b 55 90	 mov	 edx, DWORD PTR _srcU$21[ebp]
  0039d	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  003a1	89 85 68 ff ff
	ff		 mov	 DWORD PTR _cy3u$11[ebp], eax

; 392  :             int cy3v = srcV[3*src_uv_pitch + 0];

  003a7	6b 4d ac 03	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 3
  003ab	8b 55 8c	 mov	 edx, DWORD PTR _srcV$20[ebp]
  003ae	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  003b2	89 85 64 ff ff
	ff		 mov	 DWORD PTR _cy3v$10[ebp], eax

; 393  : 
; 394  :             int cu_y0 = cy0u * 3 + cy2u * 1 + 2;

  003b8	6b 4d 80 03	 imul	 ecx, DWORD PTR _cy0u$17[ebp], 3
  003bc	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR _cy2u$13[ebp]
  003c2	8d 44 11 02	 lea	 eax, DWORD PTR [ecx+edx+2]
  003c6	89 85 60 ff ff
	ff		 mov	 DWORD PTR _cu_y0$9[ebp], eax

; 395  :             int cu_y1 = cy1u * 1 + cy3u * 3 + 2;

  003cc	6b 8d 68 ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy3u$11[ebp], 3
  003d3	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _cy1u$15[ebp]
  003d9	8d 44 0a 02	 lea	 eax, DWORD PTR [edx+ecx+2]
  003dd	89 85 5c ff ff
	ff		 mov	 DWORD PTR _cu_y1$8[ebp], eax

; 396  :             int cv_y0 = cy0v * 3 + cy2v * 1 + 2;

  003e3	6b 8d 7c ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy0v$16[ebp], 3
  003ea	8b 95 6c ff ff
	ff		 mov	 edx, DWORD PTR _cy2v$12[ebp]
  003f0	8d 44 11 02	 lea	 eax, DWORD PTR [ecx+edx+2]
  003f4	89 85 58 ff ff
	ff		 mov	 DWORD PTR _cv_y0$7[ebp], eax

; 397  :             int cv_y1 = cy1v * 1 + cy3v * 3 + 2;

  003fa	6b 8d 64 ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy3v$10[ebp], 3
  00401	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _cy1v$14[ebp]
  00407	8d 44 0a 02	 lea	 eax, DWORD PTR [edx+ecx+2]
  0040b	89 85 54 ff ff
	ff		 mov	 DWORD PTR _cv_y1$6[ebp], eax

; 398  :             CHANGE_BIT_DEPTH_4(cu_y0, cu_y1, cv_y0, cv_y1, 2);

  00411	33 c9		 xor	 ecx, ecx
  00413	74 3e		 je	 SHORT $LN21@convert_yu
  00415	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _cu_y0$9[ebp]
  0041b	c1 e2 f8	 shl	 edx, -8			; fffffff8H
  0041e	89 95 60 ff ff
	ff		 mov	 DWORD PTR _cu_y0$9[ebp], edx
  00424	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _cu_y1$8[ebp]
  0042a	c1 e0 f8	 shl	 eax, -8			; fffffff8H
  0042d	89 85 5c ff ff
	ff		 mov	 DWORD PTR _cu_y1$8[ebp], eax
  00433	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _cv_y0$7[ebp]
  00439	c1 e1 f8	 shl	 ecx, -8			; fffffff8H
  0043c	89 8d 58 ff ff
	ff		 mov	 DWORD PTR _cv_y0$7[ebp], ecx
  00442	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR _cv_y1$6[ebp]
  00448	c1 e2 f8	 shl	 edx, -8			; fffffff8H
  0044b	89 95 54 ff ff
	ff		 mov	 DWORD PTR _cv_y1$6[ebp], edx
  00451	eb 45		 jmp	 SHORT $LN22@convert_yu
$LN21@convert_yu:
  00453	b8 01 00 00 00	 mov	 eax, 1
  00458	85 c0		 test	 eax, eax
  0045a	74 3c		 je	 SHORT $LN22@convert_yu
  0045c	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _cu_y0$9[ebp]
  00462	c1 f9 08	 sar	 ecx, 8
  00465	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _cu_y0$9[ebp], ecx
  0046b	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR _cu_y1$8[ebp]
  00471	c1 fa 08	 sar	 edx, 8
  00474	89 95 5c ff ff
	ff		 mov	 DWORD PTR _cu_y1$8[ebp], edx
  0047a	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _cv_y0$7[ebp]
  00480	c1 f8 08	 sar	 eax, 8
  00483	89 85 58 ff ff
	ff		 mov	 DWORD PTR _cv_y0$7[ebp], eax
  00489	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _cv_y1$6[ebp]
  0048f	c1 f9 08	 sar	 ecx, 8
  00492	89 8d 54 ff ff
	ff		 mov	 DWORD PTR _cv_y1$6[ebp], ecx
$LN22@convert_yu:

; 399  : 
; 400  :             dstC[0*dst_y_pitch + 0] = (Tout)cu_y0;

  00498	6b 55 e4 00	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 0
  0049c	8b 45 94	 mov	 eax, DWORD PTR _dstC$22[ebp]
  0049f	8a 8d 60 ff ff
	ff		 mov	 cl, BYTE PTR _cu_y0$9[ebp]
  004a5	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 401  :             dstC[0*dst_y_pitch + 1] = (Tout)cv_y0;

  004a8	6b 55 e4 00	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 0
  004ac	8b 45 94	 mov	 eax, DWORD PTR _dstC$22[ebp]
  004af	8a 8d 58 ff ff
	ff		 mov	 cl, BYTE PTR _cv_y0$7[ebp]
  004b5	88 4c 10 01	 mov	 BYTE PTR [eax+edx+1], cl

; 402  :             dstC[1*dst_y_pitch + 0] = (Tout)cu_y1;

  004b9	8b 55 94	 mov	 edx, DWORD PTR _dstC$22[ebp]
  004bc	03 55 e4	 add	 edx, DWORD PTR _dst_y_pitch$[ebp]
  004bf	8a 85 5c ff ff
	ff		 mov	 al, BYTE PTR _cu_y1$8[ebp]
  004c5	88 02		 mov	 BYTE PTR [edx], al

; 403  :             dstC[1*dst_y_pitch + 1] = (Tout)cv_y1;

  004c7	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$22[ebp]
  004ca	03 4d e4	 add	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  004cd	8a 95 54 ff ff
	ff		 mov	 dl, BYTE PTR _cv_y1$6[ebp]
  004d3	88 51 01	 mov	 BYTE PTR [ecx+1], dl

; 404  :         }

  004d6	e9 28 fe ff ff	 jmp	 $LN11@convert_yu
$LN12@convert_yu:

; 405  :     }

  004db	e9 bd fd ff ff	 jmp	 $LN8@convert_yu
$LN1@convert_yu:

; 406  : }

  004e0	52		 push	 edx
  004e1	8b cd		 mov	 ecx, ebp
  004e3	50		 push	 eax
  004e4	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN27@convert_yu
  004ea	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  004ef	58		 pop	 eax
  004f0	5a		 pop	 edx
  004f1	5f		 pop	 edi
  004f2	5b		 pop	 ebx
  004f3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004f6	33 cd		 xor	 ecx, ebp
  004f8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004fd	81 c4 c8 00 00
	00		 add	 esp, 200		; 000000c8H
  00503	3b ec		 cmp	 ebp, esp
  00505	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0050a	8b e5		 mov	 esp, ebp
  0050c	5d		 pop	 ebp
  0050d	c3		 ret	 0
  0050e	66 90		 npad	 2
$LN27@convert_yu:
  00510	01 00 00 00	 DD	 1
  00514	00 00 00 00	 DD	 $LN26@convert_yu
$LN26@convert_yu:
  00518	d4 ff ff ff	 DD	 -44			; ffffffd4H
  0051c	0c 00 00 00	 DD	 12			; 0000000cH
  00520	00 00 00 00	 DD	 $LN25@convert_yu
$LN25@convert_yu:
  00524	79		 DB	 121			; 00000079H
  00525	5f		 DB	 95			; 0000005fH
  00526	72		 DB	 114			; 00000072H
  00527	61		 DB	 97			; 00000061H
  00528	6e		 DB	 110			; 0000006eH
  00529	67		 DB	 103			; 00000067H
  0052a	65		 DB	 101			; 00000065H
  0052b	00		 DB	 0
??$convert_yuv444_to_nv12_i_c@G$0O@E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_to_nv12_i_c<unsigned short,14,unsigned char,8,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuv444_14_to_nv12_i@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_14_to_nv12_i

; 436  : static void convert_yuv444_14_to_nv12_i(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 437  :     convert_yuv444_to_nv12_i_c<uint16_t, 14, uint8_t, 8, false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yuv444_to_nv12_i_c@G$0O@E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_to_nv12_i_c<unsigned short,14,unsigned char,8,0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 438  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yuv444_14_to_nv12_i@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_14_to_nv12_i
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
$T1 = -172						; size = 4
$T2 = -168						; size = 4
$T3 = -164						; size = 4
$T4 = -160						; size = 4
$T5 = -156						; size = 12
_cv$6 = -144						; size = 4
_cu$7 = -140						; size = 4
_cy1v$8 = -136						; size = 4
_cy1u$9 = -132						; size = 4
_cy0v$10 = -128						; size = 4
_cy0u$11 = -124						; size = 4
_x$12 = -120						; size = 4
_x_fin$13 = -116					; size = 4
_srcV$14 = -112						; size = 4
_srcU$15 = -108						; size = 4
_dstC$16 = -104						; size = 4
_y$17 = -100						; size = 4
_dstLine$ = -96						; size = 4
_srcVLine$ = -92					; size = 4
_srcULine$ = -88					; size = 4
_src_uv_pitch$ = -84					; size = 4
_x$18 = -80						; size = 4
_y$19 = -76						; size = 4
_y_width$20 = -72					; size = 4
_dstLine$21 = -68					; size = 4
_srcYLine$22 = -64					; size = 4
$T23 = -60						; size = 12
_y_range$ = -44						; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yuv444_to_nv12_p_c@G$0O@E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_to_nv12_p_c<unsigned short,14,unsigned char,8,0>

; 284  : static void __forceinline convert_yuv444_to_nv12_p_c(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec ac 00 00
	00		 sub	 esp, 172		; 000000acH
  00009	53		 push	 ebx
  0000a	57		 push	 edi
  0000b	8d bd 54 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-172]
  00011	b9 2b 00 00 00	 mov	 ecx, 43			; 0000002bH
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 285  :     static_assert((sizeof(Tin)  == 1 && in_bit_depth  == 8) || (sizeof(Tin)  == 2 && 8 < in_bit_depth  && in_bit_depth  <= 16), "invalid input bit depth.");
; 286  :     static_assert((sizeof(Tout) == 1 && out_bit_depth == 8) || (sizeof(Tout) == 2 && 8 < out_bit_depth && out_bit_depth <= 16), "invalid output bit depth.");
; 287  :     const int crop_left   = crop[0];

  00027	b8 04 00 00 00	 mov	 eax, 4
  0002c	6b c8 00	 imul	 ecx, eax, 0
  0002f	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00032	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00035	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 288  :     const int crop_up     = crop[1];

  00038	b9 04 00 00 00	 mov	 ecx, 4
  0003d	c1 e1 00	 shl	 ecx, 0
  00040	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00043	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00046	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 289  :     const int crop_right  = crop[2];

  00049	b9 04 00 00 00	 mov	 ecx, 4
  0004e	d1 e1		 shl	 ecx, 1
  00050	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00053	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00056	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 290  :     const int crop_bottom = crop[3];

  00059	b9 04 00 00 00	 mov	 ecx, 4
  0005e	6b d1 03	 imul	 edx, ecx, 3
  00061	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00064	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00067	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 291  :     const int src_y_pitch = src_y_pitch_byte / sizeof(Tin);

  0006a	8b 55 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebp]
  0006d	d1 ea		 shr	 edx, 1
  0006f	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 292  :     const int dst_y_pitch = dst_y_pitch_byte / sizeof(Tout);

  00072	8b 45 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  00075	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 293  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00078	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0007b	51		 push	 ecx
  0007c	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0007f	52		 push	 edx
  00080	8b 45 20	 mov	 eax, DWORD PTR _height$[ebp]
  00083	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  00086	50		 push	 eax
  00087	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  0008a	51		 push	 ecx
  0008b	8d 95 64 ff ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  00091	52		 push	 edx
  00092	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00097	83 c4 14	 add	 esp, 20			; 00000014H
  0009a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009c	89 4d c4	 mov	 DWORD PTR $T23[ebp], ecx
  0009f	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a2	89 55 c8	 mov	 DWORD PTR $T23[ebp+4], edx
  000a5	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000a8	89 45 cc	 mov	 DWORD PTR $T23[ebp+8], eax
  000ab	8b 4d c4	 mov	 ecx, DWORD PTR $T23[ebp]
  000ae	89 4d d4	 mov	 DWORD PTR _y_range$[ebp], ecx
  000b1	8b 55 c8	 mov	 edx, DWORD PTR $T23[ebp+4]
  000b4	89 55 d8	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000b7	8b 45 cc	 mov	 eax, DWORD PTR $T23[ebp+8]
  000ba	89 45 dc	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 294  :     //Y
; 295  :     if (!uv_only) {

  000bd	b9 01 00 00 00	 mov	 ecx, 1
  000c2	85 c9		 test	 ecx, ecx
  000c4	0f 84 61 01 00
	00		 je	 $LN14@convert_yu

; 296  :         Tin *srcYLine = (Tin *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000ca	ba 04 00 00 00	 mov	 edx, 4
  000cf	6b c2 00	 imul	 eax, edx, 0
  000d2	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  000d5	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  000d9	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  000dc	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  000df	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  000e2	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  000e5	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  000e8	89 45 c0	 mov	 DWORD PTR _srcYLine$22[ebp], eax

; 297  :         Tout *dstLine = (Tout *)dst[0] + dst_y_pitch * y_range.start_dst;

  000eb	b9 04 00 00 00	 mov	 ecx, 4
  000f0	6b d1 00	 imul	 edx, ecx, 0
  000f3	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  000f6	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  000fa	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  000fd	03 04 11	 add	 eax, DWORD PTR [ecx+edx]
  00100	89 45 bc	 mov	 DWORD PTR _dstLine$21[ebp], eax

; 298  :         const int y_width = width - crop_right - crop_left;

  00103	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00106	2b 55 f0	 sub	 edx, DWORD PTR _crop_right$[ebp]
  00109	2b 55 f8	 sub	 edx, DWORD PTR _crop_left$[ebp]
  0010c	89 55 b8	 mov	 DWORD PTR _y_width$20[ebp], edx

; 299  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  0010f	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _y$19[ebp], 0
  00116	eb 1e		 jmp	 SHORT $LN4@convert_yu
$LN2@convert_yu:
  00118	8b 45 b4	 mov	 eax, DWORD PTR _y$19[ebp]
  0011b	83 c0 01	 add	 eax, 1
  0011e	89 45 b4	 mov	 DWORD PTR _y$19[ebp], eax
  00121	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  00124	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$22[ebp]
  00127	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  0012a	89 45 c0	 mov	 DWORD PTR _srcYLine$22[ebp], eax
  0012d	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$21[ebp]
  00130	03 4d e4	 add	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  00133	89 4d bc	 mov	 DWORD PTR _dstLine$21[ebp], ecx
$LN4@convert_yu:
  00136	8b 55 b4	 mov	 edx, DWORD PTR _y$19[ebp]
  00139	3b 55 dc	 cmp	 edx, DWORD PTR _y_range$[ebp+8]
  0013c	0f 8d e9 00 00
	00		 jge	 $LN14@convert_yu

; 300  :             if (in_bit_depth == out_bit_depth && sizeof(Tin) == sizeof(Tout)) {

  00142	33 c0		 xor	 eax, eax
  00144	74 1b		 je	 SHORT $LN15@convert_yu

; 301  :                 memcpy(dstLine, srcYLine, y_width * sizeof(Tin));

  00146	8b 4d b8	 mov	 ecx, DWORD PTR _y_width$20[ebp]
  00149	d1 e1		 shl	 ecx, 1
  0014b	51		 push	 ecx
  0014c	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$22[ebp]
  0014f	52		 push	 edx
  00150	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$21[ebp]
  00153	50		 push	 eax
  00154	e8 00 00 00 00	 call	 _memcpy
  00159	83 c4 0c	 add	 esp, 12			; 0000000cH

; 302  :             } else {

  0015c	e9 c5 00 00 00	 jmp	 $LN16@convert_yu
$LN15@convert_yu:

; 303  :                 for (int x = 0; x < y_width; x++) {

  00161	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _x$18[ebp], 0
  00168	eb 09		 jmp	 SHORT $LN7@convert_yu
$LN5@convert_yu:
  0016a	8b 4d b0	 mov	 ecx, DWORD PTR _x$18[ebp]
  0016d	83 c1 01	 add	 ecx, 1
  00170	89 4d b0	 mov	 DWORD PTR _x$18[ebp], ecx
$LN7@convert_yu:
  00173	8b 55 b0	 mov	 edx, DWORD PTR _x$18[ebp]
  00176	3b 55 b8	 cmp	 edx, DWORD PTR _y_width$20[ebp]
  00179	0f 8d a7 00 00
	00		 jge	 $LN16@convert_yu

; 304  :                     if (out_bit_depth > in_bit_depth) {

  0017f	33 c0		 xor	 eax, eax
  00181	74 42		 je	 SHORT $LN17@convert_yu

; 305  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) << std::max(out_bit_depth - in_bit_depth, 0));

  00183	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], 0
  0018d	c7 85 5c ff ff
	ff fa ff ff ff	 mov	 DWORD PTR $T3[ebp], -6	; fffffffaH
  00197	8b 4d b0	 mov	 ecx, DWORD PTR _x$18[ebp]
  0019a	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$22[ebp]
  0019d	0f b7 1c 4a	 movzx	 ebx, WORD PTR [edx+ecx*2]
  001a1	8d 85 60 ff ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  001a7	50		 push	 eax
  001a8	8d 8d 5c ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  001ae	51		 push	 ecx
  001af	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  001b4	83 c4 08	 add	 esp, 8
  001b7	8b 08		 mov	 ecx, DWORD PTR [eax]
  001b9	d3 e3		 shl	 ebx, cl
  001bb	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$21[ebp]
  001be	03 55 b0	 add	 edx, DWORD PTR _x$18[ebp]
  001c1	88 1a		 mov	 BYTE PTR [edx], bl
  001c3	eb 5c		 jmp	 SHORT $LN18@convert_yu
$LN17@convert_yu:

; 306  :                     } else if (out_bit_depth < in_bit_depth) {

  001c5	b8 01 00 00 00	 mov	 eax, 1
  001ca	85 c0		 test	 eax, eax
  001cc	74 42		 je	 SHORT $LN19@convert_yu

; 307  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) >> std::max(in_bit_depth - out_bit_depth, 0));

  001ce	c7 85 58 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], 0
  001d8	c7 85 54 ff ff
	ff 06 00 00 00	 mov	 DWORD PTR $T1[ebp], 6
  001e2	8b 4d b0	 mov	 ecx, DWORD PTR _x$18[ebp]
  001e5	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$22[ebp]
  001e8	0f b7 1c 4a	 movzx	 ebx, WORD PTR [edx+ecx*2]
  001ec	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  001f2	50		 push	 eax
  001f3	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  001f9	51		 push	 ecx
  001fa	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  001ff	83 c4 08	 add	 esp, 8
  00202	8b 08		 mov	 ecx, DWORD PTR [eax]
  00204	d3 fb		 sar	 ebx, cl
  00206	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$21[ebp]
  00209	03 55 b0	 add	 edx, DWORD PTR _x$18[ebp]
  0020c	88 1a		 mov	 BYTE PTR [edx], bl

; 308  :                     } else {

  0020e	eb 11		 jmp	 SHORT $LN18@convert_yu
$LN19@convert_yu:

; 309  :                         dstLine[x] = (Tout)srcYLine[x];

  00210	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$21[ebp]
  00213	03 45 b0	 add	 eax, DWORD PTR _x$18[ebp]
  00216	8b 4d b0	 mov	 ecx, DWORD PTR _x$18[ebp]
  00219	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$22[ebp]
  0021c	8a 0c 4a	 mov	 cl, BYTE PTR [edx+ecx*2]
  0021f	88 08		 mov	 BYTE PTR [eax], cl
$LN18@convert_yu:

; 310  :                     }
; 311  :                 }

  00221	e9 44 ff ff ff	 jmp	 $LN5@convert_yu
$LN16@convert_yu:

; 312  :             }
; 313  :         }

  00226	e9 ed fe ff ff	 jmp	 $LN2@convert_yu
$LN14@convert_yu:

; 314  :     }
; 315  :     //UV
; 316  :     const int src_uv_pitch = src_uv_pitch_byte / sizeof(Tin);

  0022b	8b 55 18	 mov	 edx, DWORD PTR _src_uv_pitch_byte$[ebp]
  0022e	d1 ea		 shr	 edx, 1
  00230	89 55 ac	 mov	 DWORD PTR _src_uv_pitch$[ebp], edx

; 317  :     Tin *srcULine = (Tin *)src[1] + ((src_uv_pitch * y_range.start_src) + crop_left);

  00233	b8 04 00 00 00	 mov	 eax, 4
  00238	c1 e0 00	 shl	 eax, 0
  0023b	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  0023e	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  00242	03 4d f8	 add	 ecx, DWORD PTR _crop_left$[ebp]
  00245	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  00248	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  0024b	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  0024e	89 4d a8	 mov	 DWORD PTR _srcULine$[ebp], ecx

; 318  :     Tin *srcVLine = (Tin *)src[2] + ((src_uv_pitch * y_range.start_src) + crop_left);

  00251	ba 04 00 00 00	 mov	 edx, 4
  00256	d1 e2		 shl	 edx, 1
  00258	8b 45 ac	 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  0025b	0f af 45 d4	 imul	 eax, DWORD PTR _y_range$[ebp]
  0025f	03 45 f8	 add	 eax, DWORD PTR _crop_left$[ebp]
  00262	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  00265	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  00268	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  0026b	89 45 a4	 mov	 DWORD PTR _srcVLine$[ebp], eax

; 319  :     Tout *dstLine = (Tout *)dst[1] + (dst_y_pitch >> 1) * y_range.start_dst;

  0026e	b9 04 00 00 00	 mov	 ecx, 4
  00273	c1 e1 00	 shl	 ecx, 0
  00276	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  00279	d1 fa		 sar	 edx, 1
  0027b	0f af 55 d8	 imul	 edx, DWORD PTR _y_range$[ebp+4]
  0027f	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
  00282	03 14 08	 add	 edx, DWORD PTR [eax+ecx]
  00285	89 55 a0	 mov	 DWORD PTR _dstLine$[ebp], edx

; 320  :     for (int y = 0; y < y_range.len; y += 2, srcULine += src_uv_pitch * 2, srcVLine += src_uv_pitch * 2, dstLine += dst_y_pitch) {

  00288	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR _y$17[ebp], 0
  0028f	eb 2e		 jmp	 SHORT $LN10@convert_yu
$LN8@convert_yu:
  00291	8b 4d 9c	 mov	 ecx, DWORD PTR _y$17[ebp]
  00294	83 c1 02	 add	 ecx, 2
  00297	89 4d 9c	 mov	 DWORD PTR _y$17[ebp], ecx
  0029a	8b 55 ac	 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  0029d	d1 e2		 shl	 edx, 1
  0029f	8b 45 a8	 mov	 eax, DWORD PTR _srcULine$[ebp]
  002a2	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  002a5	89 4d a8	 mov	 DWORD PTR _srcULine$[ebp], ecx
  002a8	8b 55 ac	 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  002ab	d1 e2		 shl	 edx, 1
  002ad	8b 45 a4	 mov	 eax, DWORD PTR _srcVLine$[ebp]
  002b0	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  002b3	89 4d a4	 mov	 DWORD PTR _srcVLine$[ebp], ecx
  002b6	8b 55 a0	 mov	 edx, DWORD PTR _dstLine$[ebp]
  002b9	03 55 e4	 add	 edx, DWORD PTR _dst_y_pitch$[ebp]
  002bc	89 55 a0	 mov	 DWORD PTR _dstLine$[ebp], edx
$LN10@convert_yu:
  002bf	8b 45 9c	 mov	 eax, DWORD PTR _y$17[ebp]
  002c2	3b 45 dc	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  002c5	0f 8d 36 01 00
	00		 jge	 $LN1@convert_yu

; 321  :         Tout *dstC = dstLine;

  002cb	8b 4d a0	 mov	 ecx, DWORD PTR _dstLine$[ebp]
  002ce	89 4d 98	 mov	 DWORD PTR _dstC$16[ebp], ecx

; 322  :         Tin *srcU = srcULine;

  002d1	8b 55 a8	 mov	 edx, DWORD PTR _srcULine$[ebp]
  002d4	89 55 94	 mov	 DWORD PTR _srcU$15[ebp], edx

; 323  :         Tin *srcV = srcVLine;

  002d7	8b 45 a4	 mov	 eax, DWORD PTR _srcVLine$[ebp]
  002da	89 45 90	 mov	 DWORD PTR _srcV$14[ebp], eax

; 324  :         const int x_fin = width - crop_right - crop_left;

  002dd	8b 4d 10	 mov	 ecx, DWORD PTR _width$[ebp]
  002e0	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  002e3	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  002e6	89 4d 8c	 mov	 DWORD PTR _x_fin$13[ebp], ecx

; 325  :         for (int x = 0; x < x_fin; x += 2, dstC += 2, srcU += 2, srcV += 2) {

  002e9	c7 45 88 00 00
	00 00		 mov	 DWORD PTR _x$12[ebp], 0
  002f0	eb 24		 jmp	 SHORT $LN13@convert_yu
$LN11@convert_yu:
  002f2	8b 55 88	 mov	 edx, DWORD PTR _x$12[ebp]
  002f5	83 c2 02	 add	 edx, 2
  002f8	89 55 88	 mov	 DWORD PTR _x$12[ebp], edx
  002fb	8b 45 98	 mov	 eax, DWORD PTR _dstC$16[ebp]
  002fe	83 c0 02	 add	 eax, 2
  00301	89 45 98	 mov	 DWORD PTR _dstC$16[ebp], eax
  00304	8b 4d 94	 mov	 ecx, DWORD PTR _srcU$15[ebp]
  00307	83 c1 04	 add	 ecx, 4
  0030a	89 4d 94	 mov	 DWORD PTR _srcU$15[ebp], ecx
  0030d	8b 55 90	 mov	 edx, DWORD PTR _srcV$14[ebp]
  00310	83 c2 04	 add	 edx, 4
  00313	89 55 90	 mov	 DWORD PTR _srcV$14[ebp], edx
$LN13@convert_yu:
  00316	8b 45 88	 mov	 eax, DWORD PTR _x$12[ebp]
  00319	3b 45 8c	 cmp	 eax, DWORD PTR _x_fin$13[ebp]
  0031c	0f 8d da 00 00
	00		 jge	 $LN12@convert_yu

; 326  :             int cy0u = srcU[0*src_uv_pitch + 0];

  00322	6b 4d ac 00	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 0
  00326	8b 55 94	 mov	 edx, DWORD PTR _srcU$15[ebp]
  00329	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  0032d	89 45 84	 mov	 DWORD PTR _cy0u$11[ebp], eax

; 327  :             int cy0v = srcV[0*src_uv_pitch + 0];

  00330	6b 4d ac 00	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 0
  00334	8b 55 90	 mov	 edx, DWORD PTR _srcV$14[ebp]
  00337	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  0033b	89 45 80	 mov	 DWORD PTR _cy0v$10[ebp], eax

; 328  :             int cy1u = srcU[1*src_uv_pitch + 0];

  0033e	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00341	8b 55 94	 mov	 edx, DWORD PTR _srcU$15[ebp]
  00344	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00348	89 85 7c ff ff
	ff		 mov	 DWORD PTR _cy1u$9[ebp], eax

; 329  :             int cy1v = srcV[1*src_uv_pitch + 0];

  0034e	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00351	8b 55 90	 mov	 edx, DWORD PTR _srcV$14[ebp]
  00354	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00358	89 85 78 ff ff
	ff		 mov	 DWORD PTR _cy1v$8[ebp], eax

; 330  : 
; 331  :             int cu = cy0u + cy1u + 1;

  0035e	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _cy1u$9[ebp]
  00364	8b 55 84	 mov	 edx, DWORD PTR _cy0u$11[ebp]
  00367	8d 44 0a 01	 lea	 eax, DWORD PTR [edx+ecx+1]
  0036b	89 85 74 ff ff
	ff		 mov	 DWORD PTR _cu$7[ebp], eax

; 332  :             int cv = cy0v + cy1v + 1;

  00371	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1v$8[ebp]
  00377	8b 55 80	 mov	 edx, DWORD PTR _cy0v$10[ebp]
  0037a	8d 44 0a 01	 lea	 eax, DWORD PTR [edx+ecx+1]
  0037e	89 85 70 ff ff
	ff		 mov	 DWORD PTR _cv$6[ebp], eax

; 333  :             CHANGE_BIT_DEPTH_2(cu, cv, 1);

  00384	33 c9		 xor	 ecx, ecx
  00386	74 20		 je	 SHORT $LN21@convert_yu
  00388	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _cu$7[ebp]
  0038e	c1 e2 f9	 shl	 edx, -7			; fffffff9H
  00391	89 95 74 ff ff
	ff		 mov	 DWORD PTR _cu$7[ebp], edx
  00397	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _cv$6[ebp]
  0039d	c1 e0 f9	 shl	 eax, -7			; fffffff9H
  003a0	89 85 70 ff ff
	ff		 mov	 DWORD PTR _cv$6[ebp], eax
  003a6	eb 27		 jmp	 SHORT $LN22@convert_yu
$LN21@convert_yu:
  003a8	b9 01 00 00 00	 mov	 ecx, 1
  003ad	85 c9		 test	 ecx, ecx
  003af	74 1e		 je	 SHORT $LN22@convert_yu
  003b1	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _cu$7[ebp]
  003b7	c1 fa 07	 sar	 edx, 7
  003ba	89 95 74 ff ff
	ff		 mov	 DWORD PTR _cu$7[ebp], edx
  003c0	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _cv$6[ebp]
  003c6	c1 f8 07	 sar	 eax, 7
  003c9	89 85 70 ff ff
	ff		 mov	 DWORD PTR _cv$6[ebp], eax
$LN22@convert_yu:

; 334  : 
; 335  :             dstC[0] = (Tout)cu;

  003cf	b9 01 00 00 00	 mov	 ecx, 1
  003d4	6b d1 00	 imul	 edx, ecx, 0
  003d7	8b 45 98	 mov	 eax, DWORD PTR _dstC$16[ebp]
  003da	8a 8d 74 ff ff
	ff		 mov	 cl, BYTE PTR _cu$7[ebp]
  003e0	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 336  :             dstC[1] = (Tout)cv;

  003e3	ba 01 00 00 00	 mov	 edx, 1
  003e8	c1 e2 00	 shl	 edx, 0
  003eb	8b 45 98	 mov	 eax, DWORD PTR _dstC$16[ebp]
  003ee	8a 8d 70 ff ff
	ff		 mov	 cl, BYTE PTR _cv$6[ebp]
  003f4	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 337  :         }

  003f7	e9 f6 fe ff ff	 jmp	 $LN11@convert_yu
$LN12@convert_yu:

; 338  :     }

  003fc	e9 90 fe ff ff	 jmp	 $LN8@convert_yu
$LN1@convert_yu:

; 339  : }

  00401	52		 push	 edx
  00402	8b cd		 mov	 ecx, ebp
  00404	50		 push	 eax
  00405	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN27@convert_yu
  0040b	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00410	58		 pop	 eax
  00411	5a		 pop	 edx
  00412	5f		 pop	 edi
  00413	5b		 pop	 ebx
  00414	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00417	33 cd		 xor	 ecx, ebp
  00419	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0041e	81 c4 ac 00 00
	00		 add	 esp, 172		; 000000acH
  00424	3b ec		 cmp	 ebp, esp
  00426	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0042b	8b e5		 mov	 esp, ebp
  0042d	5d		 pop	 ebp
  0042e	c3		 ret	 0
  0042f	90		 npad	 1
$LN27@convert_yu:
  00430	01 00 00 00	 DD	 1
  00434	00 00 00 00	 DD	 $LN26@convert_yu
$LN26@convert_yu:
  00438	d4 ff ff ff	 DD	 -44			; ffffffd4H
  0043c	0c 00 00 00	 DD	 12			; 0000000cH
  00440	00 00 00 00	 DD	 $LN25@convert_yu
$LN25@convert_yu:
  00444	79		 DB	 121			; 00000079H
  00445	5f		 DB	 95			; 0000005fH
  00446	72		 DB	 114			; 00000072H
  00447	61		 DB	 97			; 00000061H
  00448	6e		 DB	 110			; 0000006eH
  00449	67		 DB	 103			; 00000067H
  0044a	65		 DB	 101			; 00000065H
  0044b	00		 DB	 0
??$convert_yuv444_to_nv12_p_c@G$0O@E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_to_nv12_p_c<unsigned short,14,unsigned char,8,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuv444_14_to_nv12_p@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_14_to_nv12_p

; 432  : static void convert_yuv444_14_to_nv12_p(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 433  :     convert_yuv444_to_nv12_p_c<uint16_t, 14, uint8_t, 8, false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yuv444_to_nv12_p_c@G$0O@E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_to_nv12_p_c<unsigned short,14,unsigned char,8,0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 434  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yuv444_14_to_nv12_p@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_14_to_nv12_p
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
$T1 = -200						; size = 4
$T2 = -196						; size = 4
$T3 = -192						; size = 4
$T4 = -188						; size = 4
$T5 = -184						; size = 12
_cv_y1$6 = -172						; size = 4
_cv_y0$7 = -168						; size = 4
_cu_y1$8 = -164						; size = 4
_cu_y0$9 = -160						; size = 4
_cy3v$10 = -156						; size = 4
_cy3u$11 = -152						; size = 4
_cy2v$12 = -148						; size = 4
_cy2u$13 = -144						; size = 4
_cy1v$14 = -140						; size = 4
_cy1u$15 = -136						; size = 4
_cy0v$16 = -132						; size = 4
_cy0u$17 = -128						; size = 4
_x$18 = -124						; size = 4
_x_fin$19 = -120					; size = 4
_srcV$20 = -116						; size = 4
_srcU$21 = -112						; size = 4
_dstC$22 = -108						; size = 4
_y$23 = -104						; size = 4
_uv_fin$ = -100						; size = 4
_dstLine$ = -96						; size = 4
_srcVLine$ = -92					; size = 4
_srcULine$ = -88					; size = 4
_src_uv_pitch$ = -84					; size = 4
_x$24 = -80						; size = 4
_y$25 = -76						; size = 4
_y_width$26 = -72					; size = 4
_dstLine$27 = -68					; size = 4
_srcYLine$28 = -64					; size = 4
$T29 = -60						; size = 12
_y_range$ = -44						; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yuv444_to_nv12_i_c@G$0BA@E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_to_nv12_i_c<unsigned short,16,unsigned char,8,0>

; 342  : static void __forceinline convert_yuv444_to_nv12_i_c(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  00009	53		 push	 ebx
  0000a	57		 push	 edi
  0000b	8d bd 38 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-200]
  00011	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 343  :     static_assert((sizeof(Tin)  == 1 && in_bit_depth  == 8) || (sizeof(Tin)  == 2 && 8 < in_bit_depth  && in_bit_depth  <= 16), "invalid input bit depth.");
; 344  :     static_assert((sizeof(Tout) == 1 && out_bit_depth == 8) || (sizeof(Tout) == 2 && 8 < out_bit_depth && out_bit_depth <= 16), "invalid output bit depth.");
; 345  :     const int crop_left   = crop[0];

  00027	b8 04 00 00 00	 mov	 eax, 4
  0002c	6b c8 00	 imul	 ecx, eax, 0
  0002f	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00032	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00035	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 346  :     const int crop_up     = crop[1];

  00038	b9 04 00 00 00	 mov	 ecx, 4
  0003d	c1 e1 00	 shl	 ecx, 0
  00040	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00043	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00046	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 347  :     const int crop_right  = crop[2];

  00049	b9 04 00 00 00	 mov	 ecx, 4
  0004e	d1 e1		 shl	 ecx, 1
  00050	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00053	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00056	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 348  :     const int crop_bottom = crop[3];

  00059	b9 04 00 00 00	 mov	 ecx, 4
  0005e	6b d1 03	 imul	 edx, ecx, 3
  00061	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00064	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00067	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 349  :     const int src_y_pitch = src_y_pitch_byte / sizeof(Tin);

  0006a	8b 55 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebp]
  0006d	d1 ea		 shr	 edx, 1
  0006f	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 350  :     const int dst_y_pitch = dst_y_pitch_byte / sizeof(Tout);

  00072	8b 45 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  00075	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 351  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00078	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0007b	51		 push	 ecx
  0007c	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0007f	52		 push	 edx
  00080	8b 45 20	 mov	 eax, DWORD PTR _height$[ebp]
  00083	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  00086	50		 push	 eax
  00087	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  0008a	51		 push	 ecx
  0008b	8d 95 48 ff ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  00091	52		 push	 edx
  00092	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00097	83 c4 14	 add	 esp, 20			; 00000014H
  0009a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009c	89 4d c4	 mov	 DWORD PTR $T29[ebp], ecx
  0009f	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a2	89 55 c8	 mov	 DWORD PTR $T29[ebp+4], edx
  000a5	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000a8	89 45 cc	 mov	 DWORD PTR $T29[ebp+8], eax
  000ab	8b 4d c4	 mov	 ecx, DWORD PTR $T29[ebp]
  000ae	89 4d d4	 mov	 DWORD PTR _y_range$[ebp], ecx
  000b1	8b 55 c8	 mov	 edx, DWORD PTR $T29[ebp+4]
  000b4	89 55 d8	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000b7	8b 45 cc	 mov	 eax, DWORD PTR $T29[ebp+8]
  000ba	89 45 dc	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 352  :     //Y
; 353  :     if (!uv_only) {

  000bd	b9 01 00 00 00	 mov	 ecx, 1
  000c2	85 c9		 test	 ecx, ecx
  000c4	0f 84 61 01 00
	00		 je	 $LN14@convert_yu

; 354  :         Tin *srcYLine = (Tin *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000ca	ba 04 00 00 00	 mov	 edx, 4
  000cf	6b c2 00	 imul	 eax, edx, 0
  000d2	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  000d5	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  000d9	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  000dc	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  000df	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  000e2	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  000e5	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  000e8	89 45 c0	 mov	 DWORD PTR _srcYLine$28[ebp], eax

; 355  :         Tout *dstLine = (Tout *)dst[0] + dst_y_pitch * y_range.start_dst;

  000eb	b9 04 00 00 00	 mov	 ecx, 4
  000f0	6b d1 00	 imul	 edx, ecx, 0
  000f3	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  000f6	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  000fa	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  000fd	03 04 11	 add	 eax, DWORD PTR [ecx+edx]
  00100	89 45 bc	 mov	 DWORD PTR _dstLine$27[ebp], eax

; 356  :         const int y_width = width - crop_right - crop_left;

  00103	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00106	2b 55 f0	 sub	 edx, DWORD PTR _crop_right$[ebp]
  00109	2b 55 f8	 sub	 edx, DWORD PTR _crop_left$[ebp]
  0010c	89 55 b8	 mov	 DWORD PTR _y_width$26[ebp], edx

; 357  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  0010f	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _y$25[ebp], 0
  00116	eb 1e		 jmp	 SHORT $LN4@convert_yu
$LN2@convert_yu:
  00118	8b 45 b4	 mov	 eax, DWORD PTR _y$25[ebp]
  0011b	83 c0 01	 add	 eax, 1
  0011e	89 45 b4	 mov	 DWORD PTR _y$25[ebp], eax
  00121	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  00124	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$28[ebp]
  00127	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  0012a	89 45 c0	 mov	 DWORD PTR _srcYLine$28[ebp], eax
  0012d	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$27[ebp]
  00130	03 4d e4	 add	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  00133	89 4d bc	 mov	 DWORD PTR _dstLine$27[ebp], ecx
$LN4@convert_yu:
  00136	8b 55 b4	 mov	 edx, DWORD PTR _y$25[ebp]
  00139	3b 55 dc	 cmp	 edx, DWORD PTR _y_range$[ebp+8]
  0013c	0f 8d e9 00 00
	00		 jge	 $LN14@convert_yu

; 358  :             if (in_bit_depth == out_bit_depth && sizeof(Tin) == sizeof(Tout)) {

  00142	33 c0		 xor	 eax, eax
  00144	74 1b		 je	 SHORT $LN15@convert_yu

; 359  :                 memcpy(dstLine, srcYLine, y_width * sizeof(Tin));

  00146	8b 4d b8	 mov	 ecx, DWORD PTR _y_width$26[ebp]
  00149	d1 e1		 shl	 ecx, 1
  0014b	51		 push	 ecx
  0014c	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$28[ebp]
  0014f	52		 push	 edx
  00150	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$27[ebp]
  00153	50		 push	 eax
  00154	e8 00 00 00 00	 call	 _memcpy
  00159	83 c4 0c	 add	 esp, 12			; 0000000cH

; 360  :             } else {

  0015c	e9 c5 00 00 00	 jmp	 $LN16@convert_yu
$LN15@convert_yu:

; 361  :                 for (int x = 0; x < y_width; x++) {

  00161	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _x$24[ebp], 0
  00168	eb 09		 jmp	 SHORT $LN7@convert_yu
$LN5@convert_yu:
  0016a	8b 4d b0	 mov	 ecx, DWORD PTR _x$24[ebp]
  0016d	83 c1 01	 add	 ecx, 1
  00170	89 4d b0	 mov	 DWORD PTR _x$24[ebp], ecx
$LN7@convert_yu:
  00173	8b 55 b0	 mov	 edx, DWORD PTR _x$24[ebp]
  00176	3b 55 b8	 cmp	 edx, DWORD PTR _y_width$26[ebp]
  00179	0f 8d a7 00 00
	00		 jge	 $LN16@convert_yu

; 362  :                     if (out_bit_depth > in_bit_depth) {

  0017f	33 c0		 xor	 eax, eax
  00181	74 42		 je	 SHORT $LN17@convert_yu

; 363  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) << std::max(out_bit_depth - in_bit_depth, 0));

  00183	c7 85 44 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], 0
  0018d	c7 85 40 ff ff
	ff f8 ff ff ff	 mov	 DWORD PTR $T3[ebp], -8	; fffffff8H
  00197	8b 4d b0	 mov	 ecx, DWORD PTR _x$24[ebp]
  0019a	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$28[ebp]
  0019d	0f b7 1c 4a	 movzx	 ebx, WORD PTR [edx+ecx*2]
  001a1	8d 85 44 ff ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  001a7	50		 push	 eax
  001a8	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  001ae	51		 push	 ecx
  001af	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  001b4	83 c4 08	 add	 esp, 8
  001b7	8b 08		 mov	 ecx, DWORD PTR [eax]
  001b9	d3 e3		 shl	 ebx, cl
  001bb	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$27[ebp]
  001be	03 55 b0	 add	 edx, DWORD PTR _x$24[ebp]
  001c1	88 1a		 mov	 BYTE PTR [edx], bl
  001c3	eb 5c		 jmp	 SHORT $LN18@convert_yu
$LN17@convert_yu:

; 364  :                     } else if (out_bit_depth < in_bit_depth) {

  001c5	b8 01 00 00 00	 mov	 eax, 1
  001ca	85 c0		 test	 eax, eax
  001cc	74 42		 je	 SHORT $LN19@convert_yu

; 365  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) >> std::max(in_bit_depth - out_bit_depth, 0));

  001ce	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], 0
  001d8	c7 85 38 ff ff
	ff 08 00 00 00	 mov	 DWORD PTR $T1[ebp], 8
  001e2	8b 4d b0	 mov	 ecx, DWORD PTR _x$24[ebp]
  001e5	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$28[ebp]
  001e8	0f b7 1c 4a	 movzx	 ebx, WORD PTR [edx+ecx*2]
  001ec	8d 85 3c ff ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  001f2	50		 push	 eax
  001f3	8d 8d 38 ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  001f9	51		 push	 ecx
  001fa	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  001ff	83 c4 08	 add	 esp, 8
  00202	8b 08		 mov	 ecx, DWORD PTR [eax]
  00204	d3 fb		 sar	 ebx, cl
  00206	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$27[ebp]
  00209	03 55 b0	 add	 edx, DWORD PTR _x$24[ebp]
  0020c	88 1a		 mov	 BYTE PTR [edx], bl

; 366  :                     } else {

  0020e	eb 11		 jmp	 SHORT $LN18@convert_yu
$LN19@convert_yu:

; 367  :                         dstLine[x] = (Tout)srcYLine[x];

  00210	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$27[ebp]
  00213	03 45 b0	 add	 eax, DWORD PTR _x$24[ebp]
  00216	8b 4d b0	 mov	 ecx, DWORD PTR _x$24[ebp]
  00219	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$28[ebp]
  0021c	8a 0c 4a	 mov	 cl, BYTE PTR [edx+ecx*2]
  0021f	88 08		 mov	 BYTE PTR [eax], cl
$LN18@convert_yu:

; 368  :                     }
; 369  :                 }

  00221	e9 44 ff ff ff	 jmp	 $LN5@convert_yu
$LN16@convert_yu:

; 370  :             }
; 371  :         }

  00226	e9 ed fe ff ff	 jmp	 $LN2@convert_yu
$LN14@convert_yu:

; 372  :     }
; 373  :     //UV
; 374  :     const int src_uv_pitch = src_uv_pitch_byte / sizeof(Tin);

  0022b	8b 55 18	 mov	 edx, DWORD PTR _src_uv_pitch_byte$[ebp]
  0022e	d1 ea		 shr	 edx, 1
  00230	89 55 ac	 mov	 DWORD PTR _src_uv_pitch$[ebp], edx

; 375  :     Tin *srcULine = (Tin *)src[1] + ((src_uv_pitch * y_range.start_src) + crop_left);

  00233	b8 04 00 00 00	 mov	 eax, 4
  00238	c1 e0 00	 shl	 eax, 0
  0023b	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  0023e	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  00242	03 4d f8	 add	 ecx, DWORD PTR _crop_left$[ebp]
  00245	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  00248	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  0024b	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  0024e	89 4d a8	 mov	 DWORD PTR _srcULine$[ebp], ecx

; 376  :     Tin *srcVLine = (Tin *)src[2] + ((src_uv_pitch * y_range.start_src) + crop_left);

  00251	ba 04 00 00 00	 mov	 edx, 4
  00256	d1 e2		 shl	 edx, 1
  00258	8b 45 ac	 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  0025b	0f af 45 d4	 imul	 eax, DWORD PTR _y_range$[ebp]
  0025f	03 45 f8	 add	 eax, DWORD PTR _crop_left$[ebp]
  00262	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  00265	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  00268	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  0026b	89 45 a4	 mov	 DWORD PTR _srcVLine$[ebp], eax

; 377  :     Tout *dstLine = (Tout *)dst[1] + (dst_y_pitch >> 1) * y_range.start_dst;

  0026e	b9 04 00 00 00	 mov	 ecx, 4
  00273	c1 e1 00	 shl	 ecx, 0
  00276	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  00279	d1 fa		 sar	 edx, 1
  0027b	0f af 55 d8	 imul	 edx, DWORD PTR _y_range$[ebp+4]
  0027f	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
  00282	03 14 08	 add	 edx, DWORD PTR [eax+ecx]
  00285	89 55 a0	 mov	 DWORD PTR _dstLine$[ebp], edx

; 378  :     const int uv_fin = height - crop_bottom - crop_up;

  00288	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  0028b	2b 4d ec	 sub	 ecx, DWORD PTR _crop_bottom$[ebp]
  0028e	2b 4d f4	 sub	 ecx, DWORD PTR _crop_up$[ebp]
  00291	89 4d 9c	 mov	 DWORD PTR _uv_fin$[ebp], ecx

; 379  :     for (int y = 0; y < y_range.len; y += 4, srcULine += src_uv_pitch * 4, srcVLine += src_uv_pitch * 4, dstLine += dst_y_pitch * 2) {

  00294	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _y$23[ebp], 0
  0029b	eb 33		 jmp	 SHORT $LN10@convert_yu
$LN8@convert_yu:
  0029d	8b 55 98	 mov	 edx, DWORD PTR _y$23[ebp]
  002a0	83 c2 04	 add	 edx, 4
  002a3	89 55 98	 mov	 DWORD PTR _y$23[ebp], edx
  002a6	8b 45 ac	 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  002a9	c1 e0 02	 shl	 eax, 2
  002ac	8b 4d a8	 mov	 ecx, DWORD PTR _srcULine$[ebp]
  002af	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  002b2	89 55 a8	 mov	 DWORD PTR _srcULine$[ebp], edx
  002b5	8b 45 ac	 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  002b8	c1 e0 02	 shl	 eax, 2
  002bb	8b 4d a4	 mov	 ecx, DWORD PTR _srcVLine$[ebp]
  002be	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  002c1	89 55 a4	 mov	 DWORD PTR _srcVLine$[ebp], edx
  002c4	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  002c7	8b 4d a0	 mov	 ecx, DWORD PTR _dstLine$[ebp]
  002ca	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  002cd	89 55 a0	 mov	 DWORD PTR _dstLine$[ebp], edx
$LN10@convert_yu:
  002d0	8b 45 98	 mov	 eax, DWORD PTR _y$23[ebp]
  002d3	3b 45 dc	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  002d6	0f 8d 04 02 00
	00		 jge	 $LN1@convert_yu

; 380  :         Tout *dstC = dstLine;

  002dc	8b 4d a0	 mov	 ecx, DWORD PTR _dstLine$[ebp]
  002df	89 4d 94	 mov	 DWORD PTR _dstC$22[ebp], ecx

; 381  :         Tin *srcU = srcULine;

  002e2	8b 55 a8	 mov	 edx, DWORD PTR _srcULine$[ebp]
  002e5	89 55 90	 mov	 DWORD PTR _srcU$21[ebp], edx

; 382  :         Tin *srcV = srcVLine;

  002e8	8b 45 a4	 mov	 eax, DWORD PTR _srcVLine$[ebp]
  002eb	89 45 8c	 mov	 DWORD PTR _srcV$20[ebp], eax

; 383  :         const int x_fin = width - crop_right - crop_left;

  002ee	8b 4d 10	 mov	 ecx, DWORD PTR _width$[ebp]
  002f1	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  002f4	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  002f7	89 4d 88	 mov	 DWORD PTR _x_fin$19[ebp], ecx

; 384  :         for (int x = 0; x < x_fin; x += 2, dstC += 2, srcU += 2, srcV += 2) {

  002fa	c7 45 84 00 00
	00 00		 mov	 DWORD PTR _x$18[ebp], 0
  00301	eb 24		 jmp	 SHORT $LN13@convert_yu
$LN11@convert_yu:
  00303	8b 55 84	 mov	 edx, DWORD PTR _x$18[ebp]
  00306	83 c2 02	 add	 edx, 2
  00309	89 55 84	 mov	 DWORD PTR _x$18[ebp], edx
  0030c	8b 45 94	 mov	 eax, DWORD PTR _dstC$22[ebp]
  0030f	83 c0 02	 add	 eax, 2
  00312	89 45 94	 mov	 DWORD PTR _dstC$22[ebp], eax
  00315	8b 4d 90	 mov	 ecx, DWORD PTR _srcU$21[ebp]
  00318	83 c1 04	 add	 ecx, 4
  0031b	89 4d 90	 mov	 DWORD PTR _srcU$21[ebp], ecx
  0031e	8b 55 8c	 mov	 edx, DWORD PTR _srcV$20[ebp]
  00321	83 c2 04	 add	 edx, 4
  00324	89 55 8c	 mov	 DWORD PTR _srcV$20[ebp], edx
$LN13@convert_yu:
  00327	8b 45 84	 mov	 eax, DWORD PTR _x$18[ebp]
  0032a	3b 45 88	 cmp	 eax, DWORD PTR _x_fin$19[ebp]
  0032d	0f 8d a8 01 00
	00		 jge	 $LN12@convert_yu

; 385  :             int cy0u = srcU[0*src_uv_pitch + 0];

  00333	6b 4d ac 00	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 0
  00337	8b 55 90	 mov	 edx, DWORD PTR _srcU$21[ebp]
  0033a	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  0033e	89 45 80	 mov	 DWORD PTR _cy0u$17[ebp], eax

; 386  :             int cy0v = srcV[0*src_uv_pitch + 0];

  00341	6b 4d ac 00	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 0
  00345	8b 55 8c	 mov	 edx, DWORD PTR _srcV$20[ebp]
  00348	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  0034c	89 85 7c ff ff
	ff		 mov	 DWORD PTR _cy0v$16[ebp], eax

; 387  :             int cy1u = srcU[1*src_uv_pitch + 0];

  00352	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00355	8b 55 90	 mov	 edx, DWORD PTR _srcU$21[ebp]
  00358	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  0035c	89 85 78 ff ff
	ff		 mov	 DWORD PTR _cy1u$15[ebp], eax

; 388  :             int cy1v = srcV[1*src_uv_pitch + 0];

  00362	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00365	8b 55 8c	 mov	 edx, DWORD PTR _srcV$20[ebp]
  00368	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  0036c	89 85 74 ff ff
	ff		 mov	 DWORD PTR _cy1v$14[ebp], eax

; 389  :             int cy2u = srcU[2*src_uv_pitch + 0];

  00372	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00375	d1 e1		 shl	 ecx, 1
  00377	8b 55 90	 mov	 edx, DWORD PTR _srcU$21[ebp]
  0037a	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  0037e	89 85 70 ff ff
	ff		 mov	 DWORD PTR _cy2u$13[ebp], eax

; 390  :             int cy2v = srcV[2*src_uv_pitch + 0];

  00384	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00387	d1 e1		 shl	 ecx, 1
  00389	8b 55 8c	 mov	 edx, DWORD PTR _srcV$20[ebp]
  0038c	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00390	89 85 6c ff ff
	ff		 mov	 DWORD PTR _cy2v$12[ebp], eax

; 391  :             int cy3u = srcU[3*src_uv_pitch + 0];

  00396	6b 4d ac 03	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 3
  0039a	8b 55 90	 mov	 edx, DWORD PTR _srcU$21[ebp]
  0039d	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  003a1	89 85 68 ff ff
	ff		 mov	 DWORD PTR _cy3u$11[ebp], eax

; 392  :             int cy3v = srcV[3*src_uv_pitch + 0];

  003a7	6b 4d ac 03	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 3
  003ab	8b 55 8c	 mov	 edx, DWORD PTR _srcV$20[ebp]
  003ae	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  003b2	89 85 64 ff ff
	ff		 mov	 DWORD PTR _cy3v$10[ebp], eax

; 393  : 
; 394  :             int cu_y0 = cy0u * 3 + cy2u * 1 + 2;

  003b8	6b 4d 80 03	 imul	 ecx, DWORD PTR _cy0u$17[ebp], 3
  003bc	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR _cy2u$13[ebp]
  003c2	8d 44 11 02	 lea	 eax, DWORD PTR [ecx+edx+2]
  003c6	89 85 60 ff ff
	ff		 mov	 DWORD PTR _cu_y0$9[ebp], eax

; 395  :             int cu_y1 = cy1u * 1 + cy3u * 3 + 2;

  003cc	6b 8d 68 ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy3u$11[ebp], 3
  003d3	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _cy1u$15[ebp]
  003d9	8d 44 0a 02	 lea	 eax, DWORD PTR [edx+ecx+2]
  003dd	89 85 5c ff ff
	ff		 mov	 DWORD PTR _cu_y1$8[ebp], eax

; 396  :             int cv_y0 = cy0v * 3 + cy2v * 1 + 2;

  003e3	6b 8d 7c ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy0v$16[ebp], 3
  003ea	8b 95 6c ff ff
	ff		 mov	 edx, DWORD PTR _cy2v$12[ebp]
  003f0	8d 44 11 02	 lea	 eax, DWORD PTR [ecx+edx+2]
  003f4	89 85 58 ff ff
	ff		 mov	 DWORD PTR _cv_y0$7[ebp], eax

; 397  :             int cv_y1 = cy1v * 1 + cy3v * 3 + 2;

  003fa	6b 8d 64 ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy3v$10[ebp], 3
  00401	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _cy1v$14[ebp]
  00407	8d 44 0a 02	 lea	 eax, DWORD PTR [edx+ecx+2]
  0040b	89 85 54 ff ff
	ff		 mov	 DWORD PTR _cv_y1$6[ebp], eax

; 398  :             CHANGE_BIT_DEPTH_4(cu_y0, cu_y1, cv_y0, cv_y1, 2);

  00411	33 c9		 xor	 ecx, ecx
  00413	74 3e		 je	 SHORT $LN21@convert_yu
  00415	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _cu_y0$9[ebp]
  0041b	c1 e2 f6	 shl	 edx, -10		; fffffff6H
  0041e	89 95 60 ff ff
	ff		 mov	 DWORD PTR _cu_y0$9[ebp], edx
  00424	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _cu_y1$8[ebp]
  0042a	c1 e0 f6	 shl	 eax, -10		; fffffff6H
  0042d	89 85 5c ff ff
	ff		 mov	 DWORD PTR _cu_y1$8[ebp], eax
  00433	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _cv_y0$7[ebp]
  00439	c1 e1 f6	 shl	 ecx, -10		; fffffff6H
  0043c	89 8d 58 ff ff
	ff		 mov	 DWORD PTR _cv_y0$7[ebp], ecx
  00442	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR _cv_y1$6[ebp]
  00448	c1 e2 f6	 shl	 edx, -10		; fffffff6H
  0044b	89 95 54 ff ff
	ff		 mov	 DWORD PTR _cv_y1$6[ebp], edx
  00451	eb 45		 jmp	 SHORT $LN22@convert_yu
$LN21@convert_yu:
  00453	b8 01 00 00 00	 mov	 eax, 1
  00458	85 c0		 test	 eax, eax
  0045a	74 3c		 je	 SHORT $LN22@convert_yu
  0045c	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _cu_y0$9[ebp]
  00462	c1 f9 0a	 sar	 ecx, 10			; 0000000aH
  00465	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _cu_y0$9[ebp], ecx
  0046b	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR _cu_y1$8[ebp]
  00471	c1 fa 0a	 sar	 edx, 10			; 0000000aH
  00474	89 95 5c ff ff
	ff		 mov	 DWORD PTR _cu_y1$8[ebp], edx
  0047a	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _cv_y0$7[ebp]
  00480	c1 f8 0a	 sar	 eax, 10			; 0000000aH
  00483	89 85 58 ff ff
	ff		 mov	 DWORD PTR _cv_y0$7[ebp], eax
  00489	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _cv_y1$6[ebp]
  0048f	c1 f9 0a	 sar	 ecx, 10			; 0000000aH
  00492	89 8d 54 ff ff
	ff		 mov	 DWORD PTR _cv_y1$6[ebp], ecx
$LN22@convert_yu:

; 399  : 
; 400  :             dstC[0*dst_y_pitch + 0] = (Tout)cu_y0;

  00498	6b 55 e4 00	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 0
  0049c	8b 45 94	 mov	 eax, DWORD PTR _dstC$22[ebp]
  0049f	8a 8d 60 ff ff
	ff		 mov	 cl, BYTE PTR _cu_y0$9[ebp]
  004a5	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 401  :             dstC[0*dst_y_pitch + 1] = (Tout)cv_y0;

  004a8	6b 55 e4 00	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 0
  004ac	8b 45 94	 mov	 eax, DWORD PTR _dstC$22[ebp]
  004af	8a 8d 58 ff ff
	ff		 mov	 cl, BYTE PTR _cv_y0$7[ebp]
  004b5	88 4c 10 01	 mov	 BYTE PTR [eax+edx+1], cl

; 402  :             dstC[1*dst_y_pitch + 0] = (Tout)cu_y1;

  004b9	8b 55 94	 mov	 edx, DWORD PTR _dstC$22[ebp]
  004bc	03 55 e4	 add	 edx, DWORD PTR _dst_y_pitch$[ebp]
  004bf	8a 85 5c ff ff
	ff		 mov	 al, BYTE PTR _cu_y1$8[ebp]
  004c5	88 02		 mov	 BYTE PTR [edx], al

; 403  :             dstC[1*dst_y_pitch + 1] = (Tout)cv_y1;

  004c7	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$22[ebp]
  004ca	03 4d e4	 add	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  004cd	8a 95 54 ff ff
	ff		 mov	 dl, BYTE PTR _cv_y1$6[ebp]
  004d3	88 51 01	 mov	 BYTE PTR [ecx+1], dl

; 404  :         }

  004d6	e9 28 fe ff ff	 jmp	 $LN11@convert_yu
$LN12@convert_yu:

; 405  :     }

  004db	e9 bd fd ff ff	 jmp	 $LN8@convert_yu
$LN1@convert_yu:

; 406  : }

  004e0	52		 push	 edx
  004e1	8b cd		 mov	 ecx, ebp
  004e3	50		 push	 eax
  004e4	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN27@convert_yu
  004ea	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  004ef	58		 pop	 eax
  004f0	5a		 pop	 edx
  004f1	5f		 pop	 edi
  004f2	5b		 pop	 ebx
  004f3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004f6	33 cd		 xor	 ecx, ebp
  004f8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004fd	81 c4 c8 00 00
	00		 add	 esp, 200		; 000000c8H
  00503	3b ec		 cmp	 ebp, esp
  00505	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0050a	8b e5		 mov	 esp, ebp
  0050c	5d		 pop	 ebp
  0050d	c3		 ret	 0
  0050e	66 90		 npad	 2
$LN27@convert_yu:
  00510	01 00 00 00	 DD	 1
  00514	00 00 00 00	 DD	 $LN26@convert_yu
$LN26@convert_yu:
  00518	d4 ff ff ff	 DD	 -44			; ffffffd4H
  0051c	0c 00 00 00	 DD	 12			; 0000000cH
  00520	00 00 00 00	 DD	 $LN25@convert_yu
$LN25@convert_yu:
  00524	79		 DB	 121			; 00000079H
  00525	5f		 DB	 95			; 0000005fH
  00526	72		 DB	 114			; 00000072H
  00527	61		 DB	 97			; 00000061H
  00528	6e		 DB	 110			; 0000006eH
  00529	67		 DB	 103			; 00000067H
  0052a	65		 DB	 101			; 00000065H
  0052b	00		 DB	 0
??$convert_yuv444_to_nv12_i_c@G$0BA@E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_to_nv12_i_c<unsigned short,16,unsigned char,8,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuv444_16_to_nv12_i@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_16_to_nv12_i

; 428  : static void convert_yuv444_16_to_nv12_i(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 429  :     convert_yuv444_to_nv12_i_c<uint16_t, 16, uint8_t, 8, false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yuv444_to_nv12_i_c@G$0BA@E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_to_nv12_i_c<unsigned short,16,unsigned char,8,0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 430  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yuv444_16_to_nv12_i@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_16_to_nv12_i
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
$T1 = -172						; size = 4
$T2 = -168						; size = 4
$T3 = -164						; size = 4
$T4 = -160						; size = 4
$T5 = -156						; size = 12
_cv$6 = -144						; size = 4
_cu$7 = -140						; size = 4
_cy1v$8 = -136						; size = 4
_cy1u$9 = -132						; size = 4
_cy0v$10 = -128						; size = 4
_cy0u$11 = -124						; size = 4
_x$12 = -120						; size = 4
_x_fin$13 = -116					; size = 4
_srcV$14 = -112						; size = 4
_srcU$15 = -108						; size = 4
_dstC$16 = -104						; size = 4
_y$17 = -100						; size = 4
_dstLine$ = -96						; size = 4
_srcVLine$ = -92					; size = 4
_srcULine$ = -88					; size = 4
_src_uv_pitch$ = -84					; size = 4
_x$18 = -80						; size = 4
_y$19 = -76						; size = 4
_y_width$20 = -72					; size = 4
_dstLine$21 = -68					; size = 4
_srcYLine$22 = -64					; size = 4
$T23 = -60						; size = 12
_y_range$ = -44						; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yuv444_to_nv12_p_c@G$0BA@E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_to_nv12_p_c<unsigned short,16,unsigned char,8,0>

; 284  : static void __forceinline convert_yuv444_to_nv12_p_c(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec ac 00 00
	00		 sub	 esp, 172		; 000000acH
  00009	53		 push	 ebx
  0000a	57		 push	 edi
  0000b	8d bd 54 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-172]
  00011	b9 2b 00 00 00	 mov	 ecx, 43			; 0000002bH
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 285  :     static_assert((sizeof(Tin)  == 1 && in_bit_depth  == 8) || (sizeof(Tin)  == 2 && 8 < in_bit_depth  && in_bit_depth  <= 16), "invalid input bit depth.");
; 286  :     static_assert((sizeof(Tout) == 1 && out_bit_depth == 8) || (sizeof(Tout) == 2 && 8 < out_bit_depth && out_bit_depth <= 16), "invalid output bit depth.");
; 287  :     const int crop_left   = crop[0];

  00027	b8 04 00 00 00	 mov	 eax, 4
  0002c	6b c8 00	 imul	 ecx, eax, 0
  0002f	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00032	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00035	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 288  :     const int crop_up     = crop[1];

  00038	b9 04 00 00 00	 mov	 ecx, 4
  0003d	c1 e1 00	 shl	 ecx, 0
  00040	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00043	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00046	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 289  :     const int crop_right  = crop[2];

  00049	b9 04 00 00 00	 mov	 ecx, 4
  0004e	d1 e1		 shl	 ecx, 1
  00050	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00053	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00056	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 290  :     const int crop_bottom = crop[3];

  00059	b9 04 00 00 00	 mov	 ecx, 4
  0005e	6b d1 03	 imul	 edx, ecx, 3
  00061	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00064	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00067	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 291  :     const int src_y_pitch = src_y_pitch_byte / sizeof(Tin);

  0006a	8b 55 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebp]
  0006d	d1 ea		 shr	 edx, 1
  0006f	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 292  :     const int dst_y_pitch = dst_y_pitch_byte / sizeof(Tout);

  00072	8b 45 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  00075	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 293  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00078	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0007b	51		 push	 ecx
  0007c	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0007f	52		 push	 edx
  00080	8b 45 20	 mov	 eax, DWORD PTR _height$[ebp]
  00083	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  00086	50		 push	 eax
  00087	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  0008a	51		 push	 ecx
  0008b	8d 95 64 ff ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  00091	52		 push	 edx
  00092	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00097	83 c4 14	 add	 esp, 20			; 00000014H
  0009a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009c	89 4d c4	 mov	 DWORD PTR $T23[ebp], ecx
  0009f	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a2	89 55 c8	 mov	 DWORD PTR $T23[ebp+4], edx
  000a5	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000a8	89 45 cc	 mov	 DWORD PTR $T23[ebp+8], eax
  000ab	8b 4d c4	 mov	 ecx, DWORD PTR $T23[ebp]
  000ae	89 4d d4	 mov	 DWORD PTR _y_range$[ebp], ecx
  000b1	8b 55 c8	 mov	 edx, DWORD PTR $T23[ebp+4]
  000b4	89 55 d8	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000b7	8b 45 cc	 mov	 eax, DWORD PTR $T23[ebp+8]
  000ba	89 45 dc	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 294  :     //Y
; 295  :     if (!uv_only) {

  000bd	b9 01 00 00 00	 mov	 ecx, 1
  000c2	85 c9		 test	 ecx, ecx
  000c4	0f 84 61 01 00
	00		 je	 $LN14@convert_yu

; 296  :         Tin *srcYLine = (Tin *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000ca	ba 04 00 00 00	 mov	 edx, 4
  000cf	6b c2 00	 imul	 eax, edx, 0
  000d2	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  000d5	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  000d9	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  000dc	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  000df	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  000e2	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  000e5	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  000e8	89 45 c0	 mov	 DWORD PTR _srcYLine$22[ebp], eax

; 297  :         Tout *dstLine = (Tout *)dst[0] + dst_y_pitch * y_range.start_dst;

  000eb	b9 04 00 00 00	 mov	 ecx, 4
  000f0	6b d1 00	 imul	 edx, ecx, 0
  000f3	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  000f6	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  000fa	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  000fd	03 04 11	 add	 eax, DWORD PTR [ecx+edx]
  00100	89 45 bc	 mov	 DWORD PTR _dstLine$21[ebp], eax

; 298  :         const int y_width = width - crop_right - crop_left;

  00103	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00106	2b 55 f0	 sub	 edx, DWORD PTR _crop_right$[ebp]
  00109	2b 55 f8	 sub	 edx, DWORD PTR _crop_left$[ebp]
  0010c	89 55 b8	 mov	 DWORD PTR _y_width$20[ebp], edx

; 299  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  0010f	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _y$19[ebp], 0
  00116	eb 1e		 jmp	 SHORT $LN4@convert_yu
$LN2@convert_yu:
  00118	8b 45 b4	 mov	 eax, DWORD PTR _y$19[ebp]
  0011b	83 c0 01	 add	 eax, 1
  0011e	89 45 b4	 mov	 DWORD PTR _y$19[ebp], eax
  00121	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  00124	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$22[ebp]
  00127	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  0012a	89 45 c0	 mov	 DWORD PTR _srcYLine$22[ebp], eax
  0012d	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$21[ebp]
  00130	03 4d e4	 add	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  00133	89 4d bc	 mov	 DWORD PTR _dstLine$21[ebp], ecx
$LN4@convert_yu:
  00136	8b 55 b4	 mov	 edx, DWORD PTR _y$19[ebp]
  00139	3b 55 dc	 cmp	 edx, DWORD PTR _y_range$[ebp+8]
  0013c	0f 8d e9 00 00
	00		 jge	 $LN14@convert_yu

; 300  :             if (in_bit_depth == out_bit_depth && sizeof(Tin) == sizeof(Tout)) {

  00142	33 c0		 xor	 eax, eax
  00144	74 1b		 je	 SHORT $LN15@convert_yu

; 301  :                 memcpy(dstLine, srcYLine, y_width * sizeof(Tin));

  00146	8b 4d b8	 mov	 ecx, DWORD PTR _y_width$20[ebp]
  00149	d1 e1		 shl	 ecx, 1
  0014b	51		 push	 ecx
  0014c	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$22[ebp]
  0014f	52		 push	 edx
  00150	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$21[ebp]
  00153	50		 push	 eax
  00154	e8 00 00 00 00	 call	 _memcpy
  00159	83 c4 0c	 add	 esp, 12			; 0000000cH

; 302  :             } else {

  0015c	e9 c5 00 00 00	 jmp	 $LN16@convert_yu
$LN15@convert_yu:

; 303  :                 for (int x = 0; x < y_width; x++) {

  00161	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _x$18[ebp], 0
  00168	eb 09		 jmp	 SHORT $LN7@convert_yu
$LN5@convert_yu:
  0016a	8b 4d b0	 mov	 ecx, DWORD PTR _x$18[ebp]
  0016d	83 c1 01	 add	 ecx, 1
  00170	89 4d b0	 mov	 DWORD PTR _x$18[ebp], ecx
$LN7@convert_yu:
  00173	8b 55 b0	 mov	 edx, DWORD PTR _x$18[ebp]
  00176	3b 55 b8	 cmp	 edx, DWORD PTR _y_width$20[ebp]
  00179	0f 8d a7 00 00
	00		 jge	 $LN16@convert_yu

; 304  :                     if (out_bit_depth > in_bit_depth) {

  0017f	33 c0		 xor	 eax, eax
  00181	74 42		 je	 SHORT $LN17@convert_yu

; 305  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) << std::max(out_bit_depth - in_bit_depth, 0));

  00183	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], 0
  0018d	c7 85 5c ff ff
	ff f8 ff ff ff	 mov	 DWORD PTR $T3[ebp], -8	; fffffff8H
  00197	8b 4d b0	 mov	 ecx, DWORD PTR _x$18[ebp]
  0019a	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$22[ebp]
  0019d	0f b7 1c 4a	 movzx	 ebx, WORD PTR [edx+ecx*2]
  001a1	8d 85 60 ff ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  001a7	50		 push	 eax
  001a8	8d 8d 5c ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  001ae	51		 push	 ecx
  001af	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  001b4	83 c4 08	 add	 esp, 8
  001b7	8b 08		 mov	 ecx, DWORD PTR [eax]
  001b9	d3 e3		 shl	 ebx, cl
  001bb	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$21[ebp]
  001be	03 55 b0	 add	 edx, DWORD PTR _x$18[ebp]
  001c1	88 1a		 mov	 BYTE PTR [edx], bl
  001c3	eb 5c		 jmp	 SHORT $LN18@convert_yu
$LN17@convert_yu:

; 306  :                     } else if (out_bit_depth < in_bit_depth) {

  001c5	b8 01 00 00 00	 mov	 eax, 1
  001ca	85 c0		 test	 eax, eax
  001cc	74 42		 je	 SHORT $LN19@convert_yu

; 307  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) >> std::max(in_bit_depth - out_bit_depth, 0));

  001ce	c7 85 58 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], 0
  001d8	c7 85 54 ff ff
	ff 08 00 00 00	 mov	 DWORD PTR $T1[ebp], 8
  001e2	8b 4d b0	 mov	 ecx, DWORD PTR _x$18[ebp]
  001e5	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$22[ebp]
  001e8	0f b7 1c 4a	 movzx	 ebx, WORD PTR [edx+ecx*2]
  001ec	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  001f2	50		 push	 eax
  001f3	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  001f9	51		 push	 ecx
  001fa	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  001ff	83 c4 08	 add	 esp, 8
  00202	8b 08		 mov	 ecx, DWORD PTR [eax]
  00204	d3 fb		 sar	 ebx, cl
  00206	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$21[ebp]
  00209	03 55 b0	 add	 edx, DWORD PTR _x$18[ebp]
  0020c	88 1a		 mov	 BYTE PTR [edx], bl

; 308  :                     } else {

  0020e	eb 11		 jmp	 SHORT $LN18@convert_yu
$LN19@convert_yu:

; 309  :                         dstLine[x] = (Tout)srcYLine[x];

  00210	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$21[ebp]
  00213	03 45 b0	 add	 eax, DWORD PTR _x$18[ebp]
  00216	8b 4d b0	 mov	 ecx, DWORD PTR _x$18[ebp]
  00219	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$22[ebp]
  0021c	8a 0c 4a	 mov	 cl, BYTE PTR [edx+ecx*2]
  0021f	88 08		 mov	 BYTE PTR [eax], cl
$LN18@convert_yu:

; 310  :                     }
; 311  :                 }

  00221	e9 44 ff ff ff	 jmp	 $LN5@convert_yu
$LN16@convert_yu:

; 312  :             }
; 313  :         }

  00226	e9 ed fe ff ff	 jmp	 $LN2@convert_yu
$LN14@convert_yu:

; 314  :     }
; 315  :     //UV
; 316  :     const int src_uv_pitch = src_uv_pitch_byte / sizeof(Tin);

  0022b	8b 55 18	 mov	 edx, DWORD PTR _src_uv_pitch_byte$[ebp]
  0022e	d1 ea		 shr	 edx, 1
  00230	89 55 ac	 mov	 DWORD PTR _src_uv_pitch$[ebp], edx

; 317  :     Tin *srcULine = (Tin *)src[1] + ((src_uv_pitch * y_range.start_src) + crop_left);

  00233	b8 04 00 00 00	 mov	 eax, 4
  00238	c1 e0 00	 shl	 eax, 0
  0023b	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  0023e	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  00242	03 4d f8	 add	 ecx, DWORD PTR _crop_left$[ebp]
  00245	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  00248	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  0024b	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  0024e	89 4d a8	 mov	 DWORD PTR _srcULine$[ebp], ecx

; 318  :     Tin *srcVLine = (Tin *)src[2] + ((src_uv_pitch * y_range.start_src) + crop_left);

  00251	ba 04 00 00 00	 mov	 edx, 4
  00256	d1 e2		 shl	 edx, 1
  00258	8b 45 ac	 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  0025b	0f af 45 d4	 imul	 eax, DWORD PTR _y_range$[ebp]
  0025f	03 45 f8	 add	 eax, DWORD PTR _crop_left$[ebp]
  00262	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  00265	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  00268	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  0026b	89 45 a4	 mov	 DWORD PTR _srcVLine$[ebp], eax

; 319  :     Tout *dstLine = (Tout *)dst[1] + (dst_y_pitch >> 1) * y_range.start_dst;

  0026e	b9 04 00 00 00	 mov	 ecx, 4
  00273	c1 e1 00	 shl	 ecx, 0
  00276	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  00279	d1 fa		 sar	 edx, 1
  0027b	0f af 55 d8	 imul	 edx, DWORD PTR _y_range$[ebp+4]
  0027f	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
  00282	03 14 08	 add	 edx, DWORD PTR [eax+ecx]
  00285	89 55 a0	 mov	 DWORD PTR _dstLine$[ebp], edx

; 320  :     for (int y = 0; y < y_range.len; y += 2, srcULine += src_uv_pitch * 2, srcVLine += src_uv_pitch * 2, dstLine += dst_y_pitch) {

  00288	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR _y$17[ebp], 0
  0028f	eb 2e		 jmp	 SHORT $LN10@convert_yu
$LN8@convert_yu:
  00291	8b 4d 9c	 mov	 ecx, DWORD PTR _y$17[ebp]
  00294	83 c1 02	 add	 ecx, 2
  00297	89 4d 9c	 mov	 DWORD PTR _y$17[ebp], ecx
  0029a	8b 55 ac	 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  0029d	d1 e2		 shl	 edx, 1
  0029f	8b 45 a8	 mov	 eax, DWORD PTR _srcULine$[ebp]
  002a2	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  002a5	89 4d a8	 mov	 DWORD PTR _srcULine$[ebp], ecx
  002a8	8b 55 ac	 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  002ab	d1 e2		 shl	 edx, 1
  002ad	8b 45 a4	 mov	 eax, DWORD PTR _srcVLine$[ebp]
  002b0	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  002b3	89 4d a4	 mov	 DWORD PTR _srcVLine$[ebp], ecx
  002b6	8b 55 a0	 mov	 edx, DWORD PTR _dstLine$[ebp]
  002b9	03 55 e4	 add	 edx, DWORD PTR _dst_y_pitch$[ebp]
  002bc	89 55 a0	 mov	 DWORD PTR _dstLine$[ebp], edx
$LN10@convert_yu:
  002bf	8b 45 9c	 mov	 eax, DWORD PTR _y$17[ebp]
  002c2	3b 45 dc	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  002c5	0f 8d 36 01 00
	00		 jge	 $LN1@convert_yu

; 321  :         Tout *dstC = dstLine;

  002cb	8b 4d a0	 mov	 ecx, DWORD PTR _dstLine$[ebp]
  002ce	89 4d 98	 mov	 DWORD PTR _dstC$16[ebp], ecx

; 322  :         Tin *srcU = srcULine;

  002d1	8b 55 a8	 mov	 edx, DWORD PTR _srcULine$[ebp]
  002d4	89 55 94	 mov	 DWORD PTR _srcU$15[ebp], edx

; 323  :         Tin *srcV = srcVLine;

  002d7	8b 45 a4	 mov	 eax, DWORD PTR _srcVLine$[ebp]
  002da	89 45 90	 mov	 DWORD PTR _srcV$14[ebp], eax

; 324  :         const int x_fin = width - crop_right - crop_left;

  002dd	8b 4d 10	 mov	 ecx, DWORD PTR _width$[ebp]
  002e0	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  002e3	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  002e6	89 4d 8c	 mov	 DWORD PTR _x_fin$13[ebp], ecx

; 325  :         for (int x = 0; x < x_fin; x += 2, dstC += 2, srcU += 2, srcV += 2) {

  002e9	c7 45 88 00 00
	00 00		 mov	 DWORD PTR _x$12[ebp], 0
  002f0	eb 24		 jmp	 SHORT $LN13@convert_yu
$LN11@convert_yu:
  002f2	8b 55 88	 mov	 edx, DWORD PTR _x$12[ebp]
  002f5	83 c2 02	 add	 edx, 2
  002f8	89 55 88	 mov	 DWORD PTR _x$12[ebp], edx
  002fb	8b 45 98	 mov	 eax, DWORD PTR _dstC$16[ebp]
  002fe	83 c0 02	 add	 eax, 2
  00301	89 45 98	 mov	 DWORD PTR _dstC$16[ebp], eax
  00304	8b 4d 94	 mov	 ecx, DWORD PTR _srcU$15[ebp]
  00307	83 c1 04	 add	 ecx, 4
  0030a	89 4d 94	 mov	 DWORD PTR _srcU$15[ebp], ecx
  0030d	8b 55 90	 mov	 edx, DWORD PTR _srcV$14[ebp]
  00310	83 c2 04	 add	 edx, 4
  00313	89 55 90	 mov	 DWORD PTR _srcV$14[ebp], edx
$LN13@convert_yu:
  00316	8b 45 88	 mov	 eax, DWORD PTR _x$12[ebp]
  00319	3b 45 8c	 cmp	 eax, DWORD PTR _x_fin$13[ebp]
  0031c	0f 8d da 00 00
	00		 jge	 $LN12@convert_yu

; 326  :             int cy0u = srcU[0*src_uv_pitch + 0];

  00322	6b 4d ac 00	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 0
  00326	8b 55 94	 mov	 edx, DWORD PTR _srcU$15[ebp]
  00329	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  0032d	89 45 84	 mov	 DWORD PTR _cy0u$11[ebp], eax

; 327  :             int cy0v = srcV[0*src_uv_pitch + 0];

  00330	6b 4d ac 00	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 0
  00334	8b 55 90	 mov	 edx, DWORD PTR _srcV$14[ebp]
  00337	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  0033b	89 45 80	 mov	 DWORD PTR _cy0v$10[ebp], eax

; 328  :             int cy1u = srcU[1*src_uv_pitch + 0];

  0033e	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00341	8b 55 94	 mov	 edx, DWORD PTR _srcU$15[ebp]
  00344	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00348	89 85 7c ff ff
	ff		 mov	 DWORD PTR _cy1u$9[ebp], eax

; 329  :             int cy1v = srcV[1*src_uv_pitch + 0];

  0034e	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00351	8b 55 90	 mov	 edx, DWORD PTR _srcV$14[ebp]
  00354	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00358	89 85 78 ff ff
	ff		 mov	 DWORD PTR _cy1v$8[ebp], eax

; 330  : 
; 331  :             int cu = cy0u + cy1u + 1;

  0035e	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _cy1u$9[ebp]
  00364	8b 55 84	 mov	 edx, DWORD PTR _cy0u$11[ebp]
  00367	8d 44 0a 01	 lea	 eax, DWORD PTR [edx+ecx+1]
  0036b	89 85 74 ff ff
	ff		 mov	 DWORD PTR _cu$7[ebp], eax

; 332  :             int cv = cy0v + cy1v + 1;

  00371	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1v$8[ebp]
  00377	8b 55 80	 mov	 edx, DWORD PTR _cy0v$10[ebp]
  0037a	8d 44 0a 01	 lea	 eax, DWORD PTR [edx+ecx+1]
  0037e	89 85 70 ff ff
	ff		 mov	 DWORD PTR _cv$6[ebp], eax

; 333  :             CHANGE_BIT_DEPTH_2(cu, cv, 1);

  00384	33 c9		 xor	 ecx, ecx
  00386	74 20		 je	 SHORT $LN21@convert_yu
  00388	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _cu$7[ebp]
  0038e	c1 e2 f7	 shl	 edx, -9			; fffffff7H
  00391	89 95 74 ff ff
	ff		 mov	 DWORD PTR _cu$7[ebp], edx
  00397	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _cv$6[ebp]
  0039d	c1 e0 f7	 shl	 eax, -9			; fffffff7H
  003a0	89 85 70 ff ff
	ff		 mov	 DWORD PTR _cv$6[ebp], eax
  003a6	eb 27		 jmp	 SHORT $LN22@convert_yu
$LN21@convert_yu:
  003a8	b9 01 00 00 00	 mov	 ecx, 1
  003ad	85 c9		 test	 ecx, ecx
  003af	74 1e		 je	 SHORT $LN22@convert_yu
  003b1	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _cu$7[ebp]
  003b7	c1 fa 09	 sar	 edx, 9
  003ba	89 95 74 ff ff
	ff		 mov	 DWORD PTR _cu$7[ebp], edx
  003c0	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _cv$6[ebp]
  003c6	c1 f8 09	 sar	 eax, 9
  003c9	89 85 70 ff ff
	ff		 mov	 DWORD PTR _cv$6[ebp], eax
$LN22@convert_yu:

; 334  : 
; 335  :             dstC[0] = (Tout)cu;

  003cf	b9 01 00 00 00	 mov	 ecx, 1
  003d4	6b d1 00	 imul	 edx, ecx, 0
  003d7	8b 45 98	 mov	 eax, DWORD PTR _dstC$16[ebp]
  003da	8a 8d 74 ff ff
	ff		 mov	 cl, BYTE PTR _cu$7[ebp]
  003e0	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 336  :             dstC[1] = (Tout)cv;

  003e3	ba 01 00 00 00	 mov	 edx, 1
  003e8	c1 e2 00	 shl	 edx, 0
  003eb	8b 45 98	 mov	 eax, DWORD PTR _dstC$16[ebp]
  003ee	8a 8d 70 ff ff
	ff		 mov	 cl, BYTE PTR _cv$6[ebp]
  003f4	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 337  :         }

  003f7	e9 f6 fe ff ff	 jmp	 $LN11@convert_yu
$LN12@convert_yu:

; 338  :     }

  003fc	e9 90 fe ff ff	 jmp	 $LN8@convert_yu
$LN1@convert_yu:

; 339  : }

  00401	52		 push	 edx
  00402	8b cd		 mov	 ecx, ebp
  00404	50		 push	 eax
  00405	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN27@convert_yu
  0040b	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00410	58		 pop	 eax
  00411	5a		 pop	 edx
  00412	5f		 pop	 edi
  00413	5b		 pop	 ebx
  00414	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00417	33 cd		 xor	 ecx, ebp
  00419	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0041e	81 c4 ac 00 00
	00		 add	 esp, 172		; 000000acH
  00424	3b ec		 cmp	 ebp, esp
  00426	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0042b	8b e5		 mov	 esp, ebp
  0042d	5d		 pop	 ebp
  0042e	c3		 ret	 0
  0042f	90		 npad	 1
$LN27@convert_yu:
  00430	01 00 00 00	 DD	 1
  00434	00 00 00 00	 DD	 $LN26@convert_yu
$LN26@convert_yu:
  00438	d4 ff ff ff	 DD	 -44			; ffffffd4H
  0043c	0c 00 00 00	 DD	 12			; 0000000cH
  00440	00 00 00 00	 DD	 $LN25@convert_yu
$LN25@convert_yu:
  00444	79		 DB	 121			; 00000079H
  00445	5f		 DB	 95			; 0000005fH
  00446	72		 DB	 114			; 00000072H
  00447	61		 DB	 97			; 00000061H
  00448	6e		 DB	 110			; 0000006eH
  00449	67		 DB	 103			; 00000067H
  0044a	65		 DB	 101			; 00000065H
  0044b	00		 DB	 0
??$convert_yuv444_to_nv12_p_c@G$0BA@E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_to_nv12_p_c<unsigned short,16,unsigned char,8,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuv444_16_to_nv12_p@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_16_to_nv12_p

; 424  : static void convert_yuv444_16_to_nv12_p(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 425  :     convert_yuv444_to_nv12_p_c<uint16_t, 16, uint8_t, 8, false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yuv444_to_nv12_p_c@G$0BA@E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_to_nv12_p_c<unsigned short,16,unsigned char,8,0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 426  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yuv444_16_to_nv12_p@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_16_to_nv12_p
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
$T1 = -200						; size = 4
$T2 = -196						; size = 4
$T3 = -192						; size = 4
$T4 = -188						; size = 4
$T5 = -184						; size = 12
_cv_y1$6 = -172						; size = 4
_cv_y0$7 = -168						; size = 4
_cu_y1$8 = -164						; size = 4
_cu_y0$9 = -160						; size = 4
_cy3v$10 = -156						; size = 4
_cy3u$11 = -152						; size = 4
_cy2v$12 = -148						; size = 4
_cy2u$13 = -144						; size = 4
_cy1v$14 = -140						; size = 4
_cy1u$15 = -136						; size = 4
_cy0v$16 = -132						; size = 4
_cy0u$17 = -128						; size = 4
_x$18 = -124						; size = 4
_x_fin$19 = -120					; size = 4
_srcV$20 = -116						; size = 4
_srcU$21 = -112						; size = 4
_dstC$22 = -108						; size = 4
_y$23 = -104						; size = 4
_uv_fin$ = -100						; size = 4
_dstLine$ = -96						; size = 4
_srcVLine$ = -92					; size = 4
_srcULine$ = -88					; size = 4
_src_uv_pitch$ = -84					; size = 4
_x$24 = -80						; size = 4
_y$25 = -76						; size = 4
_y_width$26 = -72					; size = 4
_dstLine$27 = -68					; size = 4
_srcYLine$28 = -64					; size = 4
$T29 = -60						; size = 12
_y_range$ = -44						; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yuv444_to_nv12_i_c@E$07G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_to_nv12_i_c<unsigned char,8,unsigned short,16,0>

; 342  : static void __forceinline convert_yuv444_to_nv12_i_c(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8d bd 38 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-200]
  00011	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 343  :     static_assert((sizeof(Tin)  == 1 && in_bit_depth  == 8) || (sizeof(Tin)  == 2 && 8 < in_bit_depth  && in_bit_depth  <= 16), "invalid input bit depth.");
; 344  :     static_assert((sizeof(Tout) == 1 && out_bit_depth == 8) || (sizeof(Tout) == 2 && 8 < out_bit_depth && out_bit_depth <= 16), "invalid output bit depth.");
; 345  :     const int crop_left   = crop[0];

  00027	b8 04 00 00 00	 mov	 eax, 4
  0002c	6b c8 00	 imul	 ecx, eax, 0
  0002f	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00032	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00035	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 346  :     const int crop_up     = crop[1];

  00038	b9 04 00 00 00	 mov	 ecx, 4
  0003d	c1 e1 00	 shl	 ecx, 0
  00040	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00043	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00046	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 347  :     const int crop_right  = crop[2];

  00049	b9 04 00 00 00	 mov	 ecx, 4
  0004e	d1 e1		 shl	 ecx, 1
  00050	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00053	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00056	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 348  :     const int crop_bottom = crop[3];

  00059	b9 04 00 00 00	 mov	 ecx, 4
  0005e	6b d1 03	 imul	 edx, ecx, 3
  00061	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00064	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00067	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 349  :     const int src_y_pitch = src_y_pitch_byte / sizeof(Tin);

  0006a	8b 55 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebp]
  0006d	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 350  :     const int dst_y_pitch = dst_y_pitch_byte / sizeof(Tout);

  00070	8b 45 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  00073	d1 e8		 shr	 eax, 1
  00075	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 351  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00078	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0007b	51		 push	 ecx
  0007c	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0007f	52		 push	 edx
  00080	8b 45 20	 mov	 eax, DWORD PTR _height$[ebp]
  00083	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  00086	50		 push	 eax
  00087	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  0008a	51		 push	 ecx
  0008b	8d 95 48 ff ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  00091	52		 push	 edx
  00092	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00097	83 c4 14	 add	 esp, 20			; 00000014H
  0009a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009c	89 4d c4	 mov	 DWORD PTR $T29[ebp], ecx
  0009f	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a2	89 55 c8	 mov	 DWORD PTR $T29[ebp+4], edx
  000a5	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000a8	89 45 cc	 mov	 DWORD PTR $T29[ebp+8], eax
  000ab	8b 4d c4	 mov	 ecx, DWORD PTR $T29[ebp]
  000ae	89 4d d4	 mov	 DWORD PTR _y_range$[ebp], ecx
  000b1	8b 55 c8	 mov	 edx, DWORD PTR $T29[ebp+4]
  000b4	89 55 d8	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000b7	8b 45 cc	 mov	 eax, DWORD PTR $T29[ebp+8]
  000ba	89 45 dc	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 352  :     //Y
; 353  :     if (!uv_only) {

  000bd	b9 01 00 00 00	 mov	 ecx, 1
  000c2	85 c9		 test	 ecx, ecx
  000c4	0f 84 63 01 00
	00		 je	 $LN14@convert_yu

; 354  :         Tin *srcYLine = (Tin *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000ca	ba 04 00 00 00	 mov	 edx, 4
  000cf	6b c2 00	 imul	 eax, edx, 0
  000d2	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  000d5	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  000d9	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  000dc	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  000df	03 c1		 add	 eax, ecx
  000e1	03 45 f8	 add	 eax, DWORD PTR _crop_left$[ebp]
  000e4	89 45 c0	 mov	 DWORD PTR _srcYLine$28[ebp], eax

; 355  :         Tout *dstLine = (Tout *)dst[0] + dst_y_pitch * y_range.start_dst;

  000e7	b9 04 00 00 00	 mov	 ecx, 4
  000ec	6b d1 00	 imul	 edx, ecx, 0
  000ef	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  000f2	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  000f6	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  000f9	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  000fc	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  000ff	89 45 bc	 mov	 DWORD PTR _dstLine$27[ebp], eax

; 356  :         const int y_width = width - crop_right - crop_left;

  00102	8b 4d 10	 mov	 ecx, DWORD PTR _width$[ebp]
  00105	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  00108	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  0010b	89 4d b8	 mov	 DWORD PTR _y_width$26[ebp], ecx

; 357  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  0010e	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _y$25[ebp], 0
  00115	eb 1e		 jmp	 SHORT $LN4@convert_yu
$LN2@convert_yu:
  00117	8b 55 b4	 mov	 edx, DWORD PTR _y$25[ebp]
  0011a	83 c2 01	 add	 edx, 1
  0011d	89 55 b4	 mov	 DWORD PTR _y$25[ebp], edx
  00120	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$28[ebp]
  00123	03 45 e8	 add	 eax, DWORD PTR _src_y_pitch$[ebp]
  00126	89 45 c0	 mov	 DWORD PTR _srcYLine$28[ebp], eax
  00129	8b 4d e4	 mov	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  0012c	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$27[ebp]
  0012f	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  00132	89 45 bc	 mov	 DWORD PTR _dstLine$27[ebp], eax
$LN4@convert_yu:
  00135	8b 4d b4	 mov	 ecx, DWORD PTR _y$25[ebp]
  00138	3b 4d dc	 cmp	 ecx, DWORD PTR _y_range$[ebp+8]
  0013b	0f 8d ec 00 00
	00		 jge	 $LN14@convert_yu

; 358  :             if (in_bit_depth == out_bit_depth && sizeof(Tin) == sizeof(Tout)) {

  00141	33 d2		 xor	 edx, edx
  00143	74 19		 je	 SHORT $LN15@convert_yu

; 359  :                 memcpy(dstLine, srcYLine, y_width * sizeof(Tin));

  00145	8b 45 b8	 mov	 eax, DWORD PTR _y_width$26[ebp]
  00148	50		 push	 eax
  00149	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$28[ebp]
  0014c	51		 push	 ecx
  0014d	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$27[ebp]
  00150	52		 push	 edx
  00151	e8 00 00 00 00	 call	 _memcpy
  00156	83 c4 0c	 add	 esp, 12			; 0000000cH

; 360  :             } else {

  00159	e9 ca 00 00 00	 jmp	 $LN16@convert_yu
$LN15@convert_yu:

; 361  :                 for (int x = 0; x < y_width; x++) {

  0015e	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _x$24[ebp], 0
  00165	eb 09		 jmp	 SHORT $LN7@convert_yu
$LN5@convert_yu:
  00167	8b 45 b0	 mov	 eax, DWORD PTR _x$24[ebp]
  0016a	83 c0 01	 add	 eax, 1
  0016d	89 45 b0	 mov	 DWORD PTR _x$24[ebp], eax
$LN7@convert_yu:
  00170	8b 4d b0	 mov	 ecx, DWORD PTR _x$24[ebp]
  00173	3b 4d b8	 cmp	 ecx, DWORD PTR _y_width$26[ebp]
  00176	0f 8d ac 00 00
	00		 jge	 $LN16@convert_yu

; 362  :                     if (out_bit_depth > in_bit_depth) {

  0017c	ba 01 00 00 00	 mov	 edx, 1
  00181	85 d2		 test	 edx, edx
  00183	74 43		 je	 SHORT $LN17@convert_yu

; 363  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) << std::max(out_bit_depth - in_bit_depth, 0));

  00185	c7 85 44 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], 0
  0018f	c7 85 40 ff ff
	ff 08 00 00 00	 mov	 DWORD PTR $T3[ebp], 8
  00199	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$28[ebp]
  0019c	03 45 b0	 add	 eax, DWORD PTR _x$24[ebp]
  0019f	0f b6 30	 movzx	 esi, BYTE PTR [eax]
  001a2	8d 8d 44 ff ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  001a8	51		 push	 ecx
  001a9	8d 95 40 ff ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  001af	52		 push	 edx
  001b0	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  001b5	83 c4 08	 add	 esp, 8
  001b8	8b 08		 mov	 ecx, DWORD PTR [eax]
  001ba	d3 e6		 shl	 esi, cl
  001bc	8b 45 b0	 mov	 eax, DWORD PTR _x$24[ebp]
  001bf	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$27[ebp]
  001c2	66 89 34 41	 mov	 WORD PTR [ecx+eax*2], si
  001c6	eb 5b		 jmp	 SHORT $LN18@convert_yu
$LN17@convert_yu:

; 364  :                     } else if (out_bit_depth < in_bit_depth) {

  001c8	33 d2		 xor	 edx, edx
  001ca	74 43		 je	 SHORT $LN19@convert_yu

; 365  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) >> std::max(in_bit_depth - out_bit_depth, 0));

  001cc	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], 0
  001d6	c7 85 38 ff ff
	ff f8 ff ff ff	 mov	 DWORD PTR $T1[ebp], -8	; fffffff8H
  001e0	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$28[ebp]
  001e3	03 45 b0	 add	 eax, DWORD PTR _x$24[ebp]
  001e6	0f b6 30	 movzx	 esi, BYTE PTR [eax]
  001e9	8d 8d 3c ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  001ef	51		 push	 ecx
  001f0	8d 95 38 ff ff
	ff		 lea	 edx, DWORD PTR $T1[ebp]
  001f6	52		 push	 edx
  001f7	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  001fc	83 c4 08	 add	 esp, 8
  001ff	8b 08		 mov	 ecx, DWORD PTR [eax]
  00201	d3 fe		 sar	 esi, cl
  00203	8b 45 b0	 mov	 eax, DWORD PTR _x$24[ebp]
  00206	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$27[ebp]
  00209	66 89 34 41	 mov	 WORD PTR [ecx+eax*2], si

; 366  :                     } else {

  0020d	eb 14		 jmp	 SHORT $LN18@convert_yu
$LN19@convert_yu:

; 367  :                         dstLine[x] = (Tout)srcYLine[x];

  0020f	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$28[ebp]
  00212	03 55 b0	 add	 edx, DWORD PTR _x$24[ebp]
  00215	66 0f b6 02	 movzx	 ax, BYTE PTR [edx]
  00219	8b 4d b0	 mov	 ecx, DWORD PTR _x$24[ebp]
  0021c	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$27[ebp]
  0021f	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax
$LN18@convert_yu:

; 368  :                     }
; 369  :                 }

  00223	e9 3f ff ff ff	 jmp	 $LN5@convert_yu
$LN16@convert_yu:

; 370  :             }
; 371  :         }

  00228	e9 ea fe ff ff	 jmp	 $LN2@convert_yu
$LN14@convert_yu:

; 372  :     }
; 373  :     //UV
; 374  :     const int src_uv_pitch = src_uv_pitch_byte / sizeof(Tin);

  0022d	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  00230	89 45 ac	 mov	 DWORD PTR _src_uv_pitch$[ebp], eax

; 375  :     Tin *srcULine = (Tin *)src[1] + ((src_uv_pitch * y_range.start_src) + crop_left);

  00233	b9 04 00 00 00	 mov	 ecx, 4
  00238	c1 e1 00	 shl	 ecx, 0
  0023b	8b 55 ac	 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  0023e	0f af 55 d4	 imul	 edx, DWORD PTR _y_range$[ebp]
  00242	03 55 f8	 add	 edx, DWORD PTR _crop_left$[ebp]
  00245	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  00248	03 14 08	 add	 edx, DWORD PTR [eax+ecx]
  0024b	89 55 a8	 mov	 DWORD PTR _srcULine$[ebp], edx

; 376  :     Tin *srcVLine = (Tin *)src[2] + ((src_uv_pitch * y_range.start_src) + crop_left);

  0024e	b9 04 00 00 00	 mov	 ecx, 4
  00253	d1 e1		 shl	 ecx, 1
  00255	8b 55 ac	 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  00258	0f af 55 d4	 imul	 edx, DWORD PTR _y_range$[ebp]
  0025c	03 55 f8	 add	 edx, DWORD PTR _crop_left$[ebp]
  0025f	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  00262	03 14 08	 add	 edx, DWORD PTR [eax+ecx]
  00265	89 55 a4	 mov	 DWORD PTR _srcVLine$[ebp], edx

; 377  :     Tout *dstLine = (Tout *)dst[1] + (dst_y_pitch >> 1) * y_range.start_dst;

  00268	b9 04 00 00 00	 mov	 ecx, 4
  0026d	c1 e1 00	 shl	 ecx, 0
  00270	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  00273	d1 fa		 sar	 edx, 1
  00275	0f af 55 d8	 imul	 edx, DWORD PTR _y_range$[ebp+4]
  00279	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
  0027c	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  0027f	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  00282	89 55 a0	 mov	 DWORD PTR _dstLine$[ebp], edx

; 378  :     const int uv_fin = height - crop_bottom - crop_up;

  00285	8b 45 20	 mov	 eax, DWORD PTR _height$[ebp]
  00288	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  0028b	2b 45 f4	 sub	 eax, DWORD PTR _crop_up$[ebp]
  0028e	89 45 9c	 mov	 DWORD PTR _uv_fin$[ebp], eax

; 379  :     for (int y = 0; y < y_range.len; y += 4, srcULine += src_uv_pitch * 4, srcVLine += src_uv_pitch * 4, dstLine += dst_y_pitch * 2) {

  00291	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _y$23[ebp], 0
  00298	eb 2f		 jmp	 SHORT $LN10@convert_yu
$LN8@convert_yu:
  0029a	8b 4d 98	 mov	 ecx, DWORD PTR _y$23[ebp]
  0029d	83 c1 04	 add	 ecx, 4
  002a0	89 4d 98	 mov	 DWORD PTR _y$23[ebp], ecx
  002a3	8b 55 ac	 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  002a6	8b 45 a8	 mov	 eax, DWORD PTR _srcULine$[ebp]
  002a9	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  002ac	89 4d a8	 mov	 DWORD PTR _srcULine$[ebp], ecx
  002af	8b 55 ac	 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  002b2	8b 45 a4	 mov	 eax, DWORD PTR _srcVLine$[ebp]
  002b5	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  002b8	89 4d a4	 mov	 DWORD PTR _srcVLine$[ebp], ecx
  002bb	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  002be	d1 e2		 shl	 edx, 1
  002c0	8b 45 a0	 mov	 eax, DWORD PTR _dstLine$[ebp]
  002c3	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  002c6	89 4d a0	 mov	 DWORD PTR _dstLine$[ebp], ecx
$LN10@convert_yu:
  002c9	8b 55 98	 mov	 edx, DWORD PTR _y$23[ebp]
  002cc	3b 55 dc	 cmp	 edx, DWORD PTR _y_range$[ebp+8]
  002cf	0f 8d 08 02 00
	00		 jge	 $LN1@convert_yu

; 380  :         Tout *dstC = dstLine;

  002d5	8b 45 a0	 mov	 eax, DWORD PTR _dstLine$[ebp]
  002d8	89 45 94	 mov	 DWORD PTR _dstC$22[ebp], eax

; 381  :         Tin *srcU = srcULine;

  002db	8b 4d a8	 mov	 ecx, DWORD PTR _srcULine$[ebp]
  002de	89 4d 90	 mov	 DWORD PTR _srcU$21[ebp], ecx

; 382  :         Tin *srcV = srcVLine;

  002e1	8b 55 a4	 mov	 edx, DWORD PTR _srcVLine$[ebp]
  002e4	89 55 8c	 mov	 DWORD PTR _srcV$20[ebp], edx

; 383  :         const int x_fin = width - crop_right - crop_left;

  002e7	8b 45 10	 mov	 eax, DWORD PTR _width$[ebp]
  002ea	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  002ed	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  002f0	89 45 88	 mov	 DWORD PTR _x_fin$19[ebp], eax

; 384  :         for (int x = 0; x < x_fin; x += 2, dstC += 2, srcU += 2, srcV += 2) {

  002f3	c7 45 84 00 00
	00 00		 mov	 DWORD PTR _x$18[ebp], 0
  002fa	eb 24		 jmp	 SHORT $LN13@convert_yu
$LN11@convert_yu:
  002fc	8b 4d 84	 mov	 ecx, DWORD PTR _x$18[ebp]
  002ff	83 c1 02	 add	 ecx, 2
  00302	89 4d 84	 mov	 DWORD PTR _x$18[ebp], ecx
  00305	8b 55 94	 mov	 edx, DWORD PTR _dstC$22[ebp]
  00308	83 c2 04	 add	 edx, 4
  0030b	89 55 94	 mov	 DWORD PTR _dstC$22[ebp], edx
  0030e	8b 45 90	 mov	 eax, DWORD PTR _srcU$21[ebp]
  00311	83 c0 02	 add	 eax, 2
  00314	89 45 90	 mov	 DWORD PTR _srcU$21[ebp], eax
  00317	8b 4d 8c	 mov	 ecx, DWORD PTR _srcV$20[ebp]
  0031a	83 c1 02	 add	 ecx, 2
  0031d	89 4d 8c	 mov	 DWORD PTR _srcV$20[ebp], ecx
$LN13@convert_yu:
  00320	8b 55 84	 mov	 edx, DWORD PTR _x$18[ebp]
  00323	3b 55 88	 cmp	 edx, DWORD PTR _x_fin$19[ebp]
  00326	0f 8d ac 01 00
	00		 jge	 $LN12@convert_yu

; 385  :             int cy0u = srcU[0*src_uv_pitch + 0];

  0032c	6b 45 ac 00	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp], 0
  00330	8b 4d 90	 mov	 ecx, DWORD PTR _srcU$21[ebp]
  00333	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00337	89 55 80	 mov	 DWORD PTR _cy0u$17[ebp], edx

; 386  :             int cy0v = srcV[0*src_uv_pitch + 0];

  0033a	6b 45 ac 00	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp], 0
  0033e	8b 4d 8c	 mov	 ecx, DWORD PTR _srcV$20[ebp]
  00341	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00345	89 95 7c ff ff
	ff		 mov	 DWORD PTR _cy0v$16[ebp], edx

; 387  :             int cy1u = srcU[1*src_uv_pitch + 0];

  0034b	8b 45 90	 mov	 eax, DWORD PTR _srcU$21[ebp]
  0034e	03 45 ac	 add	 eax, DWORD PTR _src_uv_pitch$[ebp]
  00351	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00354	89 8d 78 ff ff
	ff		 mov	 DWORD PTR _cy1u$15[ebp], ecx

; 388  :             int cy1v = srcV[1*src_uv_pitch + 0];

  0035a	8b 55 8c	 mov	 edx, DWORD PTR _srcV$20[ebp]
  0035d	03 55 ac	 add	 edx, DWORD PTR _src_uv_pitch$[ebp]
  00360	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00363	89 85 74 ff ff
	ff		 mov	 DWORD PTR _cy1v$14[ebp], eax

; 389  :             int cy2u = srcU[2*src_uv_pitch + 0];

  00369	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  0036c	8b 55 90	 mov	 edx, DWORD PTR _srcU$21[ebp]
  0036f	0f b6 04 4a	 movzx	 eax, BYTE PTR [edx+ecx*2]
  00373	89 85 70 ff ff
	ff		 mov	 DWORD PTR _cy2u$13[ebp], eax

; 390  :             int cy2v = srcV[2*src_uv_pitch + 0];

  00379	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  0037c	8b 55 8c	 mov	 edx, DWORD PTR _srcV$20[ebp]
  0037f	0f b6 04 4a	 movzx	 eax, BYTE PTR [edx+ecx*2]
  00383	89 85 6c ff ff
	ff		 mov	 DWORD PTR _cy2v$12[ebp], eax

; 391  :             int cy3u = srcU[3*src_uv_pitch + 0];

  00389	6b 4d ac 03	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 3
  0038d	8b 55 90	 mov	 edx, DWORD PTR _srcU$21[ebp]
  00390	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  00394	89 85 68 ff ff
	ff		 mov	 DWORD PTR _cy3u$11[ebp], eax

; 392  :             int cy3v = srcV[3*src_uv_pitch + 0];

  0039a	6b 4d ac 03	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 3
  0039e	8b 55 8c	 mov	 edx, DWORD PTR _srcV$20[ebp]
  003a1	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  003a5	89 85 64 ff ff
	ff		 mov	 DWORD PTR _cy3v$10[ebp], eax

; 393  : 
; 394  :             int cu_y0 = cy0u * 3 + cy2u * 1 + 2;

  003ab	6b 4d 80 03	 imul	 ecx, DWORD PTR _cy0u$17[ebp], 3
  003af	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR _cy2u$13[ebp]
  003b5	8d 44 11 02	 lea	 eax, DWORD PTR [ecx+edx+2]
  003b9	89 85 60 ff ff
	ff		 mov	 DWORD PTR _cu_y0$9[ebp], eax

; 395  :             int cu_y1 = cy1u * 1 + cy3u * 3 + 2;

  003bf	6b 8d 68 ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy3u$11[ebp], 3
  003c6	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _cy1u$15[ebp]
  003cc	8d 44 0a 02	 lea	 eax, DWORD PTR [edx+ecx+2]
  003d0	89 85 5c ff ff
	ff		 mov	 DWORD PTR _cu_y1$8[ebp], eax

; 396  :             int cv_y0 = cy0v * 3 + cy2v * 1 + 2;

  003d6	6b 8d 7c ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy0v$16[ebp], 3
  003dd	8b 95 6c ff ff
	ff		 mov	 edx, DWORD PTR _cy2v$12[ebp]
  003e3	8d 44 11 02	 lea	 eax, DWORD PTR [ecx+edx+2]
  003e7	89 85 58 ff ff
	ff		 mov	 DWORD PTR _cv_y0$7[ebp], eax

; 397  :             int cv_y1 = cy1v * 1 + cy3v * 3 + 2;

  003ed	6b 8d 64 ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy3v$10[ebp], 3
  003f4	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _cy1v$14[ebp]
  003fa	8d 44 0a 02	 lea	 eax, DWORD PTR [edx+ecx+2]
  003fe	89 85 54 ff ff
	ff		 mov	 DWORD PTR _cv_y1$6[ebp], eax

; 398  :             CHANGE_BIT_DEPTH_4(cu_y0, cu_y1, cv_y0, cv_y1, 2);

  00404	b9 01 00 00 00	 mov	 ecx, 1
  00409	85 c9		 test	 ecx, ecx
  0040b	74 3e		 je	 SHORT $LN21@convert_yu
  0040d	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _cu_y0$9[ebp]
  00413	c1 e2 06	 shl	 edx, 6
  00416	89 95 60 ff ff
	ff		 mov	 DWORD PTR _cu_y0$9[ebp], edx
  0041c	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _cu_y1$8[ebp]
  00422	c1 e0 06	 shl	 eax, 6
  00425	89 85 5c ff ff
	ff		 mov	 DWORD PTR _cu_y1$8[ebp], eax
  0042b	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _cv_y0$7[ebp]
  00431	c1 e1 06	 shl	 ecx, 6
  00434	89 8d 58 ff ff
	ff		 mov	 DWORD PTR _cv_y0$7[ebp], ecx
  0043a	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR _cv_y1$6[ebp]
  00440	c1 e2 06	 shl	 edx, 6
  00443	89 95 54 ff ff
	ff		 mov	 DWORD PTR _cv_y1$6[ebp], edx
  00449	eb 40		 jmp	 SHORT $LN22@convert_yu
$LN21@convert_yu:
  0044b	33 c0		 xor	 eax, eax
  0044d	74 3c		 je	 SHORT $LN22@convert_yu
  0044f	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _cu_y0$9[ebp]
  00455	c1 f9 fa	 sar	 ecx, -6			; fffffffaH
  00458	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _cu_y0$9[ebp], ecx
  0045e	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR _cu_y1$8[ebp]
  00464	c1 fa fa	 sar	 edx, -6			; fffffffaH
  00467	89 95 5c ff ff
	ff		 mov	 DWORD PTR _cu_y1$8[ebp], edx
  0046d	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _cv_y0$7[ebp]
  00473	c1 f8 fa	 sar	 eax, -6			; fffffffaH
  00476	89 85 58 ff ff
	ff		 mov	 DWORD PTR _cv_y0$7[ebp], eax
  0047c	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _cv_y1$6[ebp]
  00482	c1 f9 fa	 sar	 ecx, -6			; fffffffaH
  00485	89 8d 54 ff ff
	ff		 mov	 DWORD PTR _cv_y1$6[ebp], ecx
$LN22@convert_yu:

; 399  : 
; 400  :             dstC[0*dst_y_pitch + 0] = (Tout)cu_y0;

  0048b	6b 55 e4 00	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 0
  0048f	8b 45 94	 mov	 eax, DWORD PTR _dstC$22[ebp]
  00492	66 8b 8d 60 ff
	ff ff		 mov	 cx, WORD PTR _cu_y0$9[ebp]
  00499	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx

; 401  :             dstC[0*dst_y_pitch + 1] = (Tout)cv_y0;

  0049d	6b 55 e4 00	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 0
  004a1	8b 45 94	 mov	 eax, DWORD PTR _dstC$22[ebp]
  004a4	66 8b 8d 58 ff
	ff ff		 mov	 cx, WORD PTR _cv_y0$7[ebp]
  004ab	66 89 4c 50 02	 mov	 WORD PTR [eax+edx*2+2], cx

; 402  :             dstC[1*dst_y_pitch + 0] = (Tout)cu_y1;

  004b0	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  004b3	8b 45 94	 mov	 eax, DWORD PTR _dstC$22[ebp]
  004b6	66 8b 8d 5c ff
	ff ff		 mov	 cx, WORD PTR _cu_y1$8[ebp]
  004bd	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx

; 403  :             dstC[1*dst_y_pitch + 1] = (Tout)cv_y1;

  004c1	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  004c4	8b 45 94	 mov	 eax, DWORD PTR _dstC$22[ebp]
  004c7	66 8b 8d 54 ff
	ff ff		 mov	 cx, WORD PTR _cv_y1$6[ebp]
  004ce	66 89 4c 50 02	 mov	 WORD PTR [eax+edx*2+2], cx

; 404  :         }

  004d3	e9 24 fe ff ff	 jmp	 $LN11@convert_yu
$LN12@convert_yu:

; 405  :     }

  004d8	e9 bd fd ff ff	 jmp	 $LN8@convert_yu
$LN1@convert_yu:

; 406  : }

  004dd	52		 push	 edx
  004de	8b cd		 mov	 ecx, ebp
  004e0	50		 push	 eax
  004e1	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN27@convert_yu
  004e7	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  004ec	58		 pop	 eax
  004ed	5a		 pop	 edx
  004ee	5f		 pop	 edi
  004ef	5e		 pop	 esi
  004f0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004f3	33 cd		 xor	 ecx, ebp
  004f5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004fa	81 c4 c8 00 00
	00		 add	 esp, 200		; 000000c8H
  00500	3b ec		 cmp	 ebp, esp
  00502	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00507	8b e5		 mov	 esp, ebp
  00509	5d		 pop	 ebp
  0050a	c3		 ret	 0
  0050b	90		 npad	 1
$LN27@convert_yu:
  0050c	01 00 00 00	 DD	 1
  00510	00 00 00 00	 DD	 $LN26@convert_yu
$LN26@convert_yu:
  00514	d4 ff ff ff	 DD	 -44			; ffffffd4H
  00518	0c 00 00 00	 DD	 12			; 0000000cH
  0051c	00 00 00 00	 DD	 $LN25@convert_yu
$LN25@convert_yu:
  00520	79		 DB	 121			; 00000079H
  00521	5f		 DB	 95			; 0000005fH
  00522	72		 DB	 114			; 00000072H
  00523	61		 DB	 97			; 00000061H
  00524	6e		 DB	 110			; 0000006eH
  00525	67		 DB	 103			; 00000067H
  00526	65		 DB	 101			; 00000065H
  00527	00		 DB	 0
??$convert_yuv444_to_nv12_i_c@E$07G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_to_nv12_i_c<unsigned char,8,unsigned short,16,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuv444_to_p010_i@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_to_p010_i

; 420  : static void convert_yuv444_to_p010_i(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 421  :     convert_yuv444_to_nv12_i_c<uint8_t, 8, uint16_t, 16, false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yuv444_to_nv12_i_c@E$07G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_to_nv12_i_c<unsigned char,8,unsigned short,16,0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 422  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yuv444_to_p010_i@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_to_p010_i
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
$T1 = -172						; size = 4
$T2 = -168						; size = 4
$T3 = -164						; size = 4
$T4 = -160						; size = 4
$T5 = -156						; size = 12
_cv$6 = -144						; size = 4
_cu$7 = -140						; size = 4
_cy1v$8 = -136						; size = 4
_cy1u$9 = -132						; size = 4
_cy0v$10 = -128						; size = 4
_cy0u$11 = -124						; size = 4
_x$12 = -120						; size = 4
_x_fin$13 = -116					; size = 4
_srcV$14 = -112						; size = 4
_srcU$15 = -108						; size = 4
_dstC$16 = -104						; size = 4
_y$17 = -100						; size = 4
_dstLine$ = -96						; size = 4
_srcVLine$ = -92					; size = 4
_srcULine$ = -88					; size = 4
_src_uv_pitch$ = -84					; size = 4
_x$18 = -80						; size = 4
_y$19 = -76						; size = 4
_y_width$20 = -72					; size = 4
_dstLine$21 = -68					; size = 4
_srcYLine$22 = -64					; size = 4
$T23 = -60						; size = 12
_y_range$ = -44						; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yuv444_to_nv12_p_c@E$07G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_to_nv12_p_c<unsigned char,8,unsigned short,16,0>

; 284  : static void __forceinline convert_yuv444_to_nv12_p_c(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec ac 00 00
	00		 sub	 esp, 172		; 000000acH
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8d bd 54 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-172]
  00011	b9 2b 00 00 00	 mov	 ecx, 43			; 0000002bH
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 285  :     static_assert((sizeof(Tin)  == 1 && in_bit_depth  == 8) || (sizeof(Tin)  == 2 && 8 < in_bit_depth  && in_bit_depth  <= 16), "invalid input bit depth.");
; 286  :     static_assert((sizeof(Tout) == 1 && out_bit_depth == 8) || (sizeof(Tout) == 2 && 8 < out_bit_depth && out_bit_depth <= 16), "invalid output bit depth.");
; 287  :     const int crop_left   = crop[0];

  00027	b8 04 00 00 00	 mov	 eax, 4
  0002c	6b c8 00	 imul	 ecx, eax, 0
  0002f	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00032	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00035	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 288  :     const int crop_up     = crop[1];

  00038	b9 04 00 00 00	 mov	 ecx, 4
  0003d	c1 e1 00	 shl	 ecx, 0
  00040	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00043	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00046	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 289  :     const int crop_right  = crop[2];

  00049	b9 04 00 00 00	 mov	 ecx, 4
  0004e	d1 e1		 shl	 ecx, 1
  00050	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00053	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00056	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 290  :     const int crop_bottom = crop[3];

  00059	b9 04 00 00 00	 mov	 ecx, 4
  0005e	6b d1 03	 imul	 edx, ecx, 3
  00061	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00064	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00067	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 291  :     const int src_y_pitch = src_y_pitch_byte / sizeof(Tin);

  0006a	8b 55 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebp]
  0006d	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 292  :     const int dst_y_pitch = dst_y_pitch_byte / sizeof(Tout);

  00070	8b 45 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  00073	d1 e8		 shr	 eax, 1
  00075	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 293  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00078	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0007b	51		 push	 ecx
  0007c	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0007f	52		 push	 edx
  00080	8b 45 20	 mov	 eax, DWORD PTR _height$[ebp]
  00083	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  00086	50		 push	 eax
  00087	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  0008a	51		 push	 ecx
  0008b	8d 95 64 ff ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  00091	52		 push	 edx
  00092	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00097	83 c4 14	 add	 esp, 20			; 00000014H
  0009a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009c	89 4d c4	 mov	 DWORD PTR $T23[ebp], ecx
  0009f	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a2	89 55 c8	 mov	 DWORD PTR $T23[ebp+4], edx
  000a5	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000a8	89 45 cc	 mov	 DWORD PTR $T23[ebp+8], eax
  000ab	8b 4d c4	 mov	 ecx, DWORD PTR $T23[ebp]
  000ae	89 4d d4	 mov	 DWORD PTR _y_range$[ebp], ecx
  000b1	8b 55 c8	 mov	 edx, DWORD PTR $T23[ebp+4]
  000b4	89 55 d8	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000b7	8b 45 cc	 mov	 eax, DWORD PTR $T23[ebp+8]
  000ba	89 45 dc	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 294  :     //Y
; 295  :     if (!uv_only) {

  000bd	b9 01 00 00 00	 mov	 ecx, 1
  000c2	85 c9		 test	 ecx, ecx
  000c4	0f 84 63 01 00
	00		 je	 $LN14@convert_yu

; 296  :         Tin *srcYLine = (Tin *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000ca	ba 04 00 00 00	 mov	 edx, 4
  000cf	6b c2 00	 imul	 eax, edx, 0
  000d2	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  000d5	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  000d9	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  000dc	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  000df	03 c1		 add	 eax, ecx
  000e1	03 45 f8	 add	 eax, DWORD PTR _crop_left$[ebp]
  000e4	89 45 c0	 mov	 DWORD PTR _srcYLine$22[ebp], eax

; 297  :         Tout *dstLine = (Tout *)dst[0] + dst_y_pitch * y_range.start_dst;

  000e7	b9 04 00 00 00	 mov	 ecx, 4
  000ec	6b d1 00	 imul	 edx, ecx, 0
  000ef	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  000f2	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  000f6	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  000f9	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  000fc	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  000ff	89 45 bc	 mov	 DWORD PTR _dstLine$21[ebp], eax

; 298  :         const int y_width = width - crop_right - crop_left;

  00102	8b 4d 10	 mov	 ecx, DWORD PTR _width$[ebp]
  00105	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  00108	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  0010b	89 4d b8	 mov	 DWORD PTR _y_width$20[ebp], ecx

; 299  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  0010e	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _y$19[ebp], 0
  00115	eb 1e		 jmp	 SHORT $LN4@convert_yu
$LN2@convert_yu:
  00117	8b 55 b4	 mov	 edx, DWORD PTR _y$19[ebp]
  0011a	83 c2 01	 add	 edx, 1
  0011d	89 55 b4	 mov	 DWORD PTR _y$19[ebp], edx
  00120	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$22[ebp]
  00123	03 45 e8	 add	 eax, DWORD PTR _src_y_pitch$[ebp]
  00126	89 45 c0	 mov	 DWORD PTR _srcYLine$22[ebp], eax
  00129	8b 4d e4	 mov	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  0012c	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$21[ebp]
  0012f	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  00132	89 45 bc	 mov	 DWORD PTR _dstLine$21[ebp], eax
$LN4@convert_yu:
  00135	8b 4d b4	 mov	 ecx, DWORD PTR _y$19[ebp]
  00138	3b 4d dc	 cmp	 ecx, DWORD PTR _y_range$[ebp+8]
  0013b	0f 8d ec 00 00
	00		 jge	 $LN14@convert_yu

; 300  :             if (in_bit_depth == out_bit_depth && sizeof(Tin) == sizeof(Tout)) {

  00141	33 d2		 xor	 edx, edx
  00143	74 19		 je	 SHORT $LN15@convert_yu

; 301  :                 memcpy(dstLine, srcYLine, y_width * sizeof(Tin));

  00145	8b 45 b8	 mov	 eax, DWORD PTR _y_width$20[ebp]
  00148	50		 push	 eax
  00149	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$22[ebp]
  0014c	51		 push	 ecx
  0014d	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$21[ebp]
  00150	52		 push	 edx
  00151	e8 00 00 00 00	 call	 _memcpy
  00156	83 c4 0c	 add	 esp, 12			; 0000000cH

; 302  :             } else {

  00159	e9 ca 00 00 00	 jmp	 $LN16@convert_yu
$LN15@convert_yu:

; 303  :                 for (int x = 0; x < y_width; x++) {

  0015e	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _x$18[ebp], 0
  00165	eb 09		 jmp	 SHORT $LN7@convert_yu
$LN5@convert_yu:
  00167	8b 45 b0	 mov	 eax, DWORD PTR _x$18[ebp]
  0016a	83 c0 01	 add	 eax, 1
  0016d	89 45 b0	 mov	 DWORD PTR _x$18[ebp], eax
$LN7@convert_yu:
  00170	8b 4d b0	 mov	 ecx, DWORD PTR _x$18[ebp]
  00173	3b 4d b8	 cmp	 ecx, DWORD PTR _y_width$20[ebp]
  00176	0f 8d ac 00 00
	00		 jge	 $LN16@convert_yu

; 304  :                     if (out_bit_depth > in_bit_depth) {

  0017c	ba 01 00 00 00	 mov	 edx, 1
  00181	85 d2		 test	 edx, edx
  00183	74 43		 je	 SHORT $LN17@convert_yu

; 305  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) << std::max(out_bit_depth - in_bit_depth, 0));

  00185	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], 0
  0018f	c7 85 5c ff ff
	ff 08 00 00 00	 mov	 DWORD PTR $T3[ebp], 8
  00199	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$22[ebp]
  0019c	03 45 b0	 add	 eax, DWORD PTR _x$18[ebp]
  0019f	0f b6 30	 movzx	 esi, BYTE PTR [eax]
  001a2	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  001a8	51		 push	 ecx
  001a9	8d 95 5c ff ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  001af	52		 push	 edx
  001b0	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  001b5	83 c4 08	 add	 esp, 8
  001b8	8b 08		 mov	 ecx, DWORD PTR [eax]
  001ba	d3 e6		 shl	 esi, cl
  001bc	8b 45 b0	 mov	 eax, DWORD PTR _x$18[ebp]
  001bf	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$21[ebp]
  001c2	66 89 34 41	 mov	 WORD PTR [ecx+eax*2], si
  001c6	eb 5b		 jmp	 SHORT $LN18@convert_yu
$LN17@convert_yu:

; 306  :                     } else if (out_bit_depth < in_bit_depth) {

  001c8	33 d2		 xor	 edx, edx
  001ca	74 43		 je	 SHORT $LN19@convert_yu

; 307  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) >> std::max(in_bit_depth - out_bit_depth, 0));

  001cc	c7 85 58 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], 0
  001d6	c7 85 54 ff ff
	ff f8 ff ff ff	 mov	 DWORD PTR $T1[ebp], -8	; fffffff8H
  001e0	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$22[ebp]
  001e3	03 45 b0	 add	 eax, DWORD PTR _x$18[ebp]
  001e6	0f b6 30	 movzx	 esi, BYTE PTR [eax]
  001e9	8d 8d 58 ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  001ef	51		 push	 ecx
  001f0	8d 95 54 ff ff
	ff		 lea	 edx, DWORD PTR $T1[ebp]
  001f6	52		 push	 edx
  001f7	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  001fc	83 c4 08	 add	 esp, 8
  001ff	8b 08		 mov	 ecx, DWORD PTR [eax]
  00201	d3 fe		 sar	 esi, cl
  00203	8b 45 b0	 mov	 eax, DWORD PTR _x$18[ebp]
  00206	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$21[ebp]
  00209	66 89 34 41	 mov	 WORD PTR [ecx+eax*2], si

; 308  :                     } else {

  0020d	eb 14		 jmp	 SHORT $LN18@convert_yu
$LN19@convert_yu:

; 309  :                         dstLine[x] = (Tout)srcYLine[x];

  0020f	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$22[ebp]
  00212	03 55 b0	 add	 edx, DWORD PTR _x$18[ebp]
  00215	66 0f b6 02	 movzx	 ax, BYTE PTR [edx]
  00219	8b 4d b0	 mov	 ecx, DWORD PTR _x$18[ebp]
  0021c	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$21[ebp]
  0021f	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax
$LN18@convert_yu:

; 310  :                     }
; 311  :                 }

  00223	e9 3f ff ff ff	 jmp	 $LN5@convert_yu
$LN16@convert_yu:

; 312  :             }
; 313  :         }

  00228	e9 ea fe ff ff	 jmp	 $LN2@convert_yu
$LN14@convert_yu:

; 314  :     }
; 315  :     //UV
; 316  :     const int src_uv_pitch = src_uv_pitch_byte / sizeof(Tin);

  0022d	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  00230	89 45 ac	 mov	 DWORD PTR _src_uv_pitch$[ebp], eax

; 317  :     Tin *srcULine = (Tin *)src[1] + ((src_uv_pitch * y_range.start_src) + crop_left);

  00233	b9 04 00 00 00	 mov	 ecx, 4
  00238	c1 e1 00	 shl	 ecx, 0
  0023b	8b 55 ac	 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  0023e	0f af 55 d4	 imul	 edx, DWORD PTR _y_range$[ebp]
  00242	03 55 f8	 add	 edx, DWORD PTR _crop_left$[ebp]
  00245	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  00248	03 14 08	 add	 edx, DWORD PTR [eax+ecx]
  0024b	89 55 a8	 mov	 DWORD PTR _srcULine$[ebp], edx

; 318  :     Tin *srcVLine = (Tin *)src[2] + ((src_uv_pitch * y_range.start_src) + crop_left);

  0024e	b9 04 00 00 00	 mov	 ecx, 4
  00253	d1 e1		 shl	 ecx, 1
  00255	8b 55 ac	 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  00258	0f af 55 d4	 imul	 edx, DWORD PTR _y_range$[ebp]
  0025c	03 55 f8	 add	 edx, DWORD PTR _crop_left$[ebp]
  0025f	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  00262	03 14 08	 add	 edx, DWORD PTR [eax+ecx]
  00265	89 55 a4	 mov	 DWORD PTR _srcVLine$[ebp], edx

; 319  :     Tout *dstLine = (Tout *)dst[1] + (dst_y_pitch >> 1) * y_range.start_dst;

  00268	b9 04 00 00 00	 mov	 ecx, 4
  0026d	c1 e1 00	 shl	 ecx, 0
  00270	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  00273	d1 fa		 sar	 edx, 1
  00275	0f af 55 d8	 imul	 edx, DWORD PTR _y_range$[ebp+4]
  00279	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
  0027c	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  0027f	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  00282	89 55 a0	 mov	 DWORD PTR _dstLine$[ebp], edx

; 320  :     for (int y = 0; y < y_range.len; y += 2, srcULine += src_uv_pitch * 2, srcVLine += src_uv_pitch * 2, dstLine += dst_y_pitch) {

  00285	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR _y$17[ebp], 0
  0028c	eb 2d		 jmp	 SHORT $LN10@convert_yu
$LN8@convert_yu:
  0028e	8b 45 9c	 mov	 eax, DWORD PTR _y$17[ebp]
  00291	83 c0 02	 add	 eax, 2
  00294	89 45 9c	 mov	 DWORD PTR _y$17[ebp], eax
  00297	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  0029a	8b 55 a8	 mov	 edx, DWORD PTR _srcULine$[ebp]
  0029d	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  002a0	89 45 a8	 mov	 DWORD PTR _srcULine$[ebp], eax
  002a3	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  002a6	8b 55 a4	 mov	 edx, DWORD PTR _srcVLine$[ebp]
  002a9	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  002ac	89 45 a4	 mov	 DWORD PTR _srcVLine$[ebp], eax
  002af	8b 4d e4	 mov	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  002b2	8b 55 a0	 mov	 edx, DWORD PTR _dstLine$[ebp]
  002b5	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  002b8	89 45 a0	 mov	 DWORD PTR _dstLine$[ebp], eax
$LN10@convert_yu:
  002bb	8b 4d 9c	 mov	 ecx, DWORD PTR _y$17[ebp]
  002be	3b 4d dc	 cmp	 ecx, DWORD PTR _y_range$[ebp+8]
  002c1	0f 8d 38 01 00
	00		 jge	 $LN1@convert_yu

; 321  :         Tout *dstC = dstLine;

  002c7	8b 55 a0	 mov	 edx, DWORD PTR _dstLine$[ebp]
  002ca	89 55 98	 mov	 DWORD PTR _dstC$16[ebp], edx

; 322  :         Tin *srcU = srcULine;

  002cd	8b 45 a8	 mov	 eax, DWORD PTR _srcULine$[ebp]
  002d0	89 45 94	 mov	 DWORD PTR _srcU$15[ebp], eax

; 323  :         Tin *srcV = srcVLine;

  002d3	8b 4d a4	 mov	 ecx, DWORD PTR _srcVLine$[ebp]
  002d6	89 4d 90	 mov	 DWORD PTR _srcV$14[ebp], ecx

; 324  :         const int x_fin = width - crop_right - crop_left;

  002d9	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  002dc	2b 55 f0	 sub	 edx, DWORD PTR _crop_right$[ebp]
  002df	2b 55 f8	 sub	 edx, DWORD PTR _crop_left$[ebp]
  002e2	89 55 8c	 mov	 DWORD PTR _x_fin$13[ebp], edx

; 325  :         for (int x = 0; x < x_fin; x += 2, dstC += 2, srcU += 2, srcV += 2) {

  002e5	c7 45 88 00 00
	00 00		 mov	 DWORD PTR _x$12[ebp], 0
  002ec	eb 24		 jmp	 SHORT $LN13@convert_yu
$LN11@convert_yu:
  002ee	8b 45 88	 mov	 eax, DWORD PTR _x$12[ebp]
  002f1	83 c0 02	 add	 eax, 2
  002f4	89 45 88	 mov	 DWORD PTR _x$12[ebp], eax
  002f7	8b 4d 98	 mov	 ecx, DWORD PTR _dstC$16[ebp]
  002fa	83 c1 04	 add	 ecx, 4
  002fd	89 4d 98	 mov	 DWORD PTR _dstC$16[ebp], ecx
  00300	8b 55 94	 mov	 edx, DWORD PTR _srcU$15[ebp]
  00303	83 c2 02	 add	 edx, 2
  00306	89 55 94	 mov	 DWORD PTR _srcU$15[ebp], edx
  00309	8b 45 90	 mov	 eax, DWORD PTR _srcV$14[ebp]
  0030c	83 c0 02	 add	 eax, 2
  0030f	89 45 90	 mov	 DWORD PTR _srcV$14[ebp], eax
$LN13@convert_yu:
  00312	8b 4d 88	 mov	 ecx, DWORD PTR _x$12[ebp]
  00315	3b 4d 8c	 cmp	 ecx, DWORD PTR _x_fin$13[ebp]
  00318	0f 8d dc 00 00
	00		 jge	 $LN12@convert_yu

; 326  :             int cy0u = srcU[0*src_uv_pitch + 0];

  0031e	6b 55 ac 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  00322	8b 45 94	 mov	 eax, DWORD PTR _srcU$15[ebp]
  00325	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  00329	89 4d 84	 mov	 DWORD PTR _cy0u$11[ebp], ecx

; 327  :             int cy0v = srcV[0*src_uv_pitch + 0];

  0032c	6b 55 ac 00	 imul	 edx, DWORD PTR _src_uv_pitch$[ebp], 0
  00330	8b 45 90	 mov	 eax, DWORD PTR _srcV$14[ebp]
  00333	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  00337	89 4d 80	 mov	 DWORD PTR _cy0v$10[ebp], ecx

; 328  :             int cy1u = srcU[1*src_uv_pitch + 0];

  0033a	8b 55 94	 mov	 edx, DWORD PTR _srcU$15[ebp]
  0033d	03 55 ac	 add	 edx, DWORD PTR _src_uv_pitch$[ebp]
  00340	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00343	89 85 7c ff ff
	ff		 mov	 DWORD PTR _cy1u$9[ebp], eax

; 329  :             int cy1v = srcV[1*src_uv_pitch + 0];

  00349	8b 4d 90	 mov	 ecx, DWORD PTR _srcV$14[ebp]
  0034c	03 4d ac	 add	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  0034f	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00352	89 95 78 ff ff
	ff		 mov	 DWORD PTR _cy1v$8[ebp], edx

; 330  : 
; 331  :             int cu = cy0u + cy1u + 1;

  00358	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _cy1u$9[ebp]
  0035e	8b 4d 84	 mov	 ecx, DWORD PTR _cy0u$11[ebp]
  00361	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  00365	89 95 74 ff ff
	ff		 mov	 DWORD PTR _cu$7[ebp], edx

; 332  :             int cv = cy0v + cy1v + 1;

  0036b	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _cy1v$8[ebp]
  00371	8b 4d 80	 mov	 ecx, DWORD PTR _cy0v$10[ebp]
  00374	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  00378	89 95 70 ff ff
	ff		 mov	 DWORD PTR _cv$6[ebp], edx

; 333  :             CHANGE_BIT_DEPTH_2(cu, cv, 1);

  0037e	b8 01 00 00 00	 mov	 eax, 1
  00383	85 c0		 test	 eax, eax
  00385	74 20		 je	 SHORT $LN21@convert_yu
  00387	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _cu$7[ebp]
  0038d	c1 e1 07	 shl	 ecx, 7
  00390	89 8d 74 ff ff
	ff		 mov	 DWORD PTR _cu$7[ebp], ecx
  00396	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR _cv$6[ebp]
  0039c	c1 e2 07	 shl	 edx, 7
  0039f	89 95 70 ff ff
	ff		 mov	 DWORD PTR _cv$6[ebp], edx
  003a5	eb 22		 jmp	 SHORT $LN22@convert_yu
$LN21@convert_yu:
  003a7	33 c0		 xor	 eax, eax
  003a9	74 1e		 je	 SHORT $LN22@convert_yu
  003ab	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _cu$7[ebp]
  003b1	c1 f9 f9	 sar	 ecx, -7			; fffffff9H
  003b4	89 8d 74 ff ff
	ff		 mov	 DWORD PTR _cu$7[ebp], ecx
  003ba	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR _cv$6[ebp]
  003c0	c1 fa f9	 sar	 edx, -7			; fffffff9H
  003c3	89 95 70 ff ff
	ff		 mov	 DWORD PTR _cv$6[ebp], edx
$LN22@convert_yu:

; 334  : 
; 335  :             dstC[0] = (Tout)cu;

  003c9	b8 02 00 00 00	 mov	 eax, 2
  003ce	6b c8 00	 imul	 ecx, eax, 0
  003d1	8b 55 98	 mov	 edx, DWORD PTR _dstC$16[ebp]
  003d4	66 8b 85 74 ff
	ff ff		 mov	 ax, WORD PTR _cu$7[ebp]
  003db	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax

; 336  :             dstC[1] = (Tout)cv;

  003df	b9 02 00 00 00	 mov	 ecx, 2
  003e4	c1 e1 00	 shl	 ecx, 0
  003e7	8b 55 98	 mov	 edx, DWORD PTR _dstC$16[ebp]
  003ea	66 8b 85 70 ff
	ff ff		 mov	 ax, WORD PTR _cv$6[ebp]
  003f1	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax

; 337  :         }

  003f5	e9 f4 fe ff ff	 jmp	 $LN11@convert_yu
$LN12@convert_yu:

; 338  :     }

  003fa	e9 8f fe ff ff	 jmp	 $LN8@convert_yu
$LN1@convert_yu:

; 339  : }

  003ff	52		 push	 edx
  00400	8b cd		 mov	 ecx, ebp
  00402	50		 push	 eax
  00403	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN27@convert_yu
  00409	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0040e	58		 pop	 eax
  0040f	5a		 pop	 edx
  00410	5f		 pop	 edi
  00411	5e		 pop	 esi
  00412	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00415	33 cd		 xor	 ecx, ebp
  00417	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0041c	81 c4 ac 00 00
	00		 add	 esp, 172		; 000000acH
  00422	3b ec		 cmp	 ebp, esp
  00424	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00429	8b e5		 mov	 esp, ebp
  0042b	5d		 pop	 ebp
  0042c	c3		 ret	 0
  0042d	0f 1f 00	 npad	 3
$LN27@convert_yu:
  00430	01 00 00 00	 DD	 1
  00434	00 00 00 00	 DD	 $LN26@convert_yu
$LN26@convert_yu:
  00438	d4 ff ff ff	 DD	 -44			; ffffffd4H
  0043c	0c 00 00 00	 DD	 12			; 0000000cH
  00440	00 00 00 00	 DD	 $LN25@convert_yu
$LN25@convert_yu:
  00444	79		 DB	 121			; 00000079H
  00445	5f		 DB	 95			; 0000005fH
  00446	72		 DB	 114			; 00000072H
  00447	61		 DB	 97			; 00000061H
  00448	6e		 DB	 110			; 0000006eH
  00449	67		 DB	 103			; 00000067H
  0044a	65		 DB	 101			; 00000065H
  0044b	00		 DB	 0
??$convert_yuv444_to_nv12_p_c@E$07G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_to_nv12_p_c<unsigned char,8,unsigned short,16,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuv444_to_p010_p@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_to_p010_p

; 416  : static void convert_yuv444_to_p010_p(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 417  :     convert_yuv444_to_nv12_p_c<uint8_t, 8, uint16_t, 16, false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yuv444_to_nv12_p_c@E$07G$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_to_nv12_p_c<unsigned char,8,unsigned short,16,0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 418  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yuv444_to_p010_p@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_to_p010_p
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
$T1 = -200						; size = 4
$T2 = -196						; size = 4
$T3 = -192						; size = 4
$T4 = -188						; size = 4
$T5 = -184						; size = 12
_cv_y1$6 = -172						; size = 4
_cv_y0$7 = -168						; size = 4
_cu_y1$8 = -164						; size = 4
_cu_y0$9 = -160						; size = 4
_cy3v$10 = -156						; size = 4
_cy3u$11 = -152						; size = 4
_cy2v$12 = -148						; size = 4
_cy2u$13 = -144						; size = 4
_cy1v$14 = -140						; size = 4
_cy1u$15 = -136						; size = 4
_cy0v$16 = -132						; size = 4
_cy0u$17 = -128						; size = 4
_x$18 = -124						; size = 4
_x_fin$19 = -120					; size = 4
_srcV$20 = -116						; size = 4
_srcU$21 = -112						; size = 4
_dstC$22 = -108						; size = 4
_y$23 = -104						; size = 4
_uv_fin$ = -100						; size = 4
_dstLine$ = -96						; size = 4
_srcVLine$ = -92					; size = 4
_srcULine$ = -88					; size = 4
_src_uv_pitch$ = -84					; size = 4
_x$24 = -80						; size = 4
_y$25 = -76						; size = 4
_y_width$26 = -72					; size = 4
_dstLine$27 = -68					; size = 4
_srcYLine$28 = -64					; size = 4
$T29 = -60						; size = 12
_y_range$ = -44						; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yuv444_to_nv12_i_c@E$07E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_to_nv12_i_c<unsigned char,8,unsigned char,8,0>

; 342  : static void __forceinline convert_yuv444_to_nv12_i_c(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  00009	53		 push	 ebx
  0000a	57		 push	 edi
  0000b	8d bd 38 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-200]
  00011	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 343  :     static_assert((sizeof(Tin)  == 1 && in_bit_depth  == 8) || (sizeof(Tin)  == 2 && 8 < in_bit_depth  && in_bit_depth  <= 16), "invalid input bit depth.");
; 344  :     static_assert((sizeof(Tout) == 1 && out_bit_depth == 8) || (sizeof(Tout) == 2 && 8 < out_bit_depth && out_bit_depth <= 16), "invalid output bit depth.");
; 345  :     const int crop_left   = crop[0];

  00027	b8 04 00 00 00	 mov	 eax, 4
  0002c	6b c8 00	 imul	 ecx, eax, 0
  0002f	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00032	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00035	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 346  :     const int crop_up     = crop[1];

  00038	b9 04 00 00 00	 mov	 ecx, 4
  0003d	c1 e1 00	 shl	 ecx, 0
  00040	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00043	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00046	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 347  :     const int crop_right  = crop[2];

  00049	b9 04 00 00 00	 mov	 ecx, 4
  0004e	d1 e1		 shl	 ecx, 1
  00050	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00053	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00056	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 348  :     const int crop_bottom = crop[3];

  00059	b9 04 00 00 00	 mov	 ecx, 4
  0005e	6b d1 03	 imul	 edx, ecx, 3
  00061	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00064	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00067	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 349  :     const int src_y_pitch = src_y_pitch_byte / sizeof(Tin);

  0006a	8b 55 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebp]
  0006d	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 350  :     const int dst_y_pitch = dst_y_pitch_byte / sizeof(Tout);

  00070	8b 45 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  00073	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 351  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00076	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  00079	51		 push	 ecx
  0007a	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0007d	52		 push	 edx
  0007e	8b 45 20	 mov	 eax, DWORD PTR _height$[ebp]
  00081	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  00084	50		 push	 eax
  00085	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  00088	51		 push	 ecx
  00089	8d 95 48 ff ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  0008f	52		 push	 edx
  00090	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00095	83 c4 14	 add	 esp, 20			; 00000014H
  00098	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009a	89 4d c4	 mov	 DWORD PTR $T29[ebp], ecx
  0009d	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a0	89 55 c8	 mov	 DWORD PTR $T29[ebp+4], edx
  000a3	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000a6	89 45 cc	 mov	 DWORD PTR $T29[ebp+8], eax
  000a9	8b 4d c4	 mov	 ecx, DWORD PTR $T29[ebp]
  000ac	89 4d d4	 mov	 DWORD PTR _y_range$[ebp], ecx
  000af	8b 55 c8	 mov	 edx, DWORD PTR $T29[ebp+4]
  000b2	89 55 d8	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000b5	8b 45 cc	 mov	 eax, DWORD PTR $T29[ebp+8]
  000b8	89 45 dc	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 352  :     //Y
; 353  :     if (!uv_only) {

  000bb	b9 01 00 00 00	 mov	 ecx, 1
  000c0	85 c9		 test	 ecx, ecx
  000c2	0f 84 55 01 00
	00		 je	 $LN14@convert_yu

; 354  :         Tin *srcYLine = (Tin *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000c8	ba 04 00 00 00	 mov	 edx, 4
  000cd	6b c2 00	 imul	 eax, edx, 0
  000d0	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  000d3	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  000d7	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  000da	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  000dd	03 c1		 add	 eax, ecx
  000df	03 45 f8	 add	 eax, DWORD PTR _crop_left$[ebp]
  000e2	89 45 c0	 mov	 DWORD PTR _srcYLine$28[ebp], eax

; 355  :         Tout *dstLine = (Tout *)dst[0] + dst_y_pitch * y_range.start_dst;

  000e5	b9 04 00 00 00	 mov	 ecx, 4
  000ea	6b d1 00	 imul	 edx, ecx, 0
  000ed	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  000f0	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  000f4	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  000f7	03 04 11	 add	 eax, DWORD PTR [ecx+edx]
  000fa	89 45 bc	 mov	 DWORD PTR _dstLine$27[ebp], eax

; 356  :         const int y_width = width - crop_right - crop_left;

  000fd	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00100	2b 55 f0	 sub	 edx, DWORD PTR _crop_right$[ebp]
  00103	2b 55 f8	 sub	 edx, DWORD PTR _crop_left$[ebp]
  00106	89 55 b8	 mov	 DWORD PTR _y_width$26[ebp], edx

; 357  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  00109	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _y$25[ebp], 0
  00110	eb 1b		 jmp	 SHORT $LN4@convert_yu
$LN2@convert_yu:
  00112	8b 45 b4	 mov	 eax, DWORD PTR _y$25[ebp]
  00115	83 c0 01	 add	 eax, 1
  00118	89 45 b4	 mov	 DWORD PTR _y$25[ebp], eax
  0011b	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$28[ebp]
  0011e	03 4d e8	 add	 ecx, DWORD PTR _src_y_pitch$[ebp]
  00121	89 4d c0	 mov	 DWORD PTR _srcYLine$28[ebp], ecx
  00124	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$27[ebp]
  00127	03 55 e4	 add	 edx, DWORD PTR _dst_y_pitch$[ebp]
  0012a	89 55 bc	 mov	 DWORD PTR _dstLine$27[ebp], edx
$LN4@convert_yu:
  0012d	8b 45 b4	 mov	 eax, DWORD PTR _y$25[ebp]
  00130	3b 45 dc	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  00133	0f 8d e4 00 00
	00		 jge	 $LN14@convert_yu

; 358  :             if (in_bit_depth == out_bit_depth && sizeof(Tin) == sizeof(Tout)) {

  00139	b9 01 00 00 00	 mov	 ecx, 1
  0013e	85 c9		 test	 ecx, ecx
  00140	74 19		 je	 SHORT $LN15@convert_yu

; 359  :                 memcpy(dstLine, srcYLine, y_width * sizeof(Tin));

  00142	8b 55 b8	 mov	 edx, DWORD PTR _y_width$26[ebp]
  00145	52		 push	 edx
  00146	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$28[ebp]
  00149	50		 push	 eax
  0014a	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$27[ebp]
  0014d	51		 push	 ecx
  0014e	e8 00 00 00 00	 call	 _memcpy
  00153	83 c4 0c	 add	 esp, 12			; 0000000cH

; 360  :             } else {

  00156	e9 bd 00 00 00	 jmp	 $LN16@convert_yu
$LN15@convert_yu:

; 361  :                 for (int x = 0; x < y_width; x++) {

  0015b	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _x$24[ebp], 0
  00162	eb 09		 jmp	 SHORT $LN7@convert_yu
$LN5@convert_yu:
  00164	8b 55 b0	 mov	 edx, DWORD PTR _x$24[ebp]
  00167	83 c2 01	 add	 edx, 1
  0016a	89 55 b0	 mov	 DWORD PTR _x$24[ebp], edx
$LN7@convert_yu:
  0016d	8b 45 b0	 mov	 eax, DWORD PTR _x$24[ebp]
  00170	3b 45 b8	 cmp	 eax, DWORD PTR _y_width$26[ebp]
  00173	0f 8d 9f 00 00
	00		 jge	 $LN16@convert_yu

; 362  :                     if (out_bit_depth > in_bit_depth) {

  00179	33 c9		 xor	 ecx, ecx
  0017b	74 41		 je	 SHORT $LN17@convert_yu

; 363  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) << std::max(out_bit_depth - in_bit_depth, 0));

  0017d	c7 85 44 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], 0
  00187	c7 85 40 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T3[ebp], 0
  00191	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$28[ebp]
  00194	03 55 b0	 add	 edx, DWORD PTR _x$24[ebp]
  00197	0f b6 1a	 movzx	 ebx, BYTE PTR [edx]
  0019a	8d 85 44 ff ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  001a0	50		 push	 eax
  001a1	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  001a7	51		 push	 ecx
  001a8	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  001ad	83 c4 08	 add	 esp, 8
  001b0	8b 08		 mov	 ecx, DWORD PTR [eax]
  001b2	d3 e3		 shl	 ebx, cl
  001b4	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$27[ebp]
  001b7	03 55 b0	 add	 edx, DWORD PTR _x$24[ebp]
  001ba	88 1a		 mov	 BYTE PTR [edx], bl
  001bc	eb 55		 jmp	 SHORT $LN18@convert_yu
$LN17@convert_yu:

; 364  :                     } else if (out_bit_depth < in_bit_depth) {

  001be	33 c0		 xor	 eax, eax
  001c0	74 41		 je	 SHORT $LN19@convert_yu

; 365  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) >> std::max(in_bit_depth - out_bit_depth, 0));

  001c2	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], 0
  001cc	c7 85 38 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T1[ebp], 0
  001d6	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$28[ebp]
  001d9	03 4d b0	 add	 ecx, DWORD PTR _x$24[ebp]
  001dc	0f b6 19	 movzx	 ebx, BYTE PTR [ecx]
  001df	8d 95 3c ff ff
	ff		 lea	 edx, DWORD PTR $T2[ebp]
  001e5	52		 push	 edx
  001e6	8d 85 38 ff ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  001ec	50		 push	 eax
  001ed	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  001f2	83 c4 08	 add	 esp, 8
  001f5	8b 08		 mov	 ecx, DWORD PTR [eax]
  001f7	d3 fb		 sar	 ebx, cl
  001f9	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$27[ebp]
  001fc	03 4d b0	 add	 ecx, DWORD PTR _x$24[ebp]
  001ff	88 19		 mov	 BYTE PTR [ecx], bl

; 366  :                     } else {

  00201	eb 10		 jmp	 SHORT $LN18@convert_yu
$LN19@convert_yu:

; 367  :                         dstLine[x] = (Tout)srcYLine[x];

  00203	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$27[ebp]
  00206	03 55 b0	 add	 edx, DWORD PTR _x$24[ebp]
  00209	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$28[ebp]
  0020c	03 45 b0	 add	 eax, DWORD PTR _x$24[ebp]
  0020f	8a 08		 mov	 cl, BYTE PTR [eax]
  00211	88 0a		 mov	 BYTE PTR [edx], cl
$LN18@convert_yu:

; 368  :                     }
; 369  :                 }

  00213	e9 4c ff ff ff	 jmp	 $LN5@convert_yu
$LN16@convert_yu:

; 370  :             }
; 371  :         }

  00218	e9 f5 fe ff ff	 jmp	 $LN2@convert_yu
$LN14@convert_yu:

; 372  :     }
; 373  :     //UV
; 374  :     const int src_uv_pitch = src_uv_pitch_byte / sizeof(Tin);

  0021d	8b 55 18	 mov	 edx, DWORD PTR _src_uv_pitch_byte$[ebp]
  00220	89 55 ac	 mov	 DWORD PTR _src_uv_pitch$[ebp], edx

; 375  :     Tin *srcULine = (Tin *)src[1] + ((src_uv_pitch * y_range.start_src) + crop_left);

  00223	b8 04 00 00 00	 mov	 eax, 4
  00228	c1 e0 00	 shl	 eax, 0
  0022b	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  0022e	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  00232	03 4d f8	 add	 ecx, DWORD PTR _crop_left$[ebp]
  00235	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  00238	03 0c 02	 add	 ecx, DWORD PTR [edx+eax]
  0023b	89 4d a8	 mov	 DWORD PTR _srcULine$[ebp], ecx

; 376  :     Tin *srcVLine = (Tin *)src[2] + ((src_uv_pitch * y_range.start_src) + crop_left);

  0023e	b8 04 00 00 00	 mov	 eax, 4
  00243	d1 e0		 shl	 eax, 1
  00245	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00248	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  0024c	03 4d f8	 add	 ecx, DWORD PTR _crop_left$[ebp]
  0024f	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  00252	03 0c 02	 add	 ecx, DWORD PTR [edx+eax]
  00255	89 4d a4	 mov	 DWORD PTR _srcVLine$[ebp], ecx

; 377  :     Tout *dstLine = (Tout *)dst[1] + (dst_y_pitch >> 1) * y_range.start_dst;

  00258	b8 04 00 00 00	 mov	 eax, 4
  0025d	c1 e0 00	 shl	 eax, 0
  00260	8b 4d e4	 mov	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  00263	d1 f9		 sar	 ecx, 1
  00265	0f af 4d d8	 imul	 ecx, DWORD PTR _y_range$[ebp+4]
  00269	8b 55 08	 mov	 edx, DWORD PTR _dst$[ebp]
  0026c	03 0c 02	 add	 ecx, DWORD PTR [edx+eax]
  0026f	89 4d a0	 mov	 DWORD PTR _dstLine$[ebp], ecx

; 378  :     const int uv_fin = height - crop_bottom - crop_up;

  00272	8b 45 20	 mov	 eax, DWORD PTR _height$[ebp]
  00275	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  00278	2b 45 f4	 sub	 eax, DWORD PTR _crop_up$[ebp]
  0027b	89 45 9c	 mov	 DWORD PTR _uv_fin$[ebp], eax

; 379  :     for (int y = 0; y < y_range.len; y += 4, srcULine += src_uv_pitch * 4, srcVLine += src_uv_pitch * 4, dstLine += dst_y_pitch * 2) {

  0027e	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _y$23[ebp], 0
  00285	eb 2d		 jmp	 SHORT $LN10@convert_yu
$LN8@convert_yu:
  00287	8b 4d 98	 mov	 ecx, DWORD PTR _y$23[ebp]
  0028a	83 c1 04	 add	 ecx, 4
  0028d	89 4d 98	 mov	 DWORD PTR _y$23[ebp], ecx
  00290	8b 55 ac	 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  00293	8b 45 a8	 mov	 eax, DWORD PTR _srcULine$[ebp]
  00296	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  00299	89 4d a8	 mov	 DWORD PTR _srcULine$[ebp], ecx
  0029c	8b 55 ac	 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  0029f	8b 45 a4	 mov	 eax, DWORD PTR _srcVLine$[ebp]
  002a2	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  002a5	89 4d a4	 mov	 DWORD PTR _srcVLine$[ebp], ecx
  002a8	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  002ab	8b 45 a0	 mov	 eax, DWORD PTR _dstLine$[ebp]
  002ae	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  002b1	89 4d a0	 mov	 DWORD PTR _dstLine$[ebp], ecx
$LN10@convert_yu:
  002b4	8b 55 98	 mov	 edx, DWORD PTR _y$23[ebp]
  002b7	3b 55 dc	 cmp	 edx, DWORD PTR _y_range$[ebp+8]
  002ba	0f 8d fe 01 00
	00		 jge	 $LN1@convert_yu

; 380  :         Tout *dstC = dstLine;

  002c0	8b 45 a0	 mov	 eax, DWORD PTR _dstLine$[ebp]
  002c3	89 45 94	 mov	 DWORD PTR _dstC$22[ebp], eax

; 381  :         Tin *srcU = srcULine;

  002c6	8b 4d a8	 mov	 ecx, DWORD PTR _srcULine$[ebp]
  002c9	89 4d 90	 mov	 DWORD PTR _srcU$21[ebp], ecx

; 382  :         Tin *srcV = srcVLine;

  002cc	8b 55 a4	 mov	 edx, DWORD PTR _srcVLine$[ebp]
  002cf	89 55 8c	 mov	 DWORD PTR _srcV$20[ebp], edx

; 383  :         const int x_fin = width - crop_right - crop_left;

  002d2	8b 45 10	 mov	 eax, DWORD PTR _width$[ebp]
  002d5	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  002d8	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  002db	89 45 88	 mov	 DWORD PTR _x_fin$19[ebp], eax

; 384  :         for (int x = 0; x < x_fin; x += 2, dstC += 2, srcU += 2, srcV += 2) {

  002de	c7 45 84 00 00
	00 00		 mov	 DWORD PTR _x$18[ebp], 0
  002e5	eb 24		 jmp	 SHORT $LN13@convert_yu
$LN11@convert_yu:
  002e7	8b 4d 84	 mov	 ecx, DWORD PTR _x$18[ebp]
  002ea	83 c1 02	 add	 ecx, 2
  002ed	89 4d 84	 mov	 DWORD PTR _x$18[ebp], ecx
  002f0	8b 55 94	 mov	 edx, DWORD PTR _dstC$22[ebp]
  002f3	83 c2 02	 add	 edx, 2
  002f6	89 55 94	 mov	 DWORD PTR _dstC$22[ebp], edx
  002f9	8b 45 90	 mov	 eax, DWORD PTR _srcU$21[ebp]
  002fc	83 c0 02	 add	 eax, 2
  002ff	89 45 90	 mov	 DWORD PTR _srcU$21[ebp], eax
  00302	8b 4d 8c	 mov	 ecx, DWORD PTR _srcV$20[ebp]
  00305	83 c1 02	 add	 ecx, 2
  00308	89 4d 8c	 mov	 DWORD PTR _srcV$20[ebp], ecx
$LN13@convert_yu:
  0030b	8b 55 84	 mov	 edx, DWORD PTR _x$18[ebp]
  0030e	3b 55 88	 cmp	 edx, DWORD PTR _x_fin$19[ebp]
  00311	0f 8d a2 01 00
	00		 jge	 $LN12@convert_yu

; 385  :             int cy0u = srcU[0*src_uv_pitch + 0];

  00317	6b 45 ac 00	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp], 0
  0031b	8b 4d 90	 mov	 ecx, DWORD PTR _srcU$21[ebp]
  0031e	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00322	89 55 80	 mov	 DWORD PTR _cy0u$17[ebp], edx

; 386  :             int cy0v = srcV[0*src_uv_pitch + 0];

  00325	6b 45 ac 00	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp], 0
  00329	8b 4d 8c	 mov	 ecx, DWORD PTR _srcV$20[ebp]
  0032c	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00330	89 95 7c ff ff
	ff		 mov	 DWORD PTR _cy0v$16[ebp], edx

; 387  :             int cy1u = srcU[1*src_uv_pitch + 0];

  00336	8b 45 90	 mov	 eax, DWORD PTR _srcU$21[ebp]
  00339	03 45 ac	 add	 eax, DWORD PTR _src_uv_pitch$[ebp]
  0033c	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0033f	89 8d 78 ff ff
	ff		 mov	 DWORD PTR _cy1u$15[ebp], ecx

; 388  :             int cy1v = srcV[1*src_uv_pitch + 0];

  00345	8b 55 8c	 mov	 edx, DWORD PTR _srcV$20[ebp]
  00348	03 55 ac	 add	 edx, DWORD PTR _src_uv_pitch$[ebp]
  0034b	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0034e	89 85 74 ff ff
	ff		 mov	 DWORD PTR _cy1v$14[ebp], eax

; 389  :             int cy2u = srcU[2*src_uv_pitch + 0];

  00354	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00357	8b 55 90	 mov	 edx, DWORD PTR _srcU$21[ebp]
  0035a	0f b6 04 4a	 movzx	 eax, BYTE PTR [edx+ecx*2]
  0035e	89 85 70 ff ff
	ff		 mov	 DWORD PTR _cy2u$13[ebp], eax

; 390  :             int cy2v = srcV[2*src_uv_pitch + 0];

  00364	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00367	8b 55 8c	 mov	 edx, DWORD PTR _srcV$20[ebp]
  0036a	0f b6 04 4a	 movzx	 eax, BYTE PTR [edx+ecx*2]
  0036e	89 85 6c ff ff
	ff		 mov	 DWORD PTR _cy2v$12[ebp], eax

; 391  :             int cy3u = srcU[3*src_uv_pitch + 0];

  00374	6b 4d ac 03	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 3
  00378	8b 55 90	 mov	 edx, DWORD PTR _srcU$21[ebp]
  0037b	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  0037f	89 85 68 ff ff
	ff		 mov	 DWORD PTR _cy3u$11[ebp], eax

; 392  :             int cy3v = srcV[3*src_uv_pitch + 0];

  00385	6b 4d ac 03	 imul	 ecx, DWORD PTR _src_uv_pitch$[ebp], 3
  00389	8b 55 8c	 mov	 edx, DWORD PTR _srcV$20[ebp]
  0038c	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  00390	89 85 64 ff ff
	ff		 mov	 DWORD PTR _cy3v$10[ebp], eax

; 393  : 
; 394  :             int cu_y0 = cy0u * 3 + cy2u * 1 + 2;

  00396	6b 4d 80 03	 imul	 ecx, DWORD PTR _cy0u$17[ebp], 3
  0039a	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR _cy2u$13[ebp]
  003a0	8d 44 11 02	 lea	 eax, DWORD PTR [ecx+edx+2]
  003a4	89 85 60 ff ff
	ff		 mov	 DWORD PTR _cu_y0$9[ebp], eax

; 395  :             int cu_y1 = cy1u * 1 + cy3u * 3 + 2;

  003aa	6b 8d 68 ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy3u$11[ebp], 3
  003b1	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _cy1u$15[ebp]
  003b7	8d 44 0a 02	 lea	 eax, DWORD PTR [edx+ecx+2]
  003bb	89 85 5c ff ff
	ff		 mov	 DWORD PTR _cu_y1$8[ebp], eax

; 396  :             int cv_y0 = cy0v * 3 + cy2v * 1 + 2;

  003c1	6b 8d 7c ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy0v$16[ebp], 3
  003c8	8b 95 6c ff ff
	ff		 mov	 edx, DWORD PTR _cy2v$12[ebp]
  003ce	8d 44 11 02	 lea	 eax, DWORD PTR [ecx+edx+2]
  003d2	89 85 58 ff ff
	ff		 mov	 DWORD PTR _cv_y0$7[ebp], eax

; 397  :             int cv_y1 = cy1v * 1 + cy3v * 3 + 2;

  003d8	6b 8d 64 ff ff
	ff 03		 imul	 ecx, DWORD PTR _cy3v$10[ebp], 3
  003df	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _cy1v$14[ebp]
  003e5	8d 44 0a 02	 lea	 eax, DWORD PTR [edx+ecx+2]
  003e9	89 85 54 ff ff
	ff		 mov	 DWORD PTR _cv_y1$6[ebp], eax

; 398  :             CHANGE_BIT_DEPTH_4(cu_y0, cu_y1, cv_y0, cv_y1, 2);

  003ef	33 c9		 xor	 ecx, ecx
  003f1	74 3e		 je	 SHORT $LN21@convert_yu
  003f3	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _cu_y0$9[ebp]
  003f9	c1 e2 fe	 shl	 edx, -2			; fffffffeH
  003fc	89 95 60 ff ff
	ff		 mov	 DWORD PTR _cu_y0$9[ebp], edx
  00402	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _cu_y1$8[ebp]
  00408	c1 e0 fe	 shl	 eax, -2			; fffffffeH
  0040b	89 85 5c ff ff
	ff		 mov	 DWORD PTR _cu_y1$8[ebp], eax
  00411	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _cv_y0$7[ebp]
  00417	c1 e1 fe	 shl	 ecx, -2			; fffffffeH
  0041a	89 8d 58 ff ff
	ff		 mov	 DWORD PTR _cv_y0$7[ebp], ecx
  00420	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR _cv_y1$6[ebp]
  00426	c1 e2 fe	 shl	 edx, -2			; fffffffeH
  00429	89 95 54 ff ff
	ff		 mov	 DWORD PTR _cv_y1$6[ebp], edx
  0042f	eb 45		 jmp	 SHORT $LN22@convert_yu
$LN21@convert_yu:
  00431	b8 01 00 00 00	 mov	 eax, 1
  00436	85 c0		 test	 eax, eax
  00438	74 3c		 je	 SHORT $LN22@convert_yu
  0043a	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _cu_y0$9[ebp]
  00440	c1 f9 02	 sar	 ecx, 2
  00443	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _cu_y0$9[ebp], ecx
  00449	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR _cu_y1$8[ebp]
  0044f	c1 fa 02	 sar	 edx, 2
  00452	89 95 5c ff ff
	ff		 mov	 DWORD PTR _cu_y1$8[ebp], edx
  00458	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _cv_y0$7[ebp]
  0045e	c1 f8 02	 sar	 eax, 2
  00461	89 85 58 ff ff
	ff		 mov	 DWORD PTR _cv_y0$7[ebp], eax
  00467	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _cv_y1$6[ebp]
  0046d	c1 f9 02	 sar	 ecx, 2
  00470	89 8d 54 ff ff
	ff		 mov	 DWORD PTR _cv_y1$6[ebp], ecx
$LN22@convert_yu:

; 399  : 
; 400  :             dstC[0*dst_y_pitch + 0] = (Tout)cu_y0;

  00476	6b 55 e4 00	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 0
  0047a	8b 45 94	 mov	 eax, DWORD PTR _dstC$22[ebp]
  0047d	8a 8d 60 ff ff
	ff		 mov	 cl, BYTE PTR _cu_y0$9[ebp]
  00483	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 401  :             dstC[0*dst_y_pitch + 1] = (Tout)cv_y0;

  00486	6b 55 e4 00	 imul	 edx, DWORD PTR _dst_y_pitch$[ebp], 0
  0048a	8b 45 94	 mov	 eax, DWORD PTR _dstC$22[ebp]
  0048d	8a 8d 58 ff ff
	ff		 mov	 cl, BYTE PTR _cv_y0$7[ebp]
  00493	88 4c 10 01	 mov	 BYTE PTR [eax+edx+1], cl

; 402  :             dstC[1*dst_y_pitch + 0] = (Tout)cu_y1;

  00497	8b 55 94	 mov	 edx, DWORD PTR _dstC$22[ebp]
  0049a	03 55 e4	 add	 edx, DWORD PTR _dst_y_pitch$[ebp]
  0049d	8a 85 5c ff ff
	ff		 mov	 al, BYTE PTR _cu_y1$8[ebp]
  004a3	88 02		 mov	 BYTE PTR [edx], al

; 403  :             dstC[1*dst_y_pitch + 1] = (Tout)cv_y1;

  004a5	8b 4d 94	 mov	 ecx, DWORD PTR _dstC$22[ebp]
  004a8	03 4d e4	 add	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  004ab	8a 95 54 ff ff
	ff		 mov	 dl, BYTE PTR _cv_y1$6[ebp]
  004b1	88 51 01	 mov	 BYTE PTR [ecx+1], dl

; 404  :         }

  004b4	e9 2e fe ff ff	 jmp	 $LN11@convert_yu
$LN12@convert_yu:

; 405  :     }

  004b9	e9 c9 fd ff ff	 jmp	 $LN8@convert_yu
$LN1@convert_yu:

; 406  : }

  004be	52		 push	 edx
  004bf	8b cd		 mov	 ecx, ebp
  004c1	50		 push	 eax
  004c2	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN27@convert_yu
  004c8	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  004cd	58		 pop	 eax
  004ce	5a		 pop	 edx
  004cf	5f		 pop	 edi
  004d0	5b		 pop	 ebx
  004d1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004d4	33 cd		 xor	 ecx, ebp
  004d6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004db	81 c4 c8 00 00
	00		 add	 esp, 200		; 000000c8H
  004e1	3b ec		 cmp	 ebp, esp
  004e3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  004e8	8b e5		 mov	 esp, ebp
  004ea	5d		 pop	 ebp
  004eb	c3		 ret	 0
$LN27@convert_yu:
  004ec	01 00 00 00	 DD	 1
  004f0	00 00 00 00	 DD	 $LN26@convert_yu
$LN26@convert_yu:
  004f4	d4 ff ff ff	 DD	 -44			; ffffffd4H
  004f8	0c 00 00 00	 DD	 12			; 0000000cH
  004fc	00 00 00 00	 DD	 $LN25@convert_yu
$LN25@convert_yu:
  00500	79		 DB	 121			; 00000079H
  00501	5f		 DB	 95			; 0000005fH
  00502	72		 DB	 114			; 00000072H
  00503	61		 DB	 97			; 00000061H
  00504	6e		 DB	 110			; 0000006eH
  00505	67		 DB	 103			; 00000067H
  00506	65		 DB	 101			; 00000065H
  00507	00		 DB	 0
??$convert_yuv444_to_nv12_i_c@E$07E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_to_nv12_i_c<unsigned char,8,unsigned char,8,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuv444_to_nv12_i@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_to_nv12_i

; 412  : static void convert_yuv444_to_nv12_i(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 413  :     convert_yuv444_to_nv12_i_c<uint8_t, 8, uint8_t, 8, false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yuv444_to_nv12_i_c@E$07E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_to_nv12_i_c<unsigned char,8,unsigned char,8,0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 414  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yuv444_to_nv12_i@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_to_nv12_i
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
$T1 = -172						; size = 4
$T2 = -168						; size = 4
$T3 = -164						; size = 4
$T4 = -160						; size = 4
$T5 = -156						; size = 12
_cv$6 = -144						; size = 4
_cu$7 = -140						; size = 4
_cy1v$8 = -136						; size = 4
_cy1u$9 = -132						; size = 4
_cy0v$10 = -128						; size = 4
_cy0u$11 = -124						; size = 4
_x$12 = -120						; size = 4
_x_fin$13 = -116					; size = 4
_srcV$14 = -112						; size = 4
_srcU$15 = -108						; size = 4
_dstC$16 = -104						; size = 4
_y$17 = -100						; size = 4
_dstLine$ = -96						; size = 4
_srcVLine$ = -92					; size = 4
_srcULine$ = -88					; size = 4
_src_uv_pitch$ = -84					; size = 4
_x$18 = -80						; size = 4
_y$19 = -76						; size = 4
_y_width$20 = -72					; size = 4
_dstLine$21 = -68					; size = 4
_srcYLine$22 = -64					; size = 4
$T23 = -60						; size = 12
_y_range$ = -44						; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yuv444_to_nv12_p_c@E$07E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_to_nv12_p_c<unsigned char,8,unsigned char,8,0>

; 284  : static void __forceinline convert_yuv444_to_nv12_p_c(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec ac 00 00
	00		 sub	 esp, 172		; 000000acH
  00009	53		 push	 ebx
  0000a	57		 push	 edi
  0000b	8d bd 54 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-172]
  00011	b9 2b 00 00 00	 mov	 ecx, 43			; 0000002bH
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 285  :     static_assert((sizeof(Tin)  == 1 && in_bit_depth  == 8) || (sizeof(Tin)  == 2 && 8 < in_bit_depth  && in_bit_depth  <= 16), "invalid input bit depth.");
; 286  :     static_assert((sizeof(Tout) == 1 && out_bit_depth == 8) || (sizeof(Tout) == 2 && 8 < out_bit_depth && out_bit_depth <= 16), "invalid output bit depth.");
; 287  :     const int crop_left   = crop[0];

  00027	b8 04 00 00 00	 mov	 eax, 4
  0002c	6b c8 00	 imul	 ecx, eax, 0
  0002f	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00032	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00035	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 288  :     const int crop_up     = crop[1];

  00038	b9 04 00 00 00	 mov	 ecx, 4
  0003d	c1 e1 00	 shl	 ecx, 0
  00040	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00043	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00046	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 289  :     const int crop_right  = crop[2];

  00049	b9 04 00 00 00	 mov	 ecx, 4
  0004e	d1 e1		 shl	 ecx, 1
  00050	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  00053	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00056	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 290  :     const int crop_bottom = crop[3];

  00059	b9 04 00 00 00	 mov	 ecx, 4
  0005e	6b d1 03	 imul	 edx, ecx, 3
  00061	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00064	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00067	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 291  :     const int src_y_pitch = src_y_pitch_byte / sizeof(Tin);

  0006a	8b 55 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebp]
  0006d	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 292  :     const int dst_y_pitch = dst_y_pitch_byte / sizeof(Tout);

  00070	8b 45 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  00073	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 293  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00076	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  00079	51		 push	 ecx
  0007a	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0007d	52		 push	 edx
  0007e	8b 45 20	 mov	 eax, DWORD PTR _height$[ebp]
  00081	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  00084	50		 push	 eax
  00085	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  00088	51		 push	 ecx
  00089	8d 95 64 ff ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  0008f	52		 push	 edx
  00090	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00095	83 c4 14	 add	 esp, 20			; 00000014H
  00098	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009a	89 4d c4	 mov	 DWORD PTR $T23[ebp], ecx
  0009d	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a0	89 55 c8	 mov	 DWORD PTR $T23[ebp+4], edx
  000a3	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000a6	89 45 cc	 mov	 DWORD PTR $T23[ebp+8], eax
  000a9	8b 4d c4	 mov	 ecx, DWORD PTR $T23[ebp]
  000ac	89 4d d4	 mov	 DWORD PTR _y_range$[ebp], ecx
  000af	8b 55 c8	 mov	 edx, DWORD PTR $T23[ebp+4]
  000b2	89 55 d8	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000b5	8b 45 cc	 mov	 eax, DWORD PTR $T23[ebp+8]
  000b8	89 45 dc	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 294  :     //Y
; 295  :     if (!uv_only) {

  000bb	b9 01 00 00 00	 mov	 ecx, 1
  000c0	85 c9		 test	 ecx, ecx
  000c2	0f 84 55 01 00
	00		 je	 $LN14@convert_yu

; 296  :         Tin *srcYLine = (Tin *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000c8	ba 04 00 00 00	 mov	 edx, 4
  000cd	6b c2 00	 imul	 eax, edx, 0
  000d0	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  000d3	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  000d7	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  000da	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  000dd	03 c1		 add	 eax, ecx
  000df	03 45 f8	 add	 eax, DWORD PTR _crop_left$[ebp]
  000e2	89 45 c0	 mov	 DWORD PTR _srcYLine$22[ebp], eax

; 297  :         Tout *dstLine = (Tout *)dst[0] + dst_y_pitch * y_range.start_dst;

  000e5	b9 04 00 00 00	 mov	 ecx, 4
  000ea	6b d1 00	 imul	 edx, ecx, 0
  000ed	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  000f0	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  000f4	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  000f7	03 04 11	 add	 eax, DWORD PTR [ecx+edx]
  000fa	89 45 bc	 mov	 DWORD PTR _dstLine$21[ebp], eax

; 298  :         const int y_width = width - crop_right - crop_left;

  000fd	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00100	2b 55 f0	 sub	 edx, DWORD PTR _crop_right$[ebp]
  00103	2b 55 f8	 sub	 edx, DWORD PTR _crop_left$[ebp]
  00106	89 55 b8	 mov	 DWORD PTR _y_width$20[ebp], edx

; 299  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  00109	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _y$19[ebp], 0
  00110	eb 1b		 jmp	 SHORT $LN4@convert_yu
$LN2@convert_yu:
  00112	8b 45 b4	 mov	 eax, DWORD PTR _y$19[ebp]
  00115	83 c0 01	 add	 eax, 1
  00118	89 45 b4	 mov	 DWORD PTR _y$19[ebp], eax
  0011b	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$22[ebp]
  0011e	03 4d e8	 add	 ecx, DWORD PTR _src_y_pitch$[ebp]
  00121	89 4d c0	 mov	 DWORD PTR _srcYLine$22[ebp], ecx
  00124	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$21[ebp]
  00127	03 55 e4	 add	 edx, DWORD PTR _dst_y_pitch$[ebp]
  0012a	89 55 bc	 mov	 DWORD PTR _dstLine$21[ebp], edx
$LN4@convert_yu:
  0012d	8b 45 b4	 mov	 eax, DWORD PTR _y$19[ebp]
  00130	3b 45 dc	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  00133	0f 8d e4 00 00
	00		 jge	 $LN14@convert_yu

; 300  :             if (in_bit_depth == out_bit_depth && sizeof(Tin) == sizeof(Tout)) {

  00139	b9 01 00 00 00	 mov	 ecx, 1
  0013e	85 c9		 test	 ecx, ecx
  00140	74 19		 je	 SHORT $LN15@convert_yu

; 301  :                 memcpy(dstLine, srcYLine, y_width * sizeof(Tin));

  00142	8b 55 b8	 mov	 edx, DWORD PTR _y_width$20[ebp]
  00145	52		 push	 edx
  00146	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$22[ebp]
  00149	50		 push	 eax
  0014a	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$21[ebp]
  0014d	51		 push	 ecx
  0014e	e8 00 00 00 00	 call	 _memcpy
  00153	83 c4 0c	 add	 esp, 12			; 0000000cH

; 302  :             } else {

  00156	e9 bd 00 00 00	 jmp	 $LN16@convert_yu
$LN15@convert_yu:

; 303  :                 for (int x = 0; x < y_width; x++) {

  0015b	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _x$18[ebp], 0
  00162	eb 09		 jmp	 SHORT $LN7@convert_yu
$LN5@convert_yu:
  00164	8b 55 b0	 mov	 edx, DWORD PTR _x$18[ebp]
  00167	83 c2 01	 add	 edx, 1
  0016a	89 55 b0	 mov	 DWORD PTR _x$18[ebp], edx
$LN7@convert_yu:
  0016d	8b 45 b0	 mov	 eax, DWORD PTR _x$18[ebp]
  00170	3b 45 b8	 cmp	 eax, DWORD PTR _y_width$20[ebp]
  00173	0f 8d 9f 00 00
	00		 jge	 $LN16@convert_yu

; 304  :                     if (out_bit_depth > in_bit_depth) {

  00179	33 c9		 xor	 ecx, ecx
  0017b	74 41		 je	 SHORT $LN17@convert_yu

; 305  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) << std::max(out_bit_depth - in_bit_depth, 0));

  0017d	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], 0
  00187	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T3[ebp], 0
  00191	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$22[ebp]
  00194	03 55 b0	 add	 edx, DWORD PTR _x$18[ebp]
  00197	0f b6 1a	 movzx	 ebx, BYTE PTR [edx]
  0019a	8d 85 60 ff ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  001a0	50		 push	 eax
  001a1	8d 8d 5c ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  001a7	51		 push	 ecx
  001a8	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  001ad	83 c4 08	 add	 esp, 8
  001b0	8b 08		 mov	 ecx, DWORD PTR [eax]
  001b2	d3 e3		 shl	 ebx, cl
  001b4	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$21[ebp]
  001b7	03 55 b0	 add	 edx, DWORD PTR _x$18[ebp]
  001ba	88 1a		 mov	 BYTE PTR [edx], bl
  001bc	eb 55		 jmp	 SHORT $LN18@convert_yu
$LN17@convert_yu:

; 306  :                     } else if (out_bit_depth < in_bit_depth) {

  001be	33 c0		 xor	 eax, eax
  001c0	74 41		 je	 SHORT $LN19@convert_yu

; 307  :                         dstLine[x] = (Tout)((int)(srcYLine[x]) >> std::max(in_bit_depth - out_bit_depth, 0));

  001c2	c7 85 58 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], 0
  001cc	c7 85 54 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T1[ebp], 0
  001d6	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$22[ebp]
  001d9	03 4d b0	 add	 ecx, DWORD PTR _x$18[ebp]
  001dc	0f b6 19	 movzx	 ebx, BYTE PTR [ecx]
  001df	8d 95 58 ff ff
	ff		 lea	 edx, DWORD PTR $T2[ebp]
  001e5	52		 push	 edx
  001e6	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  001ec	50		 push	 eax
  001ed	e8 00 00 00 00	 call	 ??$max@H@std@@YAABHABH0@Z ; std::max<int>
  001f2	83 c4 08	 add	 esp, 8
  001f5	8b 08		 mov	 ecx, DWORD PTR [eax]
  001f7	d3 fb		 sar	 ebx, cl
  001f9	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$21[ebp]
  001fc	03 4d b0	 add	 ecx, DWORD PTR _x$18[ebp]
  001ff	88 19		 mov	 BYTE PTR [ecx], bl

; 308  :                     } else {

  00201	eb 10		 jmp	 SHORT $LN18@convert_yu
$LN19@convert_yu:

; 309  :                         dstLine[x] = (Tout)srcYLine[x];

  00203	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$21[ebp]
  00206	03 55 b0	 add	 edx, DWORD PTR _x$18[ebp]
  00209	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$22[ebp]
  0020c	03 45 b0	 add	 eax, DWORD PTR _x$18[ebp]
  0020f	8a 08		 mov	 cl, BYTE PTR [eax]
  00211	88 0a		 mov	 BYTE PTR [edx], cl
$LN18@convert_yu:

; 310  :                     }
; 311  :                 }

  00213	e9 4c ff ff ff	 jmp	 $LN5@convert_yu
$LN16@convert_yu:

; 312  :             }
; 313  :         }

  00218	e9 f5 fe ff ff	 jmp	 $LN2@convert_yu
$LN14@convert_yu:

; 314  :     }
; 315  :     //UV
; 316  :     const int src_uv_pitch = src_uv_pitch_byte / sizeof(Tin);

  0021d	8b 55 18	 mov	 edx, DWORD PTR _src_uv_pitch_byte$[ebp]
  00220	89 55 ac	 mov	 DWORD PTR _src_uv_pitch$[ebp], edx

; 317  :     Tin *srcULine = (Tin *)src[1] + ((src_uv_pitch * y_range.start_src) + crop_left);

  00223	b8 04 00 00 00	 mov	 eax, 4
  00228	c1 e0 00	 shl	 eax, 0
  0022b	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  0022e	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  00232	03 4d f8	 add	 ecx, DWORD PTR _crop_left$[ebp]
  00235	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  00238	03 0c 02	 add	 ecx, DWORD PTR [edx+eax]
  0023b	89 4d a8	 mov	 DWORD PTR _srcULine$[ebp], ecx

; 318  :     Tin *srcVLine = (Tin *)src[2] + ((src_uv_pitch * y_range.start_src) + crop_left);

  0023e	b8 04 00 00 00	 mov	 eax, 4
  00243	d1 e0		 shl	 eax, 1
  00245	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00248	0f af 4d d4	 imul	 ecx, DWORD PTR _y_range$[ebp]
  0024c	03 4d f8	 add	 ecx, DWORD PTR _crop_left$[ebp]
  0024f	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  00252	03 0c 02	 add	 ecx, DWORD PTR [edx+eax]
  00255	89 4d a4	 mov	 DWORD PTR _srcVLine$[ebp], ecx

; 319  :     Tout *dstLine = (Tout *)dst[1] + (dst_y_pitch >> 1) * y_range.start_dst;

  00258	b8 04 00 00 00	 mov	 eax, 4
  0025d	c1 e0 00	 shl	 eax, 0
  00260	8b 4d e4	 mov	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  00263	d1 f9		 sar	 ecx, 1
  00265	0f af 4d d8	 imul	 ecx, DWORD PTR _y_range$[ebp+4]
  00269	8b 55 08	 mov	 edx, DWORD PTR _dst$[ebp]
  0026c	03 0c 02	 add	 ecx, DWORD PTR [edx+eax]
  0026f	89 4d a0	 mov	 DWORD PTR _dstLine$[ebp], ecx

; 320  :     for (int y = 0; y < y_range.len; y += 2, srcULine += src_uv_pitch * 2, srcVLine += src_uv_pitch * 2, dstLine += dst_y_pitch) {

  00272	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR _y$17[ebp], 0
  00279	eb 2a		 jmp	 SHORT $LN10@convert_yu
$LN8@convert_yu:
  0027b	8b 45 9c	 mov	 eax, DWORD PTR _y$17[ebp]
  0027e	83 c0 02	 add	 eax, 2
  00281	89 45 9c	 mov	 DWORD PTR _y$17[ebp], eax
  00284	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00287	8b 55 a8	 mov	 edx, DWORD PTR _srcULine$[ebp]
  0028a	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  0028d	89 45 a8	 mov	 DWORD PTR _srcULine$[ebp], eax
  00290	8b 4d ac	 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00293	8b 55 a4	 mov	 edx, DWORD PTR _srcVLine$[ebp]
  00296	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  00299	89 45 a4	 mov	 DWORD PTR _srcVLine$[ebp], eax
  0029c	8b 4d a0	 mov	 ecx, DWORD PTR _dstLine$[ebp]
  0029f	03 4d e4	 add	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  002a2	89 4d a0	 mov	 DWORD PTR _dstLine$[ebp], ecx
$LN10@convert_yu:
  002a5	8b 55 9c	 mov	 edx, DWORD PTR _y$17[ebp]
  002a8	3b 55 dc	 cmp	 edx, DWORD PTR _y_range$[ebp+8]
  002ab	0f 8d 32 01 00
	00		 jge	 $LN1@convert_yu

; 321  :         Tout *dstC = dstLine;

  002b1	8b 45 a0	 mov	 eax, DWORD PTR _dstLine$[ebp]
  002b4	89 45 98	 mov	 DWORD PTR _dstC$16[ebp], eax

; 322  :         Tin *srcU = srcULine;

  002b7	8b 4d a8	 mov	 ecx, DWORD PTR _srcULine$[ebp]
  002ba	89 4d 94	 mov	 DWORD PTR _srcU$15[ebp], ecx

; 323  :         Tin *srcV = srcVLine;

  002bd	8b 55 a4	 mov	 edx, DWORD PTR _srcVLine$[ebp]
  002c0	89 55 90	 mov	 DWORD PTR _srcV$14[ebp], edx

; 324  :         const int x_fin = width - crop_right - crop_left;

  002c3	8b 45 10	 mov	 eax, DWORD PTR _width$[ebp]
  002c6	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  002c9	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  002cc	89 45 8c	 mov	 DWORD PTR _x_fin$13[ebp], eax

; 325  :         for (int x = 0; x < x_fin; x += 2, dstC += 2, srcU += 2, srcV += 2) {

  002cf	c7 45 88 00 00
	00 00		 mov	 DWORD PTR _x$12[ebp], 0
  002d6	eb 24		 jmp	 SHORT $LN13@convert_yu
$LN11@convert_yu:
  002d8	8b 4d 88	 mov	 ecx, DWORD PTR _x$12[ebp]
  002db	83 c1 02	 add	 ecx, 2
  002de	89 4d 88	 mov	 DWORD PTR _x$12[ebp], ecx
  002e1	8b 55 98	 mov	 edx, DWORD PTR _dstC$16[ebp]
  002e4	83 c2 02	 add	 edx, 2
  002e7	89 55 98	 mov	 DWORD PTR _dstC$16[ebp], edx
  002ea	8b 45 94	 mov	 eax, DWORD PTR _srcU$15[ebp]
  002ed	83 c0 02	 add	 eax, 2
  002f0	89 45 94	 mov	 DWORD PTR _srcU$15[ebp], eax
  002f3	8b 4d 90	 mov	 ecx, DWORD PTR _srcV$14[ebp]
  002f6	83 c1 02	 add	 ecx, 2
  002f9	89 4d 90	 mov	 DWORD PTR _srcV$14[ebp], ecx
$LN13@convert_yu:
  002fc	8b 55 88	 mov	 edx, DWORD PTR _x$12[ebp]
  002ff	3b 55 8c	 cmp	 edx, DWORD PTR _x_fin$13[ebp]
  00302	0f 8d d6 00 00
	00		 jge	 $LN12@convert_yu

; 326  :             int cy0u = srcU[0*src_uv_pitch + 0];

  00308	6b 45 ac 00	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp], 0
  0030c	8b 4d 94	 mov	 ecx, DWORD PTR _srcU$15[ebp]
  0030f	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00313	89 55 84	 mov	 DWORD PTR _cy0u$11[ebp], edx

; 327  :             int cy0v = srcV[0*src_uv_pitch + 0];

  00316	6b 45 ac 00	 imul	 eax, DWORD PTR _src_uv_pitch$[ebp], 0
  0031a	8b 4d 90	 mov	 ecx, DWORD PTR _srcV$14[ebp]
  0031d	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00321	89 55 80	 mov	 DWORD PTR _cy0v$10[ebp], edx

; 328  :             int cy1u = srcU[1*src_uv_pitch + 0];

  00324	8b 45 94	 mov	 eax, DWORD PTR _srcU$15[ebp]
  00327	03 45 ac	 add	 eax, DWORD PTR _src_uv_pitch$[ebp]
  0032a	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0032d	89 8d 7c ff ff
	ff		 mov	 DWORD PTR _cy1u$9[ebp], ecx

; 329  :             int cy1v = srcV[1*src_uv_pitch + 0];

  00333	8b 55 90	 mov	 edx, DWORD PTR _srcV$14[ebp]
  00336	03 55 ac	 add	 edx, DWORD PTR _src_uv_pitch$[ebp]
  00339	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0033c	89 85 78 ff ff
	ff		 mov	 DWORD PTR _cy1v$8[ebp], eax

; 330  : 
; 331  :             int cu = cy0u + cy1u + 1;

  00342	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _cy1u$9[ebp]
  00348	8b 55 84	 mov	 edx, DWORD PTR _cy0u$11[ebp]
  0034b	8d 44 0a 01	 lea	 eax, DWORD PTR [edx+ecx+1]
  0034f	89 85 74 ff ff
	ff		 mov	 DWORD PTR _cu$7[ebp], eax

; 332  :             int cv = cy0v + cy1v + 1;

  00355	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _cy1v$8[ebp]
  0035b	8b 55 80	 mov	 edx, DWORD PTR _cy0v$10[ebp]
  0035e	8d 44 0a 01	 lea	 eax, DWORD PTR [edx+ecx+1]
  00362	89 85 70 ff ff
	ff		 mov	 DWORD PTR _cv$6[ebp], eax

; 333  :             CHANGE_BIT_DEPTH_2(cu, cv, 1);

  00368	33 c9		 xor	 ecx, ecx
  0036a	74 20		 je	 SHORT $LN21@convert_yu
  0036c	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _cu$7[ebp]
  00372	c1 e2 ff	 shl	 edx, -1
  00375	89 95 74 ff ff
	ff		 mov	 DWORD PTR _cu$7[ebp], edx
  0037b	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _cv$6[ebp]
  00381	c1 e0 ff	 shl	 eax, -1
  00384	89 85 70 ff ff
	ff		 mov	 DWORD PTR _cv$6[ebp], eax
  0038a	eb 25		 jmp	 SHORT $LN22@convert_yu
$LN21@convert_yu:
  0038c	b9 01 00 00 00	 mov	 ecx, 1
  00391	85 c9		 test	 ecx, ecx
  00393	74 1c		 je	 SHORT $LN22@convert_yu
  00395	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _cu$7[ebp]
  0039b	d1 fa		 sar	 edx, 1
  0039d	89 95 74 ff ff
	ff		 mov	 DWORD PTR _cu$7[ebp], edx
  003a3	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _cv$6[ebp]
  003a9	d1 f8		 sar	 eax, 1
  003ab	89 85 70 ff ff
	ff		 mov	 DWORD PTR _cv$6[ebp], eax
$LN22@convert_yu:

; 334  : 
; 335  :             dstC[0] = (Tout)cu;

  003b1	b9 01 00 00 00	 mov	 ecx, 1
  003b6	6b d1 00	 imul	 edx, ecx, 0
  003b9	8b 45 98	 mov	 eax, DWORD PTR _dstC$16[ebp]
  003bc	8a 8d 74 ff ff
	ff		 mov	 cl, BYTE PTR _cu$7[ebp]
  003c2	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 336  :             dstC[1] = (Tout)cv;

  003c5	ba 01 00 00 00	 mov	 edx, 1
  003ca	c1 e2 00	 shl	 edx, 0
  003cd	8b 45 98	 mov	 eax, DWORD PTR _dstC$16[ebp]
  003d0	8a 8d 70 ff ff
	ff		 mov	 cl, BYTE PTR _cv$6[ebp]
  003d6	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 337  :         }

  003d9	e9 fa fe ff ff	 jmp	 $LN11@convert_yu
$LN12@convert_yu:

; 338  :     }

  003de	e9 98 fe ff ff	 jmp	 $LN8@convert_yu
$LN1@convert_yu:

; 339  : }

  003e3	52		 push	 edx
  003e4	8b cd		 mov	 ecx, ebp
  003e6	50		 push	 eax
  003e7	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN27@convert_yu
  003ed	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  003f2	58		 pop	 eax
  003f3	5a		 pop	 edx
  003f4	5f		 pop	 edi
  003f5	5b		 pop	 ebx
  003f6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003f9	33 cd		 xor	 ecx, ebp
  003fb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00400	81 c4 ac 00 00
	00		 add	 esp, 172		; 000000acH
  00406	3b ec		 cmp	 ebp, esp
  00408	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0040d	8b e5		 mov	 esp, ebp
  0040f	5d		 pop	 ebp
  00410	c3		 ret	 0
  00411	0f 1f 00	 npad	 3
$LN27@convert_yu:
  00414	01 00 00 00	 DD	 1
  00418	00 00 00 00	 DD	 $LN26@convert_yu
$LN26@convert_yu:
  0041c	d4 ff ff ff	 DD	 -44			; ffffffd4H
  00420	0c 00 00 00	 DD	 12			; 0000000cH
  00424	00 00 00 00	 DD	 $LN25@convert_yu
$LN25@convert_yu:
  00428	79		 DB	 121			; 00000079H
  00429	5f		 DB	 95			; 0000005fH
  0042a	72		 DB	 114			; 00000072H
  0042b	61		 DB	 97			; 00000061H
  0042c	6e		 DB	 110			; 0000006eH
  0042d	67		 DB	 103			; 00000067H
  0042e	65		 DB	 101			; 00000065H
  0042f	00		 DB	 0
??$convert_yuv444_to_nv12_p_c@E$07E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_to_nv12_p_c<unsigned char,8,unsigned char,8,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuv444_to_nv12_p@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_to_nv12_p

; 408  : static void convert_yuv444_to_nv12_p(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 409  :     convert_yuv444_to_nv12_p_c<uint8_t, 8, uint8_t, 8, false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yuv444_to_nv12_p_c@E$07E$07$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_to_nv12_p_c<unsigned char,8,unsigned char,8,0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 410  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yuv444_to_nv12_p@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_to_nv12_p
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
$T1 = -108						; size = 12
_x$2 = -96						; size = 4
_x_fin$3 = -92						; size = 4
_srcP$4 = -88						; size = 4
_dstC$5 = -84						; size = 4
_dstY$6 = -80						; size = 4
_y$7 = -76						; size = 4
_dstCFrame$ = -72					; size = 4
_dstYFrame$ = -68					; size = 4
_srcFrame$ = -64					; size = 4
_src$ = -60						; size = 4
$T8 = -56						; size = 12
_y_range$ = -40						; size = 12
_dst$ = -24						; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst_array$ = 8						; size = 4
_src_array$ = 12					; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuy2_to_nv12_i@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuy2_to_nv12_i

; 223  : void convert_yuy2_to_nv12_i(void **dst_array, const void **src_array, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8d 7d 94	 lea	 edi, DWORD PTR [ebp-108]
  0000b	b9 1b 00 00 00	 mov	 ecx, 27			; 0000001bH
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 224  :     int crop_left   = crop[0];

  00021	b8 04 00 00 00	 mov	 eax, 4
  00026	6b c8 00	 imul	 ecx, eax, 0
  00029	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  0002c	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0002f	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 225  :     int crop_up     = crop[1];

  00032	b9 04 00 00 00	 mov	 ecx, 4
  00037	c1 e1 00	 shl	 ecx, 0
  0003a	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  0003d	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00040	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 226  :     int crop_right  = crop[2];

  00043	b9 04 00 00 00	 mov	 ecx, 4
  00048	d1 e1		 shl	 ecx, 1
  0004a	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  0004d	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00050	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 227  :     int crop_bottom = crop[3];

  00053	b9 04 00 00 00	 mov	 ecx, 4
  00058	6b d1 03	 imul	 edx, ecx, 3
  0005b	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  0005e	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00061	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 228  :     void *dst = dst_array[0];

  00064	ba 04 00 00 00	 mov	 edx, 4
  00069	6b c2 00	 imul	 eax, edx, 0
  0006c	8b 4d 08	 mov	 ecx, DWORD PTR _dst_array$[ebp]
  0006f	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  00072	89 55 e8	 mov	 DWORD PTR _dst$[ebp], edx

; 229  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00075	8b 45 2c	 mov	 eax, DWORD PTR _thread_n$[ebp]
  00078	50		 push	 eax
  00079	8b 4d 28	 mov	 ecx, DWORD PTR _thread_id$[ebp]
  0007c	51		 push	 ecx
  0007d	8b 55 20	 mov	 edx, DWORD PTR _height$[ebp]
  00080	2b 55 ec	 sub	 edx, DWORD PTR _crop_bottom$[ebp]
  00083	52		 push	 edx
  00084	8b 45 f4	 mov	 eax, DWORD PTR _crop_up$[ebp]
  00087	50		 push	 eax
  00088	8d 4d 94	 lea	 ecx, DWORD PTR $T1[ebp]
  0008b	51		 push	 ecx
  0008c	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00091	83 c4 14	 add	 esp, 20			; 00000014H
  00094	8b 10		 mov	 edx, DWORD PTR [eax]
  00096	89 55 c8	 mov	 DWORD PTR $T8[ebp], edx
  00099	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0009c	89 4d cc	 mov	 DWORD PTR $T8[ebp+4], ecx
  0009f	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000a2	89 55 d0	 mov	 DWORD PTR $T8[ebp+8], edx
  000a5	8b 45 c8	 mov	 eax, DWORD PTR $T8[ebp]
  000a8	89 45 d8	 mov	 DWORD PTR _y_range$[ebp], eax
  000ab	8b 4d cc	 mov	 ecx, DWORD PTR $T8[ebp+4]
  000ae	89 4d dc	 mov	 DWORD PTR _y_range$[ebp+4], ecx
  000b1	8b 55 d0	 mov	 edx, DWORD PTR $T8[ebp+8]
  000b4	89 55 e0	 mov	 DWORD PTR _y_range$[ebp+8], edx

; 230  :     const void *src = src_array[0];

  000b7	b8 04 00 00 00	 mov	 eax, 4
  000bc	6b c8 00	 imul	 ecx, eax, 0
  000bf	8b 55 0c	 mov	 edx, DWORD PTR _src_array$[ebp]
  000c2	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  000c5	89 45 c4	 mov	 DWORD PTR _src$[ebp], eax

; 231  :     uint8_t *srcFrame = (uint8_t *)src;

  000c8	8b 4d c4	 mov	 ecx, DWORD PTR _src$[ebp]
  000cb	89 4d c0	 mov	 DWORD PTR _srcFrame$[ebp], ecx

; 232  :     uint8_t *dstYFrame = (uint8_t *)dst;

  000ce	8b 55 e8	 mov	 edx, DWORD PTR _dst$[ebp]
  000d1	89 55 bc	 mov	 DWORD PTR _dstYFrame$[ebp], edx

; 233  :     uint8_t *dstCFrame = dstYFrame + dst_y_pitch_byte * dst_height;

  000d4	8b 45 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  000d7	0f af 45 24	 imul	 eax, DWORD PTR _dst_height$[ebp]
  000db	03 45 bc	 add	 eax, DWORD PTR _dstYFrame$[ebp]
  000de	89 45 b8	 mov	 DWORD PTR _dstCFrame$[ebp], eax

; 234  :     for (int y = y_range.start_dst; y < (y_range.start_dst + y_range.len); y += 4) {

  000e1	8b 4d dc	 mov	 ecx, DWORD PTR _y_range$[ebp+4]
  000e4	89 4d b4	 mov	 DWORD PTR _y$7[ebp], ecx
  000e7	eb 09		 jmp	 SHORT $LN4@convert_yu
$LN2@convert_yu:
  000e9	8b 55 b4	 mov	 edx, DWORD PTR _y$7[ebp]
  000ec	83 c2 04	 add	 edx, 4
  000ef	89 55 b4	 mov	 DWORD PTR _y$7[ebp], edx
$LN4@convert_yu:
  000f2	8b 45 dc	 mov	 eax, DWORD PTR _y_range$[ebp+4]
  000f5	03 45 e0	 add	 eax, DWORD PTR _y_range$[ebp+8]
  000f8	39 45 b4	 cmp	 DWORD PTR _y$7[ebp], eax
  000fb	0f 8d d8 01 00
	00		 jge	 $LN1@convert_yu

; 235  :         uint8_t *dstY = dstYFrame +   dst_y_pitch_byte * y;

  00101	8b 4d 1c	 mov	 ecx, DWORD PTR _dst_y_pitch_byte$[ebp]
  00104	0f af 4d b4	 imul	 ecx, DWORD PTR _y$7[ebp]
  00108	03 4d bc	 add	 ecx, DWORD PTR _dstYFrame$[ebp]
  0010b	89 4d b0	 mov	 DWORD PTR _dstY$6[ebp], ecx

; 236  :         uint8_t *dstC = dstCFrame + ((dst_y_pitch_byte * y) >> 1);

  0010e	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  00111	0f af 55 b4	 imul	 edx, DWORD PTR _y$7[ebp]
  00115	d1 fa		 sar	 edx, 1
  00117	03 55 b8	 add	 edx, DWORD PTR _dstCFrame$[ebp]
  0011a	89 55 ac	 mov	 DWORD PTR _dstC$5[ebp], edx

; 237  :         uint8_t *srcP = srcFrame  +   src_y_pitch_byte * (y + crop_up) + crop_left;

  0011d	8b 45 b4	 mov	 eax, DWORD PTR _y$7[ebp]
  00120	03 45 f4	 add	 eax, DWORD PTR _crop_up$[ebp]
  00123	0f af 45 14	 imul	 eax, DWORD PTR _src_y_pitch_byte$[ebp]
  00127	03 45 c0	 add	 eax, DWORD PTR _srcFrame$[ebp]
  0012a	03 45 f8	 add	 eax, DWORD PTR _crop_left$[ebp]
  0012d	89 45 a8	 mov	 DWORD PTR _srcP$4[ebp], eax

; 238  :         const int x_fin = width - crop_right - crop_left;

  00130	8b 4d 10	 mov	 ecx, DWORD PTR _width$[ebp]
  00133	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  00136	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  00139	89 4d a4	 mov	 DWORD PTR _x_fin$3[ebp], ecx

; 239  :         for (int x = 0; x < x_fin; x += 2, dstY += 2, dstC += 2, srcP += 4) {

  0013c	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR _x$2[ebp], 0
  00143	eb 24		 jmp	 SHORT $LN7@convert_yu
$LN5@convert_yu:
  00145	8b 55 a0	 mov	 edx, DWORD PTR _x$2[ebp]
  00148	83 c2 02	 add	 edx, 2
  0014b	89 55 a0	 mov	 DWORD PTR _x$2[ebp], edx
  0014e	8b 45 b0	 mov	 eax, DWORD PTR _dstY$6[ebp]
  00151	83 c0 02	 add	 eax, 2
  00154	89 45 b0	 mov	 DWORD PTR _dstY$6[ebp], eax
  00157	8b 4d ac	 mov	 ecx, DWORD PTR _dstC$5[ebp]
  0015a	83 c1 02	 add	 ecx, 2
  0015d	89 4d ac	 mov	 DWORD PTR _dstC$5[ebp], ecx
  00160	8b 55 a8	 mov	 edx, DWORD PTR _srcP$4[ebp]
  00163	83 c2 04	 add	 edx, 4
  00166	89 55 a8	 mov	 DWORD PTR _srcP$4[ebp], edx
$LN7@convert_yu:
  00169	8b 45 a0	 mov	 eax, DWORD PTR _x$2[ebp]
  0016c	3b 45 a4	 cmp	 eax, DWORD PTR _x_fin$3[ebp]
  0016f	0f 8d 5f 01 00
	00		 jge	 $LN6@convert_yu

; 240  :             dstY[0*dst_y_pitch_byte   + 0] = srcP[0*src_y_pitch_byte + 0];

  00175	6b 4d 14 00	 imul	 ecx, DWORD PTR _src_y_pitch_byte$[ebp], 0
  00179	6b 55 1c 00	 imul	 edx, DWORD PTR _dst_y_pitch_byte$[ebp], 0
  0017d	8b 45 b0	 mov	 eax, DWORD PTR _dstY$6[ebp]
  00180	8b 75 a8	 mov	 esi, DWORD PTR _srcP$4[ebp]
  00183	8a 0c 0e	 mov	 cl, BYTE PTR [esi+ecx]
  00186	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 241  :             dstY[0*dst_y_pitch_byte   + 1] = srcP[0*src_y_pitch_byte + 2];

  00189	6b 55 14 00	 imul	 edx, DWORD PTR _src_y_pitch_byte$[ebp], 0
  0018d	6b 45 1c 00	 imul	 eax, DWORD PTR _dst_y_pitch_byte$[ebp], 0
  00191	8b 4d b0	 mov	 ecx, DWORD PTR _dstY$6[ebp]
  00194	8b 75 a8	 mov	 esi, DWORD PTR _srcP$4[ebp]
  00197	8a 54 16 02	 mov	 dl, BYTE PTR [esi+edx+2]
  0019b	88 54 01 01	 mov	 BYTE PTR [ecx+eax+1], dl

; 242  :             dstY[1*dst_y_pitch_byte   + 0] = srcP[1*src_y_pitch_byte + 0];

  0019f	8b 45 b0	 mov	 eax, DWORD PTR _dstY$6[ebp]
  001a2	03 45 1c	 add	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  001a5	8b 4d a8	 mov	 ecx, DWORD PTR _srcP$4[ebp]
  001a8	03 4d 14	 add	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  001ab	8a 11		 mov	 dl, BYTE PTR [ecx]
  001ad	88 10		 mov	 BYTE PTR [eax], dl

; 243  :             dstY[1*dst_y_pitch_byte   + 1] = srcP[1*src_y_pitch_byte + 2];

  001af	8b 45 b0	 mov	 eax, DWORD PTR _dstY$6[ebp]
  001b2	03 45 1c	 add	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  001b5	8b 4d a8	 mov	 ecx, DWORD PTR _srcP$4[ebp]
  001b8	03 4d 14	 add	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  001bb	8a 51 02	 mov	 dl, BYTE PTR [ecx+2]
  001be	88 50 01	 mov	 BYTE PTR [eax+1], dl

; 244  :             dstY[2*dst_y_pitch_byte   + 0] = srcP[2*src_y_pitch_byte + 0];

  001c1	8b 45 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  001c4	8b 4d b0	 mov	 ecx, DWORD PTR _dstY$6[ebp]
  001c7	8b 55 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebp]
  001ca	8b 75 a8	 mov	 esi, DWORD PTR _srcP$4[ebp]
  001cd	8a 14 56	 mov	 dl, BYTE PTR [esi+edx*2]
  001d0	88 14 41	 mov	 BYTE PTR [ecx+eax*2], dl

; 245  :             dstY[2*dst_y_pitch_byte   + 1] = srcP[2*src_y_pitch_byte + 2];

  001d3	8b 45 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  001d6	8b 4d b0	 mov	 ecx, DWORD PTR _dstY$6[ebp]
  001d9	8b 55 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebp]
  001dc	8b 75 a8	 mov	 esi, DWORD PTR _srcP$4[ebp]
  001df	8a 54 56 02	 mov	 dl, BYTE PTR [esi+edx*2+2]
  001e3	88 54 41 01	 mov	 BYTE PTR [ecx+eax*2+1], dl

; 246  :             dstY[3*dst_y_pitch_byte   + 0] = srcP[3*src_y_pitch_byte + 0];

  001e7	6b 45 14 03	 imul	 eax, DWORD PTR _src_y_pitch_byte$[ebp], 3
  001eb	6b 4d 1c 03	 imul	 ecx, DWORD PTR _dst_y_pitch_byte$[ebp], 3
  001ef	8b 55 b0	 mov	 edx, DWORD PTR _dstY$6[ebp]
  001f2	8b 75 a8	 mov	 esi, DWORD PTR _srcP$4[ebp]
  001f5	8a 04 06	 mov	 al, BYTE PTR [esi+eax]
  001f8	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 247  :             dstY[3*dst_y_pitch_byte   + 1] = srcP[3*src_y_pitch_byte + 2];

  001fb	6b 4d 14 03	 imul	 ecx, DWORD PTR _src_y_pitch_byte$[ebp], 3
  001ff	6b 55 1c 03	 imul	 edx, DWORD PTR _dst_y_pitch_byte$[ebp], 3
  00203	8b 45 b0	 mov	 eax, DWORD PTR _dstY$6[ebp]
  00206	8b 75 a8	 mov	 esi, DWORD PTR _srcP$4[ebp]
  00209	8a 4c 0e 02	 mov	 cl, BYTE PTR [esi+ecx+2]
  0020d	88 4c 10 01	 mov	 BYTE PTR [eax+edx+1], cl

; 248  :             dstC[0*dst_y_pitch_byte/2 + 0] =(srcP[0*src_y_pitch_byte + 1] * 3 + srcP[2*src_y_pitch_byte + 1] * 1 + 2)>>2;

  00211	6b 55 14 00	 imul	 edx, DWORD PTR _src_y_pitch_byte$[ebp], 0
  00215	8b 45 a8	 mov	 eax, DWORD PTR _srcP$4[ebp]
  00218	0f b6 4c 10 01	 movzx	 ecx, BYTE PTR [eax+edx+1]
  0021d	6b d1 03	 imul	 edx, ecx, 3
  00220	8b 45 14	 mov	 eax, DWORD PTR _src_y_pitch_byte$[ebp]
  00223	8b 4d a8	 mov	 ecx, DWORD PTR _srcP$4[ebp]
  00226	0f b6 44 41 01	 movzx	 eax, BYTE PTR [ecx+eax*2+1]
  0022b	8d 4c 02 02	 lea	 ecx, DWORD PTR [edx+eax+2]
  0022f	c1 f9 02	 sar	 ecx, 2
  00232	6b 45 1c 00	 imul	 eax, DWORD PTR _dst_y_pitch_byte$[ebp], 0
  00236	99		 cdq
  00237	2b c2		 sub	 eax, edx
  00239	d1 f8		 sar	 eax, 1
  0023b	8b 55 ac	 mov	 edx, DWORD PTR _dstC$5[ebp]
  0023e	88 0c 02	 mov	 BYTE PTR [edx+eax], cl

; 249  :             dstC[0*dst_y_pitch_byte/2 + 1] =(srcP[0*src_y_pitch_byte + 3] * 3 + srcP[2*src_y_pitch_byte + 3] * 1 + 2)>>2;

  00241	6b 45 14 00	 imul	 eax, DWORD PTR _src_y_pitch_byte$[ebp], 0
  00245	8b 4d a8	 mov	 ecx, DWORD PTR _srcP$4[ebp]
  00248	0f b6 54 01 03	 movzx	 edx, BYTE PTR [ecx+eax+3]
  0024d	6b c2 03	 imul	 eax, edx, 3
  00250	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00253	8b 55 a8	 mov	 edx, DWORD PTR _srcP$4[ebp]
  00256	0f b6 4c 4a 03	 movzx	 ecx, BYTE PTR [edx+ecx*2+3]
  0025b	8d 4c 08 02	 lea	 ecx, DWORD PTR [eax+ecx+2]
  0025f	c1 f9 02	 sar	 ecx, 2
  00262	6b 45 1c 00	 imul	 eax, DWORD PTR _dst_y_pitch_byte$[ebp], 0
  00266	99		 cdq
  00267	2b c2		 sub	 eax, edx
  00269	d1 f8		 sar	 eax, 1
  0026b	8b 55 ac	 mov	 edx, DWORD PTR _dstC$5[ebp]
  0026e	88 4c 02 01	 mov	 BYTE PTR [edx+eax+1], cl

; 250  :             dstC[1*dst_y_pitch_byte/2 + 0] =(srcP[1*src_y_pitch_byte + 1] * 1 + srcP[3*src_y_pitch_byte + 1] * 3 + 2)>>2;

  00272	8b 45 a8	 mov	 eax, DWORD PTR _srcP$4[ebp]
  00275	03 45 14	 add	 eax, DWORD PTR _src_y_pitch_byte$[ebp]
  00278	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  0027c	6b 55 14 03	 imul	 edx, DWORD PTR _src_y_pitch_byte$[ebp], 3
  00280	8b 45 a8	 mov	 eax, DWORD PTR _srcP$4[ebp]
  00283	0f b6 54 10 01	 movzx	 edx, BYTE PTR [eax+edx+1]
  00288	6b c2 03	 imul	 eax, edx, 3
  0028b	8d 4c 01 02	 lea	 ecx, DWORD PTR [ecx+eax+2]
  0028f	c1 f9 02	 sar	 ecx, 2
  00292	8b 45 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  00295	99		 cdq
  00296	2b c2		 sub	 eax, edx
  00298	d1 f8		 sar	 eax, 1
  0029a	8b 55 ac	 mov	 edx, DWORD PTR _dstC$5[ebp]
  0029d	88 0c 02	 mov	 BYTE PTR [edx+eax], cl

; 251  :             dstC[1*dst_y_pitch_byte/2 + 1] =(srcP[1*src_y_pitch_byte + 3] * 1 + srcP[3*src_y_pitch_byte + 3] * 3 + 2)>>2;

  002a0	8b 45 a8	 mov	 eax, DWORD PTR _srcP$4[ebp]
  002a3	03 45 14	 add	 eax, DWORD PTR _src_y_pitch_byte$[ebp]
  002a6	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  002aa	6b 55 14 03	 imul	 edx, DWORD PTR _src_y_pitch_byte$[ebp], 3
  002ae	8b 45 a8	 mov	 eax, DWORD PTR _srcP$4[ebp]
  002b1	0f b6 54 10 03	 movzx	 edx, BYTE PTR [eax+edx+3]
  002b6	6b c2 03	 imul	 eax, edx, 3
  002b9	8d 4c 01 02	 lea	 ecx, DWORD PTR [ecx+eax+2]
  002bd	c1 f9 02	 sar	 ecx, 2
  002c0	8b 45 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  002c3	99		 cdq
  002c4	2b c2		 sub	 eax, edx
  002c6	d1 f8		 sar	 eax, 1
  002c8	8b 55 ac	 mov	 edx, DWORD PTR _dstC$5[ebp]
  002cb	88 4c 02 01	 mov	 BYTE PTR [edx+eax+1], cl

; 252  :         }

  002cf	e9 71 fe ff ff	 jmp	 $LN5@convert_yu
$LN6@convert_yu:

; 253  :     }

  002d4	e9 10 fe ff ff	 jmp	 $LN2@convert_yu
$LN1@convert_yu:

; 254  : }

  002d9	52		 push	 edx
  002da	8b cd		 mov	 ecx, ebp
  002dc	50		 push	 eax
  002dd	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN11@convert_yu
  002e3	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  002e8	58		 pop	 eax
  002e9	5a		 pop	 edx
  002ea	5f		 pop	 edi
  002eb	5e		 pop	 esi
  002ec	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002ef	33 cd		 xor	 ecx, ebp
  002f1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002f6	83 c4 6c	 add	 esp, 108		; 0000006cH
  002f9	3b ec		 cmp	 ebp, esp
  002fb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00300	8b e5		 mov	 esp, ebp
  00302	5d		 pop	 ebp
  00303	c3		 ret	 0
$LN11@convert_yu:
  00304	01 00 00 00	 DD	 1
  00308	00 00 00 00	 DD	 $LN10@convert_yu
$LN10@convert_yu:
  0030c	d8 ff ff ff	 DD	 -40			; ffffffd8H
  00310	0c 00 00 00	 DD	 12			; 0000000cH
  00314	00 00 00 00	 DD	 $LN9@convert_yu
$LN9@convert_yu:
  00318	79		 DB	 121			; 00000079H
  00319	5f		 DB	 95			; 0000005fH
  0031a	72		 DB	 114			; 00000072H
  0031b	61		 DB	 97			; 00000061H
  0031c	6e		 DB	 110			; 0000006eH
  0031d	67		 DB	 103			; 00000067H
  0031e	65		 DB	 101			; 00000065H
  0031f	00		 DB	 0
?convert_yuy2_to_nv12_i@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuy2_to_nv12_i
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
$T1 = -108						; size = 12
_x$2 = -96						; size = 4
_x_fin$3 = -92						; size = 4
_srcP$4 = -88						; size = 4
_dstC$5 = -84						; size = 4
_dstY$6 = -80						; size = 4
_y$7 = -76						; size = 4
_dstCFrame$ = -72					; size = 4
_dstYFrame$ = -68					; size = 4
_srcFrame$ = -64					; size = 4
$T8 = -60						; size = 12
_y_range$ = -44						; size = 12
_src$ = -28						; size = 4
_dst$ = -24						; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst_array$ = 8						; size = 4
_src_array$ = 12					; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuy2_to_nv12@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC	; convert_yuy2_to_nv12

; 195  : void convert_yuy2_to_nv12(void **dst_array, const void **src_array, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8d 7d 94	 lea	 edi, DWORD PTR [ebp-108]
  0000b	b9 1b 00 00 00	 mov	 ecx, 27			; 0000001bH
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 196  :     int crop_left   = crop[0];

  00021	b8 04 00 00 00	 mov	 eax, 4
  00026	6b c8 00	 imul	 ecx, eax, 0
  00029	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  0002c	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0002f	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 197  :     int crop_up     = crop[1];

  00032	b9 04 00 00 00	 mov	 ecx, 4
  00037	c1 e1 00	 shl	 ecx, 0
  0003a	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  0003d	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00040	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 198  :     int crop_right  = crop[2];

  00043	b9 04 00 00 00	 mov	 ecx, 4
  00048	d1 e1		 shl	 ecx, 1
  0004a	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  0004d	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00050	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 199  :     int crop_bottom = crop[3];

  00053	b9 04 00 00 00	 mov	 ecx, 4
  00058	6b d1 03	 imul	 edx, ecx, 3
  0005b	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  0005e	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00061	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 200  :     void *dst = dst_array[0];

  00064	ba 04 00 00 00	 mov	 edx, 4
  00069	6b c2 00	 imul	 eax, edx, 0
  0006c	8b 4d 08	 mov	 ecx, DWORD PTR _dst_array$[ebp]
  0006f	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  00072	89 55 e8	 mov	 DWORD PTR _dst$[ebp], edx

; 201  :     const void *src = src_array[0];

  00075	b8 04 00 00 00	 mov	 eax, 4
  0007a	6b c8 00	 imul	 ecx, eax, 0
  0007d	8b 55 0c	 mov	 edx, DWORD PTR _src_array$[ebp]
  00080	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00083	89 45 e4	 mov	 DWORD PTR _src$[ebp], eax

; 202  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00086	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  00089	51		 push	 ecx
  0008a	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0008d	52		 push	 edx
  0008e	8b 45 20	 mov	 eax, DWORD PTR _height$[ebp]
  00091	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  00094	50		 push	 eax
  00095	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  00098	51		 push	 ecx
  00099	8d 55 94	 lea	 edx, DWORD PTR $T1[ebp]
  0009c	52		 push	 edx
  0009d	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  000a2	83 c4 14	 add	 esp, 20			; 00000014H
  000a5	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a7	89 4d c4	 mov	 DWORD PTR $T8[ebp], ecx
  000aa	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000ad	89 55 c8	 mov	 DWORD PTR $T8[ebp+4], edx
  000b0	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000b3	89 45 cc	 mov	 DWORD PTR $T8[ebp+8], eax
  000b6	8b 4d c4	 mov	 ecx, DWORD PTR $T8[ebp]
  000b9	89 4d d4	 mov	 DWORD PTR _y_range$[ebp], ecx
  000bc	8b 55 c8	 mov	 edx, DWORD PTR $T8[ebp+4]
  000bf	89 55 d8	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000c2	8b 45 cc	 mov	 eax, DWORD PTR $T8[ebp+8]
  000c5	89 45 dc	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 203  :     uint8_t *srcFrame = (uint8_t *)src;

  000c8	8b 4d e4	 mov	 ecx, DWORD PTR _src$[ebp]
  000cb	89 4d c0	 mov	 DWORD PTR _srcFrame$[ebp], ecx

; 204  :     uint8_t *dstYFrame = (uint8_t *)dst;

  000ce	8b 55 e8	 mov	 edx, DWORD PTR _dst$[ebp]
  000d1	89 55 bc	 mov	 DWORD PTR _dstYFrame$[ebp], edx

; 205  :     uint8_t *dstCFrame = dstYFrame + dst_y_pitch_byte * dst_height;

  000d4	8b 45 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  000d7	0f af 45 24	 imul	 eax, DWORD PTR _dst_height$[ebp]
  000db	03 45 bc	 add	 eax, DWORD PTR _dstYFrame$[ebp]
  000de	89 45 b8	 mov	 DWORD PTR _dstCFrame$[ebp], eax

; 206  :     for (int y = y_range.start_dst; y < (y_range.start_dst + y_range.len); y += 2) {

  000e1	8b 4d d8	 mov	 ecx, DWORD PTR _y_range$[ebp+4]
  000e4	89 4d b4	 mov	 DWORD PTR _y$7[ebp], ecx
  000e7	eb 09		 jmp	 SHORT $LN4@convert_yu
$LN2@convert_yu:
  000e9	8b 55 b4	 mov	 edx, DWORD PTR _y$7[ebp]
  000ec	83 c2 02	 add	 edx, 2
  000ef	89 55 b4	 mov	 DWORD PTR _y$7[ebp], edx
$LN4@convert_yu:
  000f2	8b 45 d8	 mov	 eax, DWORD PTR _y_range$[ebp+4]
  000f5	03 45 dc	 add	 eax, DWORD PTR _y_range$[ebp+8]
  000f8	39 45 b4	 cmp	 DWORD PTR _y$7[ebp], eax
  000fb	0f 8d 2b 01 00
	00		 jge	 $LN1@convert_yu

; 207  :         uint8_t *dstY = dstYFrame +   dst_y_pitch_byte * y;

  00101	8b 4d 1c	 mov	 ecx, DWORD PTR _dst_y_pitch_byte$[ebp]
  00104	0f af 4d b4	 imul	 ecx, DWORD PTR _y$7[ebp]
  00108	03 4d bc	 add	 ecx, DWORD PTR _dstYFrame$[ebp]
  0010b	89 4d b0	 mov	 DWORD PTR _dstY$6[ebp], ecx

; 208  :         uint8_t *dstC = dstCFrame + ((dst_y_pitch_byte * y) >> 1);

  0010e	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  00111	0f af 55 b4	 imul	 edx, DWORD PTR _y$7[ebp]
  00115	d1 fa		 sar	 edx, 1
  00117	03 55 b8	 add	 edx, DWORD PTR _dstCFrame$[ebp]
  0011a	89 55 ac	 mov	 DWORD PTR _dstC$5[ebp], edx

; 209  :         uint8_t *srcP = srcFrame  +   src_y_pitch_byte * (y + crop_up) + crop_left;

  0011d	8b 45 b4	 mov	 eax, DWORD PTR _y$7[ebp]
  00120	03 45 f4	 add	 eax, DWORD PTR _crop_up$[ebp]
  00123	0f af 45 14	 imul	 eax, DWORD PTR _src_y_pitch_byte$[ebp]
  00127	03 45 c0	 add	 eax, DWORD PTR _srcFrame$[ebp]
  0012a	03 45 f8	 add	 eax, DWORD PTR _crop_left$[ebp]
  0012d	89 45 a8	 mov	 DWORD PTR _srcP$4[ebp], eax

; 210  :         const int x_fin = width - crop_right - crop_left;

  00130	8b 4d 10	 mov	 ecx, DWORD PTR _width$[ebp]
  00133	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  00136	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  00139	89 4d a4	 mov	 DWORD PTR _x_fin$3[ebp], ecx

; 211  :         for (int x = 0; x < x_fin; x += 2, dstY += 2, dstC += 2, srcP += 4) {

  0013c	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR _x$2[ebp], 0
  00143	eb 24		 jmp	 SHORT $LN7@convert_yu
$LN5@convert_yu:
  00145	8b 55 a0	 mov	 edx, DWORD PTR _x$2[ebp]
  00148	83 c2 02	 add	 edx, 2
  0014b	89 55 a0	 mov	 DWORD PTR _x$2[ebp], edx
  0014e	8b 45 b0	 mov	 eax, DWORD PTR _dstY$6[ebp]
  00151	83 c0 02	 add	 eax, 2
  00154	89 45 b0	 mov	 DWORD PTR _dstY$6[ebp], eax
  00157	8b 4d ac	 mov	 ecx, DWORD PTR _dstC$5[ebp]
  0015a	83 c1 02	 add	 ecx, 2
  0015d	89 4d ac	 mov	 DWORD PTR _dstC$5[ebp], ecx
  00160	8b 55 a8	 mov	 edx, DWORD PTR _srcP$4[ebp]
  00163	83 c2 04	 add	 edx, 4
  00166	89 55 a8	 mov	 DWORD PTR _srcP$4[ebp], edx
$LN7@convert_yu:
  00169	8b 45 a0	 mov	 eax, DWORD PTR _x$2[ebp]
  0016c	3b 45 a4	 cmp	 eax, DWORD PTR _x_fin$3[ebp]
  0016f	0f 8d b2 00 00
	00		 jge	 $LN6@convert_yu

; 212  :             dstY[0*dst_y_pitch_byte  + 0] = srcP[0*src_y_pitch_byte + 0];

  00175	6b 4d 14 00	 imul	 ecx, DWORD PTR _src_y_pitch_byte$[ebp], 0
  00179	6b 55 1c 00	 imul	 edx, DWORD PTR _dst_y_pitch_byte$[ebp], 0
  0017d	8b 45 b0	 mov	 eax, DWORD PTR _dstY$6[ebp]
  00180	8b 75 a8	 mov	 esi, DWORD PTR _srcP$4[ebp]
  00183	8a 0c 0e	 mov	 cl, BYTE PTR [esi+ecx]
  00186	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 213  :             dstY[0*dst_y_pitch_byte  + 1] = srcP[0*src_y_pitch_byte + 2];

  00189	6b 55 14 00	 imul	 edx, DWORD PTR _src_y_pitch_byte$[ebp], 0
  0018d	6b 45 1c 00	 imul	 eax, DWORD PTR _dst_y_pitch_byte$[ebp], 0
  00191	8b 4d b0	 mov	 ecx, DWORD PTR _dstY$6[ebp]
  00194	8b 75 a8	 mov	 esi, DWORD PTR _srcP$4[ebp]
  00197	8a 54 16 02	 mov	 dl, BYTE PTR [esi+edx+2]
  0019b	88 54 01 01	 mov	 BYTE PTR [ecx+eax+1], dl

; 214  :             dstY[1*dst_y_pitch_byte  + 0] = srcP[1*src_y_pitch_byte + 0];

  0019f	8b 45 b0	 mov	 eax, DWORD PTR _dstY$6[ebp]
  001a2	03 45 1c	 add	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  001a5	8b 4d a8	 mov	 ecx, DWORD PTR _srcP$4[ebp]
  001a8	03 4d 14	 add	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  001ab	8a 11		 mov	 dl, BYTE PTR [ecx]
  001ad	88 10		 mov	 BYTE PTR [eax], dl

; 215  :             dstY[1*dst_y_pitch_byte  + 1] = srcP[1*src_y_pitch_byte + 2];

  001af	8b 45 b0	 mov	 eax, DWORD PTR _dstY$6[ebp]
  001b2	03 45 1c	 add	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  001b5	8b 4d a8	 mov	 ecx, DWORD PTR _srcP$4[ebp]
  001b8	03 4d 14	 add	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  001bb	8a 51 02	 mov	 dl, BYTE PTR [ecx+2]
  001be	88 50 01	 mov	 BYTE PTR [eax+1], dl

; 216  :             dstC[0*dst_y_pitch_byte/2+ 0] =(srcP[0*src_y_pitch_byte + 1] + srcP[1*src_y_pitch_byte + 1] + 1)/2;

  001c1	6b 45 14 00	 imul	 eax, DWORD PTR _src_y_pitch_byte$[ebp], 0
  001c5	8b 4d a8	 mov	 ecx, DWORD PTR _srcP$4[ebp]
  001c8	0f b6 54 01 01	 movzx	 edx, BYTE PTR [ecx+eax+1]
  001cd	8b 45 a8	 mov	 eax, DWORD PTR _srcP$4[ebp]
  001d0	03 45 14	 add	 eax, DWORD PTR _src_y_pitch_byte$[ebp]
  001d3	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  001d7	8d 44 0a 01	 lea	 eax, DWORD PTR [edx+ecx+1]
  001db	99		 cdq
  001dc	2b c2		 sub	 eax, edx
  001de	8b c8		 mov	 ecx, eax
  001e0	d1 f9		 sar	 ecx, 1
  001e2	6b 45 1c 00	 imul	 eax, DWORD PTR _dst_y_pitch_byte$[ebp], 0
  001e6	99		 cdq
  001e7	2b c2		 sub	 eax, edx
  001e9	d1 f8		 sar	 eax, 1
  001eb	8b 55 ac	 mov	 edx, DWORD PTR _dstC$5[ebp]
  001ee	88 0c 02	 mov	 BYTE PTR [edx+eax], cl

; 217  :             dstC[0*dst_y_pitch_byte/2+ 1] =(srcP[0*src_y_pitch_byte + 3] + srcP[1*src_y_pitch_byte + 3] + 1)/2;

  001f1	6b 45 14 00	 imul	 eax, DWORD PTR _src_y_pitch_byte$[ebp], 0
  001f5	8b 4d a8	 mov	 ecx, DWORD PTR _srcP$4[ebp]
  001f8	0f b6 54 01 03	 movzx	 edx, BYTE PTR [ecx+eax+3]
  001fd	8b 45 a8	 mov	 eax, DWORD PTR _srcP$4[ebp]
  00200	03 45 14	 add	 eax, DWORD PTR _src_y_pitch_byte$[ebp]
  00203	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00207	8d 44 0a 01	 lea	 eax, DWORD PTR [edx+ecx+1]
  0020b	99		 cdq
  0020c	2b c2		 sub	 eax, edx
  0020e	8b c8		 mov	 ecx, eax
  00210	d1 f9		 sar	 ecx, 1
  00212	6b 45 1c 00	 imul	 eax, DWORD PTR _dst_y_pitch_byte$[ebp], 0
  00216	99		 cdq
  00217	2b c2		 sub	 eax, edx
  00219	d1 f8		 sar	 eax, 1
  0021b	8b 55 ac	 mov	 edx, DWORD PTR _dstC$5[ebp]
  0021e	88 4c 02 01	 mov	 BYTE PTR [edx+eax+1], cl

; 218  :         }

  00222	e9 1e ff ff ff	 jmp	 $LN5@convert_yu
$LN6@convert_yu:

; 219  :     }

  00227	e9 bd fe ff ff	 jmp	 $LN2@convert_yu
$LN1@convert_yu:

; 220  : }

  0022c	52		 push	 edx
  0022d	8b cd		 mov	 ecx, ebp
  0022f	50		 push	 eax
  00230	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN11@convert_yu
  00236	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0023b	58		 pop	 eax
  0023c	5a		 pop	 edx
  0023d	5f		 pop	 edi
  0023e	5e		 pop	 esi
  0023f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00242	33 cd		 xor	 ecx, ebp
  00244	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00249	83 c4 6c	 add	 esp, 108		; 0000006cH
  0024c	3b ec		 cmp	 ebp, esp
  0024e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00253	8b e5		 mov	 esp, ebp
  00255	5d		 pop	 ebp
  00256	c3		 ret	 0
  00257	90		 npad	 1
$LN11@convert_yu:
  00258	01 00 00 00	 DD	 1
  0025c	00 00 00 00	 DD	 $LN10@convert_yu
$LN10@convert_yu:
  00260	d4 ff ff ff	 DD	 -44			; ffffffd4H
  00264	0c 00 00 00	 DD	 12			; 0000000cH
  00268	00 00 00 00	 DD	 $LN9@convert_yu
$LN9@convert_yu:
  0026c	79		 DB	 121			; 00000079H
  0026d	5f		 DB	 95			; 0000005fH
  0026e	72		 DB	 114			; 00000072H
  0026f	61		 DB	 97			; 00000061H
  00270	6e		 DB	 110			; 0000006eH
  00271	67		 DB	 103			; 00000067H
  00272	65		 DB	 101			; 00000065H
  00273	00		 DB	 0
?convert_yuy2_to_nv12@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP	; convert_yuy2_to_nv12
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.h
_TEXT	SEGMENT
_y1$ = -36						; size = 4
_y0$ = -32						; size = 4
_y_range$ = -24						; size = 12
_h$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
$T1 = 8							; size = 4
_y_start$ = 12						; size = 4
_y_end$ = 16						; size = 4
_thread_id$ = 20					; size = 4
_thread_n$ = 24						; size = 4
?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z PROC	; thread_y_range

; 375  : static inline THREAD_Y_RANGE thread_y_range(int y_start, int y_end, int thread_id, int thread_n) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 dc	 mov	 DWORD PTR [ebp-36], eax
  0000e	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  00011	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  00014	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00017	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0001a	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0001d	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00020	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00023	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002b	33 c5		 xor	 eax, ebp
  0002d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 376  :     const int h = y_end - y_start;

  00030	8b 45 10	 mov	 eax, DWORD PTR _y_end$[ebp]
  00033	2b 45 0c	 sub	 eax, DWORD PTR _y_start$[ebp]
  00036	89 45 f8	 mov	 DWORD PTR _h$[ebp], eax

; 377  :     THREAD_Y_RANGE y_range;
; 378  :     int y0 = ((((h *  thread_id)    / thread_n) + 3) & ~3);

  00039	8b 45 f8	 mov	 eax, DWORD PTR _h$[ebp]
  0003c	0f af 45 14	 imul	 eax, DWORD PTR _thread_id$[ebp]
  00040	99		 cdq
  00041	f7 7d 18	 idiv	 DWORD PTR _thread_n$[ebp]
  00044	83 c0 03	 add	 eax, 3
  00047	83 e0 fc	 and	 eax, -4			; fffffffcH
  0004a	89 45 e0	 mov	 DWORD PTR _y0$[ebp], eax

; 379  :     int y1 = ((((h * (thread_id+1)) / thread_n) + 3) & ~3);

  0004d	8b 4d 14	 mov	 ecx, DWORD PTR _thread_id$[ebp]
  00050	83 c1 01	 add	 ecx, 1
  00053	8b c1		 mov	 eax, ecx
  00055	0f af 45 f8	 imul	 eax, DWORD PTR _h$[ebp]
  00059	99		 cdq
  0005a	f7 7d 18	 idiv	 DWORD PTR _thread_n$[ebp]
  0005d	83 c0 03	 add	 eax, 3
  00060	83 e0 fc	 and	 eax, -4			; fffffffcH
  00063	89 45 dc	 mov	 DWORD PTR _y1$[ebp], eax

; 380  :     if (y1 > h) {

  00066	8b 55 dc	 mov	 edx, DWORD PTR _y1$[ebp]
  00069	3b 55 f8	 cmp	 edx, DWORD PTR _h$[ebp]
  0006c	7e 06		 jle	 SHORT $LN2@thread_y_r

; 381  :         y1 = h;

  0006e	8b 45 f8	 mov	 eax, DWORD PTR _h$[ebp]
  00071	89 45 dc	 mov	 DWORD PTR _y1$[ebp], eax
$LN2@thread_y_r:

; 382  :     }
; 383  :     y_range.start_src = y_start + y0;

  00074	8b 4d 0c	 mov	 ecx, DWORD PTR _y_start$[ebp]
  00077	03 4d e0	 add	 ecx, DWORD PTR _y0$[ebp]
  0007a	89 4d e8	 mov	 DWORD PTR _y_range$[ebp], ecx

; 384  :     y_range.start_dst = y0;

  0007d	8b 55 e0	 mov	 edx, DWORD PTR _y0$[ebp]
  00080	89 55 ec	 mov	 DWORD PTR _y_range$[ebp+4], edx

; 385  :     y_range.len = y1 - y0;

  00083	8b 45 dc	 mov	 eax, DWORD PTR _y1$[ebp]
  00086	2b 45 e0	 sub	 eax, DWORD PTR _y0$[ebp]
  00089	89 45 f0	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 386  :     return y_range;

  0008c	8b 4d 08	 mov	 ecx, DWORD PTR $T1[ebp]
  0008f	8b 55 e8	 mov	 edx, DWORD PTR _y_range$[ebp]
  00092	89 11		 mov	 DWORD PTR [ecx], edx
  00094	8b 45 ec	 mov	 eax, DWORD PTR _y_range$[ebp+4]
  00097	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0009a	8b 55 f0	 mov	 edx, DWORD PTR _y_range$[ebp+8]
  0009d	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  000a0	8b 45 08	 mov	 eax, DWORD PTR $T1[ebp]

; 387  : }

  000a3	52		 push	 edx
  000a4	8b cd		 mov	 ecx, ebp
  000a6	50		 push	 eax
  000a7	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN6@thread_y_r
  000ad	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000b2	58		 pop	 eax
  000b3	5a		 pop	 edx
  000b4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b7	33 cd		 xor	 ecx, ebp
  000b9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000be	8b e5		 mov	 esp, ebp
  000c0	5d		 pop	 ebp
  000c1	c3		 ret	 0
  000c2	66 90		 npad	 2
$LN6@thread_y_r:
  000c4	01 00 00 00	 DD	 1
  000c8	00 00 00 00	 DD	 $LN5@thread_y_r
$LN5@thread_y_r:
  000cc	e8 ff ff ff	 DD	 -24			; ffffffe8H
  000d0	0c 00 00 00	 DD	 12			; 0000000cH
  000d4	00 00 00 00	 DD	 $LN4@thread_y_r
$LN4@thread_y_r:
  000d8	79		 DB	 121			; 00000079H
  000d9	5f		 DB	 95			; 0000005fH
  000da	72		 DB	 114			; 00000072H
  000db	61		 DB	 97			; 00000061H
  000dc	6e		 DB	 110			; 0000006eH
  000dd	67		 DB	 103			; 00000067H
  000de	65		 DB	 101			; 00000065H
  000df	00		 DB	 0
?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ENDP	; thread_y_range
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
$T2 = -132						; size = 8
$T3 = -124						; size = 4
$T4 = -120						; size = 4
$T5 = -116						; size = 4
$T6 = -112						; size = 4
$T7 = -108						; size = 4
$T8 = -104						; size = 4
$T9 = -97						; size = 1
_simd_str$10 = -92					; size = 8
_<end>$L1$11 = -80					; size = 4
_<begin>$L1$12 = -76					; size = 4
_<range>$L1$13 = -72					; size = 4
$T14 = -68						; size = 48
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_simd$ = 8						; size = 4
?get_simd_str@@YAPBDI@Z PROC				; get_simd_str

; 1102 : const TCHAR *get_simd_str(unsigned int simd) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?get_simd_str@@YAPBDI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 78	 sub	 esp, 120		; 00000078H
  00014	57		 push	 edi
  00015	8d bd 7c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-132]
  0001b	b9 1e 00 00 00	 mov	 ecx, 30			; 0000001eH
  00020	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00025	f3 ab		 rep stosd
  00027	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002c	33 c5		 xor	 eax, ebp
  0002e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00031	50		 push	 eax
  00032	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00035	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 1103 :     static std::vector<std::pair<uint32_t, const TCHAR*>> simd_str_list = {

  0003b	a1 00 00 00 00	 mov	 eax, DWORD PTR __tls_index
  00040	64 8b 0d 00 00
	00 00		 mov	 ecx, DWORD PTR fs:__tls_array
  00047	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  0004a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?$TSS0@?1??get_simd_str@@YAPBDI@Z@4HA
  0004f	3b 82 00 00 00
	00		 cmp	 eax, DWORD PTR __Init_thread_epoch[edx]
  00055	0f 8e ff 00 00
	00		 jle	 $LN2@get_simd_s
  0005b	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??get_simd_str@@YAPBDI@Z@4HA
  00060	e8 00 00 00 00	 call	 __Init_thread_header
  00065	83 c4 04	 add	 esp, 4
  00068	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?$TSS0@?1??get_simd_str@@YAPBDI@Z@4HA, -1
  0006f	0f 85 e5 00 00
	00		 jne	 $LN2@get_simd_s
  00075	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0007c	c7 45 98 80 00
	00 00		 mov	 DWORD PTR $T8[ebp], 128	; 00000080H
  00083	68 00 00 00 00	 push	 OFFSET $SG70199
  00088	8d 4d 98	 lea	 ecx, DWORD PTR $T8[ebp]
  0008b	51		 push	 ecx
  0008c	8d 4d bc	 lea	 ecx, DWORD PTR $T14[ebp]
  0008f	e8 00 00 00 00	 call	 ??$?0W4<unnamed-enum-NONE>@@AAY04$$CBD$0A@@?$pair@IPBD@std@@QAE@$$QAW4<unnamed-enum-NONE>@@AAY04$$CBD@Z ; std::pair<unsigned int,char const *>::pair<unsigned int,char const *><enum <unnamed-enum-NONE>,char const (&)[5],0>
  00094	c7 45 94 40 00
	00 00		 mov	 DWORD PTR $T7[ebp], 64	; 00000040H
  0009b	68 00 00 00 00	 push	 OFFSET $SG70200
  000a0	8d 55 94	 lea	 edx, DWORD PTR $T7[ebp]
  000a3	52		 push	 edx
  000a4	8d 4d c4	 lea	 ecx, DWORD PTR $T14[ebp+8]
  000a7	e8 00 00 00 00	 call	 ??$?0W4<unnamed-enum-NONE>@@AAY03$$CBD$0A@@?$pair@IPBD@std@@QAE@$$QAW4<unnamed-enum-NONE>@@AAY03$$CBD@Z ; std::pair<unsigned int,char const *>::pair<unsigned int,char const *><enum <unnamed-enum-NONE>,char const (&)[4],0>
  000ac	c7 45 90 10 00
	00 00		 mov	 DWORD PTR $T6[ebp], 16	; 00000010H
  000b3	68 00 00 00 00	 push	 OFFSET $SG70201
  000b8	8d 45 90	 lea	 eax, DWORD PTR $T6[ebp]
  000bb	50		 push	 eax
  000bc	8d 4d cc	 lea	 ecx, DWORD PTR $T14[ebp+16]
  000bf	e8 00 00 00 00	 call	 ??$?0W4<unnamed-enum-NONE>@@AAY06$$CBD$0A@@?$pair@IPBD@std@@QAE@$$QAW4<unnamed-enum-NONE>@@AAY06$$CBD@Z ; std::pair<unsigned int,char const *>::pair<unsigned int,char const *><enum <unnamed-enum-NONE>,char const (&)[7],0>
  000c4	c7 45 8c 08 00
	00 00		 mov	 DWORD PTR $T5[ebp], 8
  000cb	68 00 00 00 00	 push	 OFFSET $SG70202
  000d0	8d 4d 8c	 lea	 ecx, DWORD PTR $T5[ebp]
  000d3	51		 push	 ecx
  000d4	8d 4d d4	 lea	 ecx, DWORD PTR $T14[ebp+24]
  000d7	e8 00 00 00 00	 call	 ??$?0W4<unnamed-enum-NONE>@@AAY06$$CBD$0A@@?$pair@IPBD@std@@QAE@$$QAW4<unnamed-enum-NONE>@@AAY06$$CBD@Z ; std::pair<unsigned int,char const *>::pair<unsigned int,char const *><enum <unnamed-enum-NONE>,char const (&)[7],0>
  000dc	c7 45 88 04 00
	00 00		 mov	 DWORD PTR $T4[ebp], 4
  000e3	68 00 00 00 00	 push	 OFFSET $SG70203
  000e8	8d 55 88	 lea	 edx, DWORD PTR $T4[ebp]
  000eb	52		 push	 edx
  000ec	8d 4d dc	 lea	 ecx, DWORD PTR $T14[ebp+32]
  000ef	e8 00 00 00 00	 call	 ??$?0W4<unnamed-enum-NONE>@@AAY05$$CBD$0A@@?$pair@IPBD@std@@QAE@$$QAW4<unnamed-enum-NONE>@@AAY05$$CBD@Z ; std::pair<unsigned int,char const *>::pair<unsigned int,char const *><enum <unnamed-enum-NONE>,char const (&)[6],0>
  000f4	c7 45 84 01 00
	00 00		 mov	 DWORD PTR $T3[ebp], 1
  000fb	68 00 00 00 00	 push	 OFFSET $SG70204
  00100	8d 45 84	 lea	 eax, DWORD PTR $T3[ebp]
  00103	50		 push	 eax
  00104	8d 4d e4	 lea	 ecx, DWORD PTR $T14[ebp+40]
  00107	e8 00 00 00 00	 call	 ??$?0W4<unnamed-enum-NONE>@@AAY04$$CBD$0A@@?$pair@IPBD@std@@QAE@$$QAW4<unnamed-enum-NONE>@@AAY04$$CBD@Z ; std::pair<unsigned int,char const *>::pair<unsigned int,char const *><enum <unnamed-enum-NONE>,char const (&)[5],0>
  0010c	8d 4d 9f	 lea	 ecx, DWORD PTR $T9[ebp]
  0010f	e8 00 00 00 00	 call	 ??0?$allocator@U?$pair@IPBD@std@@@std@@QAE@XZ ; std::allocator<std::pair<unsigned int,char const *> >::allocator<std::pair<unsigned int,char const *> >
  00114	50		 push	 eax
  00115	8d 4d ec	 lea	 ecx, DWORD PTR $T14[ebp+48]
  00118	51		 push	 ecx
  00119	8d 55 bc	 lea	 edx, DWORD PTR $T14[ebp]
  0011c	52		 push	 edx
  0011d	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00123	e8 00 00 00 00	 call	 ??0?$initializer_list@U?$pair@IPBD@std@@@std@@QAE@PBU?$pair@IPBD@1@0@Z ; std::initializer_list<std::pair<unsigned int,char const *> >::initializer_list<std::pair<unsigned int,char const *> >
  00128	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0012b	51		 push	 ecx
  0012c	8b 10		 mov	 edx, DWORD PTR [eax]
  0012e	52		 push	 edx
  0012f	b9 00 00 00 00	 mov	 ecx, OFFSET ?simd_str_list@?1??get_simd_str@@YAPBDI@Z@4V?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@A
  00134	e8 00 00 00 00	 call	 ??0?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@QAE@V?$initializer_list@U?$pair@IPBD@std@@@1@ABV?$allocator@U?$pair@IPBD@std@@@1@@Z ; std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > >::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > >
  00139	68 00 00 00 00	 push	 OFFSET ??__Fsimd_str_list@?1??get_simd_str@@YAPBDI@Z@YAXXZ ; `get_simd_str'::`2'::`dynamic atexit destructor for 'simd_str_list''
  0013e	e8 00 00 00 00	 call	 _atexit
  00143	83 c4 04	 add	 esp, 4
  00146	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0014d	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??get_simd_str@@YAPBDI@Z@4HA
  00152	e8 00 00 00 00	 call	 __Init_thread_footer
  00157	83 c4 04	 add	 esp, 4
$LN2@get_simd_s:

; 1104 :         { AVX2,  _T("AVX2")   },
; 1105 :         { AVX,   _T("AVX")    },
; 1106 :         { SSE42, _T("SSE4.2") },
; 1107 :         { SSE41, _T("SSE4.1") },
; 1108 :         { SSSE3, _T("SSSE3")  },
; 1109 :         { SSE2,  _T("SSE2")   },
; 1110 :     };
; 1111 :     for (auto simd_str : simd_str_list) {

  0015a	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _<range>$L1$13[ebp], OFFSET ?simd_str_list@?1??get_simd_str@@YAPBDI@Z@4V?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@A
  00161	8b 4d b8	 mov	 ecx, DWORD PTR _<range>$L1$13[ebp]
  00164	e8 00 00 00 00	 call	 ?_Unchecked_begin@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@QAEPAU?$pair@IPBD@2@XZ ; std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > >::_Unchecked_begin
  00169	89 45 b4	 mov	 DWORD PTR _<begin>$L1$12[ebp], eax
  0016c	8b 4d b8	 mov	 ecx, DWORD PTR _<range>$L1$13[ebp]
  0016f	e8 00 00 00 00	 call	 ?_Unchecked_end@?$vector@U?$pair@IPBD@std@@V?$allocator@U?$pair@IPBD@std@@@2@@std@@QAEPAU?$pair@IPBD@2@XZ ; std::vector<std::pair<unsigned int,char const *>,std::allocator<std::pair<unsigned int,char const *> > >::_Unchecked_end
  00174	89 45 b0	 mov	 DWORD PTR _<end>$L1$11[ebp], eax
  00177	eb 09		 jmp	 SHORT $LN5@get_simd_s
$LN3@get_simd_s:
  00179	8b 45 b4	 mov	 eax, DWORD PTR _<begin>$L1$12[ebp]
  0017c	83 c0 08	 add	 eax, 8
  0017f	89 45 b4	 mov	 DWORD PTR _<begin>$L1$12[ebp], eax
$LN5@get_simd_s:
  00182	8b 4d b4	 mov	 ecx, DWORD PTR _<begin>$L1$12[ebp]
  00185	3b 4d b0	 cmp	 ecx, DWORD PTR _<end>$L1$11[ebp]
  00188	74 1d		 je	 SHORT $LN4@get_simd_s
  0018a	8b 55 b4	 mov	 edx, DWORD PTR _<begin>$L1$12[ebp]
  0018d	8b 02		 mov	 eax, DWORD PTR [edx]
  0018f	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00192	89 45 a4	 mov	 DWORD PTR _simd_str$10[ebp], eax
  00195	89 4d a8	 mov	 DWORD PTR _simd_str$10[ebp+4], ecx

; 1112 :         if (simd_str.first & simd)

  00198	8b 55 a4	 mov	 edx, DWORD PTR _simd_str$10[ebp]
  0019b	23 55 08	 and	 edx, DWORD PTR _simd$[ebp]
  0019e	74 05		 je	 SHORT $LN6@get_simd_s

; 1113 :             return simd_str.second;

  001a0	8b 45 a8	 mov	 eax, DWORD PTR _simd_str$10[ebp+4]
  001a3	eb 07		 jmp	 SHORT $LN1@get_simd_s
$LN6@get_simd_s:

; 1114 :     }

  001a5	eb d2		 jmp	 SHORT $LN3@get_simd_s
$LN4@get_simd_s:

; 1115 :     return _T("-");

  001a7	b8 00 00 00 00	 mov	 eax, OFFSET $SG70206
$LN1@get_simd_s:

; 1116 : }

  001ac	52		 push	 edx
  001ad	8b cd		 mov	 ecx, ebp
  001af	50		 push	 eax
  001b0	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN12@get_simd_s
  001b6	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  001bb	58		 pop	 eax
  001bc	5a		 pop	 edx
  001bd	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001c0	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001c7	59		 pop	 ecx
  001c8	5f		 pop	 edi
  001c9	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001cc	33 cd		 xor	 ecx, ebp
  001ce	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001d3	81 c4 84 00 00
	00		 add	 esp, 132		; 00000084H
  001d9	3b ec		 cmp	 ebp, esp
  001db	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001e0	8b e5		 mov	 esp, ebp
  001e2	5d		 pop	 ebp
  001e3	c3		 ret	 0
$LN12@get_simd_s:
  001e4	01 00 00 00	 DD	 1
  001e8	00 00 00 00	 DD	 $LN11@get_simd_s
$LN11@get_simd_s:
  001ec	a4 ff ff ff	 DD	 -92			; ffffffa4H
  001f0	08 00 00 00	 DD	 8
  001f4	00 00 00 00	 DD	 $LN9@get_simd_s
$LN9@get_simd_s:
  001f8	73		 DB	 115			; 00000073H
  001f9	69		 DB	 105			; 00000069H
  001fa	6d		 DB	 109			; 0000006dH
  001fb	64		 DB	 100			; 00000064H
  001fc	5f		 DB	 95			; 0000005fH
  001fd	73		 DB	 115			; 00000073H
  001fe	74		 DB	 116			; 00000074H
  001ff	72		 DB	 114			; 00000072H
  00200	00		 DB	 0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?get_simd_str@@YAPBDI@Z$0:
  00000	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??get_simd_str@@YAPBDI@Z@4HA
  00005	e8 00 00 00 00	 call	 __Init_thread_abort
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
__ehhandler$?get_simd_str@@YAPBDI@Z:
  0000c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00010	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00013	8b 4a 80	 mov	 ecx, DWORD PTR [edx-128]
  00016	33 c8		 xor	 ecx, eax
  00018	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001d	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00020	33 c8		 xor	 ecx, eax
  00022	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00027	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?get_simd_str@@YAPBDI@Z
  0002c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?get_simd_str@@YAPBDI@Z ENDP				; get_simd_str
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.cpp
_TEXT	SEGMENT
_i$1 = -12						; size = 4
_convert$ = -8						; size = 4
_availableSIMD$ = -4					; size = 4
_csp_from$ = 8						; size = 4
_csp_to$ = 12						; size = 4
_uv_only$ = 16						; size = 1
_simd$ = 20						; size = 4
?get_convert_csp_func@@YAPBUConvertCSP@@W4RGY_CSP@@0_NI@Z PROC ; get_convert_csp_func

; 1080 : const ConvertCSP *get_convert_csp_func(RGY_CSP csp_from, RGY_CSP csp_to, bool uv_only, uint32_t simd) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 1081 :     uint32_t availableSIMD = get_availableSIMD() & simd;

  0001b	e8 00 00 00 00	 call	 ?get_availableSIMD@@YAIXZ ; get_availableSIMD
  00020	23 45 14	 and	 eax, DWORD PTR _simd$[ebp]
  00023	89 45 fc	 mov	 DWORD PTR _availableSIMD$[ebp], eax

; 1082 :     const ConvertCSP *convert = nullptr;

  00026	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _convert$[ebp], 0

; 1083 :     for (int i = 0; i < _countof(funcList); i++) {

  0002d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00034	eb 09		 jmp	 SHORT $LN4@get_conver
$LN2@get_conver:
  00036	8b 45 f4	 mov	 eax, DWORD PTR _i$1[ebp]
  00039	83 c0 01	 add	 eax, 1
  0003c	89 45 f4	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@get_conver:
  0003f	81 7d f4 8f 00
	00 00		 cmp	 DWORD PTR _i$1[ebp], 143 ; 0000008fH
  00046	73 63		 jae	 SHORT $LN3@get_conver

; 1084 :         if (csp_from != funcList[i].csp_from)

  00048	6b 4d f4 18	 imul	 ecx, DWORD PTR _i$1[ebp], 24
  0004c	8b 55 08	 mov	 edx, DWORD PTR _csp_from$[ebp]
  0004f	3b 91 00 00 00
	00		 cmp	 edx, DWORD PTR ?funcList@@3QBUConvertCSP@@B[ecx]
  00055	74 02		 je	 SHORT $LN5@get_conver

; 1085 :             continue;

  00057	eb dd		 jmp	 SHORT $LN2@get_conver
$LN5@get_conver:

; 1086 : 
; 1087 :         if (csp_to != funcList[i].csp_to)

  00059	6b 45 f4 18	 imul	 eax, DWORD PTR _i$1[ebp], 24
  0005d	8b 4d 0c	 mov	 ecx, DWORD PTR _csp_to$[ebp]
  00060	3b 88 04 00 00
	00		 cmp	 ecx, DWORD PTR ?funcList@@3QBUConvertCSP@@B[eax+4]
  00066	74 02		 je	 SHORT $LN6@get_conver

; 1088 :             continue;

  00068	eb cc		 jmp	 SHORT $LN2@get_conver
$LN6@get_conver:

; 1089 : 
; 1090 :         if (uv_only != funcList[i].uv_only)

  0006a	0f b6 55 10	 movzx	 edx, BYTE PTR _uv_only$[ebp]
  0006e	6b 45 f4 18	 imul	 eax, DWORD PTR _i$1[ebp], 24
  00072	0f b6 88 08 00
	00 00		 movzx	 ecx, BYTE PTR ?funcList@@3QBUConvertCSP@@B[eax+8]
  00079	3b d1		 cmp	 edx, ecx
  0007b	74 02		 je	 SHORT $LN7@get_conver

; 1091 :             continue;

  0007d	eb b7		 jmp	 SHORT $LN2@get_conver
$LN7@get_conver:

; 1092 : 
; 1093 :         if (funcList[i].simd != (availableSIMD & funcList[i].simd))

  0007f	6b 55 f4 18	 imul	 edx, DWORD PTR _i$1[ebp], 24
  00083	6b 45 f4 18	 imul	 eax, DWORD PTR _i$1[ebp], 24
  00087	8b 4d fc	 mov	 ecx, DWORD PTR _availableSIMD$[ebp]
  0008a	23 88 14 00 00
	00		 and	 ecx, DWORD PTR ?funcList@@3QBUConvertCSP@@B[eax+20]
  00090	39 8a 14 00 00
	00		 cmp	 DWORD PTR ?funcList@@3QBUConvertCSP@@B[edx+20], ecx
  00096	74 02		 je	 SHORT $LN8@get_conver

; 1094 :             continue;

  00098	eb 9c		 jmp	 SHORT $LN2@get_conver
$LN8@get_conver:

; 1095 : 
; 1096 :         convert = &funcList[i];

  0009a	6b 55 f4 18	 imul	 edx, DWORD PTR _i$1[ebp], 24
  0009e	81 c2 00 00 00
	00		 add	 edx, OFFSET ?funcList@@3QBUConvertCSP@@B
  000a4	89 55 f8	 mov	 DWORD PTR _convert$[ebp], edx

; 1097 :         break;

  000a7	eb 02		 jmp	 SHORT $LN3@get_conver

; 1098 :     }

  000a9	eb 8b		 jmp	 SHORT $LN2@get_conver
$LN3@get_conver:

; 1099 :     return convert;

  000ab	8b 45 f8	 mov	 eax, DWORD PTR _convert$[ebp]

; 1100 : }

  000ae	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b1	3b ec		 cmp	 ebp, esp
  000b3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b8	8b e5		 mov	 esp, ebp
  000ba	5d		 pop	 ebp
  000bb	c3		 ret	 0
?get_convert_csp_func@@YAPBUConvertCSP@@W4RGY_CSP@@0_NI@Z ENDP ; get_convert_csp_func
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ PROC	; std::_Basic_container_proxy_ptr12::_Release, COMDAT
; _this$ = ecx

; 1348 :     void _Release() noexcept { // disengage this _Basic_container_proxy_ptr12

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1349 :         _Ptr = nullptr;

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1350 :     }

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ ENDP	; std::_Basic_container_proxy_ptr12::_Release
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ?_Orphan_all@_Container_base12@std@@QAEXXZ
_TEXT	SEGMENT
__Pnext$2 = -32						; size = 4
__Lock$3 = -24						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?_Orphan_all@_Container_base12@std@@QAEXXZ PROC		; std::_Container_base12::_Orphan_all, COMDAT
; _this$ = ecx

; 1288 : inline void _Container_base12::_Orphan_all() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	56		 push	 esi
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  0001d	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  00020	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00023	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00026	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00029	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002e	33 c5		 xor	 eax, ebp
  00030	50		 push	 eax
  00031	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00034	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003a	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1289 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1290 :     if (_Myproxy) { // proxy allocated, drain it

  0003d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00040	83 38 00	 cmp	 DWORD PTR [eax], 0
  00043	74 6f		 je	 SHORT $LN1@Orphan_all

; 1291 :         _Lockit _Lock(_LOCK_DEBUG);

  00045	8b f4		 mov	 esi, esp
  00047	6a 03		 push	 3
  00049	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
  00052	3b f4		 cmp	 esi, esp
  00054	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00059	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1292 : 
; 1293 :         for (auto _Pnext = &_Myproxy->_Myfirstiter; *_Pnext; *_Pnext = (*_Pnext)->_Mynextiter) {

  00060	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00063	8b 11		 mov	 edx, DWORD PTR [ecx]
  00065	83 c2 04	 add	 edx, 4
  00068	89 55 e0	 mov	 DWORD PTR __Pnext$2[ebp], edx
  0006b	eb 0d		 jmp	 SHORT $LN4@Orphan_all
$LN2@Orphan_all:
  0006d	8b 45 e0	 mov	 eax, DWORD PTR __Pnext$2[ebp]
  00070	8b 08		 mov	 ecx, DWORD PTR [eax]
  00072	8b 55 e0	 mov	 edx, DWORD PTR __Pnext$2[ebp]
  00075	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00078	89 02		 mov	 DWORD PTR [edx], eax
$LN4@Orphan_all:
  0007a	8b 4d e0	 mov	 ecx, DWORD PTR __Pnext$2[ebp]
  0007d	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00080	74 0d		 je	 SHORT $LN3@Orphan_all

; 1294 :             (*_Pnext)->_Myproxy = nullptr;

  00082	8b 55 e0	 mov	 edx, DWORD PTR __Pnext$2[ebp]
  00085	8b 02		 mov	 eax, DWORD PTR [edx]
  00087	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1295 :         }

  0008d	eb de		 jmp	 SHORT $LN2@Orphan_all
$LN3@Orphan_all:

; 1296 : 
; 1297 :         _Myproxy->_Myfirstiter = nullptr;

  0008f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00092	8b 11		 mov	 edx, DWORD PTR [ecx]
  00094	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0

; 1298 :     }

  0009b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000a2	8b f4		 mov	 esi, esp
  000a4	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  000a7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  000ad	3b f4		 cmp	 esi, esp
  000af	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@Orphan_all:

; 1299 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1300 : }

  000b4	52		 push	 edx
  000b5	8b cd		 mov	 ecx, ebp
  000b7	50		 push	 eax
  000b8	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN11@Orphan_all
  000be	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000c3	58		 pop	 eax
  000c4	5a		 pop	 edx
  000c5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000cf	59		 pop	 ecx
  000d0	5e		 pop	 esi
  000d1	83 c4 20	 add	 esp, 32			; 00000020H
  000d4	3b ec		 cmp	 ebp, esp
  000d6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000db	8b e5		 mov	 esp, ebp
  000dd	5d		 pop	 ebp
  000de	c3		 ret	 0
  000df	90		 npad	 1
$LN11@Orphan_all:
  000e0	01 00 00 00	 DD	 1
  000e4	00 00 00 00	 DD	 $LN10@Orphan_all
$LN10@Orphan_all:
  000e8	e8 ff ff ff	 DD	 -24			; ffffffe8H
  000ec	04 00 00 00	 DD	 4
  000f0	00 00 00 00	 DD	 $LN8@Orphan_all
$LN8@Orphan_all:
  000f4	5f		 DB	 95			; 0000005fH
  000f5	4c		 DB	 76			; 0000004cH
  000f6	6f		 DB	 111			; 0000006fH
  000f7	63		 DB	 99			; 00000063H
  000f8	6b		 DB	 107			; 0000006bH
  000f9	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0:
  00000	8b f4		 mov	 esi, esp
  00002	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  0000b	3b f4		 cmp	 esi, esp
  0000d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00012	c3		 ret	 0
__ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ:
  00013	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00017	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001a	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ
  00029	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Orphan_all@_Container_base12@std@@QAEXXZ ENDP		; std::_Container_base12::_Orphan_all
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ??0_Container_base12@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Container_base12@std@@QAE@XZ PROC			; std::_Container_base12::_Container_base12, COMDAT
; _this$ = ecx

; 1175 :     _Container_base12() : _Myproxy(nullptr) {} // construct childless container

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??0_Container_base12@std@@QAE@XZ ENDP			; std::_Container_base12::_Container_base12
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Mycont_$ = 8						; size = 4
??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z PROC ; std::_Container_proxy::_Container_proxy, COMDAT
; _this$ = ecx

; 1167 :     _Container_proxy(_Container_base12* _Mycont_) noexcept : _Mycont(_Mycont_), _Myfirstiter(nullptr) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 4d 08	 mov	 ecx, DWORD PTR __Mycont_$[ebp]
  00014	89 08		 mov	 DWORD PTR [eax], ecx
  00016	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00019	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0
  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z ENDP ; std::_Container_proxy::_Container_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ??$_Convert_size@I@std@@YAII@Z
_TEXT	SEGMENT
__Len$ = 8						; size = 4
??$_Convert_size@I@std@@YAII@Z PROC			; std::_Convert_size<unsigned int>, COMDAT

; 1073 : _NODISCARD constexpr size_t _Convert_size<size_t>(const size_t _Len) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1074 :     // convert size_t to size_t, unchanged
; 1075 :     return _Len;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Len$[ebp]

; 1076 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Convert_size@I@std@@YAII@Z ENDP			; std::_Convert_size<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
__Back_shift$ = -16					; size = 4
__Min_back_shift$ = -12					; size = 4
__Ptr_container$ = -8					; size = 4
__Ptr_user$ = -4					; size = 4
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 102  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000f	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00012	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00015	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 103  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 104  :     _Bytes += _Non_user_size;

  00018	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]
  0001b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001d	83 c1 27	 add	 ecx, 39			; 00000027H
  00020	8b 55 0c	 mov	 edx, DWORD PTR __Bytes$[ebp]
  00023	89 0a		 mov	 DWORD PTR [edx], ecx

; 105  : 
; 106  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);

  00025	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00028	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002a	89 4d fc	 mov	 DWORD PTR __Ptr_user$[ebp], ecx

; 107  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0002d	ba 04 00 00 00	 mov	 edx, 4
  00032	6b c2 ff	 imul	 eax, edx, -1
  00035	8b 4d fc	 mov	 ecx, DWORD PTR __Ptr_user$[ebp]
  00038	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  0003b	89 55 f8	 mov	 DWORD PTR __Ptr_container$[ebp], edx
$LN4@Adjust_man:

; 108  : 
; 109  :     // If the following asserts, it likely means that we are performing
; 110  :     // an aligned delete on memory coming from an unaligned allocation.
; 111  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");

  0003e	b8 04 00 00 00	 mov	 eax, 4
  00043	6b c8 fe	 imul	 ecx, eax, -2
  00046	8b 55 fc	 mov	 edx, DWORD PTR __Ptr_user$[ebp]
  00049	81 3c 0a fa fa
	fa fa		 cmp	 DWORD PTR [edx+ecx], -84215046 ; fafafafaH
  00050	75 02		 jne	 SHORT $LN7@Adjust_man
  00052	eb 56		 jmp	 SHORT $LN2@Adjust_man
$LN7@Adjust_man:
  00054	8b f4		 mov	 esi, esp
  00056	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@FCMFBGOM@invalid?5argument@
  0005b	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  00060	6a 00		 push	 0
  00062	6a 6f		 push	 111			; 0000006fH
  00064	68 00 00 00 00	 push	 OFFSET ??_C@_0GI@FJIKDGOA@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
  00069	6a 02		 push	 2
  0006b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  00071	83 c4 18	 add	 esp, 24			; 00000018H
  00074	3b f4		 cmp	 esi, esp
  00076	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007b	83 f8 01	 cmp	 eax, 1
  0007e	75 01		 jne	 SHORT $LN19@Adjust_man
  00080	cc		 int	 3
$LN19@Adjust_man:
  00081	8b f4		 mov	 esi, esp
  00083	6a 00		 push	 0
  00085	6a 6f		 push	 111			; 0000006fH
  00087	68 00 00 00 00	 push	 OFFSET ??_C@_1NA@CDBIFGMM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  0008c	68 00 00 00 00	 push	 OFFSET ??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@
  00091	68 00 00 00 00	 push	 OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
  00096	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  0009c	83 c4 14	 add	 esp, 20			; 00000014H
  0009f	3b f4		 cmp	 esi, esp
  000a1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a6	33 c9		 xor	 ecx, ecx
  000a8	75 aa		 jne	 SHORT $LN7@Adjust_man
$LN2@Adjust_man:
  000aa	33 d2		 xor	 edx, edx
  000ac	75 90		 jne	 SHORT $LN4@Adjust_man

; 112  : 
; 113  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 114  :     // in range [_Min_back_shift, _Non_user_size]
; 115  : #ifdef _DEBUG
; 116  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);

  000ae	c7 45 f4 08 00
	00 00		 mov	 DWORD PTR __Min_back_shift$[ebp], 8

; 117  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 118  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 119  : #endif // _DEBUG
; 120  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000b5	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  000b8	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ba	2b 4d f8	 sub	 ecx, DWORD PTR __Ptr_container$[ebp]
  000bd	89 4d f0	 mov	 DWORD PTR __Back_shift$[ebp], ecx
$LN10@Adjust_man:

; 121  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000c0	83 7d f0 08	 cmp	 DWORD PTR __Back_shift$[ebp], 8
  000c4	72 08		 jb	 SHORT $LN13@Adjust_man
  000c6	83 7d f0 27	 cmp	 DWORD PTR __Back_shift$[ebp], 39 ; 00000027H
  000ca	77 02		 ja	 SHORT $LN13@Adjust_man
  000cc	eb 56		 jmp	 SHORT $LN8@Adjust_man
$LN13@Adjust_man:
  000ce	8b f4		 mov	 esi, esp
  000d0	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@FCMFBGOM@invalid?5argument@
  000d5	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  000da	6a 00		 push	 0
  000dc	6a 79		 push	 121			; 00000079H
  000de	68 00 00 00 00	 push	 OFFSET ??_C@_0GI@FJIKDGOA@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
  000e3	6a 02		 push	 2
  000e5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  000eb	83 c4 18	 add	 esp, 24			; 00000018H
  000ee	3b f4		 cmp	 esi, esp
  000f0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f5	83 f8 01	 cmp	 eax, 1
  000f8	75 01		 jne	 SHORT $LN20@Adjust_man
  000fa	cc		 int	 3
$LN20@Adjust_man:
  000fb	8b f4		 mov	 esi, esp
  000fd	6a 00		 push	 0
  000ff	6a 79		 push	 121			; 00000079H
  00101	68 00 00 00 00	 push	 OFFSET ??_C@_1NA@CDBIFGMM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  00106	68 00 00 00 00	 push	 OFFSET ??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@
  0010b	68 00 00 00 00	 push	 OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
  00110	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  00116	83 c4 14	 add	 esp, 20			; 00000014H
  00119	3b f4		 cmp	 esi, esp
  0011b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00120	33 c0		 xor	 eax, eax
  00122	75 aa		 jne	 SHORT $LN13@Adjust_man
$LN8@Adjust_man:
  00124	33 c9		 xor	 ecx, ecx
  00126	75 98		 jne	 SHORT $LN10@Adjust_man

; 122  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00128	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  0012b	8b 45 f8	 mov	 eax, DWORD PTR __Ptr_container$[ebp]
  0012e	89 02		 mov	 DWORD PTR [edx], eax

; 123  : }

  00130	5e		 pop	 esi
  00131	83 c4 10	 add	 esp, 16			; 00000010H
  00134	3b ec		 cmp	 ebp, esp
  00136	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0013b	8b e5		 mov	 esp, ebp
  0013d	5d		 pop	 ebp
  0013e	c3		 ret	 0
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xmemory
;	COMDAT ?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z PROC	; std::_Default_allocate_traits::_Allocate, COMDAT

; 46   :     _DECLSPEC_ALLOCATOR static void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   :         return ::operator new(_Bytes);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000c	83 c4 04	 add	 esp, 4

; 48   :     }

  0000f	3b ec		 cmp	 ebp, esp
  00011	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ENDP	; std::_Default_allocate_traits::_Allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 323  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 324  :     _THROW(bad_array_new_length{});

  0001b	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  0001e	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  00023	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00028	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN2@Throw_bad_:

; 325  : }

  00031	83 c4 0c	 add	 esp, 12			; 0000000cH
  00034	3b ec		 cmp	 ebp, esp
  00036	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1bad_array_new_length@std@@UAE@XZ
  00016	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00019	83 e0 01	 and	 eax, 1
  0001c	74 0e		 je	 SHORT $LN2@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00029	83 c4 08	 add	 esp, 8
$LN2@scalar:
  0002c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	83 c4 04	 add	 esp, 4
  00032	3b ec		 cmp	 ebp, esp
  00034	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0bad_array_new_length@std@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002d	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00030	50		 push	 eax
  00031	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@ABV01@@Z
  00039	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00040	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_array_new_length@std@@6B@
  00049	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00050	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00053	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00056	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005d	59		 pop	 ecx
  0005e	83 c4 10	 add	 esp, 16			; 00000010H
  00061	3b ec		 cmp	 ebp, esp
  00063	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0bad_array_new_length@std@@QAE@ABV01@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1bad_alloc@std@@UAE@XZ
__ehhandler$??0bad_array_new_length@std@@QAE@ABV01@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0bad_array_new_length@std@@QAE@ABV01@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1bad_array_new_length@std@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00034	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0003b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	e8 00 00 00 00	 call	 ??1bad_alloc@std@@UAE@XZ
  00043	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00046	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0004d	59		 pop	 ecx
  0004e	83 c4 10	 add	 esp, 16			; 00000010H
  00051	3b ec		 cmp	 ebp, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1bad_array_new_length@std@@UAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1bad_alloc@std@@UAE@XZ
__ehhandler$??1bad_array_new_length@std@@UAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1bad_array_new_length@std@@UAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 138  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0bad_array_new_length@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 137  :         : bad_alloc("bad array new length")

  0002d	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
  00032	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ??0bad_alloc@std@@AAE@QBD@Z ; std::bad_alloc::bad_alloc
  0003a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 138  :     {

  00041	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00044	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@

; 139  :     }

  0004a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00051	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00054	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00057	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005e	59		 pop	 ecx
  0005f	83 c4 10	 add	 esp, 16			; 00000010H
  00062	3b ec		 cmp	 ebp, esp
  00064	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00069	8b e5		 mov	 esp, ebp
  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0bad_array_new_length@std@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1bad_alloc@std@@UAE@XZ
__ehhandler$??0bad_array_new_length@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0bad_array_new_length@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1bad_alloc@std@@UAE@XZ
  00016	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00019	83 e0 01	 and	 eax, 1
  0001c	74 0e		 je	 SHORT $LN2@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00029	83 c4 08	 add	 esp, 8
$LN2@scalar:
  0002c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	83 c4 04	 add	 esp, 4
  00032	3b ec		 cmp	 ebp, esp
  00034	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0bad_alloc@std@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002d	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00030	50		 push	 eax
  00031	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00039	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00040	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@
  00049	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00050	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00053	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00056	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005d	59		 pop	 ecx
  0005e	83 c4 10	 add	 esp, 16			; 00000010H
  00061	3b ec		 cmp	 ebp, esp
  00063	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0bad_alloc@std@@QAE@ABV01@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
__ehhandler$??0bad_alloc@std@@QAE@ABV01@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0bad_alloc@std@@QAE@ABV01@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1bad_alloc@std@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00034	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0003b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  00043	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00046	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0004d	59		 pop	 ecx
  0004e	83 c4 10	 add	 esp, 16			; 00000010H
  00051	3b ec		 cmp	 ebp, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1bad_alloc@std@@UAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
__ehhandler$??1bad_alloc@std@@UAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1bad_alloc@std@@UAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@AAE@QBD@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0bad_alloc@std@@AAE@QBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 127  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0bad_alloc@std@@AAE@QBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 126  :         : exception(_Message, 1)

  0002d	6a 01		 push	 1
  0002f	8b 45 08	 mov	 eax, DWORD PTR __Message$[ebp]
  00032	50		 push	 eax
  00033	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00036	e8 00 00 00 00	 call	 ??0exception@std@@QAE@QBDH@Z ; std::exception::exception
  0003b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 127  :     {

  00042	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 128  :     }

  0004b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00052	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00055	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00058	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005f	59		 pop	 ecx
  00060	83 c4 10	 add	 esp, 16			; 00000010H
  00063	3b ec		 cmp	 ebp, esp
  00065	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0bad_alloc@std@@AAE@QBD@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
__ehhandler$??0bad_alloc@std@@AAE@QBD@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0bad_alloc@std@@AAE@QBD@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0bad_alloc@std@@AAE@QBD@Z ENDP			; std::bad_alloc::bad_alloc
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  00016	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00019	83 e0 01	 and	 eax, 1
  0001c	74 0e		 je	 SHORT $LN2@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00029	83 c4 08	 add	 esp, 8
$LN2@scalar:
  0002c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	83 c4 04	 add	 esp, 4
  00032	3b ec		 cmp	 ebp, esp
  00034	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 91   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 92   :         return _Data._What ? _Data._What : "Unknown exception";

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0001e	74 0b		 je	 SHORT $LN3@what
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00026	89 55 f8	 mov	 DWORD PTR tv69[ebp], edx
  00029	eb 07		 jmp	 SHORT $LN4@what
$LN3@what:
  0002b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
$LN4@what:
  00032	8b 45 f8	 mov	 eax, DWORD PTR tv69[ebp]

; 93   :     }

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 86   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1exception@std@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00030	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 87   :         __std_exception_destroy(&_Data);

  00036	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	83 c1 04	 add	 ecx, 4
  0003c	51		 push	 ecx
  0003d	e8 00 00 00 00	 call	 ___std_exception_destroy
  00042	83 c4 04	 add	 esp, 4

; 88   :     }

  00045	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00048	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0004f	59		 pop	 ecx
  00050	83 c4 10	 add	 esp, 16			; 00000010H
  00053	3b ec		 cmp	 ebp, esp
  00055	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1exception@std@@UAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1exception@std@@UAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 69   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0exception@std@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00030	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 68   :         : _Data()

  00036	33 c9		 xor	 ecx, ecx
  00038	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0003b	83 c2 04	 add	 edx, 4
  0003e	89 0a		 mov	 DWORD PTR [edx], ecx
  00040	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 70   :         __std_exception_copy(&_Other._Data, &_Data);

  00043	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00046	83 c0 04	 add	 eax, 4
  00049	50		 push	 eax
  0004a	8b 4d 08	 mov	 ecx, DWORD PTR __Other$[ebp]
  0004d	83 c1 04	 add	 ecx, 4
  00050	51		 push	 ecx
  00051	e8 00 00 00 00	 call	 ___std_exception_copy
  00056	83 c4 08	 add	 esp, 8

; 71   :     }

  00059	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00066	59		 pop	 ecx
  00067	83 c4 10	 add	 esp, 16			; 00000010H
  0006a	3b ec		 cmp	 ebp, esp
  0006c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0exception@std@@QAE@ABV01@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0exception@std@@QAE@ABV01@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@QBDH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
___formal$ = 12						; size = 4
??0exception@std@@QAE@QBDH@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 63   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 62   :         : _Data()

  00017	33 c9		 xor	 ecx, ecx
  00019	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001c	83 c2 04	 add	 edx, 4
  0001f	89 0a		 mov	 DWORD PTR [edx], ecx
  00021	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 64   :         _Data._What = _Message;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	8b 4d 08	 mov	 ecx, DWORD PTR __Message$[ebp]
  0002a	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 65   :     }

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 08 00	 ret	 8
??0exception@std@@QAE@QBDH@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\limits
;	COMDAT ?max@?$numeric_limits@H@std@@SAHXZ
_TEXT	SEGMENT
?max@?$numeric_limits@H@std@@SAHXZ PROC			; std::numeric_limits<int>::max, COMDAT

; 553  :     _NODISCARD static constexpr int(max)() noexcept { // return maximum value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 554  :         return INT_MAX;

  00003	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 555  :     }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
?max@?$numeric_limits@H@std@@SAHXZ ENDP			; std::numeric_limits<int>::max
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__Size$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 168  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 169  :         (void)_Size;
; 170  :         return _Where;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 171  :     }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
END
