; Listing generated by Microsoft (R) Optimizing Compiler Version 19.23.28106.4 

	TITLE	D:\work\intel\intel_codec\QSVPipeline\gpu_info.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
?list_colormatrix@@3QBUCX_DESC@@B DD FLAT:$SG155654	; list_colormatrix
	DD	02H
	DD	FLAT:$SG155655
	DD	07fffffffH
	DD	FLAT:$SG155656
	DD	01H
	DD	FLAT:$SG155657
	DD	06H
	DD	FLAT:$SG155658
	DD	05H
	DD	FLAT:$SG155659
	DD	07H
	DD	FLAT:$SG155660
	DD	08H
	DD	FLAT:$SG155661
	DD	04H
	DD	FLAT:$SG155662
	DD	00H
	DD	FLAT:$SG155663
	DD	09H
	DD	FLAT:$SG155664
	DD	0aH
	DD	FLAT:$SG155665
	DD	0cH
	DD	FLAT:$SG155666
	DD	0dH
	DD	FLAT:$SG155667
	DD	0eH
	DD	FLAT:$SG155668
	DD	0fH
	DD	00H
	DD	00H
$SG155654 DB	'undef', 00H
	ORG $+2
$SG155655 DB	'auto', 00H
	ORG $+3
$SG155656 DB	'bt709', 00H
	ORG $+2
$SG155657 DB	'smpte170m', 00H
	ORG $+2
$SG155658 DB	'bt470bg', 00H
$SG155659 DB	'smpte240m', 00H
	ORG $+2
$SG155660 DB	'YCgCo', 00H
	ORG $+2
$SG155661 DB	'fcc', 00H
$SG155662 DB	'GBR', 00H
$SG155663 DB	'bt2020nc', 00H
	ORG $+3
$SG155664 DB	'bt2020c', 00H
$SG155665 DB	'derived-ncl', 00H
$SG155666 DB	'derived-cl', 00H
	ORG $+1
$SG155667 DB	'ictco', 00H
	ORG $+2
$SG155668 DB	'2100-lms', 00H
	ORG $+3
?list_transfer@@3QBUCX_DESC@@B DD FLAT:$SG155809	; list_transfer
	DD	02H
	DD	FLAT:$SG155810
	DD	07fffffffH
	DD	FLAT:$SG155811
	DD	01H
	DD	FLAT:$SG155812
	DD	06H
	DD	FLAT:$SG155813
	DD	04H
	DD	FLAT:$SG155814
	DD	05H
	DD	FLAT:$SG155815
	DD	07H
	DD	FLAT:$SG155816
	DD	08H
	DD	FLAT:$SG155817
	DD	09H
	DD	FLAT:$SG155818
	DD	0aH
	DD	FLAT:$SG155819
	DD	0bH
	DD	FLAT:$SG155820
	DD	0cH
	DD	FLAT:$SG155821
	DD	0dH
	DD	FLAT:$SG155822
	DD	0eH
	DD	FLAT:$SG155823
	DD	0fH
	DD	FLAT:$SG155824
	DD	010H
	DD	FLAT:$SG155825
	DD	011H
	DD	FLAT:$SG155826
	DD	012H
	DD	00H
	DD	00H
$SG155809 DB	'undef', 00H
	ORG $+2
$SG155810 DB	'auto', 00H
	ORG $+3
$SG155811 DB	'bt709', 00H
	ORG $+2
$SG155812 DB	'smpte170m', 00H
	ORG $+2
$SG155813 DB	'bt470m', 00H
	ORG $+1
$SG155814 DB	'bt470bg', 00H
$SG155815 DB	'smpte240m', 00H
	ORG $+2
$SG155816 DB	'linear', 00H
	ORG $+1
$SG155817 DB	'log100', 00H
	ORG $+1
$SG155818 DB	'log316', 00H
	ORG $+1
$SG155819 DB	'iec61966-2-4', 00H
	ORG $+3
$SG155820 DB	'bt1361e', 00H
$SG155821 DB	'iec61966-2-1', 00H
	ORG $+3
$SG155822 DB	'bt2020-10', 00H
	ORG $+2
$SG155823 DB	'bt2020-12', 00H
	ORG $+2
$SG155824 DB	'smpte2084', 00H
	ORG $+2
$SG155825 DB	'smpte428', 00H
	ORG $+3
$SG155826 DB	'arib-srd-b67', 00H
	ORG $+3
?list_colorprim@@3QBUCX_DESC@@B DD FLAT:$SG155958	; list_colorprim
	DD	02H
	DD	FLAT:$SG155959
	DD	07fffffffH
	DD	FLAT:$SG155960
	DD	01H
	DD	FLAT:$SG155961
	DD	06H
	DD	FLAT:$SG155962
	DD	04H
	DD	FLAT:$SG155963
	DD	05H
	DD	FLAT:$SG155964
	DD	07H
	DD	FLAT:$SG155965
	DD	08H
	DD	FLAT:$SG155966
	DD	09H
	DD	FLAT:$SG155967
	DD	0aH
	DD	FLAT:$SG155968
	DD	0bH
	DD	FLAT:$SG155969
	DD	0cH
	DD	FLAT:$SG155970
	DD	0dH
	DD	00H
	DD	00H
$SG155958 DB	'undef', 00H
	ORG $+2
$SG155959 DB	'auto', 00H
	ORG $+3
$SG155960 DB	'bt709', 00H
	ORG $+2
$SG155961 DB	'smpte170m', 00H
	ORG $+2
$SG155962 DB	'bt470m', 00H
	ORG $+1
$SG155963 DB	'bt470bg', 00H
$SG155964 DB	'smpte240m', 00H
	ORG $+2
$SG155965 DB	'film', 00H
	ORG $+3
$SG155966 DB	'bt2020', 00H
	ORG $+1
$SG155967 DB	'st428', 00H
	ORG $+2
$SG155968 DB	'st431-2', 00H
$SG155969 DB	'st432-1', 00H
$SG155970 DB	'ebu3213-e', 00H
	ORG $+2
?list_videoformat@@3QBUCX_DESC@@B DD FLAT:$SG155972	; list_videoformat
	DD	05H
	DD	FLAT:$SG155973
	DD	02H
	DD	FLAT:$SG155974
	DD	00H
	DD	FLAT:$SG155975
	DD	01H
	DD	FLAT:$SG155976
	DD	03H
	DD	FLAT:$SG155977
	DD	04H
	DD	00H
	DD	00H
$SG155972 DB	'undef', 00H
	ORG $+2
$SG155973 DB	'ntsc', 00H
	ORG $+3
$SG155974 DB	'component', 00H
	ORG $+2
$SG155975 DB	'pal', 00H
$SG155976 DB	'secam', 00H
	ORG $+2
$SG155977 DB	'mac', 00H
$SG155979 DB	'0', 00H
	ORG $+2
$SG155980 DB	'1', 00H
	ORG $+2
$SG155981 DB	'2', 00H
	ORG $+2
$SG155982 DB	'3', 00H
	ORG $+2
$SG155983 DB	'4', 00H
	ORG $+2
$SG155984 DB	'5', 00H
	ORG $+2
$SG155986 DB	'limited', 00H
$SG155987 DB	'full', 00H
	ORG $+3
$SG155988 DB	'tv', 00H
	ORG $+1
$SG155989 DB	'pc', 00H
	ORG $+1
$SG157071 DB	'trace', 00H
	ORG $+2
$SG157072 DB	'debug', 00H
	ORG $+2
$SG157073 DB	'more', 00H
	ORG $+3
$SG157074 DB	'info', 00H
	ORG $+3
$SG157075 DB	'warn', 00H
	ORG $+3
$SG157076 DB	'error', 00H
	ORG $+2
$SG157078 DB	'cfr', 00H
$SG157079 DB	'vfr', 00H
$SG157080 DB	'forcecfr', 00H
	ORG $+3
$SG157082 DB	'swr', 00H
$SG157083 DB	'soxr', 00H
	ORG $+3
$SG173583 DB	'invalid argument', 00H
	ORG $+3
$SG173584 DB	'%s', 00H
	ORG $+1
$SG173585 DB	'C:\Program Files (x86)\Microsoft Visual Studio\2019\Comm'
	DB	'unity\VC\Tools\MSVC\14.23.28105\include\xmemory', 00H
$SG173586 DB	'C', 00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H
	DB	'g', 00H, 'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'F', 00H, 'i'
	DB	00H, 'l', 00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H
	DB	'8', 00H, '6', 00H, ')', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c'
	DB	00H, 'r', 00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H
	DB	' ', 00H, 'V', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l'
	DB	00H, ' ', 00H, 'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H
	DB	'o', 00H, '\', 00H, '2', 00H, '0', 00H, '1', 00H, '9', 00H, '\'
	DB	00H, 'C', 00H, 'o', 00H, 'm', 00H, 'm', 00H, 'u', 00H, 'n', 00H
	DB	'i', 00H, 't', 00H, 'y', 00H, '\', 00H, 'V', 00H, 'C', 00H, '\'
	DB	00H, 'T', 00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '\', 00H
	DB	'M', 00H, 'S', 00H, 'V', 00H, 'C', 00H, '\', 00H, '1', 00H, '4'
	DB	00H, '.', 00H, '2', 00H, '3', 00H, '.', 00H, '2', 00H, '8', 00H
	DB	'1', 00H, '0', 00H, '5', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c'
	DB	00H, 'l', 00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H
	DB	'm', 00H, 'e', 00H, 'm', 00H, 'o', 00H, 'r', 00H, 'y', 00H, 00H
	DB	00H
$SG173587 DB	's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H
	DB	'A', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a', 00H, 't'
	DB	00H, 'e', 00H, '_', 00H, 'm', 00H, 'a', 00H, 'n', 00H, 'u', 00H
	DB	'a', 00H, 'l', 00H, 'l', 00H, 'y', 00H, '_', 00H, 'v', 00H, 'e'
	DB	00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'a', 00H
	DB	'l', 00H, 'i', 00H, 'g', 00H, 'n', 00H, 'e', 00H, 'd', 00H, 00H
	DB	00H
	ORG $+2
$SG173588 DB	'"', 00H, 'i', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H
	DB	'i', 00H, 'd', 00H, ' ', 00H, 'a', 00H, 'r', 00H, 'g', 00H, 'u'
	DB	00H, 'm', 00H, 'e', 00H, 'n', 00H, 't', 00H, '"', 00H, 00H, 00H
	ORG $+2
$SG157475 DB	' (%dEU)', 00H
$SG157479 DB	' %d-%dMHz', 00H
	ORG $+2
$SG157481 DB	' %dMHz', 00H
	ORG $+1
$SG157483 DB	' [%dW]', 00H
	ORG $+1
$SG157485 DB	' (%s)', 00H
	ORG $+2
$SG157486 DB	'(R)', 00H
$SG157487 DB	'(TM)', 00H
	ORG $+3
$SG157514 DB	'[0]Intel HD Graphics', 00H
	ORG $+3
$SG157516 DB	'[1]Intel HD Graphics', 00H
	ORG $+3
$SG157518 DB	'Failed to get GPU Info.', 00H
$SG174275 DB	'C:\Program Files (x86)\Microsoft Visual Studio\2019\Comm'
	DB	'unity\VC\Tools\MSVC\14.23.28105\include\xlocale', 00H
$SG169842 DB	'containers incompatible for swap', 00H
	ORG $+3
$SG169843 DB	'%s', 00H
	ORG $+1
$SG169844 DB	'C:\Program Files (x86)\Microsoft Visual Studio\2019\Comm'
	DB	'unity\VC\Tools\MSVC\14.23.28105\include\xmemory', 00H
$SG169845 DB	'C', 00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H
	DB	'g', 00H, 'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'F', 00H, 'i'
	DB	00H, 'l', 00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H
	DB	'8', 00H, '6', 00H, ')', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c'
	DB	00H, 'r', 00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H
	DB	' ', 00H, 'V', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l'
	DB	00H, ' ', 00H, 'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H
	DB	'o', 00H, '\', 00H, '2', 00H, '0', 00H, '1', 00H, '9', 00H, '\'
	DB	00H, 'C', 00H, 'o', 00H, 'm', 00H, 'm', 00H, 'u', 00H, 'n', 00H
	DB	'i', 00H, 't', 00H, 'y', 00H, '\', 00H, 'V', 00H, 'C', 00H, '\'
	DB	00H, 'T', 00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '\', 00H
	DB	'M', 00H, 'S', 00H, 'V', 00H, 'C', 00H, '\', 00H, '1', 00H, '4'
	DB	00H, '.', 00H, '2', 00H, '3', 00H, '.', 00H, '2', 00H, '8', 00H
	DB	'1', 00H, '0', 00H, '5', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c'
	DB	00H, 'l', 00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H
	DB	'm', 00H, 'e', 00H, 'm', 00H, 'o', 00H, 'r', 00H, 'y', 00H, 00H
	DB	00H
$SG169846 DB	's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H
	DB	'P', 00H, 'o', 00H, 'c', 00H, 's', 00H, 00H, 00H
	ORG $+2
$SG169847 DB	'"', 00H, 'c', 00H, 'o', 00H, 'n', 00H, 't', 00H, 'a', 00H
	DB	'i', 00H, 'n', 00H, 'e', 00H, 'r', 00H, 's', 00H, ' ', 00H, 'i'
	DB	00H, 'n', 00H, 'c', 00H, 'o', 00H, 'm', 00H, 'p', 00H, 'a', 00H
	DB	't', 00H, 'i', 00H, 'b', 00H, 'l', 00H, 'e', 00H, ' ', 00H, 'f'
	DB	00H, 'o', 00H, 'r', 00H, ' ', 00H, 's', 00H, 'w', 00H, 'a', 00H
	DB	'p', 00H, '"', 00H, 00H, 00H
	ORG $+2
$SG154067 DB	'Invalid', 00H
$SG154068 DB	'nv12', 00H
	ORG $+3
$SG154069 DB	'yv12', 00H
	ORG $+3
$SG154070 DB	'yuy2', 00H
	ORG $+3
$SG154071 DB	'yuv422', 00H
	ORG $+1
$SG154072 DB	'nv16', 00H
	ORG $+3
$SG154073 DB	'yuv444', 00H
	ORG $+1
$SG154074 DB	'yv12(9bit)', 00H
	ORG $+1
$SG154075 DB	'yv12(10bit)', 00H
$SG154076 DB	'yv12(12bit)', 00H
$SG154077 DB	'yv12(14bit)', 00H
$SG154078 DB	'yv12(16bit)', 00H
$SG154079 DB	'p010', 00H
	ORG $+3
$SG154080 DB	'yuv422(9bit)', 00H
	ORG $+3
$SG154081 DB	'yuv422(10bit)', 00H
	ORG $+2
$SG154082 DB	'yuv422(12bit)', 00H
	ORG $+2
$SG154083 DB	'yuv422(14bit)', 00H
	ORG $+2
$SG154084 DB	'yuv422(16bit)', 00H
	ORG $+2
$SG154085 DB	'p210', 00H
	ORG $+3
$SG154086 DB	'yuv444(9bit)', 00H
	ORG $+3
$SG154087 DB	'yuv444(10bit)', 00H
	ORG $+2
$SG154088 DB	'yuv444(12bit)', 00H
	ORG $+2
$SG154089 DB	'yuv444(14bit)', 00H
	ORG $+2
$SG154090 DB	'yuv444(16bit)', 00H
	ORG $+2
$SG154091 DB	'yuva444', 00H
$SG154092 DB	'yuva444(16bit)', 00H
	ORG $+1
$SG154093 DB	'rgb24r', 00H
	ORG $+1
$SG154094 DB	'rgb32r', 00H
	ORG $+1
$SG154095 DB	'rgb24', 00H
	ORG $+2
$SG154096 DB	'rgb32', 00H
	ORG $+2
$SG154097 DB	'bgr24', 00H
	ORG $+2
$SG154098 DB	'bgr32', 00H
	ORG $+2
$SG154099 DB	'rgb', 00H
$SG154100 DB	'rgba', 00H
	ORG $+3
$SG154101 DB	'gbr', 00H
$SG154102 DB	'gbra', 00H
	ORG $+3
$SG154103 DB	'yc48', 00H
	ORG $+3
$SG154104 DB	'y8', 00H
	ORG $+1
$SG154105 DB	'yc16', 00H
	ORG $+3
$SG155036 DB	'H.264/AVC', 00H
	ORG $+2
$SG155038 DB	'H.265/HEVC', 00H
	ORG $+1
$SG155040 DB	'MPEG2', 00H
	ORG $+2
$SG155042 DB	'MPEG1', 00H
	ORG $+2
$SG155044 DB	'VC-1', 00H
	ORG $+3
$SG155046 DB	'MPEG4', 00H
	ORG $+2
$SG155048 DB	'VP8', 00H
$SG155050 DB	'VP9', 00H
$SG155052 DB	'unknown', 00H
$SG155159 DB	'unknown', 00H
CONST	ENDS
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	__tcsstr
PUBLIC	?_tcsstr@@YAPADPADPBD@Z				; _tcsstr
PUBLIC	___local_stdio_printf_options
PUBLIC	__vsprintf_s_l
PUBLIC	_sprintf_s
PUBLIC	?getGPUInfo@@YAHPBDPADI_N@Z			; getGPUInfo
PUBLIC	??$make_array@W4CspMatrix@@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@@@YA?AV?$array@W4CspMatrix@@$0O@@std@@$$QAW4CspMatrix@@0000000000000@Z ; make_array<enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix>
PUBLIC	??$make_array@W4CspTransfer@@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@@@YA?AV?$array@W4CspTransfer@@$0P@@std@@$$QAW4CspTransfer@@00000000000000@Z ; make_array<enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer>
PUBLIC	??$make_array@W4CspColorprim@@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@@@YA?AV?$array@W4CspColorprim@@$0M@@std@@$$QAW4CspColorprim@@00000000000@Z ; make_array<enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim>
PUBLIC	?getIntelGPUInfo@@YAHPAUIntelDeviceInfo@@@Z	; getIntelGPUInfo
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	__imp__strcpy_s:PROC
EXTRN	_strlen:PROC
EXTRN	__imp___mbsstr:PROC
EXTRN	__imp____stdio_common_vsprintf_s:PROC
EXTRN	?cl_get_func@@YAHPAUcl_func_t@@@Z:PROC		; cl_get_func
EXTRN	?cl_get_platform_and_device@@YAHPBDHPAUcl_data_t@@PBUcl_func_t@@@Z:PROC ; cl_get_platform_and_device
EXTRN	?cl_get_device_max_compute_units@@YAHPBUcl_data_t@@PBUcl_func_t@@@Z:PROC ; cl_get_device_max_compute_units
EXTRN	?cl_get_device_name@@YAHPBUcl_data_t@@PBUcl_func_t@@PADI@Z:PROC ; cl_get_device_name
EXTRN	?cl_get_driver_version@@YAHPBUcl_data_t@@PBUcl_func_t@@PADI@Z:PROC ; cl_get_driver_version
EXTRN	?cl_release@@YAXPAUcl_data_t@@PAUcl_func_t@@@Z:PROC ; cl_release
EXTRN	?cl_get_device_max_clock_frequency_mhz@@YAHPBUcl_data_t@@PBUcl_func_t@@@Z:PROC ; cl_get_device_max_clock_frequency_mhz
EXTRN	?getGraphicsDeviceInfo@@YA_NPAI00@Z:PROC	; getGraphicsDeviceInfo
EXTRN	?getIntelDeviceInfo@@YAJIPAUIntelDeviceInfoHeader@@PAX@Z:PROC ; getIntelDeviceInfo
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	_memset:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
_BSS	SEGMENT
?CspMatrixList@@3V?$array@W4CspMatrix@@$0O@@std@@B DB 038H DUP (?) ; CspMatrixList
?CspTransferList@@3V?$array@W4CspTransfer@@$0P@@std@@B DB 03cH DUP (?) ; CspTransferList
?CspColorprimList@@3V?$array@W4CspColorprim@@$0M@@std@@B DB 030H DUP (?) ; CspColorprimList
_BSS	ENDS
CRT$XCU	SEGMENT
?CspMatrixList$initializer$@@3P6AXXZA DD FLAT:??__ECspMatrixList@@YAXXZ ; CspMatrixList$initializer$
CRT$XCU	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
CRT$XCU	SEGMENT
?CspTransferList$initializer$@@3P6AXXZA DD FLAT:??__ECspTransferList@@YAXXZ ; CspTransferList$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?CspColorprimList$initializer$@@3P6AXXZA DD FLAT:??__ECspColorprimList@@YAXXZ ; CspColorprimList$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\gpu_info.cpp
_TEXT	SEGMENT
_intelDeviceInfo$ = -1116				; size = 24
_intelDeviceInfoBuffer$ = -1084				; size = 1024
_intelDeviceInfoHeader$ = -52				; size = 8
_VideoMemory$ = -36					; size = 4
_DeviceId$ = -24					; size = 4
_VendorId$ = -12					; size = 4
__$ArrayPad$ = -4					; size = 4
_info$ = 8						; size = 4
?getIntelGPUInfo@@YAHPAUIntelDeviceInfo@@@Z PROC	; getIntelGPUInfo

; 108  : int getIntelGPUInfo(IntelDeviceInfo *info) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 60 04 00
	00		 sub	 esp, 1120		; 00000460H
  00009	57		 push	 edi
  0000a	8d bd a0 fb ff
	ff		 lea	 edi, DWORD PTR [ebp-1120]
  00010	b9 18 01 00 00	 mov	 ecx, 280		; 00000118H
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 109  :     memset(info, 0, sizeof(info[0]));

  00026	6a 1c		 push	 28			; 0000001cH
  00028	6a 00		 push	 0
  0002a	8b 45 08	 mov	 eax, DWORD PTR _info$[ebp]
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 _memset
  00033	83 c4 0c	 add	 esp, 12			; 0000000cH

; 110  : 
; 111  :     unsigned int VendorId, DeviceId, VideoMemory;
; 112  :     if (!getGraphicsDeviceInfo(&VendorId, &DeviceId, &VideoMemory)) {

  00036	8d 4d dc	 lea	 ecx, DWORD PTR _VideoMemory$[ebp]
  00039	51		 push	 ecx
  0003a	8d 55 e8	 lea	 edx, DWORD PTR _DeviceId$[ebp]
  0003d	52		 push	 edx
  0003e	8d 45 f4	 lea	 eax, DWORD PTR _VendorId$[ebp]
  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 ?getGraphicsDeviceInfo@@YA_NPAI00@Z ; getGraphicsDeviceInfo
  00047	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004a	0f b6 c8	 movzx	 ecx, al
  0004d	85 c9		 test	 ecx, ecx
  0004f	75 0a		 jne	 SHORT $LN2@getIntelGP

; 113  :         return 1;

  00051	b8 01 00 00 00	 mov	 eax, 1
  00056	e9 c5 00 00 00	 jmp	 $LN1@getIntelGP
$LN2@getIntelGP:

; 114  :     }
; 115  :     info->GPUMemoryBytes = VideoMemory;

  0005b	8b 55 08	 mov	 edx, DWORD PTR _info$[ebp]
  0005e	8b 45 dc	 mov	 eax, DWORD PTR _VideoMemory$[ebp]
  00061	89 02		 mov	 DWORD PTR [edx], eax

; 116  : 
; 117  :     IntelDeviceInfoHeader intelDeviceInfoHeader = { 0 };

  00063	33 c9		 xor	 ecx, ecx
  00065	89 4d cc	 mov	 DWORD PTR _intelDeviceInfoHeader$[ebp], ecx
  00068	89 4d d0	 mov	 DWORD PTR _intelDeviceInfoHeader$[ebp+4], ecx

; 118  :     char intelDeviceInfoBuffer[1024];
; 119  :     if (GGF_SUCCESS != getIntelDeviceInfo(VendorId, &intelDeviceInfoHeader, &intelDeviceInfoBuffer)) {

  0006b	8d 95 c4 fb ff
	ff		 lea	 edx, DWORD PTR _intelDeviceInfoBuffer$[ebp]
  00071	52		 push	 edx
  00072	8d 45 cc	 lea	 eax, DWORD PTR _intelDeviceInfoHeader$[ebp]
  00075	50		 push	 eax
  00076	8b 4d f4	 mov	 ecx, DWORD PTR _VendorId$[ebp]
  00079	51		 push	 ecx
  0007a	e8 00 00 00 00	 call	 ?getIntelDeviceInfo@@YAJIPAUIntelDeviceInfoHeader@@PAX@Z ; getIntelDeviceInfo
  0007f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00082	85 c0		 test	 eax, eax
  00084	74 0a		 je	 SHORT $LN3@getIntelGP

; 120  :         return 1;

  00086	b8 01 00 00 00	 mov	 eax, 1
  0008b	e9 90 00 00 00	 jmp	 $LN1@getIntelGP
$LN3@getIntelGP:

; 121  :     }
; 122  : 
; 123  :     IntelDeviceInfoV2 intelDeviceInfo = { 0 };

  00090	33 d2		 xor	 edx, edx
  00092	89 95 a4 fb ff
	ff		 mov	 DWORD PTR _intelDeviceInfo$[ebp], edx
  00098	89 95 a8 fb ff
	ff		 mov	 DWORD PTR _intelDeviceInfo$[ebp+4], edx
  0009e	89 95 ac fb ff
	ff		 mov	 DWORD PTR _intelDeviceInfo$[ebp+8], edx
  000a4	89 95 b0 fb ff
	ff		 mov	 DWORD PTR _intelDeviceInfo$[ebp+12], edx
  000aa	89 95 b4 fb ff
	ff		 mov	 DWORD PTR _intelDeviceInfo$[ebp+16], edx
  000b0	89 95 b8 fb ff
	ff		 mov	 DWORD PTR _intelDeviceInfo$[ebp+20], edx

; 124  :     memcpy(&intelDeviceInfo, intelDeviceInfoBuffer, intelDeviceInfoHeader.Size);

  000b6	8b 45 cc	 mov	 eax, DWORD PTR _intelDeviceInfoHeader$[ebp]
  000b9	50		 push	 eax
  000ba	8d 8d c4 fb ff
	ff		 lea	 ecx, DWORD PTR _intelDeviceInfoBuffer$[ebp]
  000c0	51		 push	 ecx
  000c1	8d 95 a4 fb ff
	ff		 lea	 edx, DWORD PTR _intelDeviceInfo$[ebp]
  000c7	52		 push	 edx
  000c8	e8 00 00 00 00	 call	 _memcpy
  000cd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 125  :     info->GPUMaxFreqMHz = intelDeviceInfo.GPUMaxFreq;

  000d0	8b 45 08	 mov	 eax, DWORD PTR _info$[ebp]
  000d3	8b 8d a4 fb ff
	ff		 mov	 ecx, DWORD PTR _intelDeviceInfo$[ebp]
  000d9	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 126  :     info->GPUMinFreqMHz = intelDeviceInfo.GPUMinFreq;

  000dc	8b 55 08	 mov	 edx, DWORD PTR _info$[ebp]
  000df	8b 85 a8 fb ff
	ff		 mov	 eax, DWORD PTR _intelDeviceInfo$[ebp+4]
  000e5	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 127  :     if (intelDeviceInfoHeader.Version == 2) {

  000e8	83 7d d0 02	 cmp	 DWORD PTR _intelDeviceInfoHeader$[ebp+4], 2
  000ec	75 30		 jne	 SHORT $LN4@getIntelGP

; 128  :         info->EUCount      = intelDeviceInfo.EUCount;

  000ee	8b 4d 08	 mov	 ecx, DWORD PTR _info$[ebp]
  000f1	8b 95 b0 fb ff
	ff		 mov	 edx, DWORD PTR _intelDeviceInfo$[ebp+12]
  000f7	89 51 10	 mov	 DWORD PTR [ecx+16], edx

; 129  :         info->GTGeneration = intelDeviceInfo.GTGeneration;

  000fa	8b 45 08	 mov	 eax, DWORD PTR _info$[ebp]
  000fd	8b 8d ac fb ff
	ff		 mov	 ecx, DWORD PTR _intelDeviceInfo$[ebp+8]
  00103	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 130  :         info->MaxFillRate  = intelDeviceInfo.MaxFillRate;

  00106	8b 55 08	 mov	 edx, DWORD PTR _info$[ebp]
  00109	8b 85 b8 fb ff
	ff		 mov	 eax, DWORD PTR _intelDeviceInfo$[ebp+20]
  0010f	89 42 18	 mov	 DWORD PTR [edx+24], eax

; 131  :         info->PackageTDP   = intelDeviceInfo.PackageTDP;

  00112	8b 4d 08	 mov	 ecx, DWORD PTR _info$[ebp]
  00115	8b 95 b4 fb ff
	ff		 mov	 edx, DWORD PTR _intelDeviceInfo$[ebp+16]
  0011b	89 51 14	 mov	 DWORD PTR [ecx+20], edx
$LN4@getIntelGP:

; 132  :     }
; 133  :     return 0;

  0011e	33 c0		 xor	 eax, eax
$LN1@getIntelGP:

; 134  : }

  00120	52		 push	 edx
  00121	8b cd		 mov	 ecx, ebp
  00123	50		 push	 eax
  00124	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN13@getIntelGP
  0012a	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0012f	58		 pop	 eax
  00130	5a		 pop	 edx
  00131	5f		 pop	 edi
  00132	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00135	33 cd		 xor	 ecx, ebp
  00137	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0013c	81 c4 60 04 00
	00		 add	 esp, 1120		; 00000460H
  00142	3b ec		 cmp	 ebp, esp
  00144	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00149	8b e5		 mov	 esp, ebp
  0014b	5d		 pop	 ebp
  0014c	c3		 ret	 0
  0014d	0f 1f 00	 npad	 3
$LN13@getIntelGP:
  00150	06 00 00 00	 DD	 6
  00154	00 00 00 00	 DD	 $LN12@getIntelGP
$LN12@getIntelGP:
  00158	f4 ff ff ff	 DD	 -12			; fffffff4H
  0015c	04 00 00 00	 DD	 4
  00160	00 00 00 00	 DD	 $LN6@getIntelGP
  00164	e8 ff ff ff	 DD	 -24			; ffffffe8H
  00168	04 00 00 00	 DD	 4
  0016c	00 00 00 00	 DD	 $LN7@getIntelGP
  00170	dc ff ff ff	 DD	 -36			; ffffffdcH
  00174	04 00 00 00	 DD	 4
  00178	00 00 00 00	 DD	 $LN8@getIntelGP
  0017c	cc ff ff ff	 DD	 -52			; ffffffccH
  00180	08 00 00 00	 DD	 8
  00184	00 00 00 00	 DD	 $LN9@getIntelGP
  00188	c4 fb ff ff	 DD	 -1084			; fffffbc4H
  0018c	00 04 00 00	 DD	 1024			; 00000400H
  00190	00 00 00 00	 DD	 $LN10@getIntelGP
  00194	a4 fb ff ff	 DD	 -1116			; fffffba4H
  00198	18 00 00 00	 DD	 24			; 00000018H
  0019c	00 00 00 00	 DD	 $LN11@getIntelGP
$LN11@getIntelGP:
  001a0	69		 DB	 105			; 00000069H
  001a1	6e		 DB	 110			; 0000006eH
  001a2	74		 DB	 116			; 00000074H
  001a3	65		 DB	 101			; 00000065H
  001a4	6c		 DB	 108			; 0000006cH
  001a5	44		 DB	 68			; 00000044H
  001a6	65		 DB	 101			; 00000065H
  001a7	76		 DB	 118			; 00000076H
  001a8	69		 DB	 105			; 00000069H
  001a9	63		 DB	 99			; 00000063H
  001aa	65		 DB	 101			; 00000065H
  001ab	49		 DB	 73			; 00000049H
  001ac	6e		 DB	 110			; 0000006eH
  001ad	66		 DB	 102			; 00000066H
  001ae	6f		 DB	 111			; 0000006fH
  001af	00		 DB	 0
$LN10@getIntelGP:
  001b0	69		 DB	 105			; 00000069H
  001b1	6e		 DB	 110			; 0000006eH
  001b2	74		 DB	 116			; 00000074H
  001b3	65		 DB	 101			; 00000065H
  001b4	6c		 DB	 108			; 0000006cH
  001b5	44		 DB	 68			; 00000044H
  001b6	65		 DB	 101			; 00000065H
  001b7	76		 DB	 118			; 00000076H
  001b8	69		 DB	 105			; 00000069H
  001b9	63		 DB	 99			; 00000063H
  001ba	65		 DB	 101			; 00000065H
  001bb	49		 DB	 73			; 00000049H
  001bc	6e		 DB	 110			; 0000006eH
  001bd	66		 DB	 102			; 00000066H
  001be	6f		 DB	 111			; 0000006fH
  001bf	42		 DB	 66			; 00000042H
  001c0	75		 DB	 117			; 00000075H
  001c1	66		 DB	 102			; 00000066H
  001c2	66		 DB	 102			; 00000066H
  001c3	65		 DB	 101			; 00000065H
  001c4	72		 DB	 114			; 00000072H
  001c5	00		 DB	 0
$LN9@getIntelGP:
  001c6	69		 DB	 105			; 00000069H
  001c7	6e		 DB	 110			; 0000006eH
  001c8	74		 DB	 116			; 00000074H
  001c9	65		 DB	 101			; 00000065H
  001ca	6c		 DB	 108			; 0000006cH
  001cb	44		 DB	 68			; 00000044H
  001cc	65		 DB	 101			; 00000065H
  001cd	76		 DB	 118			; 00000076H
  001ce	69		 DB	 105			; 00000069H
  001cf	63		 DB	 99			; 00000063H
  001d0	65		 DB	 101			; 00000065H
  001d1	49		 DB	 73			; 00000049H
  001d2	6e		 DB	 110			; 0000006eH
  001d3	66		 DB	 102			; 00000066H
  001d4	6f		 DB	 111			; 0000006fH
  001d5	48		 DB	 72			; 00000048H
  001d6	65		 DB	 101			; 00000065H
  001d7	61		 DB	 97			; 00000061H
  001d8	64		 DB	 100			; 00000064H
  001d9	65		 DB	 101			; 00000065H
  001da	72		 DB	 114			; 00000072H
  001db	00		 DB	 0
$LN8@getIntelGP:
  001dc	56		 DB	 86			; 00000056H
  001dd	69		 DB	 105			; 00000069H
  001de	64		 DB	 100			; 00000064H
  001df	65		 DB	 101			; 00000065H
  001e0	6f		 DB	 111			; 0000006fH
  001e1	4d		 DB	 77			; 0000004dH
  001e2	65		 DB	 101			; 00000065H
  001e3	6d		 DB	 109			; 0000006dH
  001e4	6f		 DB	 111			; 0000006fH
  001e5	72		 DB	 114			; 00000072H
  001e6	79		 DB	 121			; 00000079H
  001e7	00		 DB	 0
$LN7@getIntelGP:
  001e8	44		 DB	 68			; 00000044H
  001e9	65		 DB	 101			; 00000065H
  001ea	76		 DB	 118			; 00000076H
  001eb	69		 DB	 105			; 00000069H
  001ec	63		 DB	 99			; 00000063H
  001ed	65		 DB	 101			; 00000065H
  001ee	49		 DB	 73			; 00000049H
  001ef	64		 DB	 100			; 00000064H
  001f0	00		 DB	 0
$LN6@getIntelGP:
  001f1	56		 DB	 86			; 00000056H
  001f2	65		 DB	 101			; 00000065H
  001f3	6e		 DB	 110			; 0000006eH
  001f4	64		 DB	 100			; 00000064H
  001f5	6f		 DB	 111			; 0000006fH
  001f6	72		 DB	 114			; 00000072H
  001f7	49		 DB	 73			; 00000049H
  001f8	64		 DB	 100			; 00000064H
  001f9	00		 DB	 0
?getIntelGPUInfo@@YAHPAUIntelDeviceInfo@@@Z ENDP	; getIntelGPUInfo
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\gpu_info.cpp
;	COMDAT ??R<lambda_a635cb7f9ae02adf9169c43845d911a3>@@QBEXPADPBD@Z
_TEXT	SEGMENT
_ptr$ = -8						; size = 4
_this$ = -4						; size = 4
_target_str$ = 8					; size = 4
_remove_str$ = 12					; size = 4
??R<lambda_a635cb7f9ae02adf9169c43845d911a3>@@QBEXPADPBD@Z PROC ; <lambda_a635cb7f9ae02adf9169c43845d911a3>::operator(), COMDAT
; _this$ = ecx

; 94   :     auto remove_string =[](TCHAR *target_str, const TCHAR *remove_str) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00015	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 95   :         TCHAR *ptr = _tcsstr(target_str, remove_str);

  00018	8b 45 0c	 mov	 eax, DWORD PTR _remove_str$[ebp]
  0001b	50		 push	 eax
  0001c	8b 4d 08	 mov	 ecx, DWORD PTR _target_str$[ebp]
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ?_tcsstr@@YAPADPADPBD@Z	; _tcsstr
  00025	83 c4 08	 add	 esp, 8
  00028	89 45 f8	 mov	 DWORD PTR _ptr$[ebp], eax

; 96   :         if (nullptr != ptr) {

  0002b	83 7d f8 00	 cmp	 DWORD PTR _ptr$[ebp], 0
  0002f	74 3c		 je	 SHORT $LN1@operator

; 97   :             memmove(ptr, ptr + _tcslen(remove_str), (_tcslen(ptr) - _tcslen(remove_str) + 1) *  sizeof(target_str[0]));

  00031	8b 55 f8	 mov	 edx, DWORD PTR _ptr$[ebp]
  00034	52		 push	 edx
  00035	e8 00 00 00 00	 call	 _strlen
  0003a	83 c4 04	 add	 esp, 4
  0003d	8b f0		 mov	 esi, eax
  0003f	8b 45 0c	 mov	 eax, DWORD PTR _remove_str$[ebp]
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 _strlen
  00048	83 c4 04	 add	 esp, 4
  0004b	2b f0		 sub	 esi, eax
  0004d	83 c6 01	 add	 esi, 1
  00050	56		 push	 esi
  00051	8b 4d 0c	 mov	 ecx, DWORD PTR _remove_str$[ebp]
  00054	51		 push	 ecx
  00055	e8 00 00 00 00	 call	 _strlen
  0005a	83 c4 04	 add	 esp, 4
  0005d	03 45 f8	 add	 eax, DWORD PTR _ptr$[ebp]
  00060	50		 push	 eax
  00061	8b 55 f8	 mov	 edx, DWORD PTR _ptr$[ebp]
  00064	52		 push	 edx
  00065	e8 00 00 00 00	 call	 _memmove
  0006a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@operator:

; 98   :         }
; 99   :     };

  0006d	5e		 pop	 esi
  0006e	83 c4 08	 add	 esp, 8
  00071	3b ec		 cmp	 ebp, esp
  00073	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c2 08 00	 ret	 8
??R<lambda_a635cb7f9ae02adf9169c43845d911a3>@@QBEXPADPBD@Z ENDP ; <lambda_a635cb7f9ae02adf9169c43845d911a3>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\gpu_info.cpp
_TEXT	SEGMENT
tv94 = -312						; size = 4
tv91 = -308						; size = 4
tv72 = -304						; size = 4
$T1 = -297						; size = 1
_remove_string$ = -289					; size = 1
_driver_ver$ = -280					; size = 256
_MinFreqMHz$ = -20					; size = 4
_MaxFreqMHz$ = -16					; size = 4
_numEU$ = -12						; size = 4
_ret$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_cl_data$ = 8						; size = 4
_cl$ = 12						; size = 4
_info$ = 16						; size = 4
_buffer$ = 20						; size = 4
_buffer_size$ = 24					; size = 4
?cl_create_info_string@@YAHPAUcl_data_t@@PBUcl_func_t@@PBUIntelDeviceInfo@@PADI@Z PROC ; cl_create_info_string

; 62   : static cl_int cl_create_info_string(cl_data_t *cl_data, const cl_func_t *cl, const IntelDeviceInfo *info, TCHAR *buffer, unsigned int buffer_size) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 38 01 00
	00		 sub	 esp, 312		; 00000138H
  00009	57		 push	 edi
  0000a	8d bd c8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-312]
  00010	b9 4e 00 00 00	 mov	 ecx, 78			; 0000004eH
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 63   :     cl_int ret = CL_SUCCESS;

  00026	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 0

; 64   : 
; 65   :     if (cl_data) {

  0002d	83 7d 08 00	 cmp	 DWORD PTR _cl_data$[ebp], 0
  00031	74 1b		 je	 SHORT $LN2@cl_create_

; 66   :         ret = cl_get_device_name(cl_data, cl, buffer, buffer_size);

  00033	8b 45 18	 mov	 eax, DWORD PTR _buffer_size$[ebp]
  00036	50		 push	 eax
  00037	8b 4d 14	 mov	 ecx, DWORD PTR _buffer$[ebp]
  0003a	51		 push	 ecx
  0003b	8b 55 0c	 mov	 edx, DWORD PTR _cl$[ebp]
  0003e	52		 push	 edx
  0003f	8b 45 08	 mov	 eax, DWORD PTR _cl_data$[ebp]
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 ?cl_get_device_name@@YAHPBUcl_data_t@@PBUcl_func_t@@PADI@Z ; cl_get_device_name
  00048	83 c4 10	 add	 esp, 16			; 00000010H
  0004b	89 45 f8	 mov	 DWORD PTR _ret$[ebp], eax
$LN2@cl_create_:

; 67   :     }
; 68   : 
; 69   :     int numEU = (info) ? info->EUCount : 0;

  0004e	83 7d 10 00	 cmp	 DWORD PTR _info$[ebp], 0
  00052	74 0e		 je	 SHORT $LN12@cl_create_
  00054	8b 4d 10	 mov	 ecx, DWORD PTR _info$[ebp]
  00057	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0005a	89 95 d0 fe ff
	ff		 mov	 DWORD PTR tv72[ebp], edx
  00060	eb 0a		 jmp	 SHORT $LN13@cl_create_
$LN12@cl_create_:
  00062	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv72[ebp], 0
$LN13@cl_create_:
  0006c	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR tv72[ebp]
  00072	89 45 f4	 mov	 DWORD PTR _numEU$[ebp], eax

; 70   :     if (numEU == 0 && cl_data) {

  00075	83 7d f4 00	 cmp	 DWORD PTR _numEU$[ebp], 0
  00079	75 19		 jne	 SHORT $LN3@cl_create_
  0007b	83 7d 08 00	 cmp	 DWORD PTR _cl_data$[ebp], 0
  0007f	74 13		 je	 SHORT $LN3@cl_create_

; 71   :         numEU = cl_get_device_max_compute_units(cl_data, cl);

  00081	8b 4d 0c	 mov	 ecx, DWORD PTR _cl$[ebp]
  00084	51		 push	 ecx
  00085	8b 55 08	 mov	 edx, DWORD PTR _cl_data$[ebp]
  00088	52		 push	 edx
  00089	e8 00 00 00 00	 call	 ?cl_get_device_max_compute_units@@YAHPBUcl_data_t@@PBUcl_func_t@@@Z ; cl_get_device_max_compute_units
  0008e	83 c4 08	 add	 esp, 8
  00091	89 45 f4	 mov	 DWORD PTR _numEU$[ebp], eax
$LN3@cl_create_:

; 72   :     }
; 73   :     if (numEU) {

  00094	83 7d f4 00	 cmp	 DWORD PTR _numEU$[ebp], 0
  00098	74 33		 je	 SHORT $LN4@cl_create_

; 74   :         _stprintf_s(buffer + _tcslen(buffer), buffer_size - _tcslen(buffer), _T(" (%dEU)"), numEU);

  0009a	8b 45 f4	 mov	 eax, DWORD PTR _numEU$[ebp]
  0009d	50		 push	 eax
  0009e	68 00 00 00 00	 push	 OFFSET $SG157475
  000a3	8b 4d 14	 mov	 ecx, DWORD PTR _buffer$[ebp]
  000a6	51		 push	 ecx
  000a7	e8 00 00 00 00	 call	 _strlen
  000ac	83 c4 04	 add	 esp, 4
  000af	8b 55 18	 mov	 edx, DWORD PTR _buffer_size$[ebp]
  000b2	2b d0		 sub	 edx, eax
  000b4	52		 push	 edx
  000b5	8b 45 14	 mov	 eax, DWORD PTR _buffer$[ebp]
  000b8	50		 push	 eax
  000b9	e8 00 00 00 00	 call	 _strlen
  000be	83 c4 04	 add	 esp, 4
  000c1	03 45 14	 add	 eax, DWORD PTR _buffer$[ebp]
  000c4	50		 push	 eax
  000c5	e8 00 00 00 00	 call	 _sprintf_s
  000ca	83 c4 10	 add	 esp, 16			; 00000010H
$LN4@cl_create_:

; 75   :     }
; 76   : 
; 77   :     int MaxFreqMHz = (info) ? info->GPUMaxFreqMHz : 0;

  000cd	83 7d 10 00	 cmp	 DWORD PTR _info$[ebp], 0
  000d1	74 0e		 je	 SHORT $LN14@cl_create_
  000d3	8b 4d 10	 mov	 ecx, DWORD PTR _info$[ebp]
  000d6	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000d9	89 95 cc fe ff
	ff		 mov	 DWORD PTR tv91[ebp], edx
  000df	eb 0a		 jmp	 SHORT $LN15@cl_create_
$LN14@cl_create_:
  000e1	c7 85 cc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv91[ebp], 0
$LN15@cl_create_:
  000eb	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR tv91[ebp]
  000f1	89 45 f0	 mov	 DWORD PTR _MaxFreqMHz$[ebp], eax

; 78   :     int MinFreqMHz = (info) ? info->GPUMinFreqMHz : 0;

  000f4	83 7d 10 00	 cmp	 DWORD PTR _info$[ebp], 0
  000f8	74 0e		 je	 SHORT $LN16@cl_create_
  000fa	8b 4d 10	 mov	 ecx, DWORD PTR _info$[ebp]
  000fd	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00100	89 95 c8 fe ff
	ff		 mov	 DWORD PTR tv94[ebp], edx
  00106	eb 0a		 jmp	 SHORT $LN17@cl_create_
$LN16@cl_create_:
  00108	c7 85 c8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv94[ebp], 0
$LN17@cl_create_:
  00112	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR tv94[ebp]
  00118	89 45 ec	 mov	 DWORD PTR _MinFreqMHz$[ebp], eax

; 79   :     if (MaxFreqMHz == 0 && cl_data) {

  0011b	83 7d f0 00	 cmp	 DWORD PTR _MaxFreqMHz$[ebp], 0
  0011f	75 19		 jne	 SHORT $LN5@cl_create_
  00121	83 7d 08 00	 cmp	 DWORD PTR _cl_data$[ebp], 0
  00125	74 13		 je	 SHORT $LN5@cl_create_

; 80   :         MaxFreqMHz = cl_get_device_max_clock_frequency_mhz(cl_data, cl);

  00127	8b 4d 0c	 mov	 ecx, DWORD PTR _cl$[ebp]
  0012a	51		 push	 ecx
  0012b	8b 55 08	 mov	 edx, DWORD PTR _cl_data$[ebp]
  0012e	52		 push	 edx
  0012f	e8 00 00 00 00	 call	 ?cl_get_device_max_clock_frequency_mhz@@YAHPBUcl_data_t@@PBUcl_func_t@@@Z ; cl_get_device_max_clock_frequency_mhz
  00134	83 c4 08	 add	 esp, 8
  00137	89 45 f0	 mov	 DWORD PTR _MaxFreqMHz$[ebp], eax
$LN5@cl_create_:

; 81   :     }
; 82   :     if (MaxFreqMHz && MinFreqMHz) {

  0013a	83 7d f0 00	 cmp	 DWORD PTR _MaxFreqMHz$[ebp], 0
  0013e	74 3f		 je	 SHORT $LN6@cl_create_
  00140	83 7d ec 00	 cmp	 DWORD PTR _MinFreqMHz$[ebp], 0
  00144	74 39		 je	 SHORT $LN6@cl_create_

; 83   :         _stprintf_s(buffer + _tcslen(buffer), buffer_size - _tcslen(buffer), _T(" %d-%dMHz"), MinFreqMHz, MaxFreqMHz);

  00146	8b 45 f0	 mov	 eax, DWORD PTR _MaxFreqMHz$[ebp]
  00149	50		 push	 eax
  0014a	8b 4d ec	 mov	 ecx, DWORD PTR _MinFreqMHz$[ebp]
  0014d	51		 push	 ecx
  0014e	68 00 00 00 00	 push	 OFFSET $SG157479
  00153	8b 55 14	 mov	 edx, DWORD PTR _buffer$[ebp]
  00156	52		 push	 edx
  00157	e8 00 00 00 00	 call	 _strlen
  0015c	83 c4 04	 add	 esp, 4
  0015f	8b 4d 18	 mov	 ecx, DWORD PTR _buffer_size$[ebp]
  00162	2b c8		 sub	 ecx, eax
  00164	51		 push	 ecx
  00165	8b 55 14	 mov	 edx, DWORD PTR _buffer$[ebp]
  00168	52		 push	 edx
  00169	e8 00 00 00 00	 call	 _strlen
  0016e	83 c4 04	 add	 esp, 4
  00171	03 45 14	 add	 eax, DWORD PTR _buffer$[ebp]
  00174	50		 push	 eax
  00175	e8 00 00 00 00	 call	 _sprintf_s
  0017a	83 c4 14	 add	 esp, 20			; 00000014H
  0017d	eb 39		 jmp	 SHORT $LN7@cl_create_
$LN6@cl_create_:

; 84   :     } else if (MaxFreqMHz) {

  0017f	83 7d f0 00	 cmp	 DWORD PTR _MaxFreqMHz$[ebp], 0
  00183	74 33		 je	 SHORT $LN7@cl_create_

; 85   :         _stprintf_s(buffer + _tcslen(buffer), buffer_size - _tcslen(buffer), _T(" %dMHz"), MaxFreqMHz);

  00185	8b 45 f0	 mov	 eax, DWORD PTR _MaxFreqMHz$[ebp]
  00188	50		 push	 eax
  00189	68 00 00 00 00	 push	 OFFSET $SG157481
  0018e	8b 4d 14	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00191	51		 push	 ecx
  00192	e8 00 00 00 00	 call	 _strlen
  00197	83 c4 04	 add	 esp, 4
  0019a	8b 55 18	 mov	 edx, DWORD PTR _buffer_size$[ebp]
  0019d	2b d0		 sub	 edx, eax
  0019f	52		 push	 edx
  001a0	8b 45 14	 mov	 eax, DWORD PTR _buffer$[ebp]
  001a3	50		 push	 eax
  001a4	e8 00 00 00 00	 call	 _strlen
  001a9	83 c4 04	 add	 esp, 4
  001ac	03 45 14	 add	 eax, DWORD PTR _buffer$[ebp]
  001af	50		 push	 eax
  001b0	e8 00 00 00 00	 call	 _sprintf_s
  001b5	83 c4 10	 add	 esp, 16			; 00000010H
$LN7@cl_create_:

; 86   :     }
; 87   :     if (info && info->PackageTDP) {

  001b8	83 7d 10 00	 cmp	 DWORD PTR _info$[ebp], 0
  001bc	74 3f		 je	 SHORT $LN9@cl_create_
  001be	8b 4d 10	 mov	 ecx, DWORD PTR _info$[ebp]
  001c1	83 79 14 00	 cmp	 DWORD PTR [ecx+20], 0
  001c5	74 36		 je	 SHORT $LN9@cl_create_

; 88   :         _stprintf_s(buffer + _tcslen(buffer), buffer_size - _tcslen(buffer), _T(" [%dW]"), info->PackageTDP);

  001c7	8b 55 10	 mov	 edx, DWORD PTR _info$[ebp]
  001ca	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  001cd	50		 push	 eax
  001ce	68 00 00 00 00	 push	 OFFSET $SG157483
  001d3	8b 4d 14	 mov	 ecx, DWORD PTR _buffer$[ebp]
  001d6	51		 push	 ecx
  001d7	e8 00 00 00 00	 call	 _strlen
  001dc	83 c4 04	 add	 esp, 4
  001df	8b 55 18	 mov	 edx, DWORD PTR _buffer_size$[ebp]
  001e2	2b d0		 sub	 edx, eax
  001e4	52		 push	 edx
  001e5	8b 45 14	 mov	 eax, DWORD PTR _buffer$[ebp]
  001e8	50		 push	 eax
  001e9	e8 00 00 00 00	 call	 _strlen
  001ee	83 c4 04	 add	 esp, 4
  001f1	03 45 14	 add	 eax, DWORD PTR _buffer$[ebp]
  001f4	50		 push	 eax
  001f5	e8 00 00 00 00	 call	 _sprintf_s
  001fa	83 c4 10	 add	 esp, 16			; 00000010H
$LN9@cl_create_:

; 89   :     }
; 90   :     TCHAR driver_ver[256] = { 0 };

  001fd	68 00 01 00 00	 push	 256			; 00000100H
  00202	6a 00		 push	 0
  00204	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _driver_ver$[ebp]
  0020a	51		 push	 ecx
  0020b	e8 00 00 00 00	 call	 _memset
  00210	83 c4 0c	 add	 esp, 12			; 0000000cH

; 91   :     if (cl_data && CL_SUCCESS == cl_get_driver_version(cl_data, cl, driver_ver, _countof(driver_ver))) {

  00213	83 7d 08 00	 cmp	 DWORD PTR _cl_data$[ebp], 0
  00217	74 56		 je	 SHORT $LN10@cl_create_
  00219	68 00 01 00 00	 push	 256			; 00000100H
  0021e	8d 95 e8 fe ff
	ff		 lea	 edx, DWORD PTR _driver_ver$[ebp]
  00224	52		 push	 edx
  00225	8b 45 0c	 mov	 eax, DWORD PTR _cl$[ebp]
  00228	50		 push	 eax
  00229	8b 4d 08	 mov	 ecx, DWORD PTR _cl_data$[ebp]
  0022c	51		 push	 ecx
  0022d	e8 00 00 00 00	 call	 ?cl_get_driver_version@@YAHPBUcl_data_t@@PBUcl_func_t@@PADI@Z ; cl_get_driver_version
  00232	83 c4 10	 add	 esp, 16			; 00000010H
  00235	85 c0		 test	 eax, eax
  00237	75 36		 jne	 SHORT $LN10@cl_create_

; 92   :         _stprintf_s(buffer + _tcslen(buffer), buffer_size - _tcslen(buffer), _T(" (%s)"), driver_ver);

  00239	8d 95 e8 fe ff
	ff		 lea	 edx, DWORD PTR _driver_ver$[ebp]
  0023f	52		 push	 edx
  00240	68 00 00 00 00	 push	 OFFSET $SG157485
  00245	8b 45 14	 mov	 eax, DWORD PTR _buffer$[ebp]
  00248	50		 push	 eax
  00249	e8 00 00 00 00	 call	 _strlen
  0024e	83 c4 04	 add	 esp, 4
  00251	8b 4d 18	 mov	 ecx, DWORD PTR _buffer_size$[ebp]
  00254	2b c8		 sub	 ecx, eax
  00256	51		 push	 ecx
  00257	8b 55 14	 mov	 edx, DWORD PTR _buffer$[ebp]
  0025a	52		 push	 edx
  0025b	e8 00 00 00 00	 call	 _strlen
  00260	83 c4 04	 add	 esp, 4
  00263	03 45 14	 add	 eax, DWORD PTR _buffer$[ebp]
  00266	50		 push	 eax
  00267	e8 00 00 00 00	 call	 _sprintf_s
  0026c	83 c4 10	 add	 esp, 16			; 00000010H
$LN10@cl_create_:

; 93   :     }
; 94   :     auto remove_string =[](TCHAR *target_str, const TCHAR *remove_str) {

  0026f	33 c0		 xor	 eax, eax
  00271	88 85 d7 fe ff
	ff		 mov	 BYTE PTR $T1[ebp], al

; 95   :         TCHAR *ptr = _tcsstr(target_str, remove_str);
; 96   :         if (nullptr != ptr) {
; 97   :             memmove(ptr, ptr + _tcslen(remove_str), (_tcslen(ptr) - _tcslen(remove_str) + 1) *  sizeof(target_str[0]));
; 98   :         }
; 99   :     };
; 100  :     remove_string(buffer, _T("(R)"));

  00277	68 00 00 00 00	 push	 OFFSET $SG157486
  0027c	8b 4d 14	 mov	 ecx, DWORD PTR _buffer$[ebp]
  0027f	51		 push	 ecx
  00280	8d 8d df fe ff
	ff		 lea	 ecx, DWORD PTR _remove_string$[ebp]
  00286	e8 00 00 00 00	 call	 ??R<lambda_a635cb7f9ae02adf9169c43845d911a3>@@QBEXPADPBD@Z ; <lambda_a635cb7f9ae02adf9169c43845d911a3>::operator()

; 101  :     remove_string(buffer, _T("(TM)"));

  0028b	68 00 00 00 00	 push	 OFFSET $SG157487
  00290	8b 55 14	 mov	 edx, DWORD PTR _buffer$[ebp]
  00293	52		 push	 edx
  00294	8d 8d df fe ff
	ff		 lea	 ecx, DWORD PTR _remove_string$[ebp]
  0029a	e8 00 00 00 00	 call	 ??R<lambda_a635cb7f9ae02adf9169c43845d911a3>@@QBEXPADPBD@Z ; <lambda_a635cb7f9ae02adf9169c43845d911a3>::operator()

; 102  :     return ret;

  0029f	8b 45 f8	 mov	 eax, DWORD PTR _ret$[ebp]

; 103  : }

  002a2	52		 push	 edx
  002a3	8b cd		 mov	 ecx, ebp
  002a5	50		 push	 eax
  002a6	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN21@cl_create_
  002ac	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  002b1	58		 pop	 eax
  002b2	5a		 pop	 edx
  002b3	5f		 pop	 edi
  002b4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002b7	33 cd		 xor	 ecx, ebp
  002b9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002be	81 c4 38 01 00
	00		 add	 esp, 312		; 00000138H
  002c4	3b ec		 cmp	 ebp, esp
  002c6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002cb	8b e5		 mov	 esp, ebp
  002cd	5d		 pop	 ebp
  002ce	c3		 ret	 0
  002cf	90		 npad	 1
$LN21@cl_create_:
  002d0	02 00 00 00	 DD	 2
  002d4	00 00 00 00	 DD	 $LN20@cl_create_
$LN20@cl_create_:
  002d8	e8 fe ff ff	 DD	 -280			; fffffee8H
  002dc	00 01 00 00	 DD	 256			; 00000100H
  002e0	00 00 00 00	 DD	 $LN18@cl_create_
  002e4	df fe ff ff	 DD	 -289			; fffffedfH
  002e8	01 00 00 00	 DD	 1
  002ec	00 00 00 00	 DD	 $LN19@cl_create_
$LN19@cl_create_:
  002f0	72		 DB	 114			; 00000072H
  002f1	65		 DB	 101			; 00000065H
  002f2	6d		 DB	 109			; 0000006dH
  002f3	6f		 DB	 111			; 0000006fH
  002f4	76		 DB	 118			; 00000076H
  002f5	65		 DB	 101			; 00000065H
  002f6	5f		 DB	 95			; 0000005fH
  002f7	73		 DB	 115			; 00000073H
  002f8	74		 DB	 116			; 00000074H
  002f9	72		 DB	 114			; 00000072H
  002fa	69		 DB	 105			; 00000069H
  002fb	6e		 DB	 110			; 0000006eH
  002fc	67		 DB	 103			; 00000067H
  002fd	00		 DB	 0
$LN18@cl_create_:
  002fe	64		 DB	 100			; 00000064H
  002ff	72		 DB	 114			; 00000072H
  00300	69		 DB	 105			; 00000069H
  00301	76		 DB	 118			; 00000076H
  00302	65		 DB	 101			; 00000065H
  00303	72		 DB	 114			; 00000072H
  00304	5f		 DB	 95			; 0000005fH
  00305	76		 DB	 118			; 00000076H
  00306	65		 DB	 101			; 00000065H
  00307	72		 DB	 114			; 00000072H
  00308	00		 DB	 0
?cl_create_info_string@@YAHPAUcl_data_t@@PBUcl_func_t@@PBUIntelDeviceInfo@@PADI@Z ENDP ; cl_create_info_string
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\rgy_util.h
;	COMDAT ??__ECspColorprimList@@YAXXZ
text$di	SEGMENT
$T1 = -148						; size = 48
$T2 = -100						; size = 4
$T3 = -96						; size = 4
$T4 = -92						; size = 4
$T5 = -88						; size = 4
$T6 = -84						; size = 4
$T7 = -80						; size = 4
$T8 = -76						; size = 4
$T9 = -72						; size = 4
$T10 = -68						; size = 4
$T11 = -64						; size = 4
$T12 = -60						; size = 4
$T13 = -56						; size = 4
$T14 = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
??__ECspColorprimList@@YAXXZ PROC			; `dynamic initializer for 'CspColorprimList'', COMDAT

; 1187 : );

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 94 00 00
	00		 sub	 esp, 148		; 00000094H
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8d bd 6c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-148]
  00011	b9 25 00 00 00	 mov	 ecx, 37			; 00000025H
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1174 : static const auto CspColorprimList = make_array<CspColorprim>(

  00027	c7 45 c8 0d 00
	00 00		 mov	 DWORD PTR $T13[ebp], 13	; 0000000dH
  0002e	c7 45 c4 0c 00
	00 00		 mov	 DWORD PTR $T12[ebp], 12	; 0000000cH
  00035	c7 45 c0 0b 00
	00 00		 mov	 DWORD PTR $T11[ebp], 11	; 0000000bH
  0003c	c7 45 bc 0a 00
	00 00		 mov	 DWORD PTR $T10[ebp], 10	; 0000000aH
  00043	c7 45 b8 09 00
	00 00		 mov	 DWORD PTR $T9[ebp], 9
  0004a	c7 45 b4 08 00
	00 00		 mov	 DWORD PTR $T8[ebp], 8
  00051	c7 45 b0 07 00
	00 00		 mov	 DWORD PTR $T7[ebp], 7
  00058	c7 45 ac 06 00
	00 00		 mov	 DWORD PTR $T6[ebp], 6
  0005f	c7 45 a8 05 00
	00 00		 mov	 DWORD PTR $T5[ebp], 5
  00066	c7 45 a4 04 00
	00 00		 mov	 DWORD PTR $T4[ebp], 4
  0006d	c7 45 a0 02 00
	00 00		 mov	 DWORD PTR $T3[ebp], 2
  00074	c7 45 9c 01 00
	00 00		 mov	 DWORD PTR $T2[ebp], 1
  0007b	8d 45 c8	 lea	 eax, DWORD PTR $T13[ebp]
  0007e	50		 push	 eax
  0007f	8d 4d c4	 lea	 ecx, DWORD PTR $T12[ebp]
  00082	51		 push	 ecx
  00083	8d 55 c0	 lea	 edx, DWORD PTR $T11[ebp]
  00086	52		 push	 edx
  00087	8d 45 bc	 lea	 eax, DWORD PTR $T10[ebp]
  0008a	50		 push	 eax
  0008b	8d 4d b8	 lea	 ecx, DWORD PTR $T9[ebp]
  0008e	51		 push	 ecx
  0008f	8d 55 b4	 lea	 edx, DWORD PTR $T8[ebp]
  00092	52		 push	 edx
  00093	8d 45 b0	 lea	 eax, DWORD PTR $T7[ebp]
  00096	50		 push	 eax
  00097	8d 4d ac	 lea	 ecx, DWORD PTR $T6[ebp]
  0009a	51		 push	 ecx
  0009b	8d 55 a8	 lea	 edx, DWORD PTR $T5[ebp]
  0009e	52		 push	 edx
  0009f	8d 45 a4	 lea	 eax, DWORD PTR $T4[ebp]
  000a2	50		 push	 eax
  000a3	8d 4d a0	 lea	 ecx, DWORD PTR $T3[ebp]
  000a6	51		 push	 ecx
  000a7	8d 55 9c	 lea	 edx, DWORD PTR $T2[ebp]
  000aa	52		 push	 edx
  000ab	8d 85 6c ff ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  000b1	50		 push	 eax
  000b2	e8 00 00 00 00	 call	 ??$make_array@W4CspColorprim@@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@@@YA?AV?$array@W4CspColorprim@@$0M@@std@@$$QAW4CspColorprim@@00000000000@Z ; make_array<enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim>
  000b7	83 c4 34	 add	 esp, 52			; 00000034H
  000ba	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  000bf	8b f0		 mov	 esi, eax
  000c1	8d 7d cc	 lea	 edi, DWORD PTR $T14[ebp]
  000c4	f3 a5		 rep movsd
  000c6	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  000cb	8d 75 cc	 lea	 esi, DWORD PTR $T14[ebp]
  000ce	bf 00 00 00 00	 mov	 edi, OFFSET ?CspColorprimList@@3V?$array@W4CspColorprim@@$0M@@std@@B
  000d3	f3 a5		 rep movsd
  000d5	5f		 pop	 edi
  000d6	5e		 pop	 esi
  000d7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000da	33 cd		 xor	 ecx, ebp
  000dc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e1	81 c4 94 00 00
	00		 add	 esp, 148		; 00000094H
  000e7	3b ec		 cmp	 ebp, esp
  000e9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ee	8b e5		 mov	 esp, ebp
  000f0	5d		 pop	 ebp
  000f1	c3		 ret	 0
??__ECspColorprimList@@YAXXZ ENDP			; `dynamic initializer for 'CspColorprimList''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\rgy_util.h
;	COMDAT ??$make_array@W4CspColorprim@@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@@@YA?AV?$array@W4CspColorprim@@$0M@@std@@$$QAW4CspColorprim@@00000000000@Z
_TEXT	SEGMENT
$T1 = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
$T2 = 8							; size = 4
_<args_0>$ = 12						; size = 4
_<args_1>$ = 16						; size = 4
_<args_2>$ = 20						; size = 4
_<args_3>$ = 24						; size = 4
_<args_4>$ = 28						; size = 4
_<args_5>$ = 32						; size = 4
_<args_6>$ = 36						; size = 4
_<args_7>$ = 40						; size = 4
_<args_8>$ = 44						; size = 4
_<args_9>$ = 48						; size = 4
_<args_10>$ = 52					; size = 4
_<args_11>$ = 56					; size = 4
??$make_array@W4CspColorprim@@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@@@YA?AV?$array@W4CspColorprim@@$0M@@std@@$$QAW4CspColorprim@@00000000000@Z PROC ; make_array<enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim>, COMDAT

; 129  : constexpr std::array<T, sizeof...(Args)> make_array(Args&&... args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8d 7d cc	 lea	 edi, DWORD PTR [ebp-52]
  0000b	b9 0d 00 00 00	 mov	 ecx, 13			; 0000000dH
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 130  :     return std::array<T, sizeof...(Args)>{ static_cast<Args&&>(args)... };

  00021	8b 45 0c	 mov	 eax, DWORD PTR _<args_0>$[ebp]
  00024	8b 08		 mov	 ecx, DWORD PTR [eax]
  00026	89 4d cc	 mov	 DWORD PTR $T1[ebp], ecx
  00029	8b 55 10	 mov	 edx, DWORD PTR _<args_1>$[ebp]
  0002c	8b 02		 mov	 eax, DWORD PTR [edx]
  0002e	89 45 d0	 mov	 DWORD PTR $T1[ebp+4], eax
  00031	8b 4d 14	 mov	 ecx, DWORD PTR _<args_2>$[ebp]
  00034	8b 11		 mov	 edx, DWORD PTR [ecx]
  00036	89 55 d4	 mov	 DWORD PTR $T1[ebp+8], edx
  00039	8b 45 18	 mov	 eax, DWORD PTR _<args_3>$[ebp]
  0003c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003e	89 4d d8	 mov	 DWORD PTR $T1[ebp+12], ecx
  00041	8b 55 1c	 mov	 edx, DWORD PTR _<args_4>$[ebp]
  00044	8b 02		 mov	 eax, DWORD PTR [edx]
  00046	89 45 dc	 mov	 DWORD PTR $T1[ebp+16], eax
  00049	8b 4d 20	 mov	 ecx, DWORD PTR _<args_5>$[ebp]
  0004c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004e	89 55 e0	 mov	 DWORD PTR $T1[ebp+20], edx
  00051	8b 45 24	 mov	 eax, DWORD PTR _<args_6>$[ebp]
  00054	8b 08		 mov	 ecx, DWORD PTR [eax]
  00056	89 4d e4	 mov	 DWORD PTR $T1[ebp+24], ecx
  00059	8b 55 28	 mov	 edx, DWORD PTR _<args_7>$[ebp]
  0005c	8b 02		 mov	 eax, DWORD PTR [edx]
  0005e	89 45 e8	 mov	 DWORD PTR $T1[ebp+28], eax
  00061	8b 4d 2c	 mov	 ecx, DWORD PTR _<args_8>$[ebp]
  00064	8b 11		 mov	 edx, DWORD PTR [ecx]
  00066	89 55 ec	 mov	 DWORD PTR $T1[ebp+32], edx
  00069	8b 45 30	 mov	 eax, DWORD PTR _<args_9>$[ebp]
  0006c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006e	89 4d f0	 mov	 DWORD PTR $T1[ebp+36], ecx
  00071	8b 55 34	 mov	 edx, DWORD PTR _<args_10>$[ebp]
  00074	8b 02		 mov	 eax, DWORD PTR [edx]
  00076	89 45 f4	 mov	 DWORD PTR $T1[ebp+40], eax
  00079	8b 4d 38	 mov	 ecx, DWORD PTR _<args_11>$[ebp]
  0007c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0007e	89 55 f8	 mov	 DWORD PTR $T1[ebp+44], edx
  00081	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  00086	8d 75 cc	 lea	 esi, DWORD PTR $T1[ebp]
  00089	8b 7d 08	 mov	 edi, DWORD PTR $T2[ebp]
  0008c	f3 a5		 rep movsd
  0008e	8b 45 08	 mov	 eax, DWORD PTR $T2[ebp]

; 131  : }

  00091	5f		 pop	 edi
  00092	5e		 pop	 esi
  00093	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00096	33 cd		 xor	 ecx, ebp
  00098	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009d	8b e5		 mov	 esp, ebp
  0009f	5d		 pop	 ebp
  000a0	c3		 ret	 0
??$make_array@W4CspColorprim@@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@@@YA?AV?$array@W4CspColorprim@@$0M@@std@@$$QAW4CspColorprim@@00000000000@Z ENDP ; make_array<enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim,enum CspColorprim>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\rgy_util.h
;	COMDAT ??__ECspTransferList@@YAXXZ
text$di	SEGMENT
$T1 = -184						; size = 60
$T2 = -124						; size = 4
$T3 = -120						; size = 4
$T4 = -116						; size = 4
$T5 = -112						; size = 4
$T6 = -108						; size = 4
$T7 = -104						; size = 4
$T8 = -100						; size = 4
$T9 = -96						; size = 4
$T10 = -92						; size = 4
$T11 = -88						; size = 4
$T12 = -84						; size = 4
$T13 = -80						; size = 4
$T14 = -76						; size = 4
$T15 = -72						; size = 4
$T16 = -68						; size = 4
$T17 = -64						; size = 60
__$ArrayPad$ = -4					; size = 4
??__ECspTransferList@@YAXXZ PROC			; `dynamic initializer for 'CspTransferList'', COMDAT

; 1135 : );

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec b8 00 00
	00		 sub	 esp, 184		; 000000b8H
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8d bd 48 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-184]
  00011	b9 2e 00 00 00	 mov	 ecx, 46			; 0000002eH
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1119 : static const auto CspTransferList = make_array<CspTransfer>(

  00027	c7 45 bc 12 00
	00 00		 mov	 DWORD PTR $T16[ebp], 18	; 00000012H
  0002e	c7 45 b8 10 00
	00 00		 mov	 DWORD PTR $T15[ebp], 16	; 00000010H
  00035	c7 45 b4 0f 00
	00 00		 mov	 DWORD PTR $T14[ebp], 15	; 0000000fH
  0003c	c7 45 b0 0e 00
	00 00		 mov	 DWORD PTR $T13[ebp], 14	; 0000000eH
  00043	c7 45 ac 0d 00
	00 00		 mov	 DWORD PTR $T12[ebp], 13	; 0000000dH
  0004a	c7 45 a8 0b 00
	00 00		 mov	 DWORD PTR $T11[ebp], 11	; 0000000bH
  00051	c7 45 a4 0a 00
	00 00		 mov	 DWORD PTR $T10[ebp], 10	; 0000000aH
  00058	c7 45 a0 09 00
	00 00		 mov	 DWORD PTR $T9[ebp], 9
  0005f	c7 45 9c 08 00
	00 00		 mov	 DWORD PTR $T8[ebp], 8
  00066	c7 45 98 07 00
	00 00		 mov	 DWORD PTR $T7[ebp], 7
  0006d	c7 45 94 06 00
	00 00		 mov	 DWORD PTR $T6[ebp], 6
  00074	c7 45 90 05 00
	00 00		 mov	 DWORD PTR $T5[ebp], 5
  0007b	c7 45 8c 04 00
	00 00		 mov	 DWORD PTR $T4[ebp], 4
  00082	c7 45 88 02 00
	00 00		 mov	 DWORD PTR $T3[ebp], 2
  00089	c7 45 84 01 00
	00 00		 mov	 DWORD PTR $T2[ebp], 1
  00090	8d 45 bc	 lea	 eax, DWORD PTR $T16[ebp]
  00093	50		 push	 eax
  00094	8d 4d b8	 lea	 ecx, DWORD PTR $T15[ebp]
  00097	51		 push	 ecx
  00098	8d 55 b4	 lea	 edx, DWORD PTR $T14[ebp]
  0009b	52		 push	 edx
  0009c	8d 45 b0	 lea	 eax, DWORD PTR $T13[ebp]
  0009f	50		 push	 eax
  000a0	8d 4d ac	 lea	 ecx, DWORD PTR $T12[ebp]
  000a3	51		 push	 ecx
  000a4	8d 55 a8	 lea	 edx, DWORD PTR $T11[ebp]
  000a7	52		 push	 edx
  000a8	8d 45 a4	 lea	 eax, DWORD PTR $T10[ebp]
  000ab	50		 push	 eax
  000ac	8d 4d a0	 lea	 ecx, DWORD PTR $T9[ebp]
  000af	51		 push	 ecx
  000b0	8d 55 9c	 lea	 edx, DWORD PTR $T8[ebp]
  000b3	52		 push	 edx
  000b4	8d 45 98	 lea	 eax, DWORD PTR $T7[ebp]
  000b7	50		 push	 eax
  000b8	8d 4d 94	 lea	 ecx, DWORD PTR $T6[ebp]
  000bb	51		 push	 ecx
  000bc	8d 55 90	 lea	 edx, DWORD PTR $T5[ebp]
  000bf	52		 push	 edx
  000c0	8d 45 8c	 lea	 eax, DWORD PTR $T4[ebp]
  000c3	50		 push	 eax
  000c4	8d 4d 88	 lea	 ecx, DWORD PTR $T3[ebp]
  000c7	51		 push	 ecx
  000c8	8d 55 84	 lea	 edx, DWORD PTR $T2[ebp]
  000cb	52		 push	 edx
  000cc	8d 85 48 ff ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  000d2	50		 push	 eax
  000d3	e8 00 00 00 00	 call	 ??$make_array@W4CspTransfer@@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@@@YA?AV?$array@W4CspTransfer@@$0P@@std@@$$QAW4CspTransfer@@00000000000000@Z ; make_array<enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer>
  000d8	83 c4 40	 add	 esp, 64			; 00000040H
  000db	b9 0f 00 00 00	 mov	 ecx, 15			; 0000000fH
  000e0	8b f0		 mov	 esi, eax
  000e2	8d 7d c0	 lea	 edi, DWORD PTR $T17[ebp]
  000e5	f3 a5		 rep movsd
  000e7	b9 0f 00 00 00	 mov	 ecx, 15			; 0000000fH
  000ec	8d 75 c0	 lea	 esi, DWORD PTR $T17[ebp]
  000ef	bf 00 00 00 00	 mov	 edi, OFFSET ?CspTransferList@@3V?$array@W4CspTransfer@@$0P@@std@@B
  000f4	f3 a5		 rep movsd
  000f6	5f		 pop	 edi
  000f7	5e		 pop	 esi
  000f8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000fb	33 cd		 xor	 ecx, ebp
  000fd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00102	81 c4 b8 00 00
	00		 add	 esp, 184		; 000000b8H
  00108	3b ec		 cmp	 ebp, esp
  0010a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0010f	8b e5		 mov	 esp, ebp
  00111	5d		 pop	 ebp
  00112	c3		 ret	 0
??__ECspTransferList@@YAXXZ ENDP			; `dynamic initializer for 'CspTransferList''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\rgy_util.h
;	COMDAT ??$make_array@W4CspTransfer@@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@@@YA?AV?$array@W4CspTransfer@@$0P@@std@@$$QAW4CspTransfer@@00000000000000@Z
_TEXT	SEGMENT
$T1 = -64						; size = 60
__$ArrayPad$ = -4					; size = 4
$T2 = 8							; size = 4
_<args_0>$ = 12						; size = 4
_<args_1>$ = 16						; size = 4
_<args_2>$ = 20						; size = 4
_<args_3>$ = 24						; size = 4
_<args_4>$ = 28						; size = 4
_<args_5>$ = 32						; size = 4
_<args_6>$ = 36						; size = 4
_<args_7>$ = 40						; size = 4
_<args_8>$ = 44						; size = 4
_<args_9>$ = 48						; size = 4
_<args_10>$ = 52					; size = 4
_<args_11>$ = 56					; size = 4
_<args_12>$ = 60					; size = 4
_<args_13>$ = 64					; size = 4
_<args_14>$ = 68					; size = 4
??$make_array@W4CspTransfer@@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@@@YA?AV?$array@W4CspTransfer@@$0P@@std@@$$QAW4CspTransfer@@00000000000000@Z PROC ; make_array<enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer>, COMDAT

; 129  : constexpr std::array<T, sizeof...(Args)> make_array(Args&&... args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8d 7d c0	 lea	 edi, DWORD PTR [ebp-64]
  0000b	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 130  :     return std::array<T, sizeof...(Args)>{ static_cast<Args&&>(args)... };

  00021	8b 45 0c	 mov	 eax, DWORD PTR _<args_0>$[ebp]
  00024	8b 08		 mov	 ecx, DWORD PTR [eax]
  00026	89 4d c0	 mov	 DWORD PTR $T1[ebp], ecx
  00029	8b 55 10	 mov	 edx, DWORD PTR _<args_1>$[ebp]
  0002c	8b 02		 mov	 eax, DWORD PTR [edx]
  0002e	89 45 c4	 mov	 DWORD PTR $T1[ebp+4], eax
  00031	8b 4d 14	 mov	 ecx, DWORD PTR _<args_2>$[ebp]
  00034	8b 11		 mov	 edx, DWORD PTR [ecx]
  00036	89 55 c8	 mov	 DWORD PTR $T1[ebp+8], edx
  00039	8b 45 18	 mov	 eax, DWORD PTR _<args_3>$[ebp]
  0003c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003e	89 4d cc	 mov	 DWORD PTR $T1[ebp+12], ecx
  00041	8b 55 1c	 mov	 edx, DWORD PTR _<args_4>$[ebp]
  00044	8b 02		 mov	 eax, DWORD PTR [edx]
  00046	89 45 d0	 mov	 DWORD PTR $T1[ebp+16], eax
  00049	8b 4d 20	 mov	 ecx, DWORD PTR _<args_5>$[ebp]
  0004c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004e	89 55 d4	 mov	 DWORD PTR $T1[ebp+20], edx
  00051	8b 45 24	 mov	 eax, DWORD PTR _<args_6>$[ebp]
  00054	8b 08		 mov	 ecx, DWORD PTR [eax]
  00056	89 4d d8	 mov	 DWORD PTR $T1[ebp+24], ecx
  00059	8b 55 28	 mov	 edx, DWORD PTR _<args_7>$[ebp]
  0005c	8b 02		 mov	 eax, DWORD PTR [edx]
  0005e	89 45 dc	 mov	 DWORD PTR $T1[ebp+28], eax
  00061	8b 4d 2c	 mov	 ecx, DWORD PTR _<args_8>$[ebp]
  00064	8b 11		 mov	 edx, DWORD PTR [ecx]
  00066	89 55 e0	 mov	 DWORD PTR $T1[ebp+32], edx
  00069	8b 45 30	 mov	 eax, DWORD PTR _<args_9>$[ebp]
  0006c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006e	89 4d e4	 mov	 DWORD PTR $T1[ebp+36], ecx
  00071	8b 55 34	 mov	 edx, DWORD PTR _<args_10>$[ebp]
  00074	8b 02		 mov	 eax, DWORD PTR [edx]
  00076	89 45 e8	 mov	 DWORD PTR $T1[ebp+40], eax
  00079	8b 4d 38	 mov	 ecx, DWORD PTR _<args_11>$[ebp]
  0007c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0007e	89 55 ec	 mov	 DWORD PTR $T1[ebp+44], edx
  00081	8b 45 3c	 mov	 eax, DWORD PTR _<args_12>$[ebp]
  00084	8b 08		 mov	 ecx, DWORD PTR [eax]
  00086	89 4d f0	 mov	 DWORD PTR $T1[ebp+48], ecx
  00089	8b 55 40	 mov	 edx, DWORD PTR _<args_13>$[ebp]
  0008c	8b 02		 mov	 eax, DWORD PTR [edx]
  0008e	89 45 f4	 mov	 DWORD PTR $T1[ebp+52], eax
  00091	8b 4d 44	 mov	 ecx, DWORD PTR _<args_14>$[ebp]
  00094	8b 11		 mov	 edx, DWORD PTR [ecx]
  00096	89 55 f8	 mov	 DWORD PTR $T1[ebp+56], edx
  00099	b9 0f 00 00 00	 mov	 ecx, 15			; 0000000fH
  0009e	8d 75 c0	 lea	 esi, DWORD PTR $T1[ebp]
  000a1	8b 7d 08	 mov	 edi, DWORD PTR $T2[ebp]
  000a4	f3 a5		 rep movsd
  000a6	8b 45 08	 mov	 eax, DWORD PTR $T2[ebp]

; 131  : }

  000a9	5f		 pop	 edi
  000aa	5e		 pop	 esi
  000ab	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ae	33 cd		 xor	 ecx, ebp
  000b0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b5	8b e5		 mov	 esp, ebp
  000b7	5d		 pop	 ebp
  000b8	c3		 ret	 0
??$make_array@W4CspTransfer@@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@@@YA?AV?$array@W4CspTransfer@@$0P@@std@@$$QAW4CspTransfer@@00000000000000@Z ENDP ; make_array<enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer,enum CspTransfer>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\rgy_util.h
;	COMDAT ??__ECspMatrixList@@YAXXZ
text$di	SEGMENT
$T1 = -172						; size = 56
$T2 = -116						; size = 4
$T3 = -112						; size = 4
$T4 = -108						; size = 4
$T5 = -104						; size = 4
$T6 = -100						; size = 4
$T7 = -96						; size = 4
$T8 = -92						; size = 4
$T9 = -88						; size = 4
$T10 = -84						; size = 4
$T11 = -80						; size = 4
$T12 = -76						; size = 4
$T13 = -72						; size = 4
$T14 = -68						; size = 4
$T15 = -64						; size = 4
$T16 = -60						; size = 56
__$ArrayPad$ = -4					; size = 4
??__ECspMatrixList@@YAXXZ PROC				; `dynamic initializer for 'CspMatrixList'', COMDAT

; 1080 : );

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec ac 00 00
	00		 sub	 esp, 172		; 000000acH
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8d bd 54 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-172]
  00011	b9 2b 00 00 00	 mov	 ecx, 43			; 0000002bH
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1065 : static const auto CspMatrixList = make_array<CspMatrix>(

  00027	c7 45 c0 0f 00
	00 00		 mov	 DWORD PTR $T15[ebp], 15	; 0000000fH
  0002e	c7 45 bc 0e 00
	00 00		 mov	 DWORD PTR $T14[ebp], 14	; 0000000eH
  00035	c7 45 b8 0d 00
	00 00		 mov	 DWORD PTR $T13[ebp], 13	; 0000000dH
  0003c	c7 45 b4 0c 00
	00 00		 mov	 DWORD PTR $T12[ebp], 12	; 0000000cH
  00043	c7 45 b0 0a 00
	00 00		 mov	 DWORD PTR $T11[ebp], 10	; 0000000aH
  0004a	c7 45 ac 09 00
	00 00		 mov	 DWORD PTR $T10[ebp], 9
  00051	c7 45 a8 08 00
	00 00		 mov	 DWORD PTR $T9[ebp], 8
  00058	c7 45 a4 07 00
	00 00		 mov	 DWORD PTR $T8[ebp], 7
  0005f	c7 45 a0 06 00
	00 00		 mov	 DWORD PTR $T7[ebp], 6
  00066	c7 45 9c 05 00
	00 00		 mov	 DWORD PTR $T6[ebp], 5
  0006d	c7 45 98 04 00
	00 00		 mov	 DWORD PTR $T5[ebp], 4
  00074	c7 45 94 02 00
	00 00		 mov	 DWORD PTR $T4[ebp], 2
  0007b	c7 45 90 01 00
	00 00		 mov	 DWORD PTR $T3[ebp], 1
  00082	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  00089	8d 45 c0	 lea	 eax, DWORD PTR $T15[ebp]
  0008c	50		 push	 eax
  0008d	8d 4d bc	 lea	 ecx, DWORD PTR $T14[ebp]
  00090	51		 push	 ecx
  00091	8d 55 b8	 lea	 edx, DWORD PTR $T13[ebp]
  00094	52		 push	 edx
  00095	8d 45 b4	 lea	 eax, DWORD PTR $T12[ebp]
  00098	50		 push	 eax
  00099	8d 4d b0	 lea	 ecx, DWORD PTR $T11[ebp]
  0009c	51		 push	 ecx
  0009d	8d 55 ac	 lea	 edx, DWORD PTR $T10[ebp]
  000a0	52		 push	 edx
  000a1	8d 45 a8	 lea	 eax, DWORD PTR $T9[ebp]
  000a4	50		 push	 eax
  000a5	8d 4d a4	 lea	 ecx, DWORD PTR $T8[ebp]
  000a8	51		 push	 ecx
  000a9	8d 55 a0	 lea	 edx, DWORD PTR $T7[ebp]
  000ac	52		 push	 edx
  000ad	8d 45 9c	 lea	 eax, DWORD PTR $T6[ebp]
  000b0	50		 push	 eax
  000b1	8d 4d 98	 lea	 ecx, DWORD PTR $T5[ebp]
  000b4	51		 push	 ecx
  000b5	8d 55 94	 lea	 edx, DWORD PTR $T4[ebp]
  000b8	52		 push	 edx
  000b9	8d 45 90	 lea	 eax, DWORD PTR $T3[ebp]
  000bc	50		 push	 eax
  000bd	8d 4d 8c	 lea	 ecx, DWORD PTR $T2[ebp]
  000c0	51		 push	 ecx
  000c1	8d 95 54 ff ff
	ff		 lea	 edx, DWORD PTR $T1[ebp]
  000c7	52		 push	 edx
  000c8	e8 00 00 00 00	 call	 ??$make_array@W4CspMatrix@@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@@@YA?AV?$array@W4CspMatrix@@$0O@@std@@$$QAW4CspMatrix@@0000000000000@Z ; make_array<enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix>
  000cd	83 c4 3c	 add	 esp, 60			; 0000003cH
  000d0	b9 0e 00 00 00	 mov	 ecx, 14			; 0000000eH
  000d5	8b f0		 mov	 esi, eax
  000d7	8d 7d c4	 lea	 edi, DWORD PTR $T16[ebp]
  000da	f3 a5		 rep movsd
  000dc	b9 0e 00 00 00	 mov	 ecx, 14			; 0000000eH
  000e1	8d 75 c4	 lea	 esi, DWORD PTR $T16[ebp]
  000e4	bf 00 00 00 00	 mov	 edi, OFFSET ?CspMatrixList@@3V?$array@W4CspMatrix@@$0O@@std@@B
  000e9	f3 a5		 rep movsd
  000eb	5f		 pop	 edi
  000ec	5e		 pop	 esi
  000ed	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f0	33 cd		 xor	 ecx, ebp
  000f2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f7	81 c4 ac 00 00
	00		 add	 esp, 172		; 000000acH
  000fd	3b ec		 cmp	 ebp, esp
  000ff	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00104	8b e5		 mov	 esp, ebp
  00106	5d		 pop	 ebp
  00107	c3		 ret	 0
??__ECspMatrixList@@YAXXZ ENDP				; `dynamic initializer for 'CspMatrixList''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\rgy_util.h
;	COMDAT ??$make_array@W4CspMatrix@@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@@@YA?AV?$array@W4CspMatrix@@$0O@@std@@$$QAW4CspMatrix@@0000000000000@Z
_TEXT	SEGMENT
$T1 = -60						; size = 56
__$ArrayPad$ = -4					; size = 4
$T2 = 8							; size = 4
_<args_0>$ = 12						; size = 4
_<args_1>$ = 16						; size = 4
_<args_2>$ = 20						; size = 4
_<args_3>$ = 24						; size = 4
_<args_4>$ = 28						; size = 4
_<args_5>$ = 32						; size = 4
_<args_6>$ = 36						; size = 4
_<args_7>$ = 40						; size = 4
_<args_8>$ = 44						; size = 4
_<args_9>$ = 48						; size = 4
_<args_10>$ = 52					; size = 4
_<args_11>$ = 56					; size = 4
_<args_12>$ = 60					; size = 4
_<args_13>$ = 64					; size = 4
??$make_array@W4CspMatrix@@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@@@YA?AV?$array@W4CspMatrix@@$0O@@std@@$$QAW4CspMatrix@@0000000000000@Z PROC ; make_array<enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix>, COMDAT

; 129  : constexpr std::array<T, sizeof...(Args)> make_array(Args&&... args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8d 7d c4	 lea	 edi, DWORD PTR [ebp-60]
  0000b	b9 0f 00 00 00	 mov	 ecx, 15			; 0000000fH
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 130  :     return std::array<T, sizeof...(Args)>{ static_cast<Args&&>(args)... };

  00021	8b 45 0c	 mov	 eax, DWORD PTR _<args_0>$[ebp]
  00024	8b 08		 mov	 ecx, DWORD PTR [eax]
  00026	89 4d c4	 mov	 DWORD PTR $T1[ebp], ecx
  00029	8b 55 10	 mov	 edx, DWORD PTR _<args_1>$[ebp]
  0002c	8b 02		 mov	 eax, DWORD PTR [edx]
  0002e	89 45 c8	 mov	 DWORD PTR $T1[ebp+4], eax
  00031	8b 4d 14	 mov	 ecx, DWORD PTR _<args_2>$[ebp]
  00034	8b 11		 mov	 edx, DWORD PTR [ecx]
  00036	89 55 cc	 mov	 DWORD PTR $T1[ebp+8], edx
  00039	8b 45 18	 mov	 eax, DWORD PTR _<args_3>$[ebp]
  0003c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003e	89 4d d0	 mov	 DWORD PTR $T1[ebp+12], ecx
  00041	8b 55 1c	 mov	 edx, DWORD PTR _<args_4>$[ebp]
  00044	8b 02		 mov	 eax, DWORD PTR [edx]
  00046	89 45 d4	 mov	 DWORD PTR $T1[ebp+16], eax
  00049	8b 4d 20	 mov	 ecx, DWORD PTR _<args_5>$[ebp]
  0004c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004e	89 55 d8	 mov	 DWORD PTR $T1[ebp+20], edx
  00051	8b 45 24	 mov	 eax, DWORD PTR _<args_6>$[ebp]
  00054	8b 08		 mov	 ecx, DWORD PTR [eax]
  00056	89 4d dc	 mov	 DWORD PTR $T1[ebp+24], ecx
  00059	8b 55 28	 mov	 edx, DWORD PTR _<args_7>$[ebp]
  0005c	8b 02		 mov	 eax, DWORD PTR [edx]
  0005e	89 45 e0	 mov	 DWORD PTR $T1[ebp+28], eax
  00061	8b 4d 2c	 mov	 ecx, DWORD PTR _<args_8>$[ebp]
  00064	8b 11		 mov	 edx, DWORD PTR [ecx]
  00066	89 55 e4	 mov	 DWORD PTR $T1[ebp+32], edx
  00069	8b 45 30	 mov	 eax, DWORD PTR _<args_9>$[ebp]
  0006c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006e	89 4d e8	 mov	 DWORD PTR $T1[ebp+36], ecx
  00071	8b 55 34	 mov	 edx, DWORD PTR _<args_10>$[ebp]
  00074	8b 02		 mov	 eax, DWORD PTR [edx]
  00076	89 45 ec	 mov	 DWORD PTR $T1[ebp+40], eax
  00079	8b 4d 38	 mov	 ecx, DWORD PTR _<args_11>$[ebp]
  0007c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0007e	89 55 f0	 mov	 DWORD PTR $T1[ebp+44], edx
  00081	8b 45 3c	 mov	 eax, DWORD PTR _<args_12>$[ebp]
  00084	8b 08		 mov	 ecx, DWORD PTR [eax]
  00086	89 4d f4	 mov	 DWORD PTR $T1[ebp+48], ecx
  00089	8b 55 40	 mov	 edx, DWORD PTR _<args_13>$[ebp]
  0008c	8b 02		 mov	 eax, DWORD PTR [edx]
  0008e	89 45 f8	 mov	 DWORD PTR $T1[ebp+52], eax
  00091	b9 0e 00 00 00	 mov	 ecx, 14			; 0000000eH
  00096	8d 75 c4	 lea	 esi, DWORD PTR $T1[ebp]
  00099	8b 7d 08	 mov	 edi, DWORD PTR $T2[ebp]
  0009c	f3 a5		 rep movsd
  0009e	8b 45 08	 mov	 eax, DWORD PTR $T2[ebp]

; 131  : }

  000a1	5f		 pop	 edi
  000a2	5e		 pop	 esi
  000a3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a6	33 cd		 xor	 ecx, ebp
  000a8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ad	8b e5		 mov	 esp, ebp
  000af	5d		 pop	 ebp
  000b0	c3		 ret	 0
??$make_array@W4CspMatrix@@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@W41@@@YA?AV?$array@W4CspMatrix@@$0O@@std@@$$QAW4CspMatrix@@0000000000000@Z ENDP ; make_array<enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix,enum CspMatrix>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\gpu_info.cpp
_TEXT	SEGMENT
tv150 = -188						; size = 4
tv145 = -184						; size = 4
_intel_error$ = -178					; size = 1
_opencl_error$ = -177					; size = 1
_info$ = -172						; size = 28
_data$ = -136						; size = 24
_cl$ = -104						; size = 92
_ret$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_VendorName$ = 8					; size = 4
_buffer$ = 12						; size = 4
_buffer_size$ = 16					; size = 4
_driver_version_only$ = 20				; size = 1
?getGPUInfo@@YAHPBDPADI_N@Z PROC			; getGPUInfo

; 148  : int getGPUInfo(const char *VendorName, TCHAR *buffer, unsigned int buffer_size, bool driver_version_only) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec bc 00 00
	00		 sub	 esp, 188		; 000000bcH
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8d bd 44 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-188]
  00011	b9 2f 00 00 00	 mov	 ecx, 47			; 0000002fH
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 149  : #if !ENABLE_OPENCL
; 150  : #ifdef LIBVA_SUPPORT
; 151  :     _stprintf_s(buffer, buffer_size, _T("Intel Graphics / Driver : %s"), getGPUInfoVA().c_str());
; 152  : #else
; 153  :     _stprintf_s(buffer, buffer_size, _T("Unknown (not compiled with OpenCL support)"));
; 154  : #endif
; 155  :     return 0;
; 156  : #else
; 157  :     int ret = CL_SUCCESS;

  00027	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 0

; 158  :     cl_func_t cl = { 0 };

  0002e	6a 5c		 push	 92			; 0000005cH
  00030	6a 00		 push	 0
  00032	8d 45 98	 lea	 eax, DWORD PTR _cl$[ebp]
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 _memset
  0003b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 159  :     cl_data_t data = { 0 };

  0003e	33 c9		 xor	 ecx, ecx
  00040	89 8d 78 ff ff
	ff		 mov	 DWORD PTR _data$[ebp], ecx
  00046	89 8d 7c ff ff
	ff		 mov	 DWORD PTR _data$[ebp+4], ecx
  0004c	89 4d 80	 mov	 DWORD PTR _data$[ebp+8], ecx
  0004f	89 4d 84	 mov	 DWORD PTR _data$[ebp+12], ecx
  00052	89 4d 88	 mov	 DWORD PTR _data$[ebp+16], ecx
  00055	89 4d 8c	 mov	 DWORD PTR _data$[ebp+20], ecx

; 160  :     IntelDeviceInfo info = { 0 };

  00058	33 d2		 xor	 edx, edx
  0005a	89 95 54 ff ff
	ff		 mov	 DWORD PTR _info$[ebp], edx
  00060	89 95 58 ff ff
	ff		 mov	 DWORD PTR _info$[ebp+4], edx
  00066	89 95 5c ff ff
	ff		 mov	 DWORD PTR _info$[ebp+8], edx
  0006c	89 95 60 ff ff
	ff		 mov	 DWORD PTR _info$[ebp+12], edx
  00072	89 95 64 ff ff
	ff		 mov	 DWORD PTR _info$[ebp+16], edx
  00078	89 95 68 ff ff
	ff		 mov	 DWORD PTR _info$[ebp+20], edx
  0007e	89 95 6c ff ff
	ff		 mov	 DWORD PTR _info$[ebp+24], edx

; 161  : 
; 162  :     bool opencl_error = false;

  00084	c6 85 4f ff ff
	ff 00		 mov	 BYTE PTR _opencl_error$[ebp], 0

; 163  :     bool intel_error = false;

  0008b	c6 85 4e ff ff
	ff 00		 mov	 BYTE PTR _intel_error$[ebp], 0

; 164  :     if (CL_SUCCESS != (ret = cl_get_func(&cl))) {

  00092	8d 45 98	 lea	 eax, DWORD PTR _cl$[ebp]
  00095	50		 push	 eax
  00096	e8 00 00 00 00	 call	 ?cl_get_func@@YAHPAUcl_func_t@@@Z ; cl_get_func
  0009b	83 c4 04	 add	 esp, 4
  0009e	89 45 f8	 mov	 DWORD PTR _ret$[ebp], eax
  000a1	83 7d f8 00	 cmp	 DWORD PTR _ret$[ebp], 0
  000a5	74 28		 je	 SHORT $LN2@getGPUInfo

; 165  :         _tcscpy_s(buffer, buffer_size, _T("[0]Intel HD Graphics"));

  000a7	8b f4		 mov	 esi, esp
  000a9	68 00 00 00 00	 push	 OFFSET $SG157514
  000ae	8b 4d 10	 mov	 ecx, DWORD PTR _buffer_size$[ebp]
  000b1	51		 push	 ecx
  000b2	8b 55 0c	 mov	 edx, DWORD PTR _buffer$[ebp]
  000b5	52		 push	 edx
  000b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strcpy_s
  000bc	83 c4 0c	 add	 esp, 12			; 0000000cH
  000bf	3b f4		 cmp	 esi, esp
  000c1	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 166  :         opencl_error = true;

  000c6	c6 85 4f ff ff
	ff 01		 mov	 BYTE PTR _opencl_error$[ebp], 1
  000cd	eb 48		 jmp	 SHORT $LN3@getGPUInfo
$LN2@getGPUInfo:

; 167  :     } else if (CL_SUCCESS != (ret = cl_get_platform_and_device(VendorName, CL_DEVICE_TYPE_GPU, &data, &cl))) {

  000cf	8d 45 98	 lea	 eax, DWORD PTR _cl$[ebp]
  000d2	50		 push	 eax
  000d3	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _data$[ebp]
  000d9	51		 push	 ecx
  000da	6a 04		 push	 4
  000dc	8b 55 08	 mov	 edx, DWORD PTR _VendorName$[ebp]
  000df	52		 push	 edx
  000e0	e8 00 00 00 00	 call	 ?cl_get_platform_and_device@@YAHPBDHPAUcl_data_t@@PBUcl_func_t@@@Z ; cl_get_platform_and_device
  000e5	83 c4 10	 add	 esp, 16			; 00000010H
  000e8	89 45 f8	 mov	 DWORD PTR _ret$[ebp], eax
  000eb	83 7d f8 00	 cmp	 DWORD PTR _ret$[ebp], 0
  000ef	74 26		 je	 SHORT $LN3@getGPUInfo

; 168  :         _tcscpy_s(buffer, buffer_size, _T("[1]Intel HD Graphics"));

  000f1	8b f4		 mov	 esi, esp
  000f3	68 00 00 00 00	 push	 OFFSET $SG157516
  000f8	8b 45 10	 mov	 eax, DWORD PTR _buffer_size$[ebp]
  000fb	50		 push	 eax
  000fc	8b 4d 0c	 mov	 ecx, DWORD PTR _buffer$[ebp]
  000ff	51		 push	 ecx
  00100	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strcpy_s
  00106	83 c4 0c	 add	 esp, 12			; 0000000cH
  00109	3b f4		 cmp	 esi, esp
  0010b	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 169  :         opencl_error = true;

  00110	c6 85 4f ff ff
	ff 01		 mov	 BYTE PTR _opencl_error$[ebp], 1
$LN3@getGPUInfo:

; 170  :     }
; 171  : 
; 172  :     if (!driver_version_only && 0 != getIntelGPUInfo(&info)) {

  00117	0f b6 55 14	 movzx	 edx, BYTE PTR _driver_version_only$[ebp]
  0011b	85 d2		 test	 edx, edx
  0011d	75 39		 jne	 SHORT $LN5@getGPUInfo
  0011f	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR _info$[ebp]
  00125	50		 push	 eax
  00126	e8 00 00 00 00	 call	 ?getIntelGPUInfo@@YAHPAUIntelDeviceInfo@@@Z ; getIntelGPUInfo
  0012b	83 c4 04	 add	 esp, 4
  0012e	85 c0		 test	 eax, eax
  00130	74 26		 je	 SHORT $LN5@getGPUInfo

; 173  :         _tcscpy_s(buffer, buffer_size, _T("Failed to get GPU Info."));

  00132	8b f4		 mov	 esi, esp
  00134	68 00 00 00 00	 push	 OFFSET $SG157518
  00139	8b 4d 10	 mov	 ecx, DWORD PTR _buffer_size$[ebp]
  0013c	51		 push	 ecx
  0013d	8b 55 0c	 mov	 edx, DWORD PTR _buffer$[ebp]
  00140	52		 push	 edx
  00141	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strcpy_s
  00147	83 c4 0c	 add	 esp, 12			; 0000000cH
  0014a	3b f4		 cmp	 esi, esp
  0014c	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 174  :         intel_error = true;

  00151	c6 85 4e ff ff
	ff 01		 mov	 BYTE PTR _intel_error$[ebp], 1
$LN5@getGPUInfo:

; 175  :     }
; 176  : 
; 177  : 
; 178  :     if (driver_version_only) {

  00158	0f b6 45 14	 movzx	 eax, BYTE PTR _driver_version_only$[ebp]
  0015c	85 c0		 test	 eax, eax
  0015e	74 28		 je	 SHORT $LN6@getGPUInfo

; 179  :         if (!opencl_error) {

  00160	0f b6 8d 4f ff
	ff ff		 movzx	 ecx, BYTE PTR _opencl_error$[ebp]
  00167	85 c9		 test	 ecx, ecx
  00169	75 1b		 jne	 SHORT $LN8@getGPUInfo

; 180  :             cl_get_driver_version(&data, &cl, buffer, buffer_size);

  0016b	8b 55 10	 mov	 edx, DWORD PTR _buffer_size$[ebp]
  0016e	52		 push	 edx
  0016f	8b 45 0c	 mov	 eax, DWORD PTR _buffer$[ebp]
  00172	50		 push	 eax
  00173	8d 4d 98	 lea	 ecx, DWORD PTR _cl$[ebp]
  00176	51		 push	 ecx
  00177	8d 95 78 ff ff
	ff		 lea	 edx, DWORD PTR _data$[ebp]
  0017d	52		 push	 edx
  0017e	e8 00 00 00 00	 call	 ?cl_get_driver_version@@YAHPBUcl_data_t@@PBUcl_func_t@@PADI@Z ; cl_get_driver_version
  00183	83 c4 10	 add	 esp, 16			; 00000010H
$LN8@getGPUInfo:

; 181  :         }
; 182  :     } else {

  00186	eb 7e		 jmp	 SHORT $LN7@getGPUInfo
$LN6@getGPUInfo:

; 183  :         if (!(opencl_error && intel_error)) {

  00188	0f b6 85 4f ff
	ff ff		 movzx	 eax, BYTE PTR _opencl_error$[ebp]
  0018f	85 c0		 test	 eax, eax
  00191	74 0b		 je	 SHORT $LN10@getGPUInfo
  00193	0f b6 8d 4e ff
	ff ff		 movzx	 ecx, BYTE PTR _intel_error$[ebp]
  0019a	85 c9		 test	 ecx, ecx
  0019c	75 68		 jne	 SHORT $LN7@getGPUInfo
$LN10@getGPUInfo:

; 184  :             cl_create_info_string((opencl_error) ? NULL : &data, &cl, (intel_error) ? NULL : &info, buffer, buffer_size);

  0019e	0f b6 95 4e ff
	ff ff		 movzx	 edx, BYTE PTR _intel_error$[ebp]
  001a5	85 d2		 test	 edx, edx
  001a7	74 0c		 je	 SHORT $LN12@getGPUInfo
  001a9	c7 85 48 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv145[ebp], 0
  001b3	eb 0c		 jmp	 SHORT $LN13@getGPUInfo
$LN12@getGPUInfo:
  001b5	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR _info$[ebp]
  001bb	89 85 48 ff ff
	ff		 mov	 DWORD PTR tv145[ebp], eax
$LN13@getGPUInfo:
  001c1	0f b6 8d 4f ff
	ff ff		 movzx	 ecx, BYTE PTR _opencl_error$[ebp]
  001c8	85 c9		 test	 ecx, ecx
  001ca	74 0c		 je	 SHORT $LN14@getGPUInfo
  001cc	c7 85 44 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv150[ebp], 0
  001d6	eb 0c		 jmp	 SHORT $LN15@getGPUInfo
$LN14@getGPUInfo:
  001d8	8d 95 78 ff ff
	ff		 lea	 edx, DWORD PTR _data$[ebp]
  001de	89 95 44 ff ff
	ff		 mov	 DWORD PTR tv150[ebp], edx
$LN15@getGPUInfo:
  001e4	8b 45 10	 mov	 eax, DWORD PTR _buffer_size$[ebp]
  001e7	50		 push	 eax
  001e8	8b 4d 0c	 mov	 ecx, DWORD PTR _buffer$[ebp]
  001eb	51		 push	 ecx
  001ec	8b 95 48 ff ff
	ff		 mov	 edx, DWORD PTR tv145[ebp]
  001f2	52		 push	 edx
  001f3	8d 45 98	 lea	 eax, DWORD PTR _cl$[ebp]
  001f6	50		 push	 eax
  001f7	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR tv150[ebp]
  001fd	51		 push	 ecx
  001fe	e8 00 00 00 00	 call	 ?cl_create_info_string@@YAHPAUcl_data_t@@PBUcl_func_t@@PBUIntelDeviceInfo@@PADI@Z ; cl_create_info_string
  00203	83 c4 14	 add	 esp, 20			; 00000014H
$LN7@getGPUInfo:

; 185  :         }
; 186  :     }
; 187  :     cl_release(&data, &cl);

  00206	8d 55 98	 lea	 edx, DWORD PTR _cl$[ebp]
  00209	52		 push	 edx
  0020a	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _data$[ebp]
  00210	50		 push	 eax
  00211	e8 00 00 00 00	 call	 ?cl_release@@YAXPAUcl_data_t@@PAUcl_func_t@@@Z ; cl_release
  00216	83 c4 08	 add	 esp, 8

; 188  :     return ret;

  00219	8b 45 f8	 mov	 eax, DWORD PTR _ret$[ebp]

; 189  : #endif // !ENABLE_OPENCL
; 190  : }

  0021c	52		 push	 edx
  0021d	8b cd		 mov	 ecx, ebp
  0021f	50		 push	 eax
  00220	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN20@getGPUInfo
  00226	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0022b	58		 pop	 eax
  0022c	5a		 pop	 edx
  0022d	5f		 pop	 edi
  0022e	5e		 pop	 esi
  0022f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00232	33 cd		 xor	 ecx, ebp
  00234	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00239	81 c4 bc 00 00
	00		 add	 esp, 188		; 000000bcH
  0023f	3b ec		 cmp	 ebp, esp
  00241	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00246	8b e5		 mov	 esp, ebp
  00248	5d		 pop	 ebp
  00249	c3		 ret	 0
  0024a	66 90		 npad	 2
$LN20@getGPUInfo:
  0024c	03 00 00 00	 DD	 3
  00250	00 00 00 00	 DD	 $LN19@getGPUInfo
$LN19@getGPUInfo:
  00254	98 ff ff ff	 DD	 -104			; ffffff98H
  00258	5c 00 00 00	 DD	 92			; 0000005cH
  0025c	00 00 00 00	 DD	 $LN16@getGPUInfo
  00260	78 ff ff ff	 DD	 -136			; ffffff78H
  00264	18 00 00 00	 DD	 24			; 00000018H
  00268	00 00 00 00	 DD	 $LN17@getGPUInfo
  0026c	54 ff ff ff	 DD	 -172			; ffffff54H
  00270	1c 00 00 00	 DD	 28			; 0000001cH
  00274	00 00 00 00	 DD	 $LN18@getGPUInfo
$LN18@getGPUInfo:
  00278	69		 DB	 105			; 00000069H
  00279	6e		 DB	 110			; 0000006eH
  0027a	66		 DB	 102			; 00000066H
  0027b	6f		 DB	 111			; 0000006fH
  0027c	00		 DB	 0
$LN17@getGPUInfo:
  0027d	64		 DB	 100			; 00000064H
  0027e	61		 DB	 97			; 00000061H
  0027f	74		 DB	 116			; 00000074H
  00280	61		 DB	 97			; 00000061H
  00281	00		 DB	 0
$LN16@getGPUInfo:
  00282	63		 DB	 99			; 00000063H
  00283	6c		 DB	 108			; 0000006cH
  00284	00		 DB	 0
?getGPUInfo@@YAHPBDPADI_N@Z ENDP			; getGPUInfo
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _sprintf_s
_TEXT	SEGMENT
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
_sprintf_s PROC						; COMDAT

; 1841 :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 1842 :             int _Result;
; 1843 :             va_list _ArgList;
; 1844 :             __crt_va_start(_ArgList, _Format);

  0001b	8d 45 14	 lea	 eax, DWORD PTR __Format$[ebp+4]
  0001e	89 45 f8	 mov	 DWORD PTR __ArgList$[ebp], eax

; 1845 :             _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);

  00021	8b 4d f8	 mov	 ecx, DWORD PTR __ArgList$[ebp]
  00024	51		 push	 ecx
  00025	6a 00		 push	 0
  00027	8b 55 10	 mov	 edx, DWORD PTR __Format$[ebp]
  0002a	52		 push	 edx
  0002b	8b 45 0c	 mov	 eax, DWORD PTR __BufferCount$[ebp]
  0002e	50		 push	 eax
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR __Buffer$[ebp]
  00032	51		 push	 ecx
  00033	e8 00 00 00 00	 call	 __vsprintf_s_l
  00038	83 c4 14	 add	 esp, 20			; 00000014H
  0003b	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1846 :             __crt_va_end(_ArgList);

  0003e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 1847 :             return _Result;

  00045	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]

; 1848 :         }

  00048	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004b	3b ec		 cmp	 ebp, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
_sprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT __vsprintf_s_l
_TEXT	SEGMENT
tv73 = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsprintf_s_l PROC					; COMDAT

; 1497 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 1498 :         int const _Result = __stdio_common_vsprintf_s(

  00015	8b f4		 mov	 esi, esp
  00017	8b 45 18	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0001a	50		 push	 eax
  0001b	8b 4d 14	 mov	 ecx, DWORD PTR __Locale$[ebp]
  0001e	51		 push	 ecx
  0001f	8b 55 10	 mov	 edx, DWORD PTR __Format$[ebp]
  00022	52		 push	 edx
  00023	8b 45 0c	 mov	 eax, DWORD PTR __BufferCount$[ebp]
  00026	50		 push	 eax
  00027	8b 4d 08	 mov	 ecx, DWORD PTR __Buffer$[ebp]
  0002a	51		 push	 ecx
  0002b	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00030	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00033	52		 push	 edx
  00034	8b 00		 mov	 eax, DWORD PTR [eax]
  00036	50		 push	 eax
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vsprintf_s
  0003d	83 c4 1c	 add	 esp, 28			; 0000001cH
  00040	3b f4		 cmp	 esi, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1499 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1500 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1501 : 
; 1502 :         return _Result < 0 ? -1 : _Result;

  0004a	83 7d fc 00	 cmp	 DWORD PTR __Result$[ebp], 0
  0004e	7d 09		 jge	 SHORT $LN3@vsprintf_s
  00050	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR tv73[ebp], -1
  00057	eb 06		 jmp	 SHORT $LN4@vsprintf_s
$LN3@vsprintf_s:
  00059	8b 4d fc	 mov	 ecx, DWORD PTR __Result$[ebp]
  0005c	89 4d f8	 mov	 DWORD PTR tv73[ebp], ecx
$LN4@vsprintf_s:
  0005f	8b 45 f8	 mov	 eax, DWORD PTR tv73[ebp]

; 1503 :     }

  00062	5e		 pop	 esi
  00063	83 c4 08	 add	 esp, 8
  00066	3b ec		 cmp	 ebp, esp
  00068	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
__vsprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 86   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

  00003	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\tchar.h
;	COMDAT ?_tcsstr@@YAPADPADPBD@Z
_TEXT	SEGMENT
__S$ = 8						; size = 4
__P$ = 12						; size = 4
?_tcsstr@@YAPADPADPBD@Z PROC				; _tcsstr, COMDAT

; 2044 :         {return ((char *)_tcsstr((const char *)_S, _P)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 0c	 mov	 eax, DWORD PTR __P$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR __S$[ebp]
  0000a	51		 push	 ecx
  0000b	e8 00 00 00 00	 call	 __tcsstr
  00010	83 c4 08	 add	 esp, 8
  00013	3b ec		 cmp	 ebp, esp
  00015	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?_tcsstr@@YAPADPADPBD@Z ENDP				; _tcsstr
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\tchar.h
;	COMDAT __tcsstr
_TEXT	SEGMENT
__s1$ = 8						; size = 4
__s2$ = 12						; size = 4
__tcsstr PROC						; COMDAT

; 1582 : _Check_return_ __inline _CRPC _tcsstr(_In_z_ _CPC _s1,_In_z_ _CPC _s2) {return (_CRPC)_mbsstr((_CPUC)_s1,(_CPUC)_s2);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f4		 mov	 esi, esp
  00006	8b 45 0c	 mov	 eax, DWORD PTR __s2$[ebp]
  00009	50		 push	 eax
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __s1$[ebp]
  0000d	51		 push	 ecx
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___mbsstr
  00014	83 c4 08	 add	 esp, 8
  00017	3b f4		 cmp	 esi, esp
  00019	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0001e	5e		 pop	 esi
  0001f	3b ec		 cmp	 ebp, esp
  00021	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
__tcsstr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\gpu_info.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\gpu_info.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
