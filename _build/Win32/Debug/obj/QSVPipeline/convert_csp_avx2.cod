; Listing generated by Microsoft (R) Optimizing Compiler Version 19.23.28106.4 

	TITLE	D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG27397 DB	'Invalid', 00H
$SG27398 DB	'nv12', 00H
	ORG $+3
$SG27399 DB	'yv12', 00H
	ORG $+3
$SG27400 DB	'yuy2', 00H
	ORG $+3
$SG27401 DB	'yuv422', 00H
	ORG $+1
$SG27402 DB	'nv16', 00H
	ORG $+3
$SG27403 DB	'yuv444', 00H
	ORG $+1
$SG27404 DB	'yv12(9bit)', 00H
	ORG $+1
$SG27405 DB	'yv12(10bit)', 00H
$SG27406 DB	'yv12(12bit)', 00H
$SG27407 DB	'yv12(14bit)', 00H
$SG27408 DB	'yv12(16bit)', 00H
$SG27409 DB	'p010', 00H
	ORG $+3
$SG27410 DB	'yuv422(9bit)', 00H
	ORG $+3
$SG27411 DB	'yuv422(10bit)', 00H
	ORG $+2
$SG27412 DB	'yuv422(12bit)', 00H
	ORG $+2
$SG27413 DB	'yuv422(14bit)', 00H
	ORG $+2
$SG27414 DB	'yuv422(16bit)', 00H
	ORG $+2
$SG27415 DB	'p210', 00H
	ORG $+3
$SG27416 DB	'yuv444(9bit)', 00H
	ORG $+3
$SG27417 DB	'yuv444(10bit)', 00H
	ORG $+2
$SG27418 DB	'yuv444(12bit)', 00H
	ORG $+2
$SG27419 DB	'yuv444(14bit)', 00H
	ORG $+2
$SG27420 DB	'yuv444(16bit)', 00H
	ORG $+2
$SG27421 DB	'yuva444', 00H
$SG27422 DB	'yuva444(16bit)', 00H
	ORG $+1
$SG27423 DB	'rgb24r', 00H
	ORG $+1
$SG27424 DB	'rgb32r', 00H
	ORG $+1
$SG27425 DB	'rgb24', 00H
	ORG $+2
$SG27426 DB	'rgb32', 00H
	ORG $+2
$SG27427 DB	'bgr24', 00H
	ORG $+2
$SG27428 DB	'bgr32', 00H
	ORG $+2
$SG27429 DB	'rgb', 00H
$SG27430 DB	'rgba', 00H
	ORG $+3
$SG27431 DB	'gbr', 00H
$SG27432 DB	'gbra', 00H
	ORG $+3
$SG27433 DB	'yc48', 00H
	ORG $+3
$SG27434 DB	'y8', 00H
	ORG $+1
$SG27435 DB	'yc16', 00H
	ORG $+11
?Array_INTERLACE_WEIGHT@@3QAY0CA@$$CBEA DB 01H		; Array_INTERLACE_WEIGHT
	DB	03H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	03H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	01H
?Array_Y_L_MA_16@@3QBFB DW 0dbH				; Array_Y_L_MA_16
	DW	01H
	DW	0dbH
	DW	01H
	DW	0dbH
	DW	01H
	DW	0dbH
	DW	01H
	DW	0dbH
	DW	01H
	DW	0dbH
	DW	01H
	DW	0dbH
	DW	01H
	DW	0dbH
	DW	01H
?Array_UV_L_MA_16_420P@@3QBFB DW 0eH			; Array_UV_L_MA_16_420P
	DW	00H
	DW	0eH
	DW	00H
	DW	0eH
	DW	00H
	DW	0eH
	DW	00H
	DW	0eH
	DW	00H
	DW	0eH
	DW	00H
	DW	0eH
	DW	00H
	DW	0eH
	DW	00H
?Array_UV_L_MA_16_420I@@3QAY0BA@$$CBFA DW 02aH		; Array_UV_L_MA_16_420I
	DW	00H
	DW	02aH
	DW	00H
	DW	02aH
	DW	00H
	DW	02aH
	DW	00H
	DW	02aH
	DW	00H
	DW	02aH
	DW	00H
	DW	02aH
	DW	00H
	DW	02aH
	DW	00H
	DW	0eH
	DW	00H
	DW	0eH
	DW	00H
	DW	0eH
	DW	00H
	DW	0eH
	DW	00H
	DW	0eH
	DW	00H
	DW	0eH
	DW	00H
	DW	0eH
	DW	00H
	DW	0eH
	DW	00H
?Array_UV_L_MA_16_444@@3QBFB DW 0eH			; Array_UV_L_MA_16_444
	DW	00H
	DW	0eH
	DW	00H
	DW	0eH
	DW	00H
	DW	0eH
	DW	00H
	DW	0eH
	DW	00H
	DW	0eH
	DW	00H
	DW	0eH
	DW	00H
	DW	0eH
	DW	00H
?Array_SUFFLE_YCP_Y@@3QBEB DB 00H			; Array_SUFFLE_YCP_Y
	DB	01H
	DB	06H
	DB	07H
	DB	0cH
	DB	0dH
	DB	02H
	DB	03H
	DB	08H
	DB	09H
	DB	0eH
	DB	0fH
	DB	04H
	DB	05H
	DB	0aH
	DB	0bH
	DB	00H
	DB	01H
	DB	06H
	DB	07H
	DB	0cH
	DB	0dH
	DB	02H
	DB	03H
	DB	08H
	DB	09H
	DB	0eH
	DB	0fH
	DB	04H
	DB	05H
	DB	0aH
	DB	0bH
CONST	ENDS
PUBLIC	?copy_nv12_to_nv12_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; copy_nv12_to_nv12_avx2
PUBLIC	??$copy_nv12_to_nv12_avx2_internal@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; copy_nv12_to_nv12_avx2_internal<0>
PUBLIC	?copy_p010_to_p010_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; copy_p010_to_p010_avx2
PUBLIC	??$copy_nv12_to_nv12_avx2_internal@$00@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; copy_nv12_to_nv12_avx2_internal<1>
PUBLIC	?convert_yuy2_to_nv12_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuy2_to_nv12_avx2
PUBLIC	?convert_yuy2_to_nv12_i_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuy2_to_nv12_i_avx2
PUBLIC	?convert_yv12_to_nv12_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_to_nv12_avx2
PUBLIC	?convert_uv_yv12_to_nv12_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_uv_yv12_to_nv12_avx2
PUBLIC	?convert_rgb24_to_rgb32_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_rgb24_to_rgb32_avx2
PUBLIC	?convert_rgb24r_to_rgb32_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_rgb24r_to_rgb32_avx2
PUBLIC	?convert_rgb32_to_rgb32_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_rgb32_to_rgb32_avx2
PUBLIC	?convert_rgb32r_to_rgb32_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_rgb32r_to_rgb32_avx2
PUBLIC	?convert_rgb24_to_rgb24_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_rgb24_to_rgb24_avx2
PUBLIC	?convert_rgb24r_to_rgb24_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_rgb24r_to_rgb24_avx2
PUBLIC	?convert_yv12_to_p010_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_to_p010_avx2
PUBLIC	?convert_yv12_16_to_nv12_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_16_to_nv12_avx2
PUBLIC	?convert_yv12_14_to_nv12_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_14_to_nv12_avx2
PUBLIC	?convert_yv12_12_to_nv12_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_12_to_nv12_avx2
PUBLIC	?convert_yv12_10_to_nv12_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_10_to_nv12_avx2
PUBLIC	?convert_yv12_09_to_nv12_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_09_to_nv12_avx2
PUBLIC	?convert_yv12_16_to_p010_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_16_to_p010_avx2
PUBLIC	?convert_yv12_14_to_p010_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_14_to_p010_avx2
PUBLIC	?convert_yv12_12_to_p010_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_12_to_p010_avx2
PUBLIC	?convert_yv12_10_to_p010_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_10_to_p010_avx2
PUBLIC	?convert_yv12_09_to_p010_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_09_to_p010_avx2
PUBLIC	?copy_yuv444_to_yuv444_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; copy_yuv444_to_yuv444_avx2
PUBLIC	?convert_yuv444_16_to_yuv444_16_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_16_to_yuv444_16_avx2
PUBLIC	?convert_yuv444_14_to_yuv444_16_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_14_to_yuv444_16_avx2
PUBLIC	?convert_yuv444_12_to_yuv444_16_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_12_to_yuv444_16_avx2
PUBLIC	?convert_yuv444_10_to_yuv444_16_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_10_to_yuv444_16_avx2
PUBLIC	?convert_yuv444_09_to_yuv444_16_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_09_to_yuv444_16_avx2
PUBLIC	?convert_yuv444_to_yuv444_16_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_to_yuv444_16_avx2
PUBLIC	?convert_yuv444_16_to_yuv444_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_16_to_yuv444_avx2
PUBLIC	?convert_yuv444_14_to_yuv444_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_14_to_yuv444_avx2
PUBLIC	?convert_yuv444_12_to_yuv444_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_12_to_yuv444_avx2
PUBLIC	?convert_yuv444_10_to_yuv444_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_10_to_yuv444_avx2
PUBLIC	?convert_yuv444_09_to_yuv444_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_09_to_yuv444_avx2
PUBLIC	?convert_yc48_to_p010_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yc48_to_p010_avx2
PUBLIC	?convert_yc48_to_p010_i_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yc48_to_p010_i_avx2
PUBLIC	?convert_yc48_to_yuv444_16bit_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yc48_to_yuv444_16bit_avx2
PUBLIC	?convert_yuv444_16bit_to_yc48_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_16bit_to_yc48_avx2
PUBLIC	__ymm@0000100000001000000010000000100000001000000010000000100000001000
PUBLIC	__ymm@0001000100010001000100010001000100010001000100010001000100010001
PUBLIC	__ymm@0002000200020002000200020002000200020002000200020002000200020002
PUBLIC	__ymm@0080008000800080008000800080008000800080008000800080008000800080
PUBLIC	__ymm@0800080008000800080008000800080008000800080008000800080008000800
PUBLIC	__ymm@082f082f082f082f082f082f082f082f082f082f082f082f082f082f082f082f
PUBLIC	__ymm@1000100010001000100010001000100010001000100010001000100010001000
PUBLIC	__ymm@124a124a124a124a124a124a124a124a124a124a124a124a124a124a124a124a
PUBLIC	__ymm@12b412b412b412b412b412b412b412b412b412b412b412b412b412b412b412b4
PUBLIC	__ymm@ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT __ymm@ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
CONST	SEGMENT
__ymm@ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff DB 0ffH
	DB	0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH
	DB	0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH
	DB	0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH
CONST	ENDS
;	COMDAT __ymm@12b412b412b412b412b412b412b412b412b412b412b412b412b412b412b412b4
CONST	SEGMENT
__ymm@12b412b412b412b412b412b412b412b412b412b412b412b412b412b412b412b4 DB 0b4H
	DB	012H, 0b4H, 012H, 0b4H, 012H, 0b4H, 012H, 0b4H, 012H, 0b4H, 012H
	DB	0b4H, 012H, 0b4H, 012H, 0b4H, 012H, 0b4H, 012H, 0b4H, 012H, 0b4H
	DB	012H, 0b4H, 012H, 0b4H, 012H, 0b4H, 012H, 0b4H, 012H
CONST	ENDS
;	COMDAT __ymm@124a124a124a124a124a124a124a124a124a124a124a124a124a124a124a124a
CONST	SEGMENT
__ymm@124a124a124a124a124a124a124a124a124a124a124a124a124a124a124a124a DB 'J'
	DB	012H, 'J', 012H, 'J', 012H, 'J', 012H, 'J', 012H, 'J', 012H, 'J'
	DB	012H, 'J', 012H, 'J', 012H, 'J', 012H, 'J', 012H, 'J', 012H, 'J'
	DB	012H, 'J', 012H, 'J', 012H, 'J', 012H
CONST	ENDS
;	COMDAT __ymm@1000100010001000100010001000100010001000100010001000100010001000
CONST	SEGMENT
__ymm@1000100010001000100010001000100010001000100010001000100010001000 DB 00H
	DB	010H, 00H, 010H, 00H, 010H, 00H, 010H, 00H, 010H, 00H, 010H, 00H
	DB	010H, 00H, 010H, 00H, 010H, 00H, 010H, 00H, 010H, 00H, 010H, 00H
	DB	010H, 00H, 010H, 00H, 010H, 00H, 010H
CONST	ENDS
;	COMDAT __ymm@082f082f082f082f082f082f082f082f082f082f082f082f082f082f082f082f
CONST	SEGMENT
__ymm@082f082f082f082f082f082f082f082f082f082f082f082f082f082f082f082f DB '/'
	DB	08H, '/', 08H, '/', 08H, '/', 08H, '/', 08H, '/', 08H, '/', 08H
	DB	'/', 08H, '/', 08H, '/', 08H, '/', 08H, '/', 08H, '/', 08H, '/'
	DB	08H, '/', 08H, '/', 08H
CONST	ENDS
;	COMDAT __ymm@0800080008000800080008000800080008000800080008000800080008000800
CONST	SEGMENT
__ymm@0800080008000800080008000800080008000800080008000800080008000800 DB 00H
	DB	08H, 00H, 08H, 00H, 08H, 00H, 08H, 00H, 08H, 00H, 08H, 00H, 08H
	DB	00H, 08H, 00H, 08H, 00H, 08H, 00H, 08H, 00H, 08H, 00H, 08H, 00H
	DB	08H, 00H, 08H, 00H, 08H
CONST	ENDS
;	COMDAT __ymm@0080008000800080008000800080008000800080008000800080008000800080
CONST	SEGMENT
__ymm@0080008000800080008000800080008000800080008000800080008000800080 DB 080H
	DB	00H, 080H, 00H, 080H, 00H, 080H, 00H, 080H, 00H, 080H, 00H, 080H
	DB	00H, 080H, 00H, 080H, 00H, 080H, 00H, 080H, 00H, 080H, 00H, 080H
	DB	00H, 080H, 00H, 080H, 00H, 080H, 00H
CONST	ENDS
;	COMDAT __ymm@0002000200020002000200020002000200020002000200020002000200020002
CONST	SEGMENT
__ymm@0002000200020002000200020002000200020002000200020002000200020002 DB 02H
	DB	00H, 02H, 00H, 02H, 00H, 02H, 00H, 02H, 00H, 02H, 00H, 02H, 00H
	DB	02H, 00H, 02H, 00H, 02H, 00H, 02H, 00H, 02H, 00H, 02H, 00H, 02H
	DB	00H, 02H, 00H, 02H, 00H
CONST	ENDS
;	COMDAT __ymm@0001000100010001000100010001000100010001000100010001000100010001
CONST	SEGMENT
__ymm@0001000100010001000100010001000100010001000100010001000100010001 DB 01H
	DB	00H, 01H, 00H, 01H, 00H, 01H, 00H, 01H, 00H, 01H, 00H, 01H, 00H
	DB	01H, 00H, 01H, 00H, 01H, 00H, 01H, 00H, 01H, 00H, 01H, 00H, 01H
	DB	00H, 01H, 00H, 01H, 00H
CONST	ENDS
;	COMDAT __ymm@0000100000001000000010000000100000001000000010000000100000001000
CONST	SEGMENT
__ymm@0000100000001000000010000000100000001000000010000000100000001000 DB 00H
	DB	010H, 00H, 00H, 00H, 010H, 00H, 00H, 00H, 010H, 00H, 00H, 00H, 010H
	DB	00H, 00H, 00H, 010H, 00H, 00H, 00H, 010H, 00H, 00H, 00H, 010H, 00H
	DB	00H, 00H, 010H, 00H, 00H
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ?SHUFFLE_MASK@?N@???$convert_yv12_to_p010_avx2_base@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z@4QBHB
CONST	SEGMENT
?SHUFFLE_MASK@?N@???$convert_yv12_to_p010_avx2_base@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z@4QBHB DD 00H ; `convert_yv12_to_p010_avx2_base<0>'::`13'::SHUFFLE_MASK
	DD	02H
	DD	04H
	DD	06H
	DD	01H
	DD	03H
	DD	05H
	DD	07H
CONST	ENDS
;	COMDAT ?shuffle_yc48@?1??gather_y_u_v_to_yc48@@YAXAAT__m256i@@00@Z@4QBEB
CONST	SEGMENT
?shuffle_yc48@?1??gather_y_u_v_to_yc48@@YAXAAT__m256i@@00@Z@4QBEB DB 00H ; `gather_y_u_v_to_yc48'::`2'::shuffle_yc48
	DB	01H
	DB	06H
	DB	07H
	DB	0cH
	DB	0dH
	DB	02H
	DB	03H
	DB	08H
	DB	09H
	DB	0eH
	DB	0fH
	DB	04H
	DB	05H
	DB	0aH
	DB	0bH
	DB	00H
	DB	01H
	DB	06H
	DB	07H
	DB	0cH
	DB	0dH
	DB	02H
	DB	03H
	DB	08H
	DB	09H
	DB	0eH
	DB	0fH
	DB	04H
	DB	05H
	DB	0aH
	DB	0bH
CONST	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
$T1 = -464						; size = 12
$T2 = -448						; size = 32
$T3 = -416						; size = 32
$T4 = -384						; size = 32
$T5 = -352						; size = 32
$T6 = -320						; size = 32
$T7 = -288						; size = 32
_ycp$8 = -252						; size = 4
_ycp_fin$9 = -248					; size = 4
_V$10 = -244						; size = 4
_U$11 = -240						; size = 4
_Y$12 = -236						; size = 4
_y$13 = -232						; size = 4
_y3$ = -224						; size = 32
_y2$ = -160						; size = 32
_y1$ = -96						; size = 32
_pixel$ = -52						; size = 4
_V_line$ = -48						; size = 4
_U_line$ = -44						; size = 4
_Y_line$ = -40						; size = 4
$T14 = -36						; size = 12
_y_range$ = -20						; size = 12
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuv444_16bit_to_yc48_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_16bit_to_yc48_avx2

; 1143 : void convert_yuv444_16bit_to_yc48_avx2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec e0 01 00
	00		 sub	 esp, 480		; 000001e0H
  0001c	57		 push	 edi
  0001d	8d bd 20 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-480]
  00023	b9 78 00 00 00	 mov	 ecx, 120		; 00000078H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1144 :     const auto y_range = thread_y_range(0, height, thread_id, thread_n);

  00039	8b 43 2c	 mov	 eax, DWORD PTR _thread_n$[ebx]
  0003c	50		 push	 eax
  0003d	8b 4b 28	 mov	 ecx, DWORD PTR _thread_id$[ebx]
  00040	51		 push	 ecx
  00041	8b 53 20	 mov	 edx, DWORD PTR _height$[ebx]
  00044	52		 push	 edx
  00045	6a 00		 push	 0
  00047	8d 85 30 fe ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00053	83 c4 14	 add	 esp, 20			; 00000014H
  00056	8b 08		 mov	 ecx, DWORD PTR [eax]
  00058	89 4d dc	 mov	 DWORD PTR $T14[ebp], ecx
  0005b	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0005e	89 55 e0	 mov	 DWORD PTR $T14[ebp+4], edx
  00061	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00064	89 45 e4	 mov	 DWORD PTR $T14[ebp+8], eax
  00067	8b 4d dc	 mov	 ecx, DWORD PTR $T14[ebp]
  0006a	89 4d ec	 mov	 DWORD PTR _y_range$[ebp], ecx
  0006d	8b 55 e0	 mov	 edx, DWORD PTR $T14[ebp+4]
  00070	89 55 f0	 mov	 DWORD PTR _y_range$[ebp+4], edx
  00073	8b 45 e4	 mov	 eax, DWORD PTR $T14[ebp+8]
  00076	89 45 f4	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 1145 :     char *Y_line = (char *)src[0] + src_y_pitch_byte * y_range.start_src;

  00079	b9 04 00 00 00	 mov	 ecx, 4
  0007e	6b d1 00	 imul	 edx, ecx, 0
  00081	8b 43 14	 mov	 eax, DWORD PTR _src_y_pitch_byte$[ebx]
  00084	0f af 45 ec	 imul	 eax, DWORD PTR _y_range$[ebp]
  00088	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  0008b	03 04 11	 add	 eax, DWORD PTR [ecx+edx]
  0008e	89 45 d8	 mov	 DWORD PTR _Y_line$[ebp], eax

; 1146 :     char *U_line = (char *)src[1] + src_y_pitch_byte * y_range.start_src;

  00091	ba 04 00 00 00	 mov	 edx, 4
  00096	c1 e2 00	 shl	 edx, 0
  00099	8b 43 14	 mov	 eax, DWORD PTR _src_y_pitch_byte$[ebx]
  0009c	0f af 45 ec	 imul	 eax, DWORD PTR _y_range$[ebp]
  000a0	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  000a3	03 04 11	 add	 eax, DWORD PTR [ecx+edx]
  000a6	89 45 d4	 mov	 DWORD PTR _U_line$[ebp], eax

; 1147 :     char *V_line = (char *)src[2] + src_y_pitch_byte * y_range.start_src;

  000a9	ba 04 00 00 00	 mov	 edx, 4
  000ae	d1 e2		 shl	 edx, 1
  000b0	8b 43 14	 mov	 eax, DWORD PTR _src_y_pitch_byte$[ebx]
  000b3	0f af 45 ec	 imul	 eax, DWORD PTR _y_range$[ebp]
  000b7	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  000ba	03 04 11	 add	 eax, DWORD PTR [ecx+edx]
  000bd	89 45 d0	 mov	 DWORD PTR _V_line$[ebp], eax

; 1148 :     char *pixel = (char *)dst[0] + dst_y_pitch_byte * y_range.start_dst;

  000c0	ba 04 00 00 00	 mov	 edx, 4
  000c5	6b c2 00	 imul	 eax, edx, 0
  000c8	8b 4b 1c	 mov	 ecx, DWORD PTR _dst_y_pitch_byte$[ebx]
  000cb	0f af 4d f0	 imul	 ecx, DWORD PTR _y_range$[ebp+4]
  000cf	8b 53 08	 mov	 edx, DWORD PTR _dst$[ebx]
  000d2	03 0c 02	 add	 ecx, DWORD PTR [edx+eax]
  000d5	89 4d cc	 mov	 DWORD PTR _pixel$[ebp], ecx

; 1149 :     __m256i y1, y2, y3;
; 1150 :     for (int y = 0; y < y_range.len; y++, pixel += dst_y_pitch_byte, Y_line += src_y_pitch_byte, U_line += src_y_pitch_byte, V_line += src_y_pitch_byte) {

  000d8	c7 85 18 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _y$13[ebp], 0
  000e2	eb 33		 jmp	 SHORT $LN4@convert_yu
$LN2@convert_yu:
  000e4	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _y$13[ebp]
  000ea	83 c0 01	 add	 eax, 1
  000ed	89 85 18 ff ff
	ff		 mov	 DWORD PTR _y$13[ebp], eax
  000f3	8b 4d cc	 mov	 ecx, DWORD PTR _pixel$[ebp]
  000f6	03 4b 1c	 add	 ecx, DWORD PTR _dst_y_pitch_byte$[ebx]
  000f9	89 4d cc	 mov	 DWORD PTR _pixel$[ebp], ecx
  000fc	8b 55 d8	 mov	 edx, DWORD PTR _Y_line$[ebp]
  000ff	03 53 14	 add	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  00102	89 55 d8	 mov	 DWORD PTR _Y_line$[ebp], edx
  00105	8b 45 d4	 mov	 eax, DWORD PTR _U_line$[ebp]
  00108	03 43 14	 add	 eax, DWORD PTR _src_y_pitch_byte$[ebx]
  0010b	89 45 d4	 mov	 DWORD PTR _U_line$[ebp], eax
  0010e	8b 4d d0	 mov	 ecx, DWORD PTR _V_line$[ebp]
  00111	03 4b 14	 add	 ecx, DWORD PTR _src_y_pitch_byte$[ebx]
  00114	89 4d d0	 mov	 DWORD PTR _V_line$[ebp], ecx
$LN4@convert_yu:
  00117	8b 95 18 ff ff
	ff		 mov	 edx, DWORD PTR _y$13[ebp]
  0011d	3b 55 f4	 cmp	 edx, DWORD PTR _y_range$[ebp+8]
  00120	0f 8d ad 01 00
	00		 jge	 $LN1@convert_yu

; 1151 :         short *Y = (short *)Y_line;

  00126	8b 45 d8	 mov	 eax, DWORD PTR _Y_line$[ebp]
  00129	89 85 14 ff ff
	ff		 mov	 DWORD PTR _Y$12[ebp], eax

; 1152 :         short *U = (short *)U_line;

  0012f	8b 4d d4	 mov	 ecx, DWORD PTR _U_line$[ebp]
  00132	89 8d 10 ff ff
	ff		 mov	 DWORD PTR _U$11[ebp], ecx

; 1153 :         short *V = (short *)V_line;

  00138	8b 55 d0	 mov	 edx, DWORD PTR _V_line$[ebp]
  0013b	89 95 0c ff ff
	ff		 mov	 DWORD PTR _V$10[ebp], edx

; 1154 :         short *const ycp_fin = (short *)pixel + width * 3;

  00141	6b 43 10 03	 imul	 eax, DWORD PTR _width$[ebx], 3
  00145	8b 4d cc	 mov	 ecx, DWORD PTR _pixel$[ebp]
  00148	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  0014b	89 95 08 ff ff
	ff		 mov	 DWORD PTR _ycp_fin$9[ebp], edx

; 1155 :         for (short *ycp = (short *)pixel; ycp < ycp_fin; ycp += 48, Y += 16, U += 16, V += 16) {

  00151	8b 45 cc	 mov	 eax, DWORD PTR _pixel$[ebp]
  00154	89 85 04 ff ff
	ff		 mov	 DWORD PTR _ycp$8[ebp], eax
  0015a	eb 3c		 jmp	 SHORT $LN7@convert_yu
$LN5@convert_yu:
  0015c	8b 8d 04 ff ff
	ff		 mov	 ecx, DWORD PTR _ycp$8[ebp]
  00162	83 c1 60	 add	 ecx, 96			; 00000060H
  00165	89 8d 04 ff ff
	ff		 mov	 DWORD PTR _ycp$8[ebp], ecx
  0016b	8b 95 14 ff ff
	ff		 mov	 edx, DWORD PTR _Y$12[ebp]
  00171	83 c2 20	 add	 edx, 32			; 00000020H
  00174	89 95 14 ff ff
	ff		 mov	 DWORD PTR _Y$12[ebp], edx
  0017a	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _U$11[ebp]
  00180	83 c0 20	 add	 eax, 32			; 00000020H
  00183	89 85 10 ff ff
	ff		 mov	 DWORD PTR _U$11[ebp], eax
  00189	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR _V$10[ebp]
  0018f	83 c1 20	 add	 ecx, 32			; 00000020H
  00192	89 8d 0c ff ff
	ff		 mov	 DWORD PTR _V$10[ebp], ecx
$LN7@convert_yu:
  00198	8b 95 04 ff ff
	ff		 mov	 edx, DWORD PTR _ycp$8[ebp]
  0019e	3b 95 08 ff ff
	ff		 cmp	 edx, DWORD PTR _ycp_fin$9[ebp]
  001a4	0f 83 24 01 00
	00		 jae	 $LN6@convert_yu

; 1156 :             y1 = _mm256_loadu_si256((__m256i *)(Y));

  001aa	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _Y$12[ebp]
  001b0	c5 fe 6f 00	 vmovdqu ymm0, YMMWORD PTR [eax]
  001b4	c5 fe 7f 85 e0
	fe ff ff	 vmovdqu YMMWORD PTR $T7[ebp], ymm0
  001bc	c5 fe 6f 85 e0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T7[ebp]
  001c4	c5 fe 7f 45 a0	 vmovdqu YMMWORD PTR _y1$[ebp], ymm0

; 1157 :             y2 = _mm256_loadu_si256((__m256i *)(U));

  001c9	8b 8d 10 ff ff
	ff		 mov	 ecx, DWORD PTR _U$11[ebp]
  001cf	c5 fe 6f 01	 vmovdqu ymm0, YMMWORD PTR [ecx]
  001d3	c5 fe 7f 85 c0
	fe ff ff	 vmovdqu YMMWORD PTR $T6[ebp], ymm0
  001db	c5 fe 6f 85 c0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T6[ebp]
  001e3	c5 fe 7f 85 60
	ff ff ff	 vmovdqu YMMWORD PTR _y2$[ebp], ymm0

; 1158 :             y3 = _mm256_loadu_si256((__m256i *)(V));

  001eb	8b 95 0c ff ff
	ff		 mov	 edx, DWORD PTR _V$10[ebp]
  001f1	c5 fe 6f 02	 vmovdqu ymm0, YMMWORD PTR [edx]
  001f5	c5 fe 7f 85 a0
	fe ff ff	 vmovdqu YMMWORD PTR $T5[ebp], ymm0
  001fd	c5 fe 6f 85 a0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T5[ebp]
  00205	c5 fe 7f 85 20
	ff ff ff	 vmovdqu YMMWORD PTR _y3$[ebp], ymm0

; 1159 :             y1 = convert_y_range_to_yc48(y1);

  0020d	c5 fe 6f 45 a0	 vmovdqu ymm0, YMMWORD PTR _y1$[ebp]
  00212	e8 00 00 00 00	 call	 ?convert_y_range_to_yc48@@YA?AT__m256i@@T1@@Z ; convert_y_range_to_yc48
  00217	c5 fe 7f 85 80
	fe ff ff	 vmovdqu YMMWORD PTR $T4[ebp], ymm0
  0021f	c5 fe 6f 85 80
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T4[ebp]
  00227	c5 fe 7f 45 a0	 vmovdqu YMMWORD PTR _y1$[ebp], ymm0

; 1160 :             y2 = convert_uv_range_to_yc48(y2);

  0022c	c5 fe 6f 85 60
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR _y2$[ebp]
  00234	e8 00 00 00 00	 call	 ?convert_uv_range_to_yc48@@YA?AT__m256i@@T1@@Z ; convert_uv_range_to_yc48
  00239	c5 fe 7f 85 60
	fe ff ff	 vmovdqu YMMWORD PTR $T3[ebp], ymm0
  00241	c5 fe 6f 85 60
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T3[ebp]
  00249	c5 fe 7f 85 60
	ff ff ff	 vmovdqu YMMWORD PTR _y2$[ebp], ymm0

; 1161 :             y3 = convert_uv_range_to_yc48(y3);

  00251	c5 fe 6f 85 20
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR _y3$[ebp]
  00259	e8 00 00 00 00	 call	 ?convert_uv_range_to_yc48@@YA?AT__m256i@@T1@@Z ; convert_uv_range_to_yc48
  0025e	c5 fe 7f 85 40
	fe ff ff	 vmovdqu YMMWORD PTR $T2[ebp], ymm0
  00266	c5 fe 6f 85 40
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T2[ebp]
  0026e	c5 fe 7f 85 20
	ff ff ff	 vmovdqu YMMWORD PTR _y3$[ebp], ymm0

; 1162 :             gather_y_u_v_to_yc48(y1, y2, y3);

  00276	8d 85 20 ff ff
	ff		 lea	 eax, DWORD PTR _y3$[ebp]
  0027c	50		 push	 eax
  0027d	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR _y2$[ebp]
  00283	51		 push	 ecx
  00284	8d 55 a0	 lea	 edx, DWORD PTR _y1$[ebp]
  00287	52		 push	 edx
  00288	e8 00 00 00 00	 call	 ?gather_y_u_v_to_yc48@@YAXAAT__m256i@@00@Z ; gather_y_u_v_to_yc48
  0028d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1163 :             _mm256_storeu_si256((__m256i *)(ycp +  0), y1);

  00290	c5 fe 6f 45 a0	 vmovdqu ymm0, YMMWORD PTR _y1$[ebp]
  00295	8b 85 04 ff ff
	ff		 mov	 eax, DWORD PTR _ycp$8[ebp]
  0029b	c5 fe 7f 00	 vmovdqu YMMWORD PTR [eax], ymm0

; 1164 :             _mm256_storeu_si256((__m256i *)(ycp + 16), y2);

  0029f	c5 fe 6f 85 60
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR _y2$[ebp]
  002a7	8b 8d 04 ff ff
	ff		 mov	 ecx, DWORD PTR _ycp$8[ebp]
  002ad	83 c1 20	 add	 ecx, 32			; 00000020H
  002b0	c5 fe 7f 01	 vmovdqu YMMWORD PTR [ecx], ymm0

; 1165 :             _mm256_storeu_si256((__m256i *)(ycp + 32), y3);

  002b4	c5 fe 6f 85 20
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR _y3$[ebp]
  002bc	8b 95 04 ff ff
	ff		 mov	 edx, DWORD PTR _ycp$8[ebp]
  002c2	83 c2 40	 add	 edx, 64			; 00000040H
  002c5	c5 fe 7f 02	 vmovdqu YMMWORD PTR [edx], ymm0

; 1166 :         }

  002c9	e9 8e fe ff ff	 jmp	 $LN5@convert_yu
$LN6@convert_yu:

; 1167 :     }

  002ce	e9 11 fe ff ff	 jmp	 $LN2@convert_yu
$LN1@convert_yu:

; 1168 : }

  002d3	52		 push	 edx
  002d4	8b cd		 mov	 ecx, ebp
  002d6	50		 push	 eax
  002d7	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN14@convert_yu
  002dd	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  002e2	58		 pop	 eax
  002e3	5a		 pop	 edx
  002e4	5f		 pop	 edi
  002e5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002e8	33 cd		 xor	 ecx, ebp
  002ea	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002ef	8b e5		 mov	 esp, ebp
  002f1	5d		 pop	 ebp
  002f2	8b e3		 mov	 esp, ebx
  002f4	5b		 pop	 ebx
  002f5	c3		 ret	 0
  002f6	66 90		 npad	 2
$LN14@convert_yu:
  002f8	04 00 00 00	 DD	 4
  002fc	00 00 00 00	 DD	 $LN13@convert_yu
$LN13@convert_yu:
  00300	ec ff ff ff	 DD	 -20			; ffffffecH
  00304	0c 00 00 00	 DD	 12			; 0000000cH
  00308	00 00 00 00	 DD	 $LN9@convert_yu
  0030c	a0 ff ff ff	 DD	 -96			; ffffffa0H
  00310	20 00 00 00	 DD	 32			; 00000020H
  00314	00 00 00 00	 DD	 $LN10@convert_yu
  00318	60 ff ff ff	 DD	 -160			; ffffff60H
  0031c	20 00 00 00	 DD	 32			; 00000020H
  00320	00 00 00 00	 DD	 $LN11@convert_yu
  00324	20 ff ff ff	 DD	 -224			; ffffff20H
  00328	20 00 00 00	 DD	 32			; 00000020H
  0032c	00 00 00 00	 DD	 $LN12@convert_yu
$LN12@convert_yu:
  00330	79		 DB	 121			; 00000079H
  00331	33		 DB	 51			; 00000033H
  00332	00		 DB	 0
$LN11@convert_yu:
  00333	79		 DB	 121			; 00000079H
  00334	32		 DB	 50			; 00000032H
  00335	00		 DB	 0
$LN10@convert_yu:
  00336	79		 DB	 121			; 00000079H
  00337	31		 DB	 49			; 00000031H
  00338	00		 DB	 0
$LN9@convert_yu:
  00339	79		 DB	 121			; 00000079H
  0033a	5f		 DB	 95			; 0000005fH
  0033b	72		 DB	 114			; 00000072H
  0033c	61		 DB	 97			; 00000061H
  0033d	6e		 DB	 110			; 0000006eH
  0033e	67		 DB	 103			; 00000067H
  0033f	65		 DB	 101			; 00000065H
  00340	00		 DB	 0
?convert_yuv444_16bit_to_yc48_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_16bit_to_yc48_avx2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
$T1 = -880						; size = 12
$T2 = -864						; size = 32
$T3 = -832						; size = 32
$T4 = -800						; size = 32
$T5 = -768						; size = 32
$T6 = -736						; size = 32
$T7 = -704						; size = 32
$T8 = -672						; size = 32
$T9 = -640						; size = 32
$T10 = -608						; size = 32
$T11 = -576						; size = 32
$T12 = -544						; size = 32
_ycp$13 = -508						; size = 4
_ycp_fin$14 = -504					; size = 4
_V$15 = -500						; size = 4
_U$16 = -496						; size = 4
_Y$17 = -492						; size = 4
_y$18 = -488						; size = 4
_y3$ = -480						; size = 32
_y2$ = -416						; size = 32
_y1$ = -352						; size = 32
$T19 = -288						; size = 32
_yC_YCC$ = -224						; size = 32
$T20 = -160						; size = 32
_yC_pw_one$ = -96					; size = 32
_pixel$ = -52						; size = 4
_V_line$ = -48						; size = 4
_U_line$ = -44						; size = 4
_Y_line$ = -40						; size = 4
$T21 = -36						; size = 12
_y_range$ = -20						; size = 12
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yc48_to_yuv444_16bit_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yc48_to_yuv444_16bit_avx2

; 1114 : void convert_yc48_to_yuv444_16bit_avx2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 80 03 00
	00		 sub	 esp, 896		; 00000380H
  0001c	57		 push	 edi
  0001d	8d bd 80 fc ff
	ff		 lea	 edi, DWORD PTR [ebp-896]
  00023	b9 e0 00 00 00	 mov	 ecx, 224		; 000000e0H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1115 :     const auto y_range = thread_y_range(0, height, thread_id, thread_n);

  00039	8b 43 2c	 mov	 eax, DWORD PTR _thread_n$[ebx]
  0003c	50		 push	 eax
  0003d	8b 4b 28	 mov	 ecx, DWORD PTR _thread_id$[ebx]
  00040	51		 push	 ecx
  00041	8b 53 20	 mov	 edx, DWORD PTR _height$[ebx]
  00044	52		 push	 edx
  00045	6a 00		 push	 0
  00047	8d 85 90 fc ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00053	83 c4 14	 add	 esp, 20			; 00000014H
  00056	8b 08		 mov	 ecx, DWORD PTR [eax]
  00058	89 4d dc	 mov	 DWORD PTR $T21[ebp], ecx
  0005b	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0005e	89 55 e0	 mov	 DWORD PTR $T21[ebp+4], edx
  00061	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00064	89 45 e4	 mov	 DWORD PTR $T21[ebp+8], eax
  00067	8b 4d dc	 mov	 ecx, DWORD PTR $T21[ebp]
  0006a	89 4d ec	 mov	 DWORD PTR _y_range$[ebp], ecx
  0006d	8b 55 e0	 mov	 edx, DWORD PTR $T21[ebp+4]
  00070	89 55 f0	 mov	 DWORD PTR _y_range$[ebp+4], edx
  00073	8b 45 e4	 mov	 eax, DWORD PTR $T21[ebp+8]
  00076	89 45 f4	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 1116 :     char *Y_line = (char *)dst[0] + dst_y_pitch_byte * y_range.start_dst;

  00079	b9 04 00 00 00	 mov	 ecx, 4
  0007e	6b d1 00	 imul	 edx, ecx, 0
  00081	8b 43 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  00084	0f af 45 f0	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  00088	8b 4b 08	 mov	 ecx, DWORD PTR _dst$[ebx]
  0008b	03 04 11	 add	 eax, DWORD PTR [ecx+edx]
  0008e	89 45 d8	 mov	 DWORD PTR _Y_line$[ebp], eax

; 1117 :     char *U_line = (char *)dst[1] + dst_y_pitch_byte * y_range.start_dst;

  00091	ba 04 00 00 00	 mov	 edx, 4
  00096	c1 e2 00	 shl	 edx, 0
  00099	8b 43 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  0009c	0f af 45 f0	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  000a0	8b 4b 08	 mov	 ecx, DWORD PTR _dst$[ebx]
  000a3	03 04 11	 add	 eax, DWORD PTR [ecx+edx]
  000a6	89 45 d4	 mov	 DWORD PTR _U_line$[ebp], eax

; 1118 :     char *V_line = (char *)dst[2] + dst_y_pitch_byte * y_range.start_dst;

  000a9	ba 04 00 00 00	 mov	 edx, 4
  000ae	d1 e2		 shl	 edx, 1
  000b0	8b 43 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  000b3	0f af 45 f0	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  000b7	8b 4b 08	 mov	 ecx, DWORD PTR _dst$[ebx]
  000ba	03 04 11	 add	 eax, DWORD PTR [ecx+edx]
  000bd	89 45 d0	 mov	 DWORD PTR _V_line$[ebp], eax

; 1119 :     char *pixel = (char *)src[0] + src_y_pitch_byte * y_range.start_src;

  000c0	ba 04 00 00 00	 mov	 edx, 4
  000c5	6b c2 00	 imul	 eax, edx, 0
  000c8	8b 4b 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebx]
  000cb	0f af 4d ec	 imul	 ecx, DWORD PTR _y_range$[ebp]
  000cf	8b 53 0c	 mov	 edx, DWORD PTR _src$[ebx]
  000d2	03 0c 02	 add	 ecx, DWORD PTR [edx+eax]
  000d5	89 4d cc	 mov	 DWORD PTR _pixel$[ebp], ecx

; 1120 :     const __m256i yC_pw_one = _mm256_set1_epi16(1);

  000d8	c5 fe 6f 05 00
	00 00 00	 vmovdqu ymm0, YMMWORD PTR __ymm@0001000100010001000100010001000100010001000100010001000100010001
  000e0	c5 fe 7f 85 60
	ff ff ff	 vmovdqu YMMWORD PTR $T20[ebp], ymm0
  000e8	c5 fe 6f 85 60
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T20[ebp]
  000f0	c5 fe 7f 45 a0	 vmovdqu YMMWORD PTR _yC_pw_one$[ebp], ymm0

; 1121 :     const __m256i yC_YCC = _mm256_set1_epi32(1<<LSFT_YCC_16);

  000f5	c5 fe 6f 05 00
	00 00 00	 vmovdqu ymm0, YMMWORD PTR __ymm@0000100000001000000010000000100000001000000010000000100000001000
  000fd	c5 fe 7f 85 e0
	fe ff ff	 vmovdqu YMMWORD PTR $T19[ebp], ymm0
  00105	c5 fe 6f 85 e0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T19[ebp]
  0010d	c5 fe 7f 85 20
	ff ff ff	 vmovdqu YMMWORD PTR _yC_YCC$[ebp], ymm0

; 1122 :     __m256i y1, y2, y3;
; 1123 :     for (int y = 0; y < y_range.len; y++, pixel += src_y_pitch_byte, Y_line += dst_y_pitch_byte, U_line += dst_y_pitch_byte, V_line += dst_y_pitch_byte) {

  00115	c7 85 18 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _y$18[ebp], 0
  0011f	eb 33		 jmp	 SHORT $LN4@convert_yc
$LN2@convert_yc:
  00121	8b 85 18 fe ff
	ff		 mov	 eax, DWORD PTR _y$18[ebp]
  00127	83 c0 01	 add	 eax, 1
  0012a	89 85 18 fe ff
	ff		 mov	 DWORD PTR _y$18[ebp], eax
  00130	8b 4d cc	 mov	 ecx, DWORD PTR _pixel$[ebp]
  00133	03 4b 14	 add	 ecx, DWORD PTR _src_y_pitch_byte$[ebx]
  00136	89 4d cc	 mov	 DWORD PTR _pixel$[ebp], ecx
  00139	8b 55 d8	 mov	 edx, DWORD PTR _Y_line$[ebp]
  0013c	03 53 1c	 add	 edx, DWORD PTR _dst_y_pitch_byte$[ebx]
  0013f	89 55 d8	 mov	 DWORD PTR _Y_line$[ebp], edx
  00142	8b 45 d4	 mov	 eax, DWORD PTR _U_line$[ebp]
  00145	03 43 1c	 add	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  00148	89 45 d4	 mov	 DWORD PTR _U_line$[ebp], eax
  0014b	8b 4d d0	 mov	 ecx, DWORD PTR _V_line$[ebp]
  0014e	03 4b 1c	 add	 ecx, DWORD PTR _dst_y_pitch_byte$[ebx]
  00151	89 4d d0	 mov	 DWORD PTR _V_line$[ebp], ecx
$LN4@convert_yc:
  00154	8b 95 18 fe ff
	ff		 mov	 edx, DWORD PTR _y$18[ebp]
  0015a	3b 55 f4	 cmp	 edx, DWORD PTR _y_range$[ebp+8]
  0015d	0f 8d 30 02 00
	00		 jge	 $LN3@convert_yc

; 1124 :         short *Y = (short *)Y_line;

  00163	8b 45 d8	 mov	 eax, DWORD PTR _Y_line$[ebp]
  00166	89 85 14 fe ff
	ff		 mov	 DWORD PTR _Y$17[ebp], eax

; 1125 :         short *U = (short *)U_line;

  0016c	8b 4d d4	 mov	 ecx, DWORD PTR _U_line$[ebp]
  0016f	89 8d 10 fe ff
	ff		 mov	 DWORD PTR _U$16[ebp], ecx

; 1126 :         short *V = (short *)V_line;

  00175	8b 55 d0	 mov	 edx, DWORD PTR _V_line$[ebp]
  00178	89 95 0c fe ff
	ff		 mov	 DWORD PTR _V$15[ebp], edx

; 1127 :         short *const ycp_fin = (short *)pixel + width * 3;

  0017e	6b 43 10 03	 imul	 eax, DWORD PTR _width$[ebx], 3
  00182	8b 4d cc	 mov	 ecx, DWORD PTR _pixel$[ebp]
  00185	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00188	89 95 08 fe ff
	ff		 mov	 DWORD PTR _ycp_fin$14[ebp], edx

; 1128 :         for (short *ycp = (short *)pixel; ycp < ycp_fin; ycp += 48, Y += 16, U += 16, V += 16) {

  0018e	8b 45 cc	 mov	 eax, DWORD PTR _pixel$[ebp]
  00191	89 85 04 fe ff
	ff		 mov	 DWORD PTR _ycp$13[ebp], eax
  00197	eb 3c		 jmp	 SHORT $LN7@convert_yc
$LN5@convert_yc:
  00199	8b 8d 04 fe ff
	ff		 mov	 ecx, DWORD PTR _ycp$13[ebp]
  0019f	83 c1 60	 add	 ecx, 96			; 00000060H
  001a2	89 8d 04 fe ff
	ff		 mov	 DWORD PTR _ycp$13[ebp], ecx
  001a8	8b 95 14 fe ff
	ff		 mov	 edx, DWORD PTR _Y$17[ebp]
  001ae	83 c2 20	 add	 edx, 32			; 00000020H
  001b1	89 95 14 fe ff
	ff		 mov	 DWORD PTR _Y$17[ebp], edx
  001b7	8b 85 10 fe ff
	ff		 mov	 eax, DWORD PTR _U$16[ebp]
  001bd	83 c0 20	 add	 eax, 32			; 00000020H
  001c0	89 85 10 fe ff
	ff		 mov	 DWORD PTR _U$16[ebp], eax
  001c6	8b 8d 0c fe ff
	ff		 mov	 ecx, DWORD PTR _V$15[ebp]
  001cc	83 c1 20	 add	 ecx, 32			; 00000020H
  001cf	89 8d 0c fe ff
	ff		 mov	 DWORD PTR _V$15[ebp], ecx
$LN7@convert_yc:
  001d5	8b 95 04 fe ff
	ff		 mov	 edx, DWORD PTR _ycp$13[ebp]
  001db	3b 95 08 fe ff
	ff		 cmp	 edx, DWORD PTR _ycp_fin$14[ebp]
  001e1	0f 83 a7 01 00
	00		 jae	 $LN6@convert_yc

; 1129 :             y1 = _mm256_loadu_si256((__m256i *)(ycp +  0));

  001e7	8b 85 04 fe ff
	ff		 mov	 eax, DWORD PTR _ycp$13[ebp]
  001ed	c5 fe 6f 00	 vmovdqu ymm0, YMMWORD PTR [eax]
  001f1	c5 fe 7f 85 e0
	fd ff ff	 vmovdqu YMMWORD PTR $T12[ebp], ymm0
  001f9	c5 fe 6f 85 e0
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T12[ebp]
  00201	c5 fe 7f 85 a0
	fe ff ff	 vmovdqu YMMWORD PTR _y1$[ebp], ymm0

; 1130 :             y2 = _mm256_loadu_si256((__m256i *)(ycp + 16));

  00209	8b 8d 04 fe ff
	ff		 mov	 ecx, DWORD PTR _ycp$13[ebp]
  0020f	83 c1 20	 add	 ecx, 32			; 00000020H
  00212	c5 fe 6f 01	 vmovdqu ymm0, YMMWORD PTR [ecx]
  00216	c5 fe 7f 85 c0
	fd ff ff	 vmovdqu YMMWORD PTR $T11[ebp], ymm0
  0021e	c5 fe 6f 85 c0
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T11[ebp]
  00226	c5 fe 7f 85 60
	fe ff ff	 vmovdqu YMMWORD PTR _y2$[ebp], ymm0

; 1131 :             y3 = _mm256_loadu_si256((__m256i *)(ycp + 32));

  0022e	8b 95 04 fe ff
	ff		 mov	 edx, DWORD PTR _ycp$13[ebp]
  00234	83 c2 40	 add	 edx, 64			; 00000040H
  00237	c5 fe 6f 02	 vmovdqu ymm0, YMMWORD PTR [edx]
  0023b	c5 fe 7f 85 a0
	fd ff ff	 vmovdqu YMMWORD PTR $T10[ebp], ymm0
  00243	c5 fe 6f 85 a0
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T10[ebp]
  0024b	c5 fe 7f 85 20
	fe ff ff	 vmovdqu YMMWORD PTR _y3$[ebp], ymm0

; 1132 : 
; 1133 :             gather_y_u_v_from_yc48(y1, y2, y3);

  00253	8d 85 20 fe ff
	ff		 lea	 eax, DWORD PTR _y3$[ebp]
  00259	50		 push	 eax
  0025a	8d 8d 60 fe ff
	ff		 lea	 ecx, DWORD PTR _y2$[ebp]
  00260	51		 push	 ecx
  00261	8d 95 a0 fe ff
	ff		 lea	 edx, DWORD PTR _y1$[ebp]
  00267	52		 push	 edx
  00268	e8 00 00 00 00	 call	 ?gather_y_u_v_from_yc48@@YAXAAT__m256i@@00@Z ; gather_y_u_v_from_yc48
  0026d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1134 : 
; 1135 :             _mm256_storeu_si256((__m256i *)Y, convert_y_range_from_yc48(y1, yC_Y_L_MA_16, Y_L_RSH_16, yC_YCC, yC_pw_one));

  00270	c5 fd 6f 05 00
	00 00 00	 vmovdqa ymm0, YMMWORD PTR ?Array_Y_L_MA_16@@3QBFB
  00278	c5 fe 7f 85 80
	fd ff ff	 vmovdqu YMMWORD PTR $T9[ebp], ymm0
  00280	8d 45 a0	 lea	 eax, DWORD PTR _yC_pw_one$[ebp]
  00283	50		 push	 eax
  00284	8d 8d 20 ff ff
	ff		 lea	 ecx, DWORD PTR _yC_YCC$[ebp]
  0028a	51		 push	 ecx
  0028b	6a 04		 push	 4
  0028d	c5 fe 6f 8d 80
	fd ff ff	 vmovdqu ymm1, YMMWORD PTR $T9[ebp]
  00295	c5 fe 6f 85 a0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR _y1$[ebp]
  0029d	e8 00 00 00 00	 call	 ?convert_y_range_from_yc48@@YA?AT__m256i@@T1@0HABT1@1@Z ; convert_y_range_from_yc48
  002a2	83 c4 0c	 add	 esp, 12			; 0000000cH
  002a5	c5 fe 7f 85 60
	fd ff ff	 vmovdqu YMMWORD PTR $T8[ebp], ymm0
  002ad	c5 fe 6f 85 60
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T8[ebp]
  002b5	8b 95 14 fe ff
	ff		 mov	 edx, DWORD PTR _Y$17[ebp]
  002bb	c5 fe 7f 02	 vmovdqu YMMWORD PTR [edx], ymm0

; 1136 :             _mm256_storeu_si256((__m256i *)U, convert_uv_range_from_yc48(y2, _mm256_set1_epi16(UV_OFFSET_x1), yC_UV_L_MA_16_444, UV_L_RSH_16_444, yC_YCC, yC_pw_one));

  002bf	c5 fd 6f 05 00
	00 00 00	 vmovdqa ymm0, YMMWORD PTR ?Array_UV_L_MA_16_444@@3QBFB
  002c7	c5 fe 7f 85 20
	fd ff ff	 vmovdqu YMMWORD PTR $T6[ebp], ymm0
  002cf	c5 fe 6f 05 00
	00 00 00	 vmovdqu ymm0, YMMWORD PTR __ymm@0800080008000800080008000800080008000800080008000800080008000800
  002d7	c5 fe 7f 85 40
	fd ff ff	 vmovdqu YMMWORD PTR $T7[ebp], ymm0
  002df	8d 45 a0	 lea	 eax, DWORD PTR _yC_pw_one$[ebp]
  002e2	50		 push	 eax
  002e3	8d 8d 20 ff ff
	ff		 lea	 ecx, DWORD PTR _yC_YCC$[ebp]
  002e9	51		 push	 ecx
  002ea	6a 00		 push	 0
  002ec	8d 95 20 fd ff
	ff		 lea	 edx, DWORD PTR $T6[ebp]
  002f2	52		 push	 edx
  002f3	8d 85 40 fd ff
	ff		 lea	 eax, DWORD PTR $T7[ebp]
  002f9	50		 push	 eax
  002fa	c5 fe 6f 85 60
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR _y2$[ebp]
  00302	e8 00 00 00 00	 call	 ?convert_uv_range_from_yc48@@YA?AT__m256i@@T1@ABT1@1H11@Z ; convert_uv_range_from_yc48
  00307	83 c4 14	 add	 esp, 20			; 00000014H
  0030a	c5 fe 7f 85 00
	fd ff ff	 vmovdqu YMMWORD PTR $T5[ebp], ymm0
  00312	c5 fe 6f 85 00
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T5[ebp]
  0031a	8b 8d 10 fe ff
	ff		 mov	 ecx, DWORD PTR _U$16[ebp]
  00320	c5 fe 7f 01	 vmovdqu YMMWORD PTR [ecx], ymm0

; 1137 :             _mm256_storeu_si256((__m256i *)V, convert_uv_range_from_yc48(y3, _mm256_set1_epi16(UV_OFFSET_x1), yC_UV_L_MA_16_444, UV_L_RSH_16_444, yC_YCC, yC_pw_one));

  00324	c5 fd 6f 05 00
	00 00 00	 vmovdqa ymm0, YMMWORD PTR ?Array_UV_L_MA_16_444@@3QBFB
  0032c	c5 fe 7f 85 c0
	fc ff ff	 vmovdqu YMMWORD PTR $T3[ebp], ymm0
  00334	c5 fe 6f 05 00
	00 00 00	 vmovdqu ymm0, YMMWORD PTR __ymm@0800080008000800080008000800080008000800080008000800080008000800
  0033c	c5 fe 7f 85 e0
	fc ff ff	 vmovdqu YMMWORD PTR $T4[ebp], ymm0
  00344	8d 55 a0	 lea	 edx, DWORD PTR _yC_pw_one$[ebp]
  00347	52		 push	 edx
  00348	8d 85 20 ff ff
	ff		 lea	 eax, DWORD PTR _yC_YCC$[ebp]
  0034e	50		 push	 eax
  0034f	6a 00		 push	 0
  00351	8d 8d c0 fc ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00357	51		 push	 ecx
  00358	8d 95 e0 fc ff
	ff		 lea	 edx, DWORD PTR $T4[ebp]
  0035e	52		 push	 edx
  0035f	c5 fe 6f 85 20
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR _y3$[ebp]
  00367	e8 00 00 00 00	 call	 ?convert_uv_range_from_yc48@@YA?AT__m256i@@T1@ABT1@1H11@Z ; convert_uv_range_from_yc48
  0036c	83 c4 14	 add	 esp, 20			; 00000014H
  0036f	c5 fe 7f 85 a0
	fc ff ff	 vmovdqu YMMWORD PTR $T2[ebp], ymm0
  00377	c5 fe 6f 85 a0
	fc ff ff	 vmovdqu ymm0, YMMWORD PTR $T2[ebp]
  0037f	8b 85 0c fe ff
	ff		 mov	 eax, DWORD PTR _V$15[ebp]
  00385	c5 fe 7f 00	 vmovdqu YMMWORD PTR [eax], ymm0

; 1138 :         }

  00389	e9 0b fe ff ff	 jmp	 $LN5@convert_yc
$LN6@convert_yc:

; 1139 :     }

  0038e	e9 8e fd ff ff	 jmp	 $LN2@convert_yc
$LN3@convert_yc:

; 1140 :     _mm256_zeroupper();

  00393	c5 f8 77	 vzeroupper

; 1141 : }

  00396	52		 push	 edx
  00397	8b cd		 mov	 ecx, ebp
  00399	50		 push	 eax
  0039a	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN16@convert_yc
  003a0	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  003a5	58		 pop	 eax
  003a6	5a		 pop	 edx
  003a7	5f		 pop	 edi
  003a8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003ab	33 cd		 xor	 ecx, ebp
  003ad	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003b2	8b e5		 mov	 esp, ebp
  003b4	5d		 pop	 ebp
  003b5	8b e3		 mov	 esp, ebx
  003b7	5b		 pop	 ebx
  003b8	c3		 ret	 0
  003b9	0f 1f 00	 npad	 3
$LN16@convert_yc:
  003bc	06 00 00 00	 DD	 6
  003c0	00 00 00 00	 DD	 $LN15@convert_yc
$LN15@convert_yc:
  003c4	ec ff ff ff	 DD	 -20			; ffffffecH
  003c8	0c 00 00 00	 DD	 12			; 0000000cH
  003cc	00 00 00 00	 DD	 $LN9@convert_yc
  003d0	a0 ff ff ff	 DD	 -96			; ffffffa0H
  003d4	20 00 00 00	 DD	 32			; 00000020H
  003d8	00 00 00 00	 DD	 $LN10@convert_yc
  003dc	20 ff ff ff	 DD	 -224			; ffffff20H
  003e0	20 00 00 00	 DD	 32			; 00000020H
  003e4	00 00 00 00	 DD	 $LN11@convert_yc
  003e8	a0 fe ff ff	 DD	 -352			; fffffea0H
  003ec	20 00 00 00	 DD	 32			; 00000020H
  003f0	00 00 00 00	 DD	 $LN12@convert_yc
  003f4	60 fe ff ff	 DD	 -416			; fffffe60H
  003f8	20 00 00 00	 DD	 32			; 00000020H
  003fc	00 00 00 00	 DD	 $LN13@convert_yc
  00400	20 fe ff ff	 DD	 -480			; fffffe20H
  00404	20 00 00 00	 DD	 32			; 00000020H
  00408	00 00 00 00	 DD	 $LN14@convert_yc
$LN14@convert_yc:
  0040c	79		 DB	 121			; 00000079H
  0040d	33		 DB	 51			; 00000033H
  0040e	00		 DB	 0
$LN13@convert_yc:
  0040f	79		 DB	 121			; 00000079H
  00410	32		 DB	 50			; 00000032H
  00411	00		 DB	 0
$LN12@convert_yc:
  00412	79		 DB	 121			; 00000079H
  00413	31		 DB	 49			; 00000031H
  00414	00		 DB	 0
$LN11@convert_yc:
  00415	79		 DB	 121			; 00000079H
  00416	43		 DB	 67			; 00000043H
  00417	5f		 DB	 95			; 0000005fH
  00418	59		 DB	 89			; 00000059H
  00419	43		 DB	 67			; 00000043H
  0041a	43		 DB	 67			; 00000043H
  0041b	00		 DB	 0
$LN10@convert_yc:
  0041c	79		 DB	 121			; 00000079H
  0041d	43		 DB	 67			; 00000043H
  0041e	5f		 DB	 95			; 0000005fH
  0041f	70		 DB	 112			; 00000070H
  00420	77		 DB	 119			; 00000077H
  00421	5f		 DB	 95			; 0000005fH
  00422	6f		 DB	 111			; 0000006fH
  00423	6e		 DB	 110			; 0000006eH
  00424	65		 DB	 101			; 00000065H
  00425	00		 DB	 0
$LN9@convert_yc:
  00426	79		 DB	 121			; 00000079H
  00427	5f		 DB	 95			; 0000005fH
  00428	72		 DB	 114			; 00000072H
  00429	61		 DB	 97			; 00000061H
  0042a	6e		 DB	 110			; 0000006eH
  0042b	67		 DB	 103			; 00000067H
  0042c	65		 DB	 101			; 00000065H
  0042d	00		 DB	 0
?convert_yc48_to_yuv444_16bit_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yc48_to_yuv444_16bit_avx2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
$T1 = -1040						; size = 12
$T2 = -1024						; size = 32
$T3 = -992						; size = 32
$T4 = -960						; size = 32
$T5 = -928						; size = 32
$T6 = -896						; size = 32
$T7 = -864						; size = 32
$T8 = -832						; size = 32
$T9 = -800						; size = 32
$T10 = -768						; size = 32
$T11 = -736						; size = 32
$T12 = -704						; size = 32
$T13 = -672						; size = 32
$T14 = -640						; size = 32
$T15 = -608						; size = 32
_y3$ = -576						; size = 32
_y2$ = -512						; size = 32
_y1$ = -448						; size = 32
_y0$ = -384						; size = 32
$T16 = -324						; size = 12
_y_range$ = -308					; size = 12
_dst_y_pitch$ = -292					; size = 4
$T17 = -288						; size = 32
_yC_YCC$ = -224						; size = 32
$T18 = -160						; size = 32
_yC_pw_one$ = -96					; size = 32
_C$ = -44						; size = 4
_Y$ = -40						; size = 4
_ycpw$ = -36						; size = 4
_ycp$ = -32						; size = 4
_pixel$ = -28						; size = 4
_dst_C$ = -24						; size = 4
_dst_Y$ = -20						; size = 4
_i$ = -16						; size = 4
_y$ = -12						; size = 4
_x$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yc48_to_p010_i_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yc48_to_p010_i_avx2

; 1071 : void convert_yc48_to_p010_i_avx2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 20 04 00
	00		 sub	 esp, 1056		; 00000420H
  0001c	57		 push	 edi
  0001d	8d bd e0 fb ff
	ff		 lea	 edi, DWORD PTR [ebp-1056]
  00023	b9 08 01 00 00	 mov	 ecx, 264		; 00000108H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1072 :     int x, y, i;
; 1073 :     short *dst_Y = (short *)dst[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 08	 mov	 edx, DWORD PTR _dst$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 ec	 mov	 DWORD PTR _dst_Y$[ebp], eax

; 1074 :     short *dst_C = (short *)dst[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 08	 mov	 edx, DWORD PTR _dst$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 e8	 mov	 DWORD PTR _dst_C$[ebp], eax

; 1075 :     const void  *pixel = src[0];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	6b d1 00	 imul	 edx, ecx, 0
  00063	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  00066	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00069	89 4d e4	 mov	 DWORD PTR _pixel$[ebp], ecx

; 1076 :     const short *ycp, *ycpw;
; 1077 :     short *Y = NULL, *C = NULL;

  0006c	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _Y$[ebp], 0
  00073	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _C$[ebp], 0

; 1078 :     const __m256i yC_pw_one = _mm256_set1_epi16(1);

  0007a	c5 fe 6f 05 00
	00 00 00	 vmovdqu ymm0, YMMWORD PTR __ymm@0001000100010001000100010001000100010001000100010001000100010001
  00082	c5 fe 7f 85 60
	ff ff ff	 vmovdqu YMMWORD PTR $T18[ebp], ymm0
  0008a	c5 fe 6f 85 60
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T18[ebp]
  00092	c5 fe 7f 45 a0	 vmovdqu YMMWORD PTR _yC_pw_one$[ebp], ymm0

; 1079 :     const __m256i yC_YCC = _mm256_set1_epi32(1<<LSFT_YCC_16);

  00097	c5 fe 6f 05 00
	00 00 00	 vmovdqu ymm0, YMMWORD PTR __ymm@0000100000001000000010000000100000001000000010000000100000001000
  0009f	c5 fe 7f 85 e0
	fe ff ff	 vmovdqu YMMWORD PTR $T17[ebp], ymm0
  000a7	c5 fe 6f 85 e0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T17[ebp]
  000af	c5 fe 7f 85 20
	ff ff ff	 vmovdqu YMMWORD PTR _yC_YCC$[ebp], ymm0

; 1080 :     const int dst_y_pitch = dst_y_pitch_byte >> 1;

  000b7	8b 53 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebx]
  000ba	d1 fa		 sar	 edx, 1
  000bc	89 95 dc fe ff
	ff		 mov	 DWORD PTR _dst_y_pitch$[ebp], edx

; 1081 :     const auto y_range = thread_y_range(0, height, thread_id, thread_n);

  000c2	8b 43 2c	 mov	 eax, DWORD PTR _thread_n$[ebx]
  000c5	50		 push	 eax
  000c6	8b 4b 28	 mov	 ecx, DWORD PTR _thread_id$[ebx]
  000c9	51		 push	 ecx
  000ca	8b 53 20	 mov	 edx, DWORD PTR _height$[ebx]
  000cd	52		 push	 edx
  000ce	6a 00		 push	 0
  000d0	8d 85 f0 fb ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  000d6	50		 push	 eax
  000d7	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  000dc	83 c4 14	 add	 esp, 20			; 00000014H
  000df	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e1	89 8d bc fe ff
	ff		 mov	 DWORD PTR $T16[ebp], ecx
  000e7	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000ea	89 95 c0 fe ff
	ff		 mov	 DWORD PTR $T16[ebp+4], edx
  000f0	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000f3	89 85 c4 fe ff
	ff		 mov	 DWORD PTR $T16[ebp+8], eax
  000f9	8b 8d bc fe ff
	ff		 mov	 ecx, DWORD PTR $T16[ebp]
  000ff	89 8d cc fe ff
	ff		 mov	 DWORD PTR _y_range$[ebp], ecx
  00105	8b 95 c0 fe ff
	ff		 mov	 edx, DWORD PTR $T16[ebp+4]
  0010b	89 95 d0 fe ff
	ff		 mov	 DWORD PTR _y_range$[ebp+4], edx
  00111	8b 85 c4 fe ff
	ff		 mov	 eax, DWORD PTR $T16[ebp+8]
  00117	89 85 d4 fe ff
	ff		 mov	 DWORD PTR _y_range$[ebp+8], eax

; 1082 :     __m256i y0, y1, y2, y3;
; 1083 :     for (y = y_range.start_src; y < (y_range.start_src + y_range.len); y += 4) {

  0011d	8b 8d cc fe ff
	ff		 mov	 ecx, DWORD PTR _y_range$[ebp]
  00123	89 4d f4	 mov	 DWORD PTR _y$[ebp], ecx
  00126	eb 09		 jmp	 SHORT $LN4@convert_yc
$LN2@convert_yc:
  00128	8b 55 f4	 mov	 edx, DWORD PTR _y$[ebp]
  0012b	83 c2 04	 add	 edx, 4
  0012e	89 55 f4	 mov	 DWORD PTR _y$[ebp], edx
$LN4@convert_yc:
  00131	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR _y_range$[ebp]
  00137	03 85 d4 fe ff
	ff		 add	 eax, DWORD PTR _y_range$[ebp+8]
  0013d	39 45 f4	 cmp	 DWORD PTR _y$[ebp], eax
  00140	0f 8d 0d 03 00
	00		 jge	 $LN3@convert_yc

; 1084 :         for (i = 0; i < 2; i++) {

  00146	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0014d	eb 09		 jmp	 SHORT $LN7@convert_yc
$LN5@convert_yc:
  0014f	8b 4d f0	 mov	 ecx, DWORD PTR _i$[ebp]
  00152	83 c1 01	 add	 ecx, 1
  00155	89 4d f0	 mov	 DWORD PTR _i$[ebp], ecx
$LN7@convert_yc:
  00158	83 7d f0 02	 cmp	 DWORD PTR _i$[ebp], 2
  0015c	0f 8d ec 02 00
	00		 jge	 $LN6@convert_yc

; 1085 :             ycp = (short*)pixel + width * (y + i) * 3;

  00162	8b 55 f4	 mov	 edx, DWORD PTR _y$[ebp]
  00165	03 55 f0	 add	 edx, DWORD PTR _i$[ebp]
  00168	0f af 53 10	 imul	 edx, DWORD PTR _width$[ebx]
  0016c	6b c2 03	 imul	 eax, edx, 3
  0016f	8b 4d e4	 mov	 ecx, DWORD PTR _pixel$[ebp]
  00172	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00175	89 55 e0	 mov	 DWORD PTR _ycp$[ebp], edx

; 1086 :             ycpw= ycp + width*2*3;

  00178	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  0017b	d1 e0		 shl	 eax, 1
  0017d	6b c8 03	 imul	 ecx, eax, 3
  00180	8b 55 e0	 mov	 edx, DWORD PTR _ycp$[ebp]
  00183	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  00186	89 45 dc	 mov	 DWORD PTR _ycpw$[ebp], eax

; 1087 :             Y   = (short*)dst_Y + dst_y_pitch * (y + i);

  00189	8b 4d f4	 mov	 ecx, DWORD PTR _y$[ebp]
  0018c	03 4d f0	 add	 ecx, DWORD PTR _i$[ebp]
  0018f	0f af 8d dc fe
	ff ff		 imul	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  00196	8b 55 ec	 mov	 edx, DWORD PTR _dst_Y$[ebp]
  00199	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  0019c	89 45 d8	 mov	 DWORD PTR _Y$[ebp], eax

; 1088 :             C   = (short*)dst_C + dst_y_pitch * (y + i*2) / 2;

  0019f	8b 4d f0	 mov	 ecx, DWORD PTR _i$[ebp]
  001a2	8b 55 f4	 mov	 edx, DWORD PTR _y$[ebp]
  001a5	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  001a8	0f af 85 dc fe
	ff ff		 imul	 eax, DWORD PTR _dst_y_pitch$[ebp]
  001af	99		 cdq
  001b0	2b c2		 sub	 eax, edx
  001b2	d1 f8		 sar	 eax, 1
  001b4	8b 4d e8	 mov	 ecx, DWORD PTR _dst_C$[ebp]
  001b7	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  001ba	89 55 d4	 mov	 DWORD PTR _C$[ebp], edx

; 1089 :             for (x = 0; x < width; x += 16, ycp += 48, ycpw += 48) {

  001bd	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _x$[ebp], 0
  001c4	eb 1b		 jmp	 SHORT $LN10@convert_yc
$LN8@convert_yc:
  001c6	8b 45 f8	 mov	 eax, DWORD PTR _x$[ebp]
  001c9	83 c0 10	 add	 eax, 16			; 00000010H
  001cc	89 45 f8	 mov	 DWORD PTR _x$[ebp], eax
  001cf	8b 4d e0	 mov	 ecx, DWORD PTR _ycp$[ebp]
  001d2	83 c1 60	 add	 ecx, 96			; 00000060H
  001d5	89 4d e0	 mov	 DWORD PTR _ycp$[ebp], ecx
  001d8	8b 55 dc	 mov	 edx, DWORD PTR _ycpw$[ebp]
  001db	83 c2 60	 add	 edx, 96			; 00000060H
  001de	89 55 dc	 mov	 DWORD PTR _ycpw$[ebp], edx
$LN10@convert_yc:
  001e1	8b 45 f8	 mov	 eax, DWORD PTR _x$[ebp]
  001e4	3b 43 10	 cmp	 eax, DWORD PTR _width$[ebx]
  001e7	0f 8d 5c 02 00
	00		 jge	 $LN9@convert_yc

; 1090 :                 y1 = _mm256_loadu_si256((__m256i *)(ycp +  0)); // 128, 0

  001ed	8b 4d e0	 mov	 ecx, DWORD PTR _ycp$[ebp]
  001f0	c5 fe 6f 01	 vmovdqu ymm0, YMMWORD PTR [ecx]
  001f4	c5 fe 7f 85 a0
	fd ff ff	 vmovdqu YMMWORD PTR $T15[ebp], ymm0
  001fc	c5 fe 6f 85 a0
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T15[ebp]
  00204	c5 fe 7f 85 40
	fe ff ff	 vmovdqu YMMWORD PTR _y1$[ebp], ymm0

; 1091 :                 y2 = _mm256_loadu_si256((__m256i *)(ycp + 16)); // 384, 256

  0020c	8b 55 e0	 mov	 edx, DWORD PTR _ycp$[ebp]
  0020f	83 c2 20	 add	 edx, 32			; 00000020H
  00212	c5 fe 6f 02	 vmovdqu ymm0, YMMWORD PTR [edx]
  00216	c5 fe 7f 85 80
	fd ff ff	 vmovdqu YMMWORD PTR $T14[ebp], ymm0
  0021e	c5 fe 6f 85 80
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T14[ebp]
  00226	c5 fe 7f 85 00
	fe ff ff	 vmovdqu YMMWORD PTR _y2$[ebp], ymm0

; 1092 :                 y3 = _mm256_loadu_si256((__m256i *)(ycp + 32)); // 640, 512

  0022e	8b 45 e0	 mov	 eax, DWORD PTR _ycp$[ebp]
  00231	83 c0 40	 add	 eax, 64			; 00000040H
  00234	c5 fe 6f 00	 vmovdqu ymm0, YMMWORD PTR [eax]
  00238	c5 fe 7f 85 60
	fd ff ff	 vmovdqu YMMWORD PTR $T13[ebp], ymm0
  00240	c5 fe 6f 85 60
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T13[ebp]
  00248	c5 fe 7f 85 c0
	fd ff ff	 vmovdqu YMMWORD PTR _y3$[ebp], ymm0

; 1093 : 
; 1094 :                 gather_y_uv_from_yc48(y1, y2, y3);

  00250	c5 fe 6f 85 c0
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR _y3$[ebp]
  00258	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR _y2$[ebp]
  0025e	51		 push	 ecx
  0025f	8d 95 40 fe ff
	ff		 lea	 edx, DWORD PTR _y1$[ebp]
  00265	52		 push	 edx
  00266	e8 00 00 00 00	 call	 ?gather_y_uv_from_yc48@@YAXAAT__m256i@@0T1@@Z ; gather_y_uv_from_yc48
  0026b	83 c4 08	 add	 esp, 8

; 1095 :                 y0 = y2;

  0026e	c5 fe 6f 85 00
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR _y2$[ebp]
  00276	c5 fe 7f 85 80
	fe ff ff	 vmovdqu YMMWORD PTR _y0$[ebp], ymm0

; 1096 : 
; 1097 :                 _mm256_storeu_si256((__m256i *)(Y + x), convert_y_range_from_yc48(y1, yC_Y_L_MA_16, Y_L_RSH_16, yC_YCC, yC_pw_one));

  0027e	c5 fd 6f 05 00
	00 00 00	 vmovdqa ymm0, YMMWORD PTR ?Array_Y_L_MA_16@@3QBFB
  00286	c5 fe 7f 85 40
	fd ff ff	 vmovdqu YMMWORD PTR $T12[ebp], ymm0
  0028e	8d 45 a0	 lea	 eax, DWORD PTR _yC_pw_one$[ebp]
  00291	50		 push	 eax
  00292	8d 8d 20 ff ff
	ff		 lea	 ecx, DWORD PTR _yC_YCC$[ebp]
  00298	51		 push	 ecx
  00299	6a 04		 push	 4
  0029b	c5 fe 6f 8d 40
	fd ff ff	 vmovdqu ymm1, YMMWORD PTR $T12[ebp]
  002a3	c5 fe 6f 85 40
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR _y1$[ebp]
  002ab	e8 00 00 00 00	 call	 ?convert_y_range_from_yc48@@YA?AT__m256i@@T1@0HABT1@1@Z ; convert_y_range_from_yc48
  002b0	83 c4 0c	 add	 esp, 12			; 0000000cH
  002b3	c5 fe 7f 85 20
	fd ff ff	 vmovdqu YMMWORD PTR $T11[ebp], ymm0
  002bb	c5 fe 6f 85 20
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T11[ebp]
  002c3	8b 55 f8	 mov	 edx, DWORD PTR _x$[ebp]
  002c6	8b 45 d8	 mov	 eax, DWORD PTR _Y$[ebp]
  002c9	c5 fe 7f 04 50	 vmovdqu YMMWORD PTR [eax+edx*2], ymm0

; 1098 : 
; 1099 :                 y1 = _mm256_loadu_si256((__m256i *)(ycpw +  0));

  002ce	8b 4d dc	 mov	 ecx, DWORD PTR _ycpw$[ebp]
  002d1	c5 fe 6f 01	 vmovdqu ymm0, YMMWORD PTR [ecx]
  002d5	c5 fe 7f 85 00
	fd ff ff	 vmovdqu YMMWORD PTR $T10[ebp], ymm0
  002dd	c5 fe 6f 85 00
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T10[ebp]
  002e5	c5 fe 7f 85 40
	fe ff ff	 vmovdqu YMMWORD PTR _y1$[ebp], ymm0

; 1100 :                 y2 = _mm256_loadu_si256((__m256i *)(ycpw + 16));

  002ed	8b 55 dc	 mov	 edx, DWORD PTR _ycpw$[ebp]
  002f0	83 c2 20	 add	 edx, 32			; 00000020H
  002f3	c5 fe 6f 02	 vmovdqu ymm0, YMMWORD PTR [edx]
  002f7	c5 fe 7f 85 e0
	fc ff ff	 vmovdqu YMMWORD PTR $T9[ebp], ymm0
  002ff	c5 fe 6f 85 e0
	fc ff ff	 vmovdqu ymm0, YMMWORD PTR $T9[ebp]
  00307	c5 fe 7f 85 00
	fe ff ff	 vmovdqu YMMWORD PTR _y2$[ebp], ymm0

; 1101 :                 y3 = _mm256_loadu_si256((__m256i *)(ycpw + 32));

  0030f	8b 45 dc	 mov	 eax, DWORD PTR _ycpw$[ebp]
  00312	83 c0 40	 add	 eax, 64			; 00000040H
  00315	c5 fe 6f 00	 vmovdqu ymm0, YMMWORD PTR [eax]
  00319	c5 fe 7f 85 c0
	fc ff ff	 vmovdqu YMMWORD PTR $T8[ebp], ymm0
  00321	c5 fe 6f 85 c0
	fc ff ff	 vmovdqu ymm0, YMMWORD PTR $T8[ebp]
  00329	c5 fe 7f 85 c0
	fd ff ff	 vmovdqu YMMWORD PTR _y3$[ebp], ymm0

; 1102 : 
; 1103 :                 gather_y_uv_from_yc48(y1, y2, y3);

  00331	c5 fe 6f 85 c0
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR _y3$[ebp]
  00339	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR _y2$[ebp]
  0033f	51		 push	 ecx
  00340	8d 95 40 fe ff
	ff		 lea	 edx, DWORD PTR _y1$[ebp]
  00346	52		 push	 edx
  00347	e8 00 00 00 00	 call	 ?gather_y_uv_from_yc48@@YAXAAT__m256i@@0T1@@Z ; gather_y_uv_from_yc48
  0034c	83 c4 08	 add	 esp, 8

; 1104 : 
; 1105 :                 _mm256_storeu_si256((__m256i *)(Y + x + dst_y_pitch*2), convert_y_range_from_yc48(y1, yC_Y_L_MA_16, Y_L_RSH_16, yC_YCC, yC_pw_one));

  0034f	c5 fd 6f 05 00
	00 00 00	 vmovdqa ymm0, YMMWORD PTR ?Array_Y_L_MA_16@@3QBFB
  00357	c5 fe 7f 85 a0
	fc ff ff	 vmovdqu YMMWORD PTR $T7[ebp], ymm0
  0035f	8d 45 a0	 lea	 eax, DWORD PTR _yC_pw_one$[ebp]
  00362	50		 push	 eax
  00363	8d 8d 20 ff ff
	ff		 lea	 ecx, DWORD PTR _yC_YCC$[ebp]
  00369	51		 push	 ecx
  0036a	6a 04		 push	 4
  0036c	c5 fe 6f 8d a0
	fc ff ff	 vmovdqu ymm1, YMMWORD PTR $T7[ebp]
  00374	c5 fe 6f 85 40
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR _y1$[ebp]
  0037c	e8 00 00 00 00	 call	 ?convert_y_range_from_yc48@@YA?AT__m256i@@T1@0HABT1@1@Z ; convert_y_range_from_yc48
  00381	83 c4 0c	 add	 esp, 12			; 0000000cH
  00384	c5 fe 7f 85 80
	fc ff ff	 vmovdqu YMMWORD PTR $T6[ebp], ymm0
  0038c	c5 fe 6f 85 80
	fc ff ff	 vmovdqu ymm0, YMMWORD PTR $T6[ebp]
  00394	8b 55 f8	 mov	 edx, DWORD PTR _x$[ebp]
  00397	8b 45 d8	 mov	 eax, DWORD PTR _Y$[ebp]
  0039a	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  0039d	8b 95 dc fe ff
	ff		 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  003a3	d1 e2		 shl	 edx, 1
  003a5	c5 fe 7f 04 51	 vmovdqu YMMWORD PTR [ecx+edx*2], ymm0

; 1106 : 
; 1107 :                 _mm256_storeu_si256((__m256i *)(C + x), convert_uv_range_from_yc48_420i(y0, y2, _mm256_set1_epi16(UV_OFFSET_x1), yC_UV_L_MA_16_420I(i), yC_UV_L_MA_16_420I((i+1)&0x01), UV_L_RSH_16_420I, yC_YCC, yC_pw_one));

  003aa	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  003ad	83 c0 01	 add	 eax, 1
  003b0	83 e0 01	 and	 eax, 1
  003b3	c1 e0 05	 shl	 eax, 5
  003b6	05 00 00 00 00	 add	 eax, OFFSET ?Array_UV_L_MA_16_420I@@3QAY0BA@$$CBFA
  003bb	c5 fe 6f 00	 vmovdqu ymm0, YMMWORD PTR [eax]
  003bf	c5 fe 7f 85 20
	fc ff ff	 vmovdqu YMMWORD PTR $T3[ebp], ymm0
  003c7	8b 4d f0	 mov	 ecx, DWORD PTR _i$[ebp]
  003ca	c1 e1 05	 shl	 ecx, 5
  003cd	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?Array_UV_L_MA_16_420I@@3QAY0BA@$$CBFA
  003d3	c5 fe 6f 01	 vmovdqu ymm0, YMMWORD PTR [ecx]
  003d7	c5 fe 7f 85 40
	fc ff ff	 vmovdqu YMMWORD PTR $T4[ebp], ymm0
  003df	c5 fe 6f 05 00
	00 00 00	 vmovdqu ymm0, YMMWORD PTR __ymm@0800080008000800080008000800080008000800080008000800080008000800
  003e7	c5 fe 7f 85 60
	fc ff ff	 vmovdqu YMMWORD PTR $T5[ebp], ymm0
  003ef	8d 55 a0	 lea	 edx, DWORD PTR _yC_pw_one$[ebp]
  003f2	52		 push	 edx
  003f3	8d 85 20 ff ff
	ff		 lea	 eax, DWORD PTR _yC_YCC$[ebp]
  003f9	50		 push	 eax
  003fa	6a 02		 push	 2
  003fc	8d 8d 20 fc ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00402	51		 push	 ecx
  00403	8d 95 40 fc ff
	ff		 lea	 edx, DWORD PTR $T4[ebp]
  00409	52		 push	 edx
  0040a	8d 85 60 fc ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  00410	50		 push	 eax
  00411	c5 fe 6f 8d 00
	fe ff ff	 vmovdqu ymm1, YMMWORD PTR _y2$[ebp]
  00419	c5 fe 6f 85 80
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR _y0$[ebp]
  00421	e8 00 00 00 00	 call	 ?convert_uv_range_from_yc48_420i@@YA?AT__m256i@@T1@0ABT1@11H11@Z ; convert_uv_range_from_yc48_420i
  00426	83 c4 18	 add	 esp, 24			; 00000018H
  00429	c5 fe 7f 85 00
	fc ff ff	 vmovdqu YMMWORD PTR $T2[ebp], ymm0
  00431	c5 fe 6f 85 00
	fc ff ff	 vmovdqu ymm0, YMMWORD PTR $T2[ebp]
  00439	8b 4d f8	 mov	 ecx, DWORD PTR _x$[ebp]
  0043c	8b 55 d4	 mov	 edx, DWORD PTR _C$[ebp]
  0043f	c5 fe 7f 04 4a	 vmovdqu YMMWORD PTR [edx+ecx*2], ymm0

; 1108 :             }

  00444	e9 7d fd ff ff	 jmp	 $LN8@convert_yc
$LN9@convert_yc:

; 1109 :         }

  00449	e9 01 fd ff ff	 jmp	 $LN5@convert_yc
$LN6@convert_yc:

; 1110 :     }

  0044e	e9 d5 fc ff ff	 jmp	 $LN2@convert_yc
$LN3@convert_yc:

; 1111 :     _mm256_zeroupper();

  00453	c5 f8 77	 vzeroupper

; 1112 : }

  00456	52		 push	 edx
  00457	8b cd		 mov	 ecx, ebp
  00459	50		 push	 eax
  0045a	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN18@convert_yc
  00460	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00465	58		 pop	 eax
  00466	5a		 pop	 edx
  00467	5f		 pop	 edi
  00468	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0046b	33 cd		 xor	 ecx, ebp
  0046d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00472	8b e5		 mov	 esp, ebp
  00474	5d		 pop	 ebp
  00475	8b e3		 mov	 esp, ebx
  00477	5b		 pop	 ebx
  00478	c3		 ret	 0
  00479	0f 1f 00	 npad	 3
$LN18@convert_yc:
  0047c	05 00 00 00	 DD	 5
  00480	00 00 00 00	 DD	 $LN17@convert_yc
$LN17@convert_yc:
  00484	a0 ff ff ff	 DD	 -96			; ffffffa0H
  00488	20 00 00 00	 DD	 32			; 00000020H
  0048c	00 00 00 00	 DD	 $LN12@convert_yc
  00490	20 ff ff ff	 DD	 -224			; ffffff20H
  00494	20 00 00 00	 DD	 32			; 00000020H
  00498	00 00 00 00	 DD	 $LN13@convert_yc
  0049c	cc fe ff ff	 DD	 -308			; fffffeccH
  004a0	0c 00 00 00	 DD	 12			; 0000000cH
  004a4	00 00 00 00	 DD	 $LN14@convert_yc
  004a8	40 fe ff ff	 DD	 -448			; fffffe40H
  004ac	20 00 00 00	 DD	 32			; 00000020H
  004b0	00 00 00 00	 DD	 $LN15@convert_yc
  004b4	00 fe ff ff	 DD	 -512			; fffffe00H
  004b8	20 00 00 00	 DD	 32			; 00000020H
  004bc	00 00 00 00	 DD	 $LN16@convert_yc
$LN16@convert_yc:
  004c0	79		 DB	 121			; 00000079H
  004c1	32		 DB	 50			; 00000032H
  004c2	00		 DB	 0
$LN15@convert_yc:
  004c3	79		 DB	 121			; 00000079H
  004c4	31		 DB	 49			; 00000031H
  004c5	00		 DB	 0
$LN14@convert_yc:
  004c6	79		 DB	 121			; 00000079H
  004c7	5f		 DB	 95			; 0000005fH
  004c8	72		 DB	 114			; 00000072H
  004c9	61		 DB	 97			; 00000061H
  004ca	6e		 DB	 110			; 0000006eH
  004cb	67		 DB	 103			; 00000067H
  004cc	65		 DB	 101			; 00000065H
  004cd	00		 DB	 0
$LN13@convert_yc:
  004ce	79		 DB	 121			; 00000079H
  004cf	43		 DB	 67			; 00000043H
  004d0	5f		 DB	 95			; 0000005fH
  004d1	59		 DB	 89			; 00000059H
  004d2	43		 DB	 67			; 00000043H
  004d3	43		 DB	 67			; 00000043H
  004d4	00		 DB	 0
$LN12@convert_yc:
  004d5	79		 DB	 121			; 00000079H
  004d6	43		 DB	 67			; 00000043H
  004d7	5f		 DB	 95			; 0000005fH
  004d8	70		 DB	 112			; 00000070H
  004d9	77		 DB	 119			; 00000077H
  004da	5f		 DB	 95			; 0000005fH
  004db	6f		 DB	 111			; 0000006fH
  004dc	6e		 DB	 110			; 0000006eH
  004dd	65		 DB	 101			; 00000065H
  004de	00		 DB	 0
?convert_yc48_to_p010_i_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yc48_to_p010_i_avx2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
$T1 = -1008						; size = 12
$T2 = -992						; size = 32
$T3 = -960						; size = 32
$T4 = -928						; size = 32
$T5 = -896						; size = 32
$T6 = -864						; size = 32
$T7 = -832						; size = 32
$T8 = -800						; size = 32
$T9 = -768						; size = 32
$T10 = -736						; size = 32
$T11 = -704						; size = 32
$T12 = -672						; size = 32
$T13 = -640						; size = 32
$T14 = -608						; size = 32
_y3$ = -576						; size = 32
_y2$ = -512						; size = 32
_y1$ = -448						; size = 32
_y0$ = -384						; size = 32
$T15 = -324						; size = 12
_y_range$ = -308					; size = 12
_dst_y_pitch$ = -292					; size = 4
$T16 = -288						; size = 32
_yC_YCC$ = -224						; size = 32
$T17 = -160						; size = 32
_yC_pw_one$ = -96					; size = 32
_C$ = -40						; size = 4
_Y$ = -36						; size = 4
_ycpw$ = -32						; size = 4
_ycp$ = -28						; size = 4
_pixel$ = -24						; size = 4
_dst_C$ = -20						; size = 4
_dst_Y$ = -16						; size = 4
_y$ = -12						; size = 4
_x$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yc48_to_p010_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yc48_to_p010_avx2

; 1030 : void convert_yc48_to_p010_avx2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 00 04 00
	00		 sub	 esp, 1024		; 00000400H
  0001c	57		 push	 edi
  0001d	8d bd 00 fc ff
	ff		 lea	 edi, DWORD PTR [ebp-1024]
  00023	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1031 :     int x, y;
; 1032 :     short *dst_Y = (short *)dst[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 08	 mov	 edx, DWORD PTR _dst$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f0	 mov	 DWORD PTR _dst_Y$[ebp], eax

; 1033 :     short *dst_C = (short *)dst[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 08	 mov	 edx, DWORD PTR _dst$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 ec	 mov	 DWORD PTR _dst_C$[ebp], eax

; 1034 :     const void  *pixel = src[0];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	6b d1 00	 imul	 edx, ecx, 0
  00063	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  00066	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00069	89 4d e8	 mov	 DWORD PTR _pixel$[ebp], ecx

; 1035 :     const short *ycp, *ycpw;
; 1036 :     short *Y = NULL, *C = NULL;

  0006c	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _Y$[ebp], 0
  00073	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _C$[ebp], 0

; 1037 :     const __m256i yC_pw_one = _mm256_set1_epi16(1);

  0007a	c5 fe 6f 05 00
	00 00 00	 vmovdqu ymm0, YMMWORD PTR __ymm@0001000100010001000100010001000100010001000100010001000100010001
  00082	c5 fe 7f 85 60
	ff ff ff	 vmovdqu YMMWORD PTR $T17[ebp], ymm0
  0008a	c5 fe 6f 85 60
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T17[ebp]
  00092	c5 fe 7f 45 a0	 vmovdqu YMMWORD PTR _yC_pw_one$[ebp], ymm0

; 1038 :     const __m256i yC_YCC = _mm256_set1_epi32(1<<LSFT_YCC_16);

  00097	c5 fe 6f 05 00
	00 00 00	 vmovdqu ymm0, YMMWORD PTR __ymm@0000100000001000000010000000100000001000000010000000100000001000
  0009f	c5 fe 7f 85 e0
	fe ff ff	 vmovdqu YMMWORD PTR $T16[ebp], ymm0
  000a7	c5 fe 6f 85 e0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T16[ebp]
  000af	c5 fe 7f 85 20
	ff ff ff	 vmovdqu YMMWORD PTR _yC_YCC$[ebp], ymm0

; 1039 :     const int dst_y_pitch = dst_y_pitch_byte >> 1;

  000b7	8b 53 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebx]
  000ba	d1 fa		 sar	 edx, 1
  000bc	89 95 dc fe ff
	ff		 mov	 DWORD PTR _dst_y_pitch$[ebp], edx

; 1040 :     const auto y_range = thread_y_range(0, height, thread_id, thread_n);

  000c2	8b 43 2c	 mov	 eax, DWORD PTR _thread_n$[ebx]
  000c5	50		 push	 eax
  000c6	8b 4b 28	 mov	 ecx, DWORD PTR _thread_id$[ebx]
  000c9	51		 push	 ecx
  000ca	8b 53 20	 mov	 edx, DWORD PTR _height$[ebx]
  000cd	52		 push	 edx
  000ce	6a 00		 push	 0
  000d0	8d 85 10 fc ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  000d6	50		 push	 eax
  000d7	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  000dc	83 c4 14	 add	 esp, 20			; 00000014H
  000df	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e1	89 8d bc fe ff
	ff		 mov	 DWORD PTR $T15[ebp], ecx
  000e7	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000ea	89 95 c0 fe ff
	ff		 mov	 DWORD PTR $T15[ebp+4], edx
  000f0	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000f3	89 85 c4 fe ff
	ff		 mov	 DWORD PTR $T15[ebp+8], eax
  000f9	8b 8d bc fe ff
	ff		 mov	 ecx, DWORD PTR $T15[ebp]
  000ff	89 8d cc fe ff
	ff		 mov	 DWORD PTR _y_range$[ebp], ecx
  00105	8b 95 c0 fe ff
	ff		 mov	 edx, DWORD PTR $T15[ebp+4]
  0010b	89 95 d0 fe ff
	ff		 mov	 DWORD PTR _y_range$[ebp+4], edx
  00111	8b 85 c4 fe ff
	ff		 mov	 eax, DWORD PTR $T15[ebp+8]
  00117	89 85 d4 fe ff
	ff		 mov	 DWORD PTR _y_range$[ebp+8], eax

; 1041 :     __m256i y0, y1, y2, y3;
; 1042 :     for (y = y_range.start_src; y < (y_range.start_src + y_range.len); y += 2) {

  0011d	8b 8d cc fe ff
	ff		 mov	 ecx, DWORD PTR _y_range$[ebp]
  00123	89 4d f4	 mov	 DWORD PTR _y$[ebp], ecx
  00126	eb 09		 jmp	 SHORT $LN4@convert_yc
$LN2@convert_yc:
  00128	8b 55 f4	 mov	 edx, DWORD PTR _y$[ebp]
  0012b	83 c2 02	 add	 edx, 2
  0012e	89 55 f4	 mov	 DWORD PTR _y$[ebp], edx
$LN4@convert_yc:
  00131	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR _y_range$[ebp]
  00137	03 85 d4 fe ff
	ff		 add	 eax, DWORD PTR _y_range$[ebp+8]
  0013d	39 45 f4	 cmp	 DWORD PTR _y$[ebp], eax
  00140	0f 8d af 02 00
	00		 jge	 $LN3@convert_yc

; 1043 :         ycp = (short*)pixel + width * y * 3;

  00146	8b 4b 10	 mov	 ecx, DWORD PTR _width$[ebx]
  00149	0f af 4d f4	 imul	 ecx, DWORD PTR _y$[ebp]
  0014d	6b d1 03	 imul	 edx, ecx, 3
  00150	8b 45 e8	 mov	 eax, DWORD PTR _pixel$[ebp]
  00153	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00156	89 4d e4	 mov	 DWORD PTR _ycp$[ebp], ecx

; 1044 :         ycpw= ycp + width*3;

  00159	6b 53 10 03	 imul	 edx, DWORD PTR _width$[ebx], 3
  0015d	8b 45 e4	 mov	 eax, DWORD PTR _ycp$[ebp]
  00160	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00163	89 4d e0	 mov	 DWORD PTR _ycpw$[ebp], ecx

; 1045 :         Y   = (short*)dst_Y + dst_y_pitch * y;

  00166	8b 95 dc fe ff
	ff		 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  0016c	0f af 55 f4	 imul	 edx, DWORD PTR _y$[ebp]
  00170	8b 45 f0	 mov	 eax, DWORD PTR _dst_Y$[ebp]
  00173	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00176	89 4d dc	 mov	 DWORD PTR _Y$[ebp], ecx

; 1046 :         C   = (short*)dst_C + dst_y_pitch * y / 2;

  00179	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  0017f	0f af 45 f4	 imul	 eax, DWORD PTR _y$[ebp]
  00183	99		 cdq
  00184	2b c2		 sub	 eax, edx
  00186	d1 f8		 sar	 eax, 1
  00188	8b 55 ec	 mov	 edx, DWORD PTR _dst_C$[ebp]
  0018b	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  0018e	89 45 d8	 mov	 DWORD PTR _C$[ebp], eax

; 1047 :         for (x = 0; x < width; x += 16, ycp += 48, ycpw += 48) {

  00191	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _x$[ebp], 0
  00198	eb 1b		 jmp	 SHORT $LN7@convert_yc
$LN5@convert_yc:
  0019a	8b 4d f8	 mov	 ecx, DWORD PTR _x$[ebp]
  0019d	83 c1 10	 add	 ecx, 16			; 00000010H
  001a0	89 4d f8	 mov	 DWORD PTR _x$[ebp], ecx
  001a3	8b 55 e4	 mov	 edx, DWORD PTR _ycp$[ebp]
  001a6	83 c2 60	 add	 edx, 96			; 00000060H
  001a9	89 55 e4	 mov	 DWORD PTR _ycp$[ebp], edx
  001ac	8b 45 e0	 mov	 eax, DWORD PTR _ycpw$[ebp]
  001af	83 c0 60	 add	 eax, 96			; 00000060H
  001b2	89 45 e0	 mov	 DWORD PTR _ycpw$[ebp], eax
$LN7@convert_yc:
  001b5	8b 4d f8	 mov	 ecx, DWORD PTR _x$[ebp]
  001b8	3b 4b 10	 cmp	 ecx, DWORD PTR _width$[ebx]
  001bb	0f 8d 2f 02 00
	00		 jge	 $LN6@convert_yc

; 1048 :             y1 = _mm256_loadu_si256((__m256i *)(ycp +  0)); // 128, 0

  001c1	8b 55 e4	 mov	 edx, DWORD PTR _ycp$[ebp]
  001c4	c5 fe 6f 02	 vmovdqu ymm0, YMMWORD PTR [edx]
  001c8	c5 fe 7f 85 a0
	fd ff ff	 vmovdqu YMMWORD PTR $T14[ebp], ymm0
  001d0	c5 fe 6f 85 a0
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T14[ebp]
  001d8	c5 fe 7f 85 40
	fe ff ff	 vmovdqu YMMWORD PTR _y1$[ebp], ymm0

; 1049 :             y2 = _mm256_loadu_si256((__m256i *)(ycp + 16)); // 384, 256

  001e0	8b 45 e4	 mov	 eax, DWORD PTR _ycp$[ebp]
  001e3	83 c0 20	 add	 eax, 32			; 00000020H
  001e6	c5 fe 6f 00	 vmovdqu ymm0, YMMWORD PTR [eax]
  001ea	c5 fe 7f 85 80
	fd ff ff	 vmovdqu YMMWORD PTR $T13[ebp], ymm0
  001f2	c5 fe 6f 85 80
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T13[ebp]
  001fa	c5 fe 7f 85 00
	fe ff ff	 vmovdqu YMMWORD PTR _y2$[ebp], ymm0

; 1050 :             y3 = _mm256_loadu_si256((__m256i *)(ycp + 32)); // 640, 512

  00202	8b 4d e4	 mov	 ecx, DWORD PTR _ycp$[ebp]
  00205	83 c1 40	 add	 ecx, 64			; 00000040H
  00208	c5 fe 6f 01	 vmovdqu ymm0, YMMWORD PTR [ecx]
  0020c	c5 fe 7f 85 60
	fd ff ff	 vmovdqu YMMWORD PTR $T12[ebp], ymm0
  00214	c5 fe 6f 85 60
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T12[ebp]
  0021c	c5 fe 7f 85 c0
	fd ff ff	 vmovdqu YMMWORD PTR _y3$[ebp], ymm0

; 1051 : 
; 1052 :             gather_y_uv_from_yc48(y1, y2, y3);

  00224	c5 fe 6f 85 c0
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR _y3$[ebp]
  0022c	8d 95 00 fe ff
	ff		 lea	 edx, DWORD PTR _y2$[ebp]
  00232	52		 push	 edx
  00233	8d 85 40 fe ff
	ff		 lea	 eax, DWORD PTR _y1$[ebp]
  00239	50		 push	 eax
  0023a	e8 00 00 00 00	 call	 ?gather_y_uv_from_yc48@@YAXAAT__m256i@@0T1@@Z ; gather_y_uv_from_yc48
  0023f	83 c4 08	 add	 esp, 8

; 1053 :             y0 = y2;

  00242	c5 fe 6f 85 00
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR _y2$[ebp]
  0024a	c5 fe 7f 85 80
	fe ff ff	 vmovdqu YMMWORD PTR _y0$[ebp], ymm0

; 1054 : 
; 1055 :             _mm256_storeu_si256((__m256i *)(Y + x), convert_y_range_from_yc48(y1, yC_Y_L_MA_16, Y_L_RSH_16, yC_YCC, yC_pw_one));

  00252	c5 fd 6f 05 00
	00 00 00	 vmovdqa ymm0, YMMWORD PTR ?Array_Y_L_MA_16@@3QBFB
  0025a	c5 fe 7f 85 40
	fd ff ff	 vmovdqu YMMWORD PTR $T11[ebp], ymm0
  00262	8d 4d a0	 lea	 ecx, DWORD PTR _yC_pw_one$[ebp]
  00265	51		 push	 ecx
  00266	8d 95 20 ff ff
	ff		 lea	 edx, DWORD PTR _yC_YCC$[ebp]
  0026c	52		 push	 edx
  0026d	6a 04		 push	 4
  0026f	c5 fe 6f 8d 40
	fd ff ff	 vmovdqu ymm1, YMMWORD PTR $T11[ebp]
  00277	c5 fe 6f 85 40
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR _y1$[ebp]
  0027f	e8 00 00 00 00	 call	 ?convert_y_range_from_yc48@@YA?AT__m256i@@T1@0HABT1@1@Z ; convert_y_range_from_yc48
  00284	83 c4 0c	 add	 esp, 12			; 0000000cH
  00287	c5 fe 7f 85 20
	fd ff ff	 vmovdqu YMMWORD PTR $T10[ebp], ymm0
  0028f	c5 fe 6f 85 20
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T10[ebp]
  00297	8b 45 f8	 mov	 eax, DWORD PTR _x$[ebp]
  0029a	8b 4d dc	 mov	 ecx, DWORD PTR _Y$[ebp]
  0029d	c5 fe 7f 04 41	 vmovdqu YMMWORD PTR [ecx+eax*2], ymm0

; 1056 : 
; 1057 :             y1 = _mm256_loadu_si256((__m256i *)(ycpw +  0));

  002a2	8b 55 e0	 mov	 edx, DWORD PTR _ycpw$[ebp]
  002a5	c5 fe 6f 02	 vmovdqu ymm0, YMMWORD PTR [edx]
  002a9	c5 fe 7f 85 00
	fd ff ff	 vmovdqu YMMWORD PTR $T9[ebp], ymm0
  002b1	c5 fe 6f 85 00
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T9[ebp]
  002b9	c5 fe 7f 85 40
	fe ff ff	 vmovdqu YMMWORD PTR _y1$[ebp], ymm0

; 1058 :             y2 = _mm256_loadu_si256((__m256i *)(ycpw + 16));

  002c1	8b 45 e0	 mov	 eax, DWORD PTR _ycpw$[ebp]
  002c4	83 c0 20	 add	 eax, 32			; 00000020H
  002c7	c5 fe 6f 00	 vmovdqu ymm0, YMMWORD PTR [eax]
  002cb	c5 fe 7f 85 e0
	fc ff ff	 vmovdqu YMMWORD PTR $T8[ebp], ymm0
  002d3	c5 fe 6f 85 e0
	fc ff ff	 vmovdqu ymm0, YMMWORD PTR $T8[ebp]
  002db	c5 fe 7f 85 00
	fe ff ff	 vmovdqu YMMWORD PTR _y2$[ebp], ymm0

; 1059 :             y3 = _mm256_loadu_si256((__m256i *)(ycpw + 32));

  002e3	8b 4d e0	 mov	 ecx, DWORD PTR _ycpw$[ebp]
  002e6	83 c1 40	 add	 ecx, 64			; 00000040H
  002e9	c5 fe 6f 01	 vmovdqu ymm0, YMMWORD PTR [ecx]
  002ed	c5 fe 7f 85 c0
	fc ff ff	 vmovdqu YMMWORD PTR $T7[ebp], ymm0
  002f5	c5 fe 6f 85 c0
	fc ff ff	 vmovdqu ymm0, YMMWORD PTR $T7[ebp]
  002fd	c5 fe 7f 85 c0
	fd ff ff	 vmovdqu YMMWORD PTR _y3$[ebp], ymm0

; 1060 : 
; 1061 :             gather_y_uv_from_yc48(y1, y2, y3);

  00305	c5 fe 6f 85 c0
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR _y3$[ebp]
  0030d	8d 95 00 fe ff
	ff		 lea	 edx, DWORD PTR _y2$[ebp]
  00313	52		 push	 edx
  00314	8d 85 40 fe ff
	ff		 lea	 eax, DWORD PTR _y1$[ebp]
  0031a	50		 push	 eax
  0031b	e8 00 00 00 00	 call	 ?gather_y_uv_from_yc48@@YAXAAT__m256i@@0T1@@Z ; gather_y_uv_from_yc48
  00320	83 c4 08	 add	 esp, 8

; 1062 : 
; 1063 :             _mm256_storeu_si256((__m256i *)(Y + x + dst_y_pitch), convert_y_range_from_yc48(y1, yC_Y_L_MA_16, Y_L_RSH_16, yC_YCC, yC_pw_one));

  00323	c5 fd 6f 05 00
	00 00 00	 vmovdqa ymm0, YMMWORD PTR ?Array_Y_L_MA_16@@3QBFB
  0032b	c5 fe 7f 85 a0
	fc ff ff	 vmovdqu YMMWORD PTR $T6[ebp], ymm0
  00333	8d 4d a0	 lea	 ecx, DWORD PTR _yC_pw_one$[ebp]
  00336	51		 push	 ecx
  00337	8d 95 20 ff ff
	ff		 lea	 edx, DWORD PTR _yC_YCC$[ebp]
  0033d	52		 push	 edx
  0033e	6a 04		 push	 4
  00340	c5 fe 6f 8d a0
	fc ff ff	 vmovdqu ymm1, YMMWORD PTR $T6[ebp]
  00348	c5 fe 6f 85 40
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR _y1$[ebp]
  00350	e8 00 00 00 00	 call	 ?convert_y_range_from_yc48@@YA?AT__m256i@@T1@0HABT1@1@Z ; convert_y_range_from_yc48
  00355	83 c4 0c	 add	 esp, 12			; 0000000cH
  00358	c5 fe 7f 85 80
	fc ff ff	 vmovdqu YMMWORD PTR $T5[ebp], ymm0
  00360	c5 fe 6f 85 80
	fc ff ff	 vmovdqu ymm0, YMMWORD PTR $T5[ebp]
  00368	8b 45 f8	 mov	 eax, DWORD PTR _x$[ebp]
  0036b	8b 4d dc	 mov	 ecx, DWORD PTR _Y$[ebp]
  0036e	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00371	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  00377	c5 fe 7f 04 42	 vmovdqu YMMWORD PTR [edx+eax*2], ymm0

; 1064 : 
; 1065 :             _mm256_storeu_si256((__m256i *)(C + x), convert_uv_range_from_yc48_yuv420p(y0, y2,  _mm256_set1_epi16(UV_OFFSET_x2), yC_UV_L_MA_16_420P, UV_L_RSH_16_420P, yC_YCC, yC_pw_one));

  0037c	c5 fd 6f 05 00
	00 00 00	 vmovdqa ymm0, YMMWORD PTR ?Array_UV_L_MA_16_420P@@3QBFB
  00384	c5 fe 7f 85 40
	fc ff ff	 vmovdqu YMMWORD PTR $T3[ebp], ymm0
  0038c	c5 fe 6f 05 00
	00 00 00	 vmovdqu ymm0, YMMWORD PTR __ymm@1000100010001000100010001000100010001000100010001000100010001000
  00394	c5 fe 7f 85 60
	fc ff ff	 vmovdqu YMMWORD PTR $T4[ebp], ymm0
  0039c	8d 4d a0	 lea	 ecx, DWORD PTR _yC_pw_one$[ebp]
  0039f	51		 push	 ecx
  003a0	8d 95 20 ff ff
	ff		 lea	 edx, DWORD PTR _yC_YCC$[ebp]
  003a6	52		 push	 edx
  003a7	6a 01		 push	 1
  003a9	c5 fe 6f 95 40
	fc ff ff	 vmovdqu ymm2, YMMWORD PTR $T3[ebp]
  003b1	8d 85 60 fc ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  003b7	50		 push	 eax
  003b8	c5 fe 6f 8d 00
	fe ff ff	 vmovdqu ymm1, YMMWORD PTR _y2$[ebp]
  003c0	c5 fe 6f 85 80
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR _y0$[ebp]
  003c8	e8 00 00 00 00	 call	 ?convert_uv_range_from_yc48_yuv420p@@YA?AT__m256i@@T1@0ABT1@0H11@Z ; convert_uv_range_from_yc48_yuv420p
  003cd	83 c4 10	 add	 esp, 16			; 00000010H
  003d0	c5 fe 7f 85 20
	fc ff ff	 vmovdqu YMMWORD PTR $T2[ebp], ymm0
  003d8	c5 fe 6f 85 20
	fc ff ff	 vmovdqu ymm0, YMMWORD PTR $T2[ebp]
  003e0	8b 4d f8	 mov	 ecx, DWORD PTR _x$[ebp]
  003e3	8b 55 d8	 mov	 edx, DWORD PTR _C$[ebp]
  003e6	c5 fe 7f 04 4a	 vmovdqu YMMWORD PTR [edx+ecx*2], ymm0

; 1066 :         }

  003eb	e9 aa fd ff ff	 jmp	 $LN5@convert_yc
$LN6@convert_yc:

; 1067 :     }

  003f0	e9 33 fd ff ff	 jmp	 $LN2@convert_yc
$LN3@convert_yc:

; 1068 :     _mm256_zeroupper();

  003f5	c5 f8 77	 vzeroupper

; 1069 : }

  003f8	52		 push	 edx
  003f9	8b cd		 mov	 ecx, ebp
  003fb	50		 push	 eax
  003fc	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN15@convert_yc
  00402	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00407	58		 pop	 eax
  00408	5a		 pop	 edx
  00409	5f		 pop	 edi
  0040a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0040d	33 cd		 xor	 ecx, ebp
  0040f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00414	8b e5		 mov	 esp, ebp
  00416	5d		 pop	 ebp
  00417	8b e3		 mov	 esp, ebx
  00419	5b		 pop	 ebx
  0041a	c3		 ret	 0
  0041b	90		 npad	 1
$LN15@convert_yc:
  0041c	05 00 00 00	 DD	 5
  00420	00 00 00 00	 DD	 $LN14@convert_yc
$LN14@convert_yc:
  00424	a0 ff ff ff	 DD	 -96			; ffffffa0H
  00428	20 00 00 00	 DD	 32			; 00000020H
  0042c	00 00 00 00	 DD	 $LN9@convert_yc
  00430	20 ff ff ff	 DD	 -224			; ffffff20H
  00434	20 00 00 00	 DD	 32			; 00000020H
  00438	00 00 00 00	 DD	 $LN10@convert_yc
  0043c	cc fe ff ff	 DD	 -308			; fffffeccH
  00440	0c 00 00 00	 DD	 12			; 0000000cH
  00444	00 00 00 00	 DD	 $LN11@convert_yc
  00448	40 fe ff ff	 DD	 -448			; fffffe40H
  0044c	20 00 00 00	 DD	 32			; 00000020H
  00450	00 00 00 00	 DD	 $LN12@convert_yc
  00454	00 fe ff ff	 DD	 -512			; fffffe00H
  00458	20 00 00 00	 DD	 32			; 00000020H
  0045c	00 00 00 00	 DD	 $LN13@convert_yc
$LN13@convert_yc:
  00460	79		 DB	 121			; 00000079H
  00461	32		 DB	 50			; 00000032H
  00462	00		 DB	 0
$LN12@convert_yc:
  00463	79		 DB	 121			; 00000079H
  00464	31		 DB	 49			; 00000031H
  00465	00		 DB	 0
$LN11@convert_yc:
  00466	79		 DB	 121			; 00000079H
  00467	5f		 DB	 95			; 0000005fH
  00468	72		 DB	 114			; 00000072H
  00469	61		 DB	 97			; 00000061H
  0046a	6e		 DB	 110			; 0000006eH
  0046b	67		 DB	 103			; 00000067H
  0046c	65		 DB	 101			; 00000065H
  0046d	00		 DB	 0
$LN10@convert_yc:
  0046e	79		 DB	 121			; 00000079H
  0046f	43		 DB	 67			; 00000043H
  00470	5f		 DB	 95			; 0000005fH
  00471	59		 DB	 89			; 00000059H
  00472	43		 DB	 67			; 00000043H
  00473	43		 DB	 67			; 00000043H
  00474	00		 DB	 0
$LN9@convert_yc:
  00475	79		 DB	 121			; 00000079H
  00476	43		 DB	 67			; 00000043H
  00477	5f		 DB	 95			; 0000005fH
  00478	70		 DB	 112			; 00000070H
  00479	77		 DB	 119			; 00000077H
  0047a	5f		 DB	 95			; 0000005fH
  0047b	6f		 DB	 111			; 0000006fH
  0047c	6e		 DB	 110			; 0000006eH
  0047d	65		 DB	 101			; 00000065H
  0047e	00		 DB	 0
?convert_yc48_to_p010_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yc48_to_p010_avx2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
$T1 = -576						; size = 32
$T2 = -544						; size = 32
$T3 = -512						; size = 32
$T4 = -480						; size = 32
$T5 = -448						; size = 32
$T6 = -416						; size = 32
$T7 = -384						; size = 32
$T8 = -352						; size = 32
$T9 = -320						; size = 32
$T10 = -288						; size = 32
$T11 = -256						; size = 32
$T12 = -224						; size = 32
$T13 = -192						; size = 32
$T14 = -160						; size = 32
$T15 = -128						; size = 32
_y5$ = -96						; size = 32
_y4$ = -64						; size = 32
_y3$ = -32						; size = 32
_y0$ = 8						; size = 4
_y1$ = 12						; size = 4
_y2$ = 16						; size = 4
?gather_y_u_v_to_yc48@@YAXAAT__m256i@@00@Z PROC		; gather_y_u_v_to_yc48

; 1001 : static __forceinline void gather_y_u_v_to_yc48(__m256i& y0, __m256i& y1, __m256i& y2) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 40 02 00
	00		 sub	 esp, 576		; 00000240H
  0001c	57		 push	 edi
  0001d	8d bd c0 fd ff
	ff		 lea	 edi, DWORD PTR [ebp-576]
  00023	b9 90 00 00 00	 mov	 ecx, 144		; 00000090H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd

; 1002 :     __m256i y3, y4, y5;
; 1003 : 
; 1004 :     alignas(16) static const uint8_t shuffle_yc48[32] = {
; 1005 :         0x00, 0x01, 0x06, 0x07, 0x0C, 0x0D, 0x02, 0x03, 0x08, 0x09, 0x0E, 0x0F, 0x04, 0x05, 0x0A, 0x0B,
; 1006 :         0x00, 0x01, 0x06, 0x07, 0x0C, 0x0D, 0x02, 0x03, 0x08, 0x09, 0x0E, 0x0F, 0x04, 0x05, 0x0A, 0x0B
; 1007 :     };
; 1008 :     y5 = _mm256_load_si256((__m256i *)shuffle_yc48);

  0002f	c5 fe 6f 05 00
	00 00 00	 vmovdqu ymm0, YMMWORD PTR ?shuffle_yc48@?1??gather_y_u_v_to_yc48@@YAXAAT__m256i@@00@Z@4QBEB
  00037	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR $T15[ebp], ymm0
  0003c	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR $T15[ebp]
  00041	c5 fe 7f 45 a0	 vmovdqu YMMWORD PTR _y5$[ebp], ymm0

; 1009 :     y0 = _mm256_shuffle_epi8(y0, y5);                             //5,2,7,4,1,6,3,0

  00046	8b 43 08	 mov	 eax, DWORD PTR _y0$[ebx]
  00049	c5 fe 6f 00	 vmovdqu ymm0, YMMWORD PTR [eax]
  0004d	c4 e2 7d 00 45
	a0		 vpshufb ymm0, ymm0, YMMWORD PTR _y5$[ebp]
  00053	c5 fe 7f 85 60
	ff ff ff	 vmovdqu YMMWORD PTR $T14[ebp], ymm0
  0005b	8b 4b 08	 mov	 ecx, DWORD PTR _y0$[ebx]
  0005e	c5 fe 6f 85 60
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T14[ebp]
  00066	c5 fe 7f 01	 vmovdqu YMMWORD PTR [ecx], ymm0

; 1010 :     y1 = _mm256_shuffle_epi8(y1, _mm256_alignr_epi8(y5, y5, 14)); //2,7,4,1,6,3,0,5

  0006a	c5 fe 6f 45 a0	 vmovdqu ymm0, YMMWORD PTR _y5$[ebp]
  0006f	c4 e3 7d 0f 45
	a0 0e		 vpalignr ymm0, ymm0, YMMWORD PTR _y5$[ebp], 14 ; 0000000eH
  00076	c5 fe 7f 85 40
	ff ff ff	 vmovdqu YMMWORD PTR $T13[ebp], ymm0
  0007e	8b 53 0c	 mov	 edx, DWORD PTR _y1$[ebx]
  00081	c5 fe 6f 02	 vmovdqu ymm0, YMMWORD PTR [edx]
  00085	c4 e2 7d 00 85
	40 ff ff ff	 vpshufb ymm0, ymm0, YMMWORD PTR $T13[ebp]
  0008e	c5 fe 7f 85 20
	ff ff ff	 vmovdqu YMMWORD PTR $T12[ebp], ymm0
  00096	8b 43 0c	 mov	 eax, DWORD PTR _y1$[ebx]
  00099	c5 fe 6f 85 20
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T12[ebp]
  000a1	c5 fe 7f 00	 vmovdqu YMMWORD PTR [eax], ymm0

; 1011 :     y2 = _mm256_shuffle_epi8(y2, _mm256_alignr_epi8(y5, y5, 12)); //7,4,1,6,3,0,5,2

  000a5	c5 fe 6f 45 a0	 vmovdqu ymm0, YMMWORD PTR _y5$[ebp]
  000aa	c4 e3 7d 0f 45
	a0 0c		 vpalignr ymm0, ymm0, YMMWORD PTR _y5$[ebp], 12 ; 0000000cH
  000b1	c5 fe 7f 85 00
	ff ff ff	 vmovdqu YMMWORD PTR $T11[ebp], ymm0
  000b9	8b 4b 10	 mov	 ecx, DWORD PTR _y2$[ebx]
  000bc	c5 fe 6f 01	 vmovdqu ymm0, YMMWORD PTR [ecx]
  000c0	c4 e2 7d 00 85
	00 ff ff ff	 vpshufb ymm0, ymm0, YMMWORD PTR $T11[ebp]
  000c9	c5 fe 7f 85 e0
	fe ff ff	 vmovdqu YMMWORD PTR $T10[ebp], ymm0
  000d1	8b 53 10	 mov	 edx, DWORD PTR _y2$[ebx]
  000d4	c5 fe 6f 85 e0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T10[ebp]
  000dc	c5 fe 7f 02	 vmovdqu YMMWORD PTR [edx], ymm0

; 1012 : 
; 1013 :     y3 = _mm256_blend_epi16(y0, y1, 0x80 + 0x10 + 0x02);

  000e0	8b 43 0c	 mov	 eax, DWORD PTR _y1$[ebx]
  000e3	8b 4b 08	 mov	 ecx, DWORD PTR _y0$[ebx]
  000e6	c5 fe 6f 01	 vmovdqu ymm0, YMMWORD PTR [ecx]
  000ea	c4 e3 7d 0e 00
	92		 vpblendw ymm0, ymm0, YMMWORD PTR [eax], 146 ; 00000092H
  000f0	c5 fe 7f 85 c0
	fe ff ff	 vmovdqu YMMWORD PTR $T9[ebp], ymm0
  000f8	c5 fe 6f 85 c0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T9[ebp]
  00100	c5 fe 7f 45 e0	 vmovdqu YMMWORD PTR _y3$[ebp], ymm0

; 1014 :     y3 = _mm256_blend_epi16(y3, y2, 0x20 + 0x04);        //384, 0

  00105	8b 53 10	 mov	 edx, DWORD PTR _y2$[ebx]
  00108	c5 fe 6f 45 e0	 vmovdqu ymm0, YMMWORD PTR _y3$[ebp]
  0010d	c4 e3 7d 0e 02
	24		 vpblendw ymm0, ymm0, YMMWORD PTR [edx], 36 ; 00000024H
  00113	c5 fe 7f 85 a0
	fe ff ff	 vmovdqu YMMWORD PTR $T8[ebp], ymm0
  0011b	c5 fe 6f 85 a0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T8[ebp]
  00123	c5 fe 7f 45 e0	 vmovdqu YMMWORD PTR _y3$[ebp], ymm0

; 1015 : 
; 1016 :     y4 = _mm256_blend_epi16(y2, y1, 0x20 + 0x04);

  00128	8b 43 0c	 mov	 eax, DWORD PTR _y1$[ebx]
  0012b	8b 4b 10	 mov	 ecx, DWORD PTR _y2$[ebx]
  0012e	c5 fe 6f 01	 vmovdqu ymm0, YMMWORD PTR [ecx]
  00132	c4 e3 7d 0e 00
	24		 vpblendw ymm0, ymm0, YMMWORD PTR [eax], 36 ; 00000024H
  00138	c5 fe 7f 85 80
	fe ff ff	 vmovdqu YMMWORD PTR $T7[ebp], ymm0
  00140	c5 fe 6f 85 80
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T7[ebp]
  00148	c5 fe 7f 45 c0	 vmovdqu YMMWORD PTR _y4$[ebp], ymm0

; 1017 :     y4 = _mm256_blend_epi16(y4, y0, 0x80 + 0x10 + 0x02); //512, 128

  0014d	8b 53 08	 mov	 edx, DWORD PTR _y0$[ebx]
  00150	c5 fe 6f 45 c0	 vmovdqu ymm0, YMMWORD PTR _y4$[ebp]
  00155	c4 e3 7d 0e 02
	92		 vpblendw ymm0, ymm0, YMMWORD PTR [edx], 146 ; 00000092H
  0015b	c5 fe 7f 85 60
	fe ff ff	 vmovdqu YMMWORD PTR $T6[ebp], ymm0
  00163	c5 fe 6f 85 60
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T6[ebp]
  0016b	c5 fe 7f 45 c0	 vmovdqu YMMWORD PTR _y4$[ebp], ymm0

; 1018 : 
; 1019 :     y2 = _mm256_blend_epi16(y2, y0, 0x20 + 0x04);

  00170	8b 43 08	 mov	 eax, DWORD PTR _y0$[ebx]
  00173	8b 4b 10	 mov	 ecx, DWORD PTR _y2$[ebx]
  00176	c5 fe 6f 01	 vmovdqu ymm0, YMMWORD PTR [ecx]
  0017a	c4 e3 7d 0e 00
	24		 vpblendw ymm0, ymm0, YMMWORD PTR [eax], 36 ; 00000024H
  00180	c5 fe 7f 85 40
	fe ff ff	 vmovdqu YMMWORD PTR $T5[ebp], ymm0
  00188	8b 53 10	 mov	 edx, DWORD PTR _y2$[ebx]
  0018b	c5 fe 6f 85 40
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T5[ebp]
  00193	c5 fe 7f 02	 vmovdqu YMMWORD PTR [edx], ymm0

; 1020 :     y2 = _mm256_blend_epi16(y2, y1, 0x40 + 0x08 + 0x01); //640, 256

  00197	8b 43 0c	 mov	 eax, DWORD PTR _y1$[ebx]
  0019a	8b 4b 10	 mov	 ecx, DWORD PTR _y2$[ebx]
  0019d	c5 fe 6f 01	 vmovdqu ymm0, YMMWORD PTR [ecx]
  001a1	c4 e3 7d 0e 00
	49		 vpblendw ymm0, ymm0, YMMWORD PTR [eax], 73 ; 00000049H
  001a7	c5 fe 7f 85 20
	fe ff ff	 vmovdqu YMMWORD PTR $T4[ebp], ymm0
  001af	8b 53 10	 mov	 edx, DWORD PTR _y2$[ebx]
  001b2	c5 fe 6f 85 20
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T4[ebp]
  001ba	c5 fe 7f 02	 vmovdqu YMMWORD PTR [edx], ymm0

; 1021 : 
; 1022 :     y0 = _mm256_permute2x128_si256(y3, y4, (0x02<<4) + 0x00); // 128, 0

  001be	c5 fe 6f 45 e0	 vmovdqu ymm0, YMMWORD PTR _y3$[ebp]
  001c3	c4 e3 7d 46 45
	c0 20		 vperm2i128 ymm0, ymm0, YMMWORD PTR _y4$[ebp], 32 ; 00000020H
  001ca	c5 fe 7f 85 00
	fe ff ff	 vmovdqu YMMWORD PTR $T3[ebp], ymm0
  001d2	8b 43 08	 mov	 eax, DWORD PTR _y0$[ebx]
  001d5	c5 fe 6f 85 00
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T3[ebp]
  001dd	c5 fe 7f 00	 vmovdqu YMMWORD PTR [eax], ymm0

; 1023 :     y1 = _mm256_blend_epi32(y2, y3, 0xf0);                    // 384, 256

  001e1	8b 4b 10	 mov	 ecx, DWORD PTR _y2$[ebx]
  001e4	c5 fe 6f 01	 vmovdqu ymm0, YMMWORD PTR [ecx]
  001e8	c4 e3 7d 02 45
	e0 f0		 vpblendd ymm0, ymm0, YMMWORD PTR _y3$[ebp], 240 ; 000000f0H
  001ef	c5 fe 7f 85 e0
	fd ff ff	 vmovdqu YMMWORD PTR $T2[ebp], ymm0
  001f7	8b 53 0c	 mov	 edx, DWORD PTR _y1$[ebx]
  001fa	c5 fe 6f 85 e0
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T2[ebp]
  00202	c5 fe 7f 02	 vmovdqu YMMWORD PTR [edx], ymm0

; 1024 :     y2 = _mm256_permute2x128_si256(y4, y2, (0x03<<4) + 0x01); // 640, 512

  00206	8b 43 10	 mov	 eax, DWORD PTR _y2$[ebx]
  00209	c5 fe 6f 45 c0	 vmovdqu ymm0, YMMWORD PTR _y4$[ebp]
  0020e	c4 e3 7d 46 00
	31		 vperm2i128 ymm0, ymm0, YMMWORD PTR [eax], 49 ; 00000031H
  00214	c5 fe 7f 85 c0
	fd ff ff	 vmovdqu YMMWORD PTR $T1[ebp], ymm0
  0021c	8b 4b 10	 mov	 ecx, DWORD PTR _y2$[ebx]
  0021f	c5 fe 6f 85 c0
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T1[ebp]
  00227	c5 fe 7f 01	 vmovdqu YMMWORD PTR [ecx], ymm0

; 1025 : }

  0022b	5f		 pop	 edi
  0022c	8b e5		 mov	 esp, ebp
  0022e	5d		 pop	 ebp
  0022f	8b e3		 mov	 esp, ebx
  00231	5b		 pop	 ebx
  00232	c3		 ret	 0
?gather_y_u_v_to_yc48@@YAXAAT__m256i@@00@Z ENDP		; gather_y_u_v_to_yc48
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
$T1 = -736						; size = 32
$T2 = -704						; size = 32
$T3 = -672						; size = 32
$T4 = -640						; size = 32
$T5 = -608						; size = 32
$T6 = -576						; size = 32
$T7 = -544						; size = 32
$T8 = -512						; size = 32
$T9 = -480						; size = 32
$T10 = -448						; size = 32
$T11 = -416						; size = 32
$T12 = -384						; size = 32
$T13 = -352						; size = 32
$T14 = -320						; size = 32
$T15 = -288						; size = 32
$T16 = -256						; size = 32
$T17 = -224						; size = 32
$T18 = -192						; size = 32
$T19 = -160						; size = 32
_MASK_INT$ = -100					; size = 4
_y5$ = -96						; size = 32
_y4$ = -64						; size = 32
_y3$ = -32						; size = 32
_y0$ = 8						; size = 4
_y1$ = 12						; size = 4
_y2$ = 16						; size = 4
?gather_y_u_v_from_yc48@@YAXAAT__m256i@@00@Z PROC	; gather_y_u_v_from_yc48

; 980  : static __forceinline void gather_y_u_v_from_yc48(__m256i& y0, __m256i& y1, __m256i& y2) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec e0 02 00
	00		 sub	 esp, 736		; 000002e0H
  0001c	57		 push	 edi
  0001d	8d bd 20 fd ff
	ff		 lea	 edi, DWORD PTR [ebp-736]
  00023	b9 b8 00 00 00	 mov	 ecx, 184		; 000000b8H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd

; 981  :     __m256i y3, y4, y5;
; 982  :     const int MASK_INT = 0x40 + 0x08 + 0x01;

  0002f	c7 45 9c 49 00
	00 00		 mov	 DWORD PTR _MASK_INT$[ebp], 73 ; 00000049H

; 983  :     y3 = _mm256_blend_epi32(y0, y1, 0xf0);                    // 384, 0

  00036	8b 43 0c	 mov	 eax, DWORD PTR _y1$[ebx]
  00039	8b 4b 08	 mov	 ecx, DWORD PTR _y0$[ebx]
  0003c	c5 fe 6f 01	 vmovdqu ymm0, YMMWORD PTR [ecx]
  00040	c4 e3 7d 02 00
	f0		 vpblendd ymm0, ymm0, YMMWORD PTR [eax], 240 ; 000000f0H
  00046	c5 fe 7f 85 60
	ff ff ff	 vmovdqu YMMWORD PTR $T19[ebp], ymm0
  0004e	c5 fe 6f 85 60
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T19[ebp]
  00056	c5 fe 7f 45 e0	 vmovdqu YMMWORD PTR _y3$[ebp], ymm0

; 984  :     y4 = _mm256_permute2x128_si256(y0, y2, (0x02<<4) + 0x01); // 512, 128

  0005b	8b 53 10	 mov	 edx, DWORD PTR _y2$[ebx]
  0005e	8b 43 08	 mov	 eax, DWORD PTR _y0$[ebx]
  00061	c5 fe 6f 00	 vmovdqu ymm0, YMMWORD PTR [eax]
  00065	c4 e3 7d 46 02
	21		 vperm2i128 ymm0, ymm0, YMMWORD PTR [edx], 33 ; 00000021H
  0006b	c5 fe 7f 85 40
	ff ff ff	 vmovdqu YMMWORD PTR $T18[ebp], ymm0
  00073	c5 fe 6f 85 40
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T18[ebp]
  0007b	c5 fe 7f 45 c0	 vmovdqu YMMWORD PTR _y4$[ebp], ymm0

; 985  :     y5 = _mm256_blend_epi32(y1, y2, 0xf0);                    // 640, 256

  00080	8b 4b 10	 mov	 ecx, DWORD PTR _y2$[ebx]
  00083	8b 53 0c	 mov	 edx, DWORD PTR _y1$[ebx]
  00086	c5 fe 6f 02	 vmovdqu ymm0, YMMWORD PTR [edx]
  0008a	c4 e3 7d 02 01
	f0		 vpblendd ymm0, ymm0, YMMWORD PTR [ecx], 240 ; 000000f0H
  00090	c5 fe 7f 85 20
	ff ff ff	 vmovdqu YMMWORD PTR $T17[ebp], ymm0
  00098	c5 fe 6f 85 20
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T17[ebp]
  000a0	c5 fe 7f 45 a0	 vmovdqu YMMWORD PTR _y5$[ebp], ymm0

; 986  : 
; 987  :     y0 = _mm256_blend_epi16(y5, y3, MASK_INT);

  000a5	c5 fe 6f 45 a0	 vmovdqu ymm0, YMMWORD PTR _y5$[ebp]
  000aa	c4 e3 7d 0e 45
	e0 49		 vpblendw ymm0, ymm0, YMMWORD PTR _y3$[ebp], 73 ; 00000049H
  000b1	c5 fe 7f 85 00
	ff ff ff	 vmovdqu YMMWORD PTR $T16[ebp], ymm0
  000b9	8b 43 08	 mov	 eax, DWORD PTR _y0$[ebx]
  000bc	c5 fe 6f 85 00
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T16[ebp]
  000c4	c5 fe 7f 00	 vmovdqu YMMWORD PTR [eax], ymm0

; 988  :     y1 = _mm256_blend_epi16(y4, y5, MASK_INT);

  000c8	c5 fe 6f 45 c0	 vmovdqu ymm0, YMMWORD PTR _y4$[ebp]
  000cd	c4 e3 7d 0e 45
	a0 49		 vpblendw ymm0, ymm0, YMMWORD PTR _y5$[ebp], 73 ; 00000049H
  000d4	c5 fe 7f 85 e0
	fe ff ff	 vmovdqu YMMWORD PTR $T15[ebp], ymm0
  000dc	8b 4b 0c	 mov	 ecx, DWORD PTR _y1$[ebx]
  000df	c5 fe 6f 85 e0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T15[ebp]
  000e7	c5 fe 7f 01	 vmovdqu YMMWORD PTR [ecx], ymm0

; 989  :     y2 = _mm256_blend_epi16(y3, y4, MASK_INT);

  000eb	c5 fe 6f 45 e0	 vmovdqu ymm0, YMMWORD PTR _y3$[ebp]
  000f0	c4 e3 7d 0e 45
	c0 49		 vpblendw ymm0, ymm0, YMMWORD PTR _y4$[ebp], 73 ; 00000049H
  000f7	c5 fe 7f 85 c0
	fe ff ff	 vmovdqu YMMWORD PTR $T14[ebp], ymm0
  000ff	8b 53 10	 mov	 edx, DWORD PTR _y2$[ebx]
  00102	c5 fe 6f 85 c0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T14[ebp]
  0010a	c5 fe 7f 02	 vmovdqu YMMWORD PTR [edx], ymm0

; 990  : 
; 991  :     y0 = _mm256_blend_epi16(y0, y4, MASK_INT<<1);

  0010e	8b 43 08	 mov	 eax, DWORD PTR _y0$[ebx]
  00111	c5 fe 6f 00	 vmovdqu ymm0, YMMWORD PTR [eax]
  00115	c4 e3 7d 0e 45
	c0 92		 vpblendw ymm0, ymm0, YMMWORD PTR _y4$[ebp], 146 ; 00000092H
  0011c	c5 fe 7f 85 a0
	fe ff ff	 vmovdqu YMMWORD PTR $T13[ebp], ymm0
  00124	8b 4b 08	 mov	 ecx, DWORD PTR _y0$[ebx]
  00127	c5 fe 6f 85 a0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T13[ebp]
  0012f	c5 fe 7f 01	 vmovdqu YMMWORD PTR [ecx], ymm0

; 992  :     y1 = _mm256_blend_epi16(y1, y3, MASK_INT<<1);

  00133	8b 53 0c	 mov	 edx, DWORD PTR _y1$[ebx]
  00136	c5 fe 6f 02	 vmovdqu ymm0, YMMWORD PTR [edx]
  0013a	c4 e3 7d 0e 45
	e0 92		 vpblendw ymm0, ymm0, YMMWORD PTR _y3$[ebp], 146 ; 00000092H
  00141	c5 fe 7f 85 80
	fe ff ff	 vmovdqu YMMWORD PTR $T12[ebp], ymm0
  00149	8b 43 0c	 mov	 eax, DWORD PTR _y1$[ebx]
  0014c	c5 fe 6f 85 80
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T12[ebp]
  00154	c5 fe 7f 00	 vmovdqu YMMWORD PTR [eax], ymm0

; 993  :     y2 = _mm256_blend_epi16(y2, y5, MASK_INT<<1);

  00158	8b 4b 10	 mov	 ecx, DWORD PTR _y2$[ebx]
  0015b	c5 fe 6f 01	 vmovdqu ymm0, YMMWORD PTR [ecx]
  0015f	c4 e3 7d 0e 45
	a0 92		 vpblendw ymm0, ymm0, YMMWORD PTR _y5$[ebp], 146 ; 00000092H
  00166	c5 fe 7f 85 60
	fe ff ff	 vmovdqu YMMWORD PTR $T11[ebp], ymm0
  0016e	8b 53 10	 mov	 edx, DWORD PTR _y2$[ebx]
  00171	c5 fe 6f 85 60
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T11[ebp]
  00179	c5 fe 7f 02	 vmovdqu YMMWORD PTR [edx], ymm0

; 994  : 
; 995  :     y0 = _mm256_shuffle_epi8(y0, yC_SUFFLE_YCP_Y);

  0017d	c5 fd 6f 05 00
	00 00 00	 vmovdqa ymm0, YMMWORD PTR ?Array_SUFFLE_YCP_Y@@3QBEB
  00185	c5 fe 7f 85 40
	fe ff ff	 vmovdqu YMMWORD PTR $T10[ebp], ymm0
  0018d	8b 43 08	 mov	 eax, DWORD PTR _y0$[ebx]
  00190	c5 fe 6f 00	 vmovdqu ymm0, YMMWORD PTR [eax]
  00194	c4 e2 7d 00 85
	40 fe ff ff	 vpshufb ymm0, ymm0, YMMWORD PTR $T10[ebp]
  0019d	c5 fe 7f 85 20
	fe ff ff	 vmovdqu YMMWORD PTR $T9[ebp], ymm0
  001a5	8b 4b 08	 mov	 ecx, DWORD PTR _y0$[ebx]
  001a8	c5 fe 6f 85 20
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T9[ebp]
  001b0	c5 fe 7f 01	 vmovdqu YMMWORD PTR [ecx], ymm0

; 996  :     y1 = _mm256_shuffle_epi8(y1, _mm256_alignr_epi8(yC_SUFFLE_YCP_Y, yC_SUFFLE_YCP_Y, 6));

  001b4	c5 fd 6f 05 00
	00 00 00	 vmovdqa ymm0, YMMWORD PTR ?Array_SUFFLE_YCP_Y@@3QBEB
  001bc	c5 fe 7f 85 e0
	fd ff ff	 vmovdqu YMMWORD PTR $T7[ebp], ymm0
  001c4	c5 fd 6f 05 00
	00 00 00	 vmovdqa ymm0, YMMWORD PTR ?Array_SUFFLE_YCP_Y@@3QBEB
  001cc	c5 fe 7f 85 00
	fe ff ff	 vmovdqu YMMWORD PTR $T8[ebp], ymm0
  001d4	c5 fe 6f 85 00
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T8[ebp]
  001dc	c4 e3 7d 0f 85
	e0 fd ff ff 06	 vpalignr ymm0, ymm0, YMMWORD PTR $T7[ebp], 6
  001e6	c5 fe 7f 85 c0
	fd ff ff	 vmovdqu YMMWORD PTR $T6[ebp], ymm0
  001ee	8b 53 0c	 mov	 edx, DWORD PTR _y1$[ebx]
  001f1	c5 fe 6f 02	 vmovdqu ymm0, YMMWORD PTR [edx]
  001f5	c4 e2 7d 00 85
	c0 fd ff ff	 vpshufb ymm0, ymm0, YMMWORD PTR $T6[ebp]
  001fe	c5 fe 7f 85 a0
	fd ff ff	 vmovdqu YMMWORD PTR $T5[ebp], ymm0
  00206	8b 43 0c	 mov	 eax, DWORD PTR _y1$[ebx]
  00209	c5 fe 6f 85 a0
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T5[ebp]
  00211	c5 fe 7f 00	 vmovdqu YMMWORD PTR [eax], ymm0

; 997  :     y2 = _mm256_shuffle_epi8(y2, _mm256_alignr_epi8(yC_SUFFLE_YCP_Y, yC_SUFFLE_YCP_Y, 12));

  00215	c5 fd 6f 05 00
	00 00 00	 vmovdqa ymm0, YMMWORD PTR ?Array_SUFFLE_YCP_Y@@3QBEB
  0021d	c5 fe 7f 85 60
	fd ff ff	 vmovdqu YMMWORD PTR $T3[ebp], ymm0
  00225	c5 fd 6f 05 00
	00 00 00	 vmovdqa ymm0, YMMWORD PTR ?Array_SUFFLE_YCP_Y@@3QBEB
  0022d	c5 fe 7f 85 80
	fd ff ff	 vmovdqu YMMWORD PTR $T4[ebp], ymm0
  00235	c5 fe 6f 85 80
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T4[ebp]
  0023d	c4 e3 7d 0f 85
	60 fd ff ff 0c	 vpalignr ymm0, ymm0, YMMWORD PTR $T3[ebp], 12 ; 0000000cH
  00247	c5 fe 7f 85 40
	fd ff ff	 vmovdqu YMMWORD PTR $T2[ebp], ymm0
  0024f	8b 4b 10	 mov	 ecx, DWORD PTR _y2$[ebx]
  00252	c5 fe 6f 01	 vmovdqu ymm0, YMMWORD PTR [ecx]
  00256	c4 e2 7d 00 85
	40 fd ff ff	 vpshufb ymm0, ymm0, YMMWORD PTR $T2[ebp]
  0025f	c5 fe 7f 85 20
	fd ff ff	 vmovdqu YMMWORD PTR $T1[ebp], ymm0
  00267	8b 53 10	 mov	 edx, DWORD PTR _y2$[ebx]
  0026a	c5 fe 6f 85 20
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T1[ebp]
  00272	c5 fe 7f 02	 vmovdqu YMMWORD PTR [edx], ymm0

; 998  : }

  00276	5f		 pop	 edi
  00277	8b e5		 mov	 esp, ebp
  00279	5d		 pop	 ebp
  0027a	8b e3		 mov	 esp, ebx
  0027c	5b		 pop	 ebx
  0027d	c3		 ret	 0
?gather_y_u_v_from_yc48@@YAXAAT__m256i@@00@Z ENDP	; gather_y_u_v_from_yc48
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
$T1 = -544						; size = 32
$T2 = -512						; size = 32
$T3 = -480						; size = 32
$T4 = -448						; size = 32
$T5 = -416						; size = 32
$T6 = -384						; size = 32
$T7 = -352						; size = 32
$T8 = -320						; size = 32
_y1$ = -288						; size = 32
$T9 = -256						; size = 32
$T10 = -224						; size = 32
_yC_0x8000$ = -192					; size = 32
$T11 = -160						; size = 32
$T12 = -128						; size = 32
$T13 = -96						; size = 32
_yC_coeff$ = -64					; size = 32
_y0$ = -32						; size = 32
?convert_uv_range_to_yc48@@YA?AT__m256i@@T1@@Z PROC	; convert_uv_range_to_yc48
; _y0$ = ymm0

; 963  : static __forceinline __m256i convert_uv_range_to_yc48(__m256i y0) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 20 02 00
	00		 sub	 esp, 544		; 00000220H
  0001c	57		 push	 edi
  0001d	8d bd e0 fd ff
	ff		 lea	 edi, DWORD PTR [ebp-544]
  00023	b9 88 00 00 00	 mov	 ecx, 136		; 00000088H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	c5 fc 11 45 e0	 vmovups YMMWORD PTR _y0$[ebp], ymm0

; 964  :     //coeff = 4682
; 965  :     //UV = (( uv - 32768 ) * coef + (1<<15) ) >> 16
; 966  :     const __m256i yC_coeff = _mm256_unpacklo_epi16(_mm256_set1_epi16(4682), _mm256_set1_epi16(-1));

  00034	c5 fe 6f 05 00
	00 00 00	 vmovdqu ymm0, YMMWORD PTR __ymm@ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
  0003c	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR $T12[ebp], ymm0
  00041	c5 fe 6f 05 00
	00 00 00	 vmovdqu ymm0, YMMWORD PTR __ymm@124a124a124a124a124a124a124a124a124a124a124a124a124a124a124a124a
  00049	c5 fe 7f 45 a0	 vmovdqu YMMWORD PTR $T13[ebp], ymm0
  0004e	c5 fe 6f 45 a0	 vmovdqu ymm0, YMMWORD PTR $T13[ebp]
  00053	c5 fd 61 45 80	 vpunpcklwd ymm0, ymm0, YMMWORD PTR $T12[ebp]
  00058	c5 fe 7f 85 60
	ff ff ff	 vmovdqu YMMWORD PTR $T11[ebp], ymm0
  00060	c5 fe 6f 85 60
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T11[ebp]
  00068	c5 fe 7f 45 c0	 vmovdqu YMMWORD PTR _yC_coeff$[ebp], ymm0

; 967  :     const __m256i yC_0x8000 = _mm256_slli_epi16(_mm256_cmpeq_epi32(y0, y0), 15);

  0006d	c5 fe 6f 45 e0	 vmovdqu ymm0, YMMWORD PTR _y0$[ebp]
  00072	c5 fd 76 45 e0	 vpcmpeqd ymm0, ymm0, YMMWORD PTR _y0$[ebp]
  00077	c5 fe 7f 85 20
	ff ff ff	 vmovdqu YMMWORD PTR $T10[ebp], ymm0
  0007f	c5 fe 6f 85 20
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T10[ebp]
  00087	c5 fd 71 f0 0f	 vpsllw	 ymm0, ymm0, 15		; 0000000fH
  0008c	c5 fe 7f 85 00
	ff ff ff	 vmovdqu YMMWORD PTR $T9[ebp], ymm0
  00094	c5 fe 6f 85 00
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T9[ebp]
  0009c	c5 fe 7f 85 40
	ff ff ff	 vmovdqu YMMWORD PTR _yC_0x8000$[ebp], ymm0

; 968  :     __m256i y1;
; 969  :     y0 = _mm256_add_epi16(y0, yC_0x8000); // -32768

  000a4	c5 fe 6f 45 e0	 vmovdqu ymm0, YMMWORD PTR _y0$[ebp]
  000a9	c5 fd fd 85 40
	ff ff ff	 vpaddw	 ymm0, ymm0, YMMWORD PTR _yC_0x8000$[ebp]
  000b1	c5 fe 7f 85 c0
	fe ff ff	 vmovdqu YMMWORD PTR $T8[ebp], ymm0
  000b9	c5 fe 6f 85 c0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T8[ebp]
  000c1	c5 fe 7f 45 e0	 vmovdqu YMMWORD PTR _y0$[ebp], ymm0

; 970  :     y1 = _mm256_unpackhi_epi16(y0, yC_0x8000);

  000c6	c5 fe 6f 45 e0	 vmovdqu ymm0, YMMWORD PTR _y0$[ebp]
  000cb	c5 fd 69 85 40
	ff ff ff	 vpunpckhwd ymm0, ymm0, YMMWORD PTR _yC_0x8000$[ebp]
  000d3	c5 fe 7f 85 a0
	fe ff ff	 vmovdqu YMMWORD PTR $T7[ebp], ymm0
  000db	c5 fe 6f 85 a0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T7[ebp]
  000e3	c5 fe 7f 85 e0
	fe ff ff	 vmovdqu YMMWORD PTR _y1$[ebp], ymm0

; 971  :     y0 = _mm256_unpacklo_epi16(y0, yC_0x8000);

  000eb	c5 fe 6f 45 e0	 vmovdqu ymm0, YMMWORD PTR _y0$[ebp]
  000f0	c5 fd 61 85 40
	ff ff ff	 vpunpcklwd ymm0, ymm0, YMMWORD PTR _yC_0x8000$[ebp]
  000f8	c5 fe 7f 85 80
	fe ff ff	 vmovdqu YMMWORD PTR $T6[ebp], ymm0
  00100	c5 fe 6f 85 80
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T6[ebp]
  00108	c5 fe 7f 45 e0	 vmovdqu YMMWORD PTR _y0$[ebp], ymm0

; 972  :     y0 = _mm256_madd_epi16(y0, yC_coeff);

  0010d	c5 fe 6f 45 e0	 vmovdqu ymm0, YMMWORD PTR _y0$[ebp]
  00112	c5 fd f5 45 c0	 vpmaddwd ymm0, ymm0, YMMWORD PTR _yC_coeff$[ebp]
  00117	c5 fe 7f 85 60
	fe ff ff	 vmovdqu YMMWORD PTR $T5[ebp], ymm0
  0011f	c5 fe 6f 85 60
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T5[ebp]
  00127	c5 fe 7f 45 e0	 vmovdqu YMMWORD PTR _y0$[ebp], ymm0

; 973  :     y1 = _mm256_madd_epi16(y1, yC_coeff);

  0012c	c5 fe 6f 85 e0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR _y1$[ebp]
  00134	c5 fd f5 45 c0	 vpmaddwd ymm0, ymm0, YMMWORD PTR _yC_coeff$[ebp]
  00139	c5 fe 7f 85 40
	fe ff ff	 vmovdqu YMMWORD PTR $T4[ebp], ymm0
  00141	c5 fe 6f 85 40
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T4[ebp]
  00149	c5 fe 7f 85 e0
	fe ff ff	 vmovdqu YMMWORD PTR _y1$[ebp], ymm0

; 974  :     y0 = _mm256_srai_epi32(y0, 16);

  00151	c5 fe 6f 45 e0	 vmovdqu ymm0, YMMWORD PTR _y0$[ebp]
  00156	c5 fd 72 e0 10	 vpsrad	 ymm0, ymm0, 16		; 00000010H
  0015b	c5 fe 7f 85 20
	fe ff ff	 vmovdqu YMMWORD PTR $T3[ebp], ymm0
  00163	c5 fe 6f 85 20
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T3[ebp]
  0016b	c5 fe 7f 45 e0	 vmovdqu YMMWORD PTR _y0$[ebp], ymm0

; 975  :     y1 = _mm256_srai_epi32(y1, 16);

  00170	c5 fe 6f 85 e0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR _y1$[ebp]
  00178	c5 fd 72 e0 10	 vpsrad	 ymm0, ymm0, 16		; 00000010H
  0017d	c5 fe 7f 85 00
	fe ff ff	 vmovdqu YMMWORD PTR $T2[ebp], ymm0
  00185	c5 fe 6f 85 00
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T2[ebp]
  0018d	c5 fe 7f 85 e0
	fe ff ff	 vmovdqu YMMWORD PTR _y1$[ebp], ymm0

; 976  :     y0 = _mm256_packs_epi32(y0, y1);

  00195	c5 fe 6f 45 e0	 vmovdqu ymm0, YMMWORD PTR _y0$[ebp]
  0019a	c5 fd 6b 85 e0
	fe ff ff	 vpackssdw ymm0, ymm0, YMMWORD PTR _y1$[ebp]
  001a2	c5 fe 7f 85 e0
	fd ff ff	 vmovdqu YMMWORD PTR $T1[ebp], ymm0
  001aa	c5 fe 6f 85 e0
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T1[ebp]
  001b2	c5 fe 7f 45 e0	 vmovdqu YMMWORD PTR _y0$[ebp], ymm0

; 977  :     return y0;

  001b7	c5 fe 6f 45 e0	 vmovdqu ymm0, YMMWORD PTR _y0$[ebp]

; 978  : }

  001bc	5f		 pop	 edi
  001bd	8b e5		 mov	 esp, ebp
  001bf	5d		 pop	 ebp
  001c0	8b e3		 mov	 esp, ebx
  001c2	5b		 pop	 ebx
  001c3	c3		 ret	 0
?convert_uv_range_to_yc48@@YA?AT__m256i@@T1@@Z ENDP	; convert_uv_range_to_yc48
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
$T1 = -288						; size = 32
$T2 = -256						; size = 32
$T3 = -224						; size = 32
$T4 = -192						; size = 32
$T5 = -160						; size = 32
$T6 = -128						; size = 32
$T7 = -96						; size = 32
_yC_0x8000$ = -64					; size = 32
_y0$ = -32						; size = 32
?convert_y_range_to_yc48@@YA?AT__m256i@@T1@@Z PROC	; convert_y_range_to_yc48
; _y0$ = ymm0

; 953  : static __forceinline __m256i convert_y_range_to_yc48(__m256i y0) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 20 01 00
	00		 sub	 esp, 288		; 00000120H
  0001c	57		 push	 edi
  0001d	8d bd e0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-288]
  00023	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	c5 fc 11 45 e0	 vmovups YMMWORD PTR _y0$[ebp], ymm0

; 954  :     //coef = 4788
; 955  :     //((( y - 32768 ) * coef) >> 16 ) + (coef/2 - 299)
; 956  :     const __m256i yC_0x8000 = _mm256_slli_epi16(_mm256_cmpeq_epi32(y0, y0), 15);

  00034	c5 fe 6f 45 e0	 vmovdqu ymm0, YMMWORD PTR _y0$[ebp]
  00039	c5 fd 76 45 e0	 vpcmpeqd ymm0, ymm0, YMMWORD PTR _y0$[ebp]
  0003e	c5 fe 7f 45 a0	 vmovdqu YMMWORD PTR $T7[ebp], ymm0
  00043	c5 fe 6f 45 a0	 vmovdqu ymm0, YMMWORD PTR $T7[ebp]
  00048	c5 fd 71 f0 0f	 vpsllw	 ymm0, ymm0, 15		; 0000000fH
  0004d	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR $T6[ebp], ymm0
  00052	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR $T6[ebp]
  00057	c5 fe 7f 45 c0	 vmovdqu YMMWORD PTR _yC_0x8000$[ebp], ymm0

; 957  :     y0 = _mm256_add_epi16(y0, yC_0x8000); // -32768

  0005c	c5 fe 6f 45 e0	 vmovdqu ymm0, YMMWORD PTR _y0$[ebp]
  00061	c5 fd fd 45 c0	 vpaddw	 ymm0, ymm0, YMMWORD PTR _yC_0x8000$[ebp]
  00066	c5 fe 7f 85 60
	ff ff ff	 vmovdqu YMMWORD PTR $T5[ebp], ymm0
  0006e	c5 fe 6f 85 60
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T5[ebp]
  00076	c5 fe 7f 45 e0	 vmovdqu YMMWORD PTR _y0$[ebp], ymm0

; 958  :     y0 = _mm256_mulhi_epi16(y0, _mm256_set1_epi16(4788));

  0007b	c5 fe 6f 05 00
	00 00 00	 vmovdqu ymm0, YMMWORD PTR __ymm@12b412b412b412b412b412b412b412b412b412b412b412b412b412b412b412b4
  00083	c5 fe 7f 85 40
	ff ff ff	 vmovdqu YMMWORD PTR $T4[ebp], ymm0
  0008b	c5 fe 6f 45 e0	 vmovdqu ymm0, YMMWORD PTR _y0$[ebp]
  00090	c5 fd e5 85 40
	ff ff ff	 vpmulhw ymm0, ymm0, YMMWORD PTR $T4[ebp]
  00098	c5 fe 7f 85 20
	ff ff ff	 vmovdqu YMMWORD PTR $T3[ebp], ymm0
  000a0	c5 fe 6f 85 20
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T3[ebp]
  000a8	c5 fe 7f 45 e0	 vmovdqu YMMWORD PTR _y0$[ebp], ymm0

; 959  :     y0 = _mm256_adds_epi16(y0, _mm256_set1_epi16(4788/2 - 299));

  000ad	c5 fe 6f 05 00
	00 00 00	 vmovdqu ymm0, YMMWORD PTR __ymm@082f082f082f082f082f082f082f082f082f082f082f082f082f082f082f082f
  000b5	c5 fe 7f 85 00
	ff ff ff	 vmovdqu YMMWORD PTR $T2[ebp], ymm0
  000bd	c5 fe 6f 45 e0	 vmovdqu ymm0, YMMWORD PTR _y0$[ebp]
  000c2	c5 fd ed 85 00
	ff ff ff	 vpaddsw ymm0, ymm0, YMMWORD PTR $T2[ebp]
  000ca	c5 fe 7f 85 e0
	fe ff ff	 vmovdqu YMMWORD PTR $T1[ebp], ymm0
  000d2	c5 fe 6f 85 e0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T1[ebp]
  000da	c5 fe 7f 45 e0	 vmovdqu YMMWORD PTR _y0$[ebp], ymm0

; 960  :     return y0;

  000df	c5 fe 6f 45 e0	 vmovdqu ymm0, YMMWORD PTR _y0$[ebp]

; 961  : }

  000e4	5f		 pop	 edi
  000e5	8b e5		 mov	 esp, ebp
  000e7	5d		 pop	 ebp
  000e8	8b e3		 mov	 esp, ebx
  000ea	5b		 pop	 ebx
  000eb	c3		 ret	 0
?convert_y_range_to_yc48@@YA?AT__m256i@@T1@@Z ENDP	; convert_y_range_to_yc48
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
$T1 = -736						; size = 32
$T2 = -704						; size = 32
$T3 = -672						; size = 32
$T4 = -640						; size = 32
$T5 = -608						; size = 32
$T6 = -576						; size = 32
$T7 = -544						; size = 32
$T8 = -512						; size = 32
$T9 = -480						; size = 32
$T10 = -448						; size = 32
$T11 = -416						; size = 32
$T12 = -384						; size = 32
$T13 = -352						; size = 32
$T14 = -320						; size = 32
$T15 = -288						; size = 32
$T16 = -256						; size = 32
$T17 = -224						; size = 32
_y7$ = -192						; size = 32
_y6$ = -160						; size = 32
_y3$ = -128						; size = 32
_y2$ = -96						; size = 32
_y1$ = -64						; size = 32
_y0$ = -32						; size = 32
_yC_UV_OFFSET_x1$ = 8					; size = 4
_yC_UV_MA_16_0$ = 12					; size = 4
_yC_UV_MA_16_1$ = 16					; size = 4
_UV_RSH_16$ = 20					; size = 4
_yC_YCC$ = 24						; size = 4
_yC_pw_one$ = 28					; size = 4
?convert_uv_range_from_yc48_420i@@YA?AT__m256i@@T1@0ABT1@11H11@Z PROC ; convert_uv_range_from_yc48_420i
; _y0$ = ymm0
; _y1$ = ymm1

; 926  : static __forceinline __m256i convert_uv_range_from_yc48_420i(__m256i y0, __m256i y1, const __m256i& yC_UV_OFFSET_x1, const __m256i& yC_UV_MA_16_0, const __m256i& yC_UV_MA_16_1, int UV_RSH_16, const __m256i& yC_YCC, const __m256i& yC_pw_one) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec e0 02 00
	00		 sub	 esp, 736		; 000002e0H
  0001c	57		 push	 edi
  0001d	8d bd 20 fd ff
	ff		 lea	 edi, DWORD PTR [ebp-736]
  00023	b9 b8 00 00 00	 mov	 ecx, 184		; 000000b8H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	c5 fc 11 4d c0	 vmovups YMMWORD PTR _y1$[ebp], ymm1
  00034	c5 fc 11 45 e0	 vmovups YMMWORD PTR _y0$[ebp], ymm0

; 927  :     __m256i y2, y3, y6, y7;
; 928  : 
; 929  :     y0 = _mm256_add_epi16(y0, yC_UV_OFFSET_x1);

  00039	8b 43 08	 mov	 eax, DWORD PTR _yC_UV_OFFSET_x1$[ebx]
  0003c	c5 fe 6f 45 e0	 vmovdqu ymm0, YMMWORD PTR _y0$[ebp]
  00041	c5 fd fd 00	 vpaddw	 ymm0, ymm0, YMMWORD PTR [eax]
  00045	c5 fe 7f 85 20
	ff ff ff	 vmovdqu YMMWORD PTR $T17[ebp], ymm0
  0004d	c5 fe 6f 85 20
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T17[ebp]
  00055	c5 fe 7f 45 e0	 vmovdqu YMMWORD PTR _y0$[ebp], ymm0

; 930  :     y1 = _mm256_add_epi16(y1, yC_UV_OFFSET_x1);

  0005a	8b 4b 08	 mov	 ecx, DWORD PTR _yC_UV_OFFSET_x1$[ebx]
  0005d	c5 fe 6f 45 c0	 vmovdqu ymm0, YMMWORD PTR _y1$[ebp]
  00062	c5 fd fd 01	 vpaddw	 ymm0, ymm0, YMMWORD PTR [ecx]
  00066	c5 fe 7f 85 00
	ff ff ff	 vmovdqu YMMWORD PTR $T16[ebp], ymm0
  0006e	c5 fe 6f 85 00
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T16[ebp]
  00076	c5 fe 7f 45 c0	 vmovdqu YMMWORD PTR _y1$[ebp], ymm0

; 931  : 
; 932  :     y7 = _mm256_unpackhi_epi16(y0, yC_pw_one);

  0007b	8b 53 1c	 mov	 edx, DWORD PTR _yC_pw_one$[ebx]
  0007e	c5 fe 6f 45 e0	 vmovdqu ymm0, YMMWORD PTR _y0$[ebp]
  00083	c5 fd 69 02	 vpunpckhwd ymm0, ymm0, YMMWORD PTR [edx]
  00087	c5 fe 7f 85 e0
	fe ff ff	 vmovdqu YMMWORD PTR $T15[ebp], ymm0
  0008f	c5 fe 6f 85 e0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T15[ebp]
  00097	c5 fe 7f 85 40
	ff ff ff	 vmovdqu YMMWORD PTR _y7$[ebp], ymm0

; 933  :     y6 = _mm256_unpacklo_epi16(y0, yC_pw_one);

  0009f	8b 43 1c	 mov	 eax, DWORD PTR _yC_pw_one$[ebx]
  000a2	c5 fe 6f 45 e0	 vmovdqu ymm0, YMMWORD PTR _y0$[ebp]
  000a7	c5 fd 61 00	 vpunpcklwd ymm0, ymm0, YMMWORD PTR [eax]
  000ab	c5 fe 7f 85 c0
	fe ff ff	 vmovdqu YMMWORD PTR $T14[ebp], ymm0
  000b3	c5 fe 6f 85 c0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T14[ebp]
  000bb	c5 fe 7f 85 60
	ff ff ff	 vmovdqu YMMWORD PTR _y6$[ebp], ymm0

; 934  :     y3 = _mm256_unpackhi_epi16(y1, yC_pw_one);

  000c3	8b 4b 1c	 mov	 ecx, DWORD PTR _yC_pw_one$[ebx]
  000c6	c5 fe 6f 45 c0	 vmovdqu ymm0, YMMWORD PTR _y1$[ebp]
  000cb	c5 fd 69 01	 vpunpckhwd ymm0, ymm0, YMMWORD PTR [ecx]
  000cf	c5 fe 7f 85 a0
	fe ff ff	 vmovdqu YMMWORD PTR $T13[ebp], ymm0
  000d7	c5 fe 6f 85 a0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T13[ebp]
  000df	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _y3$[ebp], ymm0

; 935  :     y2 = _mm256_unpacklo_epi16(y1, yC_pw_one);

  000e4	8b 53 1c	 mov	 edx, DWORD PTR _yC_pw_one$[ebx]
  000e7	c5 fe 6f 45 c0	 vmovdqu ymm0, YMMWORD PTR _y1$[ebp]
  000ec	c5 fd 61 02	 vpunpcklwd ymm0, ymm0, YMMWORD PTR [edx]
  000f0	c5 fe 7f 85 80
	fe ff ff	 vmovdqu YMMWORD PTR $T12[ebp], ymm0
  000f8	c5 fe 6f 85 80
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T12[ebp]
  00100	c5 fe 7f 45 a0	 vmovdqu YMMWORD PTR _y2$[ebp], ymm0

; 936  : 
; 937  :     y6 = _mm256_madd_epi16(y6, yC_UV_MA_16_0);

  00105	8b 43 0c	 mov	 eax, DWORD PTR _yC_UV_MA_16_0$[ebx]
  00108	c5 fe 6f 85 60
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR _y6$[ebp]
  00110	c5 fd f5 00	 vpmaddwd ymm0, ymm0, YMMWORD PTR [eax]
  00114	c5 fe 7f 85 60
	fe ff ff	 vmovdqu YMMWORD PTR $T11[ebp], ymm0
  0011c	c5 fe 6f 85 60
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T11[ebp]
  00124	c5 fe 7f 85 60
	ff ff ff	 vmovdqu YMMWORD PTR _y6$[ebp], ymm0

; 938  :     y7 = _mm256_madd_epi16(y7, yC_UV_MA_16_0);

  0012c	8b 4b 0c	 mov	 ecx, DWORD PTR _yC_UV_MA_16_0$[ebx]
  0012f	c5 fe 6f 85 40
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR _y7$[ebp]
  00137	c5 fd f5 01	 vpmaddwd ymm0, ymm0, YMMWORD PTR [ecx]
  0013b	c5 fe 7f 85 40
	fe ff ff	 vmovdqu YMMWORD PTR $T10[ebp], ymm0
  00143	c5 fe 6f 85 40
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T10[ebp]
  0014b	c5 fe 7f 85 40
	ff ff ff	 vmovdqu YMMWORD PTR _y7$[ebp], ymm0

; 939  :     y2 = _mm256_madd_epi16(y2, yC_UV_MA_16_1);

  00153	8b 53 10	 mov	 edx, DWORD PTR _yC_UV_MA_16_1$[ebx]
  00156	c5 fe 6f 45 a0	 vmovdqu ymm0, YMMWORD PTR _y2$[ebp]
  0015b	c5 fd f5 02	 vpmaddwd ymm0, ymm0, YMMWORD PTR [edx]
  0015f	c5 fe 7f 85 20
	fe ff ff	 vmovdqu YMMWORD PTR $T9[ebp], ymm0
  00167	c5 fe 6f 85 20
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T9[ebp]
  0016f	c5 fe 7f 45 a0	 vmovdqu YMMWORD PTR _y2$[ebp], ymm0

; 940  :     y3 = _mm256_madd_epi16(y3, yC_UV_MA_16_1);

  00174	8b 43 10	 mov	 eax, DWORD PTR _yC_UV_MA_16_1$[ebx]
  00177	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR _y3$[ebp]
  0017c	c5 fd f5 00	 vpmaddwd ymm0, ymm0, YMMWORD PTR [eax]
  00180	c5 fe 7f 85 00
	fe ff ff	 vmovdqu YMMWORD PTR $T8[ebp], ymm0
  00188	c5 fe 6f 85 00
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T8[ebp]
  00190	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _y3$[ebp], ymm0

; 941  :     y0 = _mm256_add_epi32(y6, y2);

  00195	c5 fe 6f 85 60
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR _y6$[ebp]
  0019d	c5 fd fe 45 a0	 vpaddd	 ymm0, ymm0, YMMWORD PTR _y2$[ebp]
  001a2	c5 fe 7f 85 e0
	fd ff ff	 vmovdqu YMMWORD PTR $T7[ebp], ymm0
  001aa	c5 fe 6f 85 e0
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T7[ebp]
  001b2	c5 fe 7f 45 e0	 vmovdqu YMMWORD PTR _y0$[ebp], ymm0

; 942  :     y7 = _mm256_add_epi32(y7, y3);

  001b7	c5 fe 6f 85 40
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR _y7$[ebp]
  001bf	c5 fd fe 45 80	 vpaddd	 ymm0, ymm0, YMMWORD PTR _y3$[ebp]
  001c4	c5 fe 7f 85 c0
	fd ff ff	 vmovdqu YMMWORD PTR $T6[ebp], ymm0
  001cc	c5 fe 6f 85 c0
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T6[ebp]
  001d4	c5 fe 7f 85 40
	ff ff ff	 vmovdqu YMMWORD PTR _y7$[ebp], ymm0

; 943  :     y0 = _mm256_srai_epi32(y0, UV_RSH_16);

  001dc	8b 4b 14	 mov	 ecx, DWORD PTR _UV_RSH_16$[ebx]
  001df	c5 fe 6f 45 e0	 vmovdqu ymm0, YMMWORD PTR _y0$[ebp]
  001e4	66 0f 6e c9	 movd	 xmm1, ecx
  001e8	c5 fd e2 c1	 vpsrad	 ymm0, ymm0, xmm1
  001ec	c5 fe 7f 85 a0
	fd ff ff	 vmovdqu YMMWORD PTR $T5[ebp], ymm0
  001f4	c5 fe 6f 85 a0
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T5[ebp]
  001fc	c5 fe 7f 45 e0	 vmovdqu YMMWORD PTR _y0$[ebp], ymm0

; 944  :     y7 = _mm256_srai_epi32(y7, UV_RSH_16);

  00201	8b 53 14	 mov	 edx, DWORD PTR _UV_RSH_16$[ebx]
  00204	c5 fe 6f 85 40
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR _y7$[ebp]
  0020c	66 0f 6e ca	 movd	 xmm1, edx
  00210	c5 fd e2 c1	 vpsrad	 ymm0, ymm0, xmm1
  00214	c5 fe 7f 85 80
	fd ff ff	 vmovdqu YMMWORD PTR $T4[ebp], ymm0
  0021c	c5 fe 6f 85 80
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T4[ebp]
  00224	c5 fe 7f 85 40
	ff ff ff	 vmovdqu YMMWORD PTR _y7$[ebp], ymm0

; 945  :     y0 = _mm256_add_epi32(y0, yC_YCC);

  0022c	8b 43 18	 mov	 eax, DWORD PTR _yC_YCC$[ebx]
  0022f	c5 fe 6f 45 e0	 vmovdqu ymm0, YMMWORD PTR _y0$[ebp]
  00234	c5 fd fe 00	 vpaddd	 ymm0, ymm0, YMMWORD PTR [eax]
  00238	c5 fe 7f 85 60
	fd ff ff	 vmovdqu YMMWORD PTR $T3[ebp], ymm0
  00240	c5 fe 6f 85 60
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T3[ebp]
  00248	c5 fe 7f 45 e0	 vmovdqu YMMWORD PTR _y0$[ebp], ymm0

; 946  :     y7 = _mm256_add_epi32(y7, yC_YCC);

  0024d	8b 4b 18	 mov	 ecx, DWORD PTR _yC_YCC$[ebx]
  00250	c5 fe 6f 85 40
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR _y7$[ebp]
  00258	c5 fd fe 01	 vpaddd	 ymm0, ymm0, YMMWORD PTR [ecx]
  0025c	c5 fe 7f 85 40
	fd ff ff	 vmovdqu YMMWORD PTR $T2[ebp], ymm0
  00264	c5 fe 6f 85 40
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T2[ebp]
  0026c	c5 fe 7f 85 40
	ff ff ff	 vmovdqu YMMWORD PTR _y7$[ebp], ymm0

; 947  : 
; 948  :     y0 = _mm256_packus_epi32(y0, y7);

  00274	c5 fe 6f 45 e0	 vmovdqu ymm0, YMMWORD PTR _y0$[ebp]
  00279	c4 e2 7d 2b 85
	40 ff ff ff	 vpackusdw ymm0, ymm0, YMMWORD PTR _y7$[ebp]
  00282	c5 fe 7f 85 20
	fd ff ff	 vmovdqu YMMWORD PTR $T1[ebp], ymm0
  0028a	c5 fe 6f 85 20
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T1[ebp]
  00292	c5 fe 7f 45 e0	 vmovdqu YMMWORD PTR _y0$[ebp], ymm0

; 949  : 
; 950  :     return y0;

  00297	c5 fe 6f 45 e0	 vmovdqu ymm0, YMMWORD PTR _y0$[ebp]

; 951  : }

  0029c	5f		 pop	 edi
  0029d	8b e5		 mov	 esp, ebp
  0029f	5d		 pop	 ebp
  002a0	8b e3		 mov	 esp, ebx
  002a2	5b		 pop	 ebx
  002a3	c3		 ret	 0
?convert_uv_range_from_yc48_420i@@YA?AT__m256i@@T1@0ABT1@11H11@Z ENDP ; convert_uv_range_from_yc48_420i
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
$T1 = -256						; size = 32
$T2 = -224						; size = 32
$T3 = -192						; size = 32
_yC_UV_MA_16$ = -128					; size = 32
_y1$ = -64						; size = 32
_y0$ = -32						; size = 32
_yC_UV_OFFSET_x2$ = 8					; size = 4
_UV_RSH_16$ = 12					; size = 4
_yC_YCC$ = 16						; size = 4
_yC_pw_one$ = 20					; size = 4
?convert_uv_range_from_yc48_yuv420p@@YA?AT__m256i@@T1@0ABT1@0H11@Z PROC ; convert_uv_range_from_yc48_yuv420p
; _y0$ = ymm0
; _y1$ = ymm1
; _yC_UV_MA_16$ = ymm2

; 920  : static __forceinline __m256i convert_uv_range_from_yc48_yuv420p(__m256i y0, __m256i y1, const __m256i& yC_UV_OFFSET_x2, __m256i yC_UV_MA_16, int UV_RSH_16, const __m256i& yC_YCC, const __m256i& yC_pw_one) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 00 01 00
	00		 sub	 esp, 256		; 00000100H
  0001c	57		 push	 edi
  0001d	8d bd 00 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-256]
  00023	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	c5 fc 11 55 80	 vmovups YMMWORD PTR _yC_UV_MA_16$[ebp], ymm2
  00034	c5 fc 11 4d c0	 vmovups YMMWORD PTR _y1$[ebp], ymm1
  00039	c5 fc 11 45 e0	 vmovups YMMWORD PTR _y0$[ebp], ymm0

; 921  :     y0 = _mm256_add_epi16(y0, y1);

  0003e	c5 fe 6f 45 e0	 vmovdqu ymm0, YMMWORD PTR _y0$[ebp]
  00043	c5 fd fd 45 c0	 vpaddw	 ymm0, ymm0, YMMWORD PTR _y1$[ebp]
  00048	c5 fe 7f 85 40
	ff ff ff	 vmovdqu YMMWORD PTR $T3[ebp], ymm0
  00050	c5 fe 6f 85 40
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T3[ebp]
  00058	c5 fe 7f 45 e0	 vmovdqu YMMWORD PTR _y0$[ebp], ymm0

; 922  :     y0 = _mm256_add_epi16(y0, yC_UV_OFFSET_x2);

  0005d	8b 43 08	 mov	 eax, DWORD PTR _yC_UV_OFFSET_x2$[ebx]
  00060	c5 fe 6f 45 e0	 vmovdqu ymm0, YMMWORD PTR _y0$[ebp]
  00065	c5 fd fd 00	 vpaddw	 ymm0, ymm0, YMMWORD PTR [eax]
  00069	c5 fe 7f 85 20
	ff ff ff	 vmovdqu YMMWORD PTR $T2[ebp], ymm0
  00071	c5 fe 6f 85 20
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T2[ebp]
  00079	c5 fe 7f 45 e0	 vmovdqu YMMWORD PTR _y0$[ebp], ymm0

; 923  : 
; 924  :     return convert_uv_range_after_adding_offset(y0, yC_UV_MA_16, UV_RSH_16, yC_YCC, yC_pw_one);

  0007e	8b 4b 14	 mov	 ecx, DWORD PTR _yC_pw_one$[ebx]
  00081	51		 push	 ecx
  00082	8b 53 10	 mov	 edx, DWORD PTR _yC_YCC$[ebx]
  00085	52		 push	 edx
  00086	8b 43 0c	 mov	 eax, DWORD PTR _UV_RSH_16$[ebx]
  00089	50		 push	 eax
  0008a	8d 4d 80	 lea	 ecx, DWORD PTR _yC_UV_MA_16$[ebp]
  0008d	51		 push	 ecx
  0008e	c5 fe 6f 45 e0	 vmovdqu ymm0, YMMWORD PTR _y0$[ebp]
  00093	e8 00 00 00 00	 call	 ?convert_uv_range_after_adding_offset@@YA?AT__m256i@@T1@ABT1@H11@Z ; convert_uv_range_after_adding_offset
  00098	83 c4 10	 add	 esp, 16			; 00000010H
  0009b	c5 fe 7f 85 00
	ff ff ff	 vmovdqu YMMWORD PTR $T1[ebp], ymm0
  000a3	c5 fe 6f 85 00
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T1[ebp]

; 925  : }

  000ab	52		 push	 edx
  000ac	8b cd		 mov	 ecx, ebp
  000ae	50		 push	 eax
  000af	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@convert_uv
  000b5	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000ba	58		 pop	 eax
  000bb	5a		 pop	 edx
  000bc	5f		 pop	 edi
  000bd	8b e5		 mov	 esp, ebp
  000bf	5d		 pop	 ebp
  000c0	8b e3		 mov	 esp, ebx
  000c2	5b		 pop	 ebx
  000c3	c3		 ret	 0
$LN5@convert_uv:
  000c4	01 00 00 00	 DD	 1
  000c8	00 00 00 00	 DD	 $LN4@convert_uv
$LN4@convert_uv:
  000cc	80 ff ff ff	 DD	 -128			; ffffff80H
  000d0	20 00 00 00	 DD	 32			; 00000020H
  000d4	00 00 00 00	 DD	 $LN3@convert_uv
$LN3@convert_uv:
  000d8	79		 DB	 121			; 00000079H
  000d9	43		 DB	 67			; 00000043H
  000da	5f		 DB	 95			; 0000005fH
  000db	55		 DB	 85			; 00000055H
  000dc	56		 DB	 86			; 00000056H
  000dd	5f		 DB	 95			; 0000005fH
  000de	4d		 DB	 77			; 0000004dH
  000df	41		 DB	 65			; 00000041H
  000e0	5f		 DB	 95			; 0000005fH
  000e1	31		 DB	 49			; 00000031H
  000e2	36		 DB	 54			; 00000036H
  000e3	00		 DB	 0
?convert_uv_range_from_yc48_yuv420p@@YA?AT__m256i@@T1@0ABT1@0H11@Z ENDP ; convert_uv_range_from_yc48_yuv420p
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
$T1 = -96						; size = 32
$T2 = -64						; size = 32
_y0$ = -32						; size = 32
_yC_UV_OFFSET_x1$ = 8					; size = 4
_yC_UV_MA_16$ = 12					; size = 4
_UV_RSH_16$ = 16					; size = 4
_yC_YCC$ = 20						; size = 4
_yC_pw_one$ = 24					; size = 4
?convert_uv_range_from_yc48@@YA?AT__m256i@@T1@ABT1@1H11@Z PROC ; convert_uv_range_from_yc48
; _y0$ = ymm0

; 915  : static __forceinline __m256i convert_uv_range_from_yc48(__m256i y0, const __m256i& yC_UV_OFFSET_x1, const __m256i& yC_UV_MA_16, int UV_RSH_16, const __m256i& yC_YCC, const __m256i& yC_pw_one) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	83 ec 60	 sub	 esp, 96			; 00000060H
  00019	57		 push	 edi
  0001a	8d 7d a0	 lea	 edi, DWORD PTR [ebp-96]
  0001d	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  00022	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00027	f3 ab		 rep stosd
  00029	c5 fc 11 45 e0	 vmovups YMMWORD PTR _y0$[ebp], ymm0

; 916  :     y0 = _mm256_add_epi16(y0, yC_UV_OFFSET_x1);

  0002e	8b 43 08	 mov	 eax, DWORD PTR _yC_UV_OFFSET_x1$[ebx]
  00031	c5 fe 6f 45 e0	 vmovdqu ymm0, YMMWORD PTR _y0$[ebp]
  00036	c5 fd fd 00	 vpaddw	 ymm0, ymm0, YMMWORD PTR [eax]
  0003a	c5 fe 7f 45 c0	 vmovdqu YMMWORD PTR $T2[ebp], ymm0
  0003f	c5 fe 6f 45 c0	 vmovdqu ymm0, YMMWORD PTR $T2[ebp]
  00044	c5 fe 7f 45 e0	 vmovdqu YMMWORD PTR _y0$[ebp], ymm0

; 917  : 
; 918  :     return convert_uv_range_after_adding_offset(y0, yC_UV_MA_16, UV_RSH_16, yC_YCC, yC_pw_one);

  00049	8b 4b 18	 mov	 ecx, DWORD PTR _yC_pw_one$[ebx]
  0004c	51		 push	 ecx
  0004d	8b 53 14	 mov	 edx, DWORD PTR _yC_YCC$[ebx]
  00050	52		 push	 edx
  00051	8b 43 10	 mov	 eax, DWORD PTR _UV_RSH_16$[ebx]
  00054	50		 push	 eax
  00055	8b 4b 0c	 mov	 ecx, DWORD PTR _yC_UV_MA_16$[ebx]
  00058	51		 push	 ecx
  00059	c5 fe 6f 45 e0	 vmovdqu ymm0, YMMWORD PTR _y0$[ebp]
  0005e	e8 00 00 00 00	 call	 ?convert_uv_range_after_adding_offset@@YA?AT__m256i@@T1@ABT1@H11@Z ; convert_uv_range_after_adding_offset
  00063	83 c4 10	 add	 esp, 16			; 00000010H
  00066	c5 fe 7f 45 a0	 vmovdqu YMMWORD PTR $T1[ebp], ymm0
  0006b	c5 fe 6f 45 a0	 vmovdqu ymm0, YMMWORD PTR $T1[ebp]

; 919  : }

  00070	5f		 pop	 edi
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	8b e3		 mov	 esp, ebx
  00076	5b		 pop	 ebx
  00077	c3		 ret	 0
?convert_uv_range_from_yc48@@YA?AT__m256i@@T1@ABT1@1H11@Z ENDP ; convert_uv_range_from_yc48
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
$T1 = -352						; size = 32
$T2 = -320						; size = 32
$T3 = -288						; size = 32
$T4 = -256						; size = 32
$T5 = -224						; size = 32
$T6 = -192						; size = 32
$T7 = -160						; size = 32
$T8 = -128						; size = 32
$T9 = -96						; size = 32
_y7$ = -64						; size = 32
_y0$ = -32						; size = 32
_yC_UV_MA_16$ = 8					; size = 4
_UV_RSH_16$ = 12					; size = 4
_yC_YCC$ = 16						; size = 4
_yC_pw_one$ = 20					; size = 4
?convert_uv_range_after_adding_offset@@YA?AT__m256i@@T1@ABT1@H11@Z PROC ; convert_uv_range_after_adding_offset
; _y0$ = ymm0

; 899  : static __forceinline __m256i convert_uv_range_after_adding_offset(__m256i y0, const __m256i& yC_UV_MA_16, int UV_RSH_16, const __m256i& yC_YCC, const __m256i& yC_pw_one) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 60 01 00
	00		 sub	 esp, 352		; 00000160H
  0001c	57		 push	 edi
  0001d	8d bd a0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-352]
  00023	b9 58 00 00 00	 mov	 ecx, 88			; 00000058H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	c5 fc 11 45 e0	 vmovups YMMWORD PTR _y0$[ebp], ymm0

; 900  :     __m256i y7;
; 901  :     y7 = _mm256_unpackhi_epi16(y0, yC_pw_one);

  00034	8b 43 14	 mov	 eax, DWORD PTR _yC_pw_one$[ebx]
  00037	c5 fe 6f 45 e0	 vmovdqu ymm0, YMMWORD PTR _y0$[ebp]
  0003c	c5 fd 69 00	 vpunpckhwd ymm0, ymm0, YMMWORD PTR [eax]
  00040	c5 fe 7f 45 a0	 vmovdqu YMMWORD PTR $T9[ebp], ymm0
  00045	c5 fe 6f 45 a0	 vmovdqu ymm0, YMMWORD PTR $T9[ebp]
  0004a	c5 fe 7f 45 c0	 vmovdqu YMMWORD PTR _y7$[ebp], ymm0

; 902  :     y0 = _mm256_unpacklo_epi16(y0, yC_pw_one);

  0004f	8b 4b 14	 mov	 ecx, DWORD PTR _yC_pw_one$[ebx]
  00052	c5 fe 6f 45 e0	 vmovdqu ymm0, YMMWORD PTR _y0$[ebp]
  00057	c5 fd 61 01	 vpunpcklwd ymm0, ymm0, YMMWORD PTR [ecx]
  0005b	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR $T8[ebp], ymm0
  00060	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR $T8[ebp]
  00065	c5 fe 7f 45 e0	 vmovdqu YMMWORD PTR _y0$[ebp], ymm0

; 903  : 
; 904  :     y0 = _mm256_madd_epi16(y0, yC_UV_MA_16);

  0006a	8b 53 08	 mov	 edx, DWORD PTR _yC_UV_MA_16$[ebx]
  0006d	c5 fe 6f 45 e0	 vmovdqu ymm0, YMMWORD PTR _y0$[ebp]
  00072	c5 fd f5 02	 vpmaddwd ymm0, ymm0, YMMWORD PTR [edx]
  00076	c5 fe 7f 85 60
	ff ff ff	 vmovdqu YMMWORD PTR $T7[ebp], ymm0
  0007e	c5 fe 6f 85 60
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T7[ebp]
  00086	c5 fe 7f 45 e0	 vmovdqu YMMWORD PTR _y0$[ebp], ymm0

; 905  :     y7 = _mm256_madd_epi16(y7, yC_UV_MA_16);

  0008b	8b 43 08	 mov	 eax, DWORD PTR _yC_UV_MA_16$[ebx]
  0008e	c5 fe 6f 45 c0	 vmovdqu ymm0, YMMWORD PTR _y7$[ebp]
  00093	c5 fd f5 00	 vpmaddwd ymm0, ymm0, YMMWORD PTR [eax]
  00097	c5 fe 7f 85 40
	ff ff ff	 vmovdqu YMMWORD PTR $T6[ebp], ymm0
  0009f	c5 fe 6f 85 40
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T6[ebp]
  000a7	c5 fe 7f 45 c0	 vmovdqu YMMWORD PTR _y7$[ebp], ymm0

; 906  :     y0 = _mm256_srai_epi32(y0, UV_RSH_16);

  000ac	8b 4b 0c	 mov	 ecx, DWORD PTR _UV_RSH_16$[ebx]
  000af	c5 fe 6f 45 e0	 vmovdqu ymm0, YMMWORD PTR _y0$[ebp]
  000b4	66 0f 6e c9	 movd	 xmm1, ecx
  000b8	c5 fd e2 c1	 vpsrad	 ymm0, ymm0, xmm1
  000bc	c5 fe 7f 85 20
	ff ff ff	 vmovdqu YMMWORD PTR $T5[ebp], ymm0
  000c4	c5 fe 6f 85 20
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T5[ebp]
  000cc	c5 fe 7f 45 e0	 vmovdqu YMMWORD PTR _y0$[ebp], ymm0

; 907  :     y7 = _mm256_srai_epi32(y7, UV_RSH_16);

  000d1	8b 53 0c	 mov	 edx, DWORD PTR _UV_RSH_16$[ebx]
  000d4	c5 fe 6f 45 c0	 vmovdqu ymm0, YMMWORD PTR _y7$[ebp]
  000d9	66 0f 6e ca	 movd	 xmm1, edx
  000dd	c5 fd e2 c1	 vpsrad	 ymm0, ymm0, xmm1
  000e1	c5 fe 7f 85 00
	ff ff ff	 vmovdqu YMMWORD PTR $T4[ebp], ymm0
  000e9	c5 fe 6f 85 00
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T4[ebp]
  000f1	c5 fe 7f 45 c0	 vmovdqu YMMWORD PTR _y7$[ebp], ymm0

; 908  :     y0 = _mm256_add_epi32(y0, yC_YCC);

  000f6	8b 43 10	 mov	 eax, DWORD PTR _yC_YCC$[ebx]
  000f9	c5 fe 6f 45 e0	 vmovdqu ymm0, YMMWORD PTR _y0$[ebp]
  000fe	c5 fd fe 00	 vpaddd	 ymm0, ymm0, YMMWORD PTR [eax]
  00102	c5 fe 7f 85 e0
	fe ff ff	 vmovdqu YMMWORD PTR $T3[ebp], ymm0
  0010a	c5 fe 6f 85 e0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T3[ebp]
  00112	c5 fe 7f 45 e0	 vmovdqu YMMWORD PTR _y0$[ebp], ymm0

; 909  :     y7 = _mm256_add_epi32(y7, yC_YCC);

  00117	8b 4b 10	 mov	 ecx, DWORD PTR _yC_YCC$[ebx]
  0011a	c5 fe 6f 45 c0	 vmovdqu ymm0, YMMWORD PTR _y7$[ebp]
  0011f	c5 fd fe 01	 vpaddd	 ymm0, ymm0, YMMWORD PTR [ecx]
  00123	c5 fe 7f 85 c0
	fe ff ff	 vmovdqu YMMWORD PTR $T2[ebp], ymm0
  0012b	c5 fe 6f 85 c0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T2[ebp]
  00133	c5 fe 7f 45 c0	 vmovdqu YMMWORD PTR _y7$[ebp], ymm0

; 910  : 
; 911  :     y0 = _mm256_packus_epi32(y0, y7);

  00138	c5 fe 6f 45 e0	 vmovdqu ymm0, YMMWORD PTR _y0$[ebp]
  0013d	c4 e2 7d 2b 45
	c0		 vpackusdw ymm0, ymm0, YMMWORD PTR _y7$[ebp]
  00143	c5 fe 7f 85 a0
	fe ff ff	 vmovdqu YMMWORD PTR $T1[ebp], ymm0
  0014b	c5 fe 6f 85 a0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T1[ebp]
  00153	c5 fe 7f 45 e0	 vmovdqu YMMWORD PTR _y0$[ebp], ymm0

; 912  : 
; 913  :     return y0;

  00158	c5 fe 6f 45 e0	 vmovdqu ymm0, YMMWORD PTR _y0$[ebp]

; 914  : }

  0015d	5f		 pop	 edi
  0015e	8b e5		 mov	 esp, ebp
  00160	5d		 pop	 ebp
  00161	8b e3		 mov	 esp, ebx
  00163	5b		 pop	 ebx
  00164	c3		 ret	 0
?convert_uv_range_after_adding_offset@@YA?AT__m256i@@T1@ABT1@H11@Z ENDP ; convert_uv_range_after_adding_offset
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
$T1 = -384						; size = 32
$T2 = -352						; size = 32
$T3 = -320						; size = 32
$T4 = -288						; size = 32
$T5 = -256						; size = 32
$T6 = -224						; size = 32
$T7 = -192						; size = 32
$T8 = -160						; size = 32
$T9 = -128						; size = 32
_y7$ = -96						; size = 32
_yC_Y_MA_16$ = -64					; size = 32
_y0$ = -32						; size = 32
_Y_RSH_16$ = 8						; size = 4
_yC_YCC$ = 12						; size = 4
_yC_pw_one$ = 16					; size = 4
?convert_y_range_from_yc48@@YA?AT__m256i@@T1@0HABT1@1@Z PROC ; convert_y_range_from_yc48
; _y0$ = ymm0
; _yC_Y_MA_16$ = ymm1

; 882  : static __forceinline __m256i convert_y_range_from_yc48(__m256i y0, __m256i yC_Y_MA_16, int Y_RSH_16, const __m256i& yC_YCC, const __m256i& yC_pw_one) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 80 01 00
	00		 sub	 esp, 384		; 00000180H
  0001c	57		 push	 edi
  0001d	8d bd 80 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-384]
  00023	b9 60 00 00 00	 mov	 ecx, 96			; 00000060H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	c5 fc 11 4d c0	 vmovups YMMWORD PTR _yC_Y_MA_16$[ebp], ymm1
  00034	c5 fc 11 45 e0	 vmovups YMMWORD PTR _y0$[ebp], ymm0

; 883  :     __m256i y7;
; 884  : 
; 885  :     y7 = _mm256_unpackhi_epi16(y0, yC_pw_one);

  00039	8b 43 10	 mov	 eax, DWORD PTR _yC_pw_one$[ebx]
  0003c	c5 fe 6f 45 e0	 vmovdqu ymm0, YMMWORD PTR _y0$[ebp]
  00041	c5 fd 69 00	 vpunpckhwd ymm0, ymm0, YMMWORD PTR [eax]
  00045	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR $T9[ebp], ymm0
  0004a	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR $T9[ebp]
  0004f	c5 fe 7f 45 a0	 vmovdqu YMMWORD PTR _y7$[ebp], ymm0

; 886  :     y0 = _mm256_unpacklo_epi16(y0, yC_pw_one);

  00054	8b 4b 10	 mov	 ecx, DWORD PTR _yC_pw_one$[ebx]
  00057	c5 fe 6f 45 e0	 vmovdqu ymm0, YMMWORD PTR _y0$[ebp]
  0005c	c5 fd 61 01	 vpunpcklwd ymm0, ymm0, YMMWORD PTR [ecx]
  00060	c5 fe 7f 85 60
	ff ff ff	 vmovdqu YMMWORD PTR $T8[ebp], ymm0
  00068	c5 fe 6f 85 60
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T8[ebp]
  00070	c5 fe 7f 45 e0	 vmovdqu YMMWORD PTR _y0$[ebp], ymm0

; 887  : 
; 888  :     y0 = _mm256_madd_epi16(y0, yC_Y_MA_16);

  00075	c5 fe 6f 45 e0	 vmovdqu ymm0, YMMWORD PTR _y0$[ebp]
  0007a	c5 fd f5 45 c0	 vpmaddwd ymm0, ymm0, YMMWORD PTR _yC_Y_MA_16$[ebp]
  0007f	c5 fe 7f 85 40
	ff ff ff	 vmovdqu YMMWORD PTR $T7[ebp], ymm0
  00087	c5 fe 6f 85 40
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T7[ebp]
  0008f	c5 fe 7f 45 e0	 vmovdqu YMMWORD PTR _y0$[ebp], ymm0

; 889  :     y7 = _mm256_madd_epi16(y7, yC_Y_MA_16);

  00094	c5 fe 6f 45 a0	 vmovdqu ymm0, YMMWORD PTR _y7$[ebp]
  00099	c5 fd f5 45 c0	 vpmaddwd ymm0, ymm0, YMMWORD PTR _yC_Y_MA_16$[ebp]
  0009e	c5 fe 7f 85 20
	ff ff ff	 vmovdqu YMMWORD PTR $T6[ebp], ymm0
  000a6	c5 fe 6f 85 20
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T6[ebp]
  000ae	c5 fe 7f 45 a0	 vmovdqu YMMWORD PTR _y7$[ebp], ymm0

; 890  :     y0 = _mm256_srai_epi32(y0, Y_RSH_16);

  000b3	8b 53 08	 mov	 edx, DWORD PTR _Y_RSH_16$[ebx]
  000b6	c5 fe 6f 45 e0	 vmovdqu ymm0, YMMWORD PTR _y0$[ebp]
  000bb	66 0f 6e ca	 movd	 xmm1, edx
  000bf	c5 fd e2 c1	 vpsrad	 ymm0, ymm0, xmm1
  000c3	c5 fe 7f 85 00
	ff ff ff	 vmovdqu YMMWORD PTR $T5[ebp], ymm0
  000cb	c5 fe 6f 85 00
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T5[ebp]
  000d3	c5 fe 7f 45 e0	 vmovdqu YMMWORD PTR _y0$[ebp], ymm0

; 891  :     y7 = _mm256_srai_epi32(y7, Y_RSH_16);

  000d8	8b 43 08	 mov	 eax, DWORD PTR _Y_RSH_16$[ebx]
  000db	c5 fe 6f 45 a0	 vmovdqu ymm0, YMMWORD PTR _y7$[ebp]
  000e0	66 0f 6e c8	 movd	 xmm1, eax
  000e4	c5 fd e2 c1	 vpsrad	 ymm0, ymm0, xmm1
  000e8	c5 fe 7f 85 e0
	fe ff ff	 vmovdqu YMMWORD PTR $T4[ebp], ymm0
  000f0	c5 fe 6f 85 e0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T4[ebp]
  000f8	c5 fe 7f 45 a0	 vmovdqu YMMWORD PTR _y7$[ebp], ymm0

; 892  :     y0 = _mm256_add_epi32(y0, yC_YCC);

  000fd	8b 4b 0c	 mov	 ecx, DWORD PTR _yC_YCC$[ebx]
  00100	c5 fe 6f 45 e0	 vmovdqu ymm0, YMMWORD PTR _y0$[ebp]
  00105	c5 fd fe 01	 vpaddd	 ymm0, ymm0, YMMWORD PTR [ecx]
  00109	c5 fe 7f 85 c0
	fe ff ff	 vmovdqu YMMWORD PTR $T3[ebp], ymm0
  00111	c5 fe 6f 85 c0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T3[ebp]
  00119	c5 fe 7f 45 e0	 vmovdqu YMMWORD PTR _y0$[ebp], ymm0

; 893  :     y7 = _mm256_add_epi32(y7, yC_YCC);

  0011e	8b 53 0c	 mov	 edx, DWORD PTR _yC_YCC$[ebx]
  00121	c5 fe 6f 45 a0	 vmovdqu ymm0, YMMWORD PTR _y7$[ebp]
  00126	c5 fd fe 02	 vpaddd	 ymm0, ymm0, YMMWORD PTR [edx]
  0012a	c5 fe 7f 85 a0
	fe ff ff	 vmovdqu YMMWORD PTR $T2[ebp], ymm0
  00132	c5 fe 6f 85 a0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T2[ebp]
  0013a	c5 fe 7f 45 a0	 vmovdqu YMMWORD PTR _y7$[ebp], ymm0

; 894  : 
; 895  :     y0 = _mm256_packus_epi32(y0, y7);

  0013f	c5 fe 6f 45 e0	 vmovdqu ymm0, YMMWORD PTR _y0$[ebp]
  00144	c4 e2 7d 2b 45
	a0		 vpackusdw ymm0, ymm0, YMMWORD PTR _y7$[ebp]
  0014a	c5 fe 7f 85 80
	fe ff ff	 vmovdqu YMMWORD PTR $T1[ebp], ymm0
  00152	c5 fe 6f 85 80
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T1[ebp]
  0015a	c5 fe 7f 45 e0	 vmovdqu YMMWORD PTR _y0$[ebp], ymm0

; 896  : 
; 897  :     return y0;

  0015f	c5 fe 6f 45 e0	 vmovdqu ymm0, YMMWORD PTR _y0$[ebp]

; 898  : }

  00164	5f		 pop	 edi
  00165	8b e5		 mov	 esp, ebp
  00167	5d		 pop	 ebp
  00168	8b e3		 mov	 esp, ebx
  0016a	5b		 pop	 ebx
  0016b	c3		 ret	 0
?convert_y_range_from_yc48@@YA?AT__m256i@@T1@0HABT1@1@Z ENDP ; convert_y_range_from_yc48
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
$T1 = -512						; size = 32
$T2 = -480						; size = 32
$T3 = -448						; size = 32
$T4 = -416						; size = 32
$T5 = -384						; size = 32
$T6 = -352						; size = 32
$T7 = -320						; size = 32
$T8 = -288						; size = 32
$T9 = -256						; size = 32
$T10 = -224						; size = 32
$T11 = -192						; size = 32
_y5$ = -160						; size = 32
_y4$ = -128						; size = 32
_y3$ = -96						; size = 32
_MASK_INT_UV$ = -40					; size = 4
_MASK_INT_Y$ = -36					; size = 4
_y2$ = -32						; size = 32
_y0$ = 8						; size = 4
_y1$ = 12						; size = 4
?gather_y_uv_from_yc48@@YAXAAT__m256i@@0T1@@Z PROC	; gather_y_uv_from_yc48
; _y2$ = ymm0

; 860  : static __forceinline void gather_y_uv_from_yc48(__m256i& y0, __m256i& y1, __m256i y2) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 00 02 00
	00		 sub	 esp, 512		; 00000200H
  0001c	57		 push	 edi
  0001d	8d bd 00 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-512]
  00023	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	c5 fc 11 45 e0	 vmovups YMMWORD PTR _y2$[ebp], ymm0

; 861  :     const int MASK_INT_Y  = 0x80 + 0x10 + 0x02;

  00034	c7 45 dc 92 00
	00 00		 mov	 DWORD PTR _MASK_INT_Y$[ebp], 146 ; 00000092H

; 862  :     const int MASK_INT_UV = 0x40 + 0x20 + 0x01;

  0003b	c7 45 d8 61 00
	00 00		 mov	 DWORD PTR _MASK_INT_UV$[ebp], 97 ; 00000061H

; 863  :     __m256i y3 = y0;

  00042	8b 43 08	 mov	 eax, DWORD PTR _y0$[ebx]
  00045	c5 fe 6f 00	 vmovdqu ymm0, YMMWORD PTR [eax]
  00049	c5 fe 7f 45 a0	 vmovdqu YMMWORD PTR _y3$[ebp], ymm0

; 864  :     __m256i y4 = y1;

  0004e	8b 4b 0c	 mov	 ecx, DWORD PTR _y1$[ebx]
  00051	c5 fe 6f 01	 vmovdqu ymm0, YMMWORD PTR [ecx]
  00055	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _y4$[ebp], ymm0

; 865  :     __m256i y5 = y2;

  0005a	c5 fe 6f 45 e0	 vmovdqu ymm0, YMMWORD PTR _y2$[ebp]
  0005f	c5 fe 7f 85 60
	ff ff ff	 vmovdqu YMMWORD PTR _y5$[ebp], ymm0

; 866  : 
; 867  :     y0 = _mm256_blend_epi32(y3, y4, 0xf0);                    // 384, 0

  00067	c5 fe 6f 45 a0	 vmovdqu ymm0, YMMWORD PTR _y3$[ebp]
  0006c	c4 e3 7d 02 45
	80 f0		 vpblendd ymm0, ymm0, YMMWORD PTR _y4$[ebp], 240 ; 000000f0H
  00073	c5 fe 7f 85 40
	ff ff ff	 vmovdqu YMMWORD PTR $T11[ebp], ymm0
  0007b	8b 53 08	 mov	 edx, DWORD PTR _y0$[ebx]
  0007e	c5 fe 6f 85 40
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T11[ebp]
  00086	c5 fe 7f 02	 vmovdqu YMMWORD PTR [edx], ymm0

; 868  :     y1 = _mm256_permute2x128_si256(y3, y5, (0x02<<4) + 0x01); // 512, 128

  0008a	c5 fe 6f 45 a0	 vmovdqu ymm0, YMMWORD PTR _y3$[ebp]
  0008f	c4 e3 7d 46 85
	60 ff ff ff 21	 vperm2i128 ymm0, ymm0, YMMWORD PTR _y5$[ebp], 33 ; 00000021H
  00099	c5 fe 7f 85 20
	ff ff ff	 vmovdqu YMMWORD PTR $T10[ebp], ymm0
  000a1	8b 43 0c	 mov	 eax, DWORD PTR _y1$[ebx]
  000a4	c5 fe 6f 85 20
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T10[ebp]
  000ac	c5 fe 7f 00	 vmovdqu YMMWORD PTR [eax], ymm0

; 869  :     y2 = _mm256_blend_epi32(y4, y5, 0xf0);                    // 640, 256

  000b0	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR _y4$[ebp]
  000b5	c4 e3 7d 02 85
	60 ff ff ff f0	 vpblendd ymm0, ymm0, YMMWORD PTR _y5$[ebp], 240 ; 000000f0H
  000bf	c5 fe 7f 85 00
	ff ff ff	 vmovdqu YMMWORD PTR $T9[ebp], ymm0
  000c7	c5 fe 6f 85 00
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T9[ebp]
  000cf	c5 fe 7f 45 e0	 vmovdqu YMMWORD PTR _y2$[ebp], ymm0

; 870  : 
; 871  :     y3 = _mm256_blend_epi16(y0, y1, MASK_INT_Y);

  000d4	8b 4b 0c	 mov	 ecx, DWORD PTR _y1$[ebx]
  000d7	8b 53 08	 mov	 edx, DWORD PTR _y0$[ebx]
  000da	c5 fe 6f 02	 vmovdqu ymm0, YMMWORD PTR [edx]
  000de	c4 e3 7d 0e 01
	92		 vpblendw ymm0, ymm0, YMMWORD PTR [ecx], 146 ; 00000092H
  000e4	c5 fe 7f 85 e0
	fe ff ff	 vmovdqu YMMWORD PTR $T8[ebp], ymm0
  000ec	c5 fe 6f 85 e0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T8[ebp]
  000f4	c5 fe 7f 45 a0	 vmovdqu YMMWORD PTR _y3$[ebp], ymm0

; 872  :     y3 = _mm256_blend_epi16(y3, y2, MASK_INT_Y>>2);

  000f9	c5 fe 6f 45 a0	 vmovdqu ymm0, YMMWORD PTR _y3$[ebp]
  000fe	c4 e3 7d 0e 45
	e0 24		 vpblendw ymm0, ymm0, YMMWORD PTR _y2$[ebp], 36 ; 00000024H
  00105	c5 fe 7f 85 c0
	fe ff ff	 vmovdqu YMMWORD PTR $T7[ebp], ymm0
  0010d	c5 fe 6f 85 c0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T7[ebp]
  00115	c5 fe 7f 45 a0	 vmovdqu YMMWORD PTR _y3$[ebp], ymm0

; 873  : 
; 874  :     y1 = _mm256_blend_epi16(y0, y1, MASK_INT_UV);

  0011a	8b 43 0c	 mov	 eax, DWORD PTR _y1$[ebx]
  0011d	8b 4b 08	 mov	 ecx, DWORD PTR _y0$[ebx]
  00120	c5 fe 6f 01	 vmovdqu ymm0, YMMWORD PTR [ecx]
  00124	c4 e3 7d 0e 00
	61		 vpblendw ymm0, ymm0, YMMWORD PTR [eax], 97 ; 00000061H
  0012a	c5 fe 7f 85 a0
	fe ff ff	 vmovdqu YMMWORD PTR $T6[ebp], ymm0
  00132	8b 53 0c	 mov	 edx, DWORD PTR _y1$[ebx]
  00135	c5 fe 6f 85 a0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T6[ebp]
  0013d	c5 fe 7f 02	 vmovdqu YMMWORD PTR [edx], ymm0

; 875  :     y1 = _mm256_blend_epi16(y1, y2, MASK_INT_UV>>2);

  00141	8b 43 0c	 mov	 eax, DWORD PTR _y1$[ebx]
  00144	c5 fe 6f 00	 vmovdqu ymm0, YMMWORD PTR [eax]
  00148	c4 e3 7d 0e 45
	e0 18		 vpblendw ymm0, ymm0, YMMWORD PTR _y2$[ebp], 24 ; 00000018H
  0014f	c5 fe 7f 85 80
	fe ff ff	 vmovdqu YMMWORD PTR $T5[ebp], ymm0
  00157	8b 4b 0c	 mov	 ecx, DWORD PTR _y1$[ebx]
  0015a	c5 fe 6f 85 80
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T5[ebp]
  00162	c5 fe 7f 01	 vmovdqu YMMWORD PTR [ecx], ymm0

; 876  :     y1 = _mm256_alignr_epi8(y1, y1, 2);

  00166	8b 53 0c	 mov	 edx, DWORD PTR _y1$[ebx]
  00169	8b 43 0c	 mov	 eax, DWORD PTR _y1$[ebx]
  0016c	c5 fe 6f 00	 vmovdqu ymm0, YMMWORD PTR [eax]
  00170	c4 e3 7d 0f 02
	02		 vpalignr ymm0, ymm0, YMMWORD PTR [edx], 2
  00176	c5 fe 7f 85 60
	fe ff ff	 vmovdqu YMMWORD PTR $T4[ebp], ymm0
  0017e	8b 4b 0c	 mov	 ecx, DWORD PTR _y1$[ebx]
  00181	c5 fe 6f 85 60
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T4[ebp]
  00189	c5 fe 7f 01	 vmovdqu YMMWORD PTR [ecx], ymm0

; 877  :     y1 = _mm256_shuffle_epi32(y1, _MM_SHUFFLE(1, 2, 3, 0));//UV1

  0018d	8b 53 0c	 mov	 edx, DWORD PTR _y1$[ebx]
  00190	c5 fd 70 02 6c	 vpshufd ymm0, YMMWORD PTR [edx], 108 ; 0000006cH
  00195	c5 fe 7f 85 40
	fe ff ff	 vmovdqu YMMWORD PTR $T3[ebp], ymm0
  0019d	8b 43 0c	 mov	 eax, DWORD PTR _y1$[ebx]
  001a0	c5 fe 6f 85 40
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T3[ebp]
  001a8	c5 fe 7f 00	 vmovdqu YMMWORD PTR [eax], ymm0

; 878  : 
; 879  :     y0 = _mm256_shuffle_epi8(y3, yC_SUFFLE_YCP_Y);

  001ac	c5 fd 6f 05 00
	00 00 00	 vmovdqa ymm0, YMMWORD PTR ?Array_SUFFLE_YCP_Y@@3QBEB
  001b4	c5 fe 7f 85 20
	fe ff ff	 vmovdqu YMMWORD PTR $T2[ebp], ymm0
  001bc	c5 fe 6f 45 a0	 vmovdqu ymm0, YMMWORD PTR _y3$[ebp]
  001c1	c4 e2 7d 00 85
	20 fe ff ff	 vpshufb ymm0, ymm0, YMMWORD PTR $T2[ebp]
  001ca	c5 fe 7f 85 00
	fe ff ff	 vmovdqu YMMWORD PTR $T1[ebp], ymm0
  001d2	8b 4b 08	 mov	 ecx, DWORD PTR _y0$[ebx]
  001d5	c5 fe 6f 85 00
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T1[ebp]
  001dd	c5 fe 7f 01	 vmovdqu YMMWORD PTR [ecx], ymm0

; 880  : }

  001e1	5f		 pop	 edi
  001e2	8b e5		 mov	 esp, ebp
  001e4	5d		 pop	 ebp
  001e5	8b e3		 mov	 esp, ebx
  001e7	5b		 pop	 ebx
  001e8	c3		 ret	 0
?gather_y_uv_from_yc48@@YAXAAT__m256i@@0T1@@Z ENDP	; gather_y_uv_from_yc48
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
$T1 = -528						; size = 12
$T2 = -512						; size = 32
$T3 = -480						; size = 32
$T4 = -448						; size = 32
$T5 = -416						; size = 32
$T6 = -368						; size = 16
$T7 = -352						; size = 32
$T8 = -304						; size = 16
_y1$9 = -288						; size = 32
$T10 = -256						; size = 32
$T11 = -208						; size = 16
$T12 = -192						; size = 32
$T13 = -144						; size = 16
_y0$14 = -128						; size = 32
_x$15 = -88						; size = 4
_dst_ptr$16 = -84					; size = 4
_src_ptr$17 = -80					; size = 4
_y$18 = -76						; size = 4
_y_width$19 = -72					; size = 4
_dstLine$20 = -68					; size = 4
_srcYLine$21 = -64					; size = 4
_i$22 = -60						; size = 4
$T23 = -56						; size = 12
_y_range$ = -40						; size = 12
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yuv444_high_to_yuv444_avx2_base@$08@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_high_to_yuv444_avx2_base<9>

; 810  : static void __forceinline convert_yuv444_high_to_yuv444_avx2_base(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 20 02 00
	00		 sub	 esp, 544		; 00000220H
  0001c	57		 push	 edi
  0001d	8d bd e0 fd ff
	ff		 lea	 edi, DWORD PTR [ebp-544]
  00023	b9 88 00 00 00	 mov	 ecx, 136		; 00000088H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 811  :     static_assert(8 < in_bit_depth && in_bit_depth <= 16, "in_bit_depth must be 9-16.");
; 812  :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 813  :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 814  :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 815  :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 816  :     const int src_y_pitch = src_y_pitch_byte >> 1;

  0007c	8b 53 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  0007f	d1 fa		 sar	 edx, 1
  00081	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 817  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00084	8b 43 2c	 mov	 eax, DWORD PTR _thread_n$[ebx]
  00087	50		 push	 eax
  00088	8b 4b 28	 mov	 ecx, DWORD PTR _thread_id$[ebx]
  0008b	51		 push	 ecx
  0008c	8b 53 20	 mov	 edx, DWORD PTR _height$[ebx]
  0008f	2b 55 ec	 sub	 edx, DWORD PTR _crop_bottom$[ebp]
  00092	52		 push	 edx
  00093	8b 45 f4	 mov	 eax, DWORD PTR _crop_up$[ebp]
  00096	50		 push	 eax
  00097	8d 8d f0 fd ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  0009d	51		 push	 ecx
  0009e	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  000a3	83 c4 14	 add	 esp, 20			; 00000014H
  000a6	8b 10		 mov	 edx, DWORD PTR [eax]
  000a8	89 55 c8	 mov	 DWORD PTR $T23[ebp], edx
  000ab	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ae	89 4d cc	 mov	 DWORD PTR $T23[ebp+4], ecx
  000b1	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000b4	89 55 d0	 mov	 DWORD PTR $T23[ebp+8], edx
  000b7	8b 45 c8	 mov	 eax, DWORD PTR $T23[ebp]
  000ba	89 45 d8	 mov	 DWORD PTR _y_range$[ebp], eax
  000bd	8b 4d cc	 mov	 ecx, DWORD PTR $T23[ebp+4]
  000c0	89 4d dc	 mov	 DWORD PTR _y_range$[ebp+4], ecx
  000c3	8b 55 d0	 mov	 edx, DWORD PTR $T23[ebp+8]
  000c6	89 55 e0	 mov	 DWORD PTR _y_range$[ebp+8], edx

; 818  :     for (int i = 0; i < 3; i++) {

  000c9	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _i$22[ebp], 0
  000d0	eb 09		 jmp	 SHORT $LN4@convert_yu
$LN2@convert_yu:
  000d2	8b 45 c4	 mov	 eax, DWORD PTR _i$22[ebp]
  000d5	83 c0 01	 add	 eax, 1
  000d8	89 45 c4	 mov	 DWORD PTR _i$22[ebp], eax
$LN4@convert_yu:
  000db	83 7d c4 03	 cmp	 DWORD PTR _i$22[ebp], 3
  000df	0f 8d d9 01 00
	00		 jge	 $LN1@convert_yu

; 819  :         uint16_t *srcYLine = (uint16_t *)src[i] + src_y_pitch * y_range.start_src + crop_left;

  000e5	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  000e8	0f af 4d d8	 imul	 ecx, DWORD PTR _y_range$[ebp]
  000ec	8b 55 c4	 mov	 edx, DWORD PTR _i$22[ebp]
  000ef	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  000f2	8b 14 90	 mov	 edx, DWORD PTR [eax+edx*4]
  000f5	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  000f8	8b 4d f8	 mov	 ecx, DWORD PTR _crop_left$[ebp]
  000fb	8d 14 48	 lea	 edx, DWORD PTR [eax+ecx*2]
  000fe	89 55 c0	 mov	 DWORD PTR _srcYLine$21[ebp], edx

; 820  :         uint8_t *dstLine = (uint8_t *)dst[i] + dst_y_pitch_byte * y_range.start_dst;

  00101	8b 43 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  00104	0f af 45 dc	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  00108	8b 4d c4	 mov	 ecx, DWORD PTR _i$22[ebp]
  0010b	8b 53 08	 mov	 edx, DWORD PTR _dst$[ebx]
  0010e	03 04 8a	 add	 eax, DWORD PTR [edx+ecx*4]
  00111	89 45 bc	 mov	 DWORD PTR _dstLine$20[ebp], eax

; 821  :         const int y_width = width - crop_right - crop_left;

  00114	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  00117	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  0011a	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  0011d	89 45 b8	 mov	 DWORD PTR _y_width$19[ebp], eax

; 822  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch_byte) {

  00120	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _y$18[ebp], 0
  00127	eb 1e		 jmp	 SHORT $LN7@convert_yu
$LN5@convert_yu:
  00129	8b 4d b4	 mov	 ecx, DWORD PTR _y$18[ebp]
  0012c	83 c1 01	 add	 ecx, 1
  0012f	89 4d b4	 mov	 DWORD PTR _y$18[ebp], ecx
  00132	8b 55 e8	 mov	 edx, DWORD PTR _src_y_pitch$[ebp]
  00135	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$21[ebp]
  00138	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  0013b	89 4d c0	 mov	 DWORD PTR _srcYLine$21[ebp], ecx
  0013e	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$20[ebp]
  00141	03 53 1c	 add	 edx, DWORD PTR _dst_y_pitch_byte$[ebx]
  00144	89 55 bc	 mov	 DWORD PTR _dstLine$20[ebp], edx
$LN7@convert_yu:
  00147	8b 45 b4	 mov	 eax, DWORD PTR _y$18[ebp]
  0014a	3b 45 e0	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  0014d	0f 8d 66 01 00
	00		 jge	 $LN6@convert_yu

; 823  :             uint16_t *src_ptr = srcYLine;

  00153	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$21[ebp]
  00156	89 4d b0	 mov	 DWORD PTR _src_ptr$17[ebp], ecx

; 824  :             uint8_t *dst_ptr = dstLine;

  00159	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$20[ebp]
  0015c	89 55 ac	 mov	 DWORD PTR _dst_ptr$16[ebp], edx

; 825  :             for (int x = 0; x < y_width; x += 32, dst_ptr += 32, src_ptr += 32) {

  0015f	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR _x$15[ebp], 0
  00166	eb 1b		 jmp	 SHORT $LN10@convert_yu
$LN8@convert_yu:
  00168	8b 45 a8	 mov	 eax, DWORD PTR _x$15[ebp]
  0016b	83 c0 20	 add	 eax, 32			; 00000020H
  0016e	89 45 a8	 mov	 DWORD PTR _x$15[ebp], eax
  00171	8b 4d ac	 mov	 ecx, DWORD PTR _dst_ptr$16[ebp]
  00174	83 c1 20	 add	 ecx, 32			; 00000020H
  00177	89 4d ac	 mov	 DWORD PTR _dst_ptr$16[ebp], ecx
  0017a	8b 55 b0	 mov	 edx, DWORD PTR _src_ptr$17[ebp]
  0017d	83 c2 40	 add	 edx, 64			; 00000040H
  00180	89 55 b0	 mov	 DWORD PTR _src_ptr$17[ebp], edx
$LN10@convert_yu:
  00183	8b 45 a8	 mov	 eax, DWORD PTR _x$15[ebp]
  00186	3b 45 b8	 cmp	 eax, DWORD PTR _y_width$19[ebp]
  00189	0f 8d 25 01 00
	00		 jge	 $LN9@convert_yu

; 826  :                 __m256i y0 = _mm256_loadu2_m128i((const __m128i *)(src_ptr + 16), (const __m128i *)(src_ptr +  0));

  0018f	8b 4d b0	 mov	 ecx, DWORD PTR _src_ptr$17[ebp]
  00192	83 c1 20	 add	 ecx, 32			; 00000020H
  00195	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00198	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR $T11[ebp], xmm0
  0019f	8b 55 b0	 mov	 edx, DWORD PTR _src_ptr$17[ebp]
  001a2	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  001a5	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR $T13[ebp], xmm0
  001ac	c5 fa 6f 85 70
	ff ff ff	 vmovdqu xmm0, XMMWORD PTR $T13[ebp]
  001b4	c5 fe 7f 85 40
	ff ff ff	 vmovdqu YMMWORD PTR $T12[ebp], ymm0
  001bc	c5 fe 6f 85 40
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T12[ebp]
  001c4	c4 e3 7d 18 85
	30 ff ff ff 01	 vinsertf128 ymm0, ymm0, XMMWORD PTR $T11[ebp], 1
  001ce	c5 fe 7f 85 00
	ff ff ff	 vmovdqu YMMWORD PTR $T10[ebp], ymm0
  001d6	c5 fe 6f 85 00
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T10[ebp]
  001de	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _y0$14[ebp], ymm0

; 827  :                 __m256i y1 = _mm256_loadu2_m128i((const __m128i *)(src_ptr + 24), (const __m128i *)(src_ptr +  8));

  001e3	8b 45 b0	 mov	 eax, DWORD PTR _src_ptr$17[ebp]
  001e6	83 c0 30	 add	 eax, 48			; 00000030H
  001e9	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  001ec	0f 29 85 90 fe
	ff ff		 movaps	 XMMWORD PTR $T6[ebp], xmm0
  001f3	8b 4d b0	 mov	 ecx, DWORD PTR _src_ptr$17[ebp]
  001f6	83 c1 10	 add	 ecx, 16			; 00000010H
  001f9	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  001fc	0f 29 85 d0 fe
	ff ff		 movaps	 XMMWORD PTR $T8[ebp], xmm0
  00203	c5 fa 6f 85 d0
	fe ff ff	 vmovdqu xmm0, XMMWORD PTR $T8[ebp]
  0020b	c5 fe 7f 85 a0
	fe ff ff	 vmovdqu YMMWORD PTR $T7[ebp], ymm0
  00213	c5 fe 6f 85 a0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T7[ebp]
  0021b	c4 e3 7d 18 85
	90 fe ff ff 01	 vinsertf128 ymm0, ymm0, XMMWORD PTR $T6[ebp], 1
  00225	c5 fe 7f 85 60
	fe ff ff	 vmovdqu YMMWORD PTR $T5[ebp], ymm0
  0022d	c5 fe 6f 85 60
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T5[ebp]
  00235	c5 fe 7f 85 e0
	fe ff ff	 vmovdqu YMMWORD PTR _y1$9[ebp], ymm0

; 828  :                 y0 = _mm256_srli_epi16(y0, in_bit_depth - 8);

  0023d	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR _y0$14[ebp]
  00242	c5 fd 71 d0 01	 vpsrlw	 ymm0, ymm0, 1
  00247	c5 fe 7f 85 40
	fe ff ff	 vmovdqu YMMWORD PTR $T4[ebp], ymm0
  0024f	c5 fe 6f 85 40
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T4[ebp]
  00257	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _y0$14[ebp], ymm0

; 829  :                 y1 = _mm256_srli_epi16(y1, in_bit_depth - 8);

  0025c	c5 fe 6f 85 e0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR _y1$9[ebp]
  00264	c5 fd 71 d0 01	 vpsrlw	 ymm0, ymm0, 1
  00269	c5 fe 7f 85 20
	fe ff ff	 vmovdqu YMMWORD PTR $T3[ebp], ymm0
  00271	c5 fe 6f 85 20
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T3[ebp]
  00279	c5 fe 7f 85 e0
	fe ff ff	 vmovdqu YMMWORD PTR _y1$9[ebp], ymm0

; 830  :                 y0 = _mm256_packus_epi16(y0, y1);

  00281	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR _y0$14[ebp]
  00286	c5 fd 67 85 e0
	fe ff ff	 vpackuswb ymm0, ymm0, YMMWORD PTR _y1$9[ebp]
  0028e	c5 fe 7f 85 00
	fe ff ff	 vmovdqu YMMWORD PTR $T2[ebp], ymm0
  00296	c5 fe 6f 85 00
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T2[ebp]
  0029e	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _y0$14[ebp], ymm0

; 831  :                 _mm256_storeu_si256((__m256i *)dst_ptr, y0);

  002a3	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR _y0$14[ebp]
  002a8	8b 55 ac	 mov	 edx, DWORD PTR _dst_ptr$16[ebp]
  002ab	c5 fe 7f 02	 vmovdqu YMMWORD PTR [edx], ymm0

; 832  :             }

  002af	e9 b4 fe ff ff	 jmp	 $LN8@convert_yu
$LN9@convert_yu:

; 833  :         }

  002b4	e9 70 fe ff ff	 jmp	 $LN5@convert_yu
$LN6@convert_yu:

; 834  :     }

  002b9	e9 14 fe ff ff	 jmp	 $LN2@convert_yu
$LN1@convert_yu:

; 835  : }

  002be	52		 push	 edx
  002bf	8b cd		 mov	 ecx, ebp
  002c1	50		 push	 eax
  002c2	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN14@convert_yu
  002c8	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  002cd	58		 pop	 eax
  002ce	5a		 pop	 edx
  002cf	5f		 pop	 edi
  002d0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002d3	33 cd		 xor	 ecx, ebp
  002d5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002da	8b e5		 mov	 esp, ebp
  002dc	5d		 pop	 ebp
  002dd	8b e3		 mov	 esp, ebx
  002df	5b		 pop	 ebx
  002e0	c3		 ret	 0
  002e1	0f 1f 00	 npad	 3
$LN14@convert_yu:
  002e4	01 00 00 00	 DD	 1
  002e8	00 00 00 00	 DD	 $LN13@convert_yu
$LN13@convert_yu:
  002ec	d8 ff ff ff	 DD	 -40			; ffffffd8H
  002f0	0c 00 00 00	 DD	 12			; 0000000cH
  002f4	00 00 00 00	 DD	 $LN12@convert_yu
$LN12@convert_yu:
  002f8	79		 DB	 121			; 00000079H
  002f9	5f		 DB	 95			; 0000005fH
  002fa	72		 DB	 114			; 00000072H
  002fb	61		 DB	 97			; 00000061H
  002fc	6e		 DB	 110			; 0000006eH
  002fd	67		 DB	 103			; 00000067H
  002fe	65		 DB	 101			; 00000065H
  002ff	00		 DB	 0
??$convert_yuv444_high_to_yuv444_avx2_base@$08@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_high_to_yuv444_avx2_base<9>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuv444_09_to_yuv444_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_09_to_yuv444_avx2

; 854  : void convert_yuv444_09_to_yuv444_avx2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 855  :     convert_yuv444_high_to_yuv444_avx2_base<9>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yuv444_high_to_yuv444_avx2_base@$08@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_high_to_yuv444_avx2_base<9>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 856  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yuv444_09_to_yuv444_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_09_to_yuv444_avx2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
$T1 = -528						; size = 12
$T2 = -512						; size = 32
$T3 = -480						; size = 32
$T4 = -448						; size = 32
$T5 = -416						; size = 32
$T6 = -368						; size = 16
$T7 = -352						; size = 32
$T8 = -304						; size = 16
_y1$9 = -288						; size = 32
$T10 = -256						; size = 32
$T11 = -208						; size = 16
$T12 = -192						; size = 32
$T13 = -144						; size = 16
_y0$14 = -128						; size = 32
_x$15 = -88						; size = 4
_dst_ptr$16 = -84					; size = 4
_src_ptr$17 = -80					; size = 4
_y$18 = -76						; size = 4
_y_width$19 = -72					; size = 4
_dstLine$20 = -68					; size = 4
_srcYLine$21 = -64					; size = 4
_i$22 = -60						; size = 4
$T23 = -56						; size = 12
_y_range$ = -40						; size = 12
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yuv444_high_to_yuv444_avx2_base@$09@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_high_to_yuv444_avx2_base<10>

; 810  : static void __forceinline convert_yuv444_high_to_yuv444_avx2_base(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 20 02 00
	00		 sub	 esp, 544		; 00000220H
  0001c	57		 push	 edi
  0001d	8d bd e0 fd ff
	ff		 lea	 edi, DWORD PTR [ebp-544]
  00023	b9 88 00 00 00	 mov	 ecx, 136		; 00000088H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 811  :     static_assert(8 < in_bit_depth && in_bit_depth <= 16, "in_bit_depth must be 9-16.");
; 812  :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 813  :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 814  :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 815  :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 816  :     const int src_y_pitch = src_y_pitch_byte >> 1;

  0007c	8b 53 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  0007f	d1 fa		 sar	 edx, 1
  00081	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 817  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00084	8b 43 2c	 mov	 eax, DWORD PTR _thread_n$[ebx]
  00087	50		 push	 eax
  00088	8b 4b 28	 mov	 ecx, DWORD PTR _thread_id$[ebx]
  0008b	51		 push	 ecx
  0008c	8b 53 20	 mov	 edx, DWORD PTR _height$[ebx]
  0008f	2b 55 ec	 sub	 edx, DWORD PTR _crop_bottom$[ebp]
  00092	52		 push	 edx
  00093	8b 45 f4	 mov	 eax, DWORD PTR _crop_up$[ebp]
  00096	50		 push	 eax
  00097	8d 8d f0 fd ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  0009d	51		 push	 ecx
  0009e	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  000a3	83 c4 14	 add	 esp, 20			; 00000014H
  000a6	8b 10		 mov	 edx, DWORD PTR [eax]
  000a8	89 55 c8	 mov	 DWORD PTR $T23[ebp], edx
  000ab	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ae	89 4d cc	 mov	 DWORD PTR $T23[ebp+4], ecx
  000b1	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000b4	89 55 d0	 mov	 DWORD PTR $T23[ebp+8], edx
  000b7	8b 45 c8	 mov	 eax, DWORD PTR $T23[ebp]
  000ba	89 45 d8	 mov	 DWORD PTR _y_range$[ebp], eax
  000bd	8b 4d cc	 mov	 ecx, DWORD PTR $T23[ebp+4]
  000c0	89 4d dc	 mov	 DWORD PTR _y_range$[ebp+4], ecx
  000c3	8b 55 d0	 mov	 edx, DWORD PTR $T23[ebp+8]
  000c6	89 55 e0	 mov	 DWORD PTR _y_range$[ebp+8], edx

; 818  :     for (int i = 0; i < 3; i++) {

  000c9	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _i$22[ebp], 0
  000d0	eb 09		 jmp	 SHORT $LN4@convert_yu
$LN2@convert_yu:
  000d2	8b 45 c4	 mov	 eax, DWORD PTR _i$22[ebp]
  000d5	83 c0 01	 add	 eax, 1
  000d8	89 45 c4	 mov	 DWORD PTR _i$22[ebp], eax
$LN4@convert_yu:
  000db	83 7d c4 03	 cmp	 DWORD PTR _i$22[ebp], 3
  000df	0f 8d d9 01 00
	00		 jge	 $LN1@convert_yu

; 819  :         uint16_t *srcYLine = (uint16_t *)src[i] + src_y_pitch * y_range.start_src + crop_left;

  000e5	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  000e8	0f af 4d d8	 imul	 ecx, DWORD PTR _y_range$[ebp]
  000ec	8b 55 c4	 mov	 edx, DWORD PTR _i$22[ebp]
  000ef	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  000f2	8b 14 90	 mov	 edx, DWORD PTR [eax+edx*4]
  000f5	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  000f8	8b 4d f8	 mov	 ecx, DWORD PTR _crop_left$[ebp]
  000fb	8d 14 48	 lea	 edx, DWORD PTR [eax+ecx*2]
  000fe	89 55 c0	 mov	 DWORD PTR _srcYLine$21[ebp], edx

; 820  :         uint8_t *dstLine = (uint8_t *)dst[i] + dst_y_pitch_byte * y_range.start_dst;

  00101	8b 43 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  00104	0f af 45 dc	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  00108	8b 4d c4	 mov	 ecx, DWORD PTR _i$22[ebp]
  0010b	8b 53 08	 mov	 edx, DWORD PTR _dst$[ebx]
  0010e	03 04 8a	 add	 eax, DWORD PTR [edx+ecx*4]
  00111	89 45 bc	 mov	 DWORD PTR _dstLine$20[ebp], eax

; 821  :         const int y_width = width - crop_right - crop_left;

  00114	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  00117	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  0011a	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  0011d	89 45 b8	 mov	 DWORD PTR _y_width$19[ebp], eax

; 822  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch_byte) {

  00120	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _y$18[ebp], 0
  00127	eb 1e		 jmp	 SHORT $LN7@convert_yu
$LN5@convert_yu:
  00129	8b 4d b4	 mov	 ecx, DWORD PTR _y$18[ebp]
  0012c	83 c1 01	 add	 ecx, 1
  0012f	89 4d b4	 mov	 DWORD PTR _y$18[ebp], ecx
  00132	8b 55 e8	 mov	 edx, DWORD PTR _src_y_pitch$[ebp]
  00135	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$21[ebp]
  00138	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  0013b	89 4d c0	 mov	 DWORD PTR _srcYLine$21[ebp], ecx
  0013e	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$20[ebp]
  00141	03 53 1c	 add	 edx, DWORD PTR _dst_y_pitch_byte$[ebx]
  00144	89 55 bc	 mov	 DWORD PTR _dstLine$20[ebp], edx
$LN7@convert_yu:
  00147	8b 45 b4	 mov	 eax, DWORD PTR _y$18[ebp]
  0014a	3b 45 e0	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  0014d	0f 8d 66 01 00
	00		 jge	 $LN6@convert_yu

; 823  :             uint16_t *src_ptr = srcYLine;

  00153	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$21[ebp]
  00156	89 4d b0	 mov	 DWORD PTR _src_ptr$17[ebp], ecx

; 824  :             uint8_t *dst_ptr = dstLine;

  00159	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$20[ebp]
  0015c	89 55 ac	 mov	 DWORD PTR _dst_ptr$16[ebp], edx

; 825  :             for (int x = 0; x < y_width; x += 32, dst_ptr += 32, src_ptr += 32) {

  0015f	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR _x$15[ebp], 0
  00166	eb 1b		 jmp	 SHORT $LN10@convert_yu
$LN8@convert_yu:
  00168	8b 45 a8	 mov	 eax, DWORD PTR _x$15[ebp]
  0016b	83 c0 20	 add	 eax, 32			; 00000020H
  0016e	89 45 a8	 mov	 DWORD PTR _x$15[ebp], eax
  00171	8b 4d ac	 mov	 ecx, DWORD PTR _dst_ptr$16[ebp]
  00174	83 c1 20	 add	 ecx, 32			; 00000020H
  00177	89 4d ac	 mov	 DWORD PTR _dst_ptr$16[ebp], ecx
  0017a	8b 55 b0	 mov	 edx, DWORD PTR _src_ptr$17[ebp]
  0017d	83 c2 40	 add	 edx, 64			; 00000040H
  00180	89 55 b0	 mov	 DWORD PTR _src_ptr$17[ebp], edx
$LN10@convert_yu:
  00183	8b 45 a8	 mov	 eax, DWORD PTR _x$15[ebp]
  00186	3b 45 b8	 cmp	 eax, DWORD PTR _y_width$19[ebp]
  00189	0f 8d 25 01 00
	00		 jge	 $LN9@convert_yu

; 826  :                 __m256i y0 = _mm256_loadu2_m128i((const __m128i *)(src_ptr + 16), (const __m128i *)(src_ptr +  0));

  0018f	8b 4d b0	 mov	 ecx, DWORD PTR _src_ptr$17[ebp]
  00192	83 c1 20	 add	 ecx, 32			; 00000020H
  00195	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00198	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR $T11[ebp], xmm0
  0019f	8b 55 b0	 mov	 edx, DWORD PTR _src_ptr$17[ebp]
  001a2	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  001a5	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR $T13[ebp], xmm0
  001ac	c5 fa 6f 85 70
	ff ff ff	 vmovdqu xmm0, XMMWORD PTR $T13[ebp]
  001b4	c5 fe 7f 85 40
	ff ff ff	 vmovdqu YMMWORD PTR $T12[ebp], ymm0
  001bc	c5 fe 6f 85 40
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T12[ebp]
  001c4	c4 e3 7d 18 85
	30 ff ff ff 01	 vinsertf128 ymm0, ymm0, XMMWORD PTR $T11[ebp], 1
  001ce	c5 fe 7f 85 00
	ff ff ff	 vmovdqu YMMWORD PTR $T10[ebp], ymm0
  001d6	c5 fe 6f 85 00
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T10[ebp]
  001de	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _y0$14[ebp], ymm0

; 827  :                 __m256i y1 = _mm256_loadu2_m128i((const __m128i *)(src_ptr + 24), (const __m128i *)(src_ptr +  8));

  001e3	8b 45 b0	 mov	 eax, DWORD PTR _src_ptr$17[ebp]
  001e6	83 c0 30	 add	 eax, 48			; 00000030H
  001e9	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  001ec	0f 29 85 90 fe
	ff ff		 movaps	 XMMWORD PTR $T6[ebp], xmm0
  001f3	8b 4d b0	 mov	 ecx, DWORD PTR _src_ptr$17[ebp]
  001f6	83 c1 10	 add	 ecx, 16			; 00000010H
  001f9	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  001fc	0f 29 85 d0 fe
	ff ff		 movaps	 XMMWORD PTR $T8[ebp], xmm0
  00203	c5 fa 6f 85 d0
	fe ff ff	 vmovdqu xmm0, XMMWORD PTR $T8[ebp]
  0020b	c5 fe 7f 85 a0
	fe ff ff	 vmovdqu YMMWORD PTR $T7[ebp], ymm0
  00213	c5 fe 6f 85 a0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T7[ebp]
  0021b	c4 e3 7d 18 85
	90 fe ff ff 01	 vinsertf128 ymm0, ymm0, XMMWORD PTR $T6[ebp], 1
  00225	c5 fe 7f 85 60
	fe ff ff	 vmovdqu YMMWORD PTR $T5[ebp], ymm0
  0022d	c5 fe 6f 85 60
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T5[ebp]
  00235	c5 fe 7f 85 e0
	fe ff ff	 vmovdqu YMMWORD PTR _y1$9[ebp], ymm0

; 828  :                 y0 = _mm256_srli_epi16(y0, in_bit_depth - 8);

  0023d	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR _y0$14[ebp]
  00242	c5 fd 71 d0 02	 vpsrlw	 ymm0, ymm0, 2
  00247	c5 fe 7f 85 40
	fe ff ff	 vmovdqu YMMWORD PTR $T4[ebp], ymm0
  0024f	c5 fe 6f 85 40
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T4[ebp]
  00257	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _y0$14[ebp], ymm0

; 829  :                 y1 = _mm256_srli_epi16(y1, in_bit_depth - 8);

  0025c	c5 fe 6f 85 e0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR _y1$9[ebp]
  00264	c5 fd 71 d0 02	 vpsrlw	 ymm0, ymm0, 2
  00269	c5 fe 7f 85 20
	fe ff ff	 vmovdqu YMMWORD PTR $T3[ebp], ymm0
  00271	c5 fe 6f 85 20
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T3[ebp]
  00279	c5 fe 7f 85 e0
	fe ff ff	 vmovdqu YMMWORD PTR _y1$9[ebp], ymm0

; 830  :                 y0 = _mm256_packus_epi16(y0, y1);

  00281	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR _y0$14[ebp]
  00286	c5 fd 67 85 e0
	fe ff ff	 vpackuswb ymm0, ymm0, YMMWORD PTR _y1$9[ebp]
  0028e	c5 fe 7f 85 00
	fe ff ff	 vmovdqu YMMWORD PTR $T2[ebp], ymm0
  00296	c5 fe 6f 85 00
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T2[ebp]
  0029e	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _y0$14[ebp], ymm0

; 831  :                 _mm256_storeu_si256((__m256i *)dst_ptr, y0);

  002a3	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR _y0$14[ebp]
  002a8	8b 55 ac	 mov	 edx, DWORD PTR _dst_ptr$16[ebp]
  002ab	c5 fe 7f 02	 vmovdqu YMMWORD PTR [edx], ymm0

; 832  :             }

  002af	e9 b4 fe ff ff	 jmp	 $LN8@convert_yu
$LN9@convert_yu:

; 833  :         }

  002b4	e9 70 fe ff ff	 jmp	 $LN5@convert_yu
$LN6@convert_yu:

; 834  :     }

  002b9	e9 14 fe ff ff	 jmp	 $LN2@convert_yu
$LN1@convert_yu:

; 835  : }

  002be	52		 push	 edx
  002bf	8b cd		 mov	 ecx, ebp
  002c1	50		 push	 eax
  002c2	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN14@convert_yu
  002c8	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  002cd	58		 pop	 eax
  002ce	5a		 pop	 edx
  002cf	5f		 pop	 edi
  002d0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002d3	33 cd		 xor	 ecx, ebp
  002d5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002da	8b e5		 mov	 esp, ebp
  002dc	5d		 pop	 ebp
  002dd	8b e3		 mov	 esp, ebx
  002df	5b		 pop	 ebx
  002e0	c3		 ret	 0
  002e1	0f 1f 00	 npad	 3
$LN14@convert_yu:
  002e4	01 00 00 00	 DD	 1
  002e8	00 00 00 00	 DD	 $LN13@convert_yu
$LN13@convert_yu:
  002ec	d8 ff ff ff	 DD	 -40			; ffffffd8H
  002f0	0c 00 00 00	 DD	 12			; 0000000cH
  002f4	00 00 00 00	 DD	 $LN12@convert_yu
$LN12@convert_yu:
  002f8	79		 DB	 121			; 00000079H
  002f9	5f		 DB	 95			; 0000005fH
  002fa	72		 DB	 114			; 00000072H
  002fb	61		 DB	 97			; 00000061H
  002fc	6e		 DB	 110			; 0000006eH
  002fd	67		 DB	 103			; 00000067H
  002fe	65		 DB	 101			; 00000065H
  002ff	00		 DB	 0
??$convert_yuv444_high_to_yuv444_avx2_base@$09@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_high_to_yuv444_avx2_base<10>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuv444_10_to_yuv444_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_10_to_yuv444_avx2

; 850  : void convert_yuv444_10_to_yuv444_avx2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 851  :     convert_yuv444_high_to_yuv444_avx2_base<10>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yuv444_high_to_yuv444_avx2_base@$09@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_high_to_yuv444_avx2_base<10>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 852  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yuv444_10_to_yuv444_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_10_to_yuv444_avx2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
$T1 = -528						; size = 12
$T2 = -512						; size = 32
$T3 = -480						; size = 32
$T4 = -448						; size = 32
$T5 = -416						; size = 32
$T6 = -368						; size = 16
$T7 = -352						; size = 32
$T8 = -304						; size = 16
_y1$9 = -288						; size = 32
$T10 = -256						; size = 32
$T11 = -208						; size = 16
$T12 = -192						; size = 32
$T13 = -144						; size = 16
_y0$14 = -128						; size = 32
_x$15 = -88						; size = 4
_dst_ptr$16 = -84					; size = 4
_src_ptr$17 = -80					; size = 4
_y$18 = -76						; size = 4
_y_width$19 = -72					; size = 4
_dstLine$20 = -68					; size = 4
_srcYLine$21 = -64					; size = 4
_i$22 = -60						; size = 4
$T23 = -56						; size = 12
_y_range$ = -40						; size = 12
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yuv444_high_to_yuv444_avx2_base@$0M@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_high_to_yuv444_avx2_base<12>

; 810  : static void __forceinline convert_yuv444_high_to_yuv444_avx2_base(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 20 02 00
	00		 sub	 esp, 544		; 00000220H
  0001c	57		 push	 edi
  0001d	8d bd e0 fd ff
	ff		 lea	 edi, DWORD PTR [ebp-544]
  00023	b9 88 00 00 00	 mov	 ecx, 136		; 00000088H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 811  :     static_assert(8 < in_bit_depth && in_bit_depth <= 16, "in_bit_depth must be 9-16.");
; 812  :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 813  :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 814  :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 815  :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 816  :     const int src_y_pitch = src_y_pitch_byte >> 1;

  0007c	8b 53 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  0007f	d1 fa		 sar	 edx, 1
  00081	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 817  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00084	8b 43 2c	 mov	 eax, DWORD PTR _thread_n$[ebx]
  00087	50		 push	 eax
  00088	8b 4b 28	 mov	 ecx, DWORD PTR _thread_id$[ebx]
  0008b	51		 push	 ecx
  0008c	8b 53 20	 mov	 edx, DWORD PTR _height$[ebx]
  0008f	2b 55 ec	 sub	 edx, DWORD PTR _crop_bottom$[ebp]
  00092	52		 push	 edx
  00093	8b 45 f4	 mov	 eax, DWORD PTR _crop_up$[ebp]
  00096	50		 push	 eax
  00097	8d 8d f0 fd ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  0009d	51		 push	 ecx
  0009e	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  000a3	83 c4 14	 add	 esp, 20			; 00000014H
  000a6	8b 10		 mov	 edx, DWORD PTR [eax]
  000a8	89 55 c8	 mov	 DWORD PTR $T23[ebp], edx
  000ab	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ae	89 4d cc	 mov	 DWORD PTR $T23[ebp+4], ecx
  000b1	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000b4	89 55 d0	 mov	 DWORD PTR $T23[ebp+8], edx
  000b7	8b 45 c8	 mov	 eax, DWORD PTR $T23[ebp]
  000ba	89 45 d8	 mov	 DWORD PTR _y_range$[ebp], eax
  000bd	8b 4d cc	 mov	 ecx, DWORD PTR $T23[ebp+4]
  000c0	89 4d dc	 mov	 DWORD PTR _y_range$[ebp+4], ecx
  000c3	8b 55 d0	 mov	 edx, DWORD PTR $T23[ebp+8]
  000c6	89 55 e0	 mov	 DWORD PTR _y_range$[ebp+8], edx

; 818  :     for (int i = 0; i < 3; i++) {

  000c9	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _i$22[ebp], 0
  000d0	eb 09		 jmp	 SHORT $LN4@convert_yu
$LN2@convert_yu:
  000d2	8b 45 c4	 mov	 eax, DWORD PTR _i$22[ebp]
  000d5	83 c0 01	 add	 eax, 1
  000d8	89 45 c4	 mov	 DWORD PTR _i$22[ebp], eax
$LN4@convert_yu:
  000db	83 7d c4 03	 cmp	 DWORD PTR _i$22[ebp], 3
  000df	0f 8d d9 01 00
	00		 jge	 $LN1@convert_yu

; 819  :         uint16_t *srcYLine = (uint16_t *)src[i] + src_y_pitch * y_range.start_src + crop_left;

  000e5	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  000e8	0f af 4d d8	 imul	 ecx, DWORD PTR _y_range$[ebp]
  000ec	8b 55 c4	 mov	 edx, DWORD PTR _i$22[ebp]
  000ef	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  000f2	8b 14 90	 mov	 edx, DWORD PTR [eax+edx*4]
  000f5	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  000f8	8b 4d f8	 mov	 ecx, DWORD PTR _crop_left$[ebp]
  000fb	8d 14 48	 lea	 edx, DWORD PTR [eax+ecx*2]
  000fe	89 55 c0	 mov	 DWORD PTR _srcYLine$21[ebp], edx

; 820  :         uint8_t *dstLine = (uint8_t *)dst[i] + dst_y_pitch_byte * y_range.start_dst;

  00101	8b 43 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  00104	0f af 45 dc	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  00108	8b 4d c4	 mov	 ecx, DWORD PTR _i$22[ebp]
  0010b	8b 53 08	 mov	 edx, DWORD PTR _dst$[ebx]
  0010e	03 04 8a	 add	 eax, DWORD PTR [edx+ecx*4]
  00111	89 45 bc	 mov	 DWORD PTR _dstLine$20[ebp], eax

; 821  :         const int y_width = width - crop_right - crop_left;

  00114	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  00117	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  0011a	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  0011d	89 45 b8	 mov	 DWORD PTR _y_width$19[ebp], eax

; 822  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch_byte) {

  00120	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _y$18[ebp], 0
  00127	eb 1e		 jmp	 SHORT $LN7@convert_yu
$LN5@convert_yu:
  00129	8b 4d b4	 mov	 ecx, DWORD PTR _y$18[ebp]
  0012c	83 c1 01	 add	 ecx, 1
  0012f	89 4d b4	 mov	 DWORD PTR _y$18[ebp], ecx
  00132	8b 55 e8	 mov	 edx, DWORD PTR _src_y_pitch$[ebp]
  00135	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$21[ebp]
  00138	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  0013b	89 4d c0	 mov	 DWORD PTR _srcYLine$21[ebp], ecx
  0013e	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$20[ebp]
  00141	03 53 1c	 add	 edx, DWORD PTR _dst_y_pitch_byte$[ebx]
  00144	89 55 bc	 mov	 DWORD PTR _dstLine$20[ebp], edx
$LN7@convert_yu:
  00147	8b 45 b4	 mov	 eax, DWORD PTR _y$18[ebp]
  0014a	3b 45 e0	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  0014d	0f 8d 66 01 00
	00		 jge	 $LN6@convert_yu

; 823  :             uint16_t *src_ptr = srcYLine;

  00153	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$21[ebp]
  00156	89 4d b0	 mov	 DWORD PTR _src_ptr$17[ebp], ecx

; 824  :             uint8_t *dst_ptr = dstLine;

  00159	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$20[ebp]
  0015c	89 55 ac	 mov	 DWORD PTR _dst_ptr$16[ebp], edx

; 825  :             for (int x = 0; x < y_width; x += 32, dst_ptr += 32, src_ptr += 32) {

  0015f	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR _x$15[ebp], 0
  00166	eb 1b		 jmp	 SHORT $LN10@convert_yu
$LN8@convert_yu:
  00168	8b 45 a8	 mov	 eax, DWORD PTR _x$15[ebp]
  0016b	83 c0 20	 add	 eax, 32			; 00000020H
  0016e	89 45 a8	 mov	 DWORD PTR _x$15[ebp], eax
  00171	8b 4d ac	 mov	 ecx, DWORD PTR _dst_ptr$16[ebp]
  00174	83 c1 20	 add	 ecx, 32			; 00000020H
  00177	89 4d ac	 mov	 DWORD PTR _dst_ptr$16[ebp], ecx
  0017a	8b 55 b0	 mov	 edx, DWORD PTR _src_ptr$17[ebp]
  0017d	83 c2 40	 add	 edx, 64			; 00000040H
  00180	89 55 b0	 mov	 DWORD PTR _src_ptr$17[ebp], edx
$LN10@convert_yu:
  00183	8b 45 a8	 mov	 eax, DWORD PTR _x$15[ebp]
  00186	3b 45 b8	 cmp	 eax, DWORD PTR _y_width$19[ebp]
  00189	0f 8d 25 01 00
	00		 jge	 $LN9@convert_yu

; 826  :                 __m256i y0 = _mm256_loadu2_m128i((const __m128i *)(src_ptr + 16), (const __m128i *)(src_ptr +  0));

  0018f	8b 4d b0	 mov	 ecx, DWORD PTR _src_ptr$17[ebp]
  00192	83 c1 20	 add	 ecx, 32			; 00000020H
  00195	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00198	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR $T11[ebp], xmm0
  0019f	8b 55 b0	 mov	 edx, DWORD PTR _src_ptr$17[ebp]
  001a2	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  001a5	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR $T13[ebp], xmm0
  001ac	c5 fa 6f 85 70
	ff ff ff	 vmovdqu xmm0, XMMWORD PTR $T13[ebp]
  001b4	c5 fe 7f 85 40
	ff ff ff	 vmovdqu YMMWORD PTR $T12[ebp], ymm0
  001bc	c5 fe 6f 85 40
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T12[ebp]
  001c4	c4 e3 7d 18 85
	30 ff ff ff 01	 vinsertf128 ymm0, ymm0, XMMWORD PTR $T11[ebp], 1
  001ce	c5 fe 7f 85 00
	ff ff ff	 vmovdqu YMMWORD PTR $T10[ebp], ymm0
  001d6	c5 fe 6f 85 00
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T10[ebp]
  001de	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _y0$14[ebp], ymm0

; 827  :                 __m256i y1 = _mm256_loadu2_m128i((const __m128i *)(src_ptr + 24), (const __m128i *)(src_ptr +  8));

  001e3	8b 45 b0	 mov	 eax, DWORD PTR _src_ptr$17[ebp]
  001e6	83 c0 30	 add	 eax, 48			; 00000030H
  001e9	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  001ec	0f 29 85 90 fe
	ff ff		 movaps	 XMMWORD PTR $T6[ebp], xmm0
  001f3	8b 4d b0	 mov	 ecx, DWORD PTR _src_ptr$17[ebp]
  001f6	83 c1 10	 add	 ecx, 16			; 00000010H
  001f9	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  001fc	0f 29 85 d0 fe
	ff ff		 movaps	 XMMWORD PTR $T8[ebp], xmm0
  00203	c5 fa 6f 85 d0
	fe ff ff	 vmovdqu xmm0, XMMWORD PTR $T8[ebp]
  0020b	c5 fe 7f 85 a0
	fe ff ff	 vmovdqu YMMWORD PTR $T7[ebp], ymm0
  00213	c5 fe 6f 85 a0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T7[ebp]
  0021b	c4 e3 7d 18 85
	90 fe ff ff 01	 vinsertf128 ymm0, ymm0, XMMWORD PTR $T6[ebp], 1
  00225	c5 fe 7f 85 60
	fe ff ff	 vmovdqu YMMWORD PTR $T5[ebp], ymm0
  0022d	c5 fe 6f 85 60
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T5[ebp]
  00235	c5 fe 7f 85 e0
	fe ff ff	 vmovdqu YMMWORD PTR _y1$9[ebp], ymm0

; 828  :                 y0 = _mm256_srli_epi16(y0, in_bit_depth - 8);

  0023d	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR _y0$14[ebp]
  00242	c5 fd 71 d0 04	 vpsrlw	 ymm0, ymm0, 4
  00247	c5 fe 7f 85 40
	fe ff ff	 vmovdqu YMMWORD PTR $T4[ebp], ymm0
  0024f	c5 fe 6f 85 40
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T4[ebp]
  00257	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _y0$14[ebp], ymm0

; 829  :                 y1 = _mm256_srli_epi16(y1, in_bit_depth - 8);

  0025c	c5 fe 6f 85 e0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR _y1$9[ebp]
  00264	c5 fd 71 d0 04	 vpsrlw	 ymm0, ymm0, 4
  00269	c5 fe 7f 85 20
	fe ff ff	 vmovdqu YMMWORD PTR $T3[ebp], ymm0
  00271	c5 fe 6f 85 20
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T3[ebp]
  00279	c5 fe 7f 85 e0
	fe ff ff	 vmovdqu YMMWORD PTR _y1$9[ebp], ymm0

; 830  :                 y0 = _mm256_packus_epi16(y0, y1);

  00281	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR _y0$14[ebp]
  00286	c5 fd 67 85 e0
	fe ff ff	 vpackuswb ymm0, ymm0, YMMWORD PTR _y1$9[ebp]
  0028e	c5 fe 7f 85 00
	fe ff ff	 vmovdqu YMMWORD PTR $T2[ebp], ymm0
  00296	c5 fe 6f 85 00
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T2[ebp]
  0029e	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _y0$14[ebp], ymm0

; 831  :                 _mm256_storeu_si256((__m256i *)dst_ptr, y0);

  002a3	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR _y0$14[ebp]
  002a8	8b 55 ac	 mov	 edx, DWORD PTR _dst_ptr$16[ebp]
  002ab	c5 fe 7f 02	 vmovdqu YMMWORD PTR [edx], ymm0

; 832  :             }

  002af	e9 b4 fe ff ff	 jmp	 $LN8@convert_yu
$LN9@convert_yu:

; 833  :         }

  002b4	e9 70 fe ff ff	 jmp	 $LN5@convert_yu
$LN6@convert_yu:

; 834  :     }

  002b9	e9 14 fe ff ff	 jmp	 $LN2@convert_yu
$LN1@convert_yu:

; 835  : }

  002be	52		 push	 edx
  002bf	8b cd		 mov	 ecx, ebp
  002c1	50		 push	 eax
  002c2	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN14@convert_yu
  002c8	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  002cd	58		 pop	 eax
  002ce	5a		 pop	 edx
  002cf	5f		 pop	 edi
  002d0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002d3	33 cd		 xor	 ecx, ebp
  002d5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002da	8b e5		 mov	 esp, ebp
  002dc	5d		 pop	 ebp
  002dd	8b e3		 mov	 esp, ebx
  002df	5b		 pop	 ebx
  002e0	c3		 ret	 0
  002e1	0f 1f 00	 npad	 3
$LN14@convert_yu:
  002e4	01 00 00 00	 DD	 1
  002e8	00 00 00 00	 DD	 $LN13@convert_yu
$LN13@convert_yu:
  002ec	d8 ff ff ff	 DD	 -40			; ffffffd8H
  002f0	0c 00 00 00	 DD	 12			; 0000000cH
  002f4	00 00 00 00	 DD	 $LN12@convert_yu
$LN12@convert_yu:
  002f8	79		 DB	 121			; 00000079H
  002f9	5f		 DB	 95			; 0000005fH
  002fa	72		 DB	 114			; 00000072H
  002fb	61		 DB	 97			; 00000061H
  002fc	6e		 DB	 110			; 0000006eH
  002fd	67		 DB	 103			; 00000067H
  002fe	65		 DB	 101			; 00000065H
  002ff	00		 DB	 0
??$convert_yuv444_high_to_yuv444_avx2_base@$0M@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_high_to_yuv444_avx2_base<12>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuv444_12_to_yuv444_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_12_to_yuv444_avx2

; 846  : void convert_yuv444_12_to_yuv444_avx2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 847  :     convert_yuv444_high_to_yuv444_avx2_base<12>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yuv444_high_to_yuv444_avx2_base@$0M@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_high_to_yuv444_avx2_base<12>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 848  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yuv444_12_to_yuv444_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_12_to_yuv444_avx2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
$T1 = -528						; size = 12
$T2 = -512						; size = 32
$T3 = -480						; size = 32
$T4 = -448						; size = 32
$T5 = -416						; size = 32
$T6 = -368						; size = 16
$T7 = -352						; size = 32
$T8 = -304						; size = 16
_y1$9 = -288						; size = 32
$T10 = -256						; size = 32
$T11 = -208						; size = 16
$T12 = -192						; size = 32
$T13 = -144						; size = 16
_y0$14 = -128						; size = 32
_x$15 = -88						; size = 4
_dst_ptr$16 = -84					; size = 4
_src_ptr$17 = -80					; size = 4
_y$18 = -76						; size = 4
_y_width$19 = -72					; size = 4
_dstLine$20 = -68					; size = 4
_srcYLine$21 = -64					; size = 4
_i$22 = -60						; size = 4
$T23 = -56						; size = 12
_y_range$ = -40						; size = 12
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yuv444_high_to_yuv444_avx2_base@$0O@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_high_to_yuv444_avx2_base<14>

; 810  : static void __forceinline convert_yuv444_high_to_yuv444_avx2_base(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 20 02 00
	00		 sub	 esp, 544		; 00000220H
  0001c	57		 push	 edi
  0001d	8d bd e0 fd ff
	ff		 lea	 edi, DWORD PTR [ebp-544]
  00023	b9 88 00 00 00	 mov	 ecx, 136		; 00000088H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 811  :     static_assert(8 < in_bit_depth && in_bit_depth <= 16, "in_bit_depth must be 9-16.");
; 812  :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 813  :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 814  :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 815  :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 816  :     const int src_y_pitch = src_y_pitch_byte >> 1;

  0007c	8b 53 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  0007f	d1 fa		 sar	 edx, 1
  00081	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 817  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00084	8b 43 2c	 mov	 eax, DWORD PTR _thread_n$[ebx]
  00087	50		 push	 eax
  00088	8b 4b 28	 mov	 ecx, DWORD PTR _thread_id$[ebx]
  0008b	51		 push	 ecx
  0008c	8b 53 20	 mov	 edx, DWORD PTR _height$[ebx]
  0008f	2b 55 ec	 sub	 edx, DWORD PTR _crop_bottom$[ebp]
  00092	52		 push	 edx
  00093	8b 45 f4	 mov	 eax, DWORD PTR _crop_up$[ebp]
  00096	50		 push	 eax
  00097	8d 8d f0 fd ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  0009d	51		 push	 ecx
  0009e	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  000a3	83 c4 14	 add	 esp, 20			; 00000014H
  000a6	8b 10		 mov	 edx, DWORD PTR [eax]
  000a8	89 55 c8	 mov	 DWORD PTR $T23[ebp], edx
  000ab	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ae	89 4d cc	 mov	 DWORD PTR $T23[ebp+4], ecx
  000b1	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000b4	89 55 d0	 mov	 DWORD PTR $T23[ebp+8], edx
  000b7	8b 45 c8	 mov	 eax, DWORD PTR $T23[ebp]
  000ba	89 45 d8	 mov	 DWORD PTR _y_range$[ebp], eax
  000bd	8b 4d cc	 mov	 ecx, DWORD PTR $T23[ebp+4]
  000c0	89 4d dc	 mov	 DWORD PTR _y_range$[ebp+4], ecx
  000c3	8b 55 d0	 mov	 edx, DWORD PTR $T23[ebp+8]
  000c6	89 55 e0	 mov	 DWORD PTR _y_range$[ebp+8], edx

; 818  :     for (int i = 0; i < 3; i++) {

  000c9	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _i$22[ebp], 0
  000d0	eb 09		 jmp	 SHORT $LN4@convert_yu
$LN2@convert_yu:
  000d2	8b 45 c4	 mov	 eax, DWORD PTR _i$22[ebp]
  000d5	83 c0 01	 add	 eax, 1
  000d8	89 45 c4	 mov	 DWORD PTR _i$22[ebp], eax
$LN4@convert_yu:
  000db	83 7d c4 03	 cmp	 DWORD PTR _i$22[ebp], 3
  000df	0f 8d d9 01 00
	00		 jge	 $LN1@convert_yu

; 819  :         uint16_t *srcYLine = (uint16_t *)src[i] + src_y_pitch * y_range.start_src + crop_left;

  000e5	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  000e8	0f af 4d d8	 imul	 ecx, DWORD PTR _y_range$[ebp]
  000ec	8b 55 c4	 mov	 edx, DWORD PTR _i$22[ebp]
  000ef	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  000f2	8b 14 90	 mov	 edx, DWORD PTR [eax+edx*4]
  000f5	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  000f8	8b 4d f8	 mov	 ecx, DWORD PTR _crop_left$[ebp]
  000fb	8d 14 48	 lea	 edx, DWORD PTR [eax+ecx*2]
  000fe	89 55 c0	 mov	 DWORD PTR _srcYLine$21[ebp], edx

; 820  :         uint8_t *dstLine = (uint8_t *)dst[i] + dst_y_pitch_byte * y_range.start_dst;

  00101	8b 43 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  00104	0f af 45 dc	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  00108	8b 4d c4	 mov	 ecx, DWORD PTR _i$22[ebp]
  0010b	8b 53 08	 mov	 edx, DWORD PTR _dst$[ebx]
  0010e	03 04 8a	 add	 eax, DWORD PTR [edx+ecx*4]
  00111	89 45 bc	 mov	 DWORD PTR _dstLine$20[ebp], eax

; 821  :         const int y_width = width - crop_right - crop_left;

  00114	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  00117	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  0011a	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  0011d	89 45 b8	 mov	 DWORD PTR _y_width$19[ebp], eax

; 822  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch_byte) {

  00120	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _y$18[ebp], 0
  00127	eb 1e		 jmp	 SHORT $LN7@convert_yu
$LN5@convert_yu:
  00129	8b 4d b4	 mov	 ecx, DWORD PTR _y$18[ebp]
  0012c	83 c1 01	 add	 ecx, 1
  0012f	89 4d b4	 mov	 DWORD PTR _y$18[ebp], ecx
  00132	8b 55 e8	 mov	 edx, DWORD PTR _src_y_pitch$[ebp]
  00135	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$21[ebp]
  00138	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  0013b	89 4d c0	 mov	 DWORD PTR _srcYLine$21[ebp], ecx
  0013e	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$20[ebp]
  00141	03 53 1c	 add	 edx, DWORD PTR _dst_y_pitch_byte$[ebx]
  00144	89 55 bc	 mov	 DWORD PTR _dstLine$20[ebp], edx
$LN7@convert_yu:
  00147	8b 45 b4	 mov	 eax, DWORD PTR _y$18[ebp]
  0014a	3b 45 e0	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  0014d	0f 8d 66 01 00
	00		 jge	 $LN6@convert_yu

; 823  :             uint16_t *src_ptr = srcYLine;

  00153	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$21[ebp]
  00156	89 4d b0	 mov	 DWORD PTR _src_ptr$17[ebp], ecx

; 824  :             uint8_t *dst_ptr = dstLine;

  00159	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$20[ebp]
  0015c	89 55 ac	 mov	 DWORD PTR _dst_ptr$16[ebp], edx

; 825  :             for (int x = 0; x < y_width; x += 32, dst_ptr += 32, src_ptr += 32) {

  0015f	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR _x$15[ebp], 0
  00166	eb 1b		 jmp	 SHORT $LN10@convert_yu
$LN8@convert_yu:
  00168	8b 45 a8	 mov	 eax, DWORD PTR _x$15[ebp]
  0016b	83 c0 20	 add	 eax, 32			; 00000020H
  0016e	89 45 a8	 mov	 DWORD PTR _x$15[ebp], eax
  00171	8b 4d ac	 mov	 ecx, DWORD PTR _dst_ptr$16[ebp]
  00174	83 c1 20	 add	 ecx, 32			; 00000020H
  00177	89 4d ac	 mov	 DWORD PTR _dst_ptr$16[ebp], ecx
  0017a	8b 55 b0	 mov	 edx, DWORD PTR _src_ptr$17[ebp]
  0017d	83 c2 40	 add	 edx, 64			; 00000040H
  00180	89 55 b0	 mov	 DWORD PTR _src_ptr$17[ebp], edx
$LN10@convert_yu:
  00183	8b 45 a8	 mov	 eax, DWORD PTR _x$15[ebp]
  00186	3b 45 b8	 cmp	 eax, DWORD PTR _y_width$19[ebp]
  00189	0f 8d 25 01 00
	00		 jge	 $LN9@convert_yu

; 826  :                 __m256i y0 = _mm256_loadu2_m128i((const __m128i *)(src_ptr + 16), (const __m128i *)(src_ptr +  0));

  0018f	8b 4d b0	 mov	 ecx, DWORD PTR _src_ptr$17[ebp]
  00192	83 c1 20	 add	 ecx, 32			; 00000020H
  00195	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00198	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR $T11[ebp], xmm0
  0019f	8b 55 b0	 mov	 edx, DWORD PTR _src_ptr$17[ebp]
  001a2	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  001a5	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR $T13[ebp], xmm0
  001ac	c5 fa 6f 85 70
	ff ff ff	 vmovdqu xmm0, XMMWORD PTR $T13[ebp]
  001b4	c5 fe 7f 85 40
	ff ff ff	 vmovdqu YMMWORD PTR $T12[ebp], ymm0
  001bc	c5 fe 6f 85 40
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T12[ebp]
  001c4	c4 e3 7d 18 85
	30 ff ff ff 01	 vinsertf128 ymm0, ymm0, XMMWORD PTR $T11[ebp], 1
  001ce	c5 fe 7f 85 00
	ff ff ff	 vmovdqu YMMWORD PTR $T10[ebp], ymm0
  001d6	c5 fe 6f 85 00
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T10[ebp]
  001de	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _y0$14[ebp], ymm0

; 827  :                 __m256i y1 = _mm256_loadu2_m128i((const __m128i *)(src_ptr + 24), (const __m128i *)(src_ptr +  8));

  001e3	8b 45 b0	 mov	 eax, DWORD PTR _src_ptr$17[ebp]
  001e6	83 c0 30	 add	 eax, 48			; 00000030H
  001e9	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  001ec	0f 29 85 90 fe
	ff ff		 movaps	 XMMWORD PTR $T6[ebp], xmm0
  001f3	8b 4d b0	 mov	 ecx, DWORD PTR _src_ptr$17[ebp]
  001f6	83 c1 10	 add	 ecx, 16			; 00000010H
  001f9	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  001fc	0f 29 85 d0 fe
	ff ff		 movaps	 XMMWORD PTR $T8[ebp], xmm0
  00203	c5 fa 6f 85 d0
	fe ff ff	 vmovdqu xmm0, XMMWORD PTR $T8[ebp]
  0020b	c5 fe 7f 85 a0
	fe ff ff	 vmovdqu YMMWORD PTR $T7[ebp], ymm0
  00213	c5 fe 6f 85 a0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T7[ebp]
  0021b	c4 e3 7d 18 85
	90 fe ff ff 01	 vinsertf128 ymm0, ymm0, XMMWORD PTR $T6[ebp], 1
  00225	c5 fe 7f 85 60
	fe ff ff	 vmovdqu YMMWORD PTR $T5[ebp], ymm0
  0022d	c5 fe 6f 85 60
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T5[ebp]
  00235	c5 fe 7f 85 e0
	fe ff ff	 vmovdqu YMMWORD PTR _y1$9[ebp], ymm0

; 828  :                 y0 = _mm256_srli_epi16(y0, in_bit_depth - 8);

  0023d	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR _y0$14[ebp]
  00242	c5 fd 71 d0 06	 vpsrlw	 ymm0, ymm0, 6
  00247	c5 fe 7f 85 40
	fe ff ff	 vmovdqu YMMWORD PTR $T4[ebp], ymm0
  0024f	c5 fe 6f 85 40
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T4[ebp]
  00257	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _y0$14[ebp], ymm0

; 829  :                 y1 = _mm256_srli_epi16(y1, in_bit_depth - 8);

  0025c	c5 fe 6f 85 e0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR _y1$9[ebp]
  00264	c5 fd 71 d0 06	 vpsrlw	 ymm0, ymm0, 6
  00269	c5 fe 7f 85 20
	fe ff ff	 vmovdqu YMMWORD PTR $T3[ebp], ymm0
  00271	c5 fe 6f 85 20
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T3[ebp]
  00279	c5 fe 7f 85 e0
	fe ff ff	 vmovdqu YMMWORD PTR _y1$9[ebp], ymm0

; 830  :                 y0 = _mm256_packus_epi16(y0, y1);

  00281	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR _y0$14[ebp]
  00286	c5 fd 67 85 e0
	fe ff ff	 vpackuswb ymm0, ymm0, YMMWORD PTR _y1$9[ebp]
  0028e	c5 fe 7f 85 00
	fe ff ff	 vmovdqu YMMWORD PTR $T2[ebp], ymm0
  00296	c5 fe 6f 85 00
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T2[ebp]
  0029e	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _y0$14[ebp], ymm0

; 831  :                 _mm256_storeu_si256((__m256i *)dst_ptr, y0);

  002a3	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR _y0$14[ebp]
  002a8	8b 55 ac	 mov	 edx, DWORD PTR _dst_ptr$16[ebp]
  002ab	c5 fe 7f 02	 vmovdqu YMMWORD PTR [edx], ymm0

; 832  :             }

  002af	e9 b4 fe ff ff	 jmp	 $LN8@convert_yu
$LN9@convert_yu:

; 833  :         }

  002b4	e9 70 fe ff ff	 jmp	 $LN5@convert_yu
$LN6@convert_yu:

; 834  :     }

  002b9	e9 14 fe ff ff	 jmp	 $LN2@convert_yu
$LN1@convert_yu:

; 835  : }

  002be	52		 push	 edx
  002bf	8b cd		 mov	 ecx, ebp
  002c1	50		 push	 eax
  002c2	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN14@convert_yu
  002c8	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  002cd	58		 pop	 eax
  002ce	5a		 pop	 edx
  002cf	5f		 pop	 edi
  002d0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002d3	33 cd		 xor	 ecx, ebp
  002d5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002da	8b e5		 mov	 esp, ebp
  002dc	5d		 pop	 ebp
  002dd	8b e3		 mov	 esp, ebx
  002df	5b		 pop	 ebx
  002e0	c3		 ret	 0
  002e1	0f 1f 00	 npad	 3
$LN14@convert_yu:
  002e4	01 00 00 00	 DD	 1
  002e8	00 00 00 00	 DD	 $LN13@convert_yu
$LN13@convert_yu:
  002ec	d8 ff ff ff	 DD	 -40			; ffffffd8H
  002f0	0c 00 00 00	 DD	 12			; 0000000cH
  002f4	00 00 00 00	 DD	 $LN12@convert_yu
$LN12@convert_yu:
  002f8	79		 DB	 121			; 00000079H
  002f9	5f		 DB	 95			; 0000005fH
  002fa	72		 DB	 114			; 00000072H
  002fb	61		 DB	 97			; 00000061H
  002fc	6e		 DB	 110			; 0000006eH
  002fd	67		 DB	 103			; 00000067H
  002fe	65		 DB	 101			; 00000065H
  002ff	00		 DB	 0
??$convert_yuv444_high_to_yuv444_avx2_base@$0O@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_high_to_yuv444_avx2_base<14>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuv444_14_to_yuv444_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_14_to_yuv444_avx2

; 842  : void convert_yuv444_14_to_yuv444_avx2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 843  :     convert_yuv444_high_to_yuv444_avx2_base<14>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yuv444_high_to_yuv444_avx2_base@$0O@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_high_to_yuv444_avx2_base<14>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 844  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yuv444_14_to_yuv444_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_14_to_yuv444_avx2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
$T1 = -528						; size = 12
$T2 = -512						; size = 32
$T3 = -480						; size = 32
$T4 = -448						; size = 32
$T5 = -416						; size = 32
$T6 = -368						; size = 16
$T7 = -352						; size = 32
$T8 = -304						; size = 16
_y1$9 = -288						; size = 32
$T10 = -256						; size = 32
$T11 = -208						; size = 16
$T12 = -192						; size = 32
$T13 = -144						; size = 16
_y0$14 = -128						; size = 32
_x$15 = -88						; size = 4
_dst_ptr$16 = -84					; size = 4
_src_ptr$17 = -80					; size = 4
_y$18 = -76						; size = 4
_y_width$19 = -72					; size = 4
_dstLine$20 = -68					; size = 4
_srcYLine$21 = -64					; size = 4
_i$22 = -60						; size = 4
$T23 = -56						; size = 12
_y_range$ = -40						; size = 12
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yuv444_high_to_yuv444_avx2_base@$0BA@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_high_to_yuv444_avx2_base<16>

; 810  : static void __forceinline convert_yuv444_high_to_yuv444_avx2_base(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 20 02 00
	00		 sub	 esp, 544		; 00000220H
  0001c	57		 push	 edi
  0001d	8d bd e0 fd ff
	ff		 lea	 edi, DWORD PTR [ebp-544]
  00023	b9 88 00 00 00	 mov	 ecx, 136		; 00000088H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 811  :     static_assert(8 < in_bit_depth && in_bit_depth <= 16, "in_bit_depth must be 9-16.");
; 812  :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 813  :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 814  :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 815  :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 816  :     const int src_y_pitch = src_y_pitch_byte >> 1;

  0007c	8b 53 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  0007f	d1 fa		 sar	 edx, 1
  00081	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 817  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00084	8b 43 2c	 mov	 eax, DWORD PTR _thread_n$[ebx]
  00087	50		 push	 eax
  00088	8b 4b 28	 mov	 ecx, DWORD PTR _thread_id$[ebx]
  0008b	51		 push	 ecx
  0008c	8b 53 20	 mov	 edx, DWORD PTR _height$[ebx]
  0008f	2b 55 ec	 sub	 edx, DWORD PTR _crop_bottom$[ebp]
  00092	52		 push	 edx
  00093	8b 45 f4	 mov	 eax, DWORD PTR _crop_up$[ebp]
  00096	50		 push	 eax
  00097	8d 8d f0 fd ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  0009d	51		 push	 ecx
  0009e	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  000a3	83 c4 14	 add	 esp, 20			; 00000014H
  000a6	8b 10		 mov	 edx, DWORD PTR [eax]
  000a8	89 55 c8	 mov	 DWORD PTR $T23[ebp], edx
  000ab	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ae	89 4d cc	 mov	 DWORD PTR $T23[ebp+4], ecx
  000b1	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000b4	89 55 d0	 mov	 DWORD PTR $T23[ebp+8], edx
  000b7	8b 45 c8	 mov	 eax, DWORD PTR $T23[ebp]
  000ba	89 45 d8	 mov	 DWORD PTR _y_range$[ebp], eax
  000bd	8b 4d cc	 mov	 ecx, DWORD PTR $T23[ebp+4]
  000c0	89 4d dc	 mov	 DWORD PTR _y_range$[ebp+4], ecx
  000c3	8b 55 d0	 mov	 edx, DWORD PTR $T23[ebp+8]
  000c6	89 55 e0	 mov	 DWORD PTR _y_range$[ebp+8], edx

; 818  :     for (int i = 0; i < 3; i++) {

  000c9	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _i$22[ebp], 0
  000d0	eb 09		 jmp	 SHORT $LN4@convert_yu
$LN2@convert_yu:
  000d2	8b 45 c4	 mov	 eax, DWORD PTR _i$22[ebp]
  000d5	83 c0 01	 add	 eax, 1
  000d8	89 45 c4	 mov	 DWORD PTR _i$22[ebp], eax
$LN4@convert_yu:
  000db	83 7d c4 03	 cmp	 DWORD PTR _i$22[ebp], 3
  000df	0f 8d d9 01 00
	00		 jge	 $LN1@convert_yu

; 819  :         uint16_t *srcYLine = (uint16_t *)src[i] + src_y_pitch * y_range.start_src + crop_left;

  000e5	8b 4d e8	 mov	 ecx, DWORD PTR _src_y_pitch$[ebp]
  000e8	0f af 4d d8	 imul	 ecx, DWORD PTR _y_range$[ebp]
  000ec	8b 55 c4	 mov	 edx, DWORD PTR _i$22[ebp]
  000ef	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  000f2	8b 14 90	 mov	 edx, DWORD PTR [eax+edx*4]
  000f5	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  000f8	8b 4d f8	 mov	 ecx, DWORD PTR _crop_left$[ebp]
  000fb	8d 14 48	 lea	 edx, DWORD PTR [eax+ecx*2]
  000fe	89 55 c0	 mov	 DWORD PTR _srcYLine$21[ebp], edx

; 820  :         uint8_t *dstLine = (uint8_t *)dst[i] + dst_y_pitch_byte * y_range.start_dst;

  00101	8b 43 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  00104	0f af 45 dc	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  00108	8b 4d c4	 mov	 ecx, DWORD PTR _i$22[ebp]
  0010b	8b 53 08	 mov	 edx, DWORD PTR _dst$[ebx]
  0010e	03 04 8a	 add	 eax, DWORD PTR [edx+ecx*4]
  00111	89 45 bc	 mov	 DWORD PTR _dstLine$20[ebp], eax

; 821  :         const int y_width = width - crop_right - crop_left;

  00114	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  00117	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  0011a	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  0011d	89 45 b8	 mov	 DWORD PTR _y_width$19[ebp], eax

; 822  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch_byte) {

  00120	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _y$18[ebp], 0
  00127	eb 1e		 jmp	 SHORT $LN7@convert_yu
$LN5@convert_yu:
  00129	8b 4d b4	 mov	 ecx, DWORD PTR _y$18[ebp]
  0012c	83 c1 01	 add	 ecx, 1
  0012f	89 4d b4	 mov	 DWORD PTR _y$18[ebp], ecx
  00132	8b 55 e8	 mov	 edx, DWORD PTR _src_y_pitch$[ebp]
  00135	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$21[ebp]
  00138	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  0013b	89 4d c0	 mov	 DWORD PTR _srcYLine$21[ebp], ecx
  0013e	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$20[ebp]
  00141	03 53 1c	 add	 edx, DWORD PTR _dst_y_pitch_byte$[ebx]
  00144	89 55 bc	 mov	 DWORD PTR _dstLine$20[ebp], edx
$LN7@convert_yu:
  00147	8b 45 b4	 mov	 eax, DWORD PTR _y$18[ebp]
  0014a	3b 45 e0	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  0014d	0f 8d 66 01 00
	00		 jge	 $LN6@convert_yu

; 823  :             uint16_t *src_ptr = srcYLine;

  00153	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$21[ebp]
  00156	89 4d b0	 mov	 DWORD PTR _src_ptr$17[ebp], ecx

; 824  :             uint8_t *dst_ptr = dstLine;

  00159	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$20[ebp]
  0015c	89 55 ac	 mov	 DWORD PTR _dst_ptr$16[ebp], edx

; 825  :             for (int x = 0; x < y_width; x += 32, dst_ptr += 32, src_ptr += 32) {

  0015f	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR _x$15[ebp], 0
  00166	eb 1b		 jmp	 SHORT $LN10@convert_yu
$LN8@convert_yu:
  00168	8b 45 a8	 mov	 eax, DWORD PTR _x$15[ebp]
  0016b	83 c0 20	 add	 eax, 32			; 00000020H
  0016e	89 45 a8	 mov	 DWORD PTR _x$15[ebp], eax
  00171	8b 4d ac	 mov	 ecx, DWORD PTR _dst_ptr$16[ebp]
  00174	83 c1 20	 add	 ecx, 32			; 00000020H
  00177	89 4d ac	 mov	 DWORD PTR _dst_ptr$16[ebp], ecx
  0017a	8b 55 b0	 mov	 edx, DWORD PTR _src_ptr$17[ebp]
  0017d	83 c2 40	 add	 edx, 64			; 00000040H
  00180	89 55 b0	 mov	 DWORD PTR _src_ptr$17[ebp], edx
$LN10@convert_yu:
  00183	8b 45 a8	 mov	 eax, DWORD PTR _x$15[ebp]
  00186	3b 45 b8	 cmp	 eax, DWORD PTR _y_width$19[ebp]
  00189	0f 8d 25 01 00
	00		 jge	 $LN9@convert_yu

; 826  :                 __m256i y0 = _mm256_loadu2_m128i((const __m128i *)(src_ptr + 16), (const __m128i *)(src_ptr +  0));

  0018f	8b 4d b0	 mov	 ecx, DWORD PTR _src_ptr$17[ebp]
  00192	83 c1 20	 add	 ecx, 32			; 00000020H
  00195	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00198	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR $T11[ebp], xmm0
  0019f	8b 55 b0	 mov	 edx, DWORD PTR _src_ptr$17[ebp]
  001a2	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  001a5	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR $T13[ebp], xmm0
  001ac	c5 fa 6f 85 70
	ff ff ff	 vmovdqu xmm0, XMMWORD PTR $T13[ebp]
  001b4	c5 fe 7f 85 40
	ff ff ff	 vmovdqu YMMWORD PTR $T12[ebp], ymm0
  001bc	c5 fe 6f 85 40
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T12[ebp]
  001c4	c4 e3 7d 18 85
	30 ff ff ff 01	 vinsertf128 ymm0, ymm0, XMMWORD PTR $T11[ebp], 1
  001ce	c5 fe 7f 85 00
	ff ff ff	 vmovdqu YMMWORD PTR $T10[ebp], ymm0
  001d6	c5 fe 6f 85 00
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T10[ebp]
  001de	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _y0$14[ebp], ymm0

; 827  :                 __m256i y1 = _mm256_loadu2_m128i((const __m128i *)(src_ptr + 24), (const __m128i *)(src_ptr +  8));

  001e3	8b 45 b0	 mov	 eax, DWORD PTR _src_ptr$17[ebp]
  001e6	83 c0 30	 add	 eax, 48			; 00000030H
  001e9	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  001ec	0f 29 85 90 fe
	ff ff		 movaps	 XMMWORD PTR $T6[ebp], xmm0
  001f3	8b 4d b0	 mov	 ecx, DWORD PTR _src_ptr$17[ebp]
  001f6	83 c1 10	 add	 ecx, 16			; 00000010H
  001f9	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  001fc	0f 29 85 d0 fe
	ff ff		 movaps	 XMMWORD PTR $T8[ebp], xmm0
  00203	c5 fa 6f 85 d0
	fe ff ff	 vmovdqu xmm0, XMMWORD PTR $T8[ebp]
  0020b	c5 fe 7f 85 a0
	fe ff ff	 vmovdqu YMMWORD PTR $T7[ebp], ymm0
  00213	c5 fe 6f 85 a0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T7[ebp]
  0021b	c4 e3 7d 18 85
	90 fe ff ff 01	 vinsertf128 ymm0, ymm0, XMMWORD PTR $T6[ebp], 1
  00225	c5 fe 7f 85 60
	fe ff ff	 vmovdqu YMMWORD PTR $T5[ebp], ymm0
  0022d	c5 fe 6f 85 60
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T5[ebp]
  00235	c5 fe 7f 85 e0
	fe ff ff	 vmovdqu YMMWORD PTR _y1$9[ebp], ymm0

; 828  :                 y0 = _mm256_srli_epi16(y0, in_bit_depth - 8);

  0023d	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR _y0$14[ebp]
  00242	c5 fd 71 d0 08	 vpsrlw	 ymm0, ymm0, 8
  00247	c5 fe 7f 85 40
	fe ff ff	 vmovdqu YMMWORD PTR $T4[ebp], ymm0
  0024f	c5 fe 6f 85 40
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T4[ebp]
  00257	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _y0$14[ebp], ymm0

; 829  :                 y1 = _mm256_srli_epi16(y1, in_bit_depth - 8);

  0025c	c5 fe 6f 85 e0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR _y1$9[ebp]
  00264	c5 fd 71 d0 08	 vpsrlw	 ymm0, ymm0, 8
  00269	c5 fe 7f 85 20
	fe ff ff	 vmovdqu YMMWORD PTR $T3[ebp], ymm0
  00271	c5 fe 6f 85 20
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T3[ebp]
  00279	c5 fe 7f 85 e0
	fe ff ff	 vmovdqu YMMWORD PTR _y1$9[ebp], ymm0

; 830  :                 y0 = _mm256_packus_epi16(y0, y1);

  00281	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR _y0$14[ebp]
  00286	c5 fd 67 85 e0
	fe ff ff	 vpackuswb ymm0, ymm0, YMMWORD PTR _y1$9[ebp]
  0028e	c5 fe 7f 85 00
	fe ff ff	 vmovdqu YMMWORD PTR $T2[ebp], ymm0
  00296	c5 fe 6f 85 00
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T2[ebp]
  0029e	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _y0$14[ebp], ymm0

; 831  :                 _mm256_storeu_si256((__m256i *)dst_ptr, y0);

  002a3	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR _y0$14[ebp]
  002a8	8b 55 ac	 mov	 edx, DWORD PTR _dst_ptr$16[ebp]
  002ab	c5 fe 7f 02	 vmovdqu YMMWORD PTR [edx], ymm0

; 832  :             }

  002af	e9 b4 fe ff ff	 jmp	 $LN8@convert_yu
$LN9@convert_yu:

; 833  :         }

  002b4	e9 70 fe ff ff	 jmp	 $LN5@convert_yu
$LN6@convert_yu:

; 834  :     }

  002b9	e9 14 fe ff ff	 jmp	 $LN2@convert_yu
$LN1@convert_yu:

; 835  : }

  002be	52		 push	 edx
  002bf	8b cd		 mov	 ecx, ebp
  002c1	50		 push	 eax
  002c2	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN14@convert_yu
  002c8	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  002cd	58		 pop	 eax
  002ce	5a		 pop	 edx
  002cf	5f		 pop	 edi
  002d0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002d3	33 cd		 xor	 ecx, ebp
  002d5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002da	8b e5		 mov	 esp, ebp
  002dc	5d		 pop	 ebp
  002dd	8b e3		 mov	 esp, ebx
  002df	5b		 pop	 ebx
  002e0	c3		 ret	 0
  002e1	0f 1f 00	 npad	 3
$LN14@convert_yu:
  002e4	01 00 00 00	 DD	 1
  002e8	00 00 00 00	 DD	 $LN13@convert_yu
$LN13@convert_yu:
  002ec	d8 ff ff ff	 DD	 -40			; ffffffd8H
  002f0	0c 00 00 00	 DD	 12			; 0000000cH
  002f4	00 00 00 00	 DD	 $LN12@convert_yu
$LN12@convert_yu:
  002f8	79		 DB	 121			; 00000079H
  002f9	5f		 DB	 95			; 0000005fH
  002fa	72		 DB	 114			; 00000072H
  002fb	61		 DB	 97			; 00000061H
  002fc	6e		 DB	 110			; 0000006eH
  002fd	67		 DB	 103			; 00000067H
  002fe	65		 DB	 101			; 00000065H
  002ff	00		 DB	 0
??$convert_yuv444_high_to_yuv444_avx2_base@$0BA@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_high_to_yuv444_avx2_base<16>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuv444_16_to_yuv444_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_16_to_yuv444_avx2

; 838  : void convert_yuv444_16_to_yuv444_avx2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 839  :     convert_yuv444_high_to_yuv444_avx2_base<16>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yuv444_high_to_yuv444_avx2_base@$0BA@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_high_to_yuv444_avx2_base<16>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 840  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yuv444_16_to_yuv444_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_16_to_yuv444_avx2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
$T1 = -368						; size = 12
$T2 = -352						; size = 32
$T3 = -320						; size = 32
$T4 = -288						; size = 32
$T5 = -256						; size = 32
$T6 = -224						; size = 32
$T7 = -192						; size = 32
_y1$8 = -160						; size = 32
_y0$9 = -128						; size = 32
_x$10 = -88						; size = 4
_dst_ptr$11 = -84					; size = 4
_src_ptr$12 = -80					; size = 4
_y$13 = -76						; size = 4
_y_width$14 = -72					; size = 4
_dstLine$15 = -68					; size = 4
_srcYLine$16 = -64					; size = 4
_i$17 = -60						; size = 4
$T18 = -56						; size = 12
_y_range$ = -40						; size = 12
_dst_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuv444_to_yuv444_16_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_to_yuv444_16_avx2

; 782  : void convert_yuv444_to_yuv444_16_avx2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 80 01 00
	00		 sub	 esp, 384		; 00000180H
  0001c	57		 push	 edi
  0001d	8d bd 80 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-384]
  00023	b9 60 00 00 00	 mov	 ecx, 96			; 00000060H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 783  :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 784  :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 785  :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 786  :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 787  :     const int dst_y_pitch = dst_y_pitch_byte >> 1;

  0007c	8b 53 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebx]
  0007f	d1 fa		 sar	 edx, 1
  00081	89 55 e8	 mov	 DWORD PTR _dst_y_pitch$[ebp], edx

; 788  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00084	8b 43 2c	 mov	 eax, DWORD PTR _thread_n$[ebx]
  00087	50		 push	 eax
  00088	8b 4b 28	 mov	 ecx, DWORD PTR _thread_id$[ebx]
  0008b	51		 push	 ecx
  0008c	8b 53 20	 mov	 edx, DWORD PTR _height$[ebx]
  0008f	2b 55 ec	 sub	 edx, DWORD PTR _crop_bottom$[ebp]
  00092	52		 push	 edx
  00093	8b 45 f4	 mov	 eax, DWORD PTR _crop_up$[ebp]
  00096	50		 push	 eax
  00097	8d 8d 90 fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  0009d	51		 push	 ecx
  0009e	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  000a3	83 c4 14	 add	 esp, 20			; 00000014H
  000a6	8b 10		 mov	 edx, DWORD PTR [eax]
  000a8	89 55 c8	 mov	 DWORD PTR $T18[ebp], edx
  000ab	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ae	89 4d cc	 mov	 DWORD PTR $T18[ebp+4], ecx
  000b1	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000b4	89 55 d0	 mov	 DWORD PTR $T18[ebp+8], edx
  000b7	8b 45 c8	 mov	 eax, DWORD PTR $T18[ebp]
  000ba	89 45 d8	 mov	 DWORD PTR _y_range$[ebp], eax
  000bd	8b 4d cc	 mov	 ecx, DWORD PTR $T18[ebp+4]
  000c0	89 4d dc	 mov	 DWORD PTR _y_range$[ebp+4], ecx
  000c3	8b 55 d0	 mov	 edx, DWORD PTR $T18[ebp+8]
  000c6	89 55 e0	 mov	 DWORD PTR _y_range$[ebp+8], edx

; 789  :     for (int i = 0; i < 3; i++) {

  000c9	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _i$17[ebp], 0
  000d0	eb 09		 jmp	 SHORT $LN4@convert_yu
$LN2@convert_yu:
  000d2	8b 45 c4	 mov	 eax, DWORD PTR _i$17[ebp]
  000d5	83 c0 01	 add	 eax, 1
  000d8	89 45 c4	 mov	 DWORD PTR _i$17[ebp], eax
$LN4@convert_yu:
  000db	83 7d c4 03	 cmp	 DWORD PTR _i$17[ebp], 3
  000df	0f 8d 6d 01 00
	00		 jge	 $LN1@convert_yu

; 790  :         uint8_t *srcYLine = (uint8_t *)src[i] + src_y_pitch_byte * y_range.start_src + crop_left;

  000e5	8b 4b 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebx]
  000e8	0f af 4d d8	 imul	 ecx, DWORD PTR _y_range$[ebp]
  000ec	8b 55 c4	 mov	 edx, DWORD PTR _i$17[ebp]
  000ef	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  000f2	8b 14 90	 mov	 edx, DWORD PTR [eax+edx*4]
  000f5	03 d1		 add	 edx, ecx
  000f7	03 55 f8	 add	 edx, DWORD PTR _crop_left$[ebp]
  000fa	89 55 c0	 mov	 DWORD PTR _srcYLine$16[ebp], edx

; 791  :         uint16_t *dstLine = (uint16_t *)dst[i] + dst_y_pitch * y_range.start_dst;

  000fd	8b 45 e8	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  00100	0f af 45 dc	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  00104	8b 4d c4	 mov	 ecx, DWORD PTR _i$17[ebp]
  00107	8b 53 08	 mov	 edx, DWORD PTR _dst$[ebx]
  0010a	8b 0c 8a	 mov	 ecx, DWORD PTR [edx+ecx*4]
  0010d	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00110	89 55 bc	 mov	 DWORD PTR _dstLine$15[ebp], edx

; 792  :         const int y_width = width - crop_right - crop_left;

  00113	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  00116	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  00119	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  0011c	89 45 b8	 mov	 DWORD PTR _y_width$14[ebp], eax

; 793  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch_byte, dstLine += dst_y_pitch) {

  0011f	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _y$13[ebp], 0
  00126	eb 1e		 jmp	 SHORT $LN7@convert_yu
$LN5@convert_yu:
  00128	8b 4d b4	 mov	 ecx, DWORD PTR _y$13[ebp]
  0012b	83 c1 01	 add	 ecx, 1
  0012e	89 4d b4	 mov	 DWORD PTR _y$13[ebp], ecx
  00131	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$16[ebp]
  00134	03 53 14	 add	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  00137	89 55 c0	 mov	 DWORD PTR _srcYLine$16[ebp], edx
  0013a	8b 45 e8	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  0013d	8b 4d bc	 mov	 ecx, DWORD PTR _dstLine$15[ebp]
  00140	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00143	89 55 bc	 mov	 DWORD PTR _dstLine$15[ebp], edx
$LN7@convert_yu:
  00146	8b 45 b4	 mov	 eax, DWORD PTR _y$13[ebp]
  00149	3b 45 e0	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  0014c	0f 8d fb 00 00
	00		 jge	 $LN6@convert_yu

; 794  :             uint8_t *src_ptr = srcYLine;

  00152	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$16[ebp]
  00155	89 4d b0	 mov	 DWORD PTR _src_ptr$12[ebp], ecx

; 795  :             uint16_t *dst_ptr = dstLine;

  00158	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$15[ebp]
  0015b	89 55 ac	 mov	 DWORD PTR _dst_ptr$11[ebp], edx

; 796  :             for (int x = 0; x < y_width; x += 32, dst_ptr += 32, src_ptr += 32) {

  0015e	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR _x$10[ebp], 0
  00165	eb 1b		 jmp	 SHORT $LN10@convert_yu
$LN8@convert_yu:
  00167	8b 45 a8	 mov	 eax, DWORD PTR _x$10[ebp]
  0016a	83 c0 20	 add	 eax, 32			; 00000020H
  0016d	89 45 a8	 mov	 DWORD PTR _x$10[ebp], eax
  00170	8b 4d ac	 mov	 ecx, DWORD PTR _dst_ptr$11[ebp]
  00173	83 c1 40	 add	 ecx, 64			; 00000040H
  00176	89 4d ac	 mov	 DWORD PTR _dst_ptr$11[ebp], ecx
  00179	8b 55 b0	 mov	 edx, DWORD PTR _src_ptr$12[ebp]
  0017c	83 c2 20	 add	 edx, 32			; 00000020H
  0017f	89 55 b0	 mov	 DWORD PTR _src_ptr$12[ebp], edx
$LN10@convert_yu:
  00182	8b 45 a8	 mov	 eax, DWORD PTR _x$10[ebp]
  00185	3b 45 b8	 cmp	 eax, DWORD PTR _y_width$14[ebp]
  00188	0f 8d ba 00 00
	00		 jge	 $LN9@convert_yu

; 797  :                 __m256i y0, y1;
; 798  :                 y0 = _mm256_loadu_si256((const __m256i *)src_ptr);

  0018e	8b 4d b0	 mov	 ecx, DWORD PTR _src_ptr$12[ebp]
  00191	c5 fe 6f 01	 vmovdqu ymm0, YMMWORD PTR [ecx]
  00195	c5 fe 7f 85 40
	ff ff ff	 vmovdqu YMMWORD PTR $T7[ebp], ymm0
  0019d	c5 fe 6f 85 40
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T7[ebp]
  001a5	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _y0$9[ebp], ymm0

; 799  :                 y0 = _mm256_permute4x64_epi64(y0, _MM_SHUFFLE(3,1,2,0));

  001aa	c4 e3 fd 00 45
	80 d8		 vpermq	 ymm0, YMMWORD PTR _y0$9[ebp], 216 ; 000000d8H
  001b1	c5 fe 7f 85 20
	ff ff ff	 vmovdqu YMMWORD PTR $T6[ebp], ymm0
  001b9	c5 fe 6f 85 20
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T6[ebp]
  001c1	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _y0$9[ebp], ymm0

; 800  :                 y1 = _mm256_unpackhi_epi8(_mm256_setzero_si256(), y0);

  001c6	c5 f9 ef c0	 vpxor	 xmm0, xmm0, xmm0
  001ca	c5 fe 7f 85 00
	ff ff ff	 vmovdqu YMMWORD PTR $T5[ebp], ymm0
  001d2	c5 fe 6f 85 00
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T5[ebp]
  001da	c5 fd 68 45 80	 vpunpckhbw ymm0, ymm0, YMMWORD PTR _y0$9[ebp]
  001df	c5 fe 7f 85 e0
	fe ff ff	 vmovdqu YMMWORD PTR $T4[ebp], ymm0
  001e7	c5 fe 6f 85 e0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T4[ebp]
  001ef	c5 fe 7f 85 60
	ff ff ff	 vmovdqu YMMWORD PTR _y1$8[ebp], ymm0

; 801  :                 y0 = _mm256_unpacklo_epi8(_mm256_setzero_si256(), y0);

  001f7	c5 f9 ef c0	 vpxor	 xmm0, xmm0, xmm0
  001fb	c5 fe 7f 85 c0
	fe ff ff	 vmovdqu YMMWORD PTR $T3[ebp], ymm0
  00203	c5 fe 6f 85 c0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T3[ebp]
  0020b	c5 fd 60 45 80	 vpunpcklbw ymm0, ymm0, YMMWORD PTR _y0$9[ebp]
  00210	c5 fe 7f 85 a0
	fe ff ff	 vmovdqu YMMWORD PTR $T2[ebp], ymm0
  00218	c5 fe 6f 85 a0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T2[ebp]
  00220	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _y0$9[ebp], ymm0

; 802  :                 _mm256_storeu_si256((__m256i *)(dst_ptr +  0), y0);

  00225	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR _y0$9[ebp]
  0022a	8b 55 ac	 mov	 edx, DWORD PTR _dst_ptr$11[ebp]
  0022d	c5 fe 7f 02	 vmovdqu YMMWORD PTR [edx], ymm0

; 803  :                 _mm256_storeu_si256((__m256i *)(dst_ptr + 16), y1);

  00231	c5 fe 6f 85 60
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR _y1$8[ebp]
  00239	8b 45 ac	 mov	 eax, DWORD PTR _dst_ptr$11[ebp]
  0023c	83 c0 20	 add	 eax, 32			; 00000020H
  0023f	c5 fe 7f 00	 vmovdqu YMMWORD PTR [eax], ymm0

; 804  :             }

  00243	e9 1f ff ff ff	 jmp	 $LN8@convert_yu
$LN9@convert_yu:

; 805  :         }

  00248	e9 db fe ff ff	 jmp	 $LN5@convert_yu
$LN6@convert_yu:

; 806  :     }

  0024d	e9 80 fe ff ff	 jmp	 $LN2@convert_yu
$LN1@convert_yu:

; 807  : }

  00252	52		 push	 edx
  00253	8b cd		 mov	 ecx, ebp
  00255	50		 push	 eax
  00256	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN14@convert_yu
  0025c	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00261	58		 pop	 eax
  00262	5a		 pop	 edx
  00263	5f		 pop	 edi
  00264	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00267	33 cd		 xor	 ecx, ebp
  00269	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0026e	8b e5		 mov	 esp, ebp
  00270	5d		 pop	 ebp
  00271	8b e3		 mov	 esp, ebx
  00273	5b		 pop	 ebx
  00274	c3		 ret	 0
  00275	0f 1f 00	 npad	 3
$LN14@convert_yu:
  00278	01 00 00 00	 DD	 1
  0027c	00 00 00 00	 DD	 $LN13@convert_yu
$LN13@convert_yu:
  00280	d8 ff ff ff	 DD	 -40			; ffffffd8H
  00284	0c 00 00 00	 DD	 12			; 0000000cH
  00288	00 00 00 00	 DD	 $LN12@convert_yu
$LN12@convert_yu:
  0028c	79		 DB	 121			; 00000079H
  0028d	5f		 DB	 95			; 0000005fH
  0028e	72		 DB	 114			; 00000072H
  0028f	61		 DB	 97			; 00000061H
  00290	6e		 DB	 110			; 0000006eH
  00291	67		 DB	 103			; 00000067H
  00292	65		 DB	 101			; 00000065H
  00293	00		 DB	 0
?convert_yuv444_to_yuv444_16_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_to_yuv444_16_avx2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
$T1 = -208						; size = 12
$T2 = -192						; size = 32
$T3 = -160						; size = 32
_x0$4 = -128						; size = 32
_x$5 = -92						; size = 4
_dst_ptr$6 = -88					; size = 4
_src_ptr$7 = -84					; size = 4
_y$8 = -80						; size = 4
_y_width$9 = -76					; size = 4
_dstLine$10 = -72					; size = 4
_srcYLine$11 = -68					; size = 4
_i$12 = -64						; size = 4
$T13 = -60						; size = 12
_y_range$ = -44						; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yuv444_high_to_yuv444_16_avx2_base@$08@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_high_to_yuv444_16_avx2_base<9>

; 729  : static void __forceinline convert_yuv444_high_to_yuv444_16_avx2_base(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec e0 00 00
	00		 sub	 esp, 224		; 000000e0H
  0001c	57		 push	 edi
  0001d	8d bd 20 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-224]
  00023	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 730  :     static_assert(8 < in_bit_depth && in_bit_depth <= 16, "in_bit_depth must be 9-16.");
; 731  :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 732  :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 733  :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 734  :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 735  :     const int src_y_pitch = src_y_pitch_byte >> 1;

  0007c	8b 53 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  0007f	d1 fa		 sar	 edx, 1
  00081	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 736  :     const int dst_y_pitch = dst_y_pitch_byte >> 1;

  00084	8b 43 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  00087	d1 f8		 sar	 eax, 1
  00089	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 737  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  0008c	8b 4b 2c	 mov	 ecx, DWORD PTR _thread_n$[ebx]
  0008f	51		 push	 ecx
  00090	8b 53 28	 mov	 edx, DWORD PTR _thread_id$[ebx]
  00093	52		 push	 edx
  00094	8b 43 20	 mov	 eax, DWORD PTR _height$[ebx]
  00097	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  0009a	50		 push	 eax
  0009b	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  0009e	51		 push	 ecx
  0009f	8d 95 30 ff ff
	ff		 lea	 edx, DWORD PTR $T1[ebp]
  000a5	52		 push	 edx
  000a6	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  000ab	83 c4 14	 add	 esp, 20			; 00000014H
  000ae	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b0	89 4d c4	 mov	 DWORD PTR $T13[ebp], ecx
  000b3	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000b6	89 55 c8	 mov	 DWORD PTR $T13[ebp+4], edx
  000b9	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000bc	89 45 cc	 mov	 DWORD PTR $T13[ebp+8], eax
  000bf	8b 4d c4	 mov	 ecx, DWORD PTR $T13[ebp]
  000c2	89 4d d4	 mov	 DWORD PTR _y_range$[ebp], ecx
  000c5	8b 55 c8	 mov	 edx, DWORD PTR $T13[ebp+4]
  000c8	89 55 d8	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000cb	8b 45 cc	 mov	 eax, DWORD PTR $T13[ebp+8]
  000ce	89 45 dc	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 738  :     for (int i = 0; i < 3; i++) {

  000d1	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _i$12[ebp], 0
  000d8	eb 09		 jmp	 SHORT $LN4@convert_yu
$LN2@convert_yu:
  000da	8b 4d c0	 mov	 ecx, DWORD PTR _i$12[ebp]
  000dd	83 c1 01	 add	 ecx, 1
  000e0	89 4d c0	 mov	 DWORD PTR _i$12[ebp], ecx
$LN4@convert_yu:
  000e3	83 7d c0 03	 cmp	 DWORD PTR _i$12[ebp], 3
  000e7	0f 8d 1e 01 00
	00		 jge	 $LN1@convert_yu

; 739  :         const uint16_t *srcYLine = (const uint16_t *)src[i] + src_y_pitch * y_range.start_src + crop_left;

  000ed	8b 55 e8	 mov	 edx, DWORD PTR _src_y_pitch$[ebp]
  000f0	0f af 55 d4	 imul	 edx, DWORD PTR _y_range$[ebp]
  000f4	8b 45 c0	 mov	 eax, DWORD PTR _i$12[ebp]
  000f7	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  000fa	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  000fd	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00100	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  00103	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  00106	89 45 bc	 mov	 DWORD PTR _srcYLine$11[ebp], eax

; 740  :         uint16_t *dstLine = (uint16_t *)dst[i] + dst_y_pitch * y_range.start_dst;

  00109	8b 4d e4	 mov	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  0010c	0f af 4d d8	 imul	 ecx, DWORD PTR _y_range$[ebp+4]
  00110	8b 55 c0	 mov	 edx, DWORD PTR _i$12[ebp]
  00113	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  00116	8b 14 90	 mov	 edx, DWORD PTR [eax+edx*4]
  00119	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  0011c	89 45 b8	 mov	 DWORD PTR _dstLine$10[ebp], eax

; 741  :         const int y_width = width - crop_right - crop_left;

  0011f	8b 4b 10	 mov	 ecx, DWORD PTR _width$[ebx]
  00122	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  00125	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  00128	89 4d b4	 mov	 DWORD PTR _y_width$9[ebp], ecx

; 742  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  0012b	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _y$8[ebp], 0
  00132	eb 21		 jmp	 SHORT $LN7@convert_yu
$LN5@convert_yu:
  00134	8b 55 b0	 mov	 edx, DWORD PTR _y$8[ebp]
  00137	83 c2 01	 add	 edx, 1
  0013a	89 55 b0	 mov	 DWORD PTR _y$8[ebp], edx
  0013d	8b 45 e8	 mov	 eax, DWORD PTR _src_y_pitch$[ebp]
  00140	8b 4d bc	 mov	 ecx, DWORD PTR _srcYLine$11[ebp]
  00143	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00146	89 55 bc	 mov	 DWORD PTR _srcYLine$11[ebp], edx
  00149	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  0014c	8b 4d b8	 mov	 ecx, DWORD PTR _dstLine$10[ebp]
  0014f	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00152	89 55 b8	 mov	 DWORD PTR _dstLine$10[ebp], edx
$LN7@convert_yu:
  00155	8b 45 b0	 mov	 eax, DWORD PTR _y$8[ebp]
  00158	3b 45 dc	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  0015b	0f 8d a5 00 00
	00		 jge	 $LN6@convert_yu

; 743  :             if (in_bit_depth == 16) {

  00161	33 c9		 xor	 ecx, ecx
  00163	74 1b		 je	 SHORT $LN11@convert_yu

; 744  :                 avx2_memcpy<true>((uint8_t *)dstLine, (const uint8_t *)srcYLine, y_width * (int)sizeof(uint16_t));

  00165	8b 55 b4	 mov	 edx, DWORD PTR _y_width$9[ebp]
  00168	d1 e2		 shl	 edx, 1
  0016a	52		 push	 edx
  0016b	8b 45 bc	 mov	 eax, DWORD PTR _srcYLine$11[ebp]
  0016e	50		 push	 eax
  0016f	8b 4d b8	 mov	 ecx, DWORD PTR _dstLine$10[ebp]
  00172	51		 push	 ecx
  00173	e8 00 00 00 00	 call	 ??$avx2_memcpy@$00@@YAXPAEPBEH@Z ; avx2_memcpy<1>
  00178	83 c4 0c	 add	 esp, 12			; 0000000cH

; 745  :             } else {

  0017b	e9 81 00 00 00	 jmp	 $LN12@convert_yu
$LN11@convert_yu:

; 746  :                 const uint16_t *src_ptr = srcYLine;

  00180	8b 55 bc	 mov	 edx, DWORD PTR _srcYLine$11[ebp]
  00183	89 55 ac	 mov	 DWORD PTR _src_ptr$7[ebp], edx

; 747  :                 uint16_t *dst_ptr = dstLine;

  00186	8b 45 b8	 mov	 eax, DWORD PTR _dstLine$10[ebp]
  00189	89 45 a8	 mov	 DWORD PTR _dst_ptr$6[ebp], eax

; 748  :                 for (int x = 0; x < y_width; x += 16, dst_ptr += 16, src_ptr += 16) {

  0018c	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _x$5[ebp], 0
  00193	eb 1b		 jmp	 SHORT $LN10@convert_yu
$LN8@convert_yu:
  00195	8b 4d a4	 mov	 ecx, DWORD PTR _x$5[ebp]
  00198	83 c1 10	 add	 ecx, 16			; 00000010H
  0019b	89 4d a4	 mov	 DWORD PTR _x$5[ebp], ecx
  0019e	8b 55 a8	 mov	 edx, DWORD PTR _dst_ptr$6[ebp]
  001a1	83 c2 20	 add	 edx, 32			; 00000020H
  001a4	89 55 a8	 mov	 DWORD PTR _dst_ptr$6[ebp], edx
  001a7	8b 45 ac	 mov	 eax, DWORD PTR _src_ptr$7[ebp]
  001aa	83 c0 20	 add	 eax, 32			; 00000020H
  001ad	89 45 ac	 mov	 DWORD PTR _src_ptr$7[ebp], eax
$LN10@convert_yu:
  001b0	8b 4d a4	 mov	 ecx, DWORD PTR _x$5[ebp]
  001b3	3b 4d b4	 cmp	 ecx, DWORD PTR _y_width$9[ebp]
  001b6	7d 49		 jge	 SHORT $LN12@convert_yu

; 749  :                     __m256i x0 = _mm256_loadu_si256((const __m256i *)src_ptr);

  001b8	8b 55 ac	 mov	 edx, DWORD PTR _src_ptr$7[ebp]
  001bb	c5 fe 6f 02	 vmovdqu ymm0, YMMWORD PTR [edx]
  001bf	c5 fe 7f 85 60
	ff ff ff	 vmovdqu YMMWORD PTR $T3[ebp], ymm0
  001c7	c5 fe 6f 85 60
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T3[ebp]
  001cf	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _x0$4[ebp], ymm0

; 750  :                     x0 = _mm256_slli_epi16(x0, 16 - in_bit_depth);

  001d4	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR _x0$4[ebp]
  001d9	c5 fd 71 f0 07	 vpsllw	 ymm0, ymm0, 7
  001de	c5 fe 7f 85 40
	ff ff ff	 vmovdqu YMMWORD PTR $T2[ebp], ymm0
  001e6	c5 fe 6f 85 40
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T2[ebp]
  001ee	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _x0$4[ebp], ymm0

; 751  :                     _mm256_storeu_si256((__m256i *)dst_ptr, x0);

  001f3	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR _x0$4[ebp]
  001f8	8b 45 a8	 mov	 eax, DWORD PTR _dst_ptr$6[ebp]
  001fb	c5 fe 7f 00	 vmovdqu YMMWORD PTR [eax], ymm0

; 752  :                 }

  001ff	eb 94		 jmp	 SHORT $LN8@convert_yu
$LN12@convert_yu:

; 753  :             }
; 754  :         }

  00201	e9 2e ff ff ff	 jmp	 $LN5@convert_yu
$LN6@convert_yu:

; 755  :     }

  00206	e9 cf fe ff ff	 jmp	 $LN2@convert_yu
$LN1@convert_yu:

; 756  : }

  0020b	52		 push	 edx
  0020c	8b cd		 mov	 ecx, ebp
  0020e	50		 push	 eax
  0020f	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN16@convert_yu
  00215	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0021a	58		 pop	 eax
  0021b	5a		 pop	 edx
  0021c	5f		 pop	 edi
  0021d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00220	33 cd		 xor	 ecx, ebp
  00222	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00227	8b e5		 mov	 esp, ebp
  00229	5d		 pop	 ebp
  0022a	8b e3		 mov	 esp, ebx
  0022c	5b		 pop	 ebx
  0022d	c3		 ret	 0
  0022e	66 90		 npad	 2
$LN16@convert_yu:
  00230	01 00 00 00	 DD	 1
  00234	00 00 00 00	 DD	 $LN15@convert_yu
$LN15@convert_yu:
  00238	d4 ff ff ff	 DD	 -44			; ffffffd4H
  0023c	0c 00 00 00	 DD	 12			; 0000000cH
  00240	00 00 00 00	 DD	 $LN14@convert_yu
$LN14@convert_yu:
  00244	79		 DB	 121			; 00000079H
  00245	5f		 DB	 95			; 0000005fH
  00246	72		 DB	 114			; 00000072H
  00247	61		 DB	 97			; 00000061H
  00248	6e		 DB	 110			; 0000006eH
  00249	67		 DB	 103			; 00000067H
  0024a	65		 DB	 101			; 00000065H
  0024b	00		 DB	 0
??$convert_yuv444_high_to_yuv444_16_avx2_base@$08@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_high_to_yuv444_16_avx2_base<9>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuv444_09_to_yuv444_16_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_09_to_yuv444_16_avx2

; 775  : void convert_yuv444_09_to_yuv444_16_avx2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 776  :     convert_yuv444_high_to_yuv444_16_avx2_base<9>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yuv444_high_to_yuv444_16_avx2_base@$08@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_high_to_yuv444_16_avx2_base<9>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 777  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yuv444_09_to_yuv444_16_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_09_to_yuv444_16_avx2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
$T1 = -208						; size = 12
$T2 = -192						; size = 32
$T3 = -160						; size = 32
_x0$4 = -128						; size = 32
_x$5 = -92						; size = 4
_dst_ptr$6 = -88					; size = 4
_src_ptr$7 = -84					; size = 4
_y$8 = -80						; size = 4
_y_width$9 = -76					; size = 4
_dstLine$10 = -72					; size = 4
_srcYLine$11 = -68					; size = 4
_i$12 = -64						; size = 4
$T13 = -60						; size = 12
_y_range$ = -44						; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yuv444_high_to_yuv444_16_avx2_base@$09@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_high_to_yuv444_16_avx2_base<10>

; 729  : static void __forceinline convert_yuv444_high_to_yuv444_16_avx2_base(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec e0 00 00
	00		 sub	 esp, 224		; 000000e0H
  0001c	57		 push	 edi
  0001d	8d bd 20 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-224]
  00023	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 730  :     static_assert(8 < in_bit_depth && in_bit_depth <= 16, "in_bit_depth must be 9-16.");
; 731  :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 732  :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 733  :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 734  :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 735  :     const int src_y_pitch = src_y_pitch_byte >> 1;

  0007c	8b 53 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  0007f	d1 fa		 sar	 edx, 1
  00081	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 736  :     const int dst_y_pitch = dst_y_pitch_byte >> 1;

  00084	8b 43 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  00087	d1 f8		 sar	 eax, 1
  00089	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 737  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  0008c	8b 4b 2c	 mov	 ecx, DWORD PTR _thread_n$[ebx]
  0008f	51		 push	 ecx
  00090	8b 53 28	 mov	 edx, DWORD PTR _thread_id$[ebx]
  00093	52		 push	 edx
  00094	8b 43 20	 mov	 eax, DWORD PTR _height$[ebx]
  00097	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  0009a	50		 push	 eax
  0009b	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  0009e	51		 push	 ecx
  0009f	8d 95 30 ff ff
	ff		 lea	 edx, DWORD PTR $T1[ebp]
  000a5	52		 push	 edx
  000a6	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  000ab	83 c4 14	 add	 esp, 20			; 00000014H
  000ae	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b0	89 4d c4	 mov	 DWORD PTR $T13[ebp], ecx
  000b3	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000b6	89 55 c8	 mov	 DWORD PTR $T13[ebp+4], edx
  000b9	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000bc	89 45 cc	 mov	 DWORD PTR $T13[ebp+8], eax
  000bf	8b 4d c4	 mov	 ecx, DWORD PTR $T13[ebp]
  000c2	89 4d d4	 mov	 DWORD PTR _y_range$[ebp], ecx
  000c5	8b 55 c8	 mov	 edx, DWORD PTR $T13[ebp+4]
  000c8	89 55 d8	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000cb	8b 45 cc	 mov	 eax, DWORD PTR $T13[ebp+8]
  000ce	89 45 dc	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 738  :     for (int i = 0; i < 3; i++) {

  000d1	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _i$12[ebp], 0
  000d8	eb 09		 jmp	 SHORT $LN4@convert_yu
$LN2@convert_yu:
  000da	8b 4d c0	 mov	 ecx, DWORD PTR _i$12[ebp]
  000dd	83 c1 01	 add	 ecx, 1
  000e0	89 4d c0	 mov	 DWORD PTR _i$12[ebp], ecx
$LN4@convert_yu:
  000e3	83 7d c0 03	 cmp	 DWORD PTR _i$12[ebp], 3
  000e7	0f 8d 1e 01 00
	00		 jge	 $LN1@convert_yu

; 739  :         const uint16_t *srcYLine = (const uint16_t *)src[i] + src_y_pitch * y_range.start_src + crop_left;

  000ed	8b 55 e8	 mov	 edx, DWORD PTR _src_y_pitch$[ebp]
  000f0	0f af 55 d4	 imul	 edx, DWORD PTR _y_range$[ebp]
  000f4	8b 45 c0	 mov	 eax, DWORD PTR _i$12[ebp]
  000f7	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  000fa	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  000fd	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00100	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  00103	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  00106	89 45 bc	 mov	 DWORD PTR _srcYLine$11[ebp], eax

; 740  :         uint16_t *dstLine = (uint16_t *)dst[i] + dst_y_pitch * y_range.start_dst;

  00109	8b 4d e4	 mov	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  0010c	0f af 4d d8	 imul	 ecx, DWORD PTR _y_range$[ebp+4]
  00110	8b 55 c0	 mov	 edx, DWORD PTR _i$12[ebp]
  00113	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  00116	8b 14 90	 mov	 edx, DWORD PTR [eax+edx*4]
  00119	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  0011c	89 45 b8	 mov	 DWORD PTR _dstLine$10[ebp], eax

; 741  :         const int y_width = width - crop_right - crop_left;

  0011f	8b 4b 10	 mov	 ecx, DWORD PTR _width$[ebx]
  00122	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  00125	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  00128	89 4d b4	 mov	 DWORD PTR _y_width$9[ebp], ecx

; 742  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  0012b	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _y$8[ebp], 0
  00132	eb 21		 jmp	 SHORT $LN7@convert_yu
$LN5@convert_yu:
  00134	8b 55 b0	 mov	 edx, DWORD PTR _y$8[ebp]
  00137	83 c2 01	 add	 edx, 1
  0013a	89 55 b0	 mov	 DWORD PTR _y$8[ebp], edx
  0013d	8b 45 e8	 mov	 eax, DWORD PTR _src_y_pitch$[ebp]
  00140	8b 4d bc	 mov	 ecx, DWORD PTR _srcYLine$11[ebp]
  00143	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00146	89 55 bc	 mov	 DWORD PTR _srcYLine$11[ebp], edx
  00149	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  0014c	8b 4d b8	 mov	 ecx, DWORD PTR _dstLine$10[ebp]
  0014f	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00152	89 55 b8	 mov	 DWORD PTR _dstLine$10[ebp], edx
$LN7@convert_yu:
  00155	8b 45 b0	 mov	 eax, DWORD PTR _y$8[ebp]
  00158	3b 45 dc	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  0015b	0f 8d a5 00 00
	00		 jge	 $LN6@convert_yu

; 743  :             if (in_bit_depth == 16) {

  00161	33 c9		 xor	 ecx, ecx
  00163	74 1b		 je	 SHORT $LN11@convert_yu

; 744  :                 avx2_memcpy<true>((uint8_t *)dstLine, (const uint8_t *)srcYLine, y_width * (int)sizeof(uint16_t));

  00165	8b 55 b4	 mov	 edx, DWORD PTR _y_width$9[ebp]
  00168	d1 e2		 shl	 edx, 1
  0016a	52		 push	 edx
  0016b	8b 45 bc	 mov	 eax, DWORD PTR _srcYLine$11[ebp]
  0016e	50		 push	 eax
  0016f	8b 4d b8	 mov	 ecx, DWORD PTR _dstLine$10[ebp]
  00172	51		 push	 ecx
  00173	e8 00 00 00 00	 call	 ??$avx2_memcpy@$00@@YAXPAEPBEH@Z ; avx2_memcpy<1>
  00178	83 c4 0c	 add	 esp, 12			; 0000000cH

; 745  :             } else {

  0017b	e9 81 00 00 00	 jmp	 $LN12@convert_yu
$LN11@convert_yu:

; 746  :                 const uint16_t *src_ptr = srcYLine;

  00180	8b 55 bc	 mov	 edx, DWORD PTR _srcYLine$11[ebp]
  00183	89 55 ac	 mov	 DWORD PTR _src_ptr$7[ebp], edx

; 747  :                 uint16_t *dst_ptr = dstLine;

  00186	8b 45 b8	 mov	 eax, DWORD PTR _dstLine$10[ebp]
  00189	89 45 a8	 mov	 DWORD PTR _dst_ptr$6[ebp], eax

; 748  :                 for (int x = 0; x < y_width; x += 16, dst_ptr += 16, src_ptr += 16) {

  0018c	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _x$5[ebp], 0
  00193	eb 1b		 jmp	 SHORT $LN10@convert_yu
$LN8@convert_yu:
  00195	8b 4d a4	 mov	 ecx, DWORD PTR _x$5[ebp]
  00198	83 c1 10	 add	 ecx, 16			; 00000010H
  0019b	89 4d a4	 mov	 DWORD PTR _x$5[ebp], ecx
  0019e	8b 55 a8	 mov	 edx, DWORD PTR _dst_ptr$6[ebp]
  001a1	83 c2 20	 add	 edx, 32			; 00000020H
  001a4	89 55 a8	 mov	 DWORD PTR _dst_ptr$6[ebp], edx
  001a7	8b 45 ac	 mov	 eax, DWORD PTR _src_ptr$7[ebp]
  001aa	83 c0 20	 add	 eax, 32			; 00000020H
  001ad	89 45 ac	 mov	 DWORD PTR _src_ptr$7[ebp], eax
$LN10@convert_yu:
  001b0	8b 4d a4	 mov	 ecx, DWORD PTR _x$5[ebp]
  001b3	3b 4d b4	 cmp	 ecx, DWORD PTR _y_width$9[ebp]
  001b6	7d 49		 jge	 SHORT $LN12@convert_yu

; 749  :                     __m256i x0 = _mm256_loadu_si256((const __m256i *)src_ptr);

  001b8	8b 55 ac	 mov	 edx, DWORD PTR _src_ptr$7[ebp]
  001bb	c5 fe 6f 02	 vmovdqu ymm0, YMMWORD PTR [edx]
  001bf	c5 fe 7f 85 60
	ff ff ff	 vmovdqu YMMWORD PTR $T3[ebp], ymm0
  001c7	c5 fe 6f 85 60
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T3[ebp]
  001cf	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _x0$4[ebp], ymm0

; 750  :                     x0 = _mm256_slli_epi16(x0, 16 - in_bit_depth);

  001d4	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR _x0$4[ebp]
  001d9	c5 fd 71 f0 06	 vpsllw	 ymm0, ymm0, 6
  001de	c5 fe 7f 85 40
	ff ff ff	 vmovdqu YMMWORD PTR $T2[ebp], ymm0
  001e6	c5 fe 6f 85 40
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T2[ebp]
  001ee	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _x0$4[ebp], ymm0

; 751  :                     _mm256_storeu_si256((__m256i *)dst_ptr, x0);

  001f3	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR _x0$4[ebp]
  001f8	8b 45 a8	 mov	 eax, DWORD PTR _dst_ptr$6[ebp]
  001fb	c5 fe 7f 00	 vmovdqu YMMWORD PTR [eax], ymm0

; 752  :                 }

  001ff	eb 94		 jmp	 SHORT $LN8@convert_yu
$LN12@convert_yu:

; 753  :             }
; 754  :         }

  00201	e9 2e ff ff ff	 jmp	 $LN5@convert_yu
$LN6@convert_yu:

; 755  :     }

  00206	e9 cf fe ff ff	 jmp	 $LN2@convert_yu
$LN1@convert_yu:

; 756  : }

  0020b	52		 push	 edx
  0020c	8b cd		 mov	 ecx, ebp
  0020e	50		 push	 eax
  0020f	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN16@convert_yu
  00215	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0021a	58		 pop	 eax
  0021b	5a		 pop	 edx
  0021c	5f		 pop	 edi
  0021d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00220	33 cd		 xor	 ecx, ebp
  00222	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00227	8b e5		 mov	 esp, ebp
  00229	5d		 pop	 ebp
  0022a	8b e3		 mov	 esp, ebx
  0022c	5b		 pop	 ebx
  0022d	c3		 ret	 0
  0022e	66 90		 npad	 2
$LN16@convert_yu:
  00230	01 00 00 00	 DD	 1
  00234	00 00 00 00	 DD	 $LN15@convert_yu
$LN15@convert_yu:
  00238	d4 ff ff ff	 DD	 -44			; ffffffd4H
  0023c	0c 00 00 00	 DD	 12			; 0000000cH
  00240	00 00 00 00	 DD	 $LN14@convert_yu
$LN14@convert_yu:
  00244	79		 DB	 121			; 00000079H
  00245	5f		 DB	 95			; 0000005fH
  00246	72		 DB	 114			; 00000072H
  00247	61		 DB	 97			; 00000061H
  00248	6e		 DB	 110			; 0000006eH
  00249	67		 DB	 103			; 00000067H
  0024a	65		 DB	 101			; 00000065H
  0024b	00		 DB	 0
??$convert_yuv444_high_to_yuv444_16_avx2_base@$09@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_high_to_yuv444_16_avx2_base<10>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuv444_10_to_yuv444_16_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_10_to_yuv444_16_avx2

; 771  : void convert_yuv444_10_to_yuv444_16_avx2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 772  :     convert_yuv444_high_to_yuv444_16_avx2_base<10>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yuv444_high_to_yuv444_16_avx2_base@$09@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_high_to_yuv444_16_avx2_base<10>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 773  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yuv444_10_to_yuv444_16_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_10_to_yuv444_16_avx2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
$T1 = -208						; size = 12
$T2 = -192						; size = 32
$T3 = -160						; size = 32
_x0$4 = -128						; size = 32
_x$5 = -92						; size = 4
_dst_ptr$6 = -88					; size = 4
_src_ptr$7 = -84					; size = 4
_y$8 = -80						; size = 4
_y_width$9 = -76					; size = 4
_dstLine$10 = -72					; size = 4
_srcYLine$11 = -68					; size = 4
_i$12 = -64						; size = 4
$T13 = -60						; size = 12
_y_range$ = -44						; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yuv444_high_to_yuv444_16_avx2_base@$0M@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_high_to_yuv444_16_avx2_base<12>

; 729  : static void __forceinline convert_yuv444_high_to_yuv444_16_avx2_base(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec e0 00 00
	00		 sub	 esp, 224		; 000000e0H
  0001c	57		 push	 edi
  0001d	8d bd 20 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-224]
  00023	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 730  :     static_assert(8 < in_bit_depth && in_bit_depth <= 16, "in_bit_depth must be 9-16.");
; 731  :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 732  :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 733  :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 734  :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 735  :     const int src_y_pitch = src_y_pitch_byte >> 1;

  0007c	8b 53 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  0007f	d1 fa		 sar	 edx, 1
  00081	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 736  :     const int dst_y_pitch = dst_y_pitch_byte >> 1;

  00084	8b 43 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  00087	d1 f8		 sar	 eax, 1
  00089	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 737  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  0008c	8b 4b 2c	 mov	 ecx, DWORD PTR _thread_n$[ebx]
  0008f	51		 push	 ecx
  00090	8b 53 28	 mov	 edx, DWORD PTR _thread_id$[ebx]
  00093	52		 push	 edx
  00094	8b 43 20	 mov	 eax, DWORD PTR _height$[ebx]
  00097	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  0009a	50		 push	 eax
  0009b	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  0009e	51		 push	 ecx
  0009f	8d 95 30 ff ff
	ff		 lea	 edx, DWORD PTR $T1[ebp]
  000a5	52		 push	 edx
  000a6	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  000ab	83 c4 14	 add	 esp, 20			; 00000014H
  000ae	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b0	89 4d c4	 mov	 DWORD PTR $T13[ebp], ecx
  000b3	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000b6	89 55 c8	 mov	 DWORD PTR $T13[ebp+4], edx
  000b9	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000bc	89 45 cc	 mov	 DWORD PTR $T13[ebp+8], eax
  000bf	8b 4d c4	 mov	 ecx, DWORD PTR $T13[ebp]
  000c2	89 4d d4	 mov	 DWORD PTR _y_range$[ebp], ecx
  000c5	8b 55 c8	 mov	 edx, DWORD PTR $T13[ebp+4]
  000c8	89 55 d8	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000cb	8b 45 cc	 mov	 eax, DWORD PTR $T13[ebp+8]
  000ce	89 45 dc	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 738  :     for (int i = 0; i < 3; i++) {

  000d1	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _i$12[ebp], 0
  000d8	eb 09		 jmp	 SHORT $LN4@convert_yu
$LN2@convert_yu:
  000da	8b 4d c0	 mov	 ecx, DWORD PTR _i$12[ebp]
  000dd	83 c1 01	 add	 ecx, 1
  000e0	89 4d c0	 mov	 DWORD PTR _i$12[ebp], ecx
$LN4@convert_yu:
  000e3	83 7d c0 03	 cmp	 DWORD PTR _i$12[ebp], 3
  000e7	0f 8d 1e 01 00
	00		 jge	 $LN1@convert_yu

; 739  :         const uint16_t *srcYLine = (const uint16_t *)src[i] + src_y_pitch * y_range.start_src + crop_left;

  000ed	8b 55 e8	 mov	 edx, DWORD PTR _src_y_pitch$[ebp]
  000f0	0f af 55 d4	 imul	 edx, DWORD PTR _y_range$[ebp]
  000f4	8b 45 c0	 mov	 eax, DWORD PTR _i$12[ebp]
  000f7	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  000fa	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  000fd	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00100	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  00103	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  00106	89 45 bc	 mov	 DWORD PTR _srcYLine$11[ebp], eax

; 740  :         uint16_t *dstLine = (uint16_t *)dst[i] + dst_y_pitch * y_range.start_dst;

  00109	8b 4d e4	 mov	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  0010c	0f af 4d d8	 imul	 ecx, DWORD PTR _y_range$[ebp+4]
  00110	8b 55 c0	 mov	 edx, DWORD PTR _i$12[ebp]
  00113	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  00116	8b 14 90	 mov	 edx, DWORD PTR [eax+edx*4]
  00119	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  0011c	89 45 b8	 mov	 DWORD PTR _dstLine$10[ebp], eax

; 741  :         const int y_width = width - crop_right - crop_left;

  0011f	8b 4b 10	 mov	 ecx, DWORD PTR _width$[ebx]
  00122	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  00125	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  00128	89 4d b4	 mov	 DWORD PTR _y_width$9[ebp], ecx

; 742  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  0012b	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _y$8[ebp], 0
  00132	eb 21		 jmp	 SHORT $LN7@convert_yu
$LN5@convert_yu:
  00134	8b 55 b0	 mov	 edx, DWORD PTR _y$8[ebp]
  00137	83 c2 01	 add	 edx, 1
  0013a	89 55 b0	 mov	 DWORD PTR _y$8[ebp], edx
  0013d	8b 45 e8	 mov	 eax, DWORD PTR _src_y_pitch$[ebp]
  00140	8b 4d bc	 mov	 ecx, DWORD PTR _srcYLine$11[ebp]
  00143	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00146	89 55 bc	 mov	 DWORD PTR _srcYLine$11[ebp], edx
  00149	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  0014c	8b 4d b8	 mov	 ecx, DWORD PTR _dstLine$10[ebp]
  0014f	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00152	89 55 b8	 mov	 DWORD PTR _dstLine$10[ebp], edx
$LN7@convert_yu:
  00155	8b 45 b0	 mov	 eax, DWORD PTR _y$8[ebp]
  00158	3b 45 dc	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  0015b	0f 8d a5 00 00
	00		 jge	 $LN6@convert_yu

; 743  :             if (in_bit_depth == 16) {

  00161	33 c9		 xor	 ecx, ecx
  00163	74 1b		 je	 SHORT $LN11@convert_yu

; 744  :                 avx2_memcpy<true>((uint8_t *)dstLine, (const uint8_t *)srcYLine, y_width * (int)sizeof(uint16_t));

  00165	8b 55 b4	 mov	 edx, DWORD PTR _y_width$9[ebp]
  00168	d1 e2		 shl	 edx, 1
  0016a	52		 push	 edx
  0016b	8b 45 bc	 mov	 eax, DWORD PTR _srcYLine$11[ebp]
  0016e	50		 push	 eax
  0016f	8b 4d b8	 mov	 ecx, DWORD PTR _dstLine$10[ebp]
  00172	51		 push	 ecx
  00173	e8 00 00 00 00	 call	 ??$avx2_memcpy@$00@@YAXPAEPBEH@Z ; avx2_memcpy<1>
  00178	83 c4 0c	 add	 esp, 12			; 0000000cH

; 745  :             } else {

  0017b	e9 81 00 00 00	 jmp	 $LN12@convert_yu
$LN11@convert_yu:

; 746  :                 const uint16_t *src_ptr = srcYLine;

  00180	8b 55 bc	 mov	 edx, DWORD PTR _srcYLine$11[ebp]
  00183	89 55 ac	 mov	 DWORD PTR _src_ptr$7[ebp], edx

; 747  :                 uint16_t *dst_ptr = dstLine;

  00186	8b 45 b8	 mov	 eax, DWORD PTR _dstLine$10[ebp]
  00189	89 45 a8	 mov	 DWORD PTR _dst_ptr$6[ebp], eax

; 748  :                 for (int x = 0; x < y_width; x += 16, dst_ptr += 16, src_ptr += 16) {

  0018c	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _x$5[ebp], 0
  00193	eb 1b		 jmp	 SHORT $LN10@convert_yu
$LN8@convert_yu:
  00195	8b 4d a4	 mov	 ecx, DWORD PTR _x$5[ebp]
  00198	83 c1 10	 add	 ecx, 16			; 00000010H
  0019b	89 4d a4	 mov	 DWORD PTR _x$5[ebp], ecx
  0019e	8b 55 a8	 mov	 edx, DWORD PTR _dst_ptr$6[ebp]
  001a1	83 c2 20	 add	 edx, 32			; 00000020H
  001a4	89 55 a8	 mov	 DWORD PTR _dst_ptr$6[ebp], edx
  001a7	8b 45 ac	 mov	 eax, DWORD PTR _src_ptr$7[ebp]
  001aa	83 c0 20	 add	 eax, 32			; 00000020H
  001ad	89 45 ac	 mov	 DWORD PTR _src_ptr$7[ebp], eax
$LN10@convert_yu:
  001b0	8b 4d a4	 mov	 ecx, DWORD PTR _x$5[ebp]
  001b3	3b 4d b4	 cmp	 ecx, DWORD PTR _y_width$9[ebp]
  001b6	7d 49		 jge	 SHORT $LN12@convert_yu

; 749  :                     __m256i x0 = _mm256_loadu_si256((const __m256i *)src_ptr);

  001b8	8b 55 ac	 mov	 edx, DWORD PTR _src_ptr$7[ebp]
  001bb	c5 fe 6f 02	 vmovdqu ymm0, YMMWORD PTR [edx]
  001bf	c5 fe 7f 85 60
	ff ff ff	 vmovdqu YMMWORD PTR $T3[ebp], ymm0
  001c7	c5 fe 6f 85 60
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T3[ebp]
  001cf	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _x0$4[ebp], ymm0

; 750  :                     x0 = _mm256_slli_epi16(x0, 16 - in_bit_depth);

  001d4	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR _x0$4[ebp]
  001d9	c5 fd 71 f0 04	 vpsllw	 ymm0, ymm0, 4
  001de	c5 fe 7f 85 40
	ff ff ff	 vmovdqu YMMWORD PTR $T2[ebp], ymm0
  001e6	c5 fe 6f 85 40
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T2[ebp]
  001ee	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _x0$4[ebp], ymm0

; 751  :                     _mm256_storeu_si256((__m256i *)dst_ptr, x0);

  001f3	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR _x0$4[ebp]
  001f8	8b 45 a8	 mov	 eax, DWORD PTR _dst_ptr$6[ebp]
  001fb	c5 fe 7f 00	 vmovdqu YMMWORD PTR [eax], ymm0

; 752  :                 }

  001ff	eb 94		 jmp	 SHORT $LN8@convert_yu
$LN12@convert_yu:

; 753  :             }
; 754  :         }

  00201	e9 2e ff ff ff	 jmp	 $LN5@convert_yu
$LN6@convert_yu:

; 755  :     }

  00206	e9 cf fe ff ff	 jmp	 $LN2@convert_yu
$LN1@convert_yu:

; 756  : }

  0020b	52		 push	 edx
  0020c	8b cd		 mov	 ecx, ebp
  0020e	50		 push	 eax
  0020f	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN16@convert_yu
  00215	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0021a	58		 pop	 eax
  0021b	5a		 pop	 edx
  0021c	5f		 pop	 edi
  0021d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00220	33 cd		 xor	 ecx, ebp
  00222	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00227	8b e5		 mov	 esp, ebp
  00229	5d		 pop	 ebp
  0022a	8b e3		 mov	 esp, ebx
  0022c	5b		 pop	 ebx
  0022d	c3		 ret	 0
  0022e	66 90		 npad	 2
$LN16@convert_yu:
  00230	01 00 00 00	 DD	 1
  00234	00 00 00 00	 DD	 $LN15@convert_yu
$LN15@convert_yu:
  00238	d4 ff ff ff	 DD	 -44			; ffffffd4H
  0023c	0c 00 00 00	 DD	 12			; 0000000cH
  00240	00 00 00 00	 DD	 $LN14@convert_yu
$LN14@convert_yu:
  00244	79		 DB	 121			; 00000079H
  00245	5f		 DB	 95			; 0000005fH
  00246	72		 DB	 114			; 00000072H
  00247	61		 DB	 97			; 00000061H
  00248	6e		 DB	 110			; 0000006eH
  00249	67		 DB	 103			; 00000067H
  0024a	65		 DB	 101			; 00000065H
  0024b	00		 DB	 0
??$convert_yuv444_high_to_yuv444_16_avx2_base@$0M@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_high_to_yuv444_16_avx2_base<12>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuv444_12_to_yuv444_16_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_12_to_yuv444_16_avx2

; 767  : void convert_yuv444_12_to_yuv444_16_avx2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 768  :     convert_yuv444_high_to_yuv444_16_avx2_base<12>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yuv444_high_to_yuv444_16_avx2_base@$0M@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_high_to_yuv444_16_avx2_base<12>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 769  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yuv444_12_to_yuv444_16_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_12_to_yuv444_16_avx2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
$T1 = -208						; size = 12
$T2 = -192						; size = 32
$T3 = -160						; size = 32
_x0$4 = -128						; size = 32
_x$5 = -92						; size = 4
_dst_ptr$6 = -88					; size = 4
_src_ptr$7 = -84					; size = 4
_y$8 = -80						; size = 4
_y_width$9 = -76					; size = 4
_dstLine$10 = -72					; size = 4
_srcYLine$11 = -68					; size = 4
_i$12 = -64						; size = 4
$T13 = -60						; size = 12
_y_range$ = -44						; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yuv444_high_to_yuv444_16_avx2_base@$0O@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_high_to_yuv444_16_avx2_base<14>

; 729  : static void __forceinline convert_yuv444_high_to_yuv444_16_avx2_base(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec e0 00 00
	00		 sub	 esp, 224		; 000000e0H
  0001c	57		 push	 edi
  0001d	8d bd 20 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-224]
  00023	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 730  :     static_assert(8 < in_bit_depth && in_bit_depth <= 16, "in_bit_depth must be 9-16.");
; 731  :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 732  :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 733  :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 734  :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 735  :     const int src_y_pitch = src_y_pitch_byte >> 1;

  0007c	8b 53 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  0007f	d1 fa		 sar	 edx, 1
  00081	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 736  :     const int dst_y_pitch = dst_y_pitch_byte >> 1;

  00084	8b 43 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  00087	d1 f8		 sar	 eax, 1
  00089	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 737  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  0008c	8b 4b 2c	 mov	 ecx, DWORD PTR _thread_n$[ebx]
  0008f	51		 push	 ecx
  00090	8b 53 28	 mov	 edx, DWORD PTR _thread_id$[ebx]
  00093	52		 push	 edx
  00094	8b 43 20	 mov	 eax, DWORD PTR _height$[ebx]
  00097	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  0009a	50		 push	 eax
  0009b	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  0009e	51		 push	 ecx
  0009f	8d 95 30 ff ff
	ff		 lea	 edx, DWORD PTR $T1[ebp]
  000a5	52		 push	 edx
  000a6	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  000ab	83 c4 14	 add	 esp, 20			; 00000014H
  000ae	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b0	89 4d c4	 mov	 DWORD PTR $T13[ebp], ecx
  000b3	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000b6	89 55 c8	 mov	 DWORD PTR $T13[ebp+4], edx
  000b9	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000bc	89 45 cc	 mov	 DWORD PTR $T13[ebp+8], eax
  000bf	8b 4d c4	 mov	 ecx, DWORD PTR $T13[ebp]
  000c2	89 4d d4	 mov	 DWORD PTR _y_range$[ebp], ecx
  000c5	8b 55 c8	 mov	 edx, DWORD PTR $T13[ebp+4]
  000c8	89 55 d8	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000cb	8b 45 cc	 mov	 eax, DWORD PTR $T13[ebp+8]
  000ce	89 45 dc	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 738  :     for (int i = 0; i < 3; i++) {

  000d1	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _i$12[ebp], 0
  000d8	eb 09		 jmp	 SHORT $LN4@convert_yu
$LN2@convert_yu:
  000da	8b 4d c0	 mov	 ecx, DWORD PTR _i$12[ebp]
  000dd	83 c1 01	 add	 ecx, 1
  000e0	89 4d c0	 mov	 DWORD PTR _i$12[ebp], ecx
$LN4@convert_yu:
  000e3	83 7d c0 03	 cmp	 DWORD PTR _i$12[ebp], 3
  000e7	0f 8d 1e 01 00
	00		 jge	 $LN1@convert_yu

; 739  :         const uint16_t *srcYLine = (const uint16_t *)src[i] + src_y_pitch * y_range.start_src + crop_left;

  000ed	8b 55 e8	 mov	 edx, DWORD PTR _src_y_pitch$[ebp]
  000f0	0f af 55 d4	 imul	 edx, DWORD PTR _y_range$[ebp]
  000f4	8b 45 c0	 mov	 eax, DWORD PTR _i$12[ebp]
  000f7	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  000fa	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  000fd	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00100	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  00103	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  00106	89 45 bc	 mov	 DWORD PTR _srcYLine$11[ebp], eax

; 740  :         uint16_t *dstLine = (uint16_t *)dst[i] + dst_y_pitch * y_range.start_dst;

  00109	8b 4d e4	 mov	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  0010c	0f af 4d d8	 imul	 ecx, DWORD PTR _y_range$[ebp+4]
  00110	8b 55 c0	 mov	 edx, DWORD PTR _i$12[ebp]
  00113	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  00116	8b 14 90	 mov	 edx, DWORD PTR [eax+edx*4]
  00119	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  0011c	89 45 b8	 mov	 DWORD PTR _dstLine$10[ebp], eax

; 741  :         const int y_width = width - crop_right - crop_left;

  0011f	8b 4b 10	 mov	 ecx, DWORD PTR _width$[ebx]
  00122	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  00125	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  00128	89 4d b4	 mov	 DWORD PTR _y_width$9[ebp], ecx

; 742  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  0012b	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _y$8[ebp], 0
  00132	eb 21		 jmp	 SHORT $LN7@convert_yu
$LN5@convert_yu:
  00134	8b 55 b0	 mov	 edx, DWORD PTR _y$8[ebp]
  00137	83 c2 01	 add	 edx, 1
  0013a	89 55 b0	 mov	 DWORD PTR _y$8[ebp], edx
  0013d	8b 45 e8	 mov	 eax, DWORD PTR _src_y_pitch$[ebp]
  00140	8b 4d bc	 mov	 ecx, DWORD PTR _srcYLine$11[ebp]
  00143	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00146	89 55 bc	 mov	 DWORD PTR _srcYLine$11[ebp], edx
  00149	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  0014c	8b 4d b8	 mov	 ecx, DWORD PTR _dstLine$10[ebp]
  0014f	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00152	89 55 b8	 mov	 DWORD PTR _dstLine$10[ebp], edx
$LN7@convert_yu:
  00155	8b 45 b0	 mov	 eax, DWORD PTR _y$8[ebp]
  00158	3b 45 dc	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  0015b	0f 8d a5 00 00
	00		 jge	 $LN6@convert_yu

; 743  :             if (in_bit_depth == 16) {

  00161	33 c9		 xor	 ecx, ecx
  00163	74 1b		 je	 SHORT $LN11@convert_yu

; 744  :                 avx2_memcpy<true>((uint8_t *)dstLine, (const uint8_t *)srcYLine, y_width * (int)sizeof(uint16_t));

  00165	8b 55 b4	 mov	 edx, DWORD PTR _y_width$9[ebp]
  00168	d1 e2		 shl	 edx, 1
  0016a	52		 push	 edx
  0016b	8b 45 bc	 mov	 eax, DWORD PTR _srcYLine$11[ebp]
  0016e	50		 push	 eax
  0016f	8b 4d b8	 mov	 ecx, DWORD PTR _dstLine$10[ebp]
  00172	51		 push	 ecx
  00173	e8 00 00 00 00	 call	 ??$avx2_memcpy@$00@@YAXPAEPBEH@Z ; avx2_memcpy<1>
  00178	83 c4 0c	 add	 esp, 12			; 0000000cH

; 745  :             } else {

  0017b	e9 81 00 00 00	 jmp	 $LN12@convert_yu
$LN11@convert_yu:

; 746  :                 const uint16_t *src_ptr = srcYLine;

  00180	8b 55 bc	 mov	 edx, DWORD PTR _srcYLine$11[ebp]
  00183	89 55 ac	 mov	 DWORD PTR _src_ptr$7[ebp], edx

; 747  :                 uint16_t *dst_ptr = dstLine;

  00186	8b 45 b8	 mov	 eax, DWORD PTR _dstLine$10[ebp]
  00189	89 45 a8	 mov	 DWORD PTR _dst_ptr$6[ebp], eax

; 748  :                 for (int x = 0; x < y_width; x += 16, dst_ptr += 16, src_ptr += 16) {

  0018c	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _x$5[ebp], 0
  00193	eb 1b		 jmp	 SHORT $LN10@convert_yu
$LN8@convert_yu:
  00195	8b 4d a4	 mov	 ecx, DWORD PTR _x$5[ebp]
  00198	83 c1 10	 add	 ecx, 16			; 00000010H
  0019b	89 4d a4	 mov	 DWORD PTR _x$5[ebp], ecx
  0019e	8b 55 a8	 mov	 edx, DWORD PTR _dst_ptr$6[ebp]
  001a1	83 c2 20	 add	 edx, 32			; 00000020H
  001a4	89 55 a8	 mov	 DWORD PTR _dst_ptr$6[ebp], edx
  001a7	8b 45 ac	 mov	 eax, DWORD PTR _src_ptr$7[ebp]
  001aa	83 c0 20	 add	 eax, 32			; 00000020H
  001ad	89 45 ac	 mov	 DWORD PTR _src_ptr$7[ebp], eax
$LN10@convert_yu:
  001b0	8b 4d a4	 mov	 ecx, DWORD PTR _x$5[ebp]
  001b3	3b 4d b4	 cmp	 ecx, DWORD PTR _y_width$9[ebp]
  001b6	7d 49		 jge	 SHORT $LN12@convert_yu

; 749  :                     __m256i x0 = _mm256_loadu_si256((const __m256i *)src_ptr);

  001b8	8b 55 ac	 mov	 edx, DWORD PTR _src_ptr$7[ebp]
  001bb	c5 fe 6f 02	 vmovdqu ymm0, YMMWORD PTR [edx]
  001bf	c5 fe 7f 85 60
	ff ff ff	 vmovdqu YMMWORD PTR $T3[ebp], ymm0
  001c7	c5 fe 6f 85 60
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T3[ebp]
  001cf	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _x0$4[ebp], ymm0

; 750  :                     x0 = _mm256_slli_epi16(x0, 16 - in_bit_depth);

  001d4	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR _x0$4[ebp]
  001d9	c5 fd 71 f0 02	 vpsllw	 ymm0, ymm0, 2
  001de	c5 fe 7f 85 40
	ff ff ff	 vmovdqu YMMWORD PTR $T2[ebp], ymm0
  001e6	c5 fe 6f 85 40
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T2[ebp]
  001ee	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _x0$4[ebp], ymm0

; 751  :                     _mm256_storeu_si256((__m256i *)dst_ptr, x0);

  001f3	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR _x0$4[ebp]
  001f8	8b 45 a8	 mov	 eax, DWORD PTR _dst_ptr$6[ebp]
  001fb	c5 fe 7f 00	 vmovdqu YMMWORD PTR [eax], ymm0

; 752  :                 }

  001ff	eb 94		 jmp	 SHORT $LN8@convert_yu
$LN12@convert_yu:

; 753  :             }
; 754  :         }

  00201	e9 2e ff ff ff	 jmp	 $LN5@convert_yu
$LN6@convert_yu:

; 755  :     }

  00206	e9 cf fe ff ff	 jmp	 $LN2@convert_yu
$LN1@convert_yu:

; 756  : }

  0020b	52		 push	 edx
  0020c	8b cd		 mov	 ecx, ebp
  0020e	50		 push	 eax
  0020f	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN16@convert_yu
  00215	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0021a	58		 pop	 eax
  0021b	5a		 pop	 edx
  0021c	5f		 pop	 edi
  0021d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00220	33 cd		 xor	 ecx, ebp
  00222	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00227	8b e5		 mov	 esp, ebp
  00229	5d		 pop	 ebp
  0022a	8b e3		 mov	 esp, ebx
  0022c	5b		 pop	 ebx
  0022d	c3		 ret	 0
  0022e	66 90		 npad	 2
$LN16@convert_yu:
  00230	01 00 00 00	 DD	 1
  00234	00 00 00 00	 DD	 $LN15@convert_yu
$LN15@convert_yu:
  00238	d4 ff ff ff	 DD	 -44			; ffffffd4H
  0023c	0c 00 00 00	 DD	 12			; 0000000cH
  00240	00 00 00 00	 DD	 $LN14@convert_yu
$LN14@convert_yu:
  00244	79		 DB	 121			; 00000079H
  00245	5f		 DB	 95			; 0000005fH
  00246	72		 DB	 114			; 00000072H
  00247	61		 DB	 97			; 00000061H
  00248	6e		 DB	 110			; 0000006eH
  00249	67		 DB	 103			; 00000067H
  0024a	65		 DB	 101			; 00000065H
  0024b	00		 DB	 0
??$convert_yuv444_high_to_yuv444_16_avx2_base@$0O@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_high_to_yuv444_16_avx2_base<14>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuv444_14_to_yuv444_16_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_14_to_yuv444_16_avx2

; 763  : void convert_yuv444_14_to_yuv444_16_avx2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 764  :     convert_yuv444_high_to_yuv444_16_avx2_base<14>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yuv444_high_to_yuv444_16_avx2_base@$0O@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_high_to_yuv444_16_avx2_base<14>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 765  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yuv444_14_to_yuv444_16_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_14_to_yuv444_16_avx2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
$T1 = -208						; size = 12
$T2 = -192						; size = 32
$T3 = -160						; size = 32
_x0$4 = -128						; size = 32
_x$5 = -92						; size = 4
_dst_ptr$6 = -88					; size = 4
_src_ptr$7 = -84					; size = 4
_y$8 = -80						; size = 4
_y_width$9 = -76					; size = 4
_dstLine$10 = -72					; size = 4
_srcYLine$11 = -68					; size = 4
_i$12 = -64						; size = 4
$T13 = -60						; size = 12
_y_range$ = -44						; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yuv444_high_to_yuv444_16_avx2_base@$0BA@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_high_to_yuv444_16_avx2_base<16>

; 729  : static void __forceinline convert_yuv444_high_to_yuv444_16_avx2_base(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec e0 00 00
	00		 sub	 esp, 224		; 000000e0H
  0001c	57		 push	 edi
  0001d	8d bd 20 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-224]
  00023	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 730  :     static_assert(8 < in_bit_depth && in_bit_depth <= 16, "in_bit_depth must be 9-16.");
; 731  :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 732  :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 733  :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 734  :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 735  :     const int src_y_pitch = src_y_pitch_byte >> 1;

  0007c	8b 53 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  0007f	d1 fa		 sar	 edx, 1
  00081	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 736  :     const int dst_y_pitch = dst_y_pitch_byte >> 1;

  00084	8b 43 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  00087	d1 f8		 sar	 eax, 1
  00089	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 737  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  0008c	8b 4b 2c	 mov	 ecx, DWORD PTR _thread_n$[ebx]
  0008f	51		 push	 ecx
  00090	8b 53 28	 mov	 edx, DWORD PTR _thread_id$[ebx]
  00093	52		 push	 edx
  00094	8b 43 20	 mov	 eax, DWORD PTR _height$[ebx]
  00097	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  0009a	50		 push	 eax
  0009b	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  0009e	51		 push	 ecx
  0009f	8d 95 30 ff ff
	ff		 lea	 edx, DWORD PTR $T1[ebp]
  000a5	52		 push	 edx
  000a6	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  000ab	83 c4 14	 add	 esp, 20			; 00000014H
  000ae	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b0	89 4d c4	 mov	 DWORD PTR $T13[ebp], ecx
  000b3	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000b6	89 55 c8	 mov	 DWORD PTR $T13[ebp+4], edx
  000b9	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000bc	89 45 cc	 mov	 DWORD PTR $T13[ebp+8], eax
  000bf	8b 4d c4	 mov	 ecx, DWORD PTR $T13[ebp]
  000c2	89 4d d4	 mov	 DWORD PTR _y_range$[ebp], ecx
  000c5	8b 55 c8	 mov	 edx, DWORD PTR $T13[ebp+4]
  000c8	89 55 d8	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000cb	8b 45 cc	 mov	 eax, DWORD PTR $T13[ebp+8]
  000ce	89 45 dc	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 738  :     for (int i = 0; i < 3; i++) {

  000d1	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _i$12[ebp], 0
  000d8	eb 09		 jmp	 SHORT $LN4@convert_yu
$LN2@convert_yu:
  000da	8b 4d c0	 mov	 ecx, DWORD PTR _i$12[ebp]
  000dd	83 c1 01	 add	 ecx, 1
  000e0	89 4d c0	 mov	 DWORD PTR _i$12[ebp], ecx
$LN4@convert_yu:
  000e3	83 7d c0 03	 cmp	 DWORD PTR _i$12[ebp], 3
  000e7	0f 8d 23 01 00
	00		 jge	 $LN1@convert_yu

; 739  :         const uint16_t *srcYLine = (const uint16_t *)src[i] + src_y_pitch * y_range.start_src + crop_left;

  000ed	8b 55 e8	 mov	 edx, DWORD PTR _src_y_pitch$[ebp]
  000f0	0f af 55 d4	 imul	 edx, DWORD PTR _y_range$[ebp]
  000f4	8b 45 c0	 mov	 eax, DWORD PTR _i$12[ebp]
  000f7	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  000fa	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  000fd	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00100	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  00103	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  00106	89 45 bc	 mov	 DWORD PTR _srcYLine$11[ebp], eax

; 740  :         uint16_t *dstLine = (uint16_t *)dst[i] + dst_y_pitch * y_range.start_dst;

  00109	8b 4d e4	 mov	 ecx, DWORD PTR _dst_y_pitch$[ebp]
  0010c	0f af 4d d8	 imul	 ecx, DWORD PTR _y_range$[ebp+4]
  00110	8b 55 c0	 mov	 edx, DWORD PTR _i$12[ebp]
  00113	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  00116	8b 14 90	 mov	 edx, DWORD PTR [eax+edx*4]
  00119	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  0011c	89 45 b8	 mov	 DWORD PTR _dstLine$10[ebp], eax

; 741  :         const int y_width = width - crop_right - crop_left;

  0011f	8b 4b 10	 mov	 ecx, DWORD PTR _width$[ebx]
  00122	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  00125	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  00128	89 4d b4	 mov	 DWORD PTR _y_width$9[ebp], ecx

; 742  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  0012b	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _y$8[ebp], 0
  00132	eb 21		 jmp	 SHORT $LN7@convert_yu
$LN5@convert_yu:
  00134	8b 55 b0	 mov	 edx, DWORD PTR _y$8[ebp]
  00137	83 c2 01	 add	 edx, 1
  0013a	89 55 b0	 mov	 DWORD PTR _y$8[ebp], edx
  0013d	8b 45 e8	 mov	 eax, DWORD PTR _src_y_pitch$[ebp]
  00140	8b 4d bc	 mov	 ecx, DWORD PTR _srcYLine$11[ebp]
  00143	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00146	89 55 bc	 mov	 DWORD PTR _srcYLine$11[ebp], edx
  00149	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  0014c	8b 4d b8	 mov	 ecx, DWORD PTR _dstLine$10[ebp]
  0014f	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00152	89 55 b8	 mov	 DWORD PTR _dstLine$10[ebp], edx
$LN7@convert_yu:
  00155	8b 45 b0	 mov	 eax, DWORD PTR _y$8[ebp]
  00158	3b 45 dc	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  0015b	0f 8d aa 00 00
	00		 jge	 $LN6@convert_yu

; 743  :             if (in_bit_depth == 16) {

  00161	b9 01 00 00 00	 mov	 ecx, 1
  00166	85 c9		 test	 ecx, ecx
  00168	74 1b		 je	 SHORT $LN11@convert_yu

; 744  :                 avx2_memcpy<true>((uint8_t *)dstLine, (const uint8_t *)srcYLine, y_width * (int)sizeof(uint16_t));

  0016a	8b 55 b4	 mov	 edx, DWORD PTR _y_width$9[ebp]
  0016d	d1 e2		 shl	 edx, 1
  0016f	52		 push	 edx
  00170	8b 45 bc	 mov	 eax, DWORD PTR _srcYLine$11[ebp]
  00173	50		 push	 eax
  00174	8b 4d b8	 mov	 ecx, DWORD PTR _dstLine$10[ebp]
  00177	51		 push	 ecx
  00178	e8 00 00 00 00	 call	 ??$avx2_memcpy@$00@@YAXPAEPBEH@Z ; avx2_memcpy<1>
  0017d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 745  :             } else {

  00180	e9 81 00 00 00	 jmp	 $LN12@convert_yu
$LN11@convert_yu:

; 746  :                 const uint16_t *src_ptr = srcYLine;

  00185	8b 55 bc	 mov	 edx, DWORD PTR _srcYLine$11[ebp]
  00188	89 55 ac	 mov	 DWORD PTR _src_ptr$7[ebp], edx

; 747  :                 uint16_t *dst_ptr = dstLine;

  0018b	8b 45 b8	 mov	 eax, DWORD PTR _dstLine$10[ebp]
  0018e	89 45 a8	 mov	 DWORD PTR _dst_ptr$6[ebp], eax

; 748  :                 for (int x = 0; x < y_width; x += 16, dst_ptr += 16, src_ptr += 16) {

  00191	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _x$5[ebp], 0
  00198	eb 1b		 jmp	 SHORT $LN10@convert_yu
$LN8@convert_yu:
  0019a	8b 4d a4	 mov	 ecx, DWORD PTR _x$5[ebp]
  0019d	83 c1 10	 add	 ecx, 16			; 00000010H
  001a0	89 4d a4	 mov	 DWORD PTR _x$5[ebp], ecx
  001a3	8b 55 a8	 mov	 edx, DWORD PTR _dst_ptr$6[ebp]
  001a6	83 c2 20	 add	 edx, 32			; 00000020H
  001a9	89 55 a8	 mov	 DWORD PTR _dst_ptr$6[ebp], edx
  001ac	8b 45 ac	 mov	 eax, DWORD PTR _src_ptr$7[ebp]
  001af	83 c0 20	 add	 eax, 32			; 00000020H
  001b2	89 45 ac	 mov	 DWORD PTR _src_ptr$7[ebp], eax
$LN10@convert_yu:
  001b5	8b 4d a4	 mov	 ecx, DWORD PTR _x$5[ebp]
  001b8	3b 4d b4	 cmp	 ecx, DWORD PTR _y_width$9[ebp]
  001bb	7d 49		 jge	 SHORT $LN12@convert_yu

; 749  :                     __m256i x0 = _mm256_loadu_si256((const __m256i *)src_ptr);

  001bd	8b 55 ac	 mov	 edx, DWORD PTR _src_ptr$7[ebp]
  001c0	c5 fe 6f 02	 vmovdqu ymm0, YMMWORD PTR [edx]
  001c4	c5 fe 7f 85 60
	ff ff ff	 vmovdqu YMMWORD PTR $T3[ebp], ymm0
  001cc	c5 fe 6f 85 60
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T3[ebp]
  001d4	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _x0$4[ebp], ymm0

; 750  :                     x0 = _mm256_slli_epi16(x0, 16 - in_bit_depth);

  001d9	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR _x0$4[ebp]
  001de	c5 fd 71 f0 00	 vpsllw	 ymm0, ymm0, 0
  001e3	c5 fe 7f 85 40
	ff ff ff	 vmovdqu YMMWORD PTR $T2[ebp], ymm0
  001eb	c5 fe 6f 85 40
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T2[ebp]
  001f3	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _x0$4[ebp], ymm0

; 751  :                     _mm256_storeu_si256((__m256i *)dst_ptr, x0);

  001f8	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR _x0$4[ebp]
  001fd	8b 45 a8	 mov	 eax, DWORD PTR _dst_ptr$6[ebp]
  00200	c5 fe 7f 00	 vmovdqu YMMWORD PTR [eax], ymm0

; 752  :                 }

  00204	eb 94		 jmp	 SHORT $LN8@convert_yu
$LN12@convert_yu:

; 753  :             }
; 754  :         }

  00206	e9 29 ff ff ff	 jmp	 $LN5@convert_yu
$LN6@convert_yu:

; 755  :     }

  0020b	e9 ca fe ff ff	 jmp	 $LN2@convert_yu
$LN1@convert_yu:

; 756  : }

  00210	52		 push	 edx
  00211	8b cd		 mov	 ecx, ebp
  00213	50		 push	 eax
  00214	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN16@convert_yu
  0021a	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0021f	58		 pop	 eax
  00220	5a		 pop	 edx
  00221	5f		 pop	 edi
  00222	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00225	33 cd		 xor	 ecx, ebp
  00227	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0022c	8b e5		 mov	 esp, ebp
  0022e	5d		 pop	 ebp
  0022f	8b e3		 mov	 esp, ebx
  00231	5b		 pop	 ebx
  00232	c3		 ret	 0
  00233	90		 npad	 1
$LN16@convert_yu:
  00234	01 00 00 00	 DD	 1
  00238	00 00 00 00	 DD	 $LN15@convert_yu
$LN15@convert_yu:
  0023c	d4 ff ff ff	 DD	 -44			; ffffffd4H
  00240	0c 00 00 00	 DD	 12			; 0000000cH
  00244	00 00 00 00	 DD	 $LN14@convert_yu
$LN14@convert_yu:
  00248	79		 DB	 121			; 00000079H
  00249	5f		 DB	 95			; 0000005fH
  0024a	72		 DB	 114			; 00000072H
  0024b	61		 DB	 97			; 00000061H
  0024c	6e		 DB	 110			; 0000006eH
  0024d	67		 DB	 103			; 00000067H
  0024e	65		 DB	 101			; 00000065H
  0024f	00		 DB	 0
??$convert_yuv444_high_to_yuv444_16_avx2_base@$0BA@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_high_to_yuv444_16_avx2_base<16>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuv444_16_to_yuv444_16_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuv444_16_to_yuv444_16_avx2

; 759  : void convert_yuv444_16_to_yuv444_16_avx2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 760  :     convert_yuv444_high_to_yuv444_16_avx2_base<16>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yuv444_high_to_yuv444_16_avx2_base@$0BA@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yuv444_high_to_yuv444_16_avx2_base<16>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 761  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yuv444_16_to_yuv444_16_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuv444_16_to_yuv444_16_avx2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
tv160 = -528						; size = 4
tv152 = -524						; size = 4
tv144 = -520						; size = 4
tv136 = -516						; size = 4
$T1 = -512						; size = 32
$T2 = -480						; size = 32
$T3 = -448						; size = 32
$T4 = -416						; size = 32
_dst_tmp$ = -356					; size = 4
$T5 = -352						; size = 32
$T6 = -320						; size = 32
$T7 = -288						; size = 32
$T8 = -256						; size = 32
$T9 = -224						; size = 32
_start_align_diff$ = -164				; size = 4
_y3$ = -160						; size = 32
_y2$ = -128						; size = 32
_y1$ = -96						; size = 32
_y0$ = -64						; size = 32
_dst_aligned_fin$ = -12					; size = 4
_dst_fin$ = -8						; size = 4
_i$10 = -4						; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_size$ = 16						; size = 4
??$avx2_memcpy@$00@@YAXPAEPBEH@Z PROC			; avx2_memcpy<1>

; 47   : static void __forceinline avx2_memcpy(uint8_t *dst, const uint8_t *src, int size) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 20 02 00
	00		 sub	 esp, 544		; 00000220H
  0001c	57		 push	 edi
  0001d	8d bd e0 fd ff
	ff		 lea	 edi, DWORD PTR [ebp-544]
  00023	b9 88 00 00 00	 mov	 ecx, 136		; 00000088H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd

; 48   :     if (size < 128) {

  0002f	81 7b 10 80 00
	00 00		 cmp	 DWORD PTR _size$[ebx], 128 ; 00000080H
  00036	7d 31		 jge	 SHORT $LN8@avx2_memcp

; 49   :         for (int i = 0; i < size; i++)

  00038	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$10[ebp], 0
  0003f	eb 09		 jmp	 SHORT $LN4@avx2_memcp
$LN2@avx2_memcp:
  00041	8b 45 fc	 mov	 eax, DWORD PTR _i$10[ebp]
  00044	83 c0 01	 add	 eax, 1
  00047	89 45 fc	 mov	 DWORD PTR _i$10[ebp], eax
$LN4@avx2_memcp:
  0004a	8b 4d fc	 mov	 ecx, DWORD PTR _i$10[ebp]
  0004d	3b 4b 10	 cmp	 ecx, DWORD PTR _size$[ebx]
  00050	7d 12		 jge	 SHORT $LN3@avx2_memcp

; 50   :             dst[i] = src[i];

  00052	8b 53 08	 mov	 edx, DWORD PTR _dst$[ebx]
  00055	03 55 fc	 add	 edx, DWORD PTR _i$10[ebp]
  00058	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  0005b	03 45 fc	 add	 eax, DWORD PTR _i$10[ebp]
  0005e	8a 08		 mov	 cl, BYTE PTR [eax]
  00060	88 0a		 mov	 BYTE PTR [edx], cl
  00062	eb dd		 jmp	 SHORT $LN2@avx2_memcp
$LN3@avx2_memcp:

; 51   :         return;

  00064	e9 f3 02 00 00	 jmp	 $LN1@avx2_memcp
$LN8@avx2_memcp:

; 52   :     }
; 53   :     uint8_t *dst_fin = dst + size;

  00069	8b 53 08	 mov	 edx, DWORD PTR _dst$[ebx]
  0006c	03 53 10	 add	 edx, DWORD PTR _size$[ebx]
  0006f	89 55 f8	 mov	 DWORD PTR _dst_fin$[ebp], edx

; 54   :     uint8_t *dst_aligned_fin = (uint8_t *)(((size_t)(dst_fin + 31) & ~31) - 128);

  00072	8b 45 f8	 mov	 eax, DWORD PTR _dst_fin$[ebp]
  00075	83 c0 1f	 add	 eax, 31			; 0000001fH
  00078	83 e0 e0	 and	 eax, -32		; ffffffe0H
  0007b	2d 80 00 00 00	 sub	 eax, 128		; 00000080H
  00080	89 45 f4	 mov	 DWORD PTR _dst_aligned_fin$[ebp], eax

; 55   :     __m256i y0, y1, y2, y3;
; 56   :     const int start_align_diff = (int)((size_t)dst & 31);

  00083	8b 4b 08	 mov	 ecx, DWORD PTR _dst$[ebx]
  00086	83 e1 1f	 and	 ecx, 31			; 0000001fH
  00089	89 8d 5c ff ff
	ff		 mov	 DWORD PTR _start_align_diff$[ebp], ecx

; 57   :     if (start_align_diff) {

  0008f	74 4a		 je	 SHORT $LN9@avx2_memcp

; 58   :         y0 = _mm256_loadu_si256((const __m256i*)src);

  00091	8b 53 0c	 mov	 edx, DWORD PTR _src$[ebx]
  00094	c5 fe 6f 02	 vmovdqu ymm0, YMMWORD PTR [edx]
  00098	c5 fe 7f 85 20
	ff ff ff	 vmovdqu YMMWORD PTR $T9[ebp], ymm0
  000a0	c5 fe 6f 85 20
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T9[ebp]
  000a8	c5 fe 7f 45 c0	 vmovdqu YMMWORD PTR _y0$[ebp], ymm0

; 59   :         _mm256_storeu_si256((__m256i*)dst, y0);

  000ad	c5 fe 6f 45 c0	 vmovdqu ymm0, YMMWORD PTR _y0$[ebp]
  000b2	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  000b5	c5 fe 7f 00	 vmovdqu YMMWORD PTR [eax], ymm0

; 60   :         dst += 32 - start_align_diff;

  000b9	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  000be	2b 8d 5c ff ff
	ff		 sub	 ecx, DWORD PTR _start_align_diff$[ebp]
  000c4	03 4b 08	 add	 ecx, DWORD PTR _dst$[ebx]
  000c7	89 4b 08	 mov	 DWORD PTR _dst$[ebx], ecx

; 61   :         src += 32 - start_align_diff;

  000ca	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  000cf	2b 95 5c ff ff
	ff		 sub	 edx, DWORD PTR _start_align_diff$[ebp]
  000d5	03 53 0c	 add	 edx, DWORD PTR _src$[ebx]
  000d8	89 53 0c	 mov	 DWORD PTR _src$[ebx], edx
$LN9@avx2_memcp:

; 62   :     }
; 63   : #define _mm256_stream_switch_si256(x, ymm) ((use_stream) ? _mm256_stream_si256((x), (ymm)) : _mm256_store_si256((x), (ymm)))
; 64   :     for ( ; dst < dst_aligned_fin; dst += 128, src += 128) {

  000db	eb 17		 jmp	 SHORT $LN7@avx2_memcp
$LN5@avx2_memcp:
  000dd	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  000e0	05 80 00 00 00	 add	 eax, 128		; 00000080H
  000e5	89 43 08	 mov	 DWORD PTR _dst$[ebx], eax
  000e8	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  000eb	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  000f1	89 4b 0c	 mov	 DWORD PTR _src$[ebx], ecx
$LN7@avx2_memcp:
  000f4	8b 53 08	 mov	 edx, DWORD PTR _dst$[ebx]
  000f7	3b 55 f4	 cmp	 edx, DWORD PTR _dst_aligned_fin$[ebp]
  000fa	0f 83 75 01 00
	00		 jae	 $LN6@avx2_memcp

; 65   :         y0 = _mm256_loadu_si256((const __m256i*)(src +  0));

  00100	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  00103	c5 fe 6f 00	 vmovdqu ymm0, YMMWORD PTR [eax]
  00107	c5 fe 7f 85 00
	ff ff ff	 vmovdqu YMMWORD PTR $T8[ebp], ymm0
  0010f	c5 fe 6f 85 00
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T8[ebp]
  00117	c5 fe 7f 45 c0	 vmovdqu YMMWORD PTR _y0$[ebp], ymm0

; 66   :         y1 = _mm256_loadu_si256((const __m256i*)(src + 32));

  0011c	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  0011f	83 c1 20	 add	 ecx, 32			; 00000020H
  00122	c5 fe 6f 01	 vmovdqu ymm0, YMMWORD PTR [ecx]
  00126	c5 fe 7f 85 e0
	fe ff ff	 vmovdqu YMMWORD PTR $T7[ebp], ymm0
  0012e	c5 fe 6f 85 e0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T7[ebp]
  00136	c5 fe 7f 45 a0	 vmovdqu YMMWORD PTR _y1$[ebp], ymm0

; 67   :         y2 = _mm256_loadu_si256((const __m256i*)(src + 64));

  0013b	8b 53 0c	 mov	 edx, DWORD PTR _src$[ebx]
  0013e	83 c2 40	 add	 edx, 64			; 00000040H
  00141	c5 fe 6f 02	 vmovdqu ymm0, YMMWORD PTR [edx]
  00145	c5 fe 7f 85 c0
	fe ff ff	 vmovdqu YMMWORD PTR $T6[ebp], ymm0
  0014d	c5 fe 6f 85 c0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T6[ebp]
  00155	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _y2$[ebp], ymm0

; 68   :         y3 = _mm256_loadu_si256((const __m256i*)(src + 96));

  0015a	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  0015d	83 c0 60	 add	 eax, 96			; 00000060H
  00160	c5 fe 6f 00	 vmovdqu ymm0, YMMWORD PTR [eax]
  00164	c5 fe 7f 85 a0
	fe ff ff	 vmovdqu YMMWORD PTR $T5[ebp], ymm0
  0016c	c5 fe 6f 85 a0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T5[ebp]
  00174	c5 fe 7f 85 60
	ff ff ff	 vmovdqu YMMWORD PTR _y3$[ebp], ymm0

; 69   :         _mm256_stream_switch_si256((__m256i*)(dst +  0), y0);

  0017c	b9 01 00 00 00	 mov	 ecx, 1
  00181	85 c9		 test	 ecx, ecx
  00183	74 18		 je	 SHORT $LN11@avx2_memcp
  00185	c5 fe 6f 45 c0	 vmovdqu ymm0, YMMWORD PTR _y0$[ebp]
  0018a	8b 53 08	 mov	 edx, DWORD PTR _dst$[ebx]
  0018d	c5 fd e7 02	 vmovntdq YMMWORD PTR [edx], ymm0
  00191	c7 85 fc fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv136[ebp], 0
  0019b	eb 16		 jmp	 SHORT $LN12@avx2_memcp
$LN11@avx2_memcp:
  0019d	c5 fe 6f 45 c0	 vmovdqu ymm0, YMMWORD PTR _y0$[ebp]
  001a2	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  001a5	c5 fe 7f 00	 vmovdqu YMMWORD PTR [eax], ymm0
  001a9	c7 85 fc fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv136[ebp], 0
$LN12@avx2_memcp:

; 70   :         _mm256_stream_switch_si256((__m256i*)(dst + 32), y1);

  001b3	b9 01 00 00 00	 mov	 ecx, 1
  001b8	85 c9		 test	 ecx, ecx
  001ba	74 1b		 je	 SHORT $LN13@avx2_memcp
  001bc	c5 fe 6f 45 a0	 vmovdqu ymm0, YMMWORD PTR _y1$[ebp]
  001c1	8b 53 08	 mov	 edx, DWORD PTR _dst$[ebx]
  001c4	83 c2 20	 add	 edx, 32			; 00000020H
  001c7	c5 fd e7 02	 vmovntdq YMMWORD PTR [edx], ymm0
  001cb	c7 85 f8 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv144[ebp], 0
  001d5	eb 19		 jmp	 SHORT $LN14@avx2_memcp
$LN13@avx2_memcp:
  001d7	c5 fe 6f 45 a0	 vmovdqu ymm0, YMMWORD PTR _y1$[ebp]
  001dc	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  001df	83 c0 20	 add	 eax, 32			; 00000020H
  001e2	c5 fe 7f 00	 vmovdqu YMMWORD PTR [eax], ymm0
  001e6	c7 85 f8 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv144[ebp], 0
$LN14@avx2_memcp:

; 71   :         _mm256_stream_switch_si256((__m256i*)(dst + 64), y2);

  001f0	b9 01 00 00 00	 mov	 ecx, 1
  001f5	85 c9		 test	 ecx, ecx
  001f7	74 1b		 je	 SHORT $LN15@avx2_memcp
  001f9	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR _y2$[ebp]
  001fe	8b 53 08	 mov	 edx, DWORD PTR _dst$[ebx]
  00201	83 c2 40	 add	 edx, 64			; 00000040H
  00204	c5 fd e7 02	 vmovntdq YMMWORD PTR [edx], ymm0
  00208	c7 85 f4 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv152[ebp], 0
  00212	eb 19		 jmp	 SHORT $LN16@avx2_memcp
$LN15@avx2_memcp:
  00214	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR _y2$[ebp]
  00219	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  0021c	83 c0 40	 add	 eax, 64			; 00000040H
  0021f	c5 fe 7f 00	 vmovdqu YMMWORD PTR [eax], ymm0
  00223	c7 85 f4 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv152[ebp], 0
$LN16@avx2_memcp:

; 72   :         _mm256_stream_switch_si256((__m256i*)(dst + 96), y3);

  0022d	b9 01 00 00 00	 mov	 ecx, 1
  00232	85 c9		 test	 ecx, ecx
  00234	74 1e		 je	 SHORT $LN17@avx2_memcp
  00236	c5 fe 6f 85 60
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR _y3$[ebp]
  0023e	8b 53 08	 mov	 edx, DWORD PTR _dst$[ebx]
  00241	83 c2 60	 add	 edx, 96			; 00000060H
  00244	c5 fd e7 02	 vmovntdq YMMWORD PTR [edx], ymm0
  00248	c7 85 f0 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv160[ebp], 0
  00252	eb 1c		 jmp	 SHORT $LN18@avx2_memcp
$LN17@avx2_memcp:
  00254	c5 fe 6f 85 60
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR _y3$[ebp]
  0025c	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  0025f	83 c0 60	 add	 eax, 96			; 00000060H
  00262	c5 fe 7f 00	 vmovdqu YMMWORD PTR [eax], ymm0
  00266	c7 85 f0 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv160[ebp], 0
$LN18@avx2_memcp:

; 73   :     }

  00270	e9 68 fe ff ff	 jmp	 $LN5@avx2_memcp
$LN6@avx2_memcp:

; 74   : #undef _mm256_stream_switch_si256
; 75   :     uint8_t *dst_tmp = dst_fin - 128;

  00275	8b 4d f8	 mov	 ecx, DWORD PTR _dst_fin$[ebp]
  00278	81 e9 80 00 00
	00		 sub	 ecx, 128		; 00000080H
  0027e	89 8d 9c fe ff
	ff		 mov	 DWORD PTR _dst_tmp$[ebp], ecx

; 76   :     src -= (dst - dst_tmp);

  00284	8b 53 08	 mov	 edx, DWORD PTR _dst$[ebx]
  00287	2b 95 9c fe ff
	ff		 sub	 edx, DWORD PTR _dst_tmp$[ebp]
  0028d	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  00290	2b c2		 sub	 eax, edx
  00292	89 43 0c	 mov	 DWORD PTR _src$[ebx], eax

; 77   :     y0 = _mm256_loadu_si256((const __m256i*)(src +  0));

  00295	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  00298	c5 fe 6f 01	 vmovdqu ymm0, YMMWORD PTR [ecx]
  0029c	c5 fe 7f 85 60
	fe ff ff	 vmovdqu YMMWORD PTR $T4[ebp], ymm0
  002a4	c5 fe 6f 85 60
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T4[ebp]
  002ac	c5 fe 7f 45 c0	 vmovdqu YMMWORD PTR _y0$[ebp], ymm0

; 78   :     y1 = _mm256_loadu_si256((const __m256i*)(src + 32));

  002b1	8b 53 0c	 mov	 edx, DWORD PTR _src$[ebx]
  002b4	83 c2 20	 add	 edx, 32			; 00000020H
  002b7	c5 fe 6f 02	 vmovdqu ymm0, YMMWORD PTR [edx]
  002bb	c5 fe 7f 85 40
	fe ff ff	 vmovdqu YMMWORD PTR $T3[ebp], ymm0
  002c3	c5 fe 6f 85 40
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T3[ebp]
  002cb	c5 fe 7f 45 a0	 vmovdqu YMMWORD PTR _y1$[ebp], ymm0

; 79   :     y2 = _mm256_loadu_si256((const __m256i*)(src + 64));

  002d0	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  002d3	83 c0 40	 add	 eax, 64			; 00000040H
  002d6	c5 fe 6f 00	 vmovdqu ymm0, YMMWORD PTR [eax]
  002da	c5 fe 7f 85 20
	fe ff ff	 vmovdqu YMMWORD PTR $T2[ebp], ymm0
  002e2	c5 fe 6f 85 20
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T2[ebp]
  002ea	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _y2$[ebp], ymm0

; 80   :     y3 = _mm256_loadu_si256((const __m256i*)(src + 96));

  002ef	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  002f2	83 c1 60	 add	 ecx, 96			; 00000060H
  002f5	c5 fe 6f 01	 vmovdqu ymm0, YMMWORD PTR [ecx]
  002f9	c5 fe 7f 85 00
	fe ff ff	 vmovdqu YMMWORD PTR $T1[ebp], ymm0
  00301	c5 fe 6f 85 00
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T1[ebp]
  00309	c5 fe 7f 85 60
	ff ff ff	 vmovdqu YMMWORD PTR _y3$[ebp], ymm0

; 81   :     _mm256_storeu_si256((__m256i*)(dst_tmp +  0), y0);

  00311	c5 fe 6f 45 c0	 vmovdqu ymm0, YMMWORD PTR _y0$[ebp]
  00316	8b 95 9c fe ff
	ff		 mov	 edx, DWORD PTR _dst_tmp$[ebp]
  0031c	c5 fe 7f 02	 vmovdqu YMMWORD PTR [edx], ymm0

; 82   :     _mm256_storeu_si256((__m256i*)(dst_tmp + 32), y1);

  00320	c5 fe 6f 45 a0	 vmovdqu ymm0, YMMWORD PTR _y1$[ebp]
  00325	8b 85 9c fe ff
	ff		 mov	 eax, DWORD PTR _dst_tmp$[ebp]
  0032b	83 c0 20	 add	 eax, 32			; 00000020H
  0032e	c5 fe 7f 00	 vmovdqu YMMWORD PTR [eax], ymm0

; 83   :     _mm256_storeu_si256((__m256i*)(dst_tmp + 64), y2);

  00332	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR _y2$[ebp]
  00337	8b 8d 9c fe ff
	ff		 mov	 ecx, DWORD PTR _dst_tmp$[ebp]
  0033d	83 c1 40	 add	 ecx, 64			; 00000040H
  00340	c5 fe 7f 01	 vmovdqu YMMWORD PTR [ecx], ymm0

; 84   :     _mm256_storeu_si256((__m256i*)(dst_tmp + 96), y3);

  00344	c5 fe 6f 85 60
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR _y3$[ebp]
  0034c	8b 95 9c fe ff
	ff		 mov	 edx, DWORD PTR _dst_tmp$[ebp]
  00352	83 c2 60	 add	 edx, 96			; 00000060H
  00355	c5 fe 7f 02	 vmovdqu YMMWORD PTR [edx], ymm0

; 85   :     _mm256_zeroupper();

  00359	c5 f8 77	 vzeroupper
$LN1@avx2_memcp:

; 86   : }

  0035c	5f		 pop	 edi
  0035d	8b e5		 mov	 esp, ebp
  0035f	5d		 pop	 ebp
  00360	8b e3		 mov	 esp, ebx
  00362	5b		 pop	 ebx
  00363	c3		 ret	 0
??$avx2_memcpy@$00@@YAXPAEPBEH@Z ENDP			; avx2_memcpy<1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
$T1 = -84						; size = 12
_y$2 = -72						; size = 4
_y_width$3 = -68					; size = 4
_dstLine$4 = -64					; size = 4
_srcYLine$5 = -60					; size = 4
_i$6 = -56						; size = 4
$T7 = -52						; size = 12
_y_range$ = -36						; size = 12
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?copy_yuv444_to_yuv444_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; copy_yuv444_to_yuv444_avx2

; 712  : void copy_yuv444_to_yuv444_avx2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	57		 push	 edi
  00007	8d 7d ac	 lea	 edi, DWORD PTR [ebp-84]
  0000a	b9 15 00 00 00	 mov	 ecx, 21			; 00000015H
  0000f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00014	f3 ab		 rep stosd
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 713  :     const int crop_left   = crop[0];

  00020	b8 04 00 00 00	 mov	 eax, 4
  00025	6b c8 00	 imul	 ecx, eax, 0
  00028	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  0002b	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0002e	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 714  :     const int crop_up     = crop[1];

  00031	b9 04 00 00 00	 mov	 ecx, 4
  00036	c1 e1 00	 shl	 ecx, 0
  00039	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  0003c	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0003f	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 715  :     const int crop_right  = crop[2];

  00042	b9 04 00 00 00	 mov	 ecx, 4
  00047	d1 e1		 shl	 ecx, 1
  00049	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  0004c	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0004f	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 716  :     const int crop_bottom = crop[3];

  00052	b9 04 00 00 00	 mov	 ecx, 4
  00057	6b d1 03	 imul	 edx, ecx, 3
  0005a	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  0005d	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00060	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 717  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00063	8b 55 2c	 mov	 edx, DWORD PTR _thread_n$[ebp]
  00066	52		 push	 edx
  00067	8b 45 28	 mov	 eax, DWORD PTR _thread_id$[ebp]
  0006a	50		 push	 eax
  0006b	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  0006e	2b 4d ec	 sub	 ecx, DWORD PTR _crop_bottom$[ebp]
  00071	51		 push	 ecx
  00072	8b 55 f4	 mov	 edx, DWORD PTR _crop_up$[ebp]
  00075	52		 push	 edx
  00076	8d 45 ac	 lea	 eax, DWORD PTR $T1[ebp]
  00079	50		 push	 eax
  0007a	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  0007f	83 c4 14	 add	 esp, 20			; 00000014H
  00082	8b 08		 mov	 ecx, DWORD PTR [eax]
  00084	89 4d cc	 mov	 DWORD PTR $T7[ebp], ecx
  00087	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0008a	89 55 d0	 mov	 DWORD PTR $T7[ebp+4], edx
  0008d	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00090	89 45 d4	 mov	 DWORD PTR $T7[ebp+8], eax
  00093	8b 4d cc	 mov	 ecx, DWORD PTR $T7[ebp]
  00096	89 4d dc	 mov	 DWORD PTR _y_range$[ebp], ecx
  00099	8b 55 d0	 mov	 edx, DWORD PTR $T7[ebp+4]
  0009c	89 55 e0	 mov	 DWORD PTR _y_range$[ebp+4], edx
  0009f	8b 45 d4	 mov	 eax, DWORD PTR $T7[ebp+8]
  000a2	89 45 e4	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 718  :     for (int i = 0; i < 3; i++) {

  000a5	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _i$6[ebp], 0
  000ac	eb 09		 jmp	 SHORT $LN4@copy_yuv44
$LN2@copy_yuv44:
  000ae	8b 4d c8	 mov	 ecx, DWORD PTR _i$6[ebp]
  000b1	83 c1 01	 add	 ecx, 1
  000b4	89 4d c8	 mov	 DWORD PTR _i$6[ebp], ecx
$LN4@copy_yuv44:
  000b7	83 7d c8 03	 cmp	 DWORD PTR _i$6[ebp], 3
  000bb	7d 7e		 jge	 SHORT $LN1@copy_yuv44

; 719  :         const uint8_t *srcYLine = (const uint8_t *)src[i] + src_y_pitch_byte * y_range.start_src + crop_left;

  000bd	8b 55 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebp]
  000c0	0f af 55 dc	 imul	 edx, DWORD PTR _y_range$[ebp]
  000c4	8b 45 c8	 mov	 eax, DWORD PTR _i$6[ebp]
  000c7	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  000ca	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  000cd	03 c2		 add	 eax, edx
  000cf	03 45 f8	 add	 eax, DWORD PTR _crop_left$[ebp]
  000d2	89 45 c4	 mov	 DWORD PTR _srcYLine$5[ebp], eax

; 720  :         uint8_t *dstLine = (uint8_t *)dst[i] + dst_y_pitch_byte * y_range.start_dst;

  000d5	8b 4d 1c	 mov	 ecx, DWORD PTR _dst_y_pitch_byte$[ebp]
  000d8	0f af 4d e0	 imul	 ecx, DWORD PTR _y_range$[ebp+4]
  000dc	8b 55 c8	 mov	 edx, DWORD PTR _i$6[ebp]
  000df	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
  000e2	03 0c 90	 add	 ecx, DWORD PTR [eax+edx*4]
  000e5	89 4d c0	 mov	 DWORD PTR _dstLine$4[ebp], ecx

; 721  :         const int y_width = width - crop_right - crop_left;

  000e8	8b 4d 10	 mov	 ecx, DWORD PTR _width$[ebp]
  000eb	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  000ee	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  000f1	89 4d bc	 mov	 DWORD PTR _y_width$3[ebp], ecx

; 722  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch_byte, dstLine += dst_y_pitch_byte) {

  000f4	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _y$2[ebp], 0
  000fb	eb 1b		 jmp	 SHORT $LN7@copy_yuv44
$LN5@copy_yuv44:
  000fd	8b 55 b8	 mov	 edx, DWORD PTR _y$2[ebp]
  00100	83 c2 01	 add	 edx, 1
  00103	89 55 b8	 mov	 DWORD PTR _y$2[ebp], edx
  00106	8b 45 c4	 mov	 eax, DWORD PTR _srcYLine$5[ebp]
  00109	03 45 14	 add	 eax, DWORD PTR _src_y_pitch_byte$[ebp]
  0010c	89 45 c4	 mov	 DWORD PTR _srcYLine$5[ebp], eax
  0010f	8b 4d c0	 mov	 ecx, DWORD PTR _dstLine$4[ebp]
  00112	03 4d 1c	 add	 ecx, DWORD PTR _dst_y_pitch_byte$[ebp]
  00115	89 4d c0	 mov	 DWORD PTR _dstLine$4[ebp], ecx
$LN7@copy_yuv44:
  00118	8b 55 b8	 mov	 edx, DWORD PTR _y$2[ebp]
  0011b	3b 55 e4	 cmp	 edx, DWORD PTR _y_range$[ebp+8]
  0011e	7d 16		 jge	 SHORT $LN6@copy_yuv44

; 723  :             avx2_memcpy<true>(dstLine, srcYLine, y_width);

  00120	8b 45 bc	 mov	 eax, DWORD PTR _y_width$3[ebp]
  00123	50		 push	 eax
  00124	8b 4d c4	 mov	 ecx, DWORD PTR _srcYLine$5[ebp]
  00127	51		 push	 ecx
  00128	8b 55 c0	 mov	 edx, DWORD PTR _dstLine$4[ebp]
  0012b	52		 push	 edx
  0012c	e8 00 00 00 00	 call	 ??$avx2_memcpy@$00@@YAXPAEPBEH@Z ; avx2_memcpy<1>
  00131	83 c4 0c	 add	 esp, 12			; 0000000cH

; 724  :         }

  00134	eb c7		 jmp	 SHORT $LN5@copy_yuv44
$LN6@copy_yuv44:

; 725  :     }

  00136	e9 73 ff ff ff	 jmp	 $LN2@copy_yuv44
$LN1@copy_yuv44:

; 726  : }

  0013b	52		 push	 edx
  0013c	8b cd		 mov	 ecx, ebp
  0013e	50		 push	 eax
  0013f	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN11@copy_yuv44
  00145	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0014a	58		 pop	 eax
  0014b	5a		 pop	 edx
  0014c	5f		 pop	 edi
  0014d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00150	33 cd		 xor	 ecx, ebp
  00152	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00157	83 c4 54	 add	 esp, 84			; 00000054H
  0015a	3b ec		 cmp	 ebp, esp
  0015c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00161	8b e5		 mov	 esp, ebp
  00163	5d		 pop	 ebp
  00164	c3		 ret	 0
  00165	0f 1f 00	 npad	 3
$LN11@copy_yuv44:
  00168	01 00 00 00	 DD	 1
  0016c	00 00 00 00	 DD	 $LN10@copy_yuv44
$LN10@copy_yuv44:
  00170	dc ff ff ff	 DD	 -36			; ffffffdcH
  00174	0c 00 00 00	 DD	 12			; 0000000cH
  00178	00 00 00 00	 DD	 $LN9@copy_yuv44
$LN9@copy_yuv44:
  0017c	79		 DB	 121			; 00000079H
  0017d	5f		 DB	 95			; 0000005fH
  0017e	72		 DB	 114			; 00000072H
  0017f	61		 DB	 97			; 00000061H
  00180	6e		 DB	 110			; 0000006eH
  00181	67		 DB	 103			; 00000067H
  00182	65		 DB	 101			; 00000065H
  00183	00		 DB	 0
?copy_yuv444_to_yuv444_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; copy_yuv444_to_yuv444_avx2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
$T1 = -704						; size = 12
$T2 = -688						; size = 12
$T3 = -672						; size = 32
$T4 = -640						; size = 32
$T5 = -608						; size = 32
$T6 = -576						; size = 32
$T7 = -544						; size = 32
$T8 = -512						; size = 32
$T9 = -480						; size = 32
$T10 = -448						; size = 32
_x$11 = -388						; size = 4
_y2$12 = -384						; size = 32
_y1$13 = -352						; size = 32
_y0$14 = -320						; size = 32
_dst_ptr$15 = -260					; size = 4
_src_v_ptr$16 = -256					; size = 4
_src_u_ptr$17 = -252					; size = 4
_x_fin$18 = -248					; size = 4
_y$19 = -244						; size = 4
_dstLine$ = -240					; size = 4
_srcVLine$ = -236					; size = 4
_srcULine$ = -232					; size = 4
_src_uv_pitch$ = -228					; size = 4
$T20 = -224						; size = 12
_uv_range$ = -208					; size = 12
$T21 = -192						; size = 32
$T22 = -160						; size = 32
_y0$23 = -128						; size = 32
_x$24 = -88						; size = 4
_dst_ptr$25 = -84					; size = 4
_src_ptr$26 = -80					; size = 4
_y$27 = -76						; size = 4
_y_width$28 = -72					; size = 4
_dstLine$29 = -68					; size = 4
_srcYLine$30 = -64					; size = 4
$T31 = -60						; size = 12
_y_range$32 = -44					; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yv12_high_to_p010_avx2_base@$08$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_high_to_p010_avx2_base<9,0>

; 627  : static void __forceinline convert_yv12_high_to_p010_avx2_base(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec c0 02 00
	00		 sub	 esp, 704		; 000002c0H
  0001c	57		 push	 edi
  0001d	8d bd 40 fd ff
	ff		 lea	 edi, DWORD PTR [ebp-704]
  00023	b9 b0 00 00 00	 mov	 ecx, 176		; 000000b0H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 628  :     static_assert(8 < in_bit_depth && in_bit_depth <= 16, "in_bit_depth must be 9-16.");
; 629  :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 630  :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 631  :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 632  :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 633  :     const int src_y_pitch = src_y_pitch_byte >> 1;

  0007c	8b 53 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  0007f	d1 fa		 sar	 edx, 1
  00081	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 634  :     const int dst_y_pitch = dst_y_pitch_byte >> 1;

  00084	8b 43 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  00087	d1 f8		 sar	 eax, 1
  00089	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 635  :     //Y
; 636  :     if (!uv_only) {

  0008c	b9 01 00 00 00	 mov	 ecx, 1
  00091	85 c9		 test	 ecx, ecx
  00093	0f 84 68 01 00
	00		 je	 $LN14@convert_yv

; 637  :         const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00099	8b 53 2c	 mov	 edx, DWORD PTR _thread_n$[ebx]
  0009c	52		 push	 edx
  0009d	8b 43 28	 mov	 eax, DWORD PTR _thread_id$[ebx]
  000a0	50		 push	 eax
  000a1	8b 4b 20	 mov	 ecx, DWORD PTR _height$[ebx]
  000a4	2b 4d ec	 sub	 ecx, DWORD PTR _crop_bottom$[ebp]
  000a7	51		 push	 ecx
  000a8	8b 55 f4	 mov	 edx, DWORD PTR _crop_up$[ebp]
  000ab	52		 push	 edx
  000ac	8d 85 50 fd ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  000b2	50		 push	 eax
  000b3	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  000b8	83 c4 14	 add	 esp, 20			; 00000014H
  000bb	8b 08		 mov	 ecx, DWORD PTR [eax]
  000bd	89 4d c4	 mov	 DWORD PTR $T31[ebp], ecx
  000c0	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000c3	89 55 c8	 mov	 DWORD PTR $T31[ebp+4], edx
  000c6	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000c9	89 45 cc	 mov	 DWORD PTR $T31[ebp+8], eax
  000cc	8b 4d c4	 mov	 ecx, DWORD PTR $T31[ebp]
  000cf	89 4d d4	 mov	 DWORD PTR _y_range$32[ebp], ecx
  000d2	8b 55 c8	 mov	 edx, DWORD PTR $T31[ebp+4]
  000d5	89 55 d8	 mov	 DWORD PTR _y_range$32[ebp+4], edx
  000d8	8b 45 cc	 mov	 eax, DWORD PTR $T31[ebp+8]
  000db	89 45 dc	 mov	 DWORD PTR _y_range$32[ebp+8], eax

; 638  :         uint16_t *srcYLine = (uint16_t *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000de	b9 04 00 00 00	 mov	 ecx, 4
  000e3	6b d1 00	 imul	 edx, ecx, 0
  000e6	8b 45 e8	 mov	 eax, DWORD PTR _src_y_pitch$[ebp]
  000e9	0f af 45 d4	 imul	 eax, DWORD PTR _y_range$32[ebp]
  000ed	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  000f0	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  000f3	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  000f6	8b 4d f8	 mov	 ecx, DWORD PTR _crop_left$[ebp]
  000f9	8d 14 48	 lea	 edx, DWORD PTR [eax+ecx*2]
  000fc	89 55 c0	 mov	 DWORD PTR _srcYLine$30[ebp], edx

; 639  :         uint16_t *dstLine = (uint16_t *)dst[0] + dst_y_pitch * y_range.start_dst;

  000ff	b8 04 00 00 00	 mov	 eax, 4
  00104	6b c8 00	 imul	 ecx, eax, 0
  00107	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  0010a	0f af 55 d8	 imul	 edx, DWORD PTR _y_range$32[ebp+4]
  0010e	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  00111	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  00114	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  00117	89 55 bc	 mov	 DWORD PTR _dstLine$29[ebp], edx

; 640  :         const int y_width = width - crop_right - crop_left;

  0011a	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  0011d	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  00120	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  00123	89 45 b8	 mov	 DWORD PTR _y_width$28[ebp], eax

; 641  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  00126	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _y$27[ebp], 0
  0012d	eb 21		 jmp	 SHORT $LN4@convert_yv
$LN2@convert_yv:
  0012f	8b 4d b4	 mov	 ecx, DWORD PTR _y$27[ebp]
  00132	83 c1 01	 add	 ecx, 1
  00135	89 4d b4	 mov	 DWORD PTR _y$27[ebp], ecx
  00138	8b 55 e8	 mov	 edx, DWORD PTR _src_y_pitch$[ebp]
  0013b	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$30[ebp]
  0013e	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00141	89 4d c0	 mov	 DWORD PTR _srcYLine$30[ebp], ecx
  00144	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  00147	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$29[ebp]
  0014a	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  0014d	89 4d bc	 mov	 DWORD PTR _dstLine$29[ebp], ecx
$LN4@convert_yv:
  00150	8b 55 b4	 mov	 edx, DWORD PTR _y$27[ebp]
  00153	3b 55 dc	 cmp	 edx, DWORD PTR _y_range$32[ebp+8]
  00156	0f 8d a5 00 00
	00		 jge	 $LN14@convert_yv

; 642  :             if (in_bit_depth == 16) {

  0015c	33 c0		 xor	 eax, eax
  0015e	74 1b		 je	 SHORT $LN15@convert_yv

; 643  :                 avx2_memcpy<true>((uint8_t *)dstLine, (uint8_t *)srcYLine, y_width * (int)sizeof(uint16_t));

  00160	8b 4d b8	 mov	 ecx, DWORD PTR _y_width$28[ebp]
  00163	d1 e1		 shl	 ecx, 1
  00165	51		 push	 ecx
  00166	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$30[ebp]
  00169	52		 push	 edx
  0016a	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$29[ebp]
  0016d	50		 push	 eax
  0016e	e8 00 00 00 00	 call	 ??$avx2_memcpy@$00@@YAXPAEPBEH@Z ; avx2_memcpy<1>
  00173	83 c4 0c	 add	 esp, 12			; 0000000cH

; 644  :             } else {

  00176	e9 81 00 00 00	 jmp	 $LN16@convert_yv
$LN15@convert_yv:

; 645  :                 uint16_t *src_ptr = srcYLine;

  0017b	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$30[ebp]
  0017e	89 4d b0	 mov	 DWORD PTR _src_ptr$26[ebp], ecx

; 646  :                 uint16_t *dst_ptr = dstLine;

  00181	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$29[ebp]
  00184	89 55 ac	 mov	 DWORD PTR _dst_ptr$25[ebp], edx

; 647  :                 for (int x = 0; x < y_width; x += 16, dst_ptr += 16, src_ptr += 16) {

  00187	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR _x$24[ebp], 0
  0018e	eb 1b		 jmp	 SHORT $LN7@convert_yv
$LN5@convert_yv:
  00190	8b 45 a8	 mov	 eax, DWORD PTR _x$24[ebp]
  00193	83 c0 10	 add	 eax, 16			; 00000010H
  00196	89 45 a8	 mov	 DWORD PTR _x$24[ebp], eax
  00199	8b 4d ac	 mov	 ecx, DWORD PTR _dst_ptr$25[ebp]
  0019c	83 c1 20	 add	 ecx, 32			; 00000020H
  0019f	89 4d ac	 mov	 DWORD PTR _dst_ptr$25[ebp], ecx
  001a2	8b 55 b0	 mov	 edx, DWORD PTR _src_ptr$26[ebp]
  001a5	83 c2 20	 add	 edx, 32			; 00000020H
  001a8	89 55 b0	 mov	 DWORD PTR _src_ptr$26[ebp], edx
$LN7@convert_yv:
  001ab	8b 45 a8	 mov	 eax, DWORD PTR _x$24[ebp]
  001ae	3b 45 b8	 cmp	 eax, DWORD PTR _y_width$28[ebp]
  001b1	7d 49		 jge	 SHORT $LN16@convert_yv

; 648  :                     __m256i y0 = _mm256_loadu_si256((const __m256i *)src_ptr);

  001b3	8b 4d b0	 mov	 ecx, DWORD PTR _src_ptr$26[ebp]
  001b6	c5 fe 6f 01	 vmovdqu ymm0, YMMWORD PTR [ecx]
  001ba	c5 fe 7f 85 60
	ff ff ff	 vmovdqu YMMWORD PTR $T22[ebp], ymm0
  001c2	c5 fe 6f 85 60
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T22[ebp]
  001ca	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _y0$23[ebp], ymm0

; 649  :                     y0 = _mm256_slli_epi16(y0, 16 - in_bit_depth);

  001cf	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR _y0$23[ebp]
  001d4	c5 fd 71 f0 07	 vpsllw	 ymm0, ymm0, 7
  001d9	c5 fe 7f 85 40
	ff ff ff	 vmovdqu YMMWORD PTR $T21[ebp], ymm0
  001e1	c5 fe 6f 85 40
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T21[ebp]
  001e9	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _y0$23[ebp], ymm0

; 650  :                     _mm256_storeu_si256((__m256i *)dst_ptr, y0);

  001ee	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR _y0$23[ebp]
  001f3	8b 55 ac	 mov	 edx, DWORD PTR _dst_ptr$25[ebp]
  001f6	c5 fe 7f 02	 vmovdqu YMMWORD PTR [edx], ymm0

; 651  :                 }

  001fa	eb 94		 jmp	 SHORT $LN5@convert_yv
$LN16@convert_yv:

; 652  :             }
; 653  :         }

  001fc	e9 2e ff ff ff	 jmp	 $LN2@convert_yv
$LN14@convert_yv:

; 654  :     }
; 655  :     //UV
; 656  :     const auto uv_range = thread_y_range(crop_up >> 1, (height - crop_bottom) >> 1, thread_id, thread_n);

  00201	8b 43 2c	 mov	 eax, DWORD PTR _thread_n$[ebx]
  00204	50		 push	 eax
  00205	8b 4b 28	 mov	 ecx, DWORD PTR _thread_id$[ebx]
  00208	51		 push	 ecx
  00209	8b 53 20	 mov	 edx, DWORD PTR _height$[ebx]
  0020c	2b 55 ec	 sub	 edx, DWORD PTR _crop_bottom$[ebp]
  0020f	d1 fa		 sar	 edx, 1
  00211	52		 push	 edx
  00212	8b 45 f4	 mov	 eax, DWORD PTR _crop_up$[ebp]
  00215	d1 f8		 sar	 eax, 1
  00217	50		 push	 eax
  00218	8d 8d 40 fd ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  0021e	51		 push	 ecx
  0021f	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00224	83 c4 14	 add	 esp, 20			; 00000014H
  00227	8b 10		 mov	 edx, DWORD PTR [eax]
  00229	89 95 20 ff ff
	ff		 mov	 DWORD PTR $T20[ebp], edx
  0022f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00232	89 8d 24 ff ff
	ff		 mov	 DWORD PTR $T20[ebp+4], ecx
  00238	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0023b	89 95 28 ff ff
	ff		 mov	 DWORD PTR $T20[ebp+8], edx
  00241	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR $T20[ebp]
  00247	89 85 30 ff ff
	ff		 mov	 DWORD PTR _uv_range$[ebp], eax
  0024d	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR $T20[ebp+4]
  00253	89 8d 34 ff ff
	ff		 mov	 DWORD PTR _uv_range$[ebp+4], ecx
  00259	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR $T20[ebp+8]
  0025f	89 95 38 ff ff
	ff		 mov	 DWORD PTR _uv_range$[ebp+8], edx

; 657  :     const int src_uv_pitch = src_uv_pitch_byte >> 1;

  00265	8b 43 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebx]
  00268	d1 f8		 sar	 eax, 1
  0026a	89 85 1c ff ff
	ff		 mov	 DWORD PTR _src_uv_pitch$[ebp], eax

; 658  :     uint16_t *srcULine = (uint16_t *)src[1] + ((src_uv_pitch * uv_range.start_src) + (crop_left >> 1));

  00270	b9 04 00 00 00	 mov	 ecx, 4
  00275	c1 e1 00	 shl	 ecx, 0
  00278	8b 95 1c ff ff
	ff		 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  0027e	0f af 95 30 ff
	ff ff		 imul	 edx, DWORD PTR _uv_range$[ebp]
  00285	8b 45 f8	 mov	 eax, DWORD PTR _crop_left$[ebp]
  00288	d1 f8		 sar	 eax, 1
  0028a	03 d0		 add	 edx, eax
  0028c	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  0028f	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  00292	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  00295	89 95 18 ff ff
	ff		 mov	 DWORD PTR _srcULine$[ebp], edx

; 659  :     uint16_t *srcVLine = (uint16_t *)src[2] + ((src_uv_pitch * uv_range.start_src) + (crop_left >> 1));

  0029b	b8 04 00 00 00	 mov	 eax, 4
  002a0	d1 e0		 shl	 eax, 1
  002a2	8b 8d 1c ff ff
	ff		 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  002a8	0f af 8d 30 ff
	ff ff		 imul	 ecx, DWORD PTR _uv_range$[ebp]
  002af	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  002b2	d1 fa		 sar	 edx, 1
  002b4	03 ca		 add	 ecx, edx
  002b6	8b 53 0c	 mov	 edx, DWORD PTR _src$[ebx]
  002b9	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  002bc	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  002bf	89 8d 14 ff ff
	ff		 mov	 DWORD PTR _srcVLine$[ebp], ecx

; 660  :     uint16_t *dstLine = (uint16_t *)dst[1] + dst_y_pitch * uv_range.start_dst;;

  002c5	ba 04 00 00 00	 mov	 edx, 4
  002ca	c1 e2 00	 shl	 edx, 0
  002cd	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  002d0	0f af 85 34 ff
	ff ff		 imul	 eax, DWORD PTR _uv_range$[ebp+4]
  002d7	8b 4b 08	 mov	 ecx, DWORD PTR _dst$[ebx]
  002da	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  002dd	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  002e0	89 85 10 ff ff
	ff		 mov	 DWORD PTR _dstLine$[ebp], eax

; 661  :     for (int y = 0; y < uv_range.len; y++, srcULine += src_uv_pitch, srcVLine += src_uv_pitch, dstLine += dst_y_pitch) {

  002e6	c7 85 0c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _y$19[ebp], 0
  002f0	eb 4b		 jmp	 SHORT $LN10@convert_yv
$LN8@convert_yv:
  002f2	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR _y$19[ebp]
  002f8	83 c1 01	 add	 ecx, 1
  002fb	89 8d 0c ff ff
	ff		 mov	 DWORD PTR _y$19[ebp], ecx
  00301	8b 95 1c ff ff
	ff		 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  00307	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _srcULine$[ebp]
  0030d	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00310	89 8d 18 ff ff
	ff		 mov	 DWORD PTR _srcULine$[ebp], ecx
  00316	8b 95 1c ff ff
	ff		 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  0031c	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _srcVLine$[ebp]
  00322	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00325	89 8d 14 ff ff
	ff		 mov	 DWORD PTR _srcVLine$[ebp], ecx
  0032b	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  0032e	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _dstLine$[ebp]
  00334	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00337	89 8d 10 ff ff
	ff		 mov	 DWORD PTR _dstLine$[ebp], ecx
$LN10@convert_yv:
  0033d	8b 95 0c ff ff
	ff		 mov	 edx, DWORD PTR _y$19[ebp]
  00343	3b 95 38 ff ff
	ff		 cmp	 edx, DWORD PTR _uv_range$[ebp+8]
  00349	0f 8d e5 01 00
	00		 jge	 $LN1@convert_yv

; 662  :         const int x_fin = width - crop_right;

  0034f	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  00352	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  00355	89 85 08 ff ff
	ff		 mov	 DWORD PTR _x_fin$18[ebp], eax

; 663  :         uint16_t *src_u_ptr = srcULine;

  0035b	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR _srcULine$[ebp]
  00361	89 8d 04 ff ff
	ff		 mov	 DWORD PTR _src_u_ptr$17[ebp], ecx

; 664  :         uint16_t *src_v_ptr = srcVLine;

  00367	8b 95 14 ff ff
	ff		 mov	 edx, DWORD PTR _srcVLine$[ebp]
  0036d	89 95 00 ff ff
	ff		 mov	 DWORD PTR _src_v_ptr$16[ebp], edx

; 665  :         uint16_t *dst_ptr = dstLine;

  00373	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _dstLine$[ebp]
  00379	89 85 fc fe ff
	ff		 mov	 DWORD PTR _dst_ptr$15[ebp], eax

; 666  :         __m256i y0, y1, y2;
; 667  :         for (int x = crop_left; x < x_fin; x += 32, src_u_ptr += 16, src_v_ptr += 16, dst_ptr += 32) {

  0037f	8b 4d f8	 mov	 ecx, DWORD PTR _crop_left$[ebp]
  00382	89 8d 7c fe ff
	ff		 mov	 DWORD PTR _x$11[ebp], ecx
  00388	eb 3c		 jmp	 SHORT $LN13@convert_yv
$LN11@convert_yv:
  0038a	8b 95 7c fe ff
	ff		 mov	 edx, DWORD PTR _x$11[ebp]
  00390	83 c2 20	 add	 edx, 32			; 00000020H
  00393	89 95 7c fe ff
	ff		 mov	 DWORD PTR _x$11[ebp], edx
  00399	8b 85 04 ff ff
	ff		 mov	 eax, DWORD PTR _src_u_ptr$17[ebp]
  0039f	83 c0 20	 add	 eax, 32			; 00000020H
  003a2	89 85 04 ff ff
	ff		 mov	 DWORD PTR _src_u_ptr$17[ebp], eax
  003a8	8b 8d 00 ff ff
	ff		 mov	 ecx, DWORD PTR _src_v_ptr$16[ebp]
  003ae	83 c1 20	 add	 ecx, 32			; 00000020H
  003b1	89 8d 00 ff ff
	ff		 mov	 DWORD PTR _src_v_ptr$16[ebp], ecx
  003b7	8b 95 fc fe ff
	ff		 mov	 edx, DWORD PTR _dst_ptr$15[ebp]
  003bd	83 c2 40	 add	 edx, 64			; 00000040H
  003c0	89 95 fc fe ff
	ff		 mov	 DWORD PTR _dst_ptr$15[ebp], edx
$LN13@convert_yv:
  003c6	8b 85 7c fe ff
	ff		 mov	 eax, DWORD PTR _x$11[ebp]
  003cc	3b 85 08 ff ff
	ff		 cmp	 eax, DWORD PTR _x_fin$18[ebp]
  003d2	0f 8d 57 01 00
	00		 jge	 $LN12@convert_yv

; 668  :             y0 = _mm256_loadu_si256((const __m256i *)src_u_ptr);

  003d8	8b 8d 04 ff ff
	ff		 mov	 ecx, DWORD PTR _src_u_ptr$17[ebp]
  003de	c5 fe 6f 01	 vmovdqu ymm0, YMMWORD PTR [ecx]
  003e2	c5 fe 7f 85 40
	fe ff ff	 vmovdqu YMMWORD PTR $T10[ebp], ymm0
  003ea	c5 fe 6f 85 40
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T10[ebp]
  003f2	c5 fe 7f 85 c0
	fe ff ff	 vmovdqu YMMWORD PTR _y0$14[ebp], ymm0

; 669  :             y1 = _mm256_loadu_si256((const __m256i *)src_v_ptr);

  003fa	8b 95 00 ff ff
	ff		 mov	 edx, DWORD PTR _src_v_ptr$16[ebp]
  00400	c5 fe 6f 02	 vmovdqu ymm0, YMMWORD PTR [edx]
  00404	c5 fe 7f 85 20
	fe ff ff	 vmovdqu YMMWORD PTR $T9[ebp], ymm0
  0040c	c5 fe 6f 85 20
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T9[ebp]
  00414	c5 fe 7f 85 a0
	fe ff ff	 vmovdqu YMMWORD PTR _y1$13[ebp], ymm0

; 670  : 
; 671  :             if (in_bit_depth < 16) {

  0041c	b8 01 00 00 00	 mov	 eax, 1
  00421	85 c0		 test	 eax, eax
  00423	74 4a		 je	 SHORT $LN17@convert_yv

; 672  :                 y0 = _mm256_slli_epi16(y0, 16 - in_bit_depth);

  00425	c5 fe 6f 85 c0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR _y0$14[ebp]
  0042d	c5 fd 71 f0 07	 vpsllw	 ymm0, ymm0, 7
  00432	c5 fe 7f 85 00
	fe ff ff	 vmovdqu YMMWORD PTR $T8[ebp], ymm0
  0043a	c5 fe 6f 85 00
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T8[ebp]
  00442	c5 fe 7f 85 c0
	fe ff ff	 vmovdqu YMMWORD PTR _y0$14[ebp], ymm0

; 673  :                 y1 = _mm256_slli_epi16(y1, 16 - in_bit_depth);

  0044a	c5 fe 6f 85 a0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR _y1$13[ebp]
  00452	c5 fd 71 f0 07	 vpsllw	 ymm0, ymm0, 7
  00457	c5 fe 7f 85 e0
	fd ff ff	 vmovdqu YMMWORD PTR $T7[ebp], ymm0
  0045f	c5 fe 6f 85 e0
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T7[ebp]
  00467	c5 fe 7f 85 a0
	fe ff ff	 vmovdqu YMMWORD PTR _y1$13[ebp], ymm0
$LN17@convert_yv:

; 674  :             }
; 675  : 
; 676  :             y0 = _mm256_permute4x64_epi64(y0, _MM_SHUFFLE(3,1,2,0));

  0046f	c4 e3 fd 00 85
	c0 fe ff ff d8	 vpermq	 ymm0, YMMWORD PTR _y0$14[ebp], 216 ; 000000d8H
  00479	c5 fe 7f 85 c0
	fd ff ff	 vmovdqu YMMWORD PTR $T6[ebp], ymm0
  00481	c5 fe 6f 85 c0
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T6[ebp]
  00489	c5 fe 7f 85 c0
	fe ff ff	 vmovdqu YMMWORD PTR _y0$14[ebp], ymm0

; 677  :             y1 = _mm256_permute4x64_epi64(y1, _MM_SHUFFLE(3,1,2,0));

  00491	c4 e3 fd 00 85
	a0 fe ff ff d8	 vpermq	 ymm0, YMMWORD PTR _y1$13[ebp], 216 ; 000000d8H
  0049b	c5 fe 7f 85 a0
	fd ff ff	 vmovdqu YMMWORD PTR $T5[ebp], ymm0
  004a3	c5 fe 6f 85 a0
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T5[ebp]
  004ab	c5 fe 7f 85 a0
	fe ff ff	 vmovdqu YMMWORD PTR _y1$13[ebp], ymm0

; 678  : 
; 679  :             y2 = _mm256_unpackhi_epi16(y0, y1);

  004b3	c5 fe 6f 85 c0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR _y0$14[ebp]
  004bb	c5 fd 69 85 a0
	fe ff ff	 vpunpckhwd ymm0, ymm0, YMMWORD PTR _y1$13[ebp]
  004c3	c5 fe 7f 85 80
	fd ff ff	 vmovdqu YMMWORD PTR $T4[ebp], ymm0
  004cb	c5 fe 6f 85 80
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T4[ebp]
  004d3	c5 fe 7f 85 80
	fe ff ff	 vmovdqu YMMWORD PTR _y2$12[ebp], ymm0

; 680  :             y0 = _mm256_unpacklo_epi16(y0, y1);

  004db	c5 fe 6f 85 c0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR _y0$14[ebp]
  004e3	c5 fd 61 85 a0
	fe ff ff	 vpunpcklwd ymm0, ymm0, YMMWORD PTR _y1$13[ebp]
  004eb	c5 fe 7f 85 60
	fd ff ff	 vmovdqu YMMWORD PTR $T3[ebp], ymm0
  004f3	c5 fe 6f 85 60
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T3[ebp]
  004fb	c5 fe 7f 85 c0
	fe ff ff	 vmovdqu YMMWORD PTR _y0$14[ebp], ymm0

; 681  : 
; 682  :             _mm256_storeu_si256((__m256i *)(dst_ptr +  0), y0);

  00503	c5 fe 6f 85 c0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR _y0$14[ebp]
  0050b	8b 8d fc fe ff
	ff		 mov	 ecx, DWORD PTR _dst_ptr$15[ebp]
  00511	c5 fe 7f 01	 vmovdqu YMMWORD PTR [ecx], ymm0

; 683  :             _mm256_storeu_si256((__m256i *)(dst_ptr + 16), y2);

  00515	c5 fe 6f 85 80
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR _y2$12[ebp]
  0051d	8b 95 fc fe ff
	ff		 mov	 edx, DWORD PTR _dst_ptr$15[ebp]
  00523	83 c2 20	 add	 edx, 32			; 00000020H
  00526	c5 fe 7f 02	 vmovdqu YMMWORD PTR [edx], ymm0

; 684  :         }

  0052a	e9 5b fe ff ff	 jmp	 $LN11@convert_yv
$LN12@convert_yv:

; 685  :     }

  0052f	e9 be fd ff ff	 jmp	 $LN8@convert_yv
$LN1@convert_yv:

; 686  : }

  00534	52		 push	 edx
  00535	8b cd		 mov	 ecx, ebp
  00537	50		 push	 eax
  00538	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN22@convert_yv
  0053e	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00543	58		 pop	 eax
  00544	5a		 pop	 edx
  00545	5f		 pop	 edi
  00546	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00549	33 cd		 xor	 ecx, ebp
  0054b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00550	8b e5		 mov	 esp, ebp
  00552	5d		 pop	 ebp
  00553	8b e3		 mov	 esp, ebx
  00555	5b		 pop	 ebx
  00556	c3		 ret	 0
  00557	90		 npad	 1
$LN22@convert_yv:
  00558	02 00 00 00	 DD	 2
  0055c	00 00 00 00	 DD	 $LN21@convert_yv
$LN21@convert_yv:
  00560	d4 ff ff ff	 DD	 -44			; ffffffd4H
  00564	0c 00 00 00	 DD	 12			; 0000000cH
  00568	00 00 00 00	 DD	 $LN19@convert_yv
  0056c	30 ff ff ff	 DD	 -208			; ffffff30H
  00570	0c 00 00 00	 DD	 12			; 0000000cH
  00574	00 00 00 00	 DD	 $LN20@convert_yv
$LN20@convert_yv:
  00578	75		 DB	 117			; 00000075H
  00579	76		 DB	 118			; 00000076H
  0057a	5f		 DB	 95			; 0000005fH
  0057b	72		 DB	 114			; 00000072H
  0057c	61		 DB	 97			; 00000061H
  0057d	6e		 DB	 110			; 0000006eH
  0057e	67		 DB	 103			; 00000067H
  0057f	65		 DB	 101			; 00000065H
  00580	00		 DB	 0
$LN19@convert_yv:
  00581	79		 DB	 121			; 00000079H
  00582	5f		 DB	 95			; 0000005fH
  00583	72		 DB	 114			; 00000072H
  00584	61		 DB	 97			; 00000061H
  00585	6e		 DB	 110			; 0000006eH
  00586	67		 DB	 103			; 00000067H
  00587	65		 DB	 101			; 00000065H
  00588	00		 DB	 0
??$convert_yv12_high_to_p010_avx2_base@$08$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_high_to_p010_avx2_base<9,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yv12_09_to_p010_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_09_to_p010_avx2

; 705  : void convert_yv12_09_to_p010_avx2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 706  :     convert_yv12_high_to_p010_avx2_base<9, false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yv12_high_to_p010_avx2_base@$08$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_high_to_p010_avx2_base<9,0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 707  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yv12_09_to_p010_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_09_to_p010_avx2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
$T1 = -704						; size = 12
$T2 = -688						; size = 12
$T3 = -672						; size = 32
$T4 = -640						; size = 32
$T5 = -608						; size = 32
$T6 = -576						; size = 32
$T7 = -544						; size = 32
$T8 = -512						; size = 32
$T9 = -480						; size = 32
$T10 = -448						; size = 32
_x$11 = -388						; size = 4
_y2$12 = -384						; size = 32
_y1$13 = -352						; size = 32
_y0$14 = -320						; size = 32
_dst_ptr$15 = -260					; size = 4
_src_v_ptr$16 = -256					; size = 4
_src_u_ptr$17 = -252					; size = 4
_x_fin$18 = -248					; size = 4
_y$19 = -244						; size = 4
_dstLine$ = -240					; size = 4
_srcVLine$ = -236					; size = 4
_srcULine$ = -232					; size = 4
_src_uv_pitch$ = -228					; size = 4
$T20 = -224						; size = 12
_uv_range$ = -208					; size = 12
$T21 = -192						; size = 32
$T22 = -160						; size = 32
_y0$23 = -128						; size = 32
_x$24 = -88						; size = 4
_dst_ptr$25 = -84					; size = 4
_src_ptr$26 = -80					; size = 4
_y$27 = -76						; size = 4
_y_width$28 = -72					; size = 4
_dstLine$29 = -68					; size = 4
_srcYLine$30 = -64					; size = 4
$T31 = -60						; size = 12
_y_range$32 = -44					; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yv12_high_to_p010_avx2_base@$09$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_high_to_p010_avx2_base<10,0>

; 627  : static void __forceinline convert_yv12_high_to_p010_avx2_base(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec c0 02 00
	00		 sub	 esp, 704		; 000002c0H
  0001c	57		 push	 edi
  0001d	8d bd 40 fd ff
	ff		 lea	 edi, DWORD PTR [ebp-704]
  00023	b9 b0 00 00 00	 mov	 ecx, 176		; 000000b0H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 628  :     static_assert(8 < in_bit_depth && in_bit_depth <= 16, "in_bit_depth must be 9-16.");
; 629  :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 630  :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 631  :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 632  :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 633  :     const int src_y_pitch = src_y_pitch_byte >> 1;

  0007c	8b 53 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  0007f	d1 fa		 sar	 edx, 1
  00081	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 634  :     const int dst_y_pitch = dst_y_pitch_byte >> 1;

  00084	8b 43 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  00087	d1 f8		 sar	 eax, 1
  00089	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 635  :     //Y
; 636  :     if (!uv_only) {

  0008c	b9 01 00 00 00	 mov	 ecx, 1
  00091	85 c9		 test	 ecx, ecx
  00093	0f 84 68 01 00
	00		 je	 $LN14@convert_yv

; 637  :         const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00099	8b 53 2c	 mov	 edx, DWORD PTR _thread_n$[ebx]
  0009c	52		 push	 edx
  0009d	8b 43 28	 mov	 eax, DWORD PTR _thread_id$[ebx]
  000a0	50		 push	 eax
  000a1	8b 4b 20	 mov	 ecx, DWORD PTR _height$[ebx]
  000a4	2b 4d ec	 sub	 ecx, DWORD PTR _crop_bottom$[ebp]
  000a7	51		 push	 ecx
  000a8	8b 55 f4	 mov	 edx, DWORD PTR _crop_up$[ebp]
  000ab	52		 push	 edx
  000ac	8d 85 50 fd ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  000b2	50		 push	 eax
  000b3	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  000b8	83 c4 14	 add	 esp, 20			; 00000014H
  000bb	8b 08		 mov	 ecx, DWORD PTR [eax]
  000bd	89 4d c4	 mov	 DWORD PTR $T31[ebp], ecx
  000c0	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000c3	89 55 c8	 mov	 DWORD PTR $T31[ebp+4], edx
  000c6	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000c9	89 45 cc	 mov	 DWORD PTR $T31[ebp+8], eax
  000cc	8b 4d c4	 mov	 ecx, DWORD PTR $T31[ebp]
  000cf	89 4d d4	 mov	 DWORD PTR _y_range$32[ebp], ecx
  000d2	8b 55 c8	 mov	 edx, DWORD PTR $T31[ebp+4]
  000d5	89 55 d8	 mov	 DWORD PTR _y_range$32[ebp+4], edx
  000d8	8b 45 cc	 mov	 eax, DWORD PTR $T31[ebp+8]
  000db	89 45 dc	 mov	 DWORD PTR _y_range$32[ebp+8], eax

; 638  :         uint16_t *srcYLine = (uint16_t *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000de	b9 04 00 00 00	 mov	 ecx, 4
  000e3	6b d1 00	 imul	 edx, ecx, 0
  000e6	8b 45 e8	 mov	 eax, DWORD PTR _src_y_pitch$[ebp]
  000e9	0f af 45 d4	 imul	 eax, DWORD PTR _y_range$32[ebp]
  000ed	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  000f0	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  000f3	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  000f6	8b 4d f8	 mov	 ecx, DWORD PTR _crop_left$[ebp]
  000f9	8d 14 48	 lea	 edx, DWORD PTR [eax+ecx*2]
  000fc	89 55 c0	 mov	 DWORD PTR _srcYLine$30[ebp], edx

; 639  :         uint16_t *dstLine = (uint16_t *)dst[0] + dst_y_pitch * y_range.start_dst;

  000ff	b8 04 00 00 00	 mov	 eax, 4
  00104	6b c8 00	 imul	 ecx, eax, 0
  00107	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  0010a	0f af 55 d8	 imul	 edx, DWORD PTR _y_range$32[ebp+4]
  0010e	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  00111	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  00114	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  00117	89 55 bc	 mov	 DWORD PTR _dstLine$29[ebp], edx

; 640  :         const int y_width = width - crop_right - crop_left;

  0011a	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  0011d	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  00120	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  00123	89 45 b8	 mov	 DWORD PTR _y_width$28[ebp], eax

; 641  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  00126	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _y$27[ebp], 0
  0012d	eb 21		 jmp	 SHORT $LN4@convert_yv
$LN2@convert_yv:
  0012f	8b 4d b4	 mov	 ecx, DWORD PTR _y$27[ebp]
  00132	83 c1 01	 add	 ecx, 1
  00135	89 4d b4	 mov	 DWORD PTR _y$27[ebp], ecx
  00138	8b 55 e8	 mov	 edx, DWORD PTR _src_y_pitch$[ebp]
  0013b	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$30[ebp]
  0013e	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00141	89 4d c0	 mov	 DWORD PTR _srcYLine$30[ebp], ecx
  00144	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  00147	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$29[ebp]
  0014a	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  0014d	89 4d bc	 mov	 DWORD PTR _dstLine$29[ebp], ecx
$LN4@convert_yv:
  00150	8b 55 b4	 mov	 edx, DWORD PTR _y$27[ebp]
  00153	3b 55 dc	 cmp	 edx, DWORD PTR _y_range$32[ebp+8]
  00156	0f 8d a5 00 00
	00		 jge	 $LN14@convert_yv

; 642  :             if (in_bit_depth == 16) {

  0015c	33 c0		 xor	 eax, eax
  0015e	74 1b		 je	 SHORT $LN15@convert_yv

; 643  :                 avx2_memcpy<true>((uint8_t *)dstLine, (uint8_t *)srcYLine, y_width * (int)sizeof(uint16_t));

  00160	8b 4d b8	 mov	 ecx, DWORD PTR _y_width$28[ebp]
  00163	d1 e1		 shl	 ecx, 1
  00165	51		 push	 ecx
  00166	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$30[ebp]
  00169	52		 push	 edx
  0016a	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$29[ebp]
  0016d	50		 push	 eax
  0016e	e8 00 00 00 00	 call	 ??$avx2_memcpy@$00@@YAXPAEPBEH@Z ; avx2_memcpy<1>
  00173	83 c4 0c	 add	 esp, 12			; 0000000cH

; 644  :             } else {

  00176	e9 81 00 00 00	 jmp	 $LN16@convert_yv
$LN15@convert_yv:

; 645  :                 uint16_t *src_ptr = srcYLine;

  0017b	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$30[ebp]
  0017e	89 4d b0	 mov	 DWORD PTR _src_ptr$26[ebp], ecx

; 646  :                 uint16_t *dst_ptr = dstLine;

  00181	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$29[ebp]
  00184	89 55 ac	 mov	 DWORD PTR _dst_ptr$25[ebp], edx

; 647  :                 for (int x = 0; x < y_width; x += 16, dst_ptr += 16, src_ptr += 16) {

  00187	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR _x$24[ebp], 0
  0018e	eb 1b		 jmp	 SHORT $LN7@convert_yv
$LN5@convert_yv:
  00190	8b 45 a8	 mov	 eax, DWORD PTR _x$24[ebp]
  00193	83 c0 10	 add	 eax, 16			; 00000010H
  00196	89 45 a8	 mov	 DWORD PTR _x$24[ebp], eax
  00199	8b 4d ac	 mov	 ecx, DWORD PTR _dst_ptr$25[ebp]
  0019c	83 c1 20	 add	 ecx, 32			; 00000020H
  0019f	89 4d ac	 mov	 DWORD PTR _dst_ptr$25[ebp], ecx
  001a2	8b 55 b0	 mov	 edx, DWORD PTR _src_ptr$26[ebp]
  001a5	83 c2 20	 add	 edx, 32			; 00000020H
  001a8	89 55 b0	 mov	 DWORD PTR _src_ptr$26[ebp], edx
$LN7@convert_yv:
  001ab	8b 45 a8	 mov	 eax, DWORD PTR _x$24[ebp]
  001ae	3b 45 b8	 cmp	 eax, DWORD PTR _y_width$28[ebp]
  001b1	7d 49		 jge	 SHORT $LN16@convert_yv

; 648  :                     __m256i y0 = _mm256_loadu_si256((const __m256i *)src_ptr);

  001b3	8b 4d b0	 mov	 ecx, DWORD PTR _src_ptr$26[ebp]
  001b6	c5 fe 6f 01	 vmovdqu ymm0, YMMWORD PTR [ecx]
  001ba	c5 fe 7f 85 60
	ff ff ff	 vmovdqu YMMWORD PTR $T22[ebp], ymm0
  001c2	c5 fe 6f 85 60
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T22[ebp]
  001ca	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _y0$23[ebp], ymm0

; 649  :                     y0 = _mm256_slli_epi16(y0, 16 - in_bit_depth);

  001cf	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR _y0$23[ebp]
  001d4	c5 fd 71 f0 06	 vpsllw	 ymm0, ymm0, 6
  001d9	c5 fe 7f 85 40
	ff ff ff	 vmovdqu YMMWORD PTR $T21[ebp], ymm0
  001e1	c5 fe 6f 85 40
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T21[ebp]
  001e9	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _y0$23[ebp], ymm0

; 650  :                     _mm256_storeu_si256((__m256i *)dst_ptr, y0);

  001ee	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR _y0$23[ebp]
  001f3	8b 55 ac	 mov	 edx, DWORD PTR _dst_ptr$25[ebp]
  001f6	c5 fe 7f 02	 vmovdqu YMMWORD PTR [edx], ymm0

; 651  :                 }

  001fa	eb 94		 jmp	 SHORT $LN5@convert_yv
$LN16@convert_yv:

; 652  :             }
; 653  :         }

  001fc	e9 2e ff ff ff	 jmp	 $LN2@convert_yv
$LN14@convert_yv:

; 654  :     }
; 655  :     //UV
; 656  :     const auto uv_range = thread_y_range(crop_up >> 1, (height - crop_bottom) >> 1, thread_id, thread_n);

  00201	8b 43 2c	 mov	 eax, DWORD PTR _thread_n$[ebx]
  00204	50		 push	 eax
  00205	8b 4b 28	 mov	 ecx, DWORD PTR _thread_id$[ebx]
  00208	51		 push	 ecx
  00209	8b 53 20	 mov	 edx, DWORD PTR _height$[ebx]
  0020c	2b 55 ec	 sub	 edx, DWORD PTR _crop_bottom$[ebp]
  0020f	d1 fa		 sar	 edx, 1
  00211	52		 push	 edx
  00212	8b 45 f4	 mov	 eax, DWORD PTR _crop_up$[ebp]
  00215	d1 f8		 sar	 eax, 1
  00217	50		 push	 eax
  00218	8d 8d 40 fd ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  0021e	51		 push	 ecx
  0021f	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00224	83 c4 14	 add	 esp, 20			; 00000014H
  00227	8b 10		 mov	 edx, DWORD PTR [eax]
  00229	89 95 20 ff ff
	ff		 mov	 DWORD PTR $T20[ebp], edx
  0022f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00232	89 8d 24 ff ff
	ff		 mov	 DWORD PTR $T20[ebp+4], ecx
  00238	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0023b	89 95 28 ff ff
	ff		 mov	 DWORD PTR $T20[ebp+8], edx
  00241	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR $T20[ebp]
  00247	89 85 30 ff ff
	ff		 mov	 DWORD PTR _uv_range$[ebp], eax
  0024d	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR $T20[ebp+4]
  00253	89 8d 34 ff ff
	ff		 mov	 DWORD PTR _uv_range$[ebp+4], ecx
  00259	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR $T20[ebp+8]
  0025f	89 95 38 ff ff
	ff		 mov	 DWORD PTR _uv_range$[ebp+8], edx

; 657  :     const int src_uv_pitch = src_uv_pitch_byte >> 1;

  00265	8b 43 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebx]
  00268	d1 f8		 sar	 eax, 1
  0026a	89 85 1c ff ff
	ff		 mov	 DWORD PTR _src_uv_pitch$[ebp], eax

; 658  :     uint16_t *srcULine = (uint16_t *)src[1] + ((src_uv_pitch * uv_range.start_src) + (crop_left >> 1));

  00270	b9 04 00 00 00	 mov	 ecx, 4
  00275	c1 e1 00	 shl	 ecx, 0
  00278	8b 95 1c ff ff
	ff		 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  0027e	0f af 95 30 ff
	ff ff		 imul	 edx, DWORD PTR _uv_range$[ebp]
  00285	8b 45 f8	 mov	 eax, DWORD PTR _crop_left$[ebp]
  00288	d1 f8		 sar	 eax, 1
  0028a	03 d0		 add	 edx, eax
  0028c	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  0028f	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  00292	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  00295	89 95 18 ff ff
	ff		 mov	 DWORD PTR _srcULine$[ebp], edx

; 659  :     uint16_t *srcVLine = (uint16_t *)src[2] + ((src_uv_pitch * uv_range.start_src) + (crop_left >> 1));

  0029b	b8 04 00 00 00	 mov	 eax, 4
  002a0	d1 e0		 shl	 eax, 1
  002a2	8b 8d 1c ff ff
	ff		 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  002a8	0f af 8d 30 ff
	ff ff		 imul	 ecx, DWORD PTR _uv_range$[ebp]
  002af	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  002b2	d1 fa		 sar	 edx, 1
  002b4	03 ca		 add	 ecx, edx
  002b6	8b 53 0c	 mov	 edx, DWORD PTR _src$[ebx]
  002b9	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  002bc	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  002bf	89 8d 14 ff ff
	ff		 mov	 DWORD PTR _srcVLine$[ebp], ecx

; 660  :     uint16_t *dstLine = (uint16_t *)dst[1] + dst_y_pitch * uv_range.start_dst;;

  002c5	ba 04 00 00 00	 mov	 edx, 4
  002ca	c1 e2 00	 shl	 edx, 0
  002cd	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  002d0	0f af 85 34 ff
	ff ff		 imul	 eax, DWORD PTR _uv_range$[ebp+4]
  002d7	8b 4b 08	 mov	 ecx, DWORD PTR _dst$[ebx]
  002da	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  002dd	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  002e0	89 85 10 ff ff
	ff		 mov	 DWORD PTR _dstLine$[ebp], eax

; 661  :     for (int y = 0; y < uv_range.len; y++, srcULine += src_uv_pitch, srcVLine += src_uv_pitch, dstLine += dst_y_pitch) {

  002e6	c7 85 0c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _y$19[ebp], 0
  002f0	eb 4b		 jmp	 SHORT $LN10@convert_yv
$LN8@convert_yv:
  002f2	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR _y$19[ebp]
  002f8	83 c1 01	 add	 ecx, 1
  002fb	89 8d 0c ff ff
	ff		 mov	 DWORD PTR _y$19[ebp], ecx
  00301	8b 95 1c ff ff
	ff		 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  00307	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _srcULine$[ebp]
  0030d	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00310	89 8d 18 ff ff
	ff		 mov	 DWORD PTR _srcULine$[ebp], ecx
  00316	8b 95 1c ff ff
	ff		 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  0031c	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _srcVLine$[ebp]
  00322	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00325	89 8d 14 ff ff
	ff		 mov	 DWORD PTR _srcVLine$[ebp], ecx
  0032b	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  0032e	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _dstLine$[ebp]
  00334	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00337	89 8d 10 ff ff
	ff		 mov	 DWORD PTR _dstLine$[ebp], ecx
$LN10@convert_yv:
  0033d	8b 95 0c ff ff
	ff		 mov	 edx, DWORD PTR _y$19[ebp]
  00343	3b 95 38 ff ff
	ff		 cmp	 edx, DWORD PTR _uv_range$[ebp+8]
  00349	0f 8d e5 01 00
	00		 jge	 $LN1@convert_yv

; 662  :         const int x_fin = width - crop_right;

  0034f	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  00352	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  00355	89 85 08 ff ff
	ff		 mov	 DWORD PTR _x_fin$18[ebp], eax

; 663  :         uint16_t *src_u_ptr = srcULine;

  0035b	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR _srcULine$[ebp]
  00361	89 8d 04 ff ff
	ff		 mov	 DWORD PTR _src_u_ptr$17[ebp], ecx

; 664  :         uint16_t *src_v_ptr = srcVLine;

  00367	8b 95 14 ff ff
	ff		 mov	 edx, DWORD PTR _srcVLine$[ebp]
  0036d	89 95 00 ff ff
	ff		 mov	 DWORD PTR _src_v_ptr$16[ebp], edx

; 665  :         uint16_t *dst_ptr = dstLine;

  00373	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _dstLine$[ebp]
  00379	89 85 fc fe ff
	ff		 mov	 DWORD PTR _dst_ptr$15[ebp], eax

; 666  :         __m256i y0, y1, y2;
; 667  :         for (int x = crop_left; x < x_fin; x += 32, src_u_ptr += 16, src_v_ptr += 16, dst_ptr += 32) {

  0037f	8b 4d f8	 mov	 ecx, DWORD PTR _crop_left$[ebp]
  00382	89 8d 7c fe ff
	ff		 mov	 DWORD PTR _x$11[ebp], ecx
  00388	eb 3c		 jmp	 SHORT $LN13@convert_yv
$LN11@convert_yv:
  0038a	8b 95 7c fe ff
	ff		 mov	 edx, DWORD PTR _x$11[ebp]
  00390	83 c2 20	 add	 edx, 32			; 00000020H
  00393	89 95 7c fe ff
	ff		 mov	 DWORD PTR _x$11[ebp], edx
  00399	8b 85 04 ff ff
	ff		 mov	 eax, DWORD PTR _src_u_ptr$17[ebp]
  0039f	83 c0 20	 add	 eax, 32			; 00000020H
  003a2	89 85 04 ff ff
	ff		 mov	 DWORD PTR _src_u_ptr$17[ebp], eax
  003a8	8b 8d 00 ff ff
	ff		 mov	 ecx, DWORD PTR _src_v_ptr$16[ebp]
  003ae	83 c1 20	 add	 ecx, 32			; 00000020H
  003b1	89 8d 00 ff ff
	ff		 mov	 DWORD PTR _src_v_ptr$16[ebp], ecx
  003b7	8b 95 fc fe ff
	ff		 mov	 edx, DWORD PTR _dst_ptr$15[ebp]
  003bd	83 c2 40	 add	 edx, 64			; 00000040H
  003c0	89 95 fc fe ff
	ff		 mov	 DWORD PTR _dst_ptr$15[ebp], edx
$LN13@convert_yv:
  003c6	8b 85 7c fe ff
	ff		 mov	 eax, DWORD PTR _x$11[ebp]
  003cc	3b 85 08 ff ff
	ff		 cmp	 eax, DWORD PTR _x_fin$18[ebp]
  003d2	0f 8d 57 01 00
	00		 jge	 $LN12@convert_yv

; 668  :             y0 = _mm256_loadu_si256((const __m256i *)src_u_ptr);

  003d8	8b 8d 04 ff ff
	ff		 mov	 ecx, DWORD PTR _src_u_ptr$17[ebp]
  003de	c5 fe 6f 01	 vmovdqu ymm0, YMMWORD PTR [ecx]
  003e2	c5 fe 7f 85 40
	fe ff ff	 vmovdqu YMMWORD PTR $T10[ebp], ymm0
  003ea	c5 fe 6f 85 40
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T10[ebp]
  003f2	c5 fe 7f 85 c0
	fe ff ff	 vmovdqu YMMWORD PTR _y0$14[ebp], ymm0

; 669  :             y1 = _mm256_loadu_si256((const __m256i *)src_v_ptr);

  003fa	8b 95 00 ff ff
	ff		 mov	 edx, DWORD PTR _src_v_ptr$16[ebp]
  00400	c5 fe 6f 02	 vmovdqu ymm0, YMMWORD PTR [edx]
  00404	c5 fe 7f 85 20
	fe ff ff	 vmovdqu YMMWORD PTR $T9[ebp], ymm0
  0040c	c5 fe 6f 85 20
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T9[ebp]
  00414	c5 fe 7f 85 a0
	fe ff ff	 vmovdqu YMMWORD PTR _y1$13[ebp], ymm0

; 670  : 
; 671  :             if (in_bit_depth < 16) {

  0041c	b8 01 00 00 00	 mov	 eax, 1
  00421	85 c0		 test	 eax, eax
  00423	74 4a		 je	 SHORT $LN17@convert_yv

; 672  :                 y0 = _mm256_slli_epi16(y0, 16 - in_bit_depth);

  00425	c5 fe 6f 85 c0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR _y0$14[ebp]
  0042d	c5 fd 71 f0 06	 vpsllw	 ymm0, ymm0, 6
  00432	c5 fe 7f 85 00
	fe ff ff	 vmovdqu YMMWORD PTR $T8[ebp], ymm0
  0043a	c5 fe 6f 85 00
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T8[ebp]
  00442	c5 fe 7f 85 c0
	fe ff ff	 vmovdqu YMMWORD PTR _y0$14[ebp], ymm0

; 673  :                 y1 = _mm256_slli_epi16(y1, 16 - in_bit_depth);

  0044a	c5 fe 6f 85 a0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR _y1$13[ebp]
  00452	c5 fd 71 f0 06	 vpsllw	 ymm0, ymm0, 6
  00457	c5 fe 7f 85 e0
	fd ff ff	 vmovdqu YMMWORD PTR $T7[ebp], ymm0
  0045f	c5 fe 6f 85 e0
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T7[ebp]
  00467	c5 fe 7f 85 a0
	fe ff ff	 vmovdqu YMMWORD PTR _y1$13[ebp], ymm0
$LN17@convert_yv:

; 674  :             }
; 675  : 
; 676  :             y0 = _mm256_permute4x64_epi64(y0, _MM_SHUFFLE(3,1,2,0));

  0046f	c4 e3 fd 00 85
	c0 fe ff ff d8	 vpermq	 ymm0, YMMWORD PTR _y0$14[ebp], 216 ; 000000d8H
  00479	c5 fe 7f 85 c0
	fd ff ff	 vmovdqu YMMWORD PTR $T6[ebp], ymm0
  00481	c5 fe 6f 85 c0
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T6[ebp]
  00489	c5 fe 7f 85 c0
	fe ff ff	 vmovdqu YMMWORD PTR _y0$14[ebp], ymm0

; 677  :             y1 = _mm256_permute4x64_epi64(y1, _MM_SHUFFLE(3,1,2,0));

  00491	c4 e3 fd 00 85
	a0 fe ff ff d8	 vpermq	 ymm0, YMMWORD PTR _y1$13[ebp], 216 ; 000000d8H
  0049b	c5 fe 7f 85 a0
	fd ff ff	 vmovdqu YMMWORD PTR $T5[ebp], ymm0
  004a3	c5 fe 6f 85 a0
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T5[ebp]
  004ab	c5 fe 7f 85 a0
	fe ff ff	 vmovdqu YMMWORD PTR _y1$13[ebp], ymm0

; 678  : 
; 679  :             y2 = _mm256_unpackhi_epi16(y0, y1);

  004b3	c5 fe 6f 85 c0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR _y0$14[ebp]
  004bb	c5 fd 69 85 a0
	fe ff ff	 vpunpckhwd ymm0, ymm0, YMMWORD PTR _y1$13[ebp]
  004c3	c5 fe 7f 85 80
	fd ff ff	 vmovdqu YMMWORD PTR $T4[ebp], ymm0
  004cb	c5 fe 6f 85 80
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T4[ebp]
  004d3	c5 fe 7f 85 80
	fe ff ff	 vmovdqu YMMWORD PTR _y2$12[ebp], ymm0

; 680  :             y0 = _mm256_unpacklo_epi16(y0, y1);

  004db	c5 fe 6f 85 c0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR _y0$14[ebp]
  004e3	c5 fd 61 85 a0
	fe ff ff	 vpunpcklwd ymm0, ymm0, YMMWORD PTR _y1$13[ebp]
  004eb	c5 fe 7f 85 60
	fd ff ff	 vmovdqu YMMWORD PTR $T3[ebp], ymm0
  004f3	c5 fe 6f 85 60
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T3[ebp]
  004fb	c5 fe 7f 85 c0
	fe ff ff	 vmovdqu YMMWORD PTR _y0$14[ebp], ymm0

; 681  : 
; 682  :             _mm256_storeu_si256((__m256i *)(dst_ptr +  0), y0);

  00503	c5 fe 6f 85 c0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR _y0$14[ebp]
  0050b	8b 8d fc fe ff
	ff		 mov	 ecx, DWORD PTR _dst_ptr$15[ebp]
  00511	c5 fe 7f 01	 vmovdqu YMMWORD PTR [ecx], ymm0

; 683  :             _mm256_storeu_si256((__m256i *)(dst_ptr + 16), y2);

  00515	c5 fe 6f 85 80
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR _y2$12[ebp]
  0051d	8b 95 fc fe ff
	ff		 mov	 edx, DWORD PTR _dst_ptr$15[ebp]
  00523	83 c2 20	 add	 edx, 32			; 00000020H
  00526	c5 fe 7f 02	 vmovdqu YMMWORD PTR [edx], ymm0

; 684  :         }

  0052a	e9 5b fe ff ff	 jmp	 $LN11@convert_yv
$LN12@convert_yv:

; 685  :     }

  0052f	e9 be fd ff ff	 jmp	 $LN8@convert_yv
$LN1@convert_yv:

; 686  : }

  00534	52		 push	 edx
  00535	8b cd		 mov	 ecx, ebp
  00537	50		 push	 eax
  00538	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN22@convert_yv
  0053e	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00543	58		 pop	 eax
  00544	5a		 pop	 edx
  00545	5f		 pop	 edi
  00546	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00549	33 cd		 xor	 ecx, ebp
  0054b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00550	8b e5		 mov	 esp, ebp
  00552	5d		 pop	 ebp
  00553	8b e3		 mov	 esp, ebx
  00555	5b		 pop	 ebx
  00556	c3		 ret	 0
  00557	90		 npad	 1
$LN22@convert_yv:
  00558	02 00 00 00	 DD	 2
  0055c	00 00 00 00	 DD	 $LN21@convert_yv
$LN21@convert_yv:
  00560	d4 ff ff ff	 DD	 -44			; ffffffd4H
  00564	0c 00 00 00	 DD	 12			; 0000000cH
  00568	00 00 00 00	 DD	 $LN19@convert_yv
  0056c	30 ff ff ff	 DD	 -208			; ffffff30H
  00570	0c 00 00 00	 DD	 12			; 0000000cH
  00574	00 00 00 00	 DD	 $LN20@convert_yv
$LN20@convert_yv:
  00578	75		 DB	 117			; 00000075H
  00579	76		 DB	 118			; 00000076H
  0057a	5f		 DB	 95			; 0000005fH
  0057b	72		 DB	 114			; 00000072H
  0057c	61		 DB	 97			; 00000061H
  0057d	6e		 DB	 110			; 0000006eH
  0057e	67		 DB	 103			; 00000067H
  0057f	65		 DB	 101			; 00000065H
  00580	00		 DB	 0
$LN19@convert_yv:
  00581	79		 DB	 121			; 00000079H
  00582	5f		 DB	 95			; 0000005fH
  00583	72		 DB	 114			; 00000072H
  00584	61		 DB	 97			; 00000061H
  00585	6e		 DB	 110			; 0000006eH
  00586	67		 DB	 103			; 00000067H
  00587	65		 DB	 101			; 00000065H
  00588	00		 DB	 0
??$convert_yv12_high_to_p010_avx2_base@$09$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_high_to_p010_avx2_base<10,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yv12_10_to_p010_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_10_to_p010_avx2

; 701  : void convert_yv12_10_to_p010_avx2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 702  :     convert_yv12_high_to_p010_avx2_base<10, false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yv12_high_to_p010_avx2_base@$09$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_high_to_p010_avx2_base<10,0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 703  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yv12_10_to_p010_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_10_to_p010_avx2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
$T1 = -704						; size = 12
$T2 = -688						; size = 12
$T3 = -672						; size = 32
$T4 = -640						; size = 32
$T5 = -608						; size = 32
$T6 = -576						; size = 32
$T7 = -544						; size = 32
$T8 = -512						; size = 32
$T9 = -480						; size = 32
$T10 = -448						; size = 32
_x$11 = -388						; size = 4
_y2$12 = -384						; size = 32
_y1$13 = -352						; size = 32
_y0$14 = -320						; size = 32
_dst_ptr$15 = -260					; size = 4
_src_v_ptr$16 = -256					; size = 4
_src_u_ptr$17 = -252					; size = 4
_x_fin$18 = -248					; size = 4
_y$19 = -244						; size = 4
_dstLine$ = -240					; size = 4
_srcVLine$ = -236					; size = 4
_srcULine$ = -232					; size = 4
_src_uv_pitch$ = -228					; size = 4
$T20 = -224						; size = 12
_uv_range$ = -208					; size = 12
$T21 = -192						; size = 32
$T22 = -160						; size = 32
_y0$23 = -128						; size = 32
_x$24 = -88						; size = 4
_dst_ptr$25 = -84					; size = 4
_src_ptr$26 = -80					; size = 4
_y$27 = -76						; size = 4
_y_width$28 = -72					; size = 4
_dstLine$29 = -68					; size = 4
_srcYLine$30 = -64					; size = 4
$T31 = -60						; size = 12
_y_range$32 = -44					; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yv12_high_to_p010_avx2_base@$0M@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_high_to_p010_avx2_base<12,0>

; 627  : static void __forceinline convert_yv12_high_to_p010_avx2_base(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec c0 02 00
	00		 sub	 esp, 704		; 000002c0H
  0001c	57		 push	 edi
  0001d	8d bd 40 fd ff
	ff		 lea	 edi, DWORD PTR [ebp-704]
  00023	b9 b0 00 00 00	 mov	 ecx, 176		; 000000b0H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 628  :     static_assert(8 < in_bit_depth && in_bit_depth <= 16, "in_bit_depth must be 9-16.");
; 629  :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 630  :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 631  :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 632  :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 633  :     const int src_y_pitch = src_y_pitch_byte >> 1;

  0007c	8b 53 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  0007f	d1 fa		 sar	 edx, 1
  00081	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 634  :     const int dst_y_pitch = dst_y_pitch_byte >> 1;

  00084	8b 43 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  00087	d1 f8		 sar	 eax, 1
  00089	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 635  :     //Y
; 636  :     if (!uv_only) {

  0008c	b9 01 00 00 00	 mov	 ecx, 1
  00091	85 c9		 test	 ecx, ecx
  00093	0f 84 68 01 00
	00		 je	 $LN14@convert_yv

; 637  :         const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00099	8b 53 2c	 mov	 edx, DWORD PTR _thread_n$[ebx]
  0009c	52		 push	 edx
  0009d	8b 43 28	 mov	 eax, DWORD PTR _thread_id$[ebx]
  000a0	50		 push	 eax
  000a1	8b 4b 20	 mov	 ecx, DWORD PTR _height$[ebx]
  000a4	2b 4d ec	 sub	 ecx, DWORD PTR _crop_bottom$[ebp]
  000a7	51		 push	 ecx
  000a8	8b 55 f4	 mov	 edx, DWORD PTR _crop_up$[ebp]
  000ab	52		 push	 edx
  000ac	8d 85 50 fd ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  000b2	50		 push	 eax
  000b3	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  000b8	83 c4 14	 add	 esp, 20			; 00000014H
  000bb	8b 08		 mov	 ecx, DWORD PTR [eax]
  000bd	89 4d c4	 mov	 DWORD PTR $T31[ebp], ecx
  000c0	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000c3	89 55 c8	 mov	 DWORD PTR $T31[ebp+4], edx
  000c6	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000c9	89 45 cc	 mov	 DWORD PTR $T31[ebp+8], eax
  000cc	8b 4d c4	 mov	 ecx, DWORD PTR $T31[ebp]
  000cf	89 4d d4	 mov	 DWORD PTR _y_range$32[ebp], ecx
  000d2	8b 55 c8	 mov	 edx, DWORD PTR $T31[ebp+4]
  000d5	89 55 d8	 mov	 DWORD PTR _y_range$32[ebp+4], edx
  000d8	8b 45 cc	 mov	 eax, DWORD PTR $T31[ebp+8]
  000db	89 45 dc	 mov	 DWORD PTR _y_range$32[ebp+8], eax

; 638  :         uint16_t *srcYLine = (uint16_t *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000de	b9 04 00 00 00	 mov	 ecx, 4
  000e3	6b d1 00	 imul	 edx, ecx, 0
  000e6	8b 45 e8	 mov	 eax, DWORD PTR _src_y_pitch$[ebp]
  000e9	0f af 45 d4	 imul	 eax, DWORD PTR _y_range$32[ebp]
  000ed	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  000f0	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  000f3	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  000f6	8b 4d f8	 mov	 ecx, DWORD PTR _crop_left$[ebp]
  000f9	8d 14 48	 lea	 edx, DWORD PTR [eax+ecx*2]
  000fc	89 55 c0	 mov	 DWORD PTR _srcYLine$30[ebp], edx

; 639  :         uint16_t *dstLine = (uint16_t *)dst[0] + dst_y_pitch * y_range.start_dst;

  000ff	b8 04 00 00 00	 mov	 eax, 4
  00104	6b c8 00	 imul	 ecx, eax, 0
  00107	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  0010a	0f af 55 d8	 imul	 edx, DWORD PTR _y_range$32[ebp+4]
  0010e	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  00111	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  00114	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  00117	89 55 bc	 mov	 DWORD PTR _dstLine$29[ebp], edx

; 640  :         const int y_width = width - crop_right - crop_left;

  0011a	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  0011d	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  00120	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  00123	89 45 b8	 mov	 DWORD PTR _y_width$28[ebp], eax

; 641  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  00126	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _y$27[ebp], 0
  0012d	eb 21		 jmp	 SHORT $LN4@convert_yv
$LN2@convert_yv:
  0012f	8b 4d b4	 mov	 ecx, DWORD PTR _y$27[ebp]
  00132	83 c1 01	 add	 ecx, 1
  00135	89 4d b4	 mov	 DWORD PTR _y$27[ebp], ecx
  00138	8b 55 e8	 mov	 edx, DWORD PTR _src_y_pitch$[ebp]
  0013b	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$30[ebp]
  0013e	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00141	89 4d c0	 mov	 DWORD PTR _srcYLine$30[ebp], ecx
  00144	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  00147	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$29[ebp]
  0014a	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  0014d	89 4d bc	 mov	 DWORD PTR _dstLine$29[ebp], ecx
$LN4@convert_yv:
  00150	8b 55 b4	 mov	 edx, DWORD PTR _y$27[ebp]
  00153	3b 55 dc	 cmp	 edx, DWORD PTR _y_range$32[ebp+8]
  00156	0f 8d a5 00 00
	00		 jge	 $LN14@convert_yv

; 642  :             if (in_bit_depth == 16) {

  0015c	33 c0		 xor	 eax, eax
  0015e	74 1b		 je	 SHORT $LN15@convert_yv

; 643  :                 avx2_memcpy<true>((uint8_t *)dstLine, (uint8_t *)srcYLine, y_width * (int)sizeof(uint16_t));

  00160	8b 4d b8	 mov	 ecx, DWORD PTR _y_width$28[ebp]
  00163	d1 e1		 shl	 ecx, 1
  00165	51		 push	 ecx
  00166	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$30[ebp]
  00169	52		 push	 edx
  0016a	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$29[ebp]
  0016d	50		 push	 eax
  0016e	e8 00 00 00 00	 call	 ??$avx2_memcpy@$00@@YAXPAEPBEH@Z ; avx2_memcpy<1>
  00173	83 c4 0c	 add	 esp, 12			; 0000000cH

; 644  :             } else {

  00176	e9 81 00 00 00	 jmp	 $LN16@convert_yv
$LN15@convert_yv:

; 645  :                 uint16_t *src_ptr = srcYLine;

  0017b	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$30[ebp]
  0017e	89 4d b0	 mov	 DWORD PTR _src_ptr$26[ebp], ecx

; 646  :                 uint16_t *dst_ptr = dstLine;

  00181	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$29[ebp]
  00184	89 55 ac	 mov	 DWORD PTR _dst_ptr$25[ebp], edx

; 647  :                 for (int x = 0; x < y_width; x += 16, dst_ptr += 16, src_ptr += 16) {

  00187	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR _x$24[ebp], 0
  0018e	eb 1b		 jmp	 SHORT $LN7@convert_yv
$LN5@convert_yv:
  00190	8b 45 a8	 mov	 eax, DWORD PTR _x$24[ebp]
  00193	83 c0 10	 add	 eax, 16			; 00000010H
  00196	89 45 a8	 mov	 DWORD PTR _x$24[ebp], eax
  00199	8b 4d ac	 mov	 ecx, DWORD PTR _dst_ptr$25[ebp]
  0019c	83 c1 20	 add	 ecx, 32			; 00000020H
  0019f	89 4d ac	 mov	 DWORD PTR _dst_ptr$25[ebp], ecx
  001a2	8b 55 b0	 mov	 edx, DWORD PTR _src_ptr$26[ebp]
  001a5	83 c2 20	 add	 edx, 32			; 00000020H
  001a8	89 55 b0	 mov	 DWORD PTR _src_ptr$26[ebp], edx
$LN7@convert_yv:
  001ab	8b 45 a8	 mov	 eax, DWORD PTR _x$24[ebp]
  001ae	3b 45 b8	 cmp	 eax, DWORD PTR _y_width$28[ebp]
  001b1	7d 49		 jge	 SHORT $LN16@convert_yv

; 648  :                     __m256i y0 = _mm256_loadu_si256((const __m256i *)src_ptr);

  001b3	8b 4d b0	 mov	 ecx, DWORD PTR _src_ptr$26[ebp]
  001b6	c5 fe 6f 01	 vmovdqu ymm0, YMMWORD PTR [ecx]
  001ba	c5 fe 7f 85 60
	ff ff ff	 vmovdqu YMMWORD PTR $T22[ebp], ymm0
  001c2	c5 fe 6f 85 60
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T22[ebp]
  001ca	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _y0$23[ebp], ymm0

; 649  :                     y0 = _mm256_slli_epi16(y0, 16 - in_bit_depth);

  001cf	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR _y0$23[ebp]
  001d4	c5 fd 71 f0 04	 vpsllw	 ymm0, ymm0, 4
  001d9	c5 fe 7f 85 40
	ff ff ff	 vmovdqu YMMWORD PTR $T21[ebp], ymm0
  001e1	c5 fe 6f 85 40
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T21[ebp]
  001e9	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _y0$23[ebp], ymm0

; 650  :                     _mm256_storeu_si256((__m256i *)dst_ptr, y0);

  001ee	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR _y0$23[ebp]
  001f3	8b 55 ac	 mov	 edx, DWORD PTR _dst_ptr$25[ebp]
  001f6	c5 fe 7f 02	 vmovdqu YMMWORD PTR [edx], ymm0

; 651  :                 }

  001fa	eb 94		 jmp	 SHORT $LN5@convert_yv
$LN16@convert_yv:

; 652  :             }
; 653  :         }

  001fc	e9 2e ff ff ff	 jmp	 $LN2@convert_yv
$LN14@convert_yv:

; 654  :     }
; 655  :     //UV
; 656  :     const auto uv_range = thread_y_range(crop_up >> 1, (height - crop_bottom) >> 1, thread_id, thread_n);

  00201	8b 43 2c	 mov	 eax, DWORD PTR _thread_n$[ebx]
  00204	50		 push	 eax
  00205	8b 4b 28	 mov	 ecx, DWORD PTR _thread_id$[ebx]
  00208	51		 push	 ecx
  00209	8b 53 20	 mov	 edx, DWORD PTR _height$[ebx]
  0020c	2b 55 ec	 sub	 edx, DWORD PTR _crop_bottom$[ebp]
  0020f	d1 fa		 sar	 edx, 1
  00211	52		 push	 edx
  00212	8b 45 f4	 mov	 eax, DWORD PTR _crop_up$[ebp]
  00215	d1 f8		 sar	 eax, 1
  00217	50		 push	 eax
  00218	8d 8d 40 fd ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  0021e	51		 push	 ecx
  0021f	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00224	83 c4 14	 add	 esp, 20			; 00000014H
  00227	8b 10		 mov	 edx, DWORD PTR [eax]
  00229	89 95 20 ff ff
	ff		 mov	 DWORD PTR $T20[ebp], edx
  0022f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00232	89 8d 24 ff ff
	ff		 mov	 DWORD PTR $T20[ebp+4], ecx
  00238	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0023b	89 95 28 ff ff
	ff		 mov	 DWORD PTR $T20[ebp+8], edx
  00241	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR $T20[ebp]
  00247	89 85 30 ff ff
	ff		 mov	 DWORD PTR _uv_range$[ebp], eax
  0024d	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR $T20[ebp+4]
  00253	89 8d 34 ff ff
	ff		 mov	 DWORD PTR _uv_range$[ebp+4], ecx
  00259	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR $T20[ebp+8]
  0025f	89 95 38 ff ff
	ff		 mov	 DWORD PTR _uv_range$[ebp+8], edx

; 657  :     const int src_uv_pitch = src_uv_pitch_byte >> 1;

  00265	8b 43 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebx]
  00268	d1 f8		 sar	 eax, 1
  0026a	89 85 1c ff ff
	ff		 mov	 DWORD PTR _src_uv_pitch$[ebp], eax

; 658  :     uint16_t *srcULine = (uint16_t *)src[1] + ((src_uv_pitch * uv_range.start_src) + (crop_left >> 1));

  00270	b9 04 00 00 00	 mov	 ecx, 4
  00275	c1 e1 00	 shl	 ecx, 0
  00278	8b 95 1c ff ff
	ff		 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  0027e	0f af 95 30 ff
	ff ff		 imul	 edx, DWORD PTR _uv_range$[ebp]
  00285	8b 45 f8	 mov	 eax, DWORD PTR _crop_left$[ebp]
  00288	d1 f8		 sar	 eax, 1
  0028a	03 d0		 add	 edx, eax
  0028c	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  0028f	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  00292	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  00295	89 95 18 ff ff
	ff		 mov	 DWORD PTR _srcULine$[ebp], edx

; 659  :     uint16_t *srcVLine = (uint16_t *)src[2] + ((src_uv_pitch * uv_range.start_src) + (crop_left >> 1));

  0029b	b8 04 00 00 00	 mov	 eax, 4
  002a0	d1 e0		 shl	 eax, 1
  002a2	8b 8d 1c ff ff
	ff		 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  002a8	0f af 8d 30 ff
	ff ff		 imul	 ecx, DWORD PTR _uv_range$[ebp]
  002af	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  002b2	d1 fa		 sar	 edx, 1
  002b4	03 ca		 add	 ecx, edx
  002b6	8b 53 0c	 mov	 edx, DWORD PTR _src$[ebx]
  002b9	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  002bc	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  002bf	89 8d 14 ff ff
	ff		 mov	 DWORD PTR _srcVLine$[ebp], ecx

; 660  :     uint16_t *dstLine = (uint16_t *)dst[1] + dst_y_pitch * uv_range.start_dst;;

  002c5	ba 04 00 00 00	 mov	 edx, 4
  002ca	c1 e2 00	 shl	 edx, 0
  002cd	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  002d0	0f af 85 34 ff
	ff ff		 imul	 eax, DWORD PTR _uv_range$[ebp+4]
  002d7	8b 4b 08	 mov	 ecx, DWORD PTR _dst$[ebx]
  002da	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  002dd	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  002e0	89 85 10 ff ff
	ff		 mov	 DWORD PTR _dstLine$[ebp], eax

; 661  :     for (int y = 0; y < uv_range.len; y++, srcULine += src_uv_pitch, srcVLine += src_uv_pitch, dstLine += dst_y_pitch) {

  002e6	c7 85 0c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _y$19[ebp], 0
  002f0	eb 4b		 jmp	 SHORT $LN10@convert_yv
$LN8@convert_yv:
  002f2	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR _y$19[ebp]
  002f8	83 c1 01	 add	 ecx, 1
  002fb	89 8d 0c ff ff
	ff		 mov	 DWORD PTR _y$19[ebp], ecx
  00301	8b 95 1c ff ff
	ff		 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  00307	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _srcULine$[ebp]
  0030d	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00310	89 8d 18 ff ff
	ff		 mov	 DWORD PTR _srcULine$[ebp], ecx
  00316	8b 95 1c ff ff
	ff		 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  0031c	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _srcVLine$[ebp]
  00322	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00325	89 8d 14 ff ff
	ff		 mov	 DWORD PTR _srcVLine$[ebp], ecx
  0032b	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  0032e	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _dstLine$[ebp]
  00334	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00337	89 8d 10 ff ff
	ff		 mov	 DWORD PTR _dstLine$[ebp], ecx
$LN10@convert_yv:
  0033d	8b 95 0c ff ff
	ff		 mov	 edx, DWORD PTR _y$19[ebp]
  00343	3b 95 38 ff ff
	ff		 cmp	 edx, DWORD PTR _uv_range$[ebp+8]
  00349	0f 8d e5 01 00
	00		 jge	 $LN1@convert_yv

; 662  :         const int x_fin = width - crop_right;

  0034f	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  00352	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  00355	89 85 08 ff ff
	ff		 mov	 DWORD PTR _x_fin$18[ebp], eax

; 663  :         uint16_t *src_u_ptr = srcULine;

  0035b	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR _srcULine$[ebp]
  00361	89 8d 04 ff ff
	ff		 mov	 DWORD PTR _src_u_ptr$17[ebp], ecx

; 664  :         uint16_t *src_v_ptr = srcVLine;

  00367	8b 95 14 ff ff
	ff		 mov	 edx, DWORD PTR _srcVLine$[ebp]
  0036d	89 95 00 ff ff
	ff		 mov	 DWORD PTR _src_v_ptr$16[ebp], edx

; 665  :         uint16_t *dst_ptr = dstLine;

  00373	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _dstLine$[ebp]
  00379	89 85 fc fe ff
	ff		 mov	 DWORD PTR _dst_ptr$15[ebp], eax

; 666  :         __m256i y0, y1, y2;
; 667  :         for (int x = crop_left; x < x_fin; x += 32, src_u_ptr += 16, src_v_ptr += 16, dst_ptr += 32) {

  0037f	8b 4d f8	 mov	 ecx, DWORD PTR _crop_left$[ebp]
  00382	89 8d 7c fe ff
	ff		 mov	 DWORD PTR _x$11[ebp], ecx
  00388	eb 3c		 jmp	 SHORT $LN13@convert_yv
$LN11@convert_yv:
  0038a	8b 95 7c fe ff
	ff		 mov	 edx, DWORD PTR _x$11[ebp]
  00390	83 c2 20	 add	 edx, 32			; 00000020H
  00393	89 95 7c fe ff
	ff		 mov	 DWORD PTR _x$11[ebp], edx
  00399	8b 85 04 ff ff
	ff		 mov	 eax, DWORD PTR _src_u_ptr$17[ebp]
  0039f	83 c0 20	 add	 eax, 32			; 00000020H
  003a2	89 85 04 ff ff
	ff		 mov	 DWORD PTR _src_u_ptr$17[ebp], eax
  003a8	8b 8d 00 ff ff
	ff		 mov	 ecx, DWORD PTR _src_v_ptr$16[ebp]
  003ae	83 c1 20	 add	 ecx, 32			; 00000020H
  003b1	89 8d 00 ff ff
	ff		 mov	 DWORD PTR _src_v_ptr$16[ebp], ecx
  003b7	8b 95 fc fe ff
	ff		 mov	 edx, DWORD PTR _dst_ptr$15[ebp]
  003bd	83 c2 40	 add	 edx, 64			; 00000040H
  003c0	89 95 fc fe ff
	ff		 mov	 DWORD PTR _dst_ptr$15[ebp], edx
$LN13@convert_yv:
  003c6	8b 85 7c fe ff
	ff		 mov	 eax, DWORD PTR _x$11[ebp]
  003cc	3b 85 08 ff ff
	ff		 cmp	 eax, DWORD PTR _x_fin$18[ebp]
  003d2	0f 8d 57 01 00
	00		 jge	 $LN12@convert_yv

; 668  :             y0 = _mm256_loadu_si256((const __m256i *)src_u_ptr);

  003d8	8b 8d 04 ff ff
	ff		 mov	 ecx, DWORD PTR _src_u_ptr$17[ebp]
  003de	c5 fe 6f 01	 vmovdqu ymm0, YMMWORD PTR [ecx]
  003e2	c5 fe 7f 85 40
	fe ff ff	 vmovdqu YMMWORD PTR $T10[ebp], ymm0
  003ea	c5 fe 6f 85 40
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T10[ebp]
  003f2	c5 fe 7f 85 c0
	fe ff ff	 vmovdqu YMMWORD PTR _y0$14[ebp], ymm0

; 669  :             y1 = _mm256_loadu_si256((const __m256i *)src_v_ptr);

  003fa	8b 95 00 ff ff
	ff		 mov	 edx, DWORD PTR _src_v_ptr$16[ebp]
  00400	c5 fe 6f 02	 vmovdqu ymm0, YMMWORD PTR [edx]
  00404	c5 fe 7f 85 20
	fe ff ff	 vmovdqu YMMWORD PTR $T9[ebp], ymm0
  0040c	c5 fe 6f 85 20
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T9[ebp]
  00414	c5 fe 7f 85 a0
	fe ff ff	 vmovdqu YMMWORD PTR _y1$13[ebp], ymm0

; 670  : 
; 671  :             if (in_bit_depth < 16) {

  0041c	b8 01 00 00 00	 mov	 eax, 1
  00421	85 c0		 test	 eax, eax
  00423	74 4a		 je	 SHORT $LN17@convert_yv

; 672  :                 y0 = _mm256_slli_epi16(y0, 16 - in_bit_depth);

  00425	c5 fe 6f 85 c0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR _y0$14[ebp]
  0042d	c5 fd 71 f0 04	 vpsllw	 ymm0, ymm0, 4
  00432	c5 fe 7f 85 00
	fe ff ff	 vmovdqu YMMWORD PTR $T8[ebp], ymm0
  0043a	c5 fe 6f 85 00
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T8[ebp]
  00442	c5 fe 7f 85 c0
	fe ff ff	 vmovdqu YMMWORD PTR _y0$14[ebp], ymm0

; 673  :                 y1 = _mm256_slli_epi16(y1, 16 - in_bit_depth);

  0044a	c5 fe 6f 85 a0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR _y1$13[ebp]
  00452	c5 fd 71 f0 04	 vpsllw	 ymm0, ymm0, 4
  00457	c5 fe 7f 85 e0
	fd ff ff	 vmovdqu YMMWORD PTR $T7[ebp], ymm0
  0045f	c5 fe 6f 85 e0
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T7[ebp]
  00467	c5 fe 7f 85 a0
	fe ff ff	 vmovdqu YMMWORD PTR _y1$13[ebp], ymm0
$LN17@convert_yv:

; 674  :             }
; 675  : 
; 676  :             y0 = _mm256_permute4x64_epi64(y0, _MM_SHUFFLE(3,1,2,0));

  0046f	c4 e3 fd 00 85
	c0 fe ff ff d8	 vpermq	 ymm0, YMMWORD PTR _y0$14[ebp], 216 ; 000000d8H
  00479	c5 fe 7f 85 c0
	fd ff ff	 vmovdqu YMMWORD PTR $T6[ebp], ymm0
  00481	c5 fe 6f 85 c0
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T6[ebp]
  00489	c5 fe 7f 85 c0
	fe ff ff	 vmovdqu YMMWORD PTR _y0$14[ebp], ymm0

; 677  :             y1 = _mm256_permute4x64_epi64(y1, _MM_SHUFFLE(3,1,2,0));

  00491	c4 e3 fd 00 85
	a0 fe ff ff d8	 vpermq	 ymm0, YMMWORD PTR _y1$13[ebp], 216 ; 000000d8H
  0049b	c5 fe 7f 85 a0
	fd ff ff	 vmovdqu YMMWORD PTR $T5[ebp], ymm0
  004a3	c5 fe 6f 85 a0
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T5[ebp]
  004ab	c5 fe 7f 85 a0
	fe ff ff	 vmovdqu YMMWORD PTR _y1$13[ebp], ymm0

; 678  : 
; 679  :             y2 = _mm256_unpackhi_epi16(y0, y1);

  004b3	c5 fe 6f 85 c0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR _y0$14[ebp]
  004bb	c5 fd 69 85 a0
	fe ff ff	 vpunpckhwd ymm0, ymm0, YMMWORD PTR _y1$13[ebp]
  004c3	c5 fe 7f 85 80
	fd ff ff	 vmovdqu YMMWORD PTR $T4[ebp], ymm0
  004cb	c5 fe 6f 85 80
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T4[ebp]
  004d3	c5 fe 7f 85 80
	fe ff ff	 vmovdqu YMMWORD PTR _y2$12[ebp], ymm0

; 680  :             y0 = _mm256_unpacklo_epi16(y0, y1);

  004db	c5 fe 6f 85 c0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR _y0$14[ebp]
  004e3	c5 fd 61 85 a0
	fe ff ff	 vpunpcklwd ymm0, ymm0, YMMWORD PTR _y1$13[ebp]
  004eb	c5 fe 7f 85 60
	fd ff ff	 vmovdqu YMMWORD PTR $T3[ebp], ymm0
  004f3	c5 fe 6f 85 60
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T3[ebp]
  004fb	c5 fe 7f 85 c0
	fe ff ff	 vmovdqu YMMWORD PTR _y0$14[ebp], ymm0

; 681  : 
; 682  :             _mm256_storeu_si256((__m256i *)(dst_ptr +  0), y0);

  00503	c5 fe 6f 85 c0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR _y0$14[ebp]
  0050b	8b 8d fc fe ff
	ff		 mov	 ecx, DWORD PTR _dst_ptr$15[ebp]
  00511	c5 fe 7f 01	 vmovdqu YMMWORD PTR [ecx], ymm0

; 683  :             _mm256_storeu_si256((__m256i *)(dst_ptr + 16), y2);

  00515	c5 fe 6f 85 80
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR _y2$12[ebp]
  0051d	8b 95 fc fe ff
	ff		 mov	 edx, DWORD PTR _dst_ptr$15[ebp]
  00523	83 c2 20	 add	 edx, 32			; 00000020H
  00526	c5 fe 7f 02	 vmovdqu YMMWORD PTR [edx], ymm0

; 684  :         }

  0052a	e9 5b fe ff ff	 jmp	 $LN11@convert_yv
$LN12@convert_yv:

; 685  :     }

  0052f	e9 be fd ff ff	 jmp	 $LN8@convert_yv
$LN1@convert_yv:

; 686  : }

  00534	52		 push	 edx
  00535	8b cd		 mov	 ecx, ebp
  00537	50		 push	 eax
  00538	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN22@convert_yv
  0053e	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00543	58		 pop	 eax
  00544	5a		 pop	 edx
  00545	5f		 pop	 edi
  00546	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00549	33 cd		 xor	 ecx, ebp
  0054b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00550	8b e5		 mov	 esp, ebp
  00552	5d		 pop	 ebp
  00553	8b e3		 mov	 esp, ebx
  00555	5b		 pop	 ebx
  00556	c3		 ret	 0
  00557	90		 npad	 1
$LN22@convert_yv:
  00558	02 00 00 00	 DD	 2
  0055c	00 00 00 00	 DD	 $LN21@convert_yv
$LN21@convert_yv:
  00560	d4 ff ff ff	 DD	 -44			; ffffffd4H
  00564	0c 00 00 00	 DD	 12			; 0000000cH
  00568	00 00 00 00	 DD	 $LN19@convert_yv
  0056c	30 ff ff ff	 DD	 -208			; ffffff30H
  00570	0c 00 00 00	 DD	 12			; 0000000cH
  00574	00 00 00 00	 DD	 $LN20@convert_yv
$LN20@convert_yv:
  00578	75		 DB	 117			; 00000075H
  00579	76		 DB	 118			; 00000076H
  0057a	5f		 DB	 95			; 0000005fH
  0057b	72		 DB	 114			; 00000072H
  0057c	61		 DB	 97			; 00000061H
  0057d	6e		 DB	 110			; 0000006eH
  0057e	67		 DB	 103			; 00000067H
  0057f	65		 DB	 101			; 00000065H
  00580	00		 DB	 0
$LN19@convert_yv:
  00581	79		 DB	 121			; 00000079H
  00582	5f		 DB	 95			; 0000005fH
  00583	72		 DB	 114			; 00000072H
  00584	61		 DB	 97			; 00000061H
  00585	6e		 DB	 110			; 0000006eH
  00586	67		 DB	 103			; 00000067H
  00587	65		 DB	 101			; 00000065H
  00588	00		 DB	 0
??$convert_yv12_high_to_p010_avx2_base@$0M@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_high_to_p010_avx2_base<12,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yv12_12_to_p010_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_12_to_p010_avx2

; 697  : void convert_yv12_12_to_p010_avx2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 698  :     convert_yv12_high_to_p010_avx2_base<12, false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yv12_high_to_p010_avx2_base@$0M@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_high_to_p010_avx2_base<12,0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 699  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yv12_12_to_p010_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_12_to_p010_avx2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
$T1 = -704						; size = 12
$T2 = -688						; size = 12
$T3 = -672						; size = 32
$T4 = -640						; size = 32
$T5 = -608						; size = 32
$T6 = -576						; size = 32
$T7 = -544						; size = 32
$T8 = -512						; size = 32
$T9 = -480						; size = 32
$T10 = -448						; size = 32
_x$11 = -388						; size = 4
_y2$12 = -384						; size = 32
_y1$13 = -352						; size = 32
_y0$14 = -320						; size = 32
_dst_ptr$15 = -260					; size = 4
_src_v_ptr$16 = -256					; size = 4
_src_u_ptr$17 = -252					; size = 4
_x_fin$18 = -248					; size = 4
_y$19 = -244						; size = 4
_dstLine$ = -240					; size = 4
_srcVLine$ = -236					; size = 4
_srcULine$ = -232					; size = 4
_src_uv_pitch$ = -228					; size = 4
$T20 = -224						; size = 12
_uv_range$ = -208					; size = 12
$T21 = -192						; size = 32
$T22 = -160						; size = 32
_y0$23 = -128						; size = 32
_x$24 = -88						; size = 4
_dst_ptr$25 = -84					; size = 4
_src_ptr$26 = -80					; size = 4
_y$27 = -76						; size = 4
_y_width$28 = -72					; size = 4
_dstLine$29 = -68					; size = 4
_srcYLine$30 = -64					; size = 4
$T31 = -60						; size = 12
_y_range$32 = -44					; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yv12_high_to_p010_avx2_base@$0O@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_high_to_p010_avx2_base<14,0>

; 627  : static void __forceinline convert_yv12_high_to_p010_avx2_base(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec c0 02 00
	00		 sub	 esp, 704		; 000002c0H
  0001c	57		 push	 edi
  0001d	8d bd 40 fd ff
	ff		 lea	 edi, DWORD PTR [ebp-704]
  00023	b9 b0 00 00 00	 mov	 ecx, 176		; 000000b0H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 628  :     static_assert(8 < in_bit_depth && in_bit_depth <= 16, "in_bit_depth must be 9-16.");
; 629  :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 630  :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 631  :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 632  :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 633  :     const int src_y_pitch = src_y_pitch_byte >> 1;

  0007c	8b 53 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  0007f	d1 fa		 sar	 edx, 1
  00081	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 634  :     const int dst_y_pitch = dst_y_pitch_byte >> 1;

  00084	8b 43 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  00087	d1 f8		 sar	 eax, 1
  00089	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 635  :     //Y
; 636  :     if (!uv_only) {

  0008c	b9 01 00 00 00	 mov	 ecx, 1
  00091	85 c9		 test	 ecx, ecx
  00093	0f 84 68 01 00
	00		 je	 $LN14@convert_yv

; 637  :         const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00099	8b 53 2c	 mov	 edx, DWORD PTR _thread_n$[ebx]
  0009c	52		 push	 edx
  0009d	8b 43 28	 mov	 eax, DWORD PTR _thread_id$[ebx]
  000a0	50		 push	 eax
  000a1	8b 4b 20	 mov	 ecx, DWORD PTR _height$[ebx]
  000a4	2b 4d ec	 sub	 ecx, DWORD PTR _crop_bottom$[ebp]
  000a7	51		 push	 ecx
  000a8	8b 55 f4	 mov	 edx, DWORD PTR _crop_up$[ebp]
  000ab	52		 push	 edx
  000ac	8d 85 50 fd ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  000b2	50		 push	 eax
  000b3	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  000b8	83 c4 14	 add	 esp, 20			; 00000014H
  000bb	8b 08		 mov	 ecx, DWORD PTR [eax]
  000bd	89 4d c4	 mov	 DWORD PTR $T31[ebp], ecx
  000c0	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000c3	89 55 c8	 mov	 DWORD PTR $T31[ebp+4], edx
  000c6	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000c9	89 45 cc	 mov	 DWORD PTR $T31[ebp+8], eax
  000cc	8b 4d c4	 mov	 ecx, DWORD PTR $T31[ebp]
  000cf	89 4d d4	 mov	 DWORD PTR _y_range$32[ebp], ecx
  000d2	8b 55 c8	 mov	 edx, DWORD PTR $T31[ebp+4]
  000d5	89 55 d8	 mov	 DWORD PTR _y_range$32[ebp+4], edx
  000d8	8b 45 cc	 mov	 eax, DWORD PTR $T31[ebp+8]
  000db	89 45 dc	 mov	 DWORD PTR _y_range$32[ebp+8], eax

; 638  :         uint16_t *srcYLine = (uint16_t *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000de	b9 04 00 00 00	 mov	 ecx, 4
  000e3	6b d1 00	 imul	 edx, ecx, 0
  000e6	8b 45 e8	 mov	 eax, DWORD PTR _src_y_pitch$[ebp]
  000e9	0f af 45 d4	 imul	 eax, DWORD PTR _y_range$32[ebp]
  000ed	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  000f0	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  000f3	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  000f6	8b 4d f8	 mov	 ecx, DWORD PTR _crop_left$[ebp]
  000f9	8d 14 48	 lea	 edx, DWORD PTR [eax+ecx*2]
  000fc	89 55 c0	 mov	 DWORD PTR _srcYLine$30[ebp], edx

; 639  :         uint16_t *dstLine = (uint16_t *)dst[0] + dst_y_pitch * y_range.start_dst;

  000ff	b8 04 00 00 00	 mov	 eax, 4
  00104	6b c8 00	 imul	 ecx, eax, 0
  00107	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  0010a	0f af 55 d8	 imul	 edx, DWORD PTR _y_range$32[ebp+4]
  0010e	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  00111	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  00114	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  00117	89 55 bc	 mov	 DWORD PTR _dstLine$29[ebp], edx

; 640  :         const int y_width = width - crop_right - crop_left;

  0011a	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  0011d	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  00120	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  00123	89 45 b8	 mov	 DWORD PTR _y_width$28[ebp], eax

; 641  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  00126	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _y$27[ebp], 0
  0012d	eb 21		 jmp	 SHORT $LN4@convert_yv
$LN2@convert_yv:
  0012f	8b 4d b4	 mov	 ecx, DWORD PTR _y$27[ebp]
  00132	83 c1 01	 add	 ecx, 1
  00135	89 4d b4	 mov	 DWORD PTR _y$27[ebp], ecx
  00138	8b 55 e8	 mov	 edx, DWORD PTR _src_y_pitch$[ebp]
  0013b	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$30[ebp]
  0013e	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00141	89 4d c0	 mov	 DWORD PTR _srcYLine$30[ebp], ecx
  00144	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  00147	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$29[ebp]
  0014a	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  0014d	89 4d bc	 mov	 DWORD PTR _dstLine$29[ebp], ecx
$LN4@convert_yv:
  00150	8b 55 b4	 mov	 edx, DWORD PTR _y$27[ebp]
  00153	3b 55 dc	 cmp	 edx, DWORD PTR _y_range$32[ebp+8]
  00156	0f 8d a5 00 00
	00		 jge	 $LN14@convert_yv

; 642  :             if (in_bit_depth == 16) {

  0015c	33 c0		 xor	 eax, eax
  0015e	74 1b		 je	 SHORT $LN15@convert_yv

; 643  :                 avx2_memcpy<true>((uint8_t *)dstLine, (uint8_t *)srcYLine, y_width * (int)sizeof(uint16_t));

  00160	8b 4d b8	 mov	 ecx, DWORD PTR _y_width$28[ebp]
  00163	d1 e1		 shl	 ecx, 1
  00165	51		 push	 ecx
  00166	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$30[ebp]
  00169	52		 push	 edx
  0016a	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$29[ebp]
  0016d	50		 push	 eax
  0016e	e8 00 00 00 00	 call	 ??$avx2_memcpy@$00@@YAXPAEPBEH@Z ; avx2_memcpy<1>
  00173	83 c4 0c	 add	 esp, 12			; 0000000cH

; 644  :             } else {

  00176	e9 81 00 00 00	 jmp	 $LN16@convert_yv
$LN15@convert_yv:

; 645  :                 uint16_t *src_ptr = srcYLine;

  0017b	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$30[ebp]
  0017e	89 4d b0	 mov	 DWORD PTR _src_ptr$26[ebp], ecx

; 646  :                 uint16_t *dst_ptr = dstLine;

  00181	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$29[ebp]
  00184	89 55 ac	 mov	 DWORD PTR _dst_ptr$25[ebp], edx

; 647  :                 for (int x = 0; x < y_width; x += 16, dst_ptr += 16, src_ptr += 16) {

  00187	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR _x$24[ebp], 0
  0018e	eb 1b		 jmp	 SHORT $LN7@convert_yv
$LN5@convert_yv:
  00190	8b 45 a8	 mov	 eax, DWORD PTR _x$24[ebp]
  00193	83 c0 10	 add	 eax, 16			; 00000010H
  00196	89 45 a8	 mov	 DWORD PTR _x$24[ebp], eax
  00199	8b 4d ac	 mov	 ecx, DWORD PTR _dst_ptr$25[ebp]
  0019c	83 c1 20	 add	 ecx, 32			; 00000020H
  0019f	89 4d ac	 mov	 DWORD PTR _dst_ptr$25[ebp], ecx
  001a2	8b 55 b0	 mov	 edx, DWORD PTR _src_ptr$26[ebp]
  001a5	83 c2 20	 add	 edx, 32			; 00000020H
  001a8	89 55 b0	 mov	 DWORD PTR _src_ptr$26[ebp], edx
$LN7@convert_yv:
  001ab	8b 45 a8	 mov	 eax, DWORD PTR _x$24[ebp]
  001ae	3b 45 b8	 cmp	 eax, DWORD PTR _y_width$28[ebp]
  001b1	7d 49		 jge	 SHORT $LN16@convert_yv

; 648  :                     __m256i y0 = _mm256_loadu_si256((const __m256i *)src_ptr);

  001b3	8b 4d b0	 mov	 ecx, DWORD PTR _src_ptr$26[ebp]
  001b6	c5 fe 6f 01	 vmovdqu ymm0, YMMWORD PTR [ecx]
  001ba	c5 fe 7f 85 60
	ff ff ff	 vmovdqu YMMWORD PTR $T22[ebp], ymm0
  001c2	c5 fe 6f 85 60
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T22[ebp]
  001ca	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _y0$23[ebp], ymm0

; 649  :                     y0 = _mm256_slli_epi16(y0, 16 - in_bit_depth);

  001cf	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR _y0$23[ebp]
  001d4	c5 fd 71 f0 02	 vpsllw	 ymm0, ymm0, 2
  001d9	c5 fe 7f 85 40
	ff ff ff	 vmovdqu YMMWORD PTR $T21[ebp], ymm0
  001e1	c5 fe 6f 85 40
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T21[ebp]
  001e9	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _y0$23[ebp], ymm0

; 650  :                     _mm256_storeu_si256((__m256i *)dst_ptr, y0);

  001ee	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR _y0$23[ebp]
  001f3	8b 55 ac	 mov	 edx, DWORD PTR _dst_ptr$25[ebp]
  001f6	c5 fe 7f 02	 vmovdqu YMMWORD PTR [edx], ymm0

; 651  :                 }

  001fa	eb 94		 jmp	 SHORT $LN5@convert_yv
$LN16@convert_yv:

; 652  :             }
; 653  :         }

  001fc	e9 2e ff ff ff	 jmp	 $LN2@convert_yv
$LN14@convert_yv:

; 654  :     }
; 655  :     //UV
; 656  :     const auto uv_range = thread_y_range(crop_up >> 1, (height - crop_bottom) >> 1, thread_id, thread_n);

  00201	8b 43 2c	 mov	 eax, DWORD PTR _thread_n$[ebx]
  00204	50		 push	 eax
  00205	8b 4b 28	 mov	 ecx, DWORD PTR _thread_id$[ebx]
  00208	51		 push	 ecx
  00209	8b 53 20	 mov	 edx, DWORD PTR _height$[ebx]
  0020c	2b 55 ec	 sub	 edx, DWORD PTR _crop_bottom$[ebp]
  0020f	d1 fa		 sar	 edx, 1
  00211	52		 push	 edx
  00212	8b 45 f4	 mov	 eax, DWORD PTR _crop_up$[ebp]
  00215	d1 f8		 sar	 eax, 1
  00217	50		 push	 eax
  00218	8d 8d 40 fd ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  0021e	51		 push	 ecx
  0021f	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00224	83 c4 14	 add	 esp, 20			; 00000014H
  00227	8b 10		 mov	 edx, DWORD PTR [eax]
  00229	89 95 20 ff ff
	ff		 mov	 DWORD PTR $T20[ebp], edx
  0022f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00232	89 8d 24 ff ff
	ff		 mov	 DWORD PTR $T20[ebp+4], ecx
  00238	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0023b	89 95 28 ff ff
	ff		 mov	 DWORD PTR $T20[ebp+8], edx
  00241	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR $T20[ebp]
  00247	89 85 30 ff ff
	ff		 mov	 DWORD PTR _uv_range$[ebp], eax
  0024d	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR $T20[ebp+4]
  00253	89 8d 34 ff ff
	ff		 mov	 DWORD PTR _uv_range$[ebp+4], ecx
  00259	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR $T20[ebp+8]
  0025f	89 95 38 ff ff
	ff		 mov	 DWORD PTR _uv_range$[ebp+8], edx

; 657  :     const int src_uv_pitch = src_uv_pitch_byte >> 1;

  00265	8b 43 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebx]
  00268	d1 f8		 sar	 eax, 1
  0026a	89 85 1c ff ff
	ff		 mov	 DWORD PTR _src_uv_pitch$[ebp], eax

; 658  :     uint16_t *srcULine = (uint16_t *)src[1] + ((src_uv_pitch * uv_range.start_src) + (crop_left >> 1));

  00270	b9 04 00 00 00	 mov	 ecx, 4
  00275	c1 e1 00	 shl	 ecx, 0
  00278	8b 95 1c ff ff
	ff		 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  0027e	0f af 95 30 ff
	ff ff		 imul	 edx, DWORD PTR _uv_range$[ebp]
  00285	8b 45 f8	 mov	 eax, DWORD PTR _crop_left$[ebp]
  00288	d1 f8		 sar	 eax, 1
  0028a	03 d0		 add	 edx, eax
  0028c	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  0028f	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  00292	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  00295	89 95 18 ff ff
	ff		 mov	 DWORD PTR _srcULine$[ebp], edx

; 659  :     uint16_t *srcVLine = (uint16_t *)src[2] + ((src_uv_pitch * uv_range.start_src) + (crop_left >> 1));

  0029b	b8 04 00 00 00	 mov	 eax, 4
  002a0	d1 e0		 shl	 eax, 1
  002a2	8b 8d 1c ff ff
	ff		 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  002a8	0f af 8d 30 ff
	ff ff		 imul	 ecx, DWORD PTR _uv_range$[ebp]
  002af	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  002b2	d1 fa		 sar	 edx, 1
  002b4	03 ca		 add	 ecx, edx
  002b6	8b 53 0c	 mov	 edx, DWORD PTR _src$[ebx]
  002b9	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  002bc	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  002bf	89 8d 14 ff ff
	ff		 mov	 DWORD PTR _srcVLine$[ebp], ecx

; 660  :     uint16_t *dstLine = (uint16_t *)dst[1] + dst_y_pitch * uv_range.start_dst;;

  002c5	ba 04 00 00 00	 mov	 edx, 4
  002ca	c1 e2 00	 shl	 edx, 0
  002cd	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  002d0	0f af 85 34 ff
	ff ff		 imul	 eax, DWORD PTR _uv_range$[ebp+4]
  002d7	8b 4b 08	 mov	 ecx, DWORD PTR _dst$[ebx]
  002da	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  002dd	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  002e0	89 85 10 ff ff
	ff		 mov	 DWORD PTR _dstLine$[ebp], eax

; 661  :     for (int y = 0; y < uv_range.len; y++, srcULine += src_uv_pitch, srcVLine += src_uv_pitch, dstLine += dst_y_pitch) {

  002e6	c7 85 0c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _y$19[ebp], 0
  002f0	eb 4b		 jmp	 SHORT $LN10@convert_yv
$LN8@convert_yv:
  002f2	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR _y$19[ebp]
  002f8	83 c1 01	 add	 ecx, 1
  002fb	89 8d 0c ff ff
	ff		 mov	 DWORD PTR _y$19[ebp], ecx
  00301	8b 95 1c ff ff
	ff		 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  00307	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _srcULine$[ebp]
  0030d	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00310	89 8d 18 ff ff
	ff		 mov	 DWORD PTR _srcULine$[ebp], ecx
  00316	8b 95 1c ff ff
	ff		 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  0031c	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _srcVLine$[ebp]
  00322	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00325	89 8d 14 ff ff
	ff		 mov	 DWORD PTR _srcVLine$[ebp], ecx
  0032b	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  0032e	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _dstLine$[ebp]
  00334	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00337	89 8d 10 ff ff
	ff		 mov	 DWORD PTR _dstLine$[ebp], ecx
$LN10@convert_yv:
  0033d	8b 95 0c ff ff
	ff		 mov	 edx, DWORD PTR _y$19[ebp]
  00343	3b 95 38 ff ff
	ff		 cmp	 edx, DWORD PTR _uv_range$[ebp+8]
  00349	0f 8d e5 01 00
	00		 jge	 $LN1@convert_yv

; 662  :         const int x_fin = width - crop_right;

  0034f	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  00352	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  00355	89 85 08 ff ff
	ff		 mov	 DWORD PTR _x_fin$18[ebp], eax

; 663  :         uint16_t *src_u_ptr = srcULine;

  0035b	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR _srcULine$[ebp]
  00361	89 8d 04 ff ff
	ff		 mov	 DWORD PTR _src_u_ptr$17[ebp], ecx

; 664  :         uint16_t *src_v_ptr = srcVLine;

  00367	8b 95 14 ff ff
	ff		 mov	 edx, DWORD PTR _srcVLine$[ebp]
  0036d	89 95 00 ff ff
	ff		 mov	 DWORD PTR _src_v_ptr$16[ebp], edx

; 665  :         uint16_t *dst_ptr = dstLine;

  00373	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _dstLine$[ebp]
  00379	89 85 fc fe ff
	ff		 mov	 DWORD PTR _dst_ptr$15[ebp], eax

; 666  :         __m256i y0, y1, y2;
; 667  :         for (int x = crop_left; x < x_fin; x += 32, src_u_ptr += 16, src_v_ptr += 16, dst_ptr += 32) {

  0037f	8b 4d f8	 mov	 ecx, DWORD PTR _crop_left$[ebp]
  00382	89 8d 7c fe ff
	ff		 mov	 DWORD PTR _x$11[ebp], ecx
  00388	eb 3c		 jmp	 SHORT $LN13@convert_yv
$LN11@convert_yv:
  0038a	8b 95 7c fe ff
	ff		 mov	 edx, DWORD PTR _x$11[ebp]
  00390	83 c2 20	 add	 edx, 32			; 00000020H
  00393	89 95 7c fe ff
	ff		 mov	 DWORD PTR _x$11[ebp], edx
  00399	8b 85 04 ff ff
	ff		 mov	 eax, DWORD PTR _src_u_ptr$17[ebp]
  0039f	83 c0 20	 add	 eax, 32			; 00000020H
  003a2	89 85 04 ff ff
	ff		 mov	 DWORD PTR _src_u_ptr$17[ebp], eax
  003a8	8b 8d 00 ff ff
	ff		 mov	 ecx, DWORD PTR _src_v_ptr$16[ebp]
  003ae	83 c1 20	 add	 ecx, 32			; 00000020H
  003b1	89 8d 00 ff ff
	ff		 mov	 DWORD PTR _src_v_ptr$16[ebp], ecx
  003b7	8b 95 fc fe ff
	ff		 mov	 edx, DWORD PTR _dst_ptr$15[ebp]
  003bd	83 c2 40	 add	 edx, 64			; 00000040H
  003c0	89 95 fc fe ff
	ff		 mov	 DWORD PTR _dst_ptr$15[ebp], edx
$LN13@convert_yv:
  003c6	8b 85 7c fe ff
	ff		 mov	 eax, DWORD PTR _x$11[ebp]
  003cc	3b 85 08 ff ff
	ff		 cmp	 eax, DWORD PTR _x_fin$18[ebp]
  003d2	0f 8d 57 01 00
	00		 jge	 $LN12@convert_yv

; 668  :             y0 = _mm256_loadu_si256((const __m256i *)src_u_ptr);

  003d8	8b 8d 04 ff ff
	ff		 mov	 ecx, DWORD PTR _src_u_ptr$17[ebp]
  003de	c5 fe 6f 01	 vmovdqu ymm0, YMMWORD PTR [ecx]
  003e2	c5 fe 7f 85 40
	fe ff ff	 vmovdqu YMMWORD PTR $T10[ebp], ymm0
  003ea	c5 fe 6f 85 40
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T10[ebp]
  003f2	c5 fe 7f 85 c0
	fe ff ff	 vmovdqu YMMWORD PTR _y0$14[ebp], ymm0

; 669  :             y1 = _mm256_loadu_si256((const __m256i *)src_v_ptr);

  003fa	8b 95 00 ff ff
	ff		 mov	 edx, DWORD PTR _src_v_ptr$16[ebp]
  00400	c5 fe 6f 02	 vmovdqu ymm0, YMMWORD PTR [edx]
  00404	c5 fe 7f 85 20
	fe ff ff	 vmovdqu YMMWORD PTR $T9[ebp], ymm0
  0040c	c5 fe 6f 85 20
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T9[ebp]
  00414	c5 fe 7f 85 a0
	fe ff ff	 vmovdqu YMMWORD PTR _y1$13[ebp], ymm0

; 670  : 
; 671  :             if (in_bit_depth < 16) {

  0041c	b8 01 00 00 00	 mov	 eax, 1
  00421	85 c0		 test	 eax, eax
  00423	74 4a		 je	 SHORT $LN17@convert_yv

; 672  :                 y0 = _mm256_slli_epi16(y0, 16 - in_bit_depth);

  00425	c5 fe 6f 85 c0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR _y0$14[ebp]
  0042d	c5 fd 71 f0 02	 vpsllw	 ymm0, ymm0, 2
  00432	c5 fe 7f 85 00
	fe ff ff	 vmovdqu YMMWORD PTR $T8[ebp], ymm0
  0043a	c5 fe 6f 85 00
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T8[ebp]
  00442	c5 fe 7f 85 c0
	fe ff ff	 vmovdqu YMMWORD PTR _y0$14[ebp], ymm0

; 673  :                 y1 = _mm256_slli_epi16(y1, 16 - in_bit_depth);

  0044a	c5 fe 6f 85 a0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR _y1$13[ebp]
  00452	c5 fd 71 f0 02	 vpsllw	 ymm0, ymm0, 2
  00457	c5 fe 7f 85 e0
	fd ff ff	 vmovdqu YMMWORD PTR $T7[ebp], ymm0
  0045f	c5 fe 6f 85 e0
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T7[ebp]
  00467	c5 fe 7f 85 a0
	fe ff ff	 vmovdqu YMMWORD PTR _y1$13[ebp], ymm0
$LN17@convert_yv:

; 674  :             }
; 675  : 
; 676  :             y0 = _mm256_permute4x64_epi64(y0, _MM_SHUFFLE(3,1,2,0));

  0046f	c4 e3 fd 00 85
	c0 fe ff ff d8	 vpermq	 ymm0, YMMWORD PTR _y0$14[ebp], 216 ; 000000d8H
  00479	c5 fe 7f 85 c0
	fd ff ff	 vmovdqu YMMWORD PTR $T6[ebp], ymm0
  00481	c5 fe 6f 85 c0
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T6[ebp]
  00489	c5 fe 7f 85 c0
	fe ff ff	 vmovdqu YMMWORD PTR _y0$14[ebp], ymm0

; 677  :             y1 = _mm256_permute4x64_epi64(y1, _MM_SHUFFLE(3,1,2,0));

  00491	c4 e3 fd 00 85
	a0 fe ff ff d8	 vpermq	 ymm0, YMMWORD PTR _y1$13[ebp], 216 ; 000000d8H
  0049b	c5 fe 7f 85 a0
	fd ff ff	 vmovdqu YMMWORD PTR $T5[ebp], ymm0
  004a3	c5 fe 6f 85 a0
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T5[ebp]
  004ab	c5 fe 7f 85 a0
	fe ff ff	 vmovdqu YMMWORD PTR _y1$13[ebp], ymm0

; 678  : 
; 679  :             y2 = _mm256_unpackhi_epi16(y0, y1);

  004b3	c5 fe 6f 85 c0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR _y0$14[ebp]
  004bb	c5 fd 69 85 a0
	fe ff ff	 vpunpckhwd ymm0, ymm0, YMMWORD PTR _y1$13[ebp]
  004c3	c5 fe 7f 85 80
	fd ff ff	 vmovdqu YMMWORD PTR $T4[ebp], ymm0
  004cb	c5 fe 6f 85 80
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T4[ebp]
  004d3	c5 fe 7f 85 80
	fe ff ff	 vmovdqu YMMWORD PTR _y2$12[ebp], ymm0

; 680  :             y0 = _mm256_unpacklo_epi16(y0, y1);

  004db	c5 fe 6f 85 c0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR _y0$14[ebp]
  004e3	c5 fd 61 85 a0
	fe ff ff	 vpunpcklwd ymm0, ymm0, YMMWORD PTR _y1$13[ebp]
  004eb	c5 fe 7f 85 60
	fd ff ff	 vmovdqu YMMWORD PTR $T3[ebp], ymm0
  004f3	c5 fe 6f 85 60
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T3[ebp]
  004fb	c5 fe 7f 85 c0
	fe ff ff	 vmovdqu YMMWORD PTR _y0$14[ebp], ymm0

; 681  : 
; 682  :             _mm256_storeu_si256((__m256i *)(dst_ptr +  0), y0);

  00503	c5 fe 6f 85 c0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR _y0$14[ebp]
  0050b	8b 8d fc fe ff
	ff		 mov	 ecx, DWORD PTR _dst_ptr$15[ebp]
  00511	c5 fe 7f 01	 vmovdqu YMMWORD PTR [ecx], ymm0

; 683  :             _mm256_storeu_si256((__m256i *)(dst_ptr + 16), y2);

  00515	c5 fe 6f 85 80
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR _y2$12[ebp]
  0051d	8b 95 fc fe ff
	ff		 mov	 edx, DWORD PTR _dst_ptr$15[ebp]
  00523	83 c2 20	 add	 edx, 32			; 00000020H
  00526	c5 fe 7f 02	 vmovdqu YMMWORD PTR [edx], ymm0

; 684  :         }

  0052a	e9 5b fe ff ff	 jmp	 $LN11@convert_yv
$LN12@convert_yv:

; 685  :     }

  0052f	e9 be fd ff ff	 jmp	 $LN8@convert_yv
$LN1@convert_yv:

; 686  : }

  00534	52		 push	 edx
  00535	8b cd		 mov	 ecx, ebp
  00537	50		 push	 eax
  00538	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN22@convert_yv
  0053e	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00543	58		 pop	 eax
  00544	5a		 pop	 edx
  00545	5f		 pop	 edi
  00546	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00549	33 cd		 xor	 ecx, ebp
  0054b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00550	8b e5		 mov	 esp, ebp
  00552	5d		 pop	 ebp
  00553	8b e3		 mov	 esp, ebx
  00555	5b		 pop	 ebx
  00556	c3		 ret	 0
  00557	90		 npad	 1
$LN22@convert_yv:
  00558	02 00 00 00	 DD	 2
  0055c	00 00 00 00	 DD	 $LN21@convert_yv
$LN21@convert_yv:
  00560	d4 ff ff ff	 DD	 -44			; ffffffd4H
  00564	0c 00 00 00	 DD	 12			; 0000000cH
  00568	00 00 00 00	 DD	 $LN19@convert_yv
  0056c	30 ff ff ff	 DD	 -208			; ffffff30H
  00570	0c 00 00 00	 DD	 12			; 0000000cH
  00574	00 00 00 00	 DD	 $LN20@convert_yv
$LN20@convert_yv:
  00578	75		 DB	 117			; 00000075H
  00579	76		 DB	 118			; 00000076H
  0057a	5f		 DB	 95			; 0000005fH
  0057b	72		 DB	 114			; 00000072H
  0057c	61		 DB	 97			; 00000061H
  0057d	6e		 DB	 110			; 0000006eH
  0057e	67		 DB	 103			; 00000067H
  0057f	65		 DB	 101			; 00000065H
  00580	00		 DB	 0
$LN19@convert_yv:
  00581	79		 DB	 121			; 00000079H
  00582	5f		 DB	 95			; 0000005fH
  00583	72		 DB	 114			; 00000072H
  00584	61		 DB	 97			; 00000061H
  00585	6e		 DB	 110			; 0000006eH
  00586	67		 DB	 103			; 00000067H
  00587	65		 DB	 101			; 00000065H
  00588	00		 DB	 0
??$convert_yv12_high_to_p010_avx2_base@$0O@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_high_to_p010_avx2_base<14,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yv12_14_to_p010_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_14_to_p010_avx2

; 693  : void convert_yv12_14_to_p010_avx2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 694  :     convert_yv12_high_to_p010_avx2_base<14, false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yv12_high_to_p010_avx2_base@$0O@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_high_to_p010_avx2_base<14,0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 695  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yv12_14_to_p010_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_14_to_p010_avx2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
$T1 = -704						; size = 12
$T2 = -688						; size = 12
$T3 = -672						; size = 32
$T4 = -640						; size = 32
$T5 = -608						; size = 32
$T6 = -576						; size = 32
$T7 = -544						; size = 32
$T8 = -512						; size = 32
$T9 = -480						; size = 32
$T10 = -448						; size = 32
_x$11 = -388						; size = 4
_y2$12 = -384						; size = 32
_y1$13 = -352						; size = 32
_y0$14 = -320						; size = 32
_dst_ptr$15 = -260					; size = 4
_src_v_ptr$16 = -256					; size = 4
_src_u_ptr$17 = -252					; size = 4
_x_fin$18 = -248					; size = 4
_y$19 = -244						; size = 4
_dstLine$ = -240					; size = 4
_srcVLine$ = -236					; size = 4
_srcULine$ = -232					; size = 4
_src_uv_pitch$ = -228					; size = 4
$T20 = -224						; size = 12
_uv_range$ = -208					; size = 12
$T21 = -192						; size = 32
$T22 = -160						; size = 32
_y0$23 = -128						; size = 32
_x$24 = -88						; size = 4
_dst_ptr$25 = -84					; size = 4
_src_ptr$26 = -80					; size = 4
_y$27 = -76						; size = 4
_y_width$28 = -72					; size = 4
_dstLine$29 = -68					; size = 4
_srcYLine$30 = -64					; size = 4
$T31 = -60						; size = 12
_y_range$32 = -44					; size = 12
_dst_y_pitch$ = -28					; size = 4
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yv12_high_to_p010_avx2_base@$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_high_to_p010_avx2_base<16,0>

; 627  : static void __forceinline convert_yv12_high_to_p010_avx2_base(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec c0 02 00
	00		 sub	 esp, 704		; 000002c0H
  0001c	57		 push	 edi
  0001d	8d bd 40 fd ff
	ff		 lea	 edi, DWORD PTR [ebp-704]
  00023	b9 b0 00 00 00	 mov	 ecx, 176		; 000000b0H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 628  :     static_assert(8 < in_bit_depth && in_bit_depth <= 16, "in_bit_depth must be 9-16.");
; 629  :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 630  :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 631  :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 632  :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 633  :     const int src_y_pitch = src_y_pitch_byte >> 1;

  0007c	8b 53 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  0007f	d1 fa		 sar	 edx, 1
  00081	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 634  :     const int dst_y_pitch = dst_y_pitch_byte >> 1;

  00084	8b 43 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  00087	d1 f8		 sar	 eax, 1
  00089	89 45 e4	 mov	 DWORD PTR _dst_y_pitch$[ebp], eax

; 635  :     //Y
; 636  :     if (!uv_only) {

  0008c	b9 01 00 00 00	 mov	 ecx, 1
  00091	85 c9		 test	 ecx, ecx
  00093	0f 84 6d 01 00
	00		 je	 $LN14@convert_yv

; 637  :         const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00099	8b 53 2c	 mov	 edx, DWORD PTR _thread_n$[ebx]
  0009c	52		 push	 edx
  0009d	8b 43 28	 mov	 eax, DWORD PTR _thread_id$[ebx]
  000a0	50		 push	 eax
  000a1	8b 4b 20	 mov	 ecx, DWORD PTR _height$[ebx]
  000a4	2b 4d ec	 sub	 ecx, DWORD PTR _crop_bottom$[ebp]
  000a7	51		 push	 ecx
  000a8	8b 55 f4	 mov	 edx, DWORD PTR _crop_up$[ebp]
  000ab	52		 push	 edx
  000ac	8d 85 50 fd ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  000b2	50		 push	 eax
  000b3	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  000b8	83 c4 14	 add	 esp, 20			; 00000014H
  000bb	8b 08		 mov	 ecx, DWORD PTR [eax]
  000bd	89 4d c4	 mov	 DWORD PTR $T31[ebp], ecx
  000c0	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000c3	89 55 c8	 mov	 DWORD PTR $T31[ebp+4], edx
  000c6	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000c9	89 45 cc	 mov	 DWORD PTR $T31[ebp+8], eax
  000cc	8b 4d c4	 mov	 ecx, DWORD PTR $T31[ebp]
  000cf	89 4d d4	 mov	 DWORD PTR _y_range$32[ebp], ecx
  000d2	8b 55 c8	 mov	 edx, DWORD PTR $T31[ebp+4]
  000d5	89 55 d8	 mov	 DWORD PTR _y_range$32[ebp+4], edx
  000d8	8b 45 cc	 mov	 eax, DWORD PTR $T31[ebp+8]
  000db	89 45 dc	 mov	 DWORD PTR _y_range$32[ebp+8], eax

; 638  :         uint16_t *srcYLine = (uint16_t *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000de	b9 04 00 00 00	 mov	 ecx, 4
  000e3	6b d1 00	 imul	 edx, ecx, 0
  000e6	8b 45 e8	 mov	 eax, DWORD PTR _src_y_pitch$[ebp]
  000e9	0f af 45 d4	 imul	 eax, DWORD PTR _y_range$32[ebp]
  000ed	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  000f0	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  000f3	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  000f6	8b 4d f8	 mov	 ecx, DWORD PTR _crop_left$[ebp]
  000f9	8d 14 48	 lea	 edx, DWORD PTR [eax+ecx*2]
  000fc	89 55 c0	 mov	 DWORD PTR _srcYLine$30[ebp], edx

; 639  :         uint16_t *dstLine = (uint16_t *)dst[0] + dst_y_pitch * y_range.start_dst;

  000ff	b8 04 00 00 00	 mov	 eax, 4
  00104	6b c8 00	 imul	 ecx, eax, 0
  00107	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  0010a	0f af 55 d8	 imul	 edx, DWORD PTR _y_range$32[ebp+4]
  0010e	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  00111	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  00114	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  00117	89 55 bc	 mov	 DWORD PTR _dstLine$29[ebp], edx

; 640  :         const int y_width = width - crop_right - crop_left;

  0011a	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  0011d	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  00120	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  00123	89 45 b8	 mov	 DWORD PTR _y_width$28[ebp], eax

; 641  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch) {

  00126	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _y$27[ebp], 0
  0012d	eb 21		 jmp	 SHORT $LN4@convert_yv
$LN2@convert_yv:
  0012f	8b 4d b4	 mov	 ecx, DWORD PTR _y$27[ebp]
  00132	83 c1 01	 add	 ecx, 1
  00135	89 4d b4	 mov	 DWORD PTR _y$27[ebp], ecx
  00138	8b 55 e8	 mov	 edx, DWORD PTR _src_y_pitch$[ebp]
  0013b	8b 45 c0	 mov	 eax, DWORD PTR _srcYLine$30[ebp]
  0013e	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00141	89 4d c0	 mov	 DWORD PTR _srcYLine$30[ebp], ecx
  00144	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  00147	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$29[ebp]
  0014a	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  0014d	89 4d bc	 mov	 DWORD PTR _dstLine$29[ebp], ecx
$LN4@convert_yv:
  00150	8b 55 b4	 mov	 edx, DWORD PTR _y$27[ebp]
  00153	3b 55 dc	 cmp	 edx, DWORD PTR _y_range$32[ebp+8]
  00156	0f 8d aa 00 00
	00		 jge	 $LN14@convert_yv

; 642  :             if (in_bit_depth == 16) {

  0015c	b8 01 00 00 00	 mov	 eax, 1
  00161	85 c0		 test	 eax, eax
  00163	74 1b		 je	 SHORT $LN15@convert_yv

; 643  :                 avx2_memcpy<true>((uint8_t *)dstLine, (uint8_t *)srcYLine, y_width * (int)sizeof(uint16_t));

  00165	8b 4d b8	 mov	 ecx, DWORD PTR _y_width$28[ebp]
  00168	d1 e1		 shl	 ecx, 1
  0016a	51		 push	 ecx
  0016b	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$30[ebp]
  0016e	52		 push	 edx
  0016f	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$29[ebp]
  00172	50		 push	 eax
  00173	e8 00 00 00 00	 call	 ??$avx2_memcpy@$00@@YAXPAEPBEH@Z ; avx2_memcpy<1>
  00178	83 c4 0c	 add	 esp, 12			; 0000000cH

; 644  :             } else {

  0017b	e9 81 00 00 00	 jmp	 $LN16@convert_yv
$LN15@convert_yv:

; 645  :                 uint16_t *src_ptr = srcYLine;

  00180	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$30[ebp]
  00183	89 4d b0	 mov	 DWORD PTR _src_ptr$26[ebp], ecx

; 646  :                 uint16_t *dst_ptr = dstLine;

  00186	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$29[ebp]
  00189	89 55 ac	 mov	 DWORD PTR _dst_ptr$25[ebp], edx

; 647  :                 for (int x = 0; x < y_width; x += 16, dst_ptr += 16, src_ptr += 16) {

  0018c	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR _x$24[ebp], 0
  00193	eb 1b		 jmp	 SHORT $LN7@convert_yv
$LN5@convert_yv:
  00195	8b 45 a8	 mov	 eax, DWORD PTR _x$24[ebp]
  00198	83 c0 10	 add	 eax, 16			; 00000010H
  0019b	89 45 a8	 mov	 DWORD PTR _x$24[ebp], eax
  0019e	8b 4d ac	 mov	 ecx, DWORD PTR _dst_ptr$25[ebp]
  001a1	83 c1 20	 add	 ecx, 32			; 00000020H
  001a4	89 4d ac	 mov	 DWORD PTR _dst_ptr$25[ebp], ecx
  001a7	8b 55 b0	 mov	 edx, DWORD PTR _src_ptr$26[ebp]
  001aa	83 c2 20	 add	 edx, 32			; 00000020H
  001ad	89 55 b0	 mov	 DWORD PTR _src_ptr$26[ebp], edx
$LN7@convert_yv:
  001b0	8b 45 a8	 mov	 eax, DWORD PTR _x$24[ebp]
  001b3	3b 45 b8	 cmp	 eax, DWORD PTR _y_width$28[ebp]
  001b6	7d 49		 jge	 SHORT $LN16@convert_yv

; 648  :                     __m256i y0 = _mm256_loadu_si256((const __m256i *)src_ptr);

  001b8	8b 4d b0	 mov	 ecx, DWORD PTR _src_ptr$26[ebp]
  001bb	c5 fe 6f 01	 vmovdqu ymm0, YMMWORD PTR [ecx]
  001bf	c5 fe 7f 85 60
	ff ff ff	 vmovdqu YMMWORD PTR $T22[ebp], ymm0
  001c7	c5 fe 6f 85 60
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T22[ebp]
  001cf	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _y0$23[ebp], ymm0

; 649  :                     y0 = _mm256_slli_epi16(y0, 16 - in_bit_depth);

  001d4	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR _y0$23[ebp]
  001d9	c5 fd 71 f0 00	 vpsllw	 ymm0, ymm0, 0
  001de	c5 fe 7f 85 40
	ff ff ff	 vmovdqu YMMWORD PTR $T21[ebp], ymm0
  001e6	c5 fe 6f 85 40
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T21[ebp]
  001ee	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _y0$23[ebp], ymm0

; 650  :                     _mm256_storeu_si256((__m256i *)dst_ptr, y0);

  001f3	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR _y0$23[ebp]
  001f8	8b 55 ac	 mov	 edx, DWORD PTR _dst_ptr$25[ebp]
  001fb	c5 fe 7f 02	 vmovdqu YMMWORD PTR [edx], ymm0

; 651  :                 }

  001ff	eb 94		 jmp	 SHORT $LN5@convert_yv
$LN16@convert_yv:

; 652  :             }
; 653  :         }

  00201	e9 29 ff ff ff	 jmp	 $LN2@convert_yv
$LN14@convert_yv:

; 654  :     }
; 655  :     //UV
; 656  :     const auto uv_range = thread_y_range(crop_up >> 1, (height - crop_bottom) >> 1, thread_id, thread_n);

  00206	8b 43 2c	 mov	 eax, DWORD PTR _thread_n$[ebx]
  00209	50		 push	 eax
  0020a	8b 4b 28	 mov	 ecx, DWORD PTR _thread_id$[ebx]
  0020d	51		 push	 ecx
  0020e	8b 53 20	 mov	 edx, DWORD PTR _height$[ebx]
  00211	2b 55 ec	 sub	 edx, DWORD PTR _crop_bottom$[ebp]
  00214	d1 fa		 sar	 edx, 1
  00216	52		 push	 edx
  00217	8b 45 f4	 mov	 eax, DWORD PTR _crop_up$[ebp]
  0021a	d1 f8		 sar	 eax, 1
  0021c	50		 push	 eax
  0021d	8d 8d 40 fd ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  00223	51		 push	 ecx
  00224	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00229	83 c4 14	 add	 esp, 20			; 00000014H
  0022c	8b 10		 mov	 edx, DWORD PTR [eax]
  0022e	89 95 20 ff ff
	ff		 mov	 DWORD PTR $T20[ebp], edx
  00234	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00237	89 8d 24 ff ff
	ff		 mov	 DWORD PTR $T20[ebp+4], ecx
  0023d	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00240	89 95 28 ff ff
	ff		 mov	 DWORD PTR $T20[ebp+8], edx
  00246	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR $T20[ebp]
  0024c	89 85 30 ff ff
	ff		 mov	 DWORD PTR _uv_range$[ebp], eax
  00252	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR $T20[ebp+4]
  00258	89 8d 34 ff ff
	ff		 mov	 DWORD PTR _uv_range$[ebp+4], ecx
  0025e	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR $T20[ebp+8]
  00264	89 95 38 ff ff
	ff		 mov	 DWORD PTR _uv_range$[ebp+8], edx

; 657  :     const int src_uv_pitch = src_uv_pitch_byte >> 1;

  0026a	8b 43 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebx]
  0026d	d1 f8		 sar	 eax, 1
  0026f	89 85 1c ff ff
	ff		 mov	 DWORD PTR _src_uv_pitch$[ebp], eax

; 658  :     uint16_t *srcULine = (uint16_t *)src[1] + ((src_uv_pitch * uv_range.start_src) + (crop_left >> 1));

  00275	b9 04 00 00 00	 mov	 ecx, 4
  0027a	c1 e1 00	 shl	 ecx, 0
  0027d	8b 95 1c ff ff
	ff		 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  00283	0f af 95 30 ff
	ff ff		 imul	 edx, DWORD PTR _uv_range$[ebp]
  0028a	8b 45 f8	 mov	 eax, DWORD PTR _crop_left$[ebp]
  0028d	d1 f8		 sar	 eax, 1
  0028f	03 d0		 add	 edx, eax
  00291	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  00294	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  00297	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  0029a	89 95 18 ff ff
	ff		 mov	 DWORD PTR _srcULine$[ebp], edx

; 659  :     uint16_t *srcVLine = (uint16_t *)src[2] + ((src_uv_pitch * uv_range.start_src) + (crop_left >> 1));

  002a0	b8 04 00 00 00	 mov	 eax, 4
  002a5	d1 e0		 shl	 eax, 1
  002a7	8b 8d 1c ff ff
	ff		 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  002ad	0f af 8d 30 ff
	ff ff		 imul	 ecx, DWORD PTR _uv_range$[ebp]
  002b4	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  002b7	d1 fa		 sar	 edx, 1
  002b9	03 ca		 add	 ecx, edx
  002bb	8b 53 0c	 mov	 edx, DWORD PTR _src$[ebx]
  002be	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  002c1	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  002c4	89 8d 14 ff ff
	ff		 mov	 DWORD PTR _srcVLine$[ebp], ecx

; 660  :     uint16_t *dstLine = (uint16_t *)dst[1] + dst_y_pitch * uv_range.start_dst;;

  002ca	ba 04 00 00 00	 mov	 edx, 4
  002cf	c1 e2 00	 shl	 edx, 0
  002d2	8b 45 e4	 mov	 eax, DWORD PTR _dst_y_pitch$[ebp]
  002d5	0f af 85 34 ff
	ff ff		 imul	 eax, DWORD PTR _uv_range$[ebp+4]
  002dc	8b 4b 08	 mov	 ecx, DWORD PTR _dst$[ebx]
  002df	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  002e2	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  002e5	89 85 10 ff ff
	ff		 mov	 DWORD PTR _dstLine$[ebp], eax

; 661  :     for (int y = 0; y < uv_range.len; y++, srcULine += src_uv_pitch, srcVLine += src_uv_pitch, dstLine += dst_y_pitch) {

  002eb	c7 85 0c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _y$19[ebp], 0
  002f5	eb 4b		 jmp	 SHORT $LN10@convert_yv
$LN8@convert_yv:
  002f7	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR _y$19[ebp]
  002fd	83 c1 01	 add	 ecx, 1
  00300	89 8d 0c ff ff
	ff		 mov	 DWORD PTR _y$19[ebp], ecx
  00306	8b 95 1c ff ff
	ff		 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  0030c	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _srcULine$[ebp]
  00312	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00315	89 8d 18 ff ff
	ff		 mov	 DWORD PTR _srcULine$[ebp], ecx
  0031b	8b 95 1c ff ff
	ff		 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  00321	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _srcVLine$[ebp]
  00327	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  0032a	89 8d 14 ff ff
	ff		 mov	 DWORD PTR _srcVLine$[ebp], ecx
  00330	8b 55 e4	 mov	 edx, DWORD PTR _dst_y_pitch$[ebp]
  00333	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _dstLine$[ebp]
  00339	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  0033c	89 8d 10 ff ff
	ff		 mov	 DWORD PTR _dstLine$[ebp], ecx
$LN10@convert_yv:
  00342	8b 95 0c ff ff
	ff		 mov	 edx, DWORD PTR _y$19[ebp]
  00348	3b 95 38 ff ff
	ff		 cmp	 edx, DWORD PTR _uv_range$[ebp+8]
  0034e	0f 8d e0 01 00
	00		 jge	 $LN1@convert_yv

; 662  :         const int x_fin = width - crop_right;

  00354	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  00357	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  0035a	89 85 08 ff ff
	ff		 mov	 DWORD PTR _x_fin$18[ebp], eax

; 663  :         uint16_t *src_u_ptr = srcULine;

  00360	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR _srcULine$[ebp]
  00366	89 8d 04 ff ff
	ff		 mov	 DWORD PTR _src_u_ptr$17[ebp], ecx

; 664  :         uint16_t *src_v_ptr = srcVLine;

  0036c	8b 95 14 ff ff
	ff		 mov	 edx, DWORD PTR _srcVLine$[ebp]
  00372	89 95 00 ff ff
	ff		 mov	 DWORD PTR _src_v_ptr$16[ebp], edx

; 665  :         uint16_t *dst_ptr = dstLine;

  00378	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _dstLine$[ebp]
  0037e	89 85 fc fe ff
	ff		 mov	 DWORD PTR _dst_ptr$15[ebp], eax

; 666  :         __m256i y0, y1, y2;
; 667  :         for (int x = crop_left; x < x_fin; x += 32, src_u_ptr += 16, src_v_ptr += 16, dst_ptr += 32) {

  00384	8b 4d f8	 mov	 ecx, DWORD PTR _crop_left$[ebp]
  00387	89 8d 7c fe ff
	ff		 mov	 DWORD PTR _x$11[ebp], ecx
  0038d	eb 3c		 jmp	 SHORT $LN13@convert_yv
$LN11@convert_yv:
  0038f	8b 95 7c fe ff
	ff		 mov	 edx, DWORD PTR _x$11[ebp]
  00395	83 c2 20	 add	 edx, 32			; 00000020H
  00398	89 95 7c fe ff
	ff		 mov	 DWORD PTR _x$11[ebp], edx
  0039e	8b 85 04 ff ff
	ff		 mov	 eax, DWORD PTR _src_u_ptr$17[ebp]
  003a4	83 c0 20	 add	 eax, 32			; 00000020H
  003a7	89 85 04 ff ff
	ff		 mov	 DWORD PTR _src_u_ptr$17[ebp], eax
  003ad	8b 8d 00 ff ff
	ff		 mov	 ecx, DWORD PTR _src_v_ptr$16[ebp]
  003b3	83 c1 20	 add	 ecx, 32			; 00000020H
  003b6	89 8d 00 ff ff
	ff		 mov	 DWORD PTR _src_v_ptr$16[ebp], ecx
  003bc	8b 95 fc fe ff
	ff		 mov	 edx, DWORD PTR _dst_ptr$15[ebp]
  003c2	83 c2 40	 add	 edx, 64			; 00000040H
  003c5	89 95 fc fe ff
	ff		 mov	 DWORD PTR _dst_ptr$15[ebp], edx
$LN13@convert_yv:
  003cb	8b 85 7c fe ff
	ff		 mov	 eax, DWORD PTR _x$11[ebp]
  003d1	3b 85 08 ff ff
	ff		 cmp	 eax, DWORD PTR _x_fin$18[ebp]
  003d7	0f 8d 52 01 00
	00		 jge	 $LN12@convert_yv

; 668  :             y0 = _mm256_loadu_si256((const __m256i *)src_u_ptr);

  003dd	8b 8d 04 ff ff
	ff		 mov	 ecx, DWORD PTR _src_u_ptr$17[ebp]
  003e3	c5 fe 6f 01	 vmovdqu ymm0, YMMWORD PTR [ecx]
  003e7	c5 fe 7f 85 40
	fe ff ff	 vmovdqu YMMWORD PTR $T10[ebp], ymm0
  003ef	c5 fe 6f 85 40
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T10[ebp]
  003f7	c5 fe 7f 85 c0
	fe ff ff	 vmovdqu YMMWORD PTR _y0$14[ebp], ymm0

; 669  :             y1 = _mm256_loadu_si256((const __m256i *)src_v_ptr);

  003ff	8b 95 00 ff ff
	ff		 mov	 edx, DWORD PTR _src_v_ptr$16[ebp]
  00405	c5 fe 6f 02	 vmovdqu ymm0, YMMWORD PTR [edx]
  00409	c5 fe 7f 85 20
	fe ff ff	 vmovdqu YMMWORD PTR $T9[ebp], ymm0
  00411	c5 fe 6f 85 20
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T9[ebp]
  00419	c5 fe 7f 85 a0
	fe ff ff	 vmovdqu YMMWORD PTR _y1$13[ebp], ymm0

; 670  : 
; 671  :             if (in_bit_depth < 16) {

  00421	33 c0		 xor	 eax, eax
  00423	74 4a		 je	 SHORT $LN17@convert_yv

; 672  :                 y0 = _mm256_slli_epi16(y0, 16 - in_bit_depth);

  00425	c5 fe 6f 85 c0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR _y0$14[ebp]
  0042d	c5 fd 71 f0 00	 vpsllw	 ymm0, ymm0, 0
  00432	c5 fe 7f 85 00
	fe ff ff	 vmovdqu YMMWORD PTR $T8[ebp], ymm0
  0043a	c5 fe 6f 85 00
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T8[ebp]
  00442	c5 fe 7f 85 c0
	fe ff ff	 vmovdqu YMMWORD PTR _y0$14[ebp], ymm0

; 673  :                 y1 = _mm256_slli_epi16(y1, 16 - in_bit_depth);

  0044a	c5 fe 6f 85 a0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR _y1$13[ebp]
  00452	c5 fd 71 f0 00	 vpsllw	 ymm0, ymm0, 0
  00457	c5 fe 7f 85 e0
	fd ff ff	 vmovdqu YMMWORD PTR $T7[ebp], ymm0
  0045f	c5 fe 6f 85 e0
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T7[ebp]
  00467	c5 fe 7f 85 a0
	fe ff ff	 vmovdqu YMMWORD PTR _y1$13[ebp], ymm0
$LN17@convert_yv:

; 674  :             }
; 675  : 
; 676  :             y0 = _mm256_permute4x64_epi64(y0, _MM_SHUFFLE(3,1,2,0));

  0046f	c4 e3 fd 00 85
	c0 fe ff ff d8	 vpermq	 ymm0, YMMWORD PTR _y0$14[ebp], 216 ; 000000d8H
  00479	c5 fe 7f 85 c0
	fd ff ff	 vmovdqu YMMWORD PTR $T6[ebp], ymm0
  00481	c5 fe 6f 85 c0
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T6[ebp]
  00489	c5 fe 7f 85 c0
	fe ff ff	 vmovdqu YMMWORD PTR _y0$14[ebp], ymm0

; 677  :             y1 = _mm256_permute4x64_epi64(y1, _MM_SHUFFLE(3,1,2,0));

  00491	c4 e3 fd 00 85
	a0 fe ff ff d8	 vpermq	 ymm0, YMMWORD PTR _y1$13[ebp], 216 ; 000000d8H
  0049b	c5 fe 7f 85 a0
	fd ff ff	 vmovdqu YMMWORD PTR $T5[ebp], ymm0
  004a3	c5 fe 6f 85 a0
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T5[ebp]
  004ab	c5 fe 7f 85 a0
	fe ff ff	 vmovdqu YMMWORD PTR _y1$13[ebp], ymm0

; 678  : 
; 679  :             y2 = _mm256_unpackhi_epi16(y0, y1);

  004b3	c5 fe 6f 85 c0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR _y0$14[ebp]
  004bb	c5 fd 69 85 a0
	fe ff ff	 vpunpckhwd ymm0, ymm0, YMMWORD PTR _y1$13[ebp]
  004c3	c5 fe 7f 85 80
	fd ff ff	 vmovdqu YMMWORD PTR $T4[ebp], ymm0
  004cb	c5 fe 6f 85 80
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T4[ebp]
  004d3	c5 fe 7f 85 80
	fe ff ff	 vmovdqu YMMWORD PTR _y2$12[ebp], ymm0

; 680  :             y0 = _mm256_unpacklo_epi16(y0, y1);

  004db	c5 fe 6f 85 c0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR _y0$14[ebp]
  004e3	c5 fd 61 85 a0
	fe ff ff	 vpunpcklwd ymm0, ymm0, YMMWORD PTR _y1$13[ebp]
  004eb	c5 fe 7f 85 60
	fd ff ff	 vmovdqu YMMWORD PTR $T3[ebp], ymm0
  004f3	c5 fe 6f 85 60
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T3[ebp]
  004fb	c5 fe 7f 85 c0
	fe ff ff	 vmovdqu YMMWORD PTR _y0$14[ebp], ymm0

; 681  : 
; 682  :             _mm256_storeu_si256((__m256i *)(dst_ptr +  0), y0);

  00503	c5 fe 6f 85 c0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR _y0$14[ebp]
  0050b	8b 8d fc fe ff
	ff		 mov	 ecx, DWORD PTR _dst_ptr$15[ebp]
  00511	c5 fe 7f 01	 vmovdqu YMMWORD PTR [ecx], ymm0

; 683  :             _mm256_storeu_si256((__m256i *)(dst_ptr + 16), y2);

  00515	c5 fe 6f 85 80
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR _y2$12[ebp]
  0051d	8b 95 fc fe ff
	ff		 mov	 edx, DWORD PTR _dst_ptr$15[ebp]
  00523	83 c2 20	 add	 edx, 32			; 00000020H
  00526	c5 fe 7f 02	 vmovdqu YMMWORD PTR [edx], ymm0

; 684  :         }

  0052a	e9 60 fe ff ff	 jmp	 $LN11@convert_yv
$LN12@convert_yv:

; 685  :     }

  0052f	e9 c3 fd ff ff	 jmp	 $LN8@convert_yv
$LN1@convert_yv:

; 686  : }

  00534	52		 push	 edx
  00535	8b cd		 mov	 ecx, ebp
  00537	50		 push	 eax
  00538	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN22@convert_yv
  0053e	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00543	58		 pop	 eax
  00544	5a		 pop	 edx
  00545	5f		 pop	 edi
  00546	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00549	33 cd		 xor	 ecx, ebp
  0054b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00550	8b e5		 mov	 esp, ebp
  00552	5d		 pop	 ebp
  00553	8b e3		 mov	 esp, ebx
  00555	5b		 pop	 ebx
  00556	c3		 ret	 0
  00557	90		 npad	 1
$LN22@convert_yv:
  00558	02 00 00 00	 DD	 2
  0055c	00 00 00 00	 DD	 $LN21@convert_yv
$LN21@convert_yv:
  00560	d4 ff ff ff	 DD	 -44			; ffffffd4H
  00564	0c 00 00 00	 DD	 12			; 0000000cH
  00568	00 00 00 00	 DD	 $LN19@convert_yv
  0056c	30 ff ff ff	 DD	 -208			; ffffff30H
  00570	0c 00 00 00	 DD	 12			; 0000000cH
  00574	00 00 00 00	 DD	 $LN20@convert_yv
$LN20@convert_yv:
  00578	75		 DB	 117			; 00000075H
  00579	76		 DB	 118			; 00000076H
  0057a	5f		 DB	 95			; 0000005fH
  0057b	72		 DB	 114			; 00000072H
  0057c	61		 DB	 97			; 00000061H
  0057d	6e		 DB	 110			; 0000006eH
  0057e	67		 DB	 103			; 00000067H
  0057f	65		 DB	 101			; 00000065H
  00580	00		 DB	 0
$LN19@convert_yv:
  00581	79		 DB	 121			; 00000079H
  00582	5f		 DB	 95			; 0000005fH
  00583	72		 DB	 114			; 00000072H
  00584	61		 DB	 97			; 00000061H
  00585	6e		 DB	 110			; 0000006eH
  00586	67		 DB	 103			; 00000067H
  00587	65		 DB	 101			; 00000065H
  00588	00		 DB	 0
??$convert_yv12_high_to_p010_avx2_base@$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_high_to_p010_avx2_base<16,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yv12_16_to_p010_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_16_to_p010_avx2

; 689  : void convert_yv12_16_to_p010_avx2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 690  :     convert_yv12_high_to_p010_avx2_base<16, false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yv12_high_to_p010_avx2_base@$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_high_to_p010_avx2_base<16,0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 691  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yv12_16_to_p010_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_16_to_p010_avx2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
$T1 = -1056						; size = 12
$T2 = -1040						; size = 12
$T3 = -1024						; size = 32
$T4 = -992						; size = 32
$T5 = -960						; size = 32
$T6 = -928						; size = 32
$T7 = -896						; size = 32
$T8 = -864						; size = 32
_xMaskHighByte$9 = -832					; size = 32
$T10 = -800						; size = 32
$T11 = -768						; size = 32
$T12 = -736						; size = 32
$T13 = -704						; size = 32
_y1$14 = -672						; size = 32
_y0$15 = -640						; size = 32
_dst_ptr_fin$16 = -584					; size = 4
_dst_ptr$17 = -580					; size = 4
_src_v_ptr$18 = -576					; size = 4
_src_u_ptr$19 = -572					; size = 4
_x_fin$20 = -568					; size = 4
_y$21 = -564						; size = 4
_dstLine$ = -560					; size = 4
_srcVLine$ = -556					; size = 4
_srcULine$ = -552					; size = 4
_src_uv_pitch$ = -548					; size = 4
$T22 = -544						; size = 12
_uv_range$ = -528					; size = 12
$T23 = -512						; size = 32
$T24 = -480						; size = 32
$T25 = -448						; size = 32
$T26 = -416						; size = 32
$T27 = -368						; size = 16
$T28 = -352						; size = 32
$T29 = -304						; size = 16
$T30 = -288						; size = 32
$T31 = -240						; size = 16
$T32 = -224						; size = 32
$T33 = -176						; size = 16
_y1$34 = -160						; size = 32
_y0$35 = -128						; size = 32
_src_ptr_fin$36 = -84					; size = 4
_src_ptr$37 = -80					; size = 4
_dst_ptr$38 = -76					; size = 4
_y$39 = -72						; size = 4
_y_width$40 = -68					; size = 4
_dstLine$41 = -64					; size = 4
_srcYLine$42 = -60					; size = 4
$T43 = -56						; size = 12
_y_range$44 = -40					; size = 12
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yv12_high_to_nv12_avx2_base@$08$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_high_to_nv12_avx2_base<9,0>

; 542  : static void convert_yv12_high_to_nv12_avx2_base(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 20 04 00
	00		 sub	 esp, 1056		; 00000420H
  0001c	57		 push	 edi
  0001d	8d bd e0 fb ff
	ff		 lea	 edi, DWORD PTR [ebp-1056]
  00023	b9 08 01 00 00	 mov	 ecx, 264		; 00000108H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 543  :     static_assert(8 < in_bit_depth && in_bit_depth <= 16, "in_bit_depth must be 9-16.");
; 544  :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 545  :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 546  :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 547  :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 548  :     const int src_y_pitch = src_y_pitch_byte >> 1;

  0007c	8b 53 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  0007f	d1 fa		 sar	 edx, 1
  00081	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 549  :     //Y
; 550  :     if (!uv_only) {

  00084	b8 01 00 00 00	 mov	 eax, 1
  00089	85 c0		 test	 eax, eax
  0008b	0f 84 1f 02 00
	00		 je	 $LN14@convert_yv

; 551  :         const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00091	8b 4b 2c	 mov	 ecx, DWORD PTR _thread_n$[ebx]
  00094	51		 push	 ecx
  00095	8b 53 28	 mov	 edx, DWORD PTR _thread_id$[ebx]
  00098	52		 push	 edx
  00099	8b 43 20	 mov	 eax, DWORD PTR _height$[ebx]
  0009c	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  0009f	50		 push	 eax
  000a0	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  000a3	51		 push	 ecx
  000a4	8d 95 f0 fb ff
	ff		 lea	 edx, DWORD PTR $T2[ebp]
  000aa	52		 push	 edx
  000ab	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  000b0	83 c4 14	 add	 esp, 20			; 00000014H
  000b3	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b5	89 4d c8	 mov	 DWORD PTR $T43[ebp], ecx
  000b8	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000bb	89 55 cc	 mov	 DWORD PTR $T43[ebp+4], edx
  000be	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000c1	89 45 d0	 mov	 DWORD PTR $T43[ebp+8], eax
  000c4	8b 4d c8	 mov	 ecx, DWORD PTR $T43[ebp]
  000c7	89 4d d8	 mov	 DWORD PTR _y_range$44[ebp], ecx
  000ca	8b 55 cc	 mov	 edx, DWORD PTR $T43[ebp+4]
  000cd	89 55 dc	 mov	 DWORD PTR _y_range$44[ebp+4], edx
  000d0	8b 45 d0	 mov	 eax, DWORD PTR $T43[ebp+8]
  000d3	89 45 e0	 mov	 DWORD PTR _y_range$44[ebp+8], eax

; 552  :         uint16_t *srcYLine = (uint16_t *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000d6	b9 04 00 00 00	 mov	 ecx, 4
  000db	6b d1 00	 imul	 edx, ecx, 0
  000de	8b 45 e8	 mov	 eax, DWORD PTR _src_y_pitch$[ebp]
  000e1	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$44[ebp]
  000e5	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  000e8	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  000eb	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  000ee	8b 4d f8	 mov	 ecx, DWORD PTR _crop_left$[ebp]
  000f1	8d 14 48	 lea	 edx, DWORD PTR [eax+ecx*2]
  000f4	89 55 c4	 mov	 DWORD PTR _srcYLine$42[ebp], edx

; 553  :         uint8_t *dstLine  = (uint8_t *)dst[0] + dst_y_pitch_byte * y_range.start_dst;;

  000f7	b8 04 00 00 00	 mov	 eax, 4
  000fc	6b c8 00	 imul	 ecx, eax, 0
  000ff	8b 53 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebx]
  00102	0f af 55 dc	 imul	 edx, DWORD PTR _y_range$44[ebp+4]
  00106	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  00109	03 14 08	 add	 edx, DWORD PTR [eax+ecx]
  0010c	89 55 c0	 mov	 DWORD PTR _dstLine$41[ebp], edx

; 554  :         const int y_width = width - crop_right - crop_left;

  0010f	8b 4b 10	 mov	 ecx, DWORD PTR _width$[ebx]
  00112	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  00115	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  00118	89 4d bc	 mov	 DWORD PTR _y_width$40[ebp], ecx

; 555  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch_byte) {

  0011b	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _y$39[ebp], 0
  00122	eb 1e		 jmp	 SHORT $LN4@convert_yv
$LN2@convert_yv:
  00124	8b 55 b8	 mov	 edx, DWORD PTR _y$39[ebp]
  00127	83 c2 01	 add	 edx, 1
  0012a	89 55 b8	 mov	 DWORD PTR _y$39[ebp], edx
  0012d	8b 45 e8	 mov	 eax, DWORD PTR _src_y_pitch$[ebp]
  00130	8b 4d c4	 mov	 ecx, DWORD PTR _srcYLine$42[ebp]
  00133	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00136	89 55 c4	 mov	 DWORD PTR _srcYLine$42[ebp], edx
  00139	8b 45 c0	 mov	 eax, DWORD PTR _dstLine$41[ebp]
  0013c	03 43 1c	 add	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  0013f	89 45 c0	 mov	 DWORD PTR _dstLine$41[ebp], eax
$LN4@convert_yv:
  00142	8b 4d b8	 mov	 ecx, DWORD PTR _y$39[ebp]
  00145	3b 4d e0	 cmp	 ecx, DWORD PTR _y_range$44[ebp+8]
  00148	0f 8d 62 01 00
	00		 jge	 $LN14@convert_yv

; 556  :             uint8_t *dst_ptr = dstLine;

  0014e	8b 55 c0	 mov	 edx, DWORD PTR _dstLine$41[ebp]
  00151	89 55 b4	 mov	 DWORD PTR _dst_ptr$38[ebp], edx

; 557  :             uint16_t *src_ptr = srcYLine;

  00154	8b 45 c4	 mov	 eax, DWORD PTR _srcYLine$42[ebp]
  00157	89 45 b0	 mov	 DWORD PTR _src_ptr$37[ebp], eax

; 558  :             uint16_t *src_ptr_fin = src_ptr + y_width;

  0015a	8b 4d bc	 mov	 ecx, DWORD PTR _y_width$40[ebp]
  0015d	8b 55 b0	 mov	 edx, DWORD PTR _src_ptr$37[ebp]
  00160	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  00163	89 45 ac	 mov	 DWORD PTR _src_ptr_fin$36[ebp], eax

; 559  :             __m256i y0, y1;
; 560  :             for (; src_ptr < src_ptr_fin; dst_ptr += 32, src_ptr += 32) {

  00166	eb 12		 jmp	 SHORT $LN7@convert_yv
$LN5@convert_yv:
  00168	8b 4d b4	 mov	 ecx, DWORD PTR _dst_ptr$38[ebp]
  0016b	83 c1 20	 add	 ecx, 32			; 00000020H
  0016e	89 4d b4	 mov	 DWORD PTR _dst_ptr$38[ebp], ecx
  00171	8b 55 b0	 mov	 edx, DWORD PTR _src_ptr$37[ebp]
  00174	83 c2 40	 add	 edx, 64			; 00000040H
  00177	89 55 b0	 mov	 DWORD PTR _src_ptr$37[ebp], edx
$LN7@convert_yv:
  0017a	8b 45 b0	 mov	 eax, DWORD PTR _src_ptr$37[ebp]
  0017d	3b 45 ac	 cmp	 eax, DWORD PTR _src_ptr_fin$36[ebp]
  00180	0f 83 25 01 00
	00		 jae	 $LN6@convert_yv

; 561  :                 y0 = _mm256_set_m128i(_mm_loadu_si128((__m128i*)(src_ptr + 16)), _mm_loadu_si128((__m128i*)(src_ptr +  0)));

  00186	8b 4d b0	 mov	 ecx, DWORD PTR _src_ptr$37[ebp]
  00189	83 c1 20	 add	 ecx, 32			; 00000020H
  0018c	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  0018f	0f 29 85 10 ff
	ff ff		 movaps	 XMMWORD PTR $T31[ebp], xmm0
  00196	8b 55 b0	 mov	 edx, DWORD PTR _src_ptr$37[ebp]
  00199	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  0019c	0f 29 85 50 ff
	ff ff		 movaps	 XMMWORD PTR $T33[ebp], xmm0
  001a3	c5 fa 6f 85 50
	ff ff ff	 vmovdqu xmm0, XMMWORD PTR $T33[ebp]
  001ab	c5 fe 7f 85 20
	ff ff ff	 vmovdqu YMMWORD PTR $T32[ebp], ymm0
  001b3	c5 fe 6f 85 20
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T32[ebp]
  001bb	c4 e3 7d 18 85
	10 ff ff ff 01	 vinsertf128 ymm0, ymm0, XMMWORD PTR $T31[ebp], 1
  001c5	c5 fe 7f 85 e0
	fe ff ff	 vmovdqu YMMWORD PTR $T30[ebp], ymm0
  001cd	c5 fe 6f 85 e0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T30[ebp]
  001d5	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _y0$35[ebp], ymm0

; 562  :                 y1 = _mm256_set_m128i(_mm_loadu_si128((__m128i*)(src_ptr + 24)), _mm_loadu_si128((__m128i*)(src_ptr +  8)));

  001da	8b 45 b0	 mov	 eax, DWORD PTR _src_ptr$37[ebp]
  001dd	83 c0 30	 add	 eax, 48			; 00000030H
  001e0	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  001e3	0f 29 85 90 fe
	ff ff		 movaps	 XMMWORD PTR $T27[ebp], xmm0
  001ea	8b 4d b0	 mov	 ecx, DWORD PTR _src_ptr$37[ebp]
  001ed	83 c1 10	 add	 ecx, 16			; 00000010H
  001f0	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  001f3	0f 29 85 d0 fe
	ff ff		 movaps	 XMMWORD PTR $T29[ebp], xmm0
  001fa	c5 fa 6f 85 d0
	fe ff ff	 vmovdqu xmm0, XMMWORD PTR $T29[ebp]
  00202	c5 fe 7f 85 a0
	fe ff ff	 vmovdqu YMMWORD PTR $T28[ebp], ymm0
  0020a	c5 fe 6f 85 a0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T28[ebp]
  00212	c4 e3 7d 18 85
	90 fe ff ff 01	 vinsertf128 ymm0, ymm0, XMMWORD PTR $T27[ebp], 1
  0021c	c5 fe 7f 85 60
	fe ff ff	 vmovdqu YMMWORD PTR $T26[ebp], ymm0
  00224	c5 fe 6f 85 60
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T26[ebp]
  0022c	c5 fe 7f 85 60
	ff ff ff	 vmovdqu YMMWORD PTR _y1$34[ebp], ymm0

; 563  : 
; 564  :                 y0 = _mm256_srli_epi16(y0, in_bit_depth - 8);

  00234	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR _y0$35[ebp]
  00239	c5 fd 71 d0 01	 vpsrlw	 ymm0, ymm0, 1
  0023e	c5 fe 7f 85 40
	fe ff ff	 vmovdqu YMMWORD PTR $T25[ebp], ymm0
  00246	c5 fe 6f 85 40
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T25[ebp]
  0024e	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _y0$35[ebp], ymm0

; 565  :                 y1 = _mm256_srli_epi16(y1, in_bit_depth - 8);

  00253	c5 fe 6f 85 60
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR _y1$34[ebp]
  0025b	c5 fd 71 d0 01	 vpsrlw	 ymm0, ymm0, 1
  00260	c5 fe 7f 85 20
	fe ff ff	 vmovdqu YMMWORD PTR $T24[ebp], ymm0
  00268	c5 fe 6f 85 20
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T24[ebp]
  00270	c5 fe 7f 85 60
	ff ff ff	 vmovdqu YMMWORD PTR _y1$34[ebp], ymm0

; 566  : 
; 567  :                 y0 = _mm256_packus_epi16(y0, y1);

  00278	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR _y0$35[ebp]
  0027d	c5 fd 67 85 60
	ff ff ff	 vpackuswb ymm0, ymm0, YMMWORD PTR _y1$34[ebp]
  00285	c5 fe 7f 85 00
	fe ff ff	 vmovdqu YMMWORD PTR $T23[ebp], ymm0
  0028d	c5 fe 6f 85 00
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T23[ebp]
  00295	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _y0$35[ebp], ymm0

; 568  : 
; 569  :                 _mm256_storeu_si256((__m256i *)(dst_ptr + 0), y0);

  0029a	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR _y0$35[ebp]
  0029f	8b 55 b4	 mov	 edx, DWORD PTR _dst_ptr$38[ebp]
  002a2	c5 fe 7f 02	 vmovdqu YMMWORD PTR [edx], ymm0

; 570  :             }

  002a6	e9 bd fe ff ff	 jmp	 $LN5@convert_yv
$LN6@convert_yv:

; 571  :         }

  002ab	e9 74 fe ff ff	 jmp	 $LN2@convert_yv
$LN14@convert_yv:

; 572  :     }
; 573  :     //UV
; 574  :     const auto uv_range = thread_y_range(crop_up >> 1, (height - crop_bottom) >> 1, thread_id, thread_n);

  002b0	8b 43 2c	 mov	 eax, DWORD PTR _thread_n$[ebx]
  002b3	50		 push	 eax
  002b4	8b 4b 28	 mov	 ecx, DWORD PTR _thread_id$[ebx]
  002b7	51		 push	 ecx
  002b8	8b 53 20	 mov	 edx, DWORD PTR _height$[ebx]
  002bb	2b 55 ec	 sub	 edx, DWORD PTR _crop_bottom$[ebp]
  002be	d1 fa		 sar	 edx, 1
  002c0	52		 push	 edx
  002c1	8b 45 f4	 mov	 eax, DWORD PTR _crop_up$[ebp]
  002c4	d1 f8		 sar	 eax, 1
  002c6	50		 push	 eax
  002c7	8d 8d e0 fb ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  002cd	51		 push	 ecx
  002ce	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  002d3	83 c4 14	 add	 esp, 20			; 00000014H
  002d6	8b 10		 mov	 edx, DWORD PTR [eax]
  002d8	89 95 e0 fd ff
	ff		 mov	 DWORD PTR $T22[ebp], edx
  002de	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  002e1	89 8d e4 fd ff
	ff		 mov	 DWORD PTR $T22[ebp+4], ecx
  002e7	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  002ea	89 95 e8 fd ff
	ff		 mov	 DWORD PTR $T22[ebp+8], edx
  002f0	8b 85 e0 fd ff
	ff		 mov	 eax, DWORD PTR $T22[ebp]
  002f6	89 85 f0 fd ff
	ff		 mov	 DWORD PTR _uv_range$[ebp], eax
  002fc	8b 8d e4 fd ff
	ff		 mov	 ecx, DWORD PTR $T22[ebp+4]
  00302	89 8d f4 fd ff
	ff		 mov	 DWORD PTR _uv_range$[ebp+4], ecx
  00308	8b 95 e8 fd ff
	ff		 mov	 edx, DWORD PTR $T22[ebp+8]
  0030e	89 95 f8 fd ff
	ff		 mov	 DWORD PTR _uv_range$[ebp+8], edx

; 575  :     const int src_uv_pitch = src_uv_pitch_byte >> 1;

  00314	8b 43 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebx]
  00317	d1 f8		 sar	 eax, 1
  00319	89 85 dc fd ff
	ff		 mov	 DWORD PTR _src_uv_pitch$[ebp], eax

; 576  :     uint16_t *srcULine = (uint16_t *)src[1] + ((src_uv_pitch * uv_range.start_src) + (crop_left >> 1));

  0031f	b9 04 00 00 00	 mov	 ecx, 4
  00324	c1 e1 00	 shl	 ecx, 0
  00327	8b 95 dc fd ff
	ff		 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  0032d	0f af 95 f0 fd
	ff ff		 imul	 edx, DWORD PTR _uv_range$[ebp]
  00334	8b 45 f8	 mov	 eax, DWORD PTR _crop_left$[ebp]
  00337	d1 f8		 sar	 eax, 1
  00339	03 d0		 add	 edx, eax
  0033b	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  0033e	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  00341	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  00344	89 95 d8 fd ff
	ff		 mov	 DWORD PTR _srcULine$[ebp], edx

; 577  :     uint16_t *srcVLine = (uint16_t *)src[2] + ((src_uv_pitch * uv_range.start_src) + (crop_left >> 1));

  0034a	b8 04 00 00 00	 mov	 eax, 4
  0034f	d1 e0		 shl	 eax, 1
  00351	8b 8d dc fd ff
	ff		 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00357	0f af 8d f0 fd
	ff ff		 imul	 ecx, DWORD PTR _uv_range$[ebp]
  0035e	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  00361	d1 fa		 sar	 edx, 1
  00363	03 ca		 add	 ecx, edx
  00365	8b 53 0c	 mov	 edx, DWORD PTR _src$[ebx]
  00368	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  0036b	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  0036e	89 8d d4 fd ff
	ff		 mov	 DWORD PTR _srcVLine$[ebp], ecx

; 578  :     uint8_t *dstLine  = (uint8_t *)dst[1] + dst_y_pitch_byte * uv_range.start_dst;

  00374	ba 04 00 00 00	 mov	 edx, 4
  00379	c1 e2 00	 shl	 edx, 0
  0037c	8b 43 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  0037f	0f af 85 f4 fd
	ff ff		 imul	 eax, DWORD PTR _uv_range$[ebp+4]
  00386	8b 4b 08	 mov	 ecx, DWORD PTR _dst$[ebx]
  00389	03 04 11	 add	 eax, DWORD PTR [ecx+edx]
  0038c	89 85 d0 fd ff
	ff		 mov	 DWORD PTR _dstLine$[ebp], eax

; 579  :     for (int y = 0; y < uv_range.len; y++, srcULine += src_uv_pitch, srcVLine += src_uv_pitch, dstLine += dst_y_pitch_byte) {

  00392	c7 85 cc fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _y$21[ebp], 0
  0039c	eb 48		 jmp	 SHORT $LN10@convert_yv
$LN8@convert_yv:
  0039e	8b 95 cc fd ff
	ff		 mov	 edx, DWORD PTR _y$21[ebp]
  003a4	83 c2 01	 add	 edx, 1
  003a7	89 95 cc fd ff
	ff		 mov	 DWORD PTR _y$21[ebp], edx
  003ad	8b 85 dc fd ff
	ff		 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  003b3	8b 8d d8 fd ff
	ff		 mov	 ecx, DWORD PTR _srcULine$[ebp]
  003b9	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  003bc	89 95 d8 fd ff
	ff		 mov	 DWORD PTR _srcULine$[ebp], edx
  003c2	8b 85 dc fd ff
	ff		 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  003c8	8b 8d d4 fd ff
	ff		 mov	 ecx, DWORD PTR _srcVLine$[ebp]
  003ce	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  003d1	89 95 d4 fd ff
	ff		 mov	 DWORD PTR _srcVLine$[ebp], edx
  003d7	8b 85 d0 fd ff
	ff		 mov	 eax, DWORD PTR _dstLine$[ebp]
  003dd	03 43 1c	 add	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  003e0	89 85 d0 fd ff
	ff		 mov	 DWORD PTR _dstLine$[ebp], eax
$LN10@convert_yv:
  003e6	8b 8d cc fd ff
	ff		 mov	 ecx, DWORD PTR _y$21[ebp]
  003ec	3b 8d f8 fd ff
	ff		 cmp	 ecx, DWORD PTR _uv_range$[ebp+8]
  003f2	0f 8d d2 01 00
	00		 jge	 $LN1@convert_yv

; 580  :         const int x_fin = width - crop_right;

  003f8	8b 53 10	 mov	 edx, DWORD PTR _width$[ebx]
  003fb	2b 55 f0	 sub	 edx, DWORD PTR _crop_right$[ebp]
  003fe	89 95 c8 fd ff
	ff		 mov	 DWORD PTR _x_fin$20[ebp], edx

; 581  :         uint16_t *src_u_ptr = srcULine;

  00404	8b 85 d8 fd ff
	ff		 mov	 eax, DWORD PTR _srcULine$[ebp]
  0040a	89 85 c4 fd ff
	ff		 mov	 DWORD PTR _src_u_ptr$19[ebp], eax

; 582  :         uint16_t *src_v_ptr = srcVLine;

  00410	8b 8d d4 fd ff
	ff		 mov	 ecx, DWORD PTR _srcVLine$[ebp]
  00416	89 8d c0 fd ff
	ff		 mov	 DWORD PTR _src_v_ptr$18[ebp], ecx

; 583  :         uint8_t *dst_ptr = dstLine;

  0041c	8b 95 d0 fd ff
	ff		 mov	 edx, DWORD PTR _dstLine$[ebp]
  00422	89 95 bc fd ff
	ff		 mov	 DWORD PTR _dst_ptr$17[ebp], edx

; 584  :         uint8_t *dst_ptr_fin = dst_ptr + x_fin;

  00428	8b 85 bc fd ff
	ff		 mov	 eax, DWORD PTR _dst_ptr$17[ebp]
  0042e	03 85 c8 fd ff
	ff		 add	 eax, DWORD PTR _x_fin$20[ebp]
  00434	89 85 b8 fd ff
	ff		 mov	 DWORD PTR _dst_ptr_fin$16[ebp], eax

; 585  :         __m256i y0, y1;
; 586  :         for (; dst_ptr < dst_ptr_fin; src_u_ptr += 16, src_v_ptr += 16, dst_ptr += 32) {

  0043a	eb 2d		 jmp	 SHORT $LN13@convert_yv
$LN11@convert_yv:
  0043c	8b 8d c4 fd ff
	ff		 mov	 ecx, DWORD PTR _src_u_ptr$19[ebp]
  00442	83 c1 20	 add	 ecx, 32			; 00000020H
  00445	89 8d c4 fd ff
	ff		 mov	 DWORD PTR _src_u_ptr$19[ebp], ecx
  0044b	8b 95 c0 fd ff
	ff		 mov	 edx, DWORD PTR _src_v_ptr$18[ebp]
  00451	83 c2 20	 add	 edx, 32			; 00000020H
  00454	89 95 c0 fd ff
	ff		 mov	 DWORD PTR _src_v_ptr$18[ebp], edx
  0045a	8b 85 bc fd ff
	ff		 mov	 eax, DWORD PTR _dst_ptr$17[ebp]
  00460	83 c0 20	 add	 eax, 32			; 00000020H
  00463	89 85 bc fd ff
	ff		 mov	 DWORD PTR _dst_ptr$17[ebp], eax
$LN13@convert_yv:
  00469	8b 8d bc fd ff
	ff		 mov	 ecx, DWORD PTR _dst_ptr$17[ebp]
  0046f	3b 8d b8 fd ff
	ff		 cmp	 ecx, DWORD PTR _dst_ptr_fin$16[ebp]
  00475	0f 83 4a 01 00
	00		 jae	 $LN12@convert_yv

; 587  :             y0 = _mm256_loadu_si256((const __m256i *)src_u_ptr);

  0047b	8b 95 c4 fd ff
	ff		 mov	 edx, DWORD PTR _src_u_ptr$19[ebp]
  00481	c5 fe 6f 02	 vmovdqu ymm0, YMMWORD PTR [edx]
  00485	c5 fe 7f 85 40
	fd ff ff	 vmovdqu YMMWORD PTR $T13[ebp], ymm0
  0048d	c5 fe 6f 85 40
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T13[ebp]
  00495	c5 fe 7f 85 80
	fd ff ff	 vmovdqu YMMWORD PTR _y0$15[ebp], ymm0

; 588  :             y1 = _mm256_loadu_si256((const __m256i *)src_v_ptr);

  0049d	8b 85 c0 fd ff
	ff		 mov	 eax, DWORD PTR _src_v_ptr$18[ebp]
  004a3	c5 fe 6f 00	 vmovdqu ymm0, YMMWORD PTR [eax]
  004a7	c5 fe 7f 85 20
	fd ff ff	 vmovdqu YMMWORD PTR $T12[ebp], ymm0
  004af	c5 fe 6f 85 20
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T12[ebp]
  004b7	c5 fe 7f 85 60
	fd ff ff	 vmovdqu YMMWORD PTR _y1$14[ebp], ymm0

; 589  : 
; 590  :             y0 = _mm256_srli_epi16(y0, in_bit_depth - 8);

  004bf	c5 fe 6f 85 80
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR _y0$15[ebp]
  004c7	c5 fd 71 d0 01	 vpsrlw	 ymm0, ymm0, 1
  004cc	c5 fe 7f 85 00
	fd ff ff	 vmovdqu YMMWORD PTR $T11[ebp], ymm0
  004d4	c5 fe 6f 85 00
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T11[ebp]
  004dc	c5 fe 7f 85 80
	fd ff ff	 vmovdqu YMMWORD PTR _y0$15[ebp], ymm0

; 591  :             y1 = _mm256_slli_epi16(y1, 16 - in_bit_depth);

  004e4	c5 fe 6f 85 60
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR _y1$14[ebp]
  004ec	c5 fd 71 f0 07	 vpsllw	 ymm0, ymm0, 7
  004f1	c5 fe 7f 85 e0
	fc ff ff	 vmovdqu YMMWORD PTR $T10[ebp], ymm0
  004f9	c5 fe 6f 85 e0
	fc ff ff	 vmovdqu ymm0, YMMWORD PTR $T10[ebp]
  00501	c5 fe 7f 85 60
	fd ff ff	 vmovdqu YMMWORD PTR _y1$14[ebp], ymm0

; 592  :             const __m256i xMaskHighByte = _mm256_slli_epi16(_mm256_cmpeq_epi8(_mm256_setzero_si256(), _mm256_setzero_si256()), 8);

  00509	c5 f9 ef c0	 vpxor	 xmm0, xmm0, xmm0
  0050d	c5 fe 7f 85 80
	fc ff ff	 vmovdqu YMMWORD PTR $T7[ebp], ymm0
  00515	c5 f9 ef c0	 vpxor	 xmm0, xmm0, xmm0
  00519	c5 fe 7f 85 a0
	fc ff ff	 vmovdqu YMMWORD PTR $T8[ebp], ymm0
  00521	c5 fe 6f 85 a0
	fc ff ff	 vmovdqu ymm0, YMMWORD PTR $T8[ebp]
  00529	c5 fd 74 85 80
	fc ff ff	 vpcmpeqb ymm0, ymm0, YMMWORD PTR $T7[ebp]
  00531	c5 fe 7f 85 60
	fc ff ff	 vmovdqu YMMWORD PTR $T6[ebp], ymm0
  00539	c5 fe 6f 85 60
	fc ff ff	 vmovdqu ymm0, YMMWORD PTR $T6[ebp]
  00541	c5 fd 71 f0 08	 vpsllw	 ymm0, ymm0, 8
  00546	c5 fe 7f 85 40
	fc ff ff	 vmovdqu YMMWORD PTR $T5[ebp], ymm0
  0054e	c5 fe 6f 85 40
	fc ff ff	 vmovdqu ymm0, YMMWORD PTR $T5[ebp]
  00556	c5 fe 7f 85 c0
	fc ff ff	 vmovdqu YMMWORD PTR _xMaskHighByte$9[ebp], ymm0

; 593  :             y1 = _mm256_and_si256(y1, xMaskHighByte);

  0055e	c5 fe 6f 85 60
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR _y1$14[ebp]
  00566	c5 fd db 85 c0
	fc ff ff	 vpand	 ymm0, ymm0, YMMWORD PTR _xMaskHighByte$9[ebp]
  0056e	c5 fe 7f 85 20
	fc ff ff	 vmovdqu YMMWORD PTR $T4[ebp], ymm0
  00576	c5 fe 6f 85 20
	fc ff ff	 vmovdqu ymm0, YMMWORD PTR $T4[ebp]
  0057e	c5 fe 7f 85 60
	fd ff ff	 vmovdqu YMMWORD PTR _y1$14[ebp], ymm0

; 594  : 
; 595  :             y0 = _mm256_or_si256(y0, y1);

  00586	c5 fe 6f 85 80
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR _y0$15[ebp]
  0058e	c5 fd eb 85 60
	fd ff ff	 vpor	 ymm0, ymm0, YMMWORD PTR _y1$14[ebp]
  00596	c5 fe 7f 85 00
	fc ff ff	 vmovdqu YMMWORD PTR $T3[ebp], ymm0
  0059e	c5 fe 6f 85 00
	fc ff ff	 vmovdqu ymm0, YMMWORD PTR $T3[ebp]
  005a6	c5 fe 7f 85 80
	fd ff ff	 vmovdqu YMMWORD PTR _y0$15[ebp], ymm0

; 596  : 
; 597  :             _mm256_storeu_si256((__m256i *)(dst_ptr +  0), y0);

  005ae	c5 fe 6f 85 80
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR _y0$15[ebp]
  005b6	8b 8d bc fd ff
	ff		 mov	 ecx, DWORD PTR _dst_ptr$17[ebp]
  005bc	c5 fe 7f 01	 vmovdqu YMMWORD PTR [ecx], ymm0

; 598  :         }

  005c0	e9 77 fe ff ff	 jmp	 $LN11@convert_yv
$LN12@convert_yv:

; 599  :     }

  005c5	e9 d4 fd ff ff	 jmp	 $LN8@convert_yv
$LN1@convert_yv:

; 600  : }

  005ca	52		 push	 edx
  005cb	8b cd		 mov	 ecx, ebp
  005cd	50		 push	 eax
  005ce	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN19@convert_yv
  005d4	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  005d9	58		 pop	 eax
  005da	5a		 pop	 edx
  005db	5f		 pop	 edi
  005dc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005df	33 cd		 xor	 ecx, ebp
  005e1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005e6	8b e5		 mov	 esp, ebp
  005e8	5d		 pop	 ebp
  005e9	8b e3		 mov	 esp, ebx
  005eb	5b		 pop	 ebx
  005ec	c3		 ret	 0
  005ed	0f 1f 00	 npad	 3
$LN19@convert_yv:
  005f0	02 00 00 00	 DD	 2
  005f4	00 00 00 00	 DD	 $LN18@convert_yv
$LN18@convert_yv:
  005f8	d8 ff ff ff	 DD	 -40			; ffffffd8H
  005fc	0c 00 00 00	 DD	 12			; 0000000cH
  00600	00 00 00 00	 DD	 $LN16@convert_yv
  00604	f0 fd ff ff	 DD	 -528			; fffffdf0H
  00608	0c 00 00 00	 DD	 12			; 0000000cH
  0060c	00 00 00 00	 DD	 $LN17@convert_yv
$LN17@convert_yv:
  00610	75		 DB	 117			; 00000075H
  00611	76		 DB	 118			; 00000076H
  00612	5f		 DB	 95			; 0000005fH
  00613	72		 DB	 114			; 00000072H
  00614	61		 DB	 97			; 00000061H
  00615	6e		 DB	 110			; 0000006eH
  00616	67		 DB	 103			; 00000067H
  00617	65		 DB	 101			; 00000065H
  00618	00		 DB	 0
$LN16@convert_yv:
  00619	79		 DB	 121			; 00000079H
  0061a	5f		 DB	 95			; 0000005fH
  0061b	72		 DB	 114			; 00000072H
  0061c	61		 DB	 97			; 00000061H
  0061d	6e		 DB	 110			; 0000006eH
  0061e	67		 DB	 103			; 00000067H
  0061f	65		 DB	 101			; 00000065H
  00620	00		 DB	 0
??$convert_yv12_high_to_nv12_avx2_base@$08$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_high_to_nv12_avx2_base<9,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yv12_09_to_nv12_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_09_to_nv12_avx2

; 619  : void convert_yv12_09_to_nv12_avx2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 620  :     convert_yv12_high_to_nv12_avx2_base<9, false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yv12_high_to_nv12_avx2_base@$08$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_high_to_nv12_avx2_base<9,0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 621  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yv12_09_to_nv12_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_09_to_nv12_avx2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
$T1 = -1056						; size = 12
$T2 = -1040						; size = 12
$T3 = -1024						; size = 32
$T4 = -992						; size = 32
$T5 = -960						; size = 32
$T6 = -928						; size = 32
$T7 = -896						; size = 32
$T8 = -864						; size = 32
_xMaskHighByte$9 = -832					; size = 32
$T10 = -800						; size = 32
$T11 = -768						; size = 32
$T12 = -736						; size = 32
$T13 = -704						; size = 32
_y1$14 = -672						; size = 32
_y0$15 = -640						; size = 32
_dst_ptr_fin$16 = -584					; size = 4
_dst_ptr$17 = -580					; size = 4
_src_v_ptr$18 = -576					; size = 4
_src_u_ptr$19 = -572					; size = 4
_x_fin$20 = -568					; size = 4
_y$21 = -564						; size = 4
_dstLine$ = -560					; size = 4
_srcVLine$ = -556					; size = 4
_srcULine$ = -552					; size = 4
_src_uv_pitch$ = -548					; size = 4
$T22 = -544						; size = 12
_uv_range$ = -528					; size = 12
$T23 = -512						; size = 32
$T24 = -480						; size = 32
$T25 = -448						; size = 32
$T26 = -416						; size = 32
$T27 = -368						; size = 16
$T28 = -352						; size = 32
$T29 = -304						; size = 16
$T30 = -288						; size = 32
$T31 = -240						; size = 16
$T32 = -224						; size = 32
$T33 = -176						; size = 16
_y1$34 = -160						; size = 32
_y0$35 = -128						; size = 32
_src_ptr_fin$36 = -84					; size = 4
_src_ptr$37 = -80					; size = 4
_dst_ptr$38 = -76					; size = 4
_y$39 = -72						; size = 4
_y_width$40 = -68					; size = 4
_dstLine$41 = -64					; size = 4
_srcYLine$42 = -60					; size = 4
$T43 = -56						; size = 12
_y_range$44 = -40					; size = 12
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yv12_high_to_nv12_avx2_base@$09$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_high_to_nv12_avx2_base<10,0>

; 542  : static void convert_yv12_high_to_nv12_avx2_base(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 20 04 00
	00		 sub	 esp, 1056		; 00000420H
  0001c	57		 push	 edi
  0001d	8d bd e0 fb ff
	ff		 lea	 edi, DWORD PTR [ebp-1056]
  00023	b9 08 01 00 00	 mov	 ecx, 264		; 00000108H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 543  :     static_assert(8 < in_bit_depth && in_bit_depth <= 16, "in_bit_depth must be 9-16.");
; 544  :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 545  :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 546  :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 547  :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 548  :     const int src_y_pitch = src_y_pitch_byte >> 1;

  0007c	8b 53 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  0007f	d1 fa		 sar	 edx, 1
  00081	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 549  :     //Y
; 550  :     if (!uv_only) {

  00084	b8 01 00 00 00	 mov	 eax, 1
  00089	85 c0		 test	 eax, eax
  0008b	0f 84 1f 02 00
	00		 je	 $LN14@convert_yv

; 551  :         const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00091	8b 4b 2c	 mov	 ecx, DWORD PTR _thread_n$[ebx]
  00094	51		 push	 ecx
  00095	8b 53 28	 mov	 edx, DWORD PTR _thread_id$[ebx]
  00098	52		 push	 edx
  00099	8b 43 20	 mov	 eax, DWORD PTR _height$[ebx]
  0009c	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  0009f	50		 push	 eax
  000a0	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  000a3	51		 push	 ecx
  000a4	8d 95 f0 fb ff
	ff		 lea	 edx, DWORD PTR $T2[ebp]
  000aa	52		 push	 edx
  000ab	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  000b0	83 c4 14	 add	 esp, 20			; 00000014H
  000b3	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b5	89 4d c8	 mov	 DWORD PTR $T43[ebp], ecx
  000b8	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000bb	89 55 cc	 mov	 DWORD PTR $T43[ebp+4], edx
  000be	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000c1	89 45 d0	 mov	 DWORD PTR $T43[ebp+8], eax
  000c4	8b 4d c8	 mov	 ecx, DWORD PTR $T43[ebp]
  000c7	89 4d d8	 mov	 DWORD PTR _y_range$44[ebp], ecx
  000ca	8b 55 cc	 mov	 edx, DWORD PTR $T43[ebp+4]
  000cd	89 55 dc	 mov	 DWORD PTR _y_range$44[ebp+4], edx
  000d0	8b 45 d0	 mov	 eax, DWORD PTR $T43[ebp+8]
  000d3	89 45 e0	 mov	 DWORD PTR _y_range$44[ebp+8], eax

; 552  :         uint16_t *srcYLine = (uint16_t *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000d6	b9 04 00 00 00	 mov	 ecx, 4
  000db	6b d1 00	 imul	 edx, ecx, 0
  000de	8b 45 e8	 mov	 eax, DWORD PTR _src_y_pitch$[ebp]
  000e1	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$44[ebp]
  000e5	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  000e8	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  000eb	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  000ee	8b 4d f8	 mov	 ecx, DWORD PTR _crop_left$[ebp]
  000f1	8d 14 48	 lea	 edx, DWORD PTR [eax+ecx*2]
  000f4	89 55 c4	 mov	 DWORD PTR _srcYLine$42[ebp], edx

; 553  :         uint8_t *dstLine  = (uint8_t *)dst[0] + dst_y_pitch_byte * y_range.start_dst;;

  000f7	b8 04 00 00 00	 mov	 eax, 4
  000fc	6b c8 00	 imul	 ecx, eax, 0
  000ff	8b 53 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebx]
  00102	0f af 55 dc	 imul	 edx, DWORD PTR _y_range$44[ebp+4]
  00106	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  00109	03 14 08	 add	 edx, DWORD PTR [eax+ecx]
  0010c	89 55 c0	 mov	 DWORD PTR _dstLine$41[ebp], edx

; 554  :         const int y_width = width - crop_right - crop_left;

  0010f	8b 4b 10	 mov	 ecx, DWORD PTR _width$[ebx]
  00112	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  00115	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  00118	89 4d bc	 mov	 DWORD PTR _y_width$40[ebp], ecx

; 555  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch_byte) {

  0011b	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _y$39[ebp], 0
  00122	eb 1e		 jmp	 SHORT $LN4@convert_yv
$LN2@convert_yv:
  00124	8b 55 b8	 mov	 edx, DWORD PTR _y$39[ebp]
  00127	83 c2 01	 add	 edx, 1
  0012a	89 55 b8	 mov	 DWORD PTR _y$39[ebp], edx
  0012d	8b 45 e8	 mov	 eax, DWORD PTR _src_y_pitch$[ebp]
  00130	8b 4d c4	 mov	 ecx, DWORD PTR _srcYLine$42[ebp]
  00133	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00136	89 55 c4	 mov	 DWORD PTR _srcYLine$42[ebp], edx
  00139	8b 45 c0	 mov	 eax, DWORD PTR _dstLine$41[ebp]
  0013c	03 43 1c	 add	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  0013f	89 45 c0	 mov	 DWORD PTR _dstLine$41[ebp], eax
$LN4@convert_yv:
  00142	8b 4d b8	 mov	 ecx, DWORD PTR _y$39[ebp]
  00145	3b 4d e0	 cmp	 ecx, DWORD PTR _y_range$44[ebp+8]
  00148	0f 8d 62 01 00
	00		 jge	 $LN14@convert_yv

; 556  :             uint8_t *dst_ptr = dstLine;

  0014e	8b 55 c0	 mov	 edx, DWORD PTR _dstLine$41[ebp]
  00151	89 55 b4	 mov	 DWORD PTR _dst_ptr$38[ebp], edx

; 557  :             uint16_t *src_ptr = srcYLine;

  00154	8b 45 c4	 mov	 eax, DWORD PTR _srcYLine$42[ebp]
  00157	89 45 b0	 mov	 DWORD PTR _src_ptr$37[ebp], eax

; 558  :             uint16_t *src_ptr_fin = src_ptr + y_width;

  0015a	8b 4d bc	 mov	 ecx, DWORD PTR _y_width$40[ebp]
  0015d	8b 55 b0	 mov	 edx, DWORD PTR _src_ptr$37[ebp]
  00160	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  00163	89 45 ac	 mov	 DWORD PTR _src_ptr_fin$36[ebp], eax

; 559  :             __m256i y0, y1;
; 560  :             for (; src_ptr < src_ptr_fin; dst_ptr += 32, src_ptr += 32) {

  00166	eb 12		 jmp	 SHORT $LN7@convert_yv
$LN5@convert_yv:
  00168	8b 4d b4	 mov	 ecx, DWORD PTR _dst_ptr$38[ebp]
  0016b	83 c1 20	 add	 ecx, 32			; 00000020H
  0016e	89 4d b4	 mov	 DWORD PTR _dst_ptr$38[ebp], ecx
  00171	8b 55 b0	 mov	 edx, DWORD PTR _src_ptr$37[ebp]
  00174	83 c2 40	 add	 edx, 64			; 00000040H
  00177	89 55 b0	 mov	 DWORD PTR _src_ptr$37[ebp], edx
$LN7@convert_yv:
  0017a	8b 45 b0	 mov	 eax, DWORD PTR _src_ptr$37[ebp]
  0017d	3b 45 ac	 cmp	 eax, DWORD PTR _src_ptr_fin$36[ebp]
  00180	0f 83 25 01 00
	00		 jae	 $LN6@convert_yv

; 561  :                 y0 = _mm256_set_m128i(_mm_loadu_si128((__m128i*)(src_ptr + 16)), _mm_loadu_si128((__m128i*)(src_ptr +  0)));

  00186	8b 4d b0	 mov	 ecx, DWORD PTR _src_ptr$37[ebp]
  00189	83 c1 20	 add	 ecx, 32			; 00000020H
  0018c	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  0018f	0f 29 85 10 ff
	ff ff		 movaps	 XMMWORD PTR $T31[ebp], xmm0
  00196	8b 55 b0	 mov	 edx, DWORD PTR _src_ptr$37[ebp]
  00199	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  0019c	0f 29 85 50 ff
	ff ff		 movaps	 XMMWORD PTR $T33[ebp], xmm0
  001a3	c5 fa 6f 85 50
	ff ff ff	 vmovdqu xmm0, XMMWORD PTR $T33[ebp]
  001ab	c5 fe 7f 85 20
	ff ff ff	 vmovdqu YMMWORD PTR $T32[ebp], ymm0
  001b3	c5 fe 6f 85 20
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T32[ebp]
  001bb	c4 e3 7d 18 85
	10 ff ff ff 01	 vinsertf128 ymm0, ymm0, XMMWORD PTR $T31[ebp], 1
  001c5	c5 fe 7f 85 e0
	fe ff ff	 vmovdqu YMMWORD PTR $T30[ebp], ymm0
  001cd	c5 fe 6f 85 e0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T30[ebp]
  001d5	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _y0$35[ebp], ymm0

; 562  :                 y1 = _mm256_set_m128i(_mm_loadu_si128((__m128i*)(src_ptr + 24)), _mm_loadu_si128((__m128i*)(src_ptr +  8)));

  001da	8b 45 b0	 mov	 eax, DWORD PTR _src_ptr$37[ebp]
  001dd	83 c0 30	 add	 eax, 48			; 00000030H
  001e0	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  001e3	0f 29 85 90 fe
	ff ff		 movaps	 XMMWORD PTR $T27[ebp], xmm0
  001ea	8b 4d b0	 mov	 ecx, DWORD PTR _src_ptr$37[ebp]
  001ed	83 c1 10	 add	 ecx, 16			; 00000010H
  001f0	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  001f3	0f 29 85 d0 fe
	ff ff		 movaps	 XMMWORD PTR $T29[ebp], xmm0
  001fa	c5 fa 6f 85 d0
	fe ff ff	 vmovdqu xmm0, XMMWORD PTR $T29[ebp]
  00202	c5 fe 7f 85 a0
	fe ff ff	 vmovdqu YMMWORD PTR $T28[ebp], ymm0
  0020a	c5 fe 6f 85 a0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T28[ebp]
  00212	c4 e3 7d 18 85
	90 fe ff ff 01	 vinsertf128 ymm0, ymm0, XMMWORD PTR $T27[ebp], 1
  0021c	c5 fe 7f 85 60
	fe ff ff	 vmovdqu YMMWORD PTR $T26[ebp], ymm0
  00224	c5 fe 6f 85 60
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T26[ebp]
  0022c	c5 fe 7f 85 60
	ff ff ff	 vmovdqu YMMWORD PTR _y1$34[ebp], ymm0

; 563  : 
; 564  :                 y0 = _mm256_srli_epi16(y0, in_bit_depth - 8);

  00234	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR _y0$35[ebp]
  00239	c5 fd 71 d0 02	 vpsrlw	 ymm0, ymm0, 2
  0023e	c5 fe 7f 85 40
	fe ff ff	 vmovdqu YMMWORD PTR $T25[ebp], ymm0
  00246	c5 fe 6f 85 40
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T25[ebp]
  0024e	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _y0$35[ebp], ymm0

; 565  :                 y1 = _mm256_srli_epi16(y1, in_bit_depth - 8);

  00253	c5 fe 6f 85 60
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR _y1$34[ebp]
  0025b	c5 fd 71 d0 02	 vpsrlw	 ymm0, ymm0, 2
  00260	c5 fe 7f 85 20
	fe ff ff	 vmovdqu YMMWORD PTR $T24[ebp], ymm0
  00268	c5 fe 6f 85 20
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T24[ebp]
  00270	c5 fe 7f 85 60
	ff ff ff	 vmovdqu YMMWORD PTR _y1$34[ebp], ymm0

; 566  : 
; 567  :                 y0 = _mm256_packus_epi16(y0, y1);

  00278	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR _y0$35[ebp]
  0027d	c5 fd 67 85 60
	ff ff ff	 vpackuswb ymm0, ymm0, YMMWORD PTR _y1$34[ebp]
  00285	c5 fe 7f 85 00
	fe ff ff	 vmovdqu YMMWORD PTR $T23[ebp], ymm0
  0028d	c5 fe 6f 85 00
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T23[ebp]
  00295	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _y0$35[ebp], ymm0

; 568  : 
; 569  :                 _mm256_storeu_si256((__m256i *)(dst_ptr + 0), y0);

  0029a	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR _y0$35[ebp]
  0029f	8b 55 b4	 mov	 edx, DWORD PTR _dst_ptr$38[ebp]
  002a2	c5 fe 7f 02	 vmovdqu YMMWORD PTR [edx], ymm0

; 570  :             }

  002a6	e9 bd fe ff ff	 jmp	 $LN5@convert_yv
$LN6@convert_yv:

; 571  :         }

  002ab	e9 74 fe ff ff	 jmp	 $LN2@convert_yv
$LN14@convert_yv:

; 572  :     }
; 573  :     //UV
; 574  :     const auto uv_range = thread_y_range(crop_up >> 1, (height - crop_bottom) >> 1, thread_id, thread_n);

  002b0	8b 43 2c	 mov	 eax, DWORD PTR _thread_n$[ebx]
  002b3	50		 push	 eax
  002b4	8b 4b 28	 mov	 ecx, DWORD PTR _thread_id$[ebx]
  002b7	51		 push	 ecx
  002b8	8b 53 20	 mov	 edx, DWORD PTR _height$[ebx]
  002bb	2b 55 ec	 sub	 edx, DWORD PTR _crop_bottom$[ebp]
  002be	d1 fa		 sar	 edx, 1
  002c0	52		 push	 edx
  002c1	8b 45 f4	 mov	 eax, DWORD PTR _crop_up$[ebp]
  002c4	d1 f8		 sar	 eax, 1
  002c6	50		 push	 eax
  002c7	8d 8d e0 fb ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  002cd	51		 push	 ecx
  002ce	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  002d3	83 c4 14	 add	 esp, 20			; 00000014H
  002d6	8b 10		 mov	 edx, DWORD PTR [eax]
  002d8	89 95 e0 fd ff
	ff		 mov	 DWORD PTR $T22[ebp], edx
  002de	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  002e1	89 8d e4 fd ff
	ff		 mov	 DWORD PTR $T22[ebp+4], ecx
  002e7	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  002ea	89 95 e8 fd ff
	ff		 mov	 DWORD PTR $T22[ebp+8], edx
  002f0	8b 85 e0 fd ff
	ff		 mov	 eax, DWORD PTR $T22[ebp]
  002f6	89 85 f0 fd ff
	ff		 mov	 DWORD PTR _uv_range$[ebp], eax
  002fc	8b 8d e4 fd ff
	ff		 mov	 ecx, DWORD PTR $T22[ebp+4]
  00302	89 8d f4 fd ff
	ff		 mov	 DWORD PTR _uv_range$[ebp+4], ecx
  00308	8b 95 e8 fd ff
	ff		 mov	 edx, DWORD PTR $T22[ebp+8]
  0030e	89 95 f8 fd ff
	ff		 mov	 DWORD PTR _uv_range$[ebp+8], edx

; 575  :     const int src_uv_pitch = src_uv_pitch_byte >> 1;

  00314	8b 43 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebx]
  00317	d1 f8		 sar	 eax, 1
  00319	89 85 dc fd ff
	ff		 mov	 DWORD PTR _src_uv_pitch$[ebp], eax

; 576  :     uint16_t *srcULine = (uint16_t *)src[1] + ((src_uv_pitch * uv_range.start_src) + (crop_left >> 1));

  0031f	b9 04 00 00 00	 mov	 ecx, 4
  00324	c1 e1 00	 shl	 ecx, 0
  00327	8b 95 dc fd ff
	ff		 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  0032d	0f af 95 f0 fd
	ff ff		 imul	 edx, DWORD PTR _uv_range$[ebp]
  00334	8b 45 f8	 mov	 eax, DWORD PTR _crop_left$[ebp]
  00337	d1 f8		 sar	 eax, 1
  00339	03 d0		 add	 edx, eax
  0033b	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  0033e	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  00341	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  00344	89 95 d8 fd ff
	ff		 mov	 DWORD PTR _srcULine$[ebp], edx

; 577  :     uint16_t *srcVLine = (uint16_t *)src[2] + ((src_uv_pitch * uv_range.start_src) + (crop_left >> 1));

  0034a	b8 04 00 00 00	 mov	 eax, 4
  0034f	d1 e0		 shl	 eax, 1
  00351	8b 8d dc fd ff
	ff		 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00357	0f af 8d f0 fd
	ff ff		 imul	 ecx, DWORD PTR _uv_range$[ebp]
  0035e	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  00361	d1 fa		 sar	 edx, 1
  00363	03 ca		 add	 ecx, edx
  00365	8b 53 0c	 mov	 edx, DWORD PTR _src$[ebx]
  00368	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  0036b	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  0036e	89 8d d4 fd ff
	ff		 mov	 DWORD PTR _srcVLine$[ebp], ecx

; 578  :     uint8_t *dstLine  = (uint8_t *)dst[1] + dst_y_pitch_byte * uv_range.start_dst;

  00374	ba 04 00 00 00	 mov	 edx, 4
  00379	c1 e2 00	 shl	 edx, 0
  0037c	8b 43 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  0037f	0f af 85 f4 fd
	ff ff		 imul	 eax, DWORD PTR _uv_range$[ebp+4]
  00386	8b 4b 08	 mov	 ecx, DWORD PTR _dst$[ebx]
  00389	03 04 11	 add	 eax, DWORD PTR [ecx+edx]
  0038c	89 85 d0 fd ff
	ff		 mov	 DWORD PTR _dstLine$[ebp], eax

; 579  :     for (int y = 0; y < uv_range.len; y++, srcULine += src_uv_pitch, srcVLine += src_uv_pitch, dstLine += dst_y_pitch_byte) {

  00392	c7 85 cc fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _y$21[ebp], 0
  0039c	eb 48		 jmp	 SHORT $LN10@convert_yv
$LN8@convert_yv:
  0039e	8b 95 cc fd ff
	ff		 mov	 edx, DWORD PTR _y$21[ebp]
  003a4	83 c2 01	 add	 edx, 1
  003a7	89 95 cc fd ff
	ff		 mov	 DWORD PTR _y$21[ebp], edx
  003ad	8b 85 dc fd ff
	ff		 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  003b3	8b 8d d8 fd ff
	ff		 mov	 ecx, DWORD PTR _srcULine$[ebp]
  003b9	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  003bc	89 95 d8 fd ff
	ff		 mov	 DWORD PTR _srcULine$[ebp], edx
  003c2	8b 85 dc fd ff
	ff		 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  003c8	8b 8d d4 fd ff
	ff		 mov	 ecx, DWORD PTR _srcVLine$[ebp]
  003ce	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  003d1	89 95 d4 fd ff
	ff		 mov	 DWORD PTR _srcVLine$[ebp], edx
  003d7	8b 85 d0 fd ff
	ff		 mov	 eax, DWORD PTR _dstLine$[ebp]
  003dd	03 43 1c	 add	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  003e0	89 85 d0 fd ff
	ff		 mov	 DWORD PTR _dstLine$[ebp], eax
$LN10@convert_yv:
  003e6	8b 8d cc fd ff
	ff		 mov	 ecx, DWORD PTR _y$21[ebp]
  003ec	3b 8d f8 fd ff
	ff		 cmp	 ecx, DWORD PTR _uv_range$[ebp+8]
  003f2	0f 8d d2 01 00
	00		 jge	 $LN1@convert_yv

; 580  :         const int x_fin = width - crop_right;

  003f8	8b 53 10	 mov	 edx, DWORD PTR _width$[ebx]
  003fb	2b 55 f0	 sub	 edx, DWORD PTR _crop_right$[ebp]
  003fe	89 95 c8 fd ff
	ff		 mov	 DWORD PTR _x_fin$20[ebp], edx

; 581  :         uint16_t *src_u_ptr = srcULine;

  00404	8b 85 d8 fd ff
	ff		 mov	 eax, DWORD PTR _srcULine$[ebp]
  0040a	89 85 c4 fd ff
	ff		 mov	 DWORD PTR _src_u_ptr$19[ebp], eax

; 582  :         uint16_t *src_v_ptr = srcVLine;

  00410	8b 8d d4 fd ff
	ff		 mov	 ecx, DWORD PTR _srcVLine$[ebp]
  00416	89 8d c0 fd ff
	ff		 mov	 DWORD PTR _src_v_ptr$18[ebp], ecx

; 583  :         uint8_t *dst_ptr = dstLine;

  0041c	8b 95 d0 fd ff
	ff		 mov	 edx, DWORD PTR _dstLine$[ebp]
  00422	89 95 bc fd ff
	ff		 mov	 DWORD PTR _dst_ptr$17[ebp], edx

; 584  :         uint8_t *dst_ptr_fin = dst_ptr + x_fin;

  00428	8b 85 bc fd ff
	ff		 mov	 eax, DWORD PTR _dst_ptr$17[ebp]
  0042e	03 85 c8 fd ff
	ff		 add	 eax, DWORD PTR _x_fin$20[ebp]
  00434	89 85 b8 fd ff
	ff		 mov	 DWORD PTR _dst_ptr_fin$16[ebp], eax

; 585  :         __m256i y0, y1;
; 586  :         for (; dst_ptr < dst_ptr_fin; src_u_ptr += 16, src_v_ptr += 16, dst_ptr += 32) {

  0043a	eb 2d		 jmp	 SHORT $LN13@convert_yv
$LN11@convert_yv:
  0043c	8b 8d c4 fd ff
	ff		 mov	 ecx, DWORD PTR _src_u_ptr$19[ebp]
  00442	83 c1 20	 add	 ecx, 32			; 00000020H
  00445	89 8d c4 fd ff
	ff		 mov	 DWORD PTR _src_u_ptr$19[ebp], ecx
  0044b	8b 95 c0 fd ff
	ff		 mov	 edx, DWORD PTR _src_v_ptr$18[ebp]
  00451	83 c2 20	 add	 edx, 32			; 00000020H
  00454	89 95 c0 fd ff
	ff		 mov	 DWORD PTR _src_v_ptr$18[ebp], edx
  0045a	8b 85 bc fd ff
	ff		 mov	 eax, DWORD PTR _dst_ptr$17[ebp]
  00460	83 c0 20	 add	 eax, 32			; 00000020H
  00463	89 85 bc fd ff
	ff		 mov	 DWORD PTR _dst_ptr$17[ebp], eax
$LN13@convert_yv:
  00469	8b 8d bc fd ff
	ff		 mov	 ecx, DWORD PTR _dst_ptr$17[ebp]
  0046f	3b 8d b8 fd ff
	ff		 cmp	 ecx, DWORD PTR _dst_ptr_fin$16[ebp]
  00475	0f 83 4a 01 00
	00		 jae	 $LN12@convert_yv

; 587  :             y0 = _mm256_loadu_si256((const __m256i *)src_u_ptr);

  0047b	8b 95 c4 fd ff
	ff		 mov	 edx, DWORD PTR _src_u_ptr$19[ebp]
  00481	c5 fe 6f 02	 vmovdqu ymm0, YMMWORD PTR [edx]
  00485	c5 fe 7f 85 40
	fd ff ff	 vmovdqu YMMWORD PTR $T13[ebp], ymm0
  0048d	c5 fe 6f 85 40
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T13[ebp]
  00495	c5 fe 7f 85 80
	fd ff ff	 vmovdqu YMMWORD PTR _y0$15[ebp], ymm0

; 588  :             y1 = _mm256_loadu_si256((const __m256i *)src_v_ptr);

  0049d	8b 85 c0 fd ff
	ff		 mov	 eax, DWORD PTR _src_v_ptr$18[ebp]
  004a3	c5 fe 6f 00	 vmovdqu ymm0, YMMWORD PTR [eax]
  004a7	c5 fe 7f 85 20
	fd ff ff	 vmovdqu YMMWORD PTR $T12[ebp], ymm0
  004af	c5 fe 6f 85 20
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T12[ebp]
  004b7	c5 fe 7f 85 60
	fd ff ff	 vmovdqu YMMWORD PTR _y1$14[ebp], ymm0

; 589  : 
; 590  :             y0 = _mm256_srli_epi16(y0, in_bit_depth - 8);

  004bf	c5 fe 6f 85 80
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR _y0$15[ebp]
  004c7	c5 fd 71 d0 02	 vpsrlw	 ymm0, ymm0, 2
  004cc	c5 fe 7f 85 00
	fd ff ff	 vmovdqu YMMWORD PTR $T11[ebp], ymm0
  004d4	c5 fe 6f 85 00
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T11[ebp]
  004dc	c5 fe 7f 85 80
	fd ff ff	 vmovdqu YMMWORD PTR _y0$15[ebp], ymm0

; 591  :             y1 = _mm256_slli_epi16(y1, 16 - in_bit_depth);

  004e4	c5 fe 6f 85 60
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR _y1$14[ebp]
  004ec	c5 fd 71 f0 06	 vpsllw	 ymm0, ymm0, 6
  004f1	c5 fe 7f 85 e0
	fc ff ff	 vmovdqu YMMWORD PTR $T10[ebp], ymm0
  004f9	c5 fe 6f 85 e0
	fc ff ff	 vmovdqu ymm0, YMMWORD PTR $T10[ebp]
  00501	c5 fe 7f 85 60
	fd ff ff	 vmovdqu YMMWORD PTR _y1$14[ebp], ymm0

; 592  :             const __m256i xMaskHighByte = _mm256_slli_epi16(_mm256_cmpeq_epi8(_mm256_setzero_si256(), _mm256_setzero_si256()), 8);

  00509	c5 f9 ef c0	 vpxor	 xmm0, xmm0, xmm0
  0050d	c5 fe 7f 85 80
	fc ff ff	 vmovdqu YMMWORD PTR $T7[ebp], ymm0
  00515	c5 f9 ef c0	 vpxor	 xmm0, xmm0, xmm0
  00519	c5 fe 7f 85 a0
	fc ff ff	 vmovdqu YMMWORD PTR $T8[ebp], ymm0
  00521	c5 fe 6f 85 a0
	fc ff ff	 vmovdqu ymm0, YMMWORD PTR $T8[ebp]
  00529	c5 fd 74 85 80
	fc ff ff	 vpcmpeqb ymm0, ymm0, YMMWORD PTR $T7[ebp]
  00531	c5 fe 7f 85 60
	fc ff ff	 vmovdqu YMMWORD PTR $T6[ebp], ymm0
  00539	c5 fe 6f 85 60
	fc ff ff	 vmovdqu ymm0, YMMWORD PTR $T6[ebp]
  00541	c5 fd 71 f0 08	 vpsllw	 ymm0, ymm0, 8
  00546	c5 fe 7f 85 40
	fc ff ff	 vmovdqu YMMWORD PTR $T5[ebp], ymm0
  0054e	c5 fe 6f 85 40
	fc ff ff	 vmovdqu ymm0, YMMWORD PTR $T5[ebp]
  00556	c5 fe 7f 85 c0
	fc ff ff	 vmovdqu YMMWORD PTR _xMaskHighByte$9[ebp], ymm0

; 593  :             y1 = _mm256_and_si256(y1, xMaskHighByte);

  0055e	c5 fe 6f 85 60
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR _y1$14[ebp]
  00566	c5 fd db 85 c0
	fc ff ff	 vpand	 ymm0, ymm0, YMMWORD PTR _xMaskHighByte$9[ebp]
  0056e	c5 fe 7f 85 20
	fc ff ff	 vmovdqu YMMWORD PTR $T4[ebp], ymm0
  00576	c5 fe 6f 85 20
	fc ff ff	 vmovdqu ymm0, YMMWORD PTR $T4[ebp]
  0057e	c5 fe 7f 85 60
	fd ff ff	 vmovdqu YMMWORD PTR _y1$14[ebp], ymm0

; 594  : 
; 595  :             y0 = _mm256_or_si256(y0, y1);

  00586	c5 fe 6f 85 80
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR _y0$15[ebp]
  0058e	c5 fd eb 85 60
	fd ff ff	 vpor	 ymm0, ymm0, YMMWORD PTR _y1$14[ebp]
  00596	c5 fe 7f 85 00
	fc ff ff	 vmovdqu YMMWORD PTR $T3[ebp], ymm0
  0059e	c5 fe 6f 85 00
	fc ff ff	 vmovdqu ymm0, YMMWORD PTR $T3[ebp]
  005a6	c5 fe 7f 85 80
	fd ff ff	 vmovdqu YMMWORD PTR _y0$15[ebp], ymm0

; 596  : 
; 597  :             _mm256_storeu_si256((__m256i *)(dst_ptr +  0), y0);

  005ae	c5 fe 6f 85 80
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR _y0$15[ebp]
  005b6	8b 8d bc fd ff
	ff		 mov	 ecx, DWORD PTR _dst_ptr$17[ebp]
  005bc	c5 fe 7f 01	 vmovdqu YMMWORD PTR [ecx], ymm0

; 598  :         }

  005c0	e9 77 fe ff ff	 jmp	 $LN11@convert_yv
$LN12@convert_yv:

; 599  :     }

  005c5	e9 d4 fd ff ff	 jmp	 $LN8@convert_yv
$LN1@convert_yv:

; 600  : }

  005ca	52		 push	 edx
  005cb	8b cd		 mov	 ecx, ebp
  005cd	50		 push	 eax
  005ce	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN19@convert_yv
  005d4	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  005d9	58		 pop	 eax
  005da	5a		 pop	 edx
  005db	5f		 pop	 edi
  005dc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005df	33 cd		 xor	 ecx, ebp
  005e1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005e6	8b e5		 mov	 esp, ebp
  005e8	5d		 pop	 ebp
  005e9	8b e3		 mov	 esp, ebx
  005eb	5b		 pop	 ebx
  005ec	c3		 ret	 0
  005ed	0f 1f 00	 npad	 3
$LN19@convert_yv:
  005f0	02 00 00 00	 DD	 2
  005f4	00 00 00 00	 DD	 $LN18@convert_yv
$LN18@convert_yv:
  005f8	d8 ff ff ff	 DD	 -40			; ffffffd8H
  005fc	0c 00 00 00	 DD	 12			; 0000000cH
  00600	00 00 00 00	 DD	 $LN16@convert_yv
  00604	f0 fd ff ff	 DD	 -528			; fffffdf0H
  00608	0c 00 00 00	 DD	 12			; 0000000cH
  0060c	00 00 00 00	 DD	 $LN17@convert_yv
$LN17@convert_yv:
  00610	75		 DB	 117			; 00000075H
  00611	76		 DB	 118			; 00000076H
  00612	5f		 DB	 95			; 0000005fH
  00613	72		 DB	 114			; 00000072H
  00614	61		 DB	 97			; 00000061H
  00615	6e		 DB	 110			; 0000006eH
  00616	67		 DB	 103			; 00000067H
  00617	65		 DB	 101			; 00000065H
  00618	00		 DB	 0
$LN16@convert_yv:
  00619	79		 DB	 121			; 00000079H
  0061a	5f		 DB	 95			; 0000005fH
  0061b	72		 DB	 114			; 00000072H
  0061c	61		 DB	 97			; 00000061H
  0061d	6e		 DB	 110			; 0000006eH
  0061e	67		 DB	 103			; 00000067H
  0061f	65		 DB	 101			; 00000065H
  00620	00		 DB	 0
??$convert_yv12_high_to_nv12_avx2_base@$09$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_high_to_nv12_avx2_base<10,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yv12_10_to_nv12_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_10_to_nv12_avx2

; 615  : void convert_yv12_10_to_nv12_avx2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 616  :     convert_yv12_high_to_nv12_avx2_base<10, false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yv12_high_to_nv12_avx2_base@$09$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_high_to_nv12_avx2_base<10,0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 617  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yv12_10_to_nv12_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_10_to_nv12_avx2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
$T1 = -1056						; size = 12
$T2 = -1040						; size = 12
$T3 = -1024						; size = 32
$T4 = -992						; size = 32
$T5 = -960						; size = 32
$T6 = -928						; size = 32
$T7 = -896						; size = 32
$T8 = -864						; size = 32
_xMaskHighByte$9 = -832					; size = 32
$T10 = -800						; size = 32
$T11 = -768						; size = 32
$T12 = -736						; size = 32
$T13 = -704						; size = 32
_y1$14 = -672						; size = 32
_y0$15 = -640						; size = 32
_dst_ptr_fin$16 = -584					; size = 4
_dst_ptr$17 = -580					; size = 4
_src_v_ptr$18 = -576					; size = 4
_src_u_ptr$19 = -572					; size = 4
_x_fin$20 = -568					; size = 4
_y$21 = -564						; size = 4
_dstLine$ = -560					; size = 4
_srcVLine$ = -556					; size = 4
_srcULine$ = -552					; size = 4
_src_uv_pitch$ = -548					; size = 4
$T22 = -544						; size = 12
_uv_range$ = -528					; size = 12
$T23 = -512						; size = 32
$T24 = -480						; size = 32
$T25 = -448						; size = 32
$T26 = -416						; size = 32
$T27 = -368						; size = 16
$T28 = -352						; size = 32
$T29 = -304						; size = 16
$T30 = -288						; size = 32
$T31 = -240						; size = 16
$T32 = -224						; size = 32
$T33 = -176						; size = 16
_y1$34 = -160						; size = 32
_y0$35 = -128						; size = 32
_src_ptr_fin$36 = -84					; size = 4
_src_ptr$37 = -80					; size = 4
_dst_ptr$38 = -76					; size = 4
_y$39 = -72						; size = 4
_y_width$40 = -68					; size = 4
_dstLine$41 = -64					; size = 4
_srcYLine$42 = -60					; size = 4
$T43 = -56						; size = 12
_y_range$44 = -40					; size = 12
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yv12_high_to_nv12_avx2_base@$0M@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_high_to_nv12_avx2_base<12,0>

; 542  : static void convert_yv12_high_to_nv12_avx2_base(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 20 04 00
	00		 sub	 esp, 1056		; 00000420H
  0001c	57		 push	 edi
  0001d	8d bd e0 fb ff
	ff		 lea	 edi, DWORD PTR [ebp-1056]
  00023	b9 08 01 00 00	 mov	 ecx, 264		; 00000108H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 543  :     static_assert(8 < in_bit_depth && in_bit_depth <= 16, "in_bit_depth must be 9-16.");
; 544  :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 545  :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 546  :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 547  :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 548  :     const int src_y_pitch = src_y_pitch_byte >> 1;

  0007c	8b 53 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  0007f	d1 fa		 sar	 edx, 1
  00081	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 549  :     //Y
; 550  :     if (!uv_only) {

  00084	b8 01 00 00 00	 mov	 eax, 1
  00089	85 c0		 test	 eax, eax
  0008b	0f 84 1f 02 00
	00		 je	 $LN14@convert_yv

; 551  :         const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00091	8b 4b 2c	 mov	 ecx, DWORD PTR _thread_n$[ebx]
  00094	51		 push	 ecx
  00095	8b 53 28	 mov	 edx, DWORD PTR _thread_id$[ebx]
  00098	52		 push	 edx
  00099	8b 43 20	 mov	 eax, DWORD PTR _height$[ebx]
  0009c	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  0009f	50		 push	 eax
  000a0	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  000a3	51		 push	 ecx
  000a4	8d 95 f0 fb ff
	ff		 lea	 edx, DWORD PTR $T2[ebp]
  000aa	52		 push	 edx
  000ab	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  000b0	83 c4 14	 add	 esp, 20			; 00000014H
  000b3	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b5	89 4d c8	 mov	 DWORD PTR $T43[ebp], ecx
  000b8	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000bb	89 55 cc	 mov	 DWORD PTR $T43[ebp+4], edx
  000be	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000c1	89 45 d0	 mov	 DWORD PTR $T43[ebp+8], eax
  000c4	8b 4d c8	 mov	 ecx, DWORD PTR $T43[ebp]
  000c7	89 4d d8	 mov	 DWORD PTR _y_range$44[ebp], ecx
  000ca	8b 55 cc	 mov	 edx, DWORD PTR $T43[ebp+4]
  000cd	89 55 dc	 mov	 DWORD PTR _y_range$44[ebp+4], edx
  000d0	8b 45 d0	 mov	 eax, DWORD PTR $T43[ebp+8]
  000d3	89 45 e0	 mov	 DWORD PTR _y_range$44[ebp+8], eax

; 552  :         uint16_t *srcYLine = (uint16_t *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000d6	b9 04 00 00 00	 mov	 ecx, 4
  000db	6b d1 00	 imul	 edx, ecx, 0
  000de	8b 45 e8	 mov	 eax, DWORD PTR _src_y_pitch$[ebp]
  000e1	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$44[ebp]
  000e5	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  000e8	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  000eb	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  000ee	8b 4d f8	 mov	 ecx, DWORD PTR _crop_left$[ebp]
  000f1	8d 14 48	 lea	 edx, DWORD PTR [eax+ecx*2]
  000f4	89 55 c4	 mov	 DWORD PTR _srcYLine$42[ebp], edx

; 553  :         uint8_t *dstLine  = (uint8_t *)dst[0] + dst_y_pitch_byte * y_range.start_dst;;

  000f7	b8 04 00 00 00	 mov	 eax, 4
  000fc	6b c8 00	 imul	 ecx, eax, 0
  000ff	8b 53 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebx]
  00102	0f af 55 dc	 imul	 edx, DWORD PTR _y_range$44[ebp+4]
  00106	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  00109	03 14 08	 add	 edx, DWORD PTR [eax+ecx]
  0010c	89 55 c0	 mov	 DWORD PTR _dstLine$41[ebp], edx

; 554  :         const int y_width = width - crop_right - crop_left;

  0010f	8b 4b 10	 mov	 ecx, DWORD PTR _width$[ebx]
  00112	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  00115	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  00118	89 4d bc	 mov	 DWORD PTR _y_width$40[ebp], ecx

; 555  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch_byte) {

  0011b	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _y$39[ebp], 0
  00122	eb 1e		 jmp	 SHORT $LN4@convert_yv
$LN2@convert_yv:
  00124	8b 55 b8	 mov	 edx, DWORD PTR _y$39[ebp]
  00127	83 c2 01	 add	 edx, 1
  0012a	89 55 b8	 mov	 DWORD PTR _y$39[ebp], edx
  0012d	8b 45 e8	 mov	 eax, DWORD PTR _src_y_pitch$[ebp]
  00130	8b 4d c4	 mov	 ecx, DWORD PTR _srcYLine$42[ebp]
  00133	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00136	89 55 c4	 mov	 DWORD PTR _srcYLine$42[ebp], edx
  00139	8b 45 c0	 mov	 eax, DWORD PTR _dstLine$41[ebp]
  0013c	03 43 1c	 add	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  0013f	89 45 c0	 mov	 DWORD PTR _dstLine$41[ebp], eax
$LN4@convert_yv:
  00142	8b 4d b8	 mov	 ecx, DWORD PTR _y$39[ebp]
  00145	3b 4d e0	 cmp	 ecx, DWORD PTR _y_range$44[ebp+8]
  00148	0f 8d 62 01 00
	00		 jge	 $LN14@convert_yv

; 556  :             uint8_t *dst_ptr = dstLine;

  0014e	8b 55 c0	 mov	 edx, DWORD PTR _dstLine$41[ebp]
  00151	89 55 b4	 mov	 DWORD PTR _dst_ptr$38[ebp], edx

; 557  :             uint16_t *src_ptr = srcYLine;

  00154	8b 45 c4	 mov	 eax, DWORD PTR _srcYLine$42[ebp]
  00157	89 45 b0	 mov	 DWORD PTR _src_ptr$37[ebp], eax

; 558  :             uint16_t *src_ptr_fin = src_ptr + y_width;

  0015a	8b 4d bc	 mov	 ecx, DWORD PTR _y_width$40[ebp]
  0015d	8b 55 b0	 mov	 edx, DWORD PTR _src_ptr$37[ebp]
  00160	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  00163	89 45 ac	 mov	 DWORD PTR _src_ptr_fin$36[ebp], eax

; 559  :             __m256i y0, y1;
; 560  :             for (; src_ptr < src_ptr_fin; dst_ptr += 32, src_ptr += 32) {

  00166	eb 12		 jmp	 SHORT $LN7@convert_yv
$LN5@convert_yv:
  00168	8b 4d b4	 mov	 ecx, DWORD PTR _dst_ptr$38[ebp]
  0016b	83 c1 20	 add	 ecx, 32			; 00000020H
  0016e	89 4d b4	 mov	 DWORD PTR _dst_ptr$38[ebp], ecx
  00171	8b 55 b0	 mov	 edx, DWORD PTR _src_ptr$37[ebp]
  00174	83 c2 40	 add	 edx, 64			; 00000040H
  00177	89 55 b0	 mov	 DWORD PTR _src_ptr$37[ebp], edx
$LN7@convert_yv:
  0017a	8b 45 b0	 mov	 eax, DWORD PTR _src_ptr$37[ebp]
  0017d	3b 45 ac	 cmp	 eax, DWORD PTR _src_ptr_fin$36[ebp]
  00180	0f 83 25 01 00
	00		 jae	 $LN6@convert_yv

; 561  :                 y0 = _mm256_set_m128i(_mm_loadu_si128((__m128i*)(src_ptr + 16)), _mm_loadu_si128((__m128i*)(src_ptr +  0)));

  00186	8b 4d b0	 mov	 ecx, DWORD PTR _src_ptr$37[ebp]
  00189	83 c1 20	 add	 ecx, 32			; 00000020H
  0018c	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  0018f	0f 29 85 10 ff
	ff ff		 movaps	 XMMWORD PTR $T31[ebp], xmm0
  00196	8b 55 b0	 mov	 edx, DWORD PTR _src_ptr$37[ebp]
  00199	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  0019c	0f 29 85 50 ff
	ff ff		 movaps	 XMMWORD PTR $T33[ebp], xmm0
  001a3	c5 fa 6f 85 50
	ff ff ff	 vmovdqu xmm0, XMMWORD PTR $T33[ebp]
  001ab	c5 fe 7f 85 20
	ff ff ff	 vmovdqu YMMWORD PTR $T32[ebp], ymm0
  001b3	c5 fe 6f 85 20
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T32[ebp]
  001bb	c4 e3 7d 18 85
	10 ff ff ff 01	 vinsertf128 ymm0, ymm0, XMMWORD PTR $T31[ebp], 1
  001c5	c5 fe 7f 85 e0
	fe ff ff	 vmovdqu YMMWORD PTR $T30[ebp], ymm0
  001cd	c5 fe 6f 85 e0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T30[ebp]
  001d5	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _y0$35[ebp], ymm0

; 562  :                 y1 = _mm256_set_m128i(_mm_loadu_si128((__m128i*)(src_ptr + 24)), _mm_loadu_si128((__m128i*)(src_ptr +  8)));

  001da	8b 45 b0	 mov	 eax, DWORD PTR _src_ptr$37[ebp]
  001dd	83 c0 30	 add	 eax, 48			; 00000030H
  001e0	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  001e3	0f 29 85 90 fe
	ff ff		 movaps	 XMMWORD PTR $T27[ebp], xmm0
  001ea	8b 4d b0	 mov	 ecx, DWORD PTR _src_ptr$37[ebp]
  001ed	83 c1 10	 add	 ecx, 16			; 00000010H
  001f0	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  001f3	0f 29 85 d0 fe
	ff ff		 movaps	 XMMWORD PTR $T29[ebp], xmm0
  001fa	c5 fa 6f 85 d0
	fe ff ff	 vmovdqu xmm0, XMMWORD PTR $T29[ebp]
  00202	c5 fe 7f 85 a0
	fe ff ff	 vmovdqu YMMWORD PTR $T28[ebp], ymm0
  0020a	c5 fe 6f 85 a0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T28[ebp]
  00212	c4 e3 7d 18 85
	90 fe ff ff 01	 vinsertf128 ymm0, ymm0, XMMWORD PTR $T27[ebp], 1
  0021c	c5 fe 7f 85 60
	fe ff ff	 vmovdqu YMMWORD PTR $T26[ebp], ymm0
  00224	c5 fe 6f 85 60
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T26[ebp]
  0022c	c5 fe 7f 85 60
	ff ff ff	 vmovdqu YMMWORD PTR _y1$34[ebp], ymm0

; 563  : 
; 564  :                 y0 = _mm256_srli_epi16(y0, in_bit_depth - 8);

  00234	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR _y0$35[ebp]
  00239	c5 fd 71 d0 04	 vpsrlw	 ymm0, ymm0, 4
  0023e	c5 fe 7f 85 40
	fe ff ff	 vmovdqu YMMWORD PTR $T25[ebp], ymm0
  00246	c5 fe 6f 85 40
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T25[ebp]
  0024e	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _y0$35[ebp], ymm0

; 565  :                 y1 = _mm256_srli_epi16(y1, in_bit_depth - 8);

  00253	c5 fe 6f 85 60
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR _y1$34[ebp]
  0025b	c5 fd 71 d0 04	 vpsrlw	 ymm0, ymm0, 4
  00260	c5 fe 7f 85 20
	fe ff ff	 vmovdqu YMMWORD PTR $T24[ebp], ymm0
  00268	c5 fe 6f 85 20
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T24[ebp]
  00270	c5 fe 7f 85 60
	ff ff ff	 vmovdqu YMMWORD PTR _y1$34[ebp], ymm0

; 566  : 
; 567  :                 y0 = _mm256_packus_epi16(y0, y1);

  00278	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR _y0$35[ebp]
  0027d	c5 fd 67 85 60
	ff ff ff	 vpackuswb ymm0, ymm0, YMMWORD PTR _y1$34[ebp]
  00285	c5 fe 7f 85 00
	fe ff ff	 vmovdqu YMMWORD PTR $T23[ebp], ymm0
  0028d	c5 fe 6f 85 00
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T23[ebp]
  00295	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _y0$35[ebp], ymm0

; 568  : 
; 569  :                 _mm256_storeu_si256((__m256i *)(dst_ptr + 0), y0);

  0029a	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR _y0$35[ebp]
  0029f	8b 55 b4	 mov	 edx, DWORD PTR _dst_ptr$38[ebp]
  002a2	c5 fe 7f 02	 vmovdqu YMMWORD PTR [edx], ymm0

; 570  :             }

  002a6	e9 bd fe ff ff	 jmp	 $LN5@convert_yv
$LN6@convert_yv:

; 571  :         }

  002ab	e9 74 fe ff ff	 jmp	 $LN2@convert_yv
$LN14@convert_yv:

; 572  :     }
; 573  :     //UV
; 574  :     const auto uv_range = thread_y_range(crop_up >> 1, (height - crop_bottom) >> 1, thread_id, thread_n);

  002b0	8b 43 2c	 mov	 eax, DWORD PTR _thread_n$[ebx]
  002b3	50		 push	 eax
  002b4	8b 4b 28	 mov	 ecx, DWORD PTR _thread_id$[ebx]
  002b7	51		 push	 ecx
  002b8	8b 53 20	 mov	 edx, DWORD PTR _height$[ebx]
  002bb	2b 55 ec	 sub	 edx, DWORD PTR _crop_bottom$[ebp]
  002be	d1 fa		 sar	 edx, 1
  002c0	52		 push	 edx
  002c1	8b 45 f4	 mov	 eax, DWORD PTR _crop_up$[ebp]
  002c4	d1 f8		 sar	 eax, 1
  002c6	50		 push	 eax
  002c7	8d 8d e0 fb ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  002cd	51		 push	 ecx
  002ce	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  002d3	83 c4 14	 add	 esp, 20			; 00000014H
  002d6	8b 10		 mov	 edx, DWORD PTR [eax]
  002d8	89 95 e0 fd ff
	ff		 mov	 DWORD PTR $T22[ebp], edx
  002de	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  002e1	89 8d e4 fd ff
	ff		 mov	 DWORD PTR $T22[ebp+4], ecx
  002e7	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  002ea	89 95 e8 fd ff
	ff		 mov	 DWORD PTR $T22[ebp+8], edx
  002f0	8b 85 e0 fd ff
	ff		 mov	 eax, DWORD PTR $T22[ebp]
  002f6	89 85 f0 fd ff
	ff		 mov	 DWORD PTR _uv_range$[ebp], eax
  002fc	8b 8d e4 fd ff
	ff		 mov	 ecx, DWORD PTR $T22[ebp+4]
  00302	89 8d f4 fd ff
	ff		 mov	 DWORD PTR _uv_range$[ebp+4], ecx
  00308	8b 95 e8 fd ff
	ff		 mov	 edx, DWORD PTR $T22[ebp+8]
  0030e	89 95 f8 fd ff
	ff		 mov	 DWORD PTR _uv_range$[ebp+8], edx

; 575  :     const int src_uv_pitch = src_uv_pitch_byte >> 1;

  00314	8b 43 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebx]
  00317	d1 f8		 sar	 eax, 1
  00319	89 85 dc fd ff
	ff		 mov	 DWORD PTR _src_uv_pitch$[ebp], eax

; 576  :     uint16_t *srcULine = (uint16_t *)src[1] + ((src_uv_pitch * uv_range.start_src) + (crop_left >> 1));

  0031f	b9 04 00 00 00	 mov	 ecx, 4
  00324	c1 e1 00	 shl	 ecx, 0
  00327	8b 95 dc fd ff
	ff		 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  0032d	0f af 95 f0 fd
	ff ff		 imul	 edx, DWORD PTR _uv_range$[ebp]
  00334	8b 45 f8	 mov	 eax, DWORD PTR _crop_left$[ebp]
  00337	d1 f8		 sar	 eax, 1
  00339	03 d0		 add	 edx, eax
  0033b	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  0033e	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  00341	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  00344	89 95 d8 fd ff
	ff		 mov	 DWORD PTR _srcULine$[ebp], edx

; 577  :     uint16_t *srcVLine = (uint16_t *)src[2] + ((src_uv_pitch * uv_range.start_src) + (crop_left >> 1));

  0034a	b8 04 00 00 00	 mov	 eax, 4
  0034f	d1 e0		 shl	 eax, 1
  00351	8b 8d dc fd ff
	ff		 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00357	0f af 8d f0 fd
	ff ff		 imul	 ecx, DWORD PTR _uv_range$[ebp]
  0035e	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  00361	d1 fa		 sar	 edx, 1
  00363	03 ca		 add	 ecx, edx
  00365	8b 53 0c	 mov	 edx, DWORD PTR _src$[ebx]
  00368	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  0036b	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  0036e	89 8d d4 fd ff
	ff		 mov	 DWORD PTR _srcVLine$[ebp], ecx

; 578  :     uint8_t *dstLine  = (uint8_t *)dst[1] + dst_y_pitch_byte * uv_range.start_dst;

  00374	ba 04 00 00 00	 mov	 edx, 4
  00379	c1 e2 00	 shl	 edx, 0
  0037c	8b 43 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  0037f	0f af 85 f4 fd
	ff ff		 imul	 eax, DWORD PTR _uv_range$[ebp+4]
  00386	8b 4b 08	 mov	 ecx, DWORD PTR _dst$[ebx]
  00389	03 04 11	 add	 eax, DWORD PTR [ecx+edx]
  0038c	89 85 d0 fd ff
	ff		 mov	 DWORD PTR _dstLine$[ebp], eax

; 579  :     for (int y = 0; y < uv_range.len; y++, srcULine += src_uv_pitch, srcVLine += src_uv_pitch, dstLine += dst_y_pitch_byte) {

  00392	c7 85 cc fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _y$21[ebp], 0
  0039c	eb 48		 jmp	 SHORT $LN10@convert_yv
$LN8@convert_yv:
  0039e	8b 95 cc fd ff
	ff		 mov	 edx, DWORD PTR _y$21[ebp]
  003a4	83 c2 01	 add	 edx, 1
  003a7	89 95 cc fd ff
	ff		 mov	 DWORD PTR _y$21[ebp], edx
  003ad	8b 85 dc fd ff
	ff		 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  003b3	8b 8d d8 fd ff
	ff		 mov	 ecx, DWORD PTR _srcULine$[ebp]
  003b9	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  003bc	89 95 d8 fd ff
	ff		 mov	 DWORD PTR _srcULine$[ebp], edx
  003c2	8b 85 dc fd ff
	ff		 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  003c8	8b 8d d4 fd ff
	ff		 mov	 ecx, DWORD PTR _srcVLine$[ebp]
  003ce	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  003d1	89 95 d4 fd ff
	ff		 mov	 DWORD PTR _srcVLine$[ebp], edx
  003d7	8b 85 d0 fd ff
	ff		 mov	 eax, DWORD PTR _dstLine$[ebp]
  003dd	03 43 1c	 add	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  003e0	89 85 d0 fd ff
	ff		 mov	 DWORD PTR _dstLine$[ebp], eax
$LN10@convert_yv:
  003e6	8b 8d cc fd ff
	ff		 mov	 ecx, DWORD PTR _y$21[ebp]
  003ec	3b 8d f8 fd ff
	ff		 cmp	 ecx, DWORD PTR _uv_range$[ebp+8]
  003f2	0f 8d d2 01 00
	00		 jge	 $LN1@convert_yv

; 580  :         const int x_fin = width - crop_right;

  003f8	8b 53 10	 mov	 edx, DWORD PTR _width$[ebx]
  003fb	2b 55 f0	 sub	 edx, DWORD PTR _crop_right$[ebp]
  003fe	89 95 c8 fd ff
	ff		 mov	 DWORD PTR _x_fin$20[ebp], edx

; 581  :         uint16_t *src_u_ptr = srcULine;

  00404	8b 85 d8 fd ff
	ff		 mov	 eax, DWORD PTR _srcULine$[ebp]
  0040a	89 85 c4 fd ff
	ff		 mov	 DWORD PTR _src_u_ptr$19[ebp], eax

; 582  :         uint16_t *src_v_ptr = srcVLine;

  00410	8b 8d d4 fd ff
	ff		 mov	 ecx, DWORD PTR _srcVLine$[ebp]
  00416	89 8d c0 fd ff
	ff		 mov	 DWORD PTR _src_v_ptr$18[ebp], ecx

; 583  :         uint8_t *dst_ptr = dstLine;

  0041c	8b 95 d0 fd ff
	ff		 mov	 edx, DWORD PTR _dstLine$[ebp]
  00422	89 95 bc fd ff
	ff		 mov	 DWORD PTR _dst_ptr$17[ebp], edx

; 584  :         uint8_t *dst_ptr_fin = dst_ptr + x_fin;

  00428	8b 85 bc fd ff
	ff		 mov	 eax, DWORD PTR _dst_ptr$17[ebp]
  0042e	03 85 c8 fd ff
	ff		 add	 eax, DWORD PTR _x_fin$20[ebp]
  00434	89 85 b8 fd ff
	ff		 mov	 DWORD PTR _dst_ptr_fin$16[ebp], eax

; 585  :         __m256i y0, y1;
; 586  :         for (; dst_ptr < dst_ptr_fin; src_u_ptr += 16, src_v_ptr += 16, dst_ptr += 32) {

  0043a	eb 2d		 jmp	 SHORT $LN13@convert_yv
$LN11@convert_yv:
  0043c	8b 8d c4 fd ff
	ff		 mov	 ecx, DWORD PTR _src_u_ptr$19[ebp]
  00442	83 c1 20	 add	 ecx, 32			; 00000020H
  00445	89 8d c4 fd ff
	ff		 mov	 DWORD PTR _src_u_ptr$19[ebp], ecx
  0044b	8b 95 c0 fd ff
	ff		 mov	 edx, DWORD PTR _src_v_ptr$18[ebp]
  00451	83 c2 20	 add	 edx, 32			; 00000020H
  00454	89 95 c0 fd ff
	ff		 mov	 DWORD PTR _src_v_ptr$18[ebp], edx
  0045a	8b 85 bc fd ff
	ff		 mov	 eax, DWORD PTR _dst_ptr$17[ebp]
  00460	83 c0 20	 add	 eax, 32			; 00000020H
  00463	89 85 bc fd ff
	ff		 mov	 DWORD PTR _dst_ptr$17[ebp], eax
$LN13@convert_yv:
  00469	8b 8d bc fd ff
	ff		 mov	 ecx, DWORD PTR _dst_ptr$17[ebp]
  0046f	3b 8d b8 fd ff
	ff		 cmp	 ecx, DWORD PTR _dst_ptr_fin$16[ebp]
  00475	0f 83 4a 01 00
	00		 jae	 $LN12@convert_yv

; 587  :             y0 = _mm256_loadu_si256((const __m256i *)src_u_ptr);

  0047b	8b 95 c4 fd ff
	ff		 mov	 edx, DWORD PTR _src_u_ptr$19[ebp]
  00481	c5 fe 6f 02	 vmovdqu ymm0, YMMWORD PTR [edx]
  00485	c5 fe 7f 85 40
	fd ff ff	 vmovdqu YMMWORD PTR $T13[ebp], ymm0
  0048d	c5 fe 6f 85 40
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T13[ebp]
  00495	c5 fe 7f 85 80
	fd ff ff	 vmovdqu YMMWORD PTR _y0$15[ebp], ymm0

; 588  :             y1 = _mm256_loadu_si256((const __m256i *)src_v_ptr);

  0049d	8b 85 c0 fd ff
	ff		 mov	 eax, DWORD PTR _src_v_ptr$18[ebp]
  004a3	c5 fe 6f 00	 vmovdqu ymm0, YMMWORD PTR [eax]
  004a7	c5 fe 7f 85 20
	fd ff ff	 vmovdqu YMMWORD PTR $T12[ebp], ymm0
  004af	c5 fe 6f 85 20
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T12[ebp]
  004b7	c5 fe 7f 85 60
	fd ff ff	 vmovdqu YMMWORD PTR _y1$14[ebp], ymm0

; 589  : 
; 590  :             y0 = _mm256_srli_epi16(y0, in_bit_depth - 8);

  004bf	c5 fe 6f 85 80
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR _y0$15[ebp]
  004c7	c5 fd 71 d0 04	 vpsrlw	 ymm0, ymm0, 4
  004cc	c5 fe 7f 85 00
	fd ff ff	 vmovdqu YMMWORD PTR $T11[ebp], ymm0
  004d4	c5 fe 6f 85 00
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T11[ebp]
  004dc	c5 fe 7f 85 80
	fd ff ff	 vmovdqu YMMWORD PTR _y0$15[ebp], ymm0

; 591  :             y1 = _mm256_slli_epi16(y1, 16 - in_bit_depth);

  004e4	c5 fe 6f 85 60
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR _y1$14[ebp]
  004ec	c5 fd 71 f0 04	 vpsllw	 ymm0, ymm0, 4
  004f1	c5 fe 7f 85 e0
	fc ff ff	 vmovdqu YMMWORD PTR $T10[ebp], ymm0
  004f9	c5 fe 6f 85 e0
	fc ff ff	 vmovdqu ymm0, YMMWORD PTR $T10[ebp]
  00501	c5 fe 7f 85 60
	fd ff ff	 vmovdqu YMMWORD PTR _y1$14[ebp], ymm0

; 592  :             const __m256i xMaskHighByte = _mm256_slli_epi16(_mm256_cmpeq_epi8(_mm256_setzero_si256(), _mm256_setzero_si256()), 8);

  00509	c5 f9 ef c0	 vpxor	 xmm0, xmm0, xmm0
  0050d	c5 fe 7f 85 80
	fc ff ff	 vmovdqu YMMWORD PTR $T7[ebp], ymm0
  00515	c5 f9 ef c0	 vpxor	 xmm0, xmm0, xmm0
  00519	c5 fe 7f 85 a0
	fc ff ff	 vmovdqu YMMWORD PTR $T8[ebp], ymm0
  00521	c5 fe 6f 85 a0
	fc ff ff	 vmovdqu ymm0, YMMWORD PTR $T8[ebp]
  00529	c5 fd 74 85 80
	fc ff ff	 vpcmpeqb ymm0, ymm0, YMMWORD PTR $T7[ebp]
  00531	c5 fe 7f 85 60
	fc ff ff	 vmovdqu YMMWORD PTR $T6[ebp], ymm0
  00539	c5 fe 6f 85 60
	fc ff ff	 vmovdqu ymm0, YMMWORD PTR $T6[ebp]
  00541	c5 fd 71 f0 08	 vpsllw	 ymm0, ymm0, 8
  00546	c5 fe 7f 85 40
	fc ff ff	 vmovdqu YMMWORD PTR $T5[ebp], ymm0
  0054e	c5 fe 6f 85 40
	fc ff ff	 vmovdqu ymm0, YMMWORD PTR $T5[ebp]
  00556	c5 fe 7f 85 c0
	fc ff ff	 vmovdqu YMMWORD PTR _xMaskHighByte$9[ebp], ymm0

; 593  :             y1 = _mm256_and_si256(y1, xMaskHighByte);

  0055e	c5 fe 6f 85 60
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR _y1$14[ebp]
  00566	c5 fd db 85 c0
	fc ff ff	 vpand	 ymm0, ymm0, YMMWORD PTR _xMaskHighByte$9[ebp]
  0056e	c5 fe 7f 85 20
	fc ff ff	 vmovdqu YMMWORD PTR $T4[ebp], ymm0
  00576	c5 fe 6f 85 20
	fc ff ff	 vmovdqu ymm0, YMMWORD PTR $T4[ebp]
  0057e	c5 fe 7f 85 60
	fd ff ff	 vmovdqu YMMWORD PTR _y1$14[ebp], ymm0

; 594  : 
; 595  :             y0 = _mm256_or_si256(y0, y1);

  00586	c5 fe 6f 85 80
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR _y0$15[ebp]
  0058e	c5 fd eb 85 60
	fd ff ff	 vpor	 ymm0, ymm0, YMMWORD PTR _y1$14[ebp]
  00596	c5 fe 7f 85 00
	fc ff ff	 vmovdqu YMMWORD PTR $T3[ebp], ymm0
  0059e	c5 fe 6f 85 00
	fc ff ff	 vmovdqu ymm0, YMMWORD PTR $T3[ebp]
  005a6	c5 fe 7f 85 80
	fd ff ff	 vmovdqu YMMWORD PTR _y0$15[ebp], ymm0

; 596  : 
; 597  :             _mm256_storeu_si256((__m256i *)(dst_ptr +  0), y0);

  005ae	c5 fe 6f 85 80
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR _y0$15[ebp]
  005b6	8b 8d bc fd ff
	ff		 mov	 ecx, DWORD PTR _dst_ptr$17[ebp]
  005bc	c5 fe 7f 01	 vmovdqu YMMWORD PTR [ecx], ymm0

; 598  :         }

  005c0	e9 77 fe ff ff	 jmp	 $LN11@convert_yv
$LN12@convert_yv:

; 599  :     }

  005c5	e9 d4 fd ff ff	 jmp	 $LN8@convert_yv
$LN1@convert_yv:

; 600  : }

  005ca	52		 push	 edx
  005cb	8b cd		 mov	 ecx, ebp
  005cd	50		 push	 eax
  005ce	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN19@convert_yv
  005d4	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  005d9	58		 pop	 eax
  005da	5a		 pop	 edx
  005db	5f		 pop	 edi
  005dc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005df	33 cd		 xor	 ecx, ebp
  005e1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005e6	8b e5		 mov	 esp, ebp
  005e8	5d		 pop	 ebp
  005e9	8b e3		 mov	 esp, ebx
  005eb	5b		 pop	 ebx
  005ec	c3		 ret	 0
  005ed	0f 1f 00	 npad	 3
$LN19@convert_yv:
  005f0	02 00 00 00	 DD	 2
  005f4	00 00 00 00	 DD	 $LN18@convert_yv
$LN18@convert_yv:
  005f8	d8 ff ff ff	 DD	 -40			; ffffffd8H
  005fc	0c 00 00 00	 DD	 12			; 0000000cH
  00600	00 00 00 00	 DD	 $LN16@convert_yv
  00604	f0 fd ff ff	 DD	 -528			; fffffdf0H
  00608	0c 00 00 00	 DD	 12			; 0000000cH
  0060c	00 00 00 00	 DD	 $LN17@convert_yv
$LN17@convert_yv:
  00610	75		 DB	 117			; 00000075H
  00611	76		 DB	 118			; 00000076H
  00612	5f		 DB	 95			; 0000005fH
  00613	72		 DB	 114			; 00000072H
  00614	61		 DB	 97			; 00000061H
  00615	6e		 DB	 110			; 0000006eH
  00616	67		 DB	 103			; 00000067H
  00617	65		 DB	 101			; 00000065H
  00618	00		 DB	 0
$LN16@convert_yv:
  00619	79		 DB	 121			; 00000079H
  0061a	5f		 DB	 95			; 0000005fH
  0061b	72		 DB	 114			; 00000072H
  0061c	61		 DB	 97			; 00000061H
  0061d	6e		 DB	 110			; 0000006eH
  0061e	67		 DB	 103			; 00000067H
  0061f	65		 DB	 101			; 00000065H
  00620	00		 DB	 0
??$convert_yv12_high_to_nv12_avx2_base@$0M@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_high_to_nv12_avx2_base<12,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yv12_12_to_nv12_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_12_to_nv12_avx2

; 611  : void convert_yv12_12_to_nv12_avx2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 612  :     convert_yv12_high_to_nv12_avx2_base<12, false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yv12_high_to_nv12_avx2_base@$0M@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_high_to_nv12_avx2_base<12,0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 613  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yv12_12_to_nv12_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_12_to_nv12_avx2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
$T1 = -1056						; size = 12
$T2 = -1040						; size = 12
$T3 = -1024						; size = 32
$T4 = -992						; size = 32
$T5 = -960						; size = 32
$T6 = -928						; size = 32
$T7 = -896						; size = 32
$T8 = -864						; size = 32
_xMaskHighByte$9 = -832					; size = 32
$T10 = -800						; size = 32
$T11 = -768						; size = 32
$T12 = -736						; size = 32
$T13 = -704						; size = 32
_y1$14 = -672						; size = 32
_y0$15 = -640						; size = 32
_dst_ptr_fin$16 = -584					; size = 4
_dst_ptr$17 = -580					; size = 4
_src_v_ptr$18 = -576					; size = 4
_src_u_ptr$19 = -572					; size = 4
_x_fin$20 = -568					; size = 4
_y$21 = -564						; size = 4
_dstLine$ = -560					; size = 4
_srcVLine$ = -556					; size = 4
_srcULine$ = -552					; size = 4
_src_uv_pitch$ = -548					; size = 4
$T22 = -544						; size = 12
_uv_range$ = -528					; size = 12
$T23 = -512						; size = 32
$T24 = -480						; size = 32
$T25 = -448						; size = 32
$T26 = -416						; size = 32
$T27 = -368						; size = 16
$T28 = -352						; size = 32
$T29 = -304						; size = 16
$T30 = -288						; size = 32
$T31 = -240						; size = 16
$T32 = -224						; size = 32
$T33 = -176						; size = 16
_y1$34 = -160						; size = 32
_y0$35 = -128						; size = 32
_src_ptr_fin$36 = -84					; size = 4
_src_ptr$37 = -80					; size = 4
_dst_ptr$38 = -76					; size = 4
_y$39 = -72						; size = 4
_y_width$40 = -68					; size = 4
_dstLine$41 = -64					; size = 4
_srcYLine$42 = -60					; size = 4
$T43 = -56						; size = 12
_y_range$44 = -40					; size = 12
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yv12_high_to_nv12_avx2_base@$0O@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_high_to_nv12_avx2_base<14,0>

; 542  : static void convert_yv12_high_to_nv12_avx2_base(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 20 04 00
	00		 sub	 esp, 1056		; 00000420H
  0001c	57		 push	 edi
  0001d	8d bd e0 fb ff
	ff		 lea	 edi, DWORD PTR [ebp-1056]
  00023	b9 08 01 00 00	 mov	 ecx, 264		; 00000108H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 543  :     static_assert(8 < in_bit_depth && in_bit_depth <= 16, "in_bit_depth must be 9-16.");
; 544  :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 545  :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 546  :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 547  :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 548  :     const int src_y_pitch = src_y_pitch_byte >> 1;

  0007c	8b 53 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  0007f	d1 fa		 sar	 edx, 1
  00081	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 549  :     //Y
; 550  :     if (!uv_only) {

  00084	b8 01 00 00 00	 mov	 eax, 1
  00089	85 c0		 test	 eax, eax
  0008b	0f 84 1f 02 00
	00		 je	 $LN14@convert_yv

; 551  :         const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00091	8b 4b 2c	 mov	 ecx, DWORD PTR _thread_n$[ebx]
  00094	51		 push	 ecx
  00095	8b 53 28	 mov	 edx, DWORD PTR _thread_id$[ebx]
  00098	52		 push	 edx
  00099	8b 43 20	 mov	 eax, DWORD PTR _height$[ebx]
  0009c	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  0009f	50		 push	 eax
  000a0	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  000a3	51		 push	 ecx
  000a4	8d 95 f0 fb ff
	ff		 lea	 edx, DWORD PTR $T2[ebp]
  000aa	52		 push	 edx
  000ab	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  000b0	83 c4 14	 add	 esp, 20			; 00000014H
  000b3	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b5	89 4d c8	 mov	 DWORD PTR $T43[ebp], ecx
  000b8	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000bb	89 55 cc	 mov	 DWORD PTR $T43[ebp+4], edx
  000be	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000c1	89 45 d0	 mov	 DWORD PTR $T43[ebp+8], eax
  000c4	8b 4d c8	 mov	 ecx, DWORD PTR $T43[ebp]
  000c7	89 4d d8	 mov	 DWORD PTR _y_range$44[ebp], ecx
  000ca	8b 55 cc	 mov	 edx, DWORD PTR $T43[ebp+4]
  000cd	89 55 dc	 mov	 DWORD PTR _y_range$44[ebp+4], edx
  000d0	8b 45 d0	 mov	 eax, DWORD PTR $T43[ebp+8]
  000d3	89 45 e0	 mov	 DWORD PTR _y_range$44[ebp+8], eax

; 552  :         uint16_t *srcYLine = (uint16_t *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000d6	b9 04 00 00 00	 mov	 ecx, 4
  000db	6b d1 00	 imul	 edx, ecx, 0
  000de	8b 45 e8	 mov	 eax, DWORD PTR _src_y_pitch$[ebp]
  000e1	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$44[ebp]
  000e5	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  000e8	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  000eb	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  000ee	8b 4d f8	 mov	 ecx, DWORD PTR _crop_left$[ebp]
  000f1	8d 14 48	 lea	 edx, DWORD PTR [eax+ecx*2]
  000f4	89 55 c4	 mov	 DWORD PTR _srcYLine$42[ebp], edx

; 553  :         uint8_t *dstLine  = (uint8_t *)dst[0] + dst_y_pitch_byte * y_range.start_dst;;

  000f7	b8 04 00 00 00	 mov	 eax, 4
  000fc	6b c8 00	 imul	 ecx, eax, 0
  000ff	8b 53 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebx]
  00102	0f af 55 dc	 imul	 edx, DWORD PTR _y_range$44[ebp+4]
  00106	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  00109	03 14 08	 add	 edx, DWORD PTR [eax+ecx]
  0010c	89 55 c0	 mov	 DWORD PTR _dstLine$41[ebp], edx

; 554  :         const int y_width = width - crop_right - crop_left;

  0010f	8b 4b 10	 mov	 ecx, DWORD PTR _width$[ebx]
  00112	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  00115	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  00118	89 4d bc	 mov	 DWORD PTR _y_width$40[ebp], ecx

; 555  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch_byte) {

  0011b	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _y$39[ebp], 0
  00122	eb 1e		 jmp	 SHORT $LN4@convert_yv
$LN2@convert_yv:
  00124	8b 55 b8	 mov	 edx, DWORD PTR _y$39[ebp]
  00127	83 c2 01	 add	 edx, 1
  0012a	89 55 b8	 mov	 DWORD PTR _y$39[ebp], edx
  0012d	8b 45 e8	 mov	 eax, DWORD PTR _src_y_pitch$[ebp]
  00130	8b 4d c4	 mov	 ecx, DWORD PTR _srcYLine$42[ebp]
  00133	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00136	89 55 c4	 mov	 DWORD PTR _srcYLine$42[ebp], edx
  00139	8b 45 c0	 mov	 eax, DWORD PTR _dstLine$41[ebp]
  0013c	03 43 1c	 add	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  0013f	89 45 c0	 mov	 DWORD PTR _dstLine$41[ebp], eax
$LN4@convert_yv:
  00142	8b 4d b8	 mov	 ecx, DWORD PTR _y$39[ebp]
  00145	3b 4d e0	 cmp	 ecx, DWORD PTR _y_range$44[ebp+8]
  00148	0f 8d 62 01 00
	00		 jge	 $LN14@convert_yv

; 556  :             uint8_t *dst_ptr = dstLine;

  0014e	8b 55 c0	 mov	 edx, DWORD PTR _dstLine$41[ebp]
  00151	89 55 b4	 mov	 DWORD PTR _dst_ptr$38[ebp], edx

; 557  :             uint16_t *src_ptr = srcYLine;

  00154	8b 45 c4	 mov	 eax, DWORD PTR _srcYLine$42[ebp]
  00157	89 45 b0	 mov	 DWORD PTR _src_ptr$37[ebp], eax

; 558  :             uint16_t *src_ptr_fin = src_ptr + y_width;

  0015a	8b 4d bc	 mov	 ecx, DWORD PTR _y_width$40[ebp]
  0015d	8b 55 b0	 mov	 edx, DWORD PTR _src_ptr$37[ebp]
  00160	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  00163	89 45 ac	 mov	 DWORD PTR _src_ptr_fin$36[ebp], eax

; 559  :             __m256i y0, y1;
; 560  :             for (; src_ptr < src_ptr_fin; dst_ptr += 32, src_ptr += 32) {

  00166	eb 12		 jmp	 SHORT $LN7@convert_yv
$LN5@convert_yv:
  00168	8b 4d b4	 mov	 ecx, DWORD PTR _dst_ptr$38[ebp]
  0016b	83 c1 20	 add	 ecx, 32			; 00000020H
  0016e	89 4d b4	 mov	 DWORD PTR _dst_ptr$38[ebp], ecx
  00171	8b 55 b0	 mov	 edx, DWORD PTR _src_ptr$37[ebp]
  00174	83 c2 40	 add	 edx, 64			; 00000040H
  00177	89 55 b0	 mov	 DWORD PTR _src_ptr$37[ebp], edx
$LN7@convert_yv:
  0017a	8b 45 b0	 mov	 eax, DWORD PTR _src_ptr$37[ebp]
  0017d	3b 45 ac	 cmp	 eax, DWORD PTR _src_ptr_fin$36[ebp]
  00180	0f 83 25 01 00
	00		 jae	 $LN6@convert_yv

; 561  :                 y0 = _mm256_set_m128i(_mm_loadu_si128((__m128i*)(src_ptr + 16)), _mm_loadu_si128((__m128i*)(src_ptr +  0)));

  00186	8b 4d b0	 mov	 ecx, DWORD PTR _src_ptr$37[ebp]
  00189	83 c1 20	 add	 ecx, 32			; 00000020H
  0018c	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  0018f	0f 29 85 10 ff
	ff ff		 movaps	 XMMWORD PTR $T31[ebp], xmm0
  00196	8b 55 b0	 mov	 edx, DWORD PTR _src_ptr$37[ebp]
  00199	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  0019c	0f 29 85 50 ff
	ff ff		 movaps	 XMMWORD PTR $T33[ebp], xmm0
  001a3	c5 fa 6f 85 50
	ff ff ff	 vmovdqu xmm0, XMMWORD PTR $T33[ebp]
  001ab	c5 fe 7f 85 20
	ff ff ff	 vmovdqu YMMWORD PTR $T32[ebp], ymm0
  001b3	c5 fe 6f 85 20
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T32[ebp]
  001bb	c4 e3 7d 18 85
	10 ff ff ff 01	 vinsertf128 ymm0, ymm0, XMMWORD PTR $T31[ebp], 1
  001c5	c5 fe 7f 85 e0
	fe ff ff	 vmovdqu YMMWORD PTR $T30[ebp], ymm0
  001cd	c5 fe 6f 85 e0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T30[ebp]
  001d5	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _y0$35[ebp], ymm0

; 562  :                 y1 = _mm256_set_m128i(_mm_loadu_si128((__m128i*)(src_ptr + 24)), _mm_loadu_si128((__m128i*)(src_ptr +  8)));

  001da	8b 45 b0	 mov	 eax, DWORD PTR _src_ptr$37[ebp]
  001dd	83 c0 30	 add	 eax, 48			; 00000030H
  001e0	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  001e3	0f 29 85 90 fe
	ff ff		 movaps	 XMMWORD PTR $T27[ebp], xmm0
  001ea	8b 4d b0	 mov	 ecx, DWORD PTR _src_ptr$37[ebp]
  001ed	83 c1 10	 add	 ecx, 16			; 00000010H
  001f0	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  001f3	0f 29 85 d0 fe
	ff ff		 movaps	 XMMWORD PTR $T29[ebp], xmm0
  001fa	c5 fa 6f 85 d0
	fe ff ff	 vmovdqu xmm0, XMMWORD PTR $T29[ebp]
  00202	c5 fe 7f 85 a0
	fe ff ff	 vmovdqu YMMWORD PTR $T28[ebp], ymm0
  0020a	c5 fe 6f 85 a0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T28[ebp]
  00212	c4 e3 7d 18 85
	90 fe ff ff 01	 vinsertf128 ymm0, ymm0, XMMWORD PTR $T27[ebp], 1
  0021c	c5 fe 7f 85 60
	fe ff ff	 vmovdqu YMMWORD PTR $T26[ebp], ymm0
  00224	c5 fe 6f 85 60
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T26[ebp]
  0022c	c5 fe 7f 85 60
	ff ff ff	 vmovdqu YMMWORD PTR _y1$34[ebp], ymm0

; 563  : 
; 564  :                 y0 = _mm256_srli_epi16(y0, in_bit_depth - 8);

  00234	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR _y0$35[ebp]
  00239	c5 fd 71 d0 06	 vpsrlw	 ymm0, ymm0, 6
  0023e	c5 fe 7f 85 40
	fe ff ff	 vmovdqu YMMWORD PTR $T25[ebp], ymm0
  00246	c5 fe 6f 85 40
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T25[ebp]
  0024e	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _y0$35[ebp], ymm0

; 565  :                 y1 = _mm256_srli_epi16(y1, in_bit_depth - 8);

  00253	c5 fe 6f 85 60
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR _y1$34[ebp]
  0025b	c5 fd 71 d0 06	 vpsrlw	 ymm0, ymm0, 6
  00260	c5 fe 7f 85 20
	fe ff ff	 vmovdqu YMMWORD PTR $T24[ebp], ymm0
  00268	c5 fe 6f 85 20
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T24[ebp]
  00270	c5 fe 7f 85 60
	ff ff ff	 vmovdqu YMMWORD PTR _y1$34[ebp], ymm0

; 566  : 
; 567  :                 y0 = _mm256_packus_epi16(y0, y1);

  00278	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR _y0$35[ebp]
  0027d	c5 fd 67 85 60
	ff ff ff	 vpackuswb ymm0, ymm0, YMMWORD PTR _y1$34[ebp]
  00285	c5 fe 7f 85 00
	fe ff ff	 vmovdqu YMMWORD PTR $T23[ebp], ymm0
  0028d	c5 fe 6f 85 00
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T23[ebp]
  00295	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _y0$35[ebp], ymm0

; 568  : 
; 569  :                 _mm256_storeu_si256((__m256i *)(dst_ptr + 0), y0);

  0029a	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR _y0$35[ebp]
  0029f	8b 55 b4	 mov	 edx, DWORD PTR _dst_ptr$38[ebp]
  002a2	c5 fe 7f 02	 vmovdqu YMMWORD PTR [edx], ymm0

; 570  :             }

  002a6	e9 bd fe ff ff	 jmp	 $LN5@convert_yv
$LN6@convert_yv:

; 571  :         }

  002ab	e9 74 fe ff ff	 jmp	 $LN2@convert_yv
$LN14@convert_yv:

; 572  :     }
; 573  :     //UV
; 574  :     const auto uv_range = thread_y_range(crop_up >> 1, (height - crop_bottom) >> 1, thread_id, thread_n);

  002b0	8b 43 2c	 mov	 eax, DWORD PTR _thread_n$[ebx]
  002b3	50		 push	 eax
  002b4	8b 4b 28	 mov	 ecx, DWORD PTR _thread_id$[ebx]
  002b7	51		 push	 ecx
  002b8	8b 53 20	 mov	 edx, DWORD PTR _height$[ebx]
  002bb	2b 55 ec	 sub	 edx, DWORD PTR _crop_bottom$[ebp]
  002be	d1 fa		 sar	 edx, 1
  002c0	52		 push	 edx
  002c1	8b 45 f4	 mov	 eax, DWORD PTR _crop_up$[ebp]
  002c4	d1 f8		 sar	 eax, 1
  002c6	50		 push	 eax
  002c7	8d 8d e0 fb ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  002cd	51		 push	 ecx
  002ce	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  002d3	83 c4 14	 add	 esp, 20			; 00000014H
  002d6	8b 10		 mov	 edx, DWORD PTR [eax]
  002d8	89 95 e0 fd ff
	ff		 mov	 DWORD PTR $T22[ebp], edx
  002de	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  002e1	89 8d e4 fd ff
	ff		 mov	 DWORD PTR $T22[ebp+4], ecx
  002e7	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  002ea	89 95 e8 fd ff
	ff		 mov	 DWORD PTR $T22[ebp+8], edx
  002f0	8b 85 e0 fd ff
	ff		 mov	 eax, DWORD PTR $T22[ebp]
  002f6	89 85 f0 fd ff
	ff		 mov	 DWORD PTR _uv_range$[ebp], eax
  002fc	8b 8d e4 fd ff
	ff		 mov	 ecx, DWORD PTR $T22[ebp+4]
  00302	89 8d f4 fd ff
	ff		 mov	 DWORD PTR _uv_range$[ebp+4], ecx
  00308	8b 95 e8 fd ff
	ff		 mov	 edx, DWORD PTR $T22[ebp+8]
  0030e	89 95 f8 fd ff
	ff		 mov	 DWORD PTR _uv_range$[ebp+8], edx

; 575  :     const int src_uv_pitch = src_uv_pitch_byte >> 1;

  00314	8b 43 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebx]
  00317	d1 f8		 sar	 eax, 1
  00319	89 85 dc fd ff
	ff		 mov	 DWORD PTR _src_uv_pitch$[ebp], eax

; 576  :     uint16_t *srcULine = (uint16_t *)src[1] + ((src_uv_pitch * uv_range.start_src) + (crop_left >> 1));

  0031f	b9 04 00 00 00	 mov	 ecx, 4
  00324	c1 e1 00	 shl	 ecx, 0
  00327	8b 95 dc fd ff
	ff		 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  0032d	0f af 95 f0 fd
	ff ff		 imul	 edx, DWORD PTR _uv_range$[ebp]
  00334	8b 45 f8	 mov	 eax, DWORD PTR _crop_left$[ebp]
  00337	d1 f8		 sar	 eax, 1
  00339	03 d0		 add	 edx, eax
  0033b	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  0033e	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  00341	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  00344	89 95 d8 fd ff
	ff		 mov	 DWORD PTR _srcULine$[ebp], edx

; 577  :     uint16_t *srcVLine = (uint16_t *)src[2] + ((src_uv_pitch * uv_range.start_src) + (crop_left >> 1));

  0034a	b8 04 00 00 00	 mov	 eax, 4
  0034f	d1 e0		 shl	 eax, 1
  00351	8b 8d dc fd ff
	ff		 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00357	0f af 8d f0 fd
	ff ff		 imul	 ecx, DWORD PTR _uv_range$[ebp]
  0035e	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  00361	d1 fa		 sar	 edx, 1
  00363	03 ca		 add	 ecx, edx
  00365	8b 53 0c	 mov	 edx, DWORD PTR _src$[ebx]
  00368	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  0036b	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  0036e	89 8d d4 fd ff
	ff		 mov	 DWORD PTR _srcVLine$[ebp], ecx

; 578  :     uint8_t *dstLine  = (uint8_t *)dst[1] + dst_y_pitch_byte * uv_range.start_dst;

  00374	ba 04 00 00 00	 mov	 edx, 4
  00379	c1 e2 00	 shl	 edx, 0
  0037c	8b 43 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  0037f	0f af 85 f4 fd
	ff ff		 imul	 eax, DWORD PTR _uv_range$[ebp+4]
  00386	8b 4b 08	 mov	 ecx, DWORD PTR _dst$[ebx]
  00389	03 04 11	 add	 eax, DWORD PTR [ecx+edx]
  0038c	89 85 d0 fd ff
	ff		 mov	 DWORD PTR _dstLine$[ebp], eax

; 579  :     for (int y = 0; y < uv_range.len; y++, srcULine += src_uv_pitch, srcVLine += src_uv_pitch, dstLine += dst_y_pitch_byte) {

  00392	c7 85 cc fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _y$21[ebp], 0
  0039c	eb 48		 jmp	 SHORT $LN10@convert_yv
$LN8@convert_yv:
  0039e	8b 95 cc fd ff
	ff		 mov	 edx, DWORD PTR _y$21[ebp]
  003a4	83 c2 01	 add	 edx, 1
  003a7	89 95 cc fd ff
	ff		 mov	 DWORD PTR _y$21[ebp], edx
  003ad	8b 85 dc fd ff
	ff		 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  003b3	8b 8d d8 fd ff
	ff		 mov	 ecx, DWORD PTR _srcULine$[ebp]
  003b9	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  003bc	89 95 d8 fd ff
	ff		 mov	 DWORD PTR _srcULine$[ebp], edx
  003c2	8b 85 dc fd ff
	ff		 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  003c8	8b 8d d4 fd ff
	ff		 mov	 ecx, DWORD PTR _srcVLine$[ebp]
  003ce	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  003d1	89 95 d4 fd ff
	ff		 mov	 DWORD PTR _srcVLine$[ebp], edx
  003d7	8b 85 d0 fd ff
	ff		 mov	 eax, DWORD PTR _dstLine$[ebp]
  003dd	03 43 1c	 add	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  003e0	89 85 d0 fd ff
	ff		 mov	 DWORD PTR _dstLine$[ebp], eax
$LN10@convert_yv:
  003e6	8b 8d cc fd ff
	ff		 mov	 ecx, DWORD PTR _y$21[ebp]
  003ec	3b 8d f8 fd ff
	ff		 cmp	 ecx, DWORD PTR _uv_range$[ebp+8]
  003f2	0f 8d d2 01 00
	00		 jge	 $LN1@convert_yv

; 580  :         const int x_fin = width - crop_right;

  003f8	8b 53 10	 mov	 edx, DWORD PTR _width$[ebx]
  003fb	2b 55 f0	 sub	 edx, DWORD PTR _crop_right$[ebp]
  003fe	89 95 c8 fd ff
	ff		 mov	 DWORD PTR _x_fin$20[ebp], edx

; 581  :         uint16_t *src_u_ptr = srcULine;

  00404	8b 85 d8 fd ff
	ff		 mov	 eax, DWORD PTR _srcULine$[ebp]
  0040a	89 85 c4 fd ff
	ff		 mov	 DWORD PTR _src_u_ptr$19[ebp], eax

; 582  :         uint16_t *src_v_ptr = srcVLine;

  00410	8b 8d d4 fd ff
	ff		 mov	 ecx, DWORD PTR _srcVLine$[ebp]
  00416	89 8d c0 fd ff
	ff		 mov	 DWORD PTR _src_v_ptr$18[ebp], ecx

; 583  :         uint8_t *dst_ptr = dstLine;

  0041c	8b 95 d0 fd ff
	ff		 mov	 edx, DWORD PTR _dstLine$[ebp]
  00422	89 95 bc fd ff
	ff		 mov	 DWORD PTR _dst_ptr$17[ebp], edx

; 584  :         uint8_t *dst_ptr_fin = dst_ptr + x_fin;

  00428	8b 85 bc fd ff
	ff		 mov	 eax, DWORD PTR _dst_ptr$17[ebp]
  0042e	03 85 c8 fd ff
	ff		 add	 eax, DWORD PTR _x_fin$20[ebp]
  00434	89 85 b8 fd ff
	ff		 mov	 DWORD PTR _dst_ptr_fin$16[ebp], eax

; 585  :         __m256i y0, y1;
; 586  :         for (; dst_ptr < dst_ptr_fin; src_u_ptr += 16, src_v_ptr += 16, dst_ptr += 32) {

  0043a	eb 2d		 jmp	 SHORT $LN13@convert_yv
$LN11@convert_yv:
  0043c	8b 8d c4 fd ff
	ff		 mov	 ecx, DWORD PTR _src_u_ptr$19[ebp]
  00442	83 c1 20	 add	 ecx, 32			; 00000020H
  00445	89 8d c4 fd ff
	ff		 mov	 DWORD PTR _src_u_ptr$19[ebp], ecx
  0044b	8b 95 c0 fd ff
	ff		 mov	 edx, DWORD PTR _src_v_ptr$18[ebp]
  00451	83 c2 20	 add	 edx, 32			; 00000020H
  00454	89 95 c0 fd ff
	ff		 mov	 DWORD PTR _src_v_ptr$18[ebp], edx
  0045a	8b 85 bc fd ff
	ff		 mov	 eax, DWORD PTR _dst_ptr$17[ebp]
  00460	83 c0 20	 add	 eax, 32			; 00000020H
  00463	89 85 bc fd ff
	ff		 mov	 DWORD PTR _dst_ptr$17[ebp], eax
$LN13@convert_yv:
  00469	8b 8d bc fd ff
	ff		 mov	 ecx, DWORD PTR _dst_ptr$17[ebp]
  0046f	3b 8d b8 fd ff
	ff		 cmp	 ecx, DWORD PTR _dst_ptr_fin$16[ebp]
  00475	0f 83 4a 01 00
	00		 jae	 $LN12@convert_yv

; 587  :             y0 = _mm256_loadu_si256((const __m256i *)src_u_ptr);

  0047b	8b 95 c4 fd ff
	ff		 mov	 edx, DWORD PTR _src_u_ptr$19[ebp]
  00481	c5 fe 6f 02	 vmovdqu ymm0, YMMWORD PTR [edx]
  00485	c5 fe 7f 85 40
	fd ff ff	 vmovdqu YMMWORD PTR $T13[ebp], ymm0
  0048d	c5 fe 6f 85 40
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T13[ebp]
  00495	c5 fe 7f 85 80
	fd ff ff	 vmovdqu YMMWORD PTR _y0$15[ebp], ymm0

; 588  :             y1 = _mm256_loadu_si256((const __m256i *)src_v_ptr);

  0049d	8b 85 c0 fd ff
	ff		 mov	 eax, DWORD PTR _src_v_ptr$18[ebp]
  004a3	c5 fe 6f 00	 vmovdqu ymm0, YMMWORD PTR [eax]
  004a7	c5 fe 7f 85 20
	fd ff ff	 vmovdqu YMMWORD PTR $T12[ebp], ymm0
  004af	c5 fe 6f 85 20
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T12[ebp]
  004b7	c5 fe 7f 85 60
	fd ff ff	 vmovdqu YMMWORD PTR _y1$14[ebp], ymm0

; 589  : 
; 590  :             y0 = _mm256_srli_epi16(y0, in_bit_depth - 8);

  004bf	c5 fe 6f 85 80
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR _y0$15[ebp]
  004c7	c5 fd 71 d0 06	 vpsrlw	 ymm0, ymm0, 6
  004cc	c5 fe 7f 85 00
	fd ff ff	 vmovdqu YMMWORD PTR $T11[ebp], ymm0
  004d4	c5 fe 6f 85 00
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T11[ebp]
  004dc	c5 fe 7f 85 80
	fd ff ff	 vmovdqu YMMWORD PTR _y0$15[ebp], ymm0

; 591  :             y1 = _mm256_slli_epi16(y1, 16 - in_bit_depth);

  004e4	c5 fe 6f 85 60
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR _y1$14[ebp]
  004ec	c5 fd 71 f0 02	 vpsllw	 ymm0, ymm0, 2
  004f1	c5 fe 7f 85 e0
	fc ff ff	 vmovdqu YMMWORD PTR $T10[ebp], ymm0
  004f9	c5 fe 6f 85 e0
	fc ff ff	 vmovdqu ymm0, YMMWORD PTR $T10[ebp]
  00501	c5 fe 7f 85 60
	fd ff ff	 vmovdqu YMMWORD PTR _y1$14[ebp], ymm0

; 592  :             const __m256i xMaskHighByte = _mm256_slli_epi16(_mm256_cmpeq_epi8(_mm256_setzero_si256(), _mm256_setzero_si256()), 8);

  00509	c5 f9 ef c0	 vpxor	 xmm0, xmm0, xmm0
  0050d	c5 fe 7f 85 80
	fc ff ff	 vmovdqu YMMWORD PTR $T7[ebp], ymm0
  00515	c5 f9 ef c0	 vpxor	 xmm0, xmm0, xmm0
  00519	c5 fe 7f 85 a0
	fc ff ff	 vmovdqu YMMWORD PTR $T8[ebp], ymm0
  00521	c5 fe 6f 85 a0
	fc ff ff	 vmovdqu ymm0, YMMWORD PTR $T8[ebp]
  00529	c5 fd 74 85 80
	fc ff ff	 vpcmpeqb ymm0, ymm0, YMMWORD PTR $T7[ebp]
  00531	c5 fe 7f 85 60
	fc ff ff	 vmovdqu YMMWORD PTR $T6[ebp], ymm0
  00539	c5 fe 6f 85 60
	fc ff ff	 vmovdqu ymm0, YMMWORD PTR $T6[ebp]
  00541	c5 fd 71 f0 08	 vpsllw	 ymm0, ymm0, 8
  00546	c5 fe 7f 85 40
	fc ff ff	 vmovdqu YMMWORD PTR $T5[ebp], ymm0
  0054e	c5 fe 6f 85 40
	fc ff ff	 vmovdqu ymm0, YMMWORD PTR $T5[ebp]
  00556	c5 fe 7f 85 c0
	fc ff ff	 vmovdqu YMMWORD PTR _xMaskHighByte$9[ebp], ymm0

; 593  :             y1 = _mm256_and_si256(y1, xMaskHighByte);

  0055e	c5 fe 6f 85 60
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR _y1$14[ebp]
  00566	c5 fd db 85 c0
	fc ff ff	 vpand	 ymm0, ymm0, YMMWORD PTR _xMaskHighByte$9[ebp]
  0056e	c5 fe 7f 85 20
	fc ff ff	 vmovdqu YMMWORD PTR $T4[ebp], ymm0
  00576	c5 fe 6f 85 20
	fc ff ff	 vmovdqu ymm0, YMMWORD PTR $T4[ebp]
  0057e	c5 fe 7f 85 60
	fd ff ff	 vmovdqu YMMWORD PTR _y1$14[ebp], ymm0

; 594  : 
; 595  :             y0 = _mm256_or_si256(y0, y1);

  00586	c5 fe 6f 85 80
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR _y0$15[ebp]
  0058e	c5 fd eb 85 60
	fd ff ff	 vpor	 ymm0, ymm0, YMMWORD PTR _y1$14[ebp]
  00596	c5 fe 7f 85 00
	fc ff ff	 vmovdqu YMMWORD PTR $T3[ebp], ymm0
  0059e	c5 fe 6f 85 00
	fc ff ff	 vmovdqu ymm0, YMMWORD PTR $T3[ebp]
  005a6	c5 fe 7f 85 80
	fd ff ff	 vmovdqu YMMWORD PTR _y0$15[ebp], ymm0

; 596  : 
; 597  :             _mm256_storeu_si256((__m256i *)(dst_ptr +  0), y0);

  005ae	c5 fe 6f 85 80
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR _y0$15[ebp]
  005b6	8b 8d bc fd ff
	ff		 mov	 ecx, DWORD PTR _dst_ptr$17[ebp]
  005bc	c5 fe 7f 01	 vmovdqu YMMWORD PTR [ecx], ymm0

; 598  :         }

  005c0	e9 77 fe ff ff	 jmp	 $LN11@convert_yv
$LN12@convert_yv:

; 599  :     }

  005c5	e9 d4 fd ff ff	 jmp	 $LN8@convert_yv
$LN1@convert_yv:

; 600  : }

  005ca	52		 push	 edx
  005cb	8b cd		 mov	 ecx, ebp
  005cd	50		 push	 eax
  005ce	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN19@convert_yv
  005d4	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  005d9	58		 pop	 eax
  005da	5a		 pop	 edx
  005db	5f		 pop	 edi
  005dc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005df	33 cd		 xor	 ecx, ebp
  005e1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005e6	8b e5		 mov	 esp, ebp
  005e8	5d		 pop	 ebp
  005e9	8b e3		 mov	 esp, ebx
  005eb	5b		 pop	 ebx
  005ec	c3		 ret	 0
  005ed	0f 1f 00	 npad	 3
$LN19@convert_yv:
  005f0	02 00 00 00	 DD	 2
  005f4	00 00 00 00	 DD	 $LN18@convert_yv
$LN18@convert_yv:
  005f8	d8 ff ff ff	 DD	 -40			; ffffffd8H
  005fc	0c 00 00 00	 DD	 12			; 0000000cH
  00600	00 00 00 00	 DD	 $LN16@convert_yv
  00604	f0 fd ff ff	 DD	 -528			; fffffdf0H
  00608	0c 00 00 00	 DD	 12			; 0000000cH
  0060c	00 00 00 00	 DD	 $LN17@convert_yv
$LN17@convert_yv:
  00610	75		 DB	 117			; 00000075H
  00611	76		 DB	 118			; 00000076H
  00612	5f		 DB	 95			; 0000005fH
  00613	72		 DB	 114			; 00000072H
  00614	61		 DB	 97			; 00000061H
  00615	6e		 DB	 110			; 0000006eH
  00616	67		 DB	 103			; 00000067H
  00617	65		 DB	 101			; 00000065H
  00618	00		 DB	 0
$LN16@convert_yv:
  00619	79		 DB	 121			; 00000079H
  0061a	5f		 DB	 95			; 0000005fH
  0061b	72		 DB	 114			; 00000072H
  0061c	61		 DB	 97			; 00000061H
  0061d	6e		 DB	 110			; 0000006eH
  0061e	67		 DB	 103			; 00000067H
  0061f	65		 DB	 101			; 00000065H
  00620	00		 DB	 0
??$convert_yv12_high_to_nv12_avx2_base@$0O@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_high_to_nv12_avx2_base<14,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yv12_14_to_nv12_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_14_to_nv12_avx2

; 607  : void convert_yv12_14_to_nv12_avx2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 608  :     convert_yv12_high_to_nv12_avx2_base<14, false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yv12_high_to_nv12_avx2_base@$0O@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_high_to_nv12_avx2_base<14,0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 609  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yv12_14_to_nv12_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_14_to_nv12_avx2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
$T1 = -1056						; size = 12
$T2 = -1040						; size = 12
$T3 = -1024						; size = 32
$T4 = -992						; size = 32
$T5 = -960						; size = 32
$T6 = -928						; size = 32
$T7 = -896						; size = 32
$T8 = -864						; size = 32
_xMaskHighByte$9 = -832					; size = 32
$T10 = -800						; size = 32
$T11 = -768						; size = 32
$T12 = -736						; size = 32
$T13 = -704						; size = 32
_y1$14 = -672						; size = 32
_y0$15 = -640						; size = 32
_dst_ptr_fin$16 = -584					; size = 4
_dst_ptr$17 = -580					; size = 4
_src_v_ptr$18 = -576					; size = 4
_src_u_ptr$19 = -572					; size = 4
_x_fin$20 = -568					; size = 4
_y$21 = -564						; size = 4
_dstLine$ = -560					; size = 4
_srcVLine$ = -556					; size = 4
_srcULine$ = -552					; size = 4
_src_uv_pitch$ = -548					; size = 4
$T22 = -544						; size = 12
_uv_range$ = -528					; size = 12
$T23 = -512						; size = 32
$T24 = -480						; size = 32
$T25 = -448						; size = 32
$T26 = -416						; size = 32
$T27 = -368						; size = 16
$T28 = -352						; size = 32
$T29 = -304						; size = 16
$T30 = -288						; size = 32
$T31 = -240						; size = 16
$T32 = -224						; size = 32
$T33 = -176						; size = 16
_y1$34 = -160						; size = 32
_y0$35 = -128						; size = 32
_src_ptr_fin$36 = -84					; size = 4
_src_ptr$37 = -80					; size = 4
_dst_ptr$38 = -76					; size = 4
_y$39 = -72						; size = 4
_y_width$40 = -68					; size = 4
_dstLine$41 = -64					; size = 4
_srcYLine$42 = -60					; size = 4
$T43 = -56						; size = 12
_y_range$44 = -40					; size = 12
_src_y_pitch$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yv12_high_to_nv12_avx2_base@$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_high_to_nv12_avx2_base<16,0>

; 542  : static void convert_yv12_high_to_nv12_avx2_base(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 20 04 00
	00		 sub	 esp, 1056		; 00000420H
  0001c	57		 push	 edi
  0001d	8d bd e0 fb ff
	ff		 lea	 edi, DWORD PTR [ebp-1056]
  00023	b9 08 01 00 00	 mov	 ecx, 264		; 00000108H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 543  :     static_assert(8 < in_bit_depth && in_bit_depth <= 16, "in_bit_depth must be 9-16.");
; 544  :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 545  :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 546  :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 547  :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 548  :     const int src_y_pitch = src_y_pitch_byte >> 1;

  0007c	8b 53 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  0007f	d1 fa		 sar	 edx, 1
  00081	89 55 e8	 mov	 DWORD PTR _src_y_pitch$[ebp], edx

; 549  :     //Y
; 550  :     if (!uv_only) {

  00084	b8 01 00 00 00	 mov	 eax, 1
  00089	85 c0		 test	 eax, eax
  0008b	0f 84 1f 02 00
	00		 je	 $LN14@convert_yv

; 551  :         const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00091	8b 4b 2c	 mov	 ecx, DWORD PTR _thread_n$[ebx]
  00094	51		 push	 ecx
  00095	8b 53 28	 mov	 edx, DWORD PTR _thread_id$[ebx]
  00098	52		 push	 edx
  00099	8b 43 20	 mov	 eax, DWORD PTR _height$[ebx]
  0009c	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  0009f	50		 push	 eax
  000a0	8b 4d f4	 mov	 ecx, DWORD PTR _crop_up$[ebp]
  000a3	51		 push	 ecx
  000a4	8d 95 f0 fb ff
	ff		 lea	 edx, DWORD PTR $T2[ebp]
  000aa	52		 push	 edx
  000ab	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  000b0	83 c4 14	 add	 esp, 20			; 00000014H
  000b3	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b5	89 4d c8	 mov	 DWORD PTR $T43[ebp], ecx
  000b8	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000bb	89 55 cc	 mov	 DWORD PTR $T43[ebp+4], edx
  000be	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000c1	89 45 d0	 mov	 DWORD PTR $T43[ebp+8], eax
  000c4	8b 4d c8	 mov	 ecx, DWORD PTR $T43[ebp]
  000c7	89 4d d8	 mov	 DWORD PTR _y_range$44[ebp], ecx
  000ca	8b 55 cc	 mov	 edx, DWORD PTR $T43[ebp+4]
  000cd	89 55 dc	 mov	 DWORD PTR _y_range$44[ebp+4], edx
  000d0	8b 45 d0	 mov	 eax, DWORD PTR $T43[ebp+8]
  000d3	89 45 e0	 mov	 DWORD PTR _y_range$44[ebp+8], eax

; 552  :         uint16_t *srcYLine = (uint16_t *)src[0] + src_y_pitch * y_range.start_src + crop_left;

  000d6	b9 04 00 00 00	 mov	 ecx, 4
  000db	6b d1 00	 imul	 edx, ecx, 0
  000de	8b 45 e8	 mov	 eax, DWORD PTR _src_y_pitch$[ebp]
  000e1	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$44[ebp]
  000e5	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  000e8	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  000eb	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  000ee	8b 4d f8	 mov	 ecx, DWORD PTR _crop_left$[ebp]
  000f1	8d 14 48	 lea	 edx, DWORD PTR [eax+ecx*2]
  000f4	89 55 c4	 mov	 DWORD PTR _srcYLine$42[ebp], edx

; 553  :         uint8_t *dstLine  = (uint8_t *)dst[0] + dst_y_pitch_byte * y_range.start_dst;;

  000f7	b8 04 00 00 00	 mov	 eax, 4
  000fc	6b c8 00	 imul	 ecx, eax, 0
  000ff	8b 53 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebx]
  00102	0f af 55 dc	 imul	 edx, DWORD PTR _y_range$44[ebp+4]
  00106	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  00109	03 14 08	 add	 edx, DWORD PTR [eax+ecx]
  0010c	89 55 c0	 mov	 DWORD PTR _dstLine$41[ebp], edx

; 554  :         const int y_width = width - crop_right - crop_left;

  0010f	8b 4b 10	 mov	 ecx, DWORD PTR _width$[ebx]
  00112	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  00115	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  00118	89 4d bc	 mov	 DWORD PTR _y_width$40[ebp], ecx

; 555  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch, dstLine += dst_y_pitch_byte) {

  0011b	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _y$39[ebp], 0
  00122	eb 1e		 jmp	 SHORT $LN4@convert_yv
$LN2@convert_yv:
  00124	8b 55 b8	 mov	 edx, DWORD PTR _y$39[ebp]
  00127	83 c2 01	 add	 edx, 1
  0012a	89 55 b8	 mov	 DWORD PTR _y$39[ebp], edx
  0012d	8b 45 e8	 mov	 eax, DWORD PTR _src_y_pitch$[ebp]
  00130	8b 4d c4	 mov	 ecx, DWORD PTR _srcYLine$42[ebp]
  00133	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00136	89 55 c4	 mov	 DWORD PTR _srcYLine$42[ebp], edx
  00139	8b 45 c0	 mov	 eax, DWORD PTR _dstLine$41[ebp]
  0013c	03 43 1c	 add	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  0013f	89 45 c0	 mov	 DWORD PTR _dstLine$41[ebp], eax
$LN4@convert_yv:
  00142	8b 4d b8	 mov	 ecx, DWORD PTR _y$39[ebp]
  00145	3b 4d e0	 cmp	 ecx, DWORD PTR _y_range$44[ebp+8]
  00148	0f 8d 62 01 00
	00		 jge	 $LN14@convert_yv

; 556  :             uint8_t *dst_ptr = dstLine;

  0014e	8b 55 c0	 mov	 edx, DWORD PTR _dstLine$41[ebp]
  00151	89 55 b4	 mov	 DWORD PTR _dst_ptr$38[ebp], edx

; 557  :             uint16_t *src_ptr = srcYLine;

  00154	8b 45 c4	 mov	 eax, DWORD PTR _srcYLine$42[ebp]
  00157	89 45 b0	 mov	 DWORD PTR _src_ptr$37[ebp], eax

; 558  :             uint16_t *src_ptr_fin = src_ptr + y_width;

  0015a	8b 4d bc	 mov	 ecx, DWORD PTR _y_width$40[ebp]
  0015d	8b 55 b0	 mov	 edx, DWORD PTR _src_ptr$37[ebp]
  00160	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  00163	89 45 ac	 mov	 DWORD PTR _src_ptr_fin$36[ebp], eax

; 559  :             __m256i y0, y1;
; 560  :             for (; src_ptr < src_ptr_fin; dst_ptr += 32, src_ptr += 32) {

  00166	eb 12		 jmp	 SHORT $LN7@convert_yv
$LN5@convert_yv:
  00168	8b 4d b4	 mov	 ecx, DWORD PTR _dst_ptr$38[ebp]
  0016b	83 c1 20	 add	 ecx, 32			; 00000020H
  0016e	89 4d b4	 mov	 DWORD PTR _dst_ptr$38[ebp], ecx
  00171	8b 55 b0	 mov	 edx, DWORD PTR _src_ptr$37[ebp]
  00174	83 c2 40	 add	 edx, 64			; 00000040H
  00177	89 55 b0	 mov	 DWORD PTR _src_ptr$37[ebp], edx
$LN7@convert_yv:
  0017a	8b 45 b0	 mov	 eax, DWORD PTR _src_ptr$37[ebp]
  0017d	3b 45 ac	 cmp	 eax, DWORD PTR _src_ptr_fin$36[ebp]
  00180	0f 83 25 01 00
	00		 jae	 $LN6@convert_yv

; 561  :                 y0 = _mm256_set_m128i(_mm_loadu_si128((__m128i*)(src_ptr + 16)), _mm_loadu_si128((__m128i*)(src_ptr +  0)));

  00186	8b 4d b0	 mov	 ecx, DWORD PTR _src_ptr$37[ebp]
  00189	83 c1 20	 add	 ecx, 32			; 00000020H
  0018c	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  0018f	0f 29 85 10 ff
	ff ff		 movaps	 XMMWORD PTR $T31[ebp], xmm0
  00196	8b 55 b0	 mov	 edx, DWORD PTR _src_ptr$37[ebp]
  00199	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  0019c	0f 29 85 50 ff
	ff ff		 movaps	 XMMWORD PTR $T33[ebp], xmm0
  001a3	c5 fa 6f 85 50
	ff ff ff	 vmovdqu xmm0, XMMWORD PTR $T33[ebp]
  001ab	c5 fe 7f 85 20
	ff ff ff	 vmovdqu YMMWORD PTR $T32[ebp], ymm0
  001b3	c5 fe 6f 85 20
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T32[ebp]
  001bb	c4 e3 7d 18 85
	10 ff ff ff 01	 vinsertf128 ymm0, ymm0, XMMWORD PTR $T31[ebp], 1
  001c5	c5 fe 7f 85 e0
	fe ff ff	 vmovdqu YMMWORD PTR $T30[ebp], ymm0
  001cd	c5 fe 6f 85 e0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T30[ebp]
  001d5	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _y0$35[ebp], ymm0

; 562  :                 y1 = _mm256_set_m128i(_mm_loadu_si128((__m128i*)(src_ptr + 24)), _mm_loadu_si128((__m128i*)(src_ptr +  8)));

  001da	8b 45 b0	 mov	 eax, DWORD PTR _src_ptr$37[ebp]
  001dd	83 c0 30	 add	 eax, 48			; 00000030H
  001e0	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  001e3	0f 29 85 90 fe
	ff ff		 movaps	 XMMWORD PTR $T27[ebp], xmm0
  001ea	8b 4d b0	 mov	 ecx, DWORD PTR _src_ptr$37[ebp]
  001ed	83 c1 10	 add	 ecx, 16			; 00000010H
  001f0	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  001f3	0f 29 85 d0 fe
	ff ff		 movaps	 XMMWORD PTR $T29[ebp], xmm0
  001fa	c5 fa 6f 85 d0
	fe ff ff	 vmovdqu xmm0, XMMWORD PTR $T29[ebp]
  00202	c5 fe 7f 85 a0
	fe ff ff	 vmovdqu YMMWORD PTR $T28[ebp], ymm0
  0020a	c5 fe 6f 85 a0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T28[ebp]
  00212	c4 e3 7d 18 85
	90 fe ff ff 01	 vinsertf128 ymm0, ymm0, XMMWORD PTR $T27[ebp], 1
  0021c	c5 fe 7f 85 60
	fe ff ff	 vmovdqu YMMWORD PTR $T26[ebp], ymm0
  00224	c5 fe 6f 85 60
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T26[ebp]
  0022c	c5 fe 7f 85 60
	ff ff ff	 vmovdqu YMMWORD PTR _y1$34[ebp], ymm0

; 563  : 
; 564  :                 y0 = _mm256_srli_epi16(y0, in_bit_depth - 8);

  00234	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR _y0$35[ebp]
  00239	c5 fd 71 d0 08	 vpsrlw	 ymm0, ymm0, 8
  0023e	c5 fe 7f 85 40
	fe ff ff	 vmovdqu YMMWORD PTR $T25[ebp], ymm0
  00246	c5 fe 6f 85 40
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T25[ebp]
  0024e	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _y0$35[ebp], ymm0

; 565  :                 y1 = _mm256_srli_epi16(y1, in_bit_depth - 8);

  00253	c5 fe 6f 85 60
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR _y1$34[ebp]
  0025b	c5 fd 71 d0 08	 vpsrlw	 ymm0, ymm0, 8
  00260	c5 fe 7f 85 20
	fe ff ff	 vmovdqu YMMWORD PTR $T24[ebp], ymm0
  00268	c5 fe 6f 85 20
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T24[ebp]
  00270	c5 fe 7f 85 60
	ff ff ff	 vmovdqu YMMWORD PTR _y1$34[ebp], ymm0

; 566  : 
; 567  :                 y0 = _mm256_packus_epi16(y0, y1);

  00278	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR _y0$35[ebp]
  0027d	c5 fd 67 85 60
	ff ff ff	 vpackuswb ymm0, ymm0, YMMWORD PTR _y1$34[ebp]
  00285	c5 fe 7f 85 00
	fe ff ff	 vmovdqu YMMWORD PTR $T23[ebp], ymm0
  0028d	c5 fe 6f 85 00
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T23[ebp]
  00295	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _y0$35[ebp], ymm0

; 568  : 
; 569  :                 _mm256_storeu_si256((__m256i *)(dst_ptr + 0), y0);

  0029a	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR _y0$35[ebp]
  0029f	8b 55 b4	 mov	 edx, DWORD PTR _dst_ptr$38[ebp]
  002a2	c5 fe 7f 02	 vmovdqu YMMWORD PTR [edx], ymm0

; 570  :             }

  002a6	e9 bd fe ff ff	 jmp	 $LN5@convert_yv
$LN6@convert_yv:

; 571  :         }

  002ab	e9 74 fe ff ff	 jmp	 $LN2@convert_yv
$LN14@convert_yv:

; 572  :     }
; 573  :     //UV
; 574  :     const auto uv_range = thread_y_range(crop_up >> 1, (height - crop_bottom) >> 1, thread_id, thread_n);

  002b0	8b 43 2c	 mov	 eax, DWORD PTR _thread_n$[ebx]
  002b3	50		 push	 eax
  002b4	8b 4b 28	 mov	 ecx, DWORD PTR _thread_id$[ebx]
  002b7	51		 push	 ecx
  002b8	8b 53 20	 mov	 edx, DWORD PTR _height$[ebx]
  002bb	2b 55 ec	 sub	 edx, DWORD PTR _crop_bottom$[ebp]
  002be	d1 fa		 sar	 edx, 1
  002c0	52		 push	 edx
  002c1	8b 45 f4	 mov	 eax, DWORD PTR _crop_up$[ebp]
  002c4	d1 f8		 sar	 eax, 1
  002c6	50		 push	 eax
  002c7	8d 8d e0 fb ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  002cd	51		 push	 ecx
  002ce	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  002d3	83 c4 14	 add	 esp, 20			; 00000014H
  002d6	8b 10		 mov	 edx, DWORD PTR [eax]
  002d8	89 95 e0 fd ff
	ff		 mov	 DWORD PTR $T22[ebp], edx
  002de	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  002e1	89 8d e4 fd ff
	ff		 mov	 DWORD PTR $T22[ebp+4], ecx
  002e7	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  002ea	89 95 e8 fd ff
	ff		 mov	 DWORD PTR $T22[ebp+8], edx
  002f0	8b 85 e0 fd ff
	ff		 mov	 eax, DWORD PTR $T22[ebp]
  002f6	89 85 f0 fd ff
	ff		 mov	 DWORD PTR _uv_range$[ebp], eax
  002fc	8b 8d e4 fd ff
	ff		 mov	 ecx, DWORD PTR $T22[ebp+4]
  00302	89 8d f4 fd ff
	ff		 mov	 DWORD PTR _uv_range$[ebp+4], ecx
  00308	8b 95 e8 fd ff
	ff		 mov	 edx, DWORD PTR $T22[ebp+8]
  0030e	89 95 f8 fd ff
	ff		 mov	 DWORD PTR _uv_range$[ebp+8], edx

; 575  :     const int src_uv_pitch = src_uv_pitch_byte >> 1;

  00314	8b 43 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebx]
  00317	d1 f8		 sar	 eax, 1
  00319	89 85 dc fd ff
	ff		 mov	 DWORD PTR _src_uv_pitch$[ebp], eax

; 576  :     uint16_t *srcULine = (uint16_t *)src[1] + ((src_uv_pitch * uv_range.start_src) + (crop_left >> 1));

  0031f	b9 04 00 00 00	 mov	 ecx, 4
  00324	c1 e1 00	 shl	 ecx, 0
  00327	8b 95 dc fd ff
	ff		 mov	 edx, DWORD PTR _src_uv_pitch$[ebp]
  0032d	0f af 95 f0 fd
	ff ff		 imul	 edx, DWORD PTR _uv_range$[ebp]
  00334	8b 45 f8	 mov	 eax, DWORD PTR _crop_left$[ebp]
  00337	d1 f8		 sar	 eax, 1
  00339	03 d0		 add	 edx, eax
  0033b	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  0033e	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  00341	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  00344	89 95 d8 fd ff
	ff		 mov	 DWORD PTR _srcULine$[ebp], edx

; 577  :     uint16_t *srcVLine = (uint16_t *)src[2] + ((src_uv_pitch * uv_range.start_src) + (crop_left >> 1));

  0034a	b8 04 00 00 00	 mov	 eax, 4
  0034f	d1 e0		 shl	 eax, 1
  00351	8b 8d dc fd ff
	ff		 mov	 ecx, DWORD PTR _src_uv_pitch$[ebp]
  00357	0f af 8d f0 fd
	ff ff		 imul	 ecx, DWORD PTR _uv_range$[ebp]
  0035e	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  00361	d1 fa		 sar	 edx, 1
  00363	03 ca		 add	 ecx, edx
  00365	8b 53 0c	 mov	 edx, DWORD PTR _src$[ebx]
  00368	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  0036b	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  0036e	89 8d d4 fd ff
	ff		 mov	 DWORD PTR _srcVLine$[ebp], ecx

; 578  :     uint8_t *dstLine  = (uint8_t *)dst[1] + dst_y_pitch_byte * uv_range.start_dst;

  00374	ba 04 00 00 00	 mov	 edx, 4
  00379	c1 e2 00	 shl	 edx, 0
  0037c	8b 43 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  0037f	0f af 85 f4 fd
	ff ff		 imul	 eax, DWORD PTR _uv_range$[ebp+4]
  00386	8b 4b 08	 mov	 ecx, DWORD PTR _dst$[ebx]
  00389	03 04 11	 add	 eax, DWORD PTR [ecx+edx]
  0038c	89 85 d0 fd ff
	ff		 mov	 DWORD PTR _dstLine$[ebp], eax

; 579  :     for (int y = 0; y < uv_range.len; y++, srcULine += src_uv_pitch, srcVLine += src_uv_pitch, dstLine += dst_y_pitch_byte) {

  00392	c7 85 cc fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _y$21[ebp], 0
  0039c	eb 48		 jmp	 SHORT $LN10@convert_yv
$LN8@convert_yv:
  0039e	8b 95 cc fd ff
	ff		 mov	 edx, DWORD PTR _y$21[ebp]
  003a4	83 c2 01	 add	 edx, 1
  003a7	89 95 cc fd ff
	ff		 mov	 DWORD PTR _y$21[ebp], edx
  003ad	8b 85 dc fd ff
	ff		 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  003b3	8b 8d d8 fd ff
	ff		 mov	 ecx, DWORD PTR _srcULine$[ebp]
  003b9	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  003bc	89 95 d8 fd ff
	ff		 mov	 DWORD PTR _srcULine$[ebp], edx
  003c2	8b 85 dc fd ff
	ff		 mov	 eax, DWORD PTR _src_uv_pitch$[ebp]
  003c8	8b 8d d4 fd ff
	ff		 mov	 ecx, DWORD PTR _srcVLine$[ebp]
  003ce	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  003d1	89 95 d4 fd ff
	ff		 mov	 DWORD PTR _srcVLine$[ebp], edx
  003d7	8b 85 d0 fd ff
	ff		 mov	 eax, DWORD PTR _dstLine$[ebp]
  003dd	03 43 1c	 add	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  003e0	89 85 d0 fd ff
	ff		 mov	 DWORD PTR _dstLine$[ebp], eax
$LN10@convert_yv:
  003e6	8b 8d cc fd ff
	ff		 mov	 ecx, DWORD PTR _y$21[ebp]
  003ec	3b 8d f8 fd ff
	ff		 cmp	 ecx, DWORD PTR _uv_range$[ebp+8]
  003f2	0f 8d d2 01 00
	00		 jge	 $LN1@convert_yv

; 580  :         const int x_fin = width - crop_right;

  003f8	8b 53 10	 mov	 edx, DWORD PTR _width$[ebx]
  003fb	2b 55 f0	 sub	 edx, DWORD PTR _crop_right$[ebp]
  003fe	89 95 c8 fd ff
	ff		 mov	 DWORD PTR _x_fin$20[ebp], edx

; 581  :         uint16_t *src_u_ptr = srcULine;

  00404	8b 85 d8 fd ff
	ff		 mov	 eax, DWORD PTR _srcULine$[ebp]
  0040a	89 85 c4 fd ff
	ff		 mov	 DWORD PTR _src_u_ptr$19[ebp], eax

; 582  :         uint16_t *src_v_ptr = srcVLine;

  00410	8b 8d d4 fd ff
	ff		 mov	 ecx, DWORD PTR _srcVLine$[ebp]
  00416	89 8d c0 fd ff
	ff		 mov	 DWORD PTR _src_v_ptr$18[ebp], ecx

; 583  :         uint8_t *dst_ptr = dstLine;

  0041c	8b 95 d0 fd ff
	ff		 mov	 edx, DWORD PTR _dstLine$[ebp]
  00422	89 95 bc fd ff
	ff		 mov	 DWORD PTR _dst_ptr$17[ebp], edx

; 584  :         uint8_t *dst_ptr_fin = dst_ptr + x_fin;

  00428	8b 85 bc fd ff
	ff		 mov	 eax, DWORD PTR _dst_ptr$17[ebp]
  0042e	03 85 c8 fd ff
	ff		 add	 eax, DWORD PTR _x_fin$20[ebp]
  00434	89 85 b8 fd ff
	ff		 mov	 DWORD PTR _dst_ptr_fin$16[ebp], eax

; 585  :         __m256i y0, y1;
; 586  :         for (; dst_ptr < dst_ptr_fin; src_u_ptr += 16, src_v_ptr += 16, dst_ptr += 32) {

  0043a	eb 2d		 jmp	 SHORT $LN13@convert_yv
$LN11@convert_yv:
  0043c	8b 8d c4 fd ff
	ff		 mov	 ecx, DWORD PTR _src_u_ptr$19[ebp]
  00442	83 c1 20	 add	 ecx, 32			; 00000020H
  00445	89 8d c4 fd ff
	ff		 mov	 DWORD PTR _src_u_ptr$19[ebp], ecx
  0044b	8b 95 c0 fd ff
	ff		 mov	 edx, DWORD PTR _src_v_ptr$18[ebp]
  00451	83 c2 20	 add	 edx, 32			; 00000020H
  00454	89 95 c0 fd ff
	ff		 mov	 DWORD PTR _src_v_ptr$18[ebp], edx
  0045a	8b 85 bc fd ff
	ff		 mov	 eax, DWORD PTR _dst_ptr$17[ebp]
  00460	83 c0 20	 add	 eax, 32			; 00000020H
  00463	89 85 bc fd ff
	ff		 mov	 DWORD PTR _dst_ptr$17[ebp], eax
$LN13@convert_yv:
  00469	8b 8d bc fd ff
	ff		 mov	 ecx, DWORD PTR _dst_ptr$17[ebp]
  0046f	3b 8d b8 fd ff
	ff		 cmp	 ecx, DWORD PTR _dst_ptr_fin$16[ebp]
  00475	0f 83 4a 01 00
	00		 jae	 $LN12@convert_yv

; 587  :             y0 = _mm256_loadu_si256((const __m256i *)src_u_ptr);

  0047b	8b 95 c4 fd ff
	ff		 mov	 edx, DWORD PTR _src_u_ptr$19[ebp]
  00481	c5 fe 6f 02	 vmovdqu ymm0, YMMWORD PTR [edx]
  00485	c5 fe 7f 85 40
	fd ff ff	 vmovdqu YMMWORD PTR $T13[ebp], ymm0
  0048d	c5 fe 6f 85 40
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T13[ebp]
  00495	c5 fe 7f 85 80
	fd ff ff	 vmovdqu YMMWORD PTR _y0$15[ebp], ymm0

; 588  :             y1 = _mm256_loadu_si256((const __m256i *)src_v_ptr);

  0049d	8b 85 c0 fd ff
	ff		 mov	 eax, DWORD PTR _src_v_ptr$18[ebp]
  004a3	c5 fe 6f 00	 vmovdqu ymm0, YMMWORD PTR [eax]
  004a7	c5 fe 7f 85 20
	fd ff ff	 vmovdqu YMMWORD PTR $T12[ebp], ymm0
  004af	c5 fe 6f 85 20
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T12[ebp]
  004b7	c5 fe 7f 85 60
	fd ff ff	 vmovdqu YMMWORD PTR _y1$14[ebp], ymm0

; 589  : 
; 590  :             y0 = _mm256_srli_epi16(y0, in_bit_depth - 8);

  004bf	c5 fe 6f 85 80
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR _y0$15[ebp]
  004c7	c5 fd 71 d0 08	 vpsrlw	 ymm0, ymm0, 8
  004cc	c5 fe 7f 85 00
	fd ff ff	 vmovdqu YMMWORD PTR $T11[ebp], ymm0
  004d4	c5 fe 6f 85 00
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T11[ebp]
  004dc	c5 fe 7f 85 80
	fd ff ff	 vmovdqu YMMWORD PTR _y0$15[ebp], ymm0

; 591  :             y1 = _mm256_slli_epi16(y1, 16 - in_bit_depth);

  004e4	c5 fe 6f 85 60
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR _y1$14[ebp]
  004ec	c5 fd 71 f0 00	 vpsllw	 ymm0, ymm0, 0
  004f1	c5 fe 7f 85 e0
	fc ff ff	 vmovdqu YMMWORD PTR $T10[ebp], ymm0
  004f9	c5 fe 6f 85 e0
	fc ff ff	 vmovdqu ymm0, YMMWORD PTR $T10[ebp]
  00501	c5 fe 7f 85 60
	fd ff ff	 vmovdqu YMMWORD PTR _y1$14[ebp], ymm0

; 592  :             const __m256i xMaskHighByte = _mm256_slli_epi16(_mm256_cmpeq_epi8(_mm256_setzero_si256(), _mm256_setzero_si256()), 8);

  00509	c5 f9 ef c0	 vpxor	 xmm0, xmm0, xmm0
  0050d	c5 fe 7f 85 80
	fc ff ff	 vmovdqu YMMWORD PTR $T7[ebp], ymm0
  00515	c5 f9 ef c0	 vpxor	 xmm0, xmm0, xmm0
  00519	c5 fe 7f 85 a0
	fc ff ff	 vmovdqu YMMWORD PTR $T8[ebp], ymm0
  00521	c5 fe 6f 85 a0
	fc ff ff	 vmovdqu ymm0, YMMWORD PTR $T8[ebp]
  00529	c5 fd 74 85 80
	fc ff ff	 vpcmpeqb ymm0, ymm0, YMMWORD PTR $T7[ebp]
  00531	c5 fe 7f 85 60
	fc ff ff	 vmovdqu YMMWORD PTR $T6[ebp], ymm0
  00539	c5 fe 6f 85 60
	fc ff ff	 vmovdqu ymm0, YMMWORD PTR $T6[ebp]
  00541	c5 fd 71 f0 08	 vpsllw	 ymm0, ymm0, 8
  00546	c5 fe 7f 85 40
	fc ff ff	 vmovdqu YMMWORD PTR $T5[ebp], ymm0
  0054e	c5 fe 6f 85 40
	fc ff ff	 vmovdqu ymm0, YMMWORD PTR $T5[ebp]
  00556	c5 fe 7f 85 c0
	fc ff ff	 vmovdqu YMMWORD PTR _xMaskHighByte$9[ebp], ymm0

; 593  :             y1 = _mm256_and_si256(y1, xMaskHighByte);

  0055e	c5 fe 6f 85 60
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR _y1$14[ebp]
  00566	c5 fd db 85 c0
	fc ff ff	 vpand	 ymm0, ymm0, YMMWORD PTR _xMaskHighByte$9[ebp]
  0056e	c5 fe 7f 85 20
	fc ff ff	 vmovdqu YMMWORD PTR $T4[ebp], ymm0
  00576	c5 fe 6f 85 20
	fc ff ff	 vmovdqu ymm0, YMMWORD PTR $T4[ebp]
  0057e	c5 fe 7f 85 60
	fd ff ff	 vmovdqu YMMWORD PTR _y1$14[ebp], ymm0

; 594  : 
; 595  :             y0 = _mm256_or_si256(y0, y1);

  00586	c5 fe 6f 85 80
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR _y0$15[ebp]
  0058e	c5 fd eb 85 60
	fd ff ff	 vpor	 ymm0, ymm0, YMMWORD PTR _y1$14[ebp]
  00596	c5 fe 7f 85 00
	fc ff ff	 vmovdqu YMMWORD PTR $T3[ebp], ymm0
  0059e	c5 fe 6f 85 00
	fc ff ff	 vmovdqu ymm0, YMMWORD PTR $T3[ebp]
  005a6	c5 fe 7f 85 80
	fd ff ff	 vmovdqu YMMWORD PTR _y0$15[ebp], ymm0

; 596  : 
; 597  :             _mm256_storeu_si256((__m256i *)(dst_ptr +  0), y0);

  005ae	c5 fe 6f 85 80
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR _y0$15[ebp]
  005b6	8b 8d bc fd ff
	ff		 mov	 ecx, DWORD PTR _dst_ptr$17[ebp]
  005bc	c5 fe 7f 01	 vmovdqu YMMWORD PTR [ecx], ymm0

; 598  :         }

  005c0	e9 77 fe ff ff	 jmp	 $LN11@convert_yv
$LN12@convert_yv:

; 599  :     }

  005c5	e9 d4 fd ff ff	 jmp	 $LN8@convert_yv
$LN1@convert_yv:

; 600  : }

  005ca	52		 push	 edx
  005cb	8b cd		 mov	 ecx, ebp
  005cd	50		 push	 eax
  005ce	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN19@convert_yv
  005d4	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  005d9	58		 pop	 eax
  005da	5a		 pop	 edx
  005db	5f		 pop	 edi
  005dc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005df	33 cd		 xor	 ecx, ebp
  005e1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005e6	8b e5		 mov	 esp, ebp
  005e8	5d		 pop	 ebp
  005e9	8b e3		 mov	 esp, ebx
  005eb	5b		 pop	 ebx
  005ec	c3		 ret	 0
  005ed	0f 1f 00	 npad	 3
$LN19@convert_yv:
  005f0	02 00 00 00	 DD	 2
  005f4	00 00 00 00	 DD	 $LN18@convert_yv
$LN18@convert_yv:
  005f8	d8 ff ff ff	 DD	 -40			; ffffffd8H
  005fc	0c 00 00 00	 DD	 12			; 0000000cH
  00600	00 00 00 00	 DD	 $LN16@convert_yv
  00604	f0 fd ff ff	 DD	 -528			; fffffdf0H
  00608	0c 00 00 00	 DD	 12			; 0000000cH
  0060c	00 00 00 00	 DD	 $LN17@convert_yv
$LN17@convert_yv:
  00610	75		 DB	 117			; 00000075H
  00611	76		 DB	 118			; 00000076H
  00612	5f		 DB	 95			; 0000005fH
  00613	72		 DB	 114			; 00000072H
  00614	61		 DB	 97			; 00000061H
  00615	6e		 DB	 110			; 0000006eH
  00616	67		 DB	 103			; 00000067H
  00617	65		 DB	 101			; 00000065H
  00618	00		 DB	 0
$LN16@convert_yv:
  00619	79		 DB	 121			; 00000079H
  0061a	5f		 DB	 95			; 0000005fH
  0061b	72		 DB	 114			; 00000072H
  0061c	61		 DB	 97			; 00000061H
  0061d	6e		 DB	 110			; 0000006eH
  0061e	67		 DB	 103			; 00000067H
  0061f	65		 DB	 101			; 00000065H
  00620	00		 DB	 0
??$convert_yv12_high_to_nv12_avx2_base@$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_high_to_nv12_avx2_base<16,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yv12_16_to_nv12_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_16_to_nv12_avx2

; 603  : void convert_yv12_16_to_nv12_avx2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 604  :     convert_yv12_high_to_nv12_avx2_base<16, false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yv12_high_to_nv12_avx2_base@$0BA@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_high_to_nv12_avx2_base<16,0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 605  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yv12_16_to_nv12_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_16_to_nv12_avx2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
$T1 = -1504						; size = 12
$T2 = -1488						; size = 12
$T3 = -1472						; size = 32
$T4 = -1440						; size = 32
$T5 = -1408						; size = 32
$T6 = -1376						; size = 32
$T7 = -1344						; size = 32
$T8 = -1312						; size = 32
$T9 = -1280						; size = 32
$T10 = -1248						; size = 32
$T11 = -1216						; size = 32
$T12 = -1184						; size = 32
$T13 = -1152						; size = 32
$T14 = -1120						; size = 32
$T15 = -1088						; size = 32
$T16 = -1056						; size = 32
$T17 = -1024						; size = 32
$T18 = -992						; size = 32
$T19 = -960						; size = 32
$T20 = -928						; size = 32
$T21 = -896						; size = 32
$T22 = -864						; size = 32
$T23 = -832						; size = 32
$T24 = -800						; size = 32
$T25 = -768						; size = 32
$T26 = -736						; size = 32
_y3$27 = -704						; size = 32
_y2$28 = -672						; size = 32
_y1$29 = -640						; size = 32
_y0$30 = -608						; size = 32
_dst_ptr_fin$31 = -548					; size = 4
_dst_ptr$32 = -544					; size = 4
_src_v_ptr$33 = -540					; size = 4
_src_u_ptr$34 = -536					; size = 4
_x_fin$35 = -532					; size = 4
_y$36 = -528						; size = 4
_dstLine$ = -524					; size = 4
_srcVLine$ = -520					; size = 4
_srcULine$ = -516					; size = 4
$T37 = -512						; size = 12
_uv_range$ = -496					; size = 12
$T38 = -480						; size = 32
$T39 = -448						; size = 32
$T40 = -416						; size = 32
$T41 = -384						; size = 32
$T42 = -352						; size = 32
$T43 = -320						; size = 32
$T44 = -288						; size = 32
$T45 = -240						; size = 16
$T46 = -224						; size = 32
$T47 = -176						; size = 16
_y1$48 = -160						; size = 32
_y0$49 = -128						; size = 32
_src_ptr_fin$50 = -80					; size = 4
_src_ptr$51 = -76					; size = 4
_dst_ptr$52 = -72					; size = 4
_y$53 = -68						; size = 4
_y_width$54 = -64					; size = 4
_dstLine$55 = -60					; size = 4
_srcYLine$56 = -56					; size = 4
$T57 = -52						; size = 12
_y_range$58 = -36					; size = 12
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yv12_to_p010_avx2_base@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_to_p010_avx2_base<0>

; 464  : static void convert_yv12_to_p010_avx2_base(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec e0 05 00
	00		 sub	 esp, 1504		; 000005e0H
  0001c	57		 push	 edi
  0001d	8d bd 20 fa ff
	ff		 lea	 edi, DWORD PTR [ebp-1504]
  00023	b9 78 01 00 00	 mov	 ecx, 376		; 00000178H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 465  :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 466  :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 467  :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 468  :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 469  :     //Y
; 470  :     if (!uv_only) {

  0007c	ba 01 00 00 00	 mov	 edx, 1
  00081	85 d2		 test	 edx, edx
  00083	0f 84 1d 02 00
	00		 je	 $LN14@convert_yv

; 471  :         const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00089	8b 43 2c	 mov	 eax, DWORD PTR _thread_n$[ebx]
  0008c	50		 push	 eax
  0008d	8b 4b 28	 mov	 ecx, DWORD PTR _thread_id$[ebx]
  00090	51		 push	 ecx
  00091	8b 53 20	 mov	 edx, DWORD PTR _height$[ebx]
  00094	2b 55 ec	 sub	 edx, DWORD PTR _crop_bottom$[ebp]
  00097	52		 push	 edx
  00098	8b 45 f4	 mov	 eax, DWORD PTR _crop_up$[ebp]
  0009b	50		 push	 eax
  0009c	8d 8d 30 fa ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  000a2	51		 push	 ecx
  000a3	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  000a8	83 c4 14	 add	 esp, 20			; 00000014H
  000ab	8b 10		 mov	 edx, DWORD PTR [eax]
  000ad	89 55 cc	 mov	 DWORD PTR $T57[ebp], edx
  000b0	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000b3	89 4d d0	 mov	 DWORD PTR $T57[ebp+4], ecx
  000b6	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000b9	89 55 d4	 mov	 DWORD PTR $T57[ebp+8], edx
  000bc	8b 45 cc	 mov	 eax, DWORD PTR $T57[ebp]
  000bf	89 45 dc	 mov	 DWORD PTR _y_range$58[ebp], eax
  000c2	8b 4d d0	 mov	 ecx, DWORD PTR $T57[ebp+4]
  000c5	89 4d e0	 mov	 DWORD PTR _y_range$58[ebp+4], ecx
  000c8	8b 55 d4	 mov	 edx, DWORD PTR $T57[ebp+8]
  000cb	89 55 e4	 mov	 DWORD PTR _y_range$58[ebp+8], edx

; 472  :         uint8_t *srcYLine = (uint8_t *)src[0] + src_y_pitch_byte * y_range.start_src + crop_left;

  000ce	b8 04 00 00 00	 mov	 eax, 4
  000d3	6b c8 00	 imul	 ecx, eax, 0
  000d6	8b 53 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  000d9	0f af 55 dc	 imul	 edx, DWORD PTR _y_range$58[ebp]
  000dd	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  000e0	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  000e3	03 ca		 add	 ecx, edx
  000e5	03 4d f8	 add	 ecx, DWORD PTR _crop_left$[ebp]
  000e8	89 4d c8	 mov	 DWORD PTR _srcYLine$56[ebp], ecx

; 473  :         uint8_t *dstLine  = (uint8_t *)dst[0] + dst_y_pitch_byte * y_range.start_dst;

  000eb	ba 04 00 00 00	 mov	 edx, 4
  000f0	6b c2 00	 imul	 eax, edx, 0
  000f3	8b 4b 1c	 mov	 ecx, DWORD PTR _dst_y_pitch_byte$[ebx]
  000f6	0f af 4d e0	 imul	 ecx, DWORD PTR _y_range$58[ebp+4]
  000fa	8b 53 08	 mov	 edx, DWORD PTR _dst$[ebx]
  000fd	03 0c 02	 add	 ecx, DWORD PTR [edx+eax]
  00100	89 4d c4	 mov	 DWORD PTR _dstLine$55[ebp], ecx

; 474  :         const int y_width = width - crop_right - crop_left;

  00103	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  00106	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  00109	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  0010c	89 45 c0	 mov	 DWORD PTR _y_width$54[ebp], eax

; 475  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch_byte, dstLine += dst_y_pitch_byte) {

  0010f	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _y$53[ebp], 0
  00116	eb 1b		 jmp	 SHORT $LN4@convert_yv
$LN2@convert_yv:
  00118	8b 4d bc	 mov	 ecx, DWORD PTR _y$53[ebp]
  0011b	83 c1 01	 add	 ecx, 1
  0011e	89 4d bc	 mov	 DWORD PTR _y$53[ebp], ecx
  00121	8b 55 c8	 mov	 edx, DWORD PTR _srcYLine$56[ebp]
  00124	03 53 14	 add	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  00127	89 55 c8	 mov	 DWORD PTR _srcYLine$56[ebp], edx
  0012a	8b 45 c4	 mov	 eax, DWORD PTR _dstLine$55[ebp]
  0012d	03 43 1c	 add	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  00130	89 45 c4	 mov	 DWORD PTR _dstLine$55[ebp], eax
$LN4@convert_yv:
  00133	8b 4d bc	 mov	 ecx, DWORD PTR _y$53[ebp]
  00136	3b 4d e4	 cmp	 ecx, DWORD PTR _y_range$58[ebp+8]
  00139	0f 8d 67 01 00
	00		 jge	 $LN14@convert_yv

; 476  :             uint16_t *dst_ptr = (uint16_t *)dstLine;

  0013f	8b 55 c4	 mov	 edx, DWORD PTR _dstLine$55[ebp]
  00142	89 55 b8	 mov	 DWORD PTR _dst_ptr$52[ebp], edx

; 477  :             uint8_t *src_ptr = srcYLine;

  00145	8b 45 c8	 mov	 eax, DWORD PTR _srcYLine$56[ebp]
  00148	89 45 b4	 mov	 DWORD PTR _src_ptr$51[ebp], eax

; 478  :             uint8_t *src_ptr_fin = src_ptr + y_width;

  0014b	8b 4d b4	 mov	 ecx, DWORD PTR _src_ptr$51[ebp]
  0014e	03 4d c0	 add	 ecx, DWORD PTR _y_width$54[ebp]
  00151	89 4d b0	 mov	 DWORD PTR _src_ptr_fin$50[ebp], ecx

; 479  :             __m256i y0, y1;
; 480  :             for (; src_ptr < src_ptr_fin; dst_ptr += 32, src_ptr += 32) {

  00154	eb 12		 jmp	 SHORT $LN7@convert_yv
$LN5@convert_yv:
  00156	8b 55 b8	 mov	 edx, DWORD PTR _dst_ptr$52[ebp]
  00159	83 c2 40	 add	 edx, 64			; 00000040H
  0015c	89 55 b8	 mov	 DWORD PTR _dst_ptr$52[ebp], edx
  0015f	8b 45 b4	 mov	 eax, DWORD PTR _src_ptr$51[ebp]
  00162	83 c0 20	 add	 eax, 32			; 00000020H
  00165	89 45 b4	 mov	 DWORD PTR _src_ptr$51[ebp], eax
$LN7@convert_yv:
  00168	8b 4d b4	 mov	 ecx, DWORD PTR _src_ptr$51[ebp]
  0016b	3b 4d b0	 cmp	 ecx, DWORD PTR _src_ptr_fin$50[ebp]
  0016e	0f 83 2d 01 00
	00		 jae	 $LN6@convert_yv

; 481  :                 y0 = _mm256_cvtepu8_epi16(_mm_loadu_si128((const __m128i *)(src_ptr +  0)));

  00174	8b 55 b4	 mov	 edx, DWORD PTR _src_ptr$51[ebp]
  00177	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  0017a	0f 29 85 50 ff
	ff ff		 movaps	 XMMWORD PTR $T47[ebp], xmm0
  00181	c4 e2 7d 30 85
	50 ff ff ff	 vpmovzxbw ymm0, XMMWORD PTR $T47[ebp]
  0018a	c5 fe 7f 85 20
	ff ff ff	 vmovdqu YMMWORD PTR $T46[ebp], ymm0
  00192	c5 fe 6f 85 20
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T46[ebp]
  0019a	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _y0$49[ebp], ymm0

; 482  :                 y1 = _mm256_cvtepu8_epi16(_mm_loadu_si128((const __m128i *)(src_ptr + 16)));

  0019f	8b 45 b4	 mov	 eax, DWORD PTR _src_ptr$51[ebp]
  001a2	83 c0 10	 add	 eax, 16			; 00000010H
  001a5	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  001a8	0f 29 85 10 ff
	ff ff		 movaps	 XMMWORD PTR $T45[ebp], xmm0
  001af	c4 e2 7d 30 85
	10 ff ff ff	 vpmovzxbw ymm0, XMMWORD PTR $T45[ebp]
  001b8	c5 fe 7f 85 e0
	fe ff ff	 vmovdqu YMMWORD PTR $T44[ebp], ymm0
  001c0	c5 fe 6f 85 e0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T44[ebp]
  001c8	c5 fe 7f 85 60
	ff ff ff	 vmovdqu YMMWORD PTR _y1$48[ebp], ymm0

; 483  :                 y0 = _mm256_slli_epi16(y0, 8);

  001d0	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR _y0$49[ebp]
  001d5	c5 fd 71 f0 08	 vpsllw	 ymm0, ymm0, 8
  001da	c5 fe 7f 85 c0
	fe ff ff	 vmovdqu YMMWORD PTR $T43[ebp], ymm0
  001e2	c5 fe 6f 85 c0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T43[ebp]
  001ea	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _y0$49[ebp], ymm0

; 484  :                 y1 = _mm256_slli_epi16(y1, 8);

  001ef	c5 fe 6f 85 60
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR _y1$48[ebp]
  001f7	c5 fd 71 f0 08	 vpsllw	 ymm0, ymm0, 8
  001fc	c5 fe 7f 85 a0
	fe ff ff	 vmovdqu YMMWORD PTR $T42[ebp], ymm0
  00204	c5 fe 6f 85 a0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T42[ebp]
  0020c	c5 fe 7f 85 60
	ff ff ff	 vmovdqu YMMWORD PTR _y1$48[ebp], ymm0

; 485  :                 y0 = _mm256_add_epi16(y0, _mm256_set1_epi16(2 << 6));

  00214	c5 fe 6f 05 00
	00 00 00	 vmovdqu ymm0, YMMWORD PTR __ymm@0080008000800080008000800080008000800080008000800080008000800080
  0021c	c5 fe 7f 85 80
	fe ff ff	 vmovdqu YMMWORD PTR $T41[ebp], ymm0
  00224	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR _y0$49[ebp]
  00229	c5 fd fd 85 80
	fe ff ff	 vpaddw	 ymm0, ymm0, YMMWORD PTR $T41[ebp]
  00231	c5 fe 7f 85 60
	fe ff ff	 vmovdqu YMMWORD PTR $T40[ebp], ymm0
  00239	c5 fe 6f 85 60
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T40[ebp]
  00241	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _y0$49[ebp], ymm0

; 486  :                 y1 = _mm256_add_epi16(y1, _mm256_set1_epi16(2 << 6));

  00246	c5 fe 6f 05 00
	00 00 00	 vmovdqu ymm0, YMMWORD PTR __ymm@0080008000800080008000800080008000800080008000800080008000800080
  0024e	c5 fe 7f 85 40
	fe ff ff	 vmovdqu YMMWORD PTR $T39[ebp], ymm0
  00256	c5 fe 6f 85 60
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR _y1$48[ebp]
  0025e	c5 fd fd 85 40
	fe ff ff	 vpaddw	 ymm0, ymm0, YMMWORD PTR $T39[ebp]
  00266	c5 fe 7f 85 20
	fe ff ff	 vmovdqu YMMWORD PTR $T38[ebp], ymm0
  0026e	c5 fe 6f 85 20
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T38[ebp]
  00276	c5 fe 7f 85 60
	ff ff ff	 vmovdqu YMMWORD PTR _y1$48[ebp], ymm0

; 487  :                 _mm256_storeu_si256((__m256i *)(dst_ptr +  0), y0);

  0027e	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR _y0$49[ebp]
  00283	8b 4d b8	 mov	 ecx, DWORD PTR _dst_ptr$52[ebp]
  00286	c5 fe 7f 01	 vmovdqu YMMWORD PTR [ecx], ymm0

; 488  :                 _mm256_storeu_si256((__m256i *)(dst_ptr + 16), y1);

  0028a	c5 fe 6f 85 60
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR _y1$48[ebp]
  00292	8b 55 b8	 mov	 edx, DWORD PTR _dst_ptr$52[ebp]
  00295	83 c2 20	 add	 edx, 32			; 00000020H
  00298	c5 fe 7f 02	 vmovdqu YMMWORD PTR [edx], ymm0

; 489  :             }

  0029c	e9 b5 fe ff ff	 jmp	 $LN5@convert_yv
$LN6@convert_yv:

; 490  :         }

  002a1	e9 72 fe ff ff	 jmp	 $LN2@convert_yv
$LN14@convert_yv:

; 491  :     }
; 492  :     //UV
; 493  :     const auto uv_range = thread_y_range(crop_up >> 1, (height - crop_bottom) >> 1, thread_id, thread_n);

  002a6	8b 43 2c	 mov	 eax, DWORD PTR _thread_n$[ebx]
  002a9	50		 push	 eax
  002aa	8b 4b 28	 mov	 ecx, DWORD PTR _thread_id$[ebx]
  002ad	51		 push	 ecx
  002ae	8b 53 20	 mov	 edx, DWORD PTR _height$[ebx]
  002b1	2b 55 ec	 sub	 edx, DWORD PTR _crop_bottom$[ebp]
  002b4	d1 fa		 sar	 edx, 1
  002b6	52		 push	 edx
  002b7	8b 45 f4	 mov	 eax, DWORD PTR _crop_up$[ebp]
  002ba	d1 f8		 sar	 eax, 1
  002bc	50		 push	 eax
  002bd	8d 8d 20 fa ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  002c3	51		 push	 ecx
  002c4	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  002c9	83 c4 14	 add	 esp, 20			; 00000014H
  002cc	8b 10		 mov	 edx, DWORD PTR [eax]
  002ce	89 95 00 fe ff
	ff		 mov	 DWORD PTR $T37[ebp], edx
  002d4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  002d7	89 8d 04 fe ff
	ff		 mov	 DWORD PTR $T37[ebp+4], ecx
  002dd	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  002e0	89 95 08 fe ff
	ff		 mov	 DWORD PTR $T37[ebp+8], edx
  002e6	8b 85 00 fe ff
	ff		 mov	 eax, DWORD PTR $T37[ebp]
  002ec	89 85 10 fe ff
	ff		 mov	 DWORD PTR _uv_range$[ebp], eax
  002f2	8b 8d 04 fe ff
	ff		 mov	 ecx, DWORD PTR $T37[ebp+4]
  002f8	89 8d 14 fe ff
	ff		 mov	 DWORD PTR _uv_range$[ebp+4], ecx
  002fe	8b 95 08 fe ff
	ff		 mov	 edx, DWORD PTR $T37[ebp+8]
  00304	89 95 18 fe ff
	ff		 mov	 DWORD PTR _uv_range$[ebp+8], edx

; 494  :     uint8_t *srcULine = (uint8_t *)src[1] + ((src_uv_pitch_byte * uv_range.start_src) + (crop_left >> 1));

  0030a	b8 04 00 00 00	 mov	 eax, 4
  0030f	c1 e0 00	 shl	 eax, 0
  00312	8b 4b 18	 mov	 ecx, DWORD PTR _src_uv_pitch_byte$[ebx]
  00315	0f af 8d 10 fe
	ff ff		 imul	 ecx, DWORD PTR _uv_range$[ebp]
  0031c	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  0031f	d1 fa		 sar	 edx, 1
  00321	03 ca		 add	 ecx, edx
  00323	8b 53 0c	 mov	 edx, DWORD PTR _src$[ebx]
  00326	03 0c 02	 add	 ecx, DWORD PTR [edx+eax]
  00329	89 8d fc fd ff
	ff		 mov	 DWORD PTR _srcULine$[ebp], ecx

; 495  :     uint8_t *srcVLine = (uint8_t *)src[2] + ((src_uv_pitch_byte * uv_range.start_src) + (crop_left >> 1));

  0032f	b8 04 00 00 00	 mov	 eax, 4
  00334	d1 e0		 shl	 eax, 1
  00336	8b 4b 18	 mov	 ecx, DWORD PTR _src_uv_pitch_byte$[ebx]
  00339	0f af 8d 10 fe
	ff ff		 imul	 ecx, DWORD PTR _uv_range$[ebp]
  00340	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  00343	d1 fa		 sar	 edx, 1
  00345	03 ca		 add	 ecx, edx
  00347	8b 53 0c	 mov	 edx, DWORD PTR _src$[ebx]
  0034a	03 0c 02	 add	 ecx, DWORD PTR [edx+eax]
  0034d	89 8d f8 fd ff
	ff		 mov	 DWORD PTR _srcVLine$[ebp], ecx

; 496  :     uint8_t *dstLine  = (uint8_t *)dst[1] + dst_y_pitch_byte * uv_range.start_dst;

  00353	b8 04 00 00 00	 mov	 eax, 4
  00358	c1 e0 00	 shl	 eax, 0
  0035b	8b 4b 1c	 mov	 ecx, DWORD PTR _dst_y_pitch_byte$[ebx]
  0035e	0f af 8d 14 fe
	ff ff		 imul	 ecx, DWORD PTR _uv_range$[ebp+4]
  00365	8b 53 08	 mov	 edx, DWORD PTR _dst$[ebx]
  00368	03 0c 02	 add	 ecx, DWORD PTR [edx+eax]
  0036b	89 8d f4 fd ff
	ff		 mov	 DWORD PTR _dstLine$[ebp], ecx

; 497  :     for (int y = 0; y < uv_range.len; y++, srcULine += src_uv_pitch_byte, srcVLine += src_uv_pitch_byte, dstLine += dst_y_pitch_byte) {

  00371	c7 85 f0 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _y$36[ebp], 0
  0037b	eb 3c		 jmp	 SHORT $LN10@convert_yv
$LN8@convert_yv:
  0037d	8b 85 f0 fd ff
	ff		 mov	 eax, DWORD PTR _y$36[ebp]
  00383	83 c0 01	 add	 eax, 1
  00386	89 85 f0 fd ff
	ff		 mov	 DWORD PTR _y$36[ebp], eax
  0038c	8b 8d fc fd ff
	ff		 mov	 ecx, DWORD PTR _srcULine$[ebp]
  00392	03 4b 18	 add	 ecx, DWORD PTR _src_uv_pitch_byte$[ebx]
  00395	89 8d fc fd ff
	ff		 mov	 DWORD PTR _srcULine$[ebp], ecx
  0039b	8b 95 f8 fd ff
	ff		 mov	 edx, DWORD PTR _srcVLine$[ebp]
  003a1	03 53 18	 add	 edx, DWORD PTR _src_uv_pitch_byte$[ebx]
  003a4	89 95 f8 fd ff
	ff		 mov	 DWORD PTR _srcVLine$[ebp], edx
  003aa	8b 85 f4 fd ff
	ff		 mov	 eax, DWORD PTR _dstLine$[ebp]
  003b0	03 43 1c	 add	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  003b3	89 85 f4 fd ff
	ff		 mov	 DWORD PTR _dstLine$[ebp], eax
$LN10@convert_yv:
  003b9	8b 8d f0 fd ff
	ff		 mov	 ecx, DWORD PTR _y$36[ebp]
  003bf	3b 8d 18 fe ff
	ff		 cmp	 ecx, DWORD PTR _uv_range$[ebp+8]
  003c5	0f 8d 9a 03 00
	00		 jge	 $LN1@convert_yv

; 498  :         const int x_fin = width - crop_right;

  003cb	8b 53 10	 mov	 edx, DWORD PTR _width$[ebx]
  003ce	2b 55 f0	 sub	 edx, DWORD PTR _crop_right$[ebp]
  003d1	89 95 ec fd ff
	ff		 mov	 DWORD PTR _x_fin$35[ebp], edx

; 499  :         uint8_t *src_u_ptr = srcULine;

  003d7	8b 85 fc fd ff
	ff		 mov	 eax, DWORD PTR _srcULine$[ebp]
  003dd	89 85 e8 fd ff
	ff		 mov	 DWORD PTR _src_u_ptr$34[ebp], eax

; 500  :         uint8_t *src_v_ptr = srcVLine;

  003e3	8b 8d f8 fd ff
	ff		 mov	 ecx, DWORD PTR _srcVLine$[ebp]
  003e9	89 8d e4 fd ff
	ff		 mov	 DWORD PTR _src_v_ptr$33[ebp], ecx

; 501  :         uint16_t *dst_ptr = (uint16_t *)dstLine;

  003ef	8b 95 f4 fd ff
	ff		 mov	 edx, DWORD PTR _dstLine$[ebp]
  003f5	89 95 e0 fd ff
	ff		 mov	 DWORD PTR _dst_ptr$32[ebp], edx

; 502  :         uint16_t *dst_ptr_fin = dst_ptr + x_fin;

  003fb	8b 85 ec fd ff
	ff		 mov	 eax, DWORD PTR _x_fin$35[ebp]
  00401	8b 8d e0 fd ff
	ff		 mov	 ecx, DWORD PTR _dst_ptr$32[ebp]
  00407	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  0040a	89 95 dc fd ff
	ff		 mov	 DWORD PTR _dst_ptr_fin$31[ebp], edx

; 503  :         __m256i y0, y1, y2, y3;
; 504  :         for (; dst_ptr < dst_ptr_fin; src_u_ptr += 32, src_v_ptr += 32, dst_ptr += 64) {

  00410	eb 30		 jmp	 SHORT $LN13@convert_yv
$LN11@convert_yv:
  00412	8b 85 e8 fd ff
	ff		 mov	 eax, DWORD PTR _src_u_ptr$34[ebp]
  00418	83 c0 20	 add	 eax, 32			; 00000020H
  0041b	89 85 e8 fd ff
	ff		 mov	 DWORD PTR _src_u_ptr$34[ebp], eax
  00421	8b 8d e4 fd ff
	ff		 mov	 ecx, DWORD PTR _src_v_ptr$33[ebp]
  00427	83 c1 20	 add	 ecx, 32			; 00000020H
  0042a	89 8d e4 fd ff
	ff		 mov	 DWORD PTR _src_v_ptr$33[ebp], ecx
  00430	8b 95 e0 fd ff
	ff		 mov	 edx, DWORD PTR _dst_ptr$32[ebp]
  00436	81 c2 80 00 00
	00		 add	 edx, 128		; 00000080H
  0043c	89 95 e0 fd ff
	ff		 mov	 DWORD PTR _dst_ptr$32[ebp], edx
$LN13@convert_yv:
  00442	8b 85 e0 fd ff
	ff		 mov	 eax, DWORD PTR _dst_ptr$32[ebp]
  00448	3b 85 dc fd ff
	ff		 cmp	 eax, DWORD PTR _dst_ptr_fin$31[ebp]
  0044e	0f 83 0c 03 00
	00		 jae	 $LN12@convert_yv

; 505  :             y0 = _mm256_loadu_si256((const __m256i *)src_u_ptr); // 31-28  27-24 23-20  19-16 | 15-12  11-8  7-4  3-0

  00454	8b 8d e8 fd ff
	ff		 mov	 ecx, DWORD PTR _src_u_ptr$34[ebp]
  0045a	c5 fe 6f 01	 vmovdqu ymm0, YMMWORD PTR [ecx]
  0045e	c5 fe 7f 85 20
	fd ff ff	 vmovdqu YMMWORD PTR $T26[ebp], ymm0
  00466	c5 fe 6f 85 20
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T26[ebp]
  0046e	c5 fe 7f 85 a0
	fd ff ff	 vmovdqu YMMWORD PTR _y0$30[ebp], ymm0

; 506  :             y2 = _mm256_loadu_si256((const __m256i *)src_v_ptr);

  00476	8b 95 e4 fd ff
	ff		 mov	 edx, DWORD PTR _src_v_ptr$33[ebp]
  0047c	c5 fe 6f 02	 vmovdqu ymm0, YMMWORD PTR [edx]
  00480	c5 fe 7f 85 00
	fd ff ff	 vmovdqu YMMWORD PTR $T25[ebp], ymm0
  00488	c5 fe 6f 85 00
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T25[ebp]
  00490	c5 fe 7f 85 60
	fd ff ff	 vmovdqu YMMWORD PTR _y2$28[ebp], ymm0

; 507  : 
; 508  :             alignas(32) static const int SHUFFLE_MASK[] = { 0, 2, 4, 6, 1, 3, 5, 7 };
; 509  :             y0 = _mm256_permutevar8x32_epi32(y0, _mm256_load_si256((const __m256i *)SHUFFLE_MASK)); // 31-28  23-20  15-12  7-4 | 27-24  19-16  11-8  3-0

  00498	c5 fd 6f 05 00
	00 00 00	 vmovdqa ymm0, YMMWORD PTR ?SHUFFLE_MASK@?N@???$convert_yv12_to_p010_avx2_base@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z@4QBHB
  004a0	c5 fe 7f 85 e0
	fc ff ff	 vmovdqu YMMWORD PTR $T24[ebp], ymm0
  004a8	c5 fe 6f 85 e0
	fc ff ff	 vmovdqu ymm0, YMMWORD PTR $T24[ebp]
  004b0	c4 e2 7d 36 85
	a0 fd ff ff	 vpermd	 ymm0, ymm0, YMMWORD PTR _y0$30[ebp]
  004b9	c5 fe 7f 85 c0
	fc ff ff	 vmovdqu YMMWORD PTR $T23[ebp], ymm0
  004c1	c5 fe 6f 85 c0
	fc ff ff	 vmovdqu ymm0, YMMWORD PTR $T23[ebp]
  004c9	c5 fe 7f 85 a0
	fd ff ff	 vmovdqu YMMWORD PTR _y0$30[ebp], ymm0

; 510  :             y2 = _mm256_permutevar8x32_epi32(y2, _mm256_load_si256((const __m256i *)SHUFFLE_MASK));

  004d1	c5 fd 6f 05 00
	00 00 00	 vmovdqa ymm0, YMMWORD PTR ?SHUFFLE_MASK@?N@???$convert_yv12_to_p010_avx2_base@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z@4QBHB
  004d9	c5 fe 7f 85 a0
	fc ff ff	 vmovdqu YMMWORD PTR $T22[ebp], ymm0
  004e1	c5 fe 6f 85 a0
	fc ff ff	 vmovdqu ymm0, YMMWORD PTR $T22[ebp]
  004e9	c4 e2 7d 36 85
	60 fd ff ff	 vpermd	 ymm0, ymm0, YMMWORD PTR _y2$28[ebp]
  004f2	c5 fe 7f 85 80
	fc ff ff	 vmovdqu YMMWORD PTR $T21[ebp], ymm0
  004fa	c5 fe 6f 85 80
	fc ff ff	 vmovdqu ymm0, YMMWORD PTR $T21[ebp]
  00502	c5 fe 7f 85 60
	fd ff ff	 vmovdqu YMMWORD PTR _y2$28[ebp], ymm0

; 511  : 
; 512  :             y1 = _mm256_unpacklo_epi8(y0, y2); // 15-12    7-4 | 11- 8   3- 0

  0050a	c5 fe 6f 85 a0
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR _y0$30[ebp]
  00512	c5 fd 60 85 60
	fd ff ff	 vpunpcklbw ymm0, ymm0, YMMWORD PTR _y2$28[ebp]
  0051a	c5 fe 7f 85 60
	fc ff ff	 vmovdqu YMMWORD PTR $T20[ebp], ymm0
  00522	c5 fe 6f 85 60
	fc ff ff	 vmovdqu ymm0, YMMWORD PTR $T20[ebp]
  0052a	c5 fe 7f 85 80
	fd ff ff	 vmovdqu YMMWORD PTR _y1$29[ebp], ymm0

; 513  :             y3 = _mm256_unpackhi_epi8(y0, y2); // 31-28  23-20 | 27-24  19-16

  00532	c5 fe 6f 85 a0
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR _y0$30[ebp]
  0053a	c5 fd 68 85 60
	fd ff ff	 vpunpckhbw ymm0, ymm0, YMMWORD PTR _y2$28[ebp]
  00542	c5 fe 7f 85 40
	fc ff ff	 vmovdqu YMMWORD PTR $T19[ebp], ymm0
  0054a	c5 fe 6f 85 40
	fc ff ff	 vmovdqu ymm0, YMMWORD PTR $T19[ebp]
  00552	c5 fe 7f 85 40
	fd ff ff	 vmovdqu YMMWORD PTR _y3$27[ebp], ymm0

; 514  : 
; 515  :             y0 = _mm256_unpacklo_epi8(_mm256_setzero_si256(), y1);  //   7-4 |  3- 0

  0055a	c5 f9 ef c0	 vpxor	 xmm0, xmm0, xmm0
  0055e	c5 fe 7f 85 20
	fc ff ff	 vmovdqu YMMWORD PTR $T18[ebp], ymm0
  00566	c5 fe 6f 85 20
	fc ff ff	 vmovdqu ymm0, YMMWORD PTR $T18[ebp]
  0056e	c5 fd 60 85 80
	fd ff ff	 vpunpcklbw ymm0, ymm0, YMMWORD PTR _y1$29[ebp]
  00576	c5 fe 7f 85 00
	fc ff ff	 vmovdqu YMMWORD PTR $T17[ebp], ymm0
  0057e	c5 fe 6f 85 00
	fc ff ff	 vmovdqu ymm0, YMMWORD PTR $T17[ebp]
  00586	c5 fe 7f 85 a0
	fd ff ff	 vmovdqu YMMWORD PTR _y0$30[ebp], ymm0

; 516  :             y1 = _mm256_unpackhi_epi8(_mm256_setzero_si256(), y1);  // 15-12 | 11- 8

  0058e	c5 f9 ef c0	 vpxor	 xmm0, xmm0, xmm0
  00592	c5 fe 7f 85 e0
	fb ff ff	 vmovdqu YMMWORD PTR $T16[ebp], ymm0
  0059a	c5 fe 6f 85 e0
	fb ff ff	 vmovdqu ymm0, YMMWORD PTR $T16[ebp]
  005a2	c5 fd 68 85 80
	fd ff ff	 vpunpckhbw ymm0, ymm0, YMMWORD PTR _y1$29[ebp]
  005aa	c5 fe 7f 85 c0
	fb ff ff	 vmovdqu YMMWORD PTR $T15[ebp], ymm0
  005b2	c5 fe 6f 85 c0
	fb ff ff	 vmovdqu ymm0, YMMWORD PTR $T15[ebp]
  005ba	c5 fe 7f 85 80
	fd ff ff	 vmovdqu YMMWORD PTR _y1$29[ebp], ymm0

; 517  :             y0 = _mm256_add_epi16(y0, _mm256_set1_epi16(2 << 6));

  005c2	c5 fe 6f 05 00
	00 00 00	 vmovdqu ymm0, YMMWORD PTR __ymm@0080008000800080008000800080008000800080008000800080008000800080
  005ca	c5 fe 7f 85 a0
	fb ff ff	 vmovdqu YMMWORD PTR $T14[ebp], ymm0
  005d2	c5 fe 6f 85 a0
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR _y0$30[ebp]
  005da	c5 fd fd 85 a0
	fb ff ff	 vpaddw	 ymm0, ymm0, YMMWORD PTR $T14[ebp]
  005e2	c5 fe 7f 85 80
	fb ff ff	 vmovdqu YMMWORD PTR $T13[ebp], ymm0
  005ea	c5 fe 6f 85 80
	fb ff ff	 vmovdqu ymm0, YMMWORD PTR $T13[ebp]
  005f2	c5 fe 7f 85 a0
	fd ff ff	 vmovdqu YMMWORD PTR _y0$30[ebp], ymm0

; 518  :             y1 = _mm256_add_epi16(y1, _mm256_set1_epi16(2 << 6));

  005fa	c5 fe 6f 05 00
	00 00 00	 vmovdqu ymm0, YMMWORD PTR __ymm@0080008000800080008000800080008000800080008000800080008000800080
  00602	c5 fe 7f 85 60
	fb ff ff	 vmovdqu YMMWORD PTR $T12[ebp], ymm0
  0060a	c5 fe 6f 85 80
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR _y1$29[ebp]
  00612	c5 fd fd 85 60
	fb ff ff	 vpaddw	 ymm0, ymm0, YMMWORD PTR $T12[ebp]
  0061a	c5 fe 7f 85 40
	fb ff ff	 vmovdqu YMMWORD PTR $T11[ebp], ymm0
  00622	c5 fe 6f 85 40
	fb ff ff	 vmovdqu ymm0, YMMWORD PTR $T11[ebp]
  0062a	c5 fe 7f 85 80
	fd ff ff	 vmovdqu YMMWORD PTR _y1$29[ebp], ymm0

; 519  : 
; 520  :             y2 = _mm256_unpacklo_epi8(_mm256_setzero_si256(), y3);  // 23-20 | 19-16

  00632	c5 f9 ef c0	 vpxor	 xmm0, xmm0, xmm0
  00636	c5 fe 7f 85 20
	fb ff ff	 vmovdqu YMMWORD PTR $T10[ebp], ymm0
  0063e	c5 fe 6f 85 20
	fb ff ff	 vmovdqu ymm0, YMMWORD PTR $T10[ebp]
  00646	c5 fd 60 85 40
	fd ff ff	 vpunpcklbw ymm0, ymm0, YMMWORD PTR _y3$27[ebp]
  0064e	c5 fe 7f 85 00
	fb ff ff	 vmovdqu YMMWORD PTR $T9[ebp], ymm0
  00656	c5 fe 6f 85 00
	fb ff ff	 vmovdqu ymm0, YMMWORD PTR $T9[ebp]
  0065e	c5 fe 7f 85 60
	fd ff ff	 vmovdqu YMMWORD PTR _y2$28[ebp], ymm0

; 521  :             y3 = _mm256_unpackhi_epi8(_mm256_setzero_si256(), y3);  // 31-28 | 27-24

  00666	c5 f9 ef c0	 vpxor	 xmm0, xmm0, xmm0
  0066a	c5 fe 7f 85 e0
	fa ff ff	 vmovdqu YMMWORD PTR $T8[ebp], ymm0
  00672	c5 fe 6f 85 e0
	fa ff ff	 vmovdqu ymm0, YMMWORD PTR $T8[ebp]
  0067a	c5 fd 68 85 40
	fd ff ff	 vpunpckhbw ymm0, ymm0, YMMWORD PTR _y3$27[ebp]
  00682	c5 fe 7f 85 c0
	fa ff ff	 vmovdqu YMMWORD PTR $T7[ebp], ymm0
  0068a	c5 fe 6f 85 c0
	fa ff ff	 vmovdqu ymm0, YMMWORD PTR $T7[ebp]
  00692	c5 fe 7f 85 40
	fd ff ff	 vmovdqu YMMWORD PTR _y3$27[ebp], ymm0

; 522  :             y2 = _mm256_add_epi16(y2, _mm256_set1_epi16(2 << 6));

  0069a	c5 fe 6f 05 00
	00 00 00	 vmovdqu ymm0, YMMWORD PTR __ymm@0080008000800080008000800080008000800080008000800080008000800080
  006a2	c5 fe 7f 85 a0
	fa ff ff	 vmovdqu YMMWORD PTR $T6[ebp], ymm0
  006aa	c5 fe 6f 85 60
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR _y2$28[ebp]
  006b2	c5 fd fd 85 a0
	fa ff ff	 vpaddw	 ymm0, ymm0, YMMWORD PTR $T6[ebp]
  006ba	c5 fe 7f 85 80
	fa ff ff	 vmovdqu YMMWORD PTR $T5[ebp], ymm0
  006c2	c5 fe 6f 85 80
	fa ff ff	 vmovdqu ymm0, YMMWORD PTR $T5[ebp]
  006ca	c5 fe 7f 85 60
	fd ff ff	 vmovdqu YMMWORD PTR _y2$28[ebp], ymm0

; 523  :             y3 = _mm256_add_epi16(y3, _mm256_set1_epi16(2 << 6));

  006d2	c5 fe 6f 05 00
	00 00 00	 vmovdqu ymm0, YMMWORD PTR __ymm@0080008000800080008000800080008000800080008000800080008000800080
  006da	c5 fe 7f 85 60
	fa ff ff	 vmovdqu YMMWORD PTR $T4[ebp], ymm0
  006e2	c5 fe 6f 85 40
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR _y3$27[ebp]
  006ea	c5 fd fd 85 60
	fa ff ff	 vpaddw	 ymm0, ymm0, YMMWORD PTR $T4[ebp]
  006f2	c5 fe 7f 85 40
	fa ff ff	 vmovdqu YMMWORD PTR $T3[ebp], ymm0
  006fa	c5 fe 6f 85 40
	fa ff ff	 vmovdqu ymm0, YMMWORD PTR $T3[ebp]
  00702	c5 fe 7f 85 40
	fd ff ff	 vmovdqu YMMWORD PTR _y3$27[ebp], ymm0

; 524  : 
; 525  :             _mm256_storeu_si256((__m256i *)(dst_ptr +  0), y0);

  0070a	c5 fe 6f 85 a0
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR _y0$30[ebp]
  00712	8b 85 e0 fd ff
	ff		 mov	 eax, DWORD PTR _dst_ptr$32[ebp]
  00718	c5 fe 7f 00	 vmovdqu YMMWORD PTR [eax], ymm0

; 526  :             _mm256_storeu_si256((__m256i *)(dst_ptr + 16), y1);

  0071c	c5 fe 6f 85 80
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR _y1$29[ebp]
  00724	8b 8d e0 fd ff
	ff		 mov	 ecx, DWORD PTR _dst_ptr$32[ebp]
  0072a	83 c1 20	 add	 ecx, 32			; 00000020H
  0072d	c5 fe 7f 01	 vmovdqu YMMWORD PTR [ecx], ymm0

; 527  :             _mm256_storeu_si256((__m256i *)(dst_ptr + 32), y2);

  00731	c5 fe 6f 85 60
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR _y2$28[ebp]
  00739	8b 95 e0 fd ff
	ff		 mov	 edx, DWORD PTR _dst_ptr$32[ebp]
  0073f	83 c2 40	 add	 edx, 64			; 00000040H
  00742	c5 fe 7f 02	 vmovdqu YMMWORD PTR [edx], ymm0

; 528  :             _mm256_storeu_si256((__m256i *)(dst_ptr + 48), y3);

  00746	c5 fe 6f 85 40
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR _y3$27[ebp]
  0074e	8b 85 e0 fd ff
	ff		 mov	 eax, DWORD PTR _dst_ptr$32[ebp]
  00754	83 c0 60	 add	 eax, 96			; 00000060H
  00757	c5 fe 7f 00	 vmovdqu YMMWORD PTR [eax], ymm0

; 529  :         }

  0075b	e9 b2 fc ff ff	 jmp	 $LN11@convert_yv
$LN12@convert_yv:

; 530  :     }

  00760	e9 18 fc ff ff	 jmp	 $LN8@convert_yv
$LN1@convert_yv:

; 531  : }

  00765	52		 push	 edx
  00766	8b cd		 mov	 ecx, ebp
  00768	50		 push	 eax
  00769	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN19@convert_yv
  0076f	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00774	58		 pop	 eax
  00775	5a		 pop	 edx
  00776	5f		 pop	 edi
  00777	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0077a	33 cd		 xor	 ecx, ebp
  0077c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00781	8b e5		 mov	 esp, ebp
  00783	5d		 pop	 ebp
  00784	8b e3		 mov	 esp, ebx
  00786	5b		 pop	 ebx
  00787	c3		 ret	 0
$LN19@convert_yv:
  00788	02 00 00 00	 DD	 2
  0078c	00 00 00 00	 DD	 $LN18@convert_yv
$LN18@convert_yv:
  00790	dc ff ff ff	 DD	 -36			; ffffffdcH
  00794	0c 00 00 00	 DD	 12			; 0000000cH
  00798	00 00 00 00	 DD	 $LN16@convert_yv
  0079c	10 fe ff ff	 DD	 -496			; fffffe10H
  007a0	0c 00 00 00	 DD	 12			; 0000000cH
  007a4	00 00 00 00	 DD	 $LN17@convert_yv
$LN17@convert_yv:
  007a8	75		 DB	 117			; 00000075H
  007a9	76		 DB	 118			; 00000076H
  007aa	5f		 DB	 95			; 0000005fH
  007ab	72		 DB	 114			; 00000072H
  007ac	61		 DB	 97			; 00000061H
  007ad	6e		 DB	 110			; 0000006eH
  007ae	67		 DB	 103			; 00000067H
  007af	65		 DB	 101			; 00000065H
  007b0	00		 DB	 0
$LN16@convert_yv:
  007b1	79		 DB	 121			; 00000079H
  007b2	5f		 DB	 95			; 0000005fH
  007b3	72		 DB	 114			; 00000072H
  007b4	61		 DB	 97			; 00000061H
  007b5	6e		 DB	 110			; 0000006eH
  007b6	67		 DB	 103			; 00000067H
  007b7	65		 DB	 101			; 00000065H
  007b8	00		 DB	 0
??$convert_yv12_to_p010_avx2_base@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_to_p010_avx2_base<0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yv12_to_p010_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_to_p010_avx2

; 534  : void convert_yv12_to_p010_avx2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 535  :     convert_yv12_to_p010_avx2_base<false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yv12_to_p010_avx2_base@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_to_p010_avx2_base<0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 536  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yv12_to_p010_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_to_p010_avx2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
$T1 = -80						; size = 12
_y$2 = -68						; size = 4
_y_width$ = -64						; size = 4
_dstLine$ = -60						; size = 4
_srcLine$ = -56						; size = 4
$T3 = -52						; size = 12
_y_range$ = -36						; size = 12
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_rgb24r_to_rgb24_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_rgb24r_to_rgb24_avx2

; 448  : void convert_rgb24r_to_rgb24_avx2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	57		 push	 edi
  00007	8d 7d b0	 lea	 edi, DWORD PTR [ebp-80]
  0000a	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  0000f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00014	f3 ab		 rep stosd
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 449  :     const int crop_left   = crop[0];

  00020	b8 04 00 00 00	 mov	 eax, 4
  00025	6b c8 00	 imul	 ecx, eax, 0
  00028	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  0002b	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0002e	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 450  :     const int crop_up     = crop[1];

  00031	b9 04 00 00 00	 mov	 ecx, 4
  00036	c1 e1 00	 shl	 ecx, 0
  00039	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  0003c	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0003f	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 451  :     const int crop_right  = crop[2];

  00042	b9 04 00 00 00	 mov	 ecx, 4
  00047	d1 e1		 shl	 ecx, 1
  00049	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  0004c	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0004f	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 452  :     const int crop_bottom = crop[3];

  00052	b9 04 00 00 00	 mov	 ecx, 4
  00057	6b d1 03	 imul	 edx, ecx, 3
  0005a	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  0005d	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00060	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 453  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00063	8b 55 2c	 mov	 edx, DWORD PTR _thread_n$[ebp]
  00066	52		 push	 edx
  00067	8b 45 28	 mov	 eax, DWORD PTR _thread_id$[ebp]
  0006a	50		 push	 eax
  0006b	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  0006e	2b 4d ec	 sub	 ecx, DWORD PTR _crop_bottom$[ebp]
  00071	51		 push	 ecx
  00072	8b 55 f4	 mov	 edx, DWORD PTR _crop_up$[ebp]
  00075	52		 push	 edx
  00076	8d 45 b0	 lea	 eax, DWORD PTR $T1[ebp]
  00079	50		 push	 eax
  0007a	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  0007f	83 c4 14	 add	 esp, 20			; 00000014H
  00082	8b 08		 mov	 ecx, DWORD PTR [eax]
  00084	89 4d cc	 mov	 DWORD PTR $T3[ebp], ecx
  00087	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0008a	89 55 d0	 mov	 DWORD PTR $T3[ebp+4], edx
  0008d	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00090	89 45 d4	 mov	 DWORD PTR $T3[ebp+8], eax
  00093	8b 4d cc	 mov	 ecx, DWORD PTR $T3[ebp]
  00096	89 4d dc	 mov	 DWORD PTR _y_range$[ebp], ecx
  00099	8b 55 d0	 mov	 edx, DWORD PTR $T3[ebp+4]
  0009c	89 55 e0	 mov	 DWORD PTR _y_range$[ebp+4], edx
  0009f	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp+8]
  000a2	89 45 e4	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 454  :     uint8_t *srcLine = (uint8_t *)src[0] + src_y_pitch_byte * ((y_range.start_src + y_range.len) - 1) + crop_left * 3;

  000a5	b9 04 00 00 00	 mov	 ecx, 4
  000aa	6b d1 00	 imul	 edx, ecx, 0
  000ad	8b 45 e4	 mov	 eax, DWORD PTR _y_range$[ebp+8]
  000b0	8b 4d dc	 mov	 ecx, DWORD PTR _y_range$[ebp]
  000b3	8d 44 01 ff	 lea	 eax, DWORD PTR [ecx+eax-1]
  000b7	0f af 45 14	 imul	 eax, DWORD PTR _src_y_pitch_byte$[ebp]
  000bb	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  000be	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  000c1	03 d0		 add	 edx, eax
  000c3	6b 45 f8 03	 imul	 eax, DWORD PTR _crop_left$[ebp], 3
  000c7	03 d0		 add	 edx, eax
  000c9	89 55 c8	 mov	 DWORD PTR _srcLine$[ebp], edx

; 455  :     uint8_t *dstLine = (uint8_t *)dst[0] + dst_y_pitch_byte * (height - (y_range.start_dst + y_range.len));

  000cc	b9 04 00 00 00	 mov	 ecx, 4
  000d1	6b d1 00	 imul	 edx, ecx, 0
  000d4	8b 45 e0	 mov	 eax, DWORD PTR _y_range$[ebp+4]
  000d7	03 45 e4	 add	 eax, DWORD PTR _y_range$[ebp+8]
  000da	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  000dd	2b c8		 sub	 ecx, eax
  000df	0f af 4d 1c	 imul	 ecx, DWORD PTR _dst_y_pitch_byte$[ebp]
  000e3	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
  000e6	03 0c 10	 add	 ecx, DWORD PTR [eax+edx]
  000e9	89 4d c4	 mov	 DWORD PTR _dstLine$[ebp], ecx

; 456  :     const int y_width = width - crop_right - crop_left;

  000ec	8b 4d 10	 mov	 ecx, DWORD PTR _width$[ebp]
  000ef	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  000f2	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  000f5	89 4d c0	 mov	 DWORD PTR _y_width$[ebp], ecx

; 457  :     for (int y = 0; y < y_range.len; y++, dstLine += dst_y_pitch_byte, srcLine -= src_y_pitch_byte) {

  000f8	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _y$2[ebp], 0
  000ff	eb 1b		 jmp	 SHORT $LN4@convert_rg
$LN2@convert_rg:
  00101	8b 55 bc	 mov	 edx, DWORD PTR _y$2[ebp]
  00104	83 c2 01	 add	 edx, 1
  00107	89 55 bc	 mov	 DWORD PTR _y$2[ebp], edx
  0010a	8b 45 c4	 mov	 eax, DWORD PTR _dstLine$[ebp]
  0010d	03 45 1c	 add	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  00110	89 45 c4	 mov	 DWORD PTR _dstLine$[ebp], eax
  00113	8b 4d c8	 mov	 ecx, DWORD PTR _srcLine$[ebp]
  00116	2b 4d 14	 sub	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00119	89 4d c8	 mov	 DWORD PTR _srcLine$[ebp], ecx
$LN4@convert_rg:
  0011c	8b 55 bc	 mov	 edx, DWORD PTR _y$2[ebp]
  0011f	3b 55 e4	 cmp	 edx, DWORD PTR _y_range$[ebp+8]
  00122	7d 17		 jge	 SHORT $LN3@convert_rg

; 458  :         avx2_memcpy<false>(dstLine, srcLine, y_width * 3);

  00124	6b 45 c0 03	 imul	 eax, DWORD PTR _y_width$[ebp], 3
  00128	50		 push	 eax
  00129	8b 4d c8	 mov	 ecx, DWORD PTR _srcLine$[ebp]
  0012c	51		 push	 ecx
  0012d	8b 55 c4	 mov	 edx, DWORD PTR _dstLine$[ebp]
  00130	52		 push	 edx
  00131	e8 00 00 00 00	 call	 ??$avx2_memcpy@$0A@@@YAXPAEPBEH@Z ; avx2_memcpy<0>
  00136	83 c4 0c	 add	 esp, 12			; 0000000cH

; 459  :     }

  00139	eb c6		 jmp	 SHORT $LN2@convert_rg
$LN3@convert_rg:

; 460  :     _mm256_zeroupper();

  0013b	c5 f8 77	 vzeroupper

; 461  : }

  0013e	52		 push	 edx
  0013f	8b cd		 mov	 ecx, ebp
  00141	50		 push	 eax
  00142	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN8@convert_rg
  00148	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0014d	58		 pop	 eax
  0014e	5a		 pop	 edx
  0014f	5f		 pop	 edi
  00150	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00153	33 cd		 xor	 ecx, ebp
  00155	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0015a	83 c4 50	 add	 esp, 80			; 00000050H
  0015d	3b ec		 cmp	 ebp, esp
  0015f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00164	8b e5		 mov	 esp, ebp
  00166	5d		 pop	 ebp
  00167	c3		 ret	 0
$LN8@convert_rg:
  00168	01 00 00 00	 DD	 1
  0016c	00 00 00 00	 DD	 $LN7@convert_rg
$LN7@convert_rg:
  00170	dc ff ff ff	 DD	 -36			; ffffffdcH
  00174	0c 00 00 00	 DD	 12			; 0000000cH
  00178	00 00 00 00	 DD	 $LN6@convert_rg
$LN6@convert_rg:
  0017c	79		 DB	 121			; 00000079H
  0017d	5f		 DB	 95			; 0000005fH
  0017e	72		 DB	 114			; 00000072H
  0017f	61		 DB	 97			; 00000061H
  00180	6e		 DB	 110			; 0000006eH
  00181	67		 DB	 103			; 00000067H
  00182	65		 DB	 101			; 00000065H
  00183	00		 DB	 0
?convert_rgb24r_to_rgb24_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_rgb24r_to_rgb24_avx2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
$T1 = -80						; size = 12
_y$2 = -68						; size = 4
_y_width$ = -64						; size = 4
_dstLine$ = -60						; size = 4
_srcLine$ = -56						; size = 4
$T3 = -52						; size = 12
_y_range$ = -36						; size = 12
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_rgb24_to_rgb24_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_rgb24_to_rgb24_avx2

; 433  : void convert_rgb24_to_rgb24_avx2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	57		 push	 edi
  00007	8d 7d b0	 lea	 edi, DWORD PTR [ebp-80]
  0000a	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  0000f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00014	f3 ab		 rep stosd
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 434  :     const int crop_left   = crop[0];

  00020	b8 04 00 00 00	 mov	 eax, 4
  00025	6b c8 00	 imul	 ecx, eax, 0
  00028	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  0002b	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0002e	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 435  :     const int crop_up     = crop[1];

  00031	b9 04 00 00 00	 mov	 ecx, 4
  00036	c1 e1 00	 shl	 ecx, 0
  00039	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  0003c	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0003f	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 436  :     const int crop_right  = crop[2];

  00042	b9 04 00 00 00	 mov	 ecx, 4
  00047	d1 e1		 shl	 ecx, 1
  00049	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  0004c	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0004f	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 437  :     const int crop_bottom = crop[3];

  00052	b9 04 00 00 00	 mov	 ecx, 4
  00057	6b d1 03	 imul	 edx, ecx, 3
  0005a	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  0005d	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00060	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 438  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00063	8b 55 2c	 mov	 edx, DWORD PTR _thread_n$[ebp]
  00066	52		 push	 edx
  00067	8b 45 28	 mov	 eax, DWORD PTR _thread_id$[ebp]
  0006a	50		 push	 eax
  0006b	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  0006e	2b 4d ec	 sub	 ecx, DWORD PTR _crop_bottom$[ebp]
  00071	51		 push	 ecx
  00072	8b 55 f4	 mov	 edx, DWORD PTR _crop_up$[ebp]
  00075	52		 push	 edx
  00076	8d 45 b0	 lea	 eax, DWORD PTR $T1[ebp]
  00079	50		 push	 eax
  0007a	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  0007f	83 c4 14	 add	 esp, 20			; 00000014H
  00082	8b 08		 mov	 ecx, DWORD PTR [eax]
  00084	89 4d cc	 mov	 DWORD PTR $T3[ebp], ecx
  00087	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0008a	89 55 d0	 mov	 DWORD PTR $T3[ebp+4], edx
  0008d	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00090	89 45 d4	 mov	 DWORD PTR $T3[ebp+8], eax
  00093	8b 4d cc	 mov	 ecx, DWORD PTR $T3[ebp]
  00096	89 4d dc	 mov	 DWORD PTR _y_range$[ebp], ecx
  00099	8b 55 d0	 mov	 edx, DWORD PTR $T3[ebp+4]
  0009c	89 55 e0	 mov	 DWORD PTR _y_range$[ebp+4], edx
  0009f	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp+8]
  000a2	89 45 e4	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 439  :     uint8_t *srcLine = (uint8_t *)src[0] + src_y_pitch_byte * y_range.start_src + crop_left * 3;

  000a5	b9 04 00 00 00	 mov	 ecx, 4
  000aa	6b d1 00	 imul	 edx, ecx, 0
  000ad	8b 45 14	 mov	 eax, DWORD PTR _src_y_pitch_byte$[ebp]
  000b0	0f af 45 dc	 imul	 eax, DWORD PTR _y_range$[ebp]
  000b4	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  000b7	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  000ba	03 d0		 add	 edx, eax
  000bc	6b 45 f8 03	 imul	 eax, DWORD PTR _crop_left$[ebp], 3
  000c0	03 d0		 add	 edx, eax
  000c2	89 55 c8	 mov	 DWORD PTR _srcLine$[ebp], edx

; 440  :     uint8_t *dstLine = (uint8_t *)dst[0] + dst_y_pitch_byte * y_range.start_dst;

  000c5	b9 04 00 00 00	 mov	 ecx, 4
  000ca	6b d1 00	 imul	 edx, ecx, 0
  000cd	8b 45 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebp]
  000d0	0f af 45 e0	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  000d4	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  000d7	03 04 11	 add	 eax, DWORD PTR [ecx+edx]
  000da	89 45 c4	 mov	 DWORD PTR _dstLine$[ebp], eax

; 441  :     const int y_width = width - crop_right - crop_left;

  000dd	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  000e0	2b 55 f0	 sub	 edx, DWORD PTR _crop_right$[ebp]
  000e3	2b 55 f8	 sub	 edx, DWORD PTR _crop_left$[ebp]
  000e6	89 55 c0	 mov	 DWORD PTR _y_width$[ebp], edx

; 442  :     for (int y = 0; y < y_range.len; y++, dstLine += dst_y_pitch_byte, srcLine += src_y_pitch_byte) {

  000e9	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _y$2[ebp], 0
  000f0	eb 1b		 jmp	 SHORT $LN4@convert_rg
$LN2@convert_rg:
  000f2	8b 45 bc	 mov	 eax, DWORD PTR _y$2[ebp]
  000f5	83 c0 01	 add	 eax, 1
  000f8	89 45 bc	 mov	 DWORD PTR _y$2[ebp], eax
  000fb	8b 4d c4	 mov	 ecx, DWORD PTR _dstLine$[ebp]
  000fe	03 4d 1c	 add	 ecx, DWORD PTR _dst_y_pitch_byte$[ebp]
  00101	89 4d c4	 mov	 DWORD PTR _dstLine$[ebp], ecx
  00104	8b 55 c8	 mov	 edx, DWORD PTR _srcLine$[ebp]
  00107	03 55 14	 add	 edx, DWORD PTR _src_y_pitch_byte$[ebp]
  0010a	89 55 c8	 mov	 DWORD PTR _srcLine$[ebp], edx
$LN4@convert_rg:
  0010d	8b 45 bc	 mov	 eax, DWORD PTR _y$2[ebp]
  00110	3b 45 e4	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  00113	7d 17		 jge	 SHORT $LN3@convert_rg

; 443  :         avx2_memcpy<false>(dstLine, srcLine, y_width * 3);

  00115	6b 4d c0 03	 imul	 ecx, DWORD PTR _y_width$[ebp], 3
  00119	51		 push	 ecx
  0011a	8b 55 c8	 mov	 edx, DWORD PTR _srcLine$[ebp]
  0011d	52		 push	 edx
  0011e	8b 45 c4	 mov	 eax, DWORD PTR _dstLine$[ebp]
  00121	50		 push	 eax
  00122	e8 00 00 00 00	 call	 ??$avx2_memcpy@$0A@@@YAXPAEPBEH@Z ; avx2_memcpy<0>
  00127	83 c4 0c	 add	 esp, 12			; 0000000cH

; 444  :     }

  0012a	eb c6		 jmp	 SHORT $LN2@convert_rg
$LN3@convert_rg:

; 445  :     _mm256_zeroupper();

  0012c	c5 f8 77	 vzeroupper

; 446  : }

  0012f	52		 push	 edx
  00130	8b cd		 mov	 ecx, ebp
  00132	50		 push	 eax
  00133	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN8@convert_rg
  00139	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0013e	58		 pop	 eax
  0013f	5a		 pop	 edx
  00140	5f		 pop	 edi
  00141	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00144	33 cd		 xor	 ecx, ebp
  00146	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0014b	83 c4 50	 add	 esp, 80			; 00000050H
  0014e	3b ec		 cmp	 ebp, esp
  00150	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00155	8b e5		 mov	 esp, ebp
  00157	5d		 pop	 ebp
  00158	c3		 ret	 0
  00159	0f 1f 00	 npad	 3
$LN8@convert_rg:
  0015c	01 00 00 00	 DD	 1
  00160	00 00 00 00	 DD	 $LN7@convert_rg
$LN7@convert_rg:
  00164	dc ff ff ff	 DD	 -36			; ffffffdcH
  00168	0c 00 00 00	 DD	 12			; 0000000cH
  0016c	00 00 00 00	 DD	 $LN6@convert_rg
$LN6@convert_rg:
  00170	79		 DB	 121			; 00000079H
  00171	5f		 DB	 95			; 0000005fH
  00172	72		 DB	 114			; 00000072H
  00173	61		 DB	 97			; 00000061H
  00174	6e		 DB	 110			; 0000006eH
  00175	67		 DB	 103			; 00000067H
  00176	65		 DB	 101			; 00000065H
  00177	00		 DB	 0
?convert_rgb24_to_rgb24_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_rgb24_to_rgb24_avx2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
$T1 = -80						; size = 12
_y$2 = -68						; size = 4
_y_width$ = -64						; size = 4
_dstLine$ = -60						; size = 4
_srcLine$ = -56						; size = 4
$T3 = -52						; size = 12
_y_range$ = -36						; size = 12
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_rgb32r_to_rgb32_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_rgb32r_to_rgb32_avx2

; 418  : void convert_rgb32r_to_rgb32_avx2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	57		 push	 edi
  00007	8d 7d b0	 lea	 edi, DWORD PTR [ebp-80]
  0000a	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  0000f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00014	f3 ab		 rep stosd
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 419  :     const int crop_left   = crop[0];

  00020	b8 04 00 00 00	 mov	 eax, 4
  00025	6b c8 00	 imul	 ecx, eax, 0
  00028	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  0002b	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0002e	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 420  :     const int crop_up     = crop[1];

  00031	b9 04 00 00 00	 mov	 ecx, 4
  00036	c1 e1 00	 shl	 ecx, 0
  00039	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  0003c	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0003f	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 421  :     const int crop_right  = crop[2];

  00042	b9 04 00 00 00	 mov	 ecx, 4
  00047	d1 e1		 shl	 ecx, 1
  00049	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  0004c	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0004f	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 422  :     const int crop_bottom = crop[3];

  00052	b9 04 00 00 00	 mov	 ecx, 4
  00057	6b d1 03	 imul	 edx, ecx, 3
  0005a	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  0005d	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00060	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 423  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00063	8b 55 2c	 mov	 edx, DWORD PTR _thread_n$[ebp]
  00066	52		 push	 edx
  00067	8b 45 28	 mov	 eax, DWORD PTR _thread_id$[ebp]
  0006a	50		 push	 eax
  0006b	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  0006e	2b 4d ec	 sub	 ecx, DWORD PTR _crop_bottom$[ebp]
  00071	51		 push	 ecx
  00072	8b 55 f4	 mov	 edx, DWORD PTR _crop_up$[ebp]
  00075	52		 push	 edx
  00076	8d 45 b0	 lea	 eax, DWORD PTR $T1[ebp]
  00079	50		 push	 eax
  0007a	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  0007f	83 c4 14	 add	 esp, 20			; 00000014H
  00082	8b 08		 mov	 ecx, DWORD PTR [eax]
  00084	89 4d cc	 mov	 DWORD PTR $T3[ebp], ecx
  00087	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0008a	89 55 d0	 mov	 DWORD PTR $T3[ebp+4], edx
  0008d	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00090	89 45 d4	 mov	 DWORD PTR $T3[ebp+8], eax
  00093	8b 4d cc	 mov	 ecx, DWORD PTR $T3[ebp]
  00096	89 4d dc	 mov	 DWORD PTR _y_range$[ebp], ecx
  00099	8b 55 d0	 mov	 edx, DWORD PTR $T3[ebp+4]
  0009c	89 55 e0	 mov	 DWORD PTR _y_range$[ebp+4], edx
  0009f	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp+8]
  000a2	89 45 e4	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 424  :     uint8_t *srcLine = (uint8_t *)src[0] + src_y_pitch_byte * ((y_range.start_src + y_range.len) - 1) + crop_left * 4;

  000a5	b9 04 00 00 00	 mov	 ecx, 4
  000aa	6b d1 00	 imul	 edx, ecx, 0
  000ad	8b 45 e4	 mov	 eax, DWORD PTR _y_range$[ebp+8]
  000b0	8b 4d dc	 mov	 ecx, DWORD PTR _y_range$[ebp]
  000b3	8d 44 01 ff	 lea	 eax, DWORD PTR [ecx+eax-1]
  000b7	0f af 45 14	 imul	 eax, DWORD PTR _src_y_pitch_byte$[ebp]
  000bb	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  000be	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  000c1	03 d0		 add	 edx, eax
  000c3	8b 45 f8	 mov	 eax, DWORD PTR _crop_left$[ebp]
  000c6	8d 0c 82	 lea	 ecx, DWORD PTR [edx+eax*4]
  000c9	89 4d c8	 mov	 DWORD PTR _srcLine$[ebp], ecx

; 425  :     uint8_t *dstLine = (uint8_t *)dst[0] + dst_y_pitch_byte * (height - (y_range.start_dst + y_range.len));

  000cc	ba 04 00 00 00	 mov	 edx, 4
  000d1	6b c2 00	 imul	 eax, edx, 0
  000d4	8b 4d e0	 mov	 ecx, DWORD PTR _y_range$[ebp+4]
  000d7	03 4d e4	 add	 ecx, DWORD PTR _y_range$[ebp+8]
  000da	8b 55 20	 mov	 edx, DWORD PTR _height$[ebp]
  000dd	2b d1		 sub	 edx, ecx
  000df	0f af 55 1c	 imul	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  000e3	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  000e6	03 14 01	 add	 edx, DWORD PTR [ecx+eax]
  000e9	89 55 c4	 mov	 DWORD PTR _dstLine$[ebp], edx

; 426  :     const int y_width = width - crop_right - crop_left;

  000ec	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  000ef	2b 55 f0	 sub	 edx, DWORD PTR _crop_right$[ebp]
  000f2	2b 55 f8	 sub	 edx, DWORD PTR _crop_left$[ebp]
  000f5	89 55 c0	 mov	 DWORD PTR _y_width$[ebp], edx

; 427  :     for (int y = 0; y < y_range.len; y++, dstLine += dst_y_pitch_byte, srcLine -= src_y_pitch_byte) {

  000f8	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _y$2[ebp], 0
  000ff	eb 1b		 jmp	 SHORT $LN4@convert_rg
$LN2@convert_rg:
  00101	8b 45 bc	 mov	 eax, DWORD PTR _y$2[ebp]
  00104	83 c0 01	 add	 eax, 1
  00107	89 45 bc	 mov	 DWORD PTR _y$2[ebp], eax
  0010a	8b 4d c4	 mov	 ecx, DWORD PTR _dstLine$[ebp]
  0010d	03 4d 1c	 add	 ecx, DWORD PTR _dst_y_pitch_byte$[ebp]
  00110	89 4d c4	 mov	 DWORD PTR _dstLine$[ebp], ecx
  00113	8b 55 c8	 mov	 edx, DWORD PTR _srcLine$[ebp]
  00116	2b 55 14	 sub	 edx, DWORD PTR _src_y_pitch_byte$[ebp]
  00119	89 55 c8	 mov	 DWORD PTR _srcLine$[ebp], edx
$LN4@convert_rg:
  0011c	8b 45 bc	 mov	 eax, DWORD PTR _y$2[ebp]
  0011f	3b 45 e4	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  00122	7d 19		 jge	 SHORT $LN3@convert_rg

; 428  :         avx2_memcpy<false>(dstLine, srcLine, y_width * 4);

  00124	8b 4d c0	 mov	 ecx, DWORD PTR _y_width$[ebp]
  00127	c1 e1 02	 shl	 ecx, 2
  0012a	51		 push	 ecx
  0012b	8b 55 c8	 mov	 edx, DWORD PTR _srcLine$[ebp]
  0012e	52		 push	 edx
  0012f	8b 45 c4	 mov	 eax, DWORD PTR _dstLine$[ebp]
  00132	50		 push	 eax
  00133	e8 00 00 00 00	 call	 ??$avx2_memcpy@$0A@@@YAXPAEPBEH@Z ; avx2_memcpy<0>
  00138	83 c4 0c	 add	 esp, 12			; 0000000cH

; 429  :     }

  0013b	eb c4		 jmp	 SHORT $LN2@convert_rg
$LN3@convert_rg:

; 430  :     _mm256_zeroupper();

  0013d	c5 f8 77	 vzeroupper

; 431  : }

  00140	52		 push	 edx
  00141	8b cd		 mov	 ecx, ebp
  00143	50		 push	 eax
  00144	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN8@convert_rg
  0014a	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0014f	58		 pop	 eax
  00150	5a		 pop	 edx
  00151	5f		 pop	 edi
  00152	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00155	33 cd		 xor	 ecx, ebp
  00157	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0015c	83 c4 50	 add	 esp, 80			; 00000050H
  0015f	3b ec		 cmp	 ebp, esp
  00161	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00166	8b e5		 mov	 esp, ebp
  00168	5d		 pop	 ebp
  00169	c3		 ret	 0
  0016a	66 90		 npad	 2
$LN8@convert_rg:
  0016c	01 00 00 00	 DD	 1
  00170	00 00 00 00	 DD	 $LN7@convert_rg
$LN7@convert_rg:
  00174	dc ff ff ff	 DD	 -36			; ffffffdcH
  00178	0c 00 00 00	 DD	 12			; 0000000cH
  0017c	00 00 00 00	 DD	 $LN6@convert_rg
$LN6@convert_rg:
  00180	79		 DB	 121			; 00000079H
  00181	5f		 DB	 95			; 0000005fH
  00182	72		 DB	 114			; 00000072H
  00183	61		 DB	 97			; 00000061H
  00184	6e		 DB	 110			; 0000006eH
  00185	67		 DB	 103			; 00000067H
  00186	65		 DB	 101			; 00000065H
  00187	00		 DB	 0
?convert_rgb32r_to_rgb32_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_rgb32r_to_rgb32_avx2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
tv160 = -528						; size = 4
tv152 = -524						; size = 4
tv144 = -520						; size = 4
tv136 = -516						; size = 4
$T1 = -512						; size = 32
$T2 = -480						; size = 32
$T3 = -448						; size = 32
$T4 = -416						; size = 32
_dst_tmp$ = -356					; size = 4
$T5 = -352						; size = 32
$T6 = -320						; size = 32
$T7 = -288						; size = 32
$T8 = -256						; size = 32
$T9 = -224						; size = 32
_start_align_diff$ = -164				; size = 4
_y3$ = -160						; size = 32
_y2$ = -128						; size = 32
_y1$ = -96						; size = 32
_y0$ = -64						; size = 32
_dst_aligned_fin$ = -12					; size = 4
_dst_fin$ = -8						; size = 4
_i$10 = -4						; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_size$ = 16						; size = 4
??$avx2_memcpy@$0A@@@YAXPAEPBEH@Z PROC			; avx2_memcpy<0>

; 47   : static void __forceinline avx2_memcpy(uint8_t *dst, const uint8_t *src, int size) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 20 02 00
	00		 sub	 esp, 544		; 00000220H
  0001c	57		 push	 edi
  0001d	8d bd e0 fd ff
	ff		 lea	 edi, DWORD PTR [ebp-544]
  00023	b9 88 00 00 00	 mov	 ecx, 136		; 00000088H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd

; 48   :     if (size < 128) {

  0002f	81 7b 10 80 00
	00 00		 cmp	 DWORD PTR _size$[ebx], 128 ; 00000080H
  00036	7d 31		 jge	 SHORT $LN8@avx2_memcp

; 49   :         for (int i = 0; i < size; i++)

  00038	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$10[ebp], 0
  0003f	eb 09		 jmp	 SHORT $LN4@avx2_memcp
$LN2@avx2_memcp:
  00041	8b 45 fc	 mov	 eax, DWORD PTR _i$10[ebp]
  00044	83 c0 01	 add	 eax, 1
  00047	89 45 fc	 mov	 DWORD PTR _i$10[ebp], eax
$LN4@avx2_memcp:
  0004a	8b 4d fc	 mov	 ecx, DWORD PTR _i$10[ebp]
  0004d	3b 4b 10	 cmp	 ecx, DWORD PTR _size$[ebx]
  00050	7d 12		 jge	 SHORT $LN3@avx2_memcp

; 50   :             dst[i] = src[i];

  00052	8b 53 08	 mov	 edx, DWORD PTR _dst$[ebx]
  00055	03 55 fc	 add	 edx, DWORD PTR _i$10[ebp]
  00058	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  0005b	03 45 fc	 add	 eax, DWORD PTR _i$10[ebp]
  0005e	8a 08		 mov	 cl, BYTE PTR [eax]
  00060	88 0a		 mov	 BYTE PTR [edx], cl
  00062	eb dd		 jmp	 SHORT $LN2@avx2_memcp
$LN3@avx2_memcp:

; 51   :         return;

  00064	e9 df 02 00 00	 jmp	 $LN1@avx2_memcp
$LN8@avx2_memcp:

; 52   :     }
; 53   :     uint8_t *dst_fin = dst + size;

  00069	8b 53 08	 mov	 edx, DWORD PTR _dst$[ebx]
  0006c	03 53 10	 add	 edx, DWORD PTR _size$[ebx]
  0006f	89 55 f8	 mov	 DWORD PTR _dst_fin$[ebp], edx

; 54   :     uint8_t *dst_aligned_fin = (uint8_t *)(((size_t)(dst_fin + 31) & ~31) - 128);

  00072	8b 45 f8	 mov	 eax, DWORD PTR _dst_fin$[ebp]
  00075	83 c0 1f	 add	 eax, 31			; 0000001fH
  00078	83 e0 e0	 and	 eax, -32		; ffffffe0H
  0007b	2d 80 00 00 00	 sub	 eax, 128		; 00000080H
  00080	89 45 f4	 mov	 DWORD PTR _dst_aligned_fin$[ebp], eax

; 55   :     __m256i y0, y1, y2, y3;
; 56   :     const int start_align_diff = (int)((size_t)dst & 31);

  00083	8b 4b 08	 mov	 ecx, DWORD PTR _dst$[ebx]
  00086	83 e1 1f	 and	 ecx, 31			; 0000001fH
  00089	89 8d 5c ff ff
	ff		 mov	 DWORD PTR _start_align_diff$[ebp], ecx

; 57   :     if (start_align_diff) {

  0008f	74 4a		 je	 SHORT $LN9@avx2_memcp

; 58   :         y0 = _mm256_loadu_si256((const __m256i*)src);

  00091	8b 53 0c	 mov	 edx, DWORD PTR _src$[ebx]
  00094	c5 fe 6f 02	 vmovdqu ymm0, YMMWORD PTR [edx]
  00098	c5 fe 7f 85 20
	ff ff ff	 vmovdqu YMMWORD PTR $T9[ebp], ymm0
  000a0	c5 fe 6f 85 20
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T9[ebp]
  000a8	c5 fe 7f 45 c0	 vmovdqu YMMWORD PTR _y0$[ebp], ymm0

; 59   :         _mm256_storeu_si256((__m256i*)dst, y0);

  000ad	c5 fe 6f 45 c0	 vmovdqu ymm0, YMMWORD PTR _y0$[ebp]
  000b2	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  000b5	c5 fe 7f 00	 vmovdqu YMMWORD PTR [eax], ymm0

; 60   :         dst += 32 - start_align_diff;

  000b9	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  000be	2b 8d 5c ff ff
	ff		 sub	 ecx, DWORD PTR _start_align_diff$[ebp]
  000c4	03 4b 08	 add	 ecx, DWORD PTR _dst$[ebx]
  000c7	89 4b 08	 mov	 DWORD PTR _dst$[ebx], ecx

; 61   :         src += 32 - start_align_diff;

  000ca	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  000cf	2b 95 5c ff ff
	ff		 sub	 edx, DWORD PTR _start_align_diff$[ebp]
  000d5	03 53 0c	 add	 edx, DWORD PTR _src$[ebx]
  000d8	89 53 0c	 mov	 DWORD PTR _src$[ebx], edx
$LN9@avx2_memcp:

; 62   :     }
; 63   : #define _mm256_stream_switch_si256(x, ymm) ((use_stream) ? _mm256_stream_si256((x), (ymm)) : _mm256_store_si256((x), (ymm)))
; 64   :     for ( ; dst < dst_aligned_fin; dst += 128, src += 128) {

  000db	eb 17		 jmp	 SHORT $LN7@avx2_memcp
$LN5@avx2_memcp:
  000dd	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  000e0	05 80 00 00 00	 add	 eax, 128		; 00000080H
  000e5	89 43 08	 mov	 DWORD PTR _dst$[ebx], eax
  000e8	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  000eb	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  000f1	89 4b 0c	 mov	 DWORD PTR _src$[ebx], ecx
$LN7@avx2_memcp:
  000f4	8b 53 08	 mov	 edx, DWORD PTR _dst$[ebx]
  000f7	3b 55 f4	 cmp	 edx, DWORD PTR _dst_aligned_fin$[ebp]
  000fa	0f 83 61 01 00
	00		 jae	 $LN6@avx2_memcp

; 65   :         y0 = _mm256_loadu_si256((const __m256i*)(src +  0));

  00100	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  00103	c5 fe 6f 00	 vmovdqu ymm0, YMMWORD PTR [eax]
  00107	c5 fe 7f 85 00
	ff ff ff	 vmovdqu YMMWORD PTR $T8[ebp], ymm0
  0010f	c5 fe 6f 85 00
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T8[ebp]
  00117	c5 fe 7f 45 c0	 vmovdqu YMMWORD PTR _y0$[ebp], ymm0

; 66   :         y1 = _mm256_loadu_si256((const __m256i*)(src + 32));

  0011c	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  0011f	83 c1 20	 add	 ecx, 32			; 00000020H
  00122	c5 fe 6f 01	 vmovdqu ymm0, YMMWORD PTR [ecx]
  00126	c5 fe 7f 85 e0
	fe ff ff	 vmovdqu YMMWORD PTR $T7[ebp], ymm0
  0012e	c5 fe 6f 85 e0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T7[ebp]
  00136	c5 fe 7f 45 a0	 vmovdqu YMMWORD PTR _y1$[ebp], ymm0

; 67   :         y2 = _mm256_loadu_si256((const __m256i*)(src + 64));

  0013b	8b 53 0c	 mov	 edx, DWORD PTR _src$[ebx]
  0013e	83 c2 40	 add	 edx, 64			; 00000040H
  00141	c5 fe 6f 02	 vmovdqu ymm0, YMMWORD PTR [edx]
  00145	c5 fe 7f 85 c0
	fe ff ff	 vmovdqu YMMWORD PTR $T6[ebp], ymm0
  0014d	c5 fe 6f 85 c0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T6[ebp]
  00155	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _y2$[ebp], ymm0

; 68   :         y3 = _mm256_loadu_si256((const __m256i*)(src + 96));

  0015a	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  0015d	83 c0 60	 add	 eax, 96			; 00000060H
  00160	c5 fe 6f 00	 vmovdqu ymm0, YMMWORD PTR [eax]
  00164	c5 fe 7f 85 a0
	fe ff ff	 vmovdqu YMMWORD PTR $T5[ebp], ymm0
  0016c	c5 fe 6f 85 a0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T5[ebp]
  00174	c5 fe 7f 85 60
	ff ff ff	 vmovdqu YMMWORD PTR _y3$[ebp], ymm0

; 69   :         _mm256_stream_switch_si256((__m256i*)(dst +  0), y0);

  0017c	33 c9		 xor	 ecx, ecx
  0017e	74 18		 je	 SHORT $LN11@avx2_memcp
  00180	c5 fe 6f 45 c0	 vmovdqu ymm0, YMMWORD PTR _y0$[ebp]
  00185	8b 53 08	 mov	 edx, DWORD PTR _dst$[ebx]
  00188	c5 fd e7 02	 vmovntdq YMMWORD PTR [edx], ymm0
  0018c	c7 85 fc fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv136[ebp], 0
  00196	eb 16		 jmp	 SHORT $LN12@avx2_memcp
$LN11@avx2_memcp:
  00198	c5 fe 6f 45 c0	 vmovdqu ymm0, YMMWORD PTR _y0$[ebp]
  0019d	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  001a0	c5 fe 7f 00	 vmovdqu YMMWORD PTR [eax], ymm0
  001a4	c7 85 fc fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv136[ebp], 0
$LN12@avx2_memcp:

; 70   :         _mm256_stream_switch_si256((__m256i*)(dst + 32), y1);

  001ae	33 c9		 xor	 ecx, ecx
  001b0	74 1b		 je	 SHORT $LN13@avx2_memcp
  001b2	c5 fe 6f 45 a0	 vmovdqu ymm0, YMMWORD PTR _y1$[ebp]
  001b7	8b 53 08	 mov	 edx, DWORD PTR _dst$[ebx]
  001ba	83 c2 20	 add	 edx, 32			; 00000020H
  001bd	c5 fd e7 02	 vmovntdq YMMWORD PTR [edx], ymm0
  001c1	c7 85 f8 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv144[ebp], 0
  001cb	eb 19		 jmp	 SHORT $LN14@avx2_memcp
$LN13@avx2_memcp:
  001cd	c5 fe 6f 45 a0	 vmovdqu ymm0, YMMWORD PTR _y1$[ebp]
  001d2	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  001d5	83 c0 20	 add	 eax, 32			; 00000020H
  001d8	c5 fe 7f 00	 vmovdqu YMMWORD PTR [eax], ymm0
  001dc	c7 85 f8 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv144[ebp], 0
$LN14@avx2_memcp:

; 71   :         _mm256_stream_switch_si256((__m256i*)(dst + 64), y2);

  001e6	33 c9		 xor	 ecx, ecx
  001e8	74 1b		 je	 SHORT $LN15@avx2_memcp
  001ea	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR _y2$[ebp]
  001ef	8b 53 08	 mov	 edx, DWORD PTR _dst$[ebx]
  001f2	83 c2 40	 add	 edx, 64			; 00000040H
  001f5	c5 fd e7 02	 vmovntdq YMMWORD PTR [edx], ymm0
  001f9	c7 85 f4 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv152[ebp], 0
  00203	eb 19		 jmp	 SHORT $LN16@avx2_memcp
$LN15@avx2_memcp:
  00205	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR _y2$[ebp]
  0020a	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  0020d	83 c0 40	 add	 eax, 64			; 00000040H
  00210	c5 fe 7f 00	 vmovdqu YMMWORD PTR [eax], ymm0
  00214	c7 85 f4 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv152[ebp], 0
$LN16@avx2_memcp:

; 72   :         _mm256_stream_switch_si256((__m256i*)(dst + 96), y3);

  0021e	33 c9		 xor	 ecx, ecx
  00220	74 1e		 je	 SHORT $LN17@avx2_memcp
  00222	c5 fe 6f 85 60
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR _y3$[ebp]
  0022a	8b 53 08	 mov	 edx, DWORD PTR _dst$[ebx]
  0022d	83 c2 60	 add	 edx, 96			; 00000060H
  00230	c5 fd e7 02	 vmovntdq YMMWORD PTR [edx], ymm0
  00234	c7 85 f0 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv160[ebp], 0
  0023e	eb 1c		 jmp	 SHORT $LN18@avx2_memcp
$LN17@avx2_memcp:
  00240	c5 fe 6f 85 60
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR _y3$[ebp]
  00248	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  0024b	83 c0 60	 add	 eax, 96			; 00000060H
  0024e	c5 fe 7f 00	 vmovdqu YMMWORD PTR [eax], ymm0
  00252	c7 85 f0 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv160[ebp], 0
$LN18@avx2_memcp:

; 73   :     }

  0025c	e9 7c fe ff ff	 jmp	 $LN5@avx2_memcp
$LN6@avx2_memcp:

; 74   : #undef _mm256_stream_switch_si256
; 75   :     uint8_t *dst_tmp = dst_fin - 128;

  00261	8b 4d f8	 mov	 ecx, DWORD PTR _dst_fin$[ebp]
  00264	81 e9 80 00 00
	00		 sub	 ecx, 128		; 00000080H
  0026a	89 8d 9c fe ff
	ff		 mov	 DWORD PTR _dst_tmp$[ebp], ecx

; 76   :     src -= (dst - dst_tmp);

  00270	8b 53 08	 mov	 edx, DWORD PTR _dst$[ebx]
  00273	2b 95 9c fe ff
	ff		 sub	 edx, DWORD PTR _dst_tmp$[ebp]
  00279	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  0027c	2b c2		 sub	 eax, edx
  0027e	89 43 0c	 mov	 DWORD PTR _src$[ebx], eax

; 77   :     y0 = _mm256_loadu_si256((const __m256i*)(src +  0));

  00281	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  00284	c5 fe 6f 01	 vmovdqu ymm0, YMMWORD PTR [ecx]
  00288	c5 fe 7f 85 60
	fe ff ff	 vmovdqu YMMWORD PTR $T4[ebp], ymm0
  00290	c5 fe 6f 85 60
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T4[ebp]
  00298	c5 fe 7f 45 c0	 vmovdqu YMMWORD PTR _y0$[ebp], ymm0

; 78   :     y1 = _mm256_loadu_si256((const __m256i*)(src + 32));

  0029d	8b 53 0c	 mov	 edx, DWORD PTR _src$[ebx]
  002a0	83 c2 20	 add	 edx, 32			; 00000020H
  002a3	c5 fe 6f 02	 vmovdqu ymm0, YMMWORD PTR [edx]
  002a7	c5 fe 7f 85 40
	fe ff ff	 vmovdqu YMMWORD PTR $T3[ebp], ymm0
  002af	c5 fe 6f 85 40
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T3[ebp]
  002b7	c5 fe 7f 45 a0	 vmovdqu YMMWORD PTR _y1$[ebp], ymm0

; 79   :     y2 = _mm256_loadu_si256((const __m256i*)(src + 64));

  002bc	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  002bf	83 c0 40	 add	 eax, 64			; 00000040H
  002c2	c5 fe 6f 00	 vmovdqu ymm0, YMMWORD PTR [eax]
  002c6	c5 fe 7f 85 20
	fe ff ff	 vmovdqu YMMWORD PTR $T2[ebp], ymm0
  002ce	c5 fe 6f 85 20
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T2[ebp]
  002d6	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _y2$[ebp], ymm0

; 80   :     y3 = _mm256_loadu_si256((const __m256i*)(src + 96));

  002db	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  002de	83 c1 60	 add	 ecx, 96			; 00000060H
  002e1	c5 fe 6f 01	 vmovdqu ymm0, YMMWORD PTR [ecx]
  002e5	c5 fe 7f 85 00
	fe ff ff	 vmovdqu YMMWORD PTR $T1[ebp], ymm0
  002ed	c5 fe 6f 85 00
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T1[ebp]
  002f5	c5 fe 7f 85 60
	ff ff ff	 vmovdqu YMMWORD PTR _y3$[ebp], ymm0

; 81   :     _mm256_storeu_si256((__m256i*)(dst_tmp +  0), y0);

  002fd	c5 fe 6f 45 c0	 vmovdqu ymm0, YMMWORD PTR _y0$[ebp]
  00302	8b 95 9c fe ff
	ff		 mov	 edx, DWORD PTR _dst_tmp$[ebp]
  00308	c5 fe 7f 02	 vmovdqu YMMWORD PTR [edx], ymm0

; 82   :     _mm256_storeu_si256((__m256i*)(dst_tmp + 32), y1);

  0030c	c5 fe 6f 45 a0	 vmovdqu ymm0, YMMWORD PTR _y1$[ebp]
  00311	8b 85 9c fe ff
	ff		 mov	 eax, DWORD PTR _dst_tmp$[ebp]
  00317	83 c0 20	 add	 eax, 32			; 00000020H
  0031a	c5 fe 7f 00	 vmovdqu YMMWORD PTR [eax], ymm0

; 83   :     _mm256_storeu_si256((__m256i*)(dst_tmp + 64), y2);

  0031e	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR _y2$[ebp]
  00323	8b 8d 9c fe ff
	ff		 mov	 ecx, DWORD PTR _dst_tmp$[ebp]
  00329	83 c1 40	 add	 ecx, 64			; 00000040H
  0032c	c5 fe 7f 01	 vmovdqu YMMWORD PTR [ecx], ymm0

; 84   :     _mm256_storeu_si256((__m256i*)(dst_tmp + 96), y3);

  00330	c5 fe 6f 85 60
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR _y3$[ebp]
  00338	8b 95 9c fe ff
	ff		 mov	 edx, DWORD PTR _dst_tmp$[ebp]
  0033e	83 c2 60	 add	 edx, 96			; 00000060H
  00341	c5 fe 7f 02	 vmovdqu YMMWORD PTR [edx], ymm0

; 85   :     _mm256_zeroupper();

  00345	c5 f8 77	 vzeroupper
$LN1@avx2_memcp:

; 86   : }

  00348	5f		 pop	 edi
  00349	8b e5		 mov	 esp, ebp
  0034b	5d		 pop	 ebp
  0034c	8b e3		 mov	 esp, ebx
  0034e	5b		 pop	 ebx
  0034f	c3		 ret	 0
??$avx2_memcpy@$0A@@@YAXPAEPBEH@Z ENDP			; avx2_memcpy<0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
$T1 = -80						; size = 12
_y$2 = -68						; size = 4
_y_width$ = -64						; size = 4
_dstLine$ = -60						; size = 4
_srcLine$ = -56						; size = 4
$T3 = -52						; size = 12
_y_range$ = -36						; size = 12
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_rgb32_to_rgb32_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_rgb32_to_rgb32_avx2

; 403  : void convert_rgb32_to_rgb32_avx2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	57		 push	 edi
  00007	8d 7d b0	 lea	 edi, DWORD PTR [ebp-80]
  0000a	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  0000f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00014	f3 ab		 rep stosd
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 404  :     const int crop_left   = crop[0];

  00020	b8 04 00 00 00	 mov	 eax, 4
  00025	6b c8 00	 imul	 ecx, eax, 0
  00028	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  0002b	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0002e	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 405  :     const int crop_up     = crop[1];

  00031	b9 04 00 00 00	 mov	 ecx, 4
  00036	c1 e1 00	 shl	 ecx, 0
  00039	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  0003c	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0003f	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 406  :     const int crop_right  = crop[2];

  00042	b9 04 00 00 00	 mov	 ecx, 4
  00047	d1 e1		 shl	 ecx, 1
  00049	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  0004c	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0004f	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 407  :     const int crop_bottom = crop[3];

  00052	b9 04 00 00 00	 mov	 ecx, 4
  00057	6b d1 03	 imul	 edx, ecx, 3
  0005a	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  0005d	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00060	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 408  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00063	8b 55 2c	 mov	 edx, DWORD PTR _thread_n$[ebp]
  00066	52		 push	 edx
  00067	8b 45 28	 mov	 eax, DWORD PTR _thread_id$[ebp]
  0006a	50		 push	 eax
  0006b	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  0006e	2b 4d ec	 sub	 ecx, DWORD PTR _crop_bottom$[ebp]
  00071	51		 push	 ecx
  00072	8b 55 f4	 mov	 edx, DWORD PTR _crop_up$[ebp]
  00075	52		 push	 edx
  00076	8d 45 b0	 lea	 eax, DWORD PTR $T1[ebp]
  00079	50		 push	 eax
  0007a	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  0007f	83 c4 14	 add	 esp, 20			; 00000014H
  00082	8b 08		 mov	 ecx, DWORD PTR [eax]
  00084	89 4d cc	 mov	 DWORD PTR $T3[ebp], ecx
  00087	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0008a	89 55 d0	 mov	 DWORD PTR $T3[ebp+4], edx
  0008d	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00090	89 45 d4	 mov	 DWORD PTR $T3[ebp+8], eax
  00093	8b 4d cc	 mov	 ecx, DWORD PTR $T3[ebp]
  00096	89 4d dc	 mov	 DWORD PTR _y_range$[ebp], ecx
  00099	8b 55 d0	 mov	 edx, DWORD PTR $T3[ebp+4]
  0009c	89 55 e0	 mov	 DWORD PTR _y_range$[ebp+4], edx
  0009f	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp+8]
  000a2	89 45 e4	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 409  :     uint8_t *srcLine = (uint8_t *)src[0] + src_y_pitch_byte * y_range.start_src + crop_left * 4;

  000a5	b9 04 00 00 00	 mov	 ecx, 4
  000aa	6b d1 00	 imul	 edx, ecx, 0
  000ad	8b 45 14	 mov	 eax, DWORD PTR _src_y_pitch_byte$[ebp]
  000b0	0f af 45 dc	 imul	 eax, DWORD PTR _y_range$[ebp]
  000b4	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  000b7	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  000ba	03 d0		 add	 edx, eax
  000bc	8b 45 f8	 mov	 eax, DWORD PTR _crop_left$[ebp]
  000bf	8d 0c 82	 lea	 ecx, DWORD PTR [edx+eax*4]
  000c2	89 4d c8	 mov	 DWORD PTR _srcLine$[ebp], ecx

; 410  :     uint8_t *dstLine = (uint8_t *)dst[0] + dst_y_pitch_byte * y_range.start_dst;

  000c5	ba 04 00 00 00	 mov	 edx, 4
  000ca	6b c2 00	 imul	 eax, edx, 0
  000cd	8b 4d 1c	 mov	 ecx, DWORD PTR _dst_y_pitch_byte$[ebp]
  000d0	0f af 4d e0	 imul	 ecx, DWORD PTR _y_range$[ebp+4]
  000d4	8b 55 08	 mov	 edx, DWORD PTR _dst$[ebp]
  000d7	03 0c 02	 add	 ecx, DWORD PTR [edx+eax]
  000da	89 4d c4	 mov	 DWORD PTR _dstLine$[ebp], ecx

; 411  :     const int y_width = width - crop_right - crop_left;

  000dd	8b 45 10	 mov	 eax, DWORD PTR _width$[ebp]
  000e0	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  000e3	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  000e6	89 45 c0	 mov	 DWORD PTR _y_width$[ebp], eax

; 412  :     for (int y = 0; y < y_range.len; y++, dstLine += dst_y_pitch_byte, srcLine += src_y_pitch_byte) {

  000e9	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _y$2[ebp], 0
  000f0	eb 1b		 jmp	 SHORT $LN4@convert_rg
$LN2@convert_rg:
  000f2	8b 4d bc	 mov	 ecx, DWORD PTR _y$2[ebp]
  000f5	83 c1 01	 add	 ecx, 1
  000f8	89 4d bc	 mov	 DWORD PTR _y$2[ebp], ecx
  000fb	8b 55 c4	 mov	 edx, DWORD PTR _dstLine$[ebp]
  000fe	03 55 1c	 add	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  00101	89 55 c4	 mov	 DWORD PTR _dstLine$[ebp], edx
  00104	8b 45 c8	 mov	 eax, DWORD PTR _srcLine$[ebp]
  00107	03 45 14	 add	 eax, DWORD PTR _src_y_pitch_byte$[ebp]
  0010a	89 45 c8	 mov	 DWORD PTR _srcLine$[ebp], eax
$LN4@convert_rg:
  0010d	8b 4d bc	 mov	 ecx, DWORD PTR _y$2[ebp]
  00110	3b 4d e4	 cmp	 ecx, DWORD PTR _y_range$[ebp+8]
  00113	7d 19		 jge	 SHORT $LN3@convert_rg

; 413  :         avx2_memcpy<false>(dstLine, srcLine, y_width * 4);

  00115	8b 55 c0	 mov	 edx, DWORD PTR _y_width$[ebp]
  00118	c1 e2 02	 shl	 edx, 2
  0011b	52		 push	 edx
  0011c	8b 45 c8	 mov	 eax, DWORD PTR _srcLine$[ebp]
  0011f	50		 push	 eax
  00120	8b 4d c4	 mov	 ecx, DWORD PTR _dstLine$[ebp]
  00123	51		 push	 ecx
  00124	e8 00 00 00 00	 call	 ??$avx2_memcpy@$0A@@@YAXPAEPBEH@Z ; avx2_memcpy<0>
  00129	83 c4 0c	 add	 esp, 12			; 0000000cH

; 414  :     }

  0012c	eb c4		 jmp	 SHORT $LN2@convert_rg
$LN3@convert_rg:

; 415  :     _mm256_zeroupper();

  0012e	c5 f8 77	 vzeroupper

; 416  : }

  00131	52		 push	 edx
  00132	8b cd		 mov	 ecx, ebp
  00134	50		 push	 eax
  00135	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN8@convert_rg
  0013b	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00140	58		 pop	 eax
  00141	5a		 pop	 edx
  00142	5f		 pop	 edi
  00143	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00146	33 cd		 xor	 ecx, ebp
  00148	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0014d	83 c4 50	 add	 esp, 80			; 00000050H
  00150	3b ec		 cmp	 ebp, esp
  00152	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00157	8b e5		 mov	 esp, ebp
  00159	5d		 pop	 ebp
  0015a	c3		 ret	 0
  0015b	90		 npad	 1
$LN8@convert_rg:
  0015c	01 00 00 00	 DD	 1
  00160	00 00 00 00	 DD	 $LN7@convert_rg
$LN7@convert_rg:
  00164	dc ff ff ff	 DD	 -36			; ffffffdcH
  00168	0c 00 00 00	 DD	 12			; 0000000cH
  0016c	00 00 00 00	 DD	 $LN6@convert_rg
$LN6@convert_rg:
  00170	79		 DB	 121			; 00000079H
  00171	5f		 DB	 95			; 0000005fH
  00172	72		 DB	 114			; 00000072H
  00173	61		 DB	 97			; 00000061H
  00174	6e		 DB	 110			; 0000006eH
  00175	67		 DB	 103			; 00000067H
  00176	65		 DB	 101			; 00000065H
  00177	00		 DB	 0
?convert_rgb32_to_rgb32_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_rgb32_to_rgb32_avx2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
$T1 = -1104						; size = 12
$T2 = -1088						; size = 32
$T3 = -1056						; size = 32
$T4 = -1024						; size = 32
$T5 = -992						; size = 32
$T6 = -960						; size = 32
$T7 = -928						; size = 32
$T8 = -896						; size = 32
$T9 = -864						; size = 32
$T10 = -832						; size = 32
$T11 = -800						; size = 32
$T12 = -768						; size = 32
_y3$13 = -736						; size = 32
$T14 = -704						; size = 32
$T15 = -656						; size = 16
$T16 = -640						; size = 32
$T17 = -592						; size = 16
_y2$18 = -576						; size = 32
$T19 = -544						; size = 32
$T20 = -496						; size = 16
$T21 = -480						; size = 32
$T22 = -432						; size = 16
_y1$23 = -416						; size = 32
$T24 = -384						; size = 32
$T25 = -336						; size = 16
$T26 = -320						; size = 32
$T27 = -272						; size = 16
_y0$28 = -256						; size = 32
_x_fin$29 = -212					; size = 4
_x$30 = -208						; size = 4
_ptr_dst$31 = -204					; size = 4
_ptr_src$32 = -200					; size = 4
_y$33 = -196						; size = 4
$T34 = -192						; size = 32
_yMask$ = -160						; size = 32
_MASK_RGB3_TO_RGB4$ = -96				; size = 32
_dstLine$ = -60						; size = 4
_srcLine$ = -56						; size = 4
$T35 = -52						; size = 12
_y_range$ = -36						; size = 12
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_rgb24r_to_rgb32_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_rgb24r_to_rgb32_avx2

; 361  : void convert_rgb24r_to_rgb32_avx2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 60 04 00
	00		 sub	 esp, 1120		; 00000460H
  0001c	57		 push	 edi
  0001d	8d bd a0 fb ff
	ff		 lea	 edi, DWORD PTR [ebp-1120]
  00023	b9 18 01 00 00	 mov	 ecx, 280		; 00000118H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 362  :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 363  :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 364  :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 365  :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 366  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  0007c	8b 53 2c	 mov	 edx, DWORD PTR _thread_n$[ebx]
  0007f	52		 push	 edx
  00080	8b 43 28	 mov	 eax, DWORD PTR _thread_id$[ebx]
  00083	50		 push	 eax
  00084	8b 4b 20	 mov	 ecx, DWORD PTR _height$[ebx]
  00087	2b 4d ec	 sub	 ecx, DWORD PTR _crop_bottom$[ebp]
  0008a	51		 push	 ecx
  0008b	8b 55 f4	 mov	 edx, DWORD PTR _crop_up$[ebp]
  0008e	52		 push	 edx
  0008f	8d 85 b0 fb ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  00095	50		 push	 eax
  00096	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  0009b	83 c4 14	 add	 esp, 20			; 00000014H
  0009e	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a0	89 4d cc	 mov	 DWORD PTR $T35[ebp], ecx
  000a3	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a6	89 55 d0	 mov	 DWORD PTR $T35[ebp+4], edx
  000a9	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000ac	89 45 d4	 mov	 DWORD PTR $T35[ebp+8], eax
  000af	8b 4d cc	 mov	 ecx, DWORD PTR $T35[ebp]
  000b2	89 4d dc	 mov	 DWORD PTR _y_range$[ebp], ecx
  000b5	8b 55 d0	 mov	 edx, DWORD PTR $T35[ebp+4]
  000b8	89 55 e0	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000bb	8b 45 d4	 mov	 eax, DWORD PTR $T35[ebp+8]
  000be	89 45 e4	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 367  :     uint8_t *srcLine = (uint8_t *)src[0] + src_y_pitch_byte * ((y_range.start_src + y_range.len) - 1) + crop_left * 3;

  000c1	b9 04 00 00 00	 mov	 ecx, 4
  000c6	6b d1 00	 imul	 edx, ecx, 0
  000c9	8b 45 e4	 mov	 eax, DWORD PTR _y_range$[ebp+8]
  000cc	8b 4d dc	 mov	 ecx, DWORD PTR _y_range$[ebp]
  000cf	8d 44 01 ff	 lea	 eax, DWORD PTR [ecx+eax-1]
  000d3	0f af 43 14	 imul	 eax, DWORD PTR _src_y_pitch_byte$[ebx]
  000d7	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  000da	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  000dd	03 d0		 add	 edx, eax
  000df	6b 45 f8 03	 imul	 eax, DWORD PTR _crop_left$[ebp], 3
  000e3	03 d0		 add	 edx, eax
  000e5	89 55 c8	 mov	 DWORD PTR _srcLine$[ebp], edx

; 368  :     uint8_t *dstLine = (uint8_t *)dst[0] + dst_y_pitch_byte * (height - (y_range.start_dst + y_range.len));

  000e8	b9 04 00 00 00	 mov	 ecx, 4
  000ed	6b d1 00	 imul	 edx, ecx, 0
  000f0	8b 45 e0	 mov	 eax, DWORD PTR _y_range$[ebp+4]
  000f3	03 45 e4	 add	 eax, DWORD PTR _y_range$[ebp+8]
  000f6	8b 4b 20	 mov	 ecx, DWORD PTR _height$[ebx]
  000f9	2b c8		 sub	 ecx, eax
  000fb	0f af 4b 1c	 imul	 ecx, DWORD PTR _dst_y_pitch_byte$[ebx]
  000ff	8b 43 08	 mov	 eax, DWORD PTR _dst$[ebx]
  00102	03 0c 10	 add	 ecx, DWORD PTR [eax+edx]
  00105	89 4d c4	 mov	 DWORD PTR _dstLine$[ebp], ecx

; 369  :     alignas(32) const char MASK_RGB3_TO_RGB4[] = {
; 370  :         0, 1, 2, -1, 3, 4, 5, -1, 6, 7, 8, -1, 9, 10, 11, -1,

  00108	c6 45 a0 00	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp], 0
  0010c	c6 45 a1 01	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+1], 1
  00110	c6 45 a2 02	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+2], 2
  00114	c6 45 a3 ff	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+3], -1
  00118	c6 45 a4 03	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+4], 3
  0011c	c6 45 a5 04	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+5], 4
  00120	c6 45 a6 05	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+6], 5
  00124	c6 45 a7 ff	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+7], -1
  00128	c6 45 a8 06	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+8], 6
  0012c	c6 45 a9 07	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+9], 7
  00130	c6 45 aa 08	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+10], 8
  00134	c6 45 ab ff	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+11], -1
  00138	c6 45 ac 09	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+12], 9
  0013c	c6 45 ad 0a	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+13], 10 ; 0000000aH
  00140	c6 45 ae 0b	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+14], 11 ; 0000000bH
  00144	c6 45 af ff	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+15], -1

; 371  :         0, 1, 2, -1, 3, 4, 5, -1, 6, 7, 8, -1, 9, 10, 11, -1

  00148	c6 45 b0 00	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+16], 0
  0014c	c6 45 b1 01	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+17], 1
  00150	c6 45 b2 02	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+18], 2
  00154	c6 45 b3 ff	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+19], -1
  00158	c6 45 b4 03	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+20], 3
  0015c	c6 45 b5 04	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+21], 4
  00160	c6 45 b6 05	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+22], 5
  00164	c6 45 b7 ff	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+23], -1
  00168	c6 45 b8 06	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+24], 6
  0016c	c6 45 b9 07	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+25], 7
  00170	c6 45 ba 08	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+26], 8
  00174	c6 45 bb ff	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+27], -1
  00178	c6 45 bc 09	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+28], 9
  0017c	c6 45 bd 0a	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+29], 10 ; 0000000aH
  00180	c6 45 be 0b	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+30], 11 ; 0000000bH
  00184	c6 45 bf ff	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+31], -1

; 372  :     };
; 373  :     __m256i yMask = _mm256_load_si256((__m256i*)MASK_RGB3_TO_RGB4);

  00188	c5 fd 6f 45 a0	 vmovdqa ymm0, YMMWORD PTR _MASK_RGB3_TO_RGB4$[ebp]
  0018d	c5 fe 7f 85 40
	ff ff ff	 vmovdqu YMMWORD PTR $T34[ebp], ymm0
  00195	c5 fe 6f 85 40
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T34[ebp]
  0019d	c5 fe 7f 85 60
	ff ff ff	 vmovdqu YMMWORD PTR _yMask$[ebp], ymm0

; 374  :     for (int y = 0; y < y_range.len; y++, srcLine -= src_y_pitch_byte, dstLine += dst_y_pitch_byte) {

  001a5	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _y$33[ebp], 0
  001af	eb 21		 jmp	 SHORT $LN4@convert_rg
$LN2@convert_rg:
  001b1	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _y$33[ebp]
  001b7	83 c1 01	 add	 ecx, 1
  001ba	89 8d 3c ff ff
	ff		 mov	 DWORD PTR _y$33[ebp], ecx
  001c0	8b 55 c8	 mov	 edx, DWORD PTR _srcLine$[ebp]
  001c3	2b 53 14	 sub	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  001c6	89 55 c8	 mov	 DWORD PTR _srcLine$[ebp], edx
  001c9	8b 45 c4	 mov	 eax, DWORD PTR _dstLine$[ebp]
  001cc	03 43 1c	 add	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  001cf	89 45 c4	 mov	 DWORD PTR _dstLine$[ebp], eax
$LN4@convert_rg:
  001d2	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _y$33[ebp]
  001d8	3b 4d e4	 cmp	 ecx, DWORD PTR _y_range$[ebp+8]
  001db	0f 8d de 03 00
	00		 jge	 $LN3@convert_rg

; 375  :         uint8_t *ptr_src = srcLine;

  001e1	8b 55 c8	 mov	 edx, DWORD PTR _srcLine$[ebp]
  001e4	89 95 38 ff ff
	ff		 mov	 DWORD PTR _ptr_src$32[ebp], edx

; 376  :         uint8_t *ptr_dst = dstLine;

  001ea	8b 45 c4	 mov	 eax, DWORD PTR _dstLine$[ebp]
  001ed	89 85 34 ff ff
	ff		 mov	 DWORD PTR _ptr_dst$31[ebp], eax

; 377  :         int x = 0, x_fin = width - crop_left - crop_right - 32;

  001f3	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _x$30[ebp], 0
  001fd	8b 4b 10	 mov	 ecx, DWORD PTR _width$[ebx]
  00200	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  00203	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  00206	83 e9 20	 sub	 ecx, 32			; 00000020H
  00209	89 8d 2c ff ff
	ff		 mov	 DWORD PTR _x_fin$29[ebp], ecx

; 378  :         for ( ; x < x_fin; x += 32, ptr_dst += 128, ptr_src += 96) {

  0020f	eb 2f		 jmp	 SHORT $LN7@convert_rg
$LN5@convert_rg:
  00211	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR _x$30[ebp]
  00217	83 c2 20	 add	 edx, 32			; 00000020H
  0021a	89 95 30 ff ff
	ff		 mov	 DWORD PTR _x$30[ebp], edx
  00220	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR _ptr_dst$31[ebp]
  00226	05 80 00 00 00	 add	 eax, 128		; 00000080H
  0022b	89 85 34 ff ff
	ff		 mov	 DWORD PTR _ptr_dst$31[ebp], eax
  00231	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR _ptr_src$32[ebp]
  00237	83 c1 60	 add	 ecx, 96			; 00000060H
  0023a	89 8d 38 ff ff
	ff		 mov	 DWORD PTR _ptr_src$32[ebp], ecx
$LN7@convert_rg:
  00240	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR _x$30[ebp]
  00246	3b 95 2c ff ff
	ff		 cmp	 edx, DWORD PTR _x_fin$29[ebp]
  0024c	0f 8d f8 02 00
	00		 jge	 $LN6@convert_rg

; 379  :             __m256i y0 = _mm256_set_m128i(_mm_loadu_si128((__m128i*)(ptr_src+48)), _mm_loadu_si128((__m128i*)(ptr_src+ 0))); //384,   0

  00252	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _ptr_src$32[ebp]
  00258	83 c0 30	 add	 eax, 48			; 00000030H
  0025b	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  0025e	0f 29 85 b0 fe
	ff ff		 movaps	 XMMWORD PTR $T25[ebp], xmm0
  00265	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR _ptr_src$32[ebp]
  0026b	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  0026e	0f 29 85 f0 fe
	ff ff		 movaps	 XMMWORD PTR $T27[ebp], xmm0
  00275	c5 fa 6f 85 f0
	fe ff ff	 vmovdqu xmm0, XMMWORD PTR $T27[ebp]
  0027d	c5 fe 7f 85 c0
	fe ff ff	 vmovdqu YMMWORD PTR $T26[ebp], ymm0
  00285	c5 fe 6f 85 c0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T26[ebp]
  0028d	c4 e3 7d 18 85
	b0 fe ff ff 01	 vinsertf128 ymm0, ymm0, XMMWORD PTR $T25[ebp], 1
  00297	c5 fe 7f 85 80
	fe ff ff	 vmovdqu YMMWORD PTR $T24[ebp], ymm0
  0029f	c5 fe 6f 85 80
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T24[ebp]
  002a7	c5 fe 7f 85 00
	ff ff ff	 vmovdqu YMMWORD PTR _y0$28[ebp], ymm0

; 380  :             __m256i y1 = _mm256_set_m128i(_mm_loadu_si128((__m128i*)(ptr_src+64)), _mm_loadu_si128((__m128i*)(ptr_src+16))); //512, 128

  002af	8b 95 38 ff ff
	ff		 mov	 edx, DWORD PTR _ptr_src$32[ebp]
  002b5	83 c2 40	 add	 edx, 64			; 00000040H
  002b8	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  002bb	0f 29 85 10 fe
	ff ff		 movaps	 XMMWORD PTR $T20[ebp], xmm0
  002c2	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _ptr_src$32[ebp]
  002c8	83 c0 10	 add	 eax, 16			; 00000010H
  002cb	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  002ce	0f 29 85 50 fe
	ff ff		 movaps	 XMMWORD PTR $T22[ebp], xmm0
  002d5	c5 fa 6f 85 50
	fe ff ff	 vmovdqu xmm0, XMMWORD PTR $T22[ebp]
  002dd	c5 fe 7f 85 20
	fe ff ff	 vmovdqu YMMWORD PTR $T21[ebp], ymm0
  002e5	c5 fe 6f 85 20
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T21[ebp]
  002ed	c4 e3 7d 18 85
	10 fe ff ff 01	 vinsertf128 ymm0, ymm0, XMMWORD PTR $T20[ebp], 1
  002f7	c5 fe 7f 85 e0
	fd ff ff	 vmovdqu YMMWORD PTR $T19[ebp], ymm0
  002ff	c5 fe 6f 85 e0
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T19[ebp]
  00307	c5 fe 7f 85 60
	fe ff ff	 vmovdqu YMMWORD PTR _y1$23[ebp], ymm0

; 381  :             __m256i y2 = _mm256_set_m128i(_mm_loadu_si128((__m128i*)(ptr_src+80)), _mm_loadu_si128((__m128i*)(ptr_src+32))); //640, 256

  0030f	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR _ptr_src$32[ebp]
  00315	83 c1 50	 add	 ecx, 80			; 00000050H
  00318	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  0031b	0f 29 85 70 fd
	ff ff		 movaps	 XMMWORD PTR $T15[ebp], xmm0
  00322	8b 95 38 ff ff
	ff		 mov	 edx, DWORD PTR _ptr_src$32[ebp]
  00328	83 c2 20	 add	 edx, 32			; 00000020H
  0032b	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  0032e	0f 29 85 b0 fd
	ff ff		 movaps	 XMMWORD PTR $T17[ebp], xmm0
  00335	c5 fa 6f 85 b0
	fd ff ff	 vmovdqu xmm0, XMMWORD PTR $T17[ebp]
  0033d	c5 fe 7f 85 80
	fd ff ff	 vmovdqu YMMWORD PTR $T16[ebp], ymm0
  00345	c5 fe 6f 85 80
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T16[ebp]
  0034d	c4 e3 7d 18 85
	70 fd ff ff 01	 vinsertf128 ymm0, ymm0, XMMWORD PTR $T15[ebp], 1
  00357	c5 fe 7f 85 40
	fd ff ff	 vmovdqu YMMWORD PTR $T14[ebp], ymm0
  0035f	c5 fe 6f 85 40
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T14[ebp]
  00367	c5 fe 7f 85 c0
	fd ff ff	 vmovdqu YMMWORD PTR _y2$18[ebp], ymm0

; 382  :             __m256i y3 = _mm256_srli_si256(y2, 4);

  0036f	c5 fe 6f 85 c0
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR _y2$18[ebp]
  00377	c5 fd 73 d8 04	 vpsrldq ymm0, ymm0, 4
  0037c	c5 fe 7f 85 00
	fd ff ff	 vmovdqu YMMWORD PTR $T12[ebp], ymm0
  00384	c5 fe 6f 85 00
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T12[ebp]
  0038c	c5 fe 7f 85 20
	fd ff ff	 vmovdqu YMMWORD PTR _y3$13[ebp], ymm0

; 383  :             y3 = _mm256_shuffle_epi8(y3, yMask); // 896, 384

  00394	c5 fe 6f 85 20
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR _y3$13[ebp]
  0039c	c4 e2 7d 00 85
	60 ff ff ff	 vpshufb ymm0, ymm0, YMMWORD PTR _yMask$[ebp]
  003a5	c5 fe 7f 85 e0
	fc ff ff	 vmovdqu YMMWORD PTR $T11[ebp], ymm0
  003ad	c5 fe 6f 85 e0
	fc ff ff	 vmovdqu ymm0, YMMWORD PTR $T11[ebp]
  003b5	c5 fe 7f 85 20
	fd ff ff	 vmovdqu YMMWORD PTR _y3$13[ebp], ymm0

; 384  :             y2 = _mm256_alignr_epi8(y2, y1, 8);

  003bd	c5 fe 6f 85 c0
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR _y2$18[ebp]
  003c5	c4 e3 7d 0f 85
	60 fe ff ff 08	 vpalignr ymm0, ymm0, YMMWORD PTR _y1$23[ebp], 8
  003cf	c5 fe 7f 85 c0
	fc ff ff	 vmovdqu YMMWORD PTR $T10[ebp], ymm0
  003d7	c5 fe 6f 85 c0
	fc ff ff	 vmovdqu ymm0, YMMWORD PTR $T10[ebp]
  003df	c5 fe 7f 85 c0
	fd ff ff	 vmovdqu YMMWORD PTR _y2$18[ebp], ymm0

; 385  :             y2 = _mm256_shuffle_epi8(y2, yMask); // 768, 256

  003e7	c5 fe 6f 85 c0
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR _y2$18[ebp]
  003ef	c4 e2 7d 00 85
	60 ff ff ff	 vpshufb ymm0, ymm0, YMMWORD PTR _yMask$[ebp]
  003f8	c5 fe 7f 85 a0
	fc ff ff	 vmovdqu YMMWORD PTR $T9[ebp], ymm0
  00400	c5 fe 6f 85 a0
	fc ff ff	 vmovdqu ymm0, YMMWORD PTR $T9[ebp]
  00408	c5 fe 7f 85 c0
	fd ff ff	 vmovdqu YMMWORD PTR _y2$18[ebp], ymm0

; 386  :             y1 = _mm256_alignr_epi8(y1, y0, 12);

  00410	c5 fe 6f 85 60
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR _y1$23[ebp]
  00418	c4 e3 7d 0f 85
	00 ff ff ff 0c	 vpalignr ymm0, ymm0, YMMWORD PTR _y0$28[ebp], 12 ; 0000000cH
  00422	c5 fe 7f 85 80
	fc ff ff	 vmovdqu YMMWORD PTR $T8[ebp], ymm0
  0042a	c5 fe 6f 85 80
	fc ff ff	 vmovdqu ymm0, YMMWORD PTR $T8[ebp]
  00432	c5 fe 7f 85 60
	fe ff ff	 vmovdqu YMMWORD PTR _y1$23[ebp], ymm0

; 387  :             y1 = _mm256_shuffle_epi8(y1, yMask); // 640, 128

  0043a	c5 fe 6f 85 60
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR _y1$23[ebp]
  00442	c4 e2 7d 00 85
	60 ff ff ff	 vpshufb ymm0, ymm0, YMMWORD PTR _yMask$[ebp]
  0044b	c5 fe 7f 85 60
	fc ff ff	 vmovdqu YMMWORD PTR $T7[ebp], ymm0
  00453	c5 fe 6f 85 60
	fc ff ff	 vmovdqu ymm0, YMMWORD PTR $T7[ebp]
  0045b	c5 fe 7f 85 60
	fe ff ff	 vmovdqu YMMWORD PTR _y1$23[ebp], ymm0

; 388  :             y0 = _mm256_shuffle_epi8(y0, yMask); // 512,   0

  00463	c5 fe 6f 85 00
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR _y0$28[ebp]
  0046b	c4 e2 7d 00 85
	60 ff ff ff	 vpshufb ymm0, ymm0, YMMWORD PTR _yMask$[ebp]
  00474	c5 fe 7f 85 40
	fc ff ff	 vmovdqu YMMWORD PTR $T6[ebp], ymm0
  0047c	c5 fe 6f 85 40
	fc ff ff	 vmovdqu ymm0, YMMWORD PTR $T6[ebp]
  00484	c5 fe 7f 85 00
	ff ff ff	 vmovdqu YMMWORD PTR _y0$28[ebp], ymm0

; 389  :             _mm256_storeu_si256((__m256i*)(ptr_dst +  0), _mm256_permute2x128_si256(y0, y1, (2<<4) | 0)); // 128,   0

  0048c	c5 fe 6f 85 00
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR _y0$28[ebp]
  00494	c4 e3 7d 46 85
	60 fe ff ff 20	 vperm2i128 ymm0, ymm0, YMMWORD PTR _y1$23[ebp], 32 ; 00000020H
  0049e	c5 fe 7f 85 20
	fc ff ff	 vmovdqu YMMWORD PTR $T5[ebp], ymm0
  004a6	c5 fe 6f 85 20
	fc ff ff	 vmovdqu ymm0, YMMWORD PTR $T5[ebp]
  004ae	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR _ptr_dst$31[ebp]
  004b4	c5 fe 7f 00	 vmovdqu YMMWORD PTR [eax], ymm0

; 390  :             _mm256_storeu_si256((__m256i*)(ptr_dst + 32), _mm256_permute2x128_si256(y2, y3, (2<<4) | 0)); // 384, 256

  004b8	c5 fe 6f 85 c0
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR _y2$18[ebp]
  004c0	c4 e3 7d 46 85
	20 fd ff ff 20	 vperm2i128 ymm0, ymm0, YMMWORD PTR _y3$13[ebp], 32 ; 00000020H
  004ca	c5 fe 7f 85 00
	fc ff ff	 vmovdqu YMMWORD PTR $T4[ebp], ymm0
  004d2	c5 fe 6f 85 00
	fc ff ff	 vmovdqu ymm0, YMMWORD PTR $T4[ebp]
  004da	8b 8d 34 ff ff
	ff		 mov	 ecx, DWORD PTR _ptr_dst$31[ebp]
  004e0	83 c1 20	 add	 ecx, 32			; 00000020H
  004e3	c5 fe 7f 01	 vmovdqu YMMWORD PTR [ecx], ymm0

; 391  :             _mm256_storeu_si256((__m256i*)(ptr_dst + 64), _mm256_permute2x128_si256(y0, y1, (3<<4) | 1)); // 640, 512

  004e7	c5 fe 6f 85 00
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR _y0$28[ebp]
  004ef	c4 e3 7d 46 85
	60 fe ff ff 31	 vperm2i128 ymm0, ymm0, YMMWORD PTR _y1$23[ebp], 49 ; 00000031H
  004f9	c5 fe 7f 85 e0
	fb ff ff	 vmovdqu YMMWORD PTR $T3[ebp], ymm0
  00501	c5 fe 6f 85 e0
	fb ff ff	 vmovdqu ymm0, YMMWORD PTR $T3[ebp]
  00509	8b 95 34 ff ff
	ff		 mov	 edx, DWORD PTR _ptr_dst$31[ebp]
  0050f	83 c2 40	 add	 edx, 64			; 00000040H
  00512	c5 fe 7f 02	 vmovdqu YMMWORD PTR [edx], ymm0

; 392  :             _mm256_storeu_si256((__m256i*)(ptr_dst + 96), _mm256_permute2x128_si256(y2, y3, (3<<4) | 1)); // 896, 768

  00516	c5 fe 6f 85 c0
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR _y2$18[ebp]
  0051e	c4 e3 7d 46 85
	20 fd ff ff 31	 vperm2i128 ymm0, ymm0, YMMWORD PTR _y3$13[ebp], 49 ; 00000031H
  00528	c5 fe 7f 85 c0
	fb ff ff	 vmovdqu YMMWORD PTR $T2[ebp], ymm0
  00530	c5 fe 6f 85 c0
	fb ff ff	 vmovdqu ymm0, YMMWORD PTR $T2[ebp]
  00538	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR _ptr_dst$31[ebp]
  0053e	83 c0 60	 add	 eax, 96			; 00000060H
  00541	c5 fe 7f 00	 vmovdqu YMMWORD PTR [eax], ymm0

; 393  :         }

  00545	e9 c7 fc ff ff	 jmp	 $LN5@convert_rg
$LN6@convert_rg:

; 394  :         x_fin = width - crop_left - crop_right;

  0054a	8b 4b 10	 mov	 ecx, DWORD PTR _width$[ebx]
  0054d	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  00550	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  00553	89 8d 2c ff ff
	ff		 mov	 DWORD PTR _x_fin$29[ebp], ecx

; 395  :         for ( ; x < x_fin; x++, ptr_dst += 4, ptr_src += 3) {

  00559	eb 2d		 jmp	 SHORT $LN10@convert_rg
$LN8@convert_rg:
  0055b	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR _x$30[ebp]
  00561	83 c2 01	 add	 edx, 1
  00564	89 95 30 ff ff
	ff		 mov	 DWORD PTR _x$30[ebp], edx
  0056a	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR _ptr_dst$31[ebp]
  00570	83 c0 04	 add	 eax, 4
  00573	89 85 34 ff ff
	ff		 mov	 DWORD PTR _ptr_dst$31[ebp], eax
  00579	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR _ptr_src$32[ebp]
  0057f	83 c1 03	 add	 ecx, 3
  00582	89 8d 38 ff ff
	ff		 mov	 DWORD PTR _ptr_src$32[ebp], ecx
$LN10@convert_rg:
  00588	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR _x$30[ebp]
  0058e	3b 95 2c ff ff
	ff		 cmp	 edx, DWORD PTR _x_fin$29[ebp]
  00594	7d 24		 jge	 SHORT $LN9@convert_rg

; 396  :             *(int *)ptr_dst = *(int *)ptr_src;

  00596	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR _ptr_dst$31[ebp]
  0059c	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR _ptr_src$32[ebp]
  005a2	8b 11		 mov	 edx, DWORD PTR [ecx]
  005a4	89 10		 mov	 DWORD PTR [eax], edx

; 397  :             ptr_dst[3] = 0;

  005a6	b8 01 00 00 00	 mov	 eax, 1
  005ab	6b c8 03	 imul	 ecx, eax, 3
  005ae	8b 95 34 ff ff
	ff		 mov	 edx, DWORD PTR _ptr_dst$31[ebp]
  005b4	c6 04 0a 00	 mov	 BYTE PTR [edx+ecx], 0

; 398  :         }

  005b8	eb a1		 jmp	 SHORT $LN8@convert_rg
$LN9@convert_rg:

; 399  :     }

  005ba	e9 f2 fb ff ff	 jmp	 $LN2@convert_rg
$LN3@convert_rg:

; 400  :     _mm256_zeroupper();

  005bf	c5 f8 77	 vzeroupper

; 401  : }

  005c2	52		 push	 edx
  005c3	8b cd		 mov	 ecx, ebp
  005c5	50		 push	 eax
  005c6	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN15@convert_rg
  005cc	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  005d1	58		 pop	 eax
  005d2	5a		 pop	 edx
  005d3	5f		 pop	 edi
  005d4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005d7	33 cd		 xor	 ecx, ebp
  005d9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005de	8b e5		 mov	 esp, ebp
  005e0	5d		 pop	 ebp
  005e1	8b e3		 mov	 esp, ebx
  005e3	5b		 pop	 ebx
  005e4	c3		 ret	 0
  005e5	0f 1f 00	 npad	 3
$LN15@convert_rg:
  005e8	02 00 00 00	 DD	 2
  005ec	00 00 00 00	 DD	 $LN14@convert_rg
$LN14@convert_rg:
  005f0	dc ff ff ff	 DD	 -36			; ffffffdcH
  005f4	0c 00 00 00	 DD	 12			; 0000000cH
  005f8	00 00 00 00	 DD	 $LN12@convert_rg
  005fc	a0 ff ff ff	 DD	 -96			; ffffffa0H
  00600	20 00 00 00	 DD	 32			; 00000020H
  00604	00 00 00 00	 DD	 $LN13@convert_rg
$LN13@convert_rg:
  00608	4d		 DB	 77			; 0000004dH
  00609	41		 DB	 65			; 00000041H
  0060a	53		 DB	 83			; 00000053H
  0060b	4b		 DB	 75			; 0000004bH
  0060c	5f		 DB	 95			; 0000005fH
  0060d	52		 DB	 82			; 00000052H
  0060e	47		 DB	 71			; 00000047H
  0060f	42		 DB	 66			; 00000042H
  00610	33		 DB	 51			; 00000033H
  00611	5f		 DB	 95			; 0000005fH
  00612	54		 DB	 84			; 00000054H
  00613	4f		 DB	 79			; 0000004fH
  00614	5f		 DB	 95			; 0000005fH
  00615	52		 DB	 82			; 00000052H
  00616	47		 DB	 71			; 00000047H
  00617	42		 DB	 66			; 00000042H
  00618	34		 DB	 52			; 00000034H
  00619	00		 DB	 0
$LN12@convert_rg:
  0061a	79		 DB	 121			; 00000079H
  0061b	5f		 DB	 95			; 0000005fH
  0061c	72		 DB	 114			; 00000072H
  0061d	61		 DB	 97			; 00000061H
  0061e	6e		 DB	 110			; 0000006eH
  0061f	67		 DB	 103			; 00000067H
  00620	65		 DB	 101			; 00000065H
  00621	00		 DB	 0
?convert_rgb24r_to_rgb32_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_rgb24r_to_rgb32_avx2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
$T1 = -1104						; size = 12
$T2 = -1088						; size = 32
$T3 = -1056						; size = 32
$T4 = -1024						; size = 32
$T5 = -992						; size = 32
$T6 = -960						; size = 32
$T7 = -928						; size = 32
$T8 = -896						; size = 32
$T9 = -864						; size = 32
$T10 = -832						; size = 32
$T11 = -800						; size = 32
$T12 = -768						; size = 32
_y3$13 = -736						; size = 32
$T14 = -704						; size = 32
$T15 = -656						; size = 16
$T16 = -640						; size = 32
$T17 = -592						; size = 16
_y2$18 = -576						; size = 32
$T19 = -544						; size = 32
$T20 = -496						; size = 16
$T21 = -480						; size = 32
$T22 = -432						; size = 16
_y1$23 = -416						; size = 32
$T24 = -384						; size = 32
$T25 = -336						; size = 16
$T26 = -320						; size = 32
$T27 = -272						; size = 16
_y0$28 = -256						; size = 32
_x_fin$29 = -212					; size = 4
_x$30 = -208						; size = 4
_ptr_dst$31 = -204					; size = 4
_ptr_src$32 = -200					; size = 4
_y$33 = -196						; size = 4
$T34 = -192						; size = 32
_yMask$ = -160						; size = 32
_MASK_RGB3_TO_RGB4$ = -96				; size = 32
_dstLine$ = -60						; size = 4
_srcLine$ = -56						; size = 4
$T35 = -52						; size = 12
_y_range$ = -36						; size = 12
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_rgb24_to_rgb32_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_rgb24_to_rgb32_avx2

; 319  : void convert_rgb24_to_rgb32_avx2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 60 04 00
	00		 sub	 esp, 1120		; 00000460H
  0001c	57		 push	 edi
  0001d	8d bd a0 fb ff
	ff		 lea	 edi, DWORD PTR [ebp-1120]
  00023	b9 18 01 00 00	 mov	 ecx, 280		; 00000118H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 320  :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 321  :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 322  :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 323  :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 324  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  0007c	8b 53 2c	 mov	 edx, DWORD PTR _thread_n$[ebx]
  0007f	52		 push	 edx
  00080	8b 43 28	 mov	 eax, DWORD PTR _thread_id$[ebx]
  00083	50		 push	 eax
  00084	8b 4b 20	 mov	 ecx, DWORD PTR _height$[ebx]
  00087	2b 4d ec	 sub	 ecx, DWORD PTR _crop_bottom$[ebp]
  0008a	51		 push	 ecx
  0008b	8b 55 f4	 mov	 edx, DWORD PTR _crop_up$[ebp]
  0008e	52		 push	 edx
  0008f	8d 85 b0 fb ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  00095	50		 push	 eax
  00096	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  0009b	83 c4 14	 add	 esp, 20			; 00000014H
  0009e	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a0	89 4d cc	 mov	 DWORD PTR $T35[ebp], ecx
  000a3	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a6	89 55 d0	 mov	 DWORD PTR $T35[ebp+4], edx
  000a9	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000ac	89 45 d4	 mov	 DWORD PTR $T35[ebp+8], eax
  000af	8b 4d cc	 mov	 ecx, DWORD PTR $T35[ebp]
  000b2	89 4d dc	 mov	 DWORD PTR _y_range$[ebp], ecx
  000b5	8b 55 d0	 mov	 edx, DWORD PTR $T35[ebp+4]
  000b8	89 55 e0	 mov	 DWORD PTR _y_range$[ebp+4], edx
  000bb	8b 45 d4	 mov	 eax, DWORD PTR $T35[ebp+8]
  000be	89 45 e4	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 325  :     uint8_t *srcLine = (uint8_t *)src[0] + src_y_pitch_byte * y_range.start_src + crop_left * 3;

  000c1	b9 04 00 00 00	 mov	 ecx, 4
  000c6	6b d1 00	 imul	 edx, ecx, 0
  000c9	8b 43 14	 mov	 eax, DWORD PTR _src_y_pitch_byte$[ebx]
  000cc	0f af 45 dc	 imul	 eax, DWORD PTR _y_range$[ebp]
  000d0	8b 4b 0c	 mov	 ecx, DWORD PTR _src$[ebx]
  000d3	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  000d6	03 d0		 add	 edx, eax
  000d8	6b 45 f8 03	 imul	 eax, DWORD PTR _crop_left$[ebp], 3
  000dc	03 d0		 add	 edx, eax
  000de	89 55 c8	 mov	 DWORD PTR _srcLine$[ebp], edx

; 326  :     uint8_t *dstLine = (uint8_t *)dst[0] + dst_y_pitch_byte * y_range.start_dst;

  000e1	b9 04 00 00 00	 mov	 ecx, 4
  000e6	6b d1 00	 imul	 edx, ecx, 0
  000e9	8b 43 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  000ec	0f af 45 e0	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  000f0	8b 4b 08	 mov	 ecx, DWORD PTR _dst$[ebx]
  000f3	03 04 11	 add	 eax, DWORD PTR [ecx+edx]
  000f6	89 45 c4	 mov	 DWORD PTR _dstLine$[ebp], eax

; 327  :     alignas(32) const char MASK_RGB3_TO_RGB4[] ={
; 328  :         0, 1, 2, -1, 3, 4, 5, -1, 6, 7, 8, -1, 9, 10, 11, -1,

  000f9	c6 45 a0 00	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp], 0
  000fd	c6 45 a1 01	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+1], 1
  00101	c6 45 a2 02	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+2], 2
  00105	c6 45 a3 ff	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+3], -1
  00109	c6 45 a4 03	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+4], 3
  0010d	c6 45 a5 04	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+5], 4
  00111	c6 45 a6 05	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+6], 5
  00115	c6 45 a7 ff	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+7], -1
  00119	c6 45 a8 06	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+8], 6
  0011d	c6 45 a9 07	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+9], 7
  00121	c6 45 aa 08	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+10], 8
  00125	c6 45 ab ff	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+11], -1
  00129	c6 45 ac 09	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+12], 9
  0012d	c6 45 ad 0a	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+13], 10 ; 0000000aH
  00131	c6 45 ae 0b	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+14], 11 ; 0000000bH
  00135	c6 45 af ff	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+15], -1

; 329  :         0, 1, 2, -1, 3, 4, 5, -1, 6, 7, 8, -1, 9, 10, 11, -1

  00139	c6 45 b0 00	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+16], 0
  0013d	c6 45 b1 01	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+17], 1
  00141	c6 45 b2 02	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+18], 2
  00145	c6 45 b3 ff	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+19], -1
  00149	c6 45 b4 03	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+20], 3
  0014d	c6 45 b5 04	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+21], 4
  00151	c6 45 b6 05	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+22], 5
  00155	c6 45 b7 ff	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+23], -1
  00159	c6 45 b8 06	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+24], 6
  0015d	c6 45 b9 07	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+25], 7
  00161	c6 45 ba 08	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+26], 8
  00165	c6 45 bb ff	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+27], -1
  00169	c6 45 bc 09	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+28], 9
  0016d	c6 45 bd 0a	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+29], 10 ; 0000000aH
  00171	c6 45 be 0b	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+30], 11 ; 0000000bH
  00175	c6 45 bf ff	 mov	 BYTE PTR _MASK_RGB3_TO_RGB4$[ebp+31], -1

; 330  :     };
; 331  :     __m256i yMask = _mm256_load_si256((__m256i*)MASK_RGB3_TO_RGB4);

  00179	c5 fd 6f 45 a0	 vmovdqa ymm0, YMMWORD PTR _MASK_RGB3_TO_RGB4$[ebp]
  0017e	c5 fe 7f 85 40
	ff ff ff	 vmovdqu YMMWORD PTR $T34[ebp], ymm0
  00186	c5 fe 6f 85 40
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T34[ebp]
  0018e	c5 fe 7f 85 60
	ff ff ff	 vmovdqu YMMWORD PTR _yMask$[ebp], ymm0

; 332  :     for (int y = 0; y < y_range.len; y++, dstLine += dst_y_pitch_byte, srcLine += src_y_pitch_byte) {

  00196	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _y$33[ebp], 0
  001a0	eb 21		 jmp	 SHORT $LN4@convert_rg
$LN2@convert_rg:
  001a2	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR _y$33[ebp]
  001a8	83 c2 01	 add	 edx, 1
  001ab	89 95 3c ff ff
	ff		 mov	 DWORD PTR _y$33[ebp], edx
  001b1	8b 45 c4	 mov	 eax, DWORD PTR _dstLine$[ebp]
  001b4	03 43 1c	 add	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  001b7	89 45 c4	 mov	 DWORD PTR _dstLine$[ebp], eax
  001ba	8b 4d c8	 mov	 ecx, DWORD PTR _srcLine$[ebp]
  001bd	03 4b 14	 add	 ecx, DWORD PTR _src_y_pitch_byte$[ebx]
  001c0	89 4d c8	 mov	 DWORD PTR _srcLine$[ebp], ecx
$LN4@convert_rg:
  001c3	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR _y$33[ebp]
  001c9	3b 55 e4	 cmp	 edx, DWORD PTR _y_range$[ebp+8]
  001cc	0f 8d df 03 00
	00		 jge	 $LN3@convert_rg

; 333  :         uint8_t *ptr_src = srcLine;

  001d2	8b 45 c8	 mov	 eax, DWORD PTR _srcLine$[ebp]
  001d5	89 85 38 ff ff
	ff		 mov	 DWORD PTR _ptr_src$32[ebp], eax

; 334  :         uint8_t *ptr_dst = dstLine;

  001db	8b 4d c4	 mov	 ecx, DWORD PTR _dstLine$[ebp]
  001de	89 8d 34 ff ff
	ff		 mov	 DWORD PTR _ptr_dst$31[ebp], ecx

; 335  :         int x = 0, x_fin = width - crop_left - crop_right - 32;

  001e4	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _x$30[ebp], 0
  001ee	8b 53 10	 mov	 edx, DWORD PTR _width$[ebx]
  001f1	2b 55 f8	 sub	 edx, DWORD PTR _crop_left$[ebp]
  001f4	2b 55 f0	 sub	 edx, DWORD PTR _crop_right$[ebp]
  001f7	83 ea 20	 sub	 edx, 32			; 00000020H
  001fa	89 95 2c ff ff
	ff		 mov	 DWORD PTR _x_fin$29[ebp], edx

; 336  :         for (; x < x_fin; x += 32, ptr_dst += 128, ptr_src += 96) {

  00200	eb 30		 jmp	 SHORT $LN7@convert_rg
$LN5@convert_rg:
  00202	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR _x$30[ebp]
  00208	83 c0 20	 add	 eax, 32			; 00000020H
  0020b	89 85 30 ff ff
	ff		 mov	 DWORD PTR _x$30[ebp], eax
  00211	8b 8d 34 ff ff
	ff		 mov	 ecx, DWORD PTR _ptr_dst$31[ebp]
  00217	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0021d	89 8d 34 ff ff
	ff		 mov	 DWORD PTR _ptr_dst$31[ebp], ecx
  00223	8b 95 38 ff ff
	ff		 mov	 edx, DWORD PTR _ptr_src$32[ebp]
  00229	83 c2 60	 add	 edx, 96			; 00000060H
  0022c	89 95 38 ff ff
	ff		 mov	 DWORD PTR _ptr_src$32[ebp], edx
$LN7@convert_rg:
  00232	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR _x$30[ebp]
  00238	3b 85 2c ff ff
	ff		 cmp	 eax, DWORD PTR _x_fin$29[ebp]
  0023e	0f 8d f8 02 00
	00		 jge	 $LN6@convert_rg

; 337  :             __m256i y0 = _mm256_set_m128i(_mm_loadu_si128((__m128i*)(ptr_src+48)), _mm_loadu_si128((__m128i*)(ptr_src+ 0))); //384,   0

  00244	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR _ptr_src$32[ebp]
  0024a	83 c1 30	 add	 ecx, 48			; 00000030H
  0024d	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00250	0f 29 85 b0 fe
	ff ff		 movaps	 XMMWORD PTR $T25[ebp], xmm0
  00257	8b 95 38 ff ff
	ff		 mov	 edx, DWORD PTR _ptr_src$32[ebp]
  0025d	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  00260	0f 29 85 f0 fe
	ff ff		 movaps	 XMMWORD PTR $T27[ebp], xmm0
  00267	c5 fa 6f 85 f0
	fe ff ff	 vmovdqu xmm0, XMMWORD PTR $T27[ebp]
  0026f	c5 fe 7f 85 c0
	fe ff ff	 vmovdqu YMMWORD PTR $T26[ebp], ymm0
  00277	c5 fe 6f 85 c0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T26[ebp]
  0027f	c4 e3 7d 18 85
	b0 fe ff ff 01	 vinsertf128 ymm0, ymm0, XMMWORD PTR $T25[ebp], 1
  00289	c5 fe 7f 85 80
	fe ff ff	 vmovdqu YMMWORD PTR $T24[ebp], ymm0
  00291	c5 fe 6f 85 80
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T24[ebp]
  00299	c5 fe 7f 85 00
	ff ff ff	 vmovdqu YMMWORD PTR _y0$28[ebp], ymm0

; 338  :             __m256i y1 = _mm256_set_m128i(_mm_loadu_si128((__m128i*)(ptr_src+64)), _mm_loadu_si128((__m128i*)(ptr_src+16))); //512, 128

  002a1	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _ptr_src$32[ebp]
  002a7	83 c0 40	 add	 eax, 64			; 00000040H
  002aa	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  002ad	0f 29 85 10 fe
	ff ff		 movaps	 XMMWORD PTR $T20[ebp], xmm0
  002b4	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR _ptr_src$32[ebp]
  002ba	83 c1 10	 add	 ecx, 16			; 00000010H
  002bd	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  002c0	0f 29 85 50 fe
	ff ff		 movaps	 XMMWORD PTR $T22[ebp], xmm0
  002c7	c5 fa 6f 85 50
	fe ff ff	 vmovdqu xmm0, XMMWORD PTR $T22[ebp]
  002cf	c5 fe 7f 85 20
	fe ff ff	 vmovdqu YMMWORD PTR $T21[ebp], ymm0
  002d7	c5 fe 6f 85 20
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T21[ebp]
  002df	c4 e3 7d 18 85
	10 fe ff ff 01	 vinsertf128 ymm0, ymm0, XMMWORD PTR $T20[ebp], 1
  002e9	c5 fe 7f 85 e0
	fd ff ff	 vmovdqu YMMWORD PTR $T19[ebp], ymm0
  002f1	c5 fe 6f 85 e0
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T19[ebp]
  002f9	c5 fe 7f 85 60
	fe ff ff	 vmovdqu YMMWORD PTR _y1$23[ebp], ymm0

; 339  :             __m256i y2 = _mm256_set_m128i(_mm_loadu_si128((__m128i*)(ptr_src+80)), _mm_loadu_si128((__m128i*)(ptr_src+32))); //640, 256

  00301	8b 95 38 ff ff
	ff		 mov	 edx, DWORD PTR _ptr_src$32[ebp]
  00307	83 c2 50	 add	 edx, 80			; 00000050H
  0030a	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  0030d	0f 29 85 70 fd
	ff ff		 movaps	 XMMWORD PTR $T15[ebp], xmm0
  00314	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _ptr_src$32[ebp]
  0031a	83 c0 20	 add	 eax, 32			; 00000020H
  0031d	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00320	0f 29 85 b0 fd
	ff ff		 movaps	 XMMWORD PTR $T17[ebp], xmm0
  00327	c5 fa 6f 85 b0
	fd ff ff	 vmovdqu xmm0, XMMWORD PTR $T17[ebp]
  0032f	c5 fe 7f 85 80
	fd ff ff	 vmovdqu YMMWORD PTR $T16[ebp], ymm0
  00337	c5 fe 6f 85 80
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T16[ebp]
  0033f	c4 e3 7d 18 85
	70 fd ff ff 01	 vinsertf128 ymm0, ymm0, XMMWORD PTR $T15[ebp], 1
  00349	c5 fe 7f 85 40
	fd ff ff	 vmovdqu YMMWORD PTR $T14[ebp], ymm0
  00351	c5 fe 6f 85 40
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T14[ebp]
  00359	c5 fe 7f 85 c0
	fd ff ff	 vmovdqu YMMWORD PTR _y2$18[ebp], ymm0

; 340  :             __m256i y3 = _mm256_srli_si256(y2, 4);

  00361	c5 fe 6f 85 c0
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR _y2$18[ebp]
  00369	c5 fd 73 d8 04	 vpsrldq ymm0, ymm0, 4
  0036e	c5 fe 7f 85 00
	fd ff ff	 vmovdqu YMMWORD PTR $T12[ebp], ymm0
  00376	c5 fe 6f 85 00
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T12[ebp]
  0037e	c5 fe 7f 85 20
	fd ff ff	 vmovdqu YMMWORD PTR _y3$13[ebp], ymm0

; 341  :             y3 = _mm256_shuffle_epi8(y3, yMask); // 896, 384

  00386	c5 fe 6f 85 20
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR _y3$13[ebp]
  0038e	c4 e2 7d 00 85
	60 ff ff ff	 vpshufb ymm0, ymm0, YMMWORD PTR _yMask$[ebp]
  00397	c5 fe 7f 85 e0
	fc ff ff	 vmovdqu YMMWORD PTR $T11[ebp], ymm0
  0039f	c5 fe 6f 85 e0
	fc ff ff	 vmovdqu ymm0, YMMWORD PTR $T11[ebp]
  003a7	c5 fe 7f 85 20
	fd ff ff	 vmovdqu YMMWORD PTR _y3$13[ebp], ymm0

; 342  :             y2 = _mm256_alignr_epi8(y2, y1, 8);

  003af	c5 fe 6f 85 c0
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR _y2$18[ebp]
  003b7	c4 e3 7d 0f 85
	60 fe ff ff 08	 vpalignr ymm0, ymm0, YMMWORD PTR _y1$23[ebp], 8
  003c1	c5 fe 7f 85 c0
	fc ff ff	 vmovdqu YMMWORD PTR $T10[ebp], ymm0
  003c9	c5 fe 6f 85 c0
	fc ff ff	 vmovdqu ymm0, YMMWORD PTR $T10[ebp]
  003d1	c5 fe 7f 85 c0
	fd ff ff	 vmovdqu YMMWORD PTR _y2$18[ebp], ymm0

; 343  :             y2 = _mm256_shuffle_epi8(y2, yMask); // 768, 256

  003d9	c5 fe 6f 85 c0
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR _y2$18[ebp]
  003e1	c4 e2 7d 00 85
	60 ff ff ff	 vpshufb ymm0, ymm0, YMMWORD PTR _yMask$[ebp]
  003ea	c5 fe 7f 85 a0
	fc ff ff	 vmovdqu YMMWORD PTR $T9[ebp], ymm0
  003f2	c5 fe 6f 85 a0
	fc ff ff	 vmovdqu ymm0, YMMWORD PTR $T9[ebp]
  003fa	c5 fe 7f 85 c0
	fd ff ff	 vmovdqu YMMWORD PTR _y2$18[ebp], ymm0

; 344  :             y1 = _mm256_alignr_epi8(y1, y0, 12);

  00402	c5 fe 6f 85 60
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR _y1$23[ebp]
  0040a	c4 e3 7d 0f 85
	00 ff ff ff 0c	 vpalignr ymm0, ymm0, YMMWORD PTR _y0$28[ebp], 12 ; 0000000cH
  00414	c5 fe 7f 85 80
	fc ff ff	 vmovdqu YMMWORD PTR $T8[ebp], ymm0
  0041c	c5 fe 6f 85 80
	fc ff ff	 vmovdqu ymm0, YMMWORD PTR $T8[ebp]
  00424	c5 fe 7f 85 60
	fe ff ff	 vmovdqu YMMWORD PTR _y1$23[ebp], ymm0

; 345  :             y1 = _mm256_shuffle_epi8(y1, yMask); // 640, 128

  0042c	c5 fe 6f 85 60
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR _y1$23[ebp]
  00434	c4 e2 7d 00 85
	60 ff ff ff	 vpshufb ymm0, ymm0, YMMWORD PTR _yMask$[ebp]
  0043d	c5 fe 7f 85 60
	fc ff ff	 vmovdqu YMMWORD PTR $T7[ebp], ymm0
  00445	c5 fe 6f 85 60
	fc ff ff	 vmovdqu ymm0, YMMWORD PTR $T7[ebp]
  0044d	c5 fe 7f 85 60
	fe ff ff	 vmovdqu YMMWORD PTR _y1$23[ebp], ymm0

; 346  :             y0 = _mm256_shuffle_epi8(y0, yMask); // 512,   0

  00455	c5 fe 6f 85 00
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR _y0$28[ebp]
  0045d	c4 e2 7d 00 85
	60 ff ff ff	 vpshufb ymm0, ymm0, YMMWORD PTR _yMask$[ebp]
  00466	c5 fe 7f 85 40
	fc ff ff	 vmovdqu YMMWORD PTR $T6[ebp], ymm0
  0046e	c5 fe 6f 85 40
	fc ff ff	 vmovdqu ymm0, YMMWORD PTR $T6[ebp]
  00476	c5 fe 7f 85 00
	ff ff ff	 vmovdqu YMMWORD PTR _y0$28[ebp], ymm0

; 347  :             _mm256_storeu_si256((__m256i*)(ptr_dst +  0), _mm256_permute2x128_si256(y0, y1, (2<<4) | 0)); // 128,   0

  0047e	c5 fe 6f 85 00
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR _y0$28[ebp]
  00486	c4 e3 7d 46 85
	60 fe ff ff 20	 vperm2i128 ymm0, ymm0, YMMWORD PTR _y1$23[ebp], 32 ; 00000020H
  00490	c5 fe 7f 85 20
	fc ff ff	 vmovdqu YMMWORD PTR $T5[ebp], ymm0
  00498	c5 fe 6f 85 20
	fc ff ff	 vmovdqu ymm0, YMMWORD PTR $T5[ebp]
  004a0	8b 8d 34 ff ff
	ff		 mov	 ecx, DWORD PTR _ptr_dst$31[ebp]
  004a6	c5 fe 7f 01	 vmovdqu YMMWORD PTR [ecx], ymm0

; 348  :             _mm256_storeu_si256((__m256i*)(ptr_dst + 32), _mm256_permute2x128_si256(y2, y3, (2<<4) | 0)); // 384, 256

  004aa	c5 fe 6f 85 c0
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR _y2$18[ebp]
  004b2	c4 e3 7d 46 85
	20 fd ff ff 20	 vperm2i128 ymm0, ymm0, YMMWORD PTR _y3$13[ebp], 32 ; 00000020H
  004bc	c5 fe 7f 85 00
	fc ff ff	 vmovdqu YMMWORD PTR $T4[ebp], ymm0
  004c4	c5 fe 6f 85 00
	fc ff ff	 vmovdqu ymm0, YMMWORD PTR $T4[ebp]
  004cc	8b 95 34 ff ff
	ff		 mov	 edx, DWORD PTR _ptr_dst$31[ebp]
  004d2	83 c2 20	 add	 edx, 32			; 00000020H
  004d5	c5 fe 7f 02	 vmovdqu YMMWORD PTR [edx], ymm0

; 349  :             _mm256_storeu_si256((__m256i*)(ptr_dst + 64), _mm256_permute2x128_si256(y0, y1, (3<<4) | 1)); // 640, 512

  004d9	c5 fe 6f 85 00
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR _y0$28[ebp]
  004e1	c4 e3 7d 46 85
	60 fe ff ff 31	 vperm2i128 ymm0, ymm0, YMMWORD PTR _y1$23[ebp], 49 ; 00000031H
  004eb	c5 fe 7f 85 e0
	fb ff ff	 vmovdqu YMMWORD PTR $T3[ebp], ymm0
  004f3	c5 fe 6f 85 e0
	fb ff ff	 vmovdqu ymm0, YMMWORD PTR $T3[ebp]
  004fb	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR _ptr_dst$31[ebp]
  00501	83 c0 40	 add	 eax, 64			; 00000040H
  00504	c5 fe 7f 00	 vmovdqu YMMWORD PTR [eax], ymm0

; 350  :             _mm256_storeu_si256((__m256i*)(ptr_dst + 96), _mm256_permute2x128_si256(y2, y3, (3<<4) | 1)); // 896, 768

  00508	c5 fe 6f 85 c0
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR _y2$18[ebp]
  00510	c4 e3 7d 46 85
	20 fd ff ff 31	 vperm2i128 ymm0, ymm0, YMMWORD PTR _y3$13[ebp], 49 ; 00000031H
  0051a	c5 fe 7f 85 c0
	fb ff ff	 vmovdqu YMMWORD PTR $T2[ebp], ymm0
  00522	c5 fe 6f 85 c0
	fb ff ff	 vmovdqu ymm0, YMMWORD PTR $T2[ebp]
  0052a	8b 8d 34 ff ff
	ff		 mov	 ecx, DWORD PTR _ptr_dst$31[ebp]
  00530	83 c1 60	 add	 ecx, 96			; 00000060H
  00533	c5 fe 7f 01	 vmovdqu YMMWORD PTR [ecx], ymm0

; 351  :         }

  00537	e9 c6 fc ff ff	 jmp	 $LN5@convert_rg
$LN6@convert_rg:

; 352  :         x_fin = width - crop_left - crop_right;

  0053c	8b 53 10	 mov	 edx, DWORD PTR _width$[ebx]
  0053f	2b 55 f8	 sub	 edx, DWORD PTR _crop_left$[ebp]
  00542	2b 55 f0	 sub	 edx, DWORD PTR _crop_right$[ebp]
  00545	89 95 2c ff ff
	ff		 mov	 DWORD PTR _x_fin$29[ebp], edx

; 353  :         for (; x < x_fin; x++, ptr_dst += 4, ptr_src += 3) {

  0054b	eb 2d		 jmp	 SHORT $LN10@convert_rg
$LN8@convert_rg:
  0054d	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR _x$30[ebp]
  00553	83 c0 01	 add	 eax, 1
  00556	89 85 30 ff ff
	ff		 mov	 DWORD PTR _x$30[ebp], eax
  0055c	8b 8d 34 ff ff
	ff		 mov	 ecx, DWORD PTR _ptr_dst$31[ebp]
  00562	83 c1 04	 add	 ecx, 4
  00565	89 8d 34 ff ff
	ff		 mov	 DWORD PTR _ptr_dst$31[ebp], ecx
  0056b	8b 95 38 ff ff
	ff		 mov	 edx, DWORD PTR _ptr_src$32[ebp]
  00571	83 c2 03	 add	 edx, 3
  00574	89 95 38 ff ff
	ff		 mov	 DWORD PTR _ptr_src$32[ebp], edx
$LN10@convert_rg:
  0057a	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR _x$30[ebp]
  00580	3b 85 2c ff ff
	ff		 cmp	 eax, DWORD PTR _x_fin$29[ebp]
  00586	7d 24		 jge	 SHORT $LN9@convert_rg

; 354  :             *(int *)ptr_dst = *(int *)ptr_src;

  00588	8b 8d 34 ff ff
	ff		 mov	 ecx, DWORD PTR _ptr_dst$31[ebp]
  0058e	8b 95 38 ff ff
	ff		 mov	 edx, DWORD PTR _ptr_src$32[ebp]
  00594	8b 02		 mov	 eax, DWORD PTR [edx]
  00596	89 01		 mov	 DWORD PTR [ecx], eax

; 355  :             ptr_dst[3] = 0;

  00598	b9 01 00 00 00	 mov	 ecx, 1
  0059d	6b d1 03	 imul	 edx, ecx, 3
  005a0	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR _ptr_dst$31[ebp]
  005a6	c6 04 10 00	 mov	 BYTE PTR [eax+edx], 0

; 356  :         }

  005aa	eb a1		 jmp	 SHORT $LN8@convert_rg
$LN9@convert_rg:

; 357  :     }

  005ac	e9 f1 fb ff ff	 jmp	 $LN2@convert_rg
$LN3@convert_rg:

; 358  :     _mm256_zeroupper();

  005b1	c5 f8 77	 vzeroupper

; 359  : }

  005b4	52		 push	 edx
  005b5	8b cd		 mov	 ecx, ebp
  005b7	50		 push	 eax
  005b8	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN15@convert_rg
  005be	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  005c3	58		 pop	 eax
  005c4	5a		 pop	 edx
  005c5	5f		 pop	 edi
  005c6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005c9	33 cd		 xor	 ecx, ebp
  005cb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005d0	8b e5		 mov	 esp, ebp
  005d2	5d		 pop	 ebp
  005d3	8b e3		 mov	 esp, ebx
  005d5	5b		 pop	 ebx
  005d6	c3		 ret	 0
  005d7	90		 npad	 1
$LN15@convert_rg:
  005d8	02 00 00 00	 DD	 2
  005dc	00 00 00 00	 DD	 $LN14@convert_rg
$LN14@convert_rg:
  005e0	dc ff ff ff	 DD	 -36			; ffffffdcH
  005e4	0c 00 00 00	 DD	 12			; 0000000cH
  005e8	00 00 00 00	 DD	 $LN12@convert_rg
  005ec	a0 ff ff ff	 DD	 -96			; ffffffa0H
  005f0	20 00 00 00	 DD	 32			; 00000020H
  005f4	00 00 00 00	 DD	 $LN13@convert_rg
$LN13@convert_rg:
  005f8	4d		 DB	 77			; 0000004dH
  005f9	41		 DB	 65			; 00000041H
  005fa	53		 DB	 83			; 00000053H
  005fb	4b		 DB	 75			; 0000004bH
  005fc	5f		 DB	 95			; 0000005fH
  005fd	52		 DB	 82			; 00000052H
  005fe	47		 DB	 71			; 00000047H
  005ff	42		 DB	 66			; 00000042H
  00600	33		 DB	 51			; 00000033H
  00601	5f		 DB	 95			; 0000005fH
  00602	54		 DB	 84			; 00000054H
  00603	4f		 DB	 79			; 0000004fH
  00604	5f		 DB	 95			; 0000005fH
  00605	52		 DB	 82			; 00000052H
  00606	47		 DB	 71			; 00000047H
  00607	42		 DB	 66			; 00000042H
  00608	34		 DB	 52			; 00000034H
  00609	00		 DB	 0
$LN12@convert_rg:
  0060a	79		 DB	 121			; 00000079H
  0060b	5f		 DB	 95			; 0000005fH
  0060c	72		 DB	 114			; 00000072H
  0060d	61		 DB	 97			; 00000061H
  0060e	6e		 DB	 110			; 0000006eH
  0060f	67		 DB	 103			; 00000067H
  00610	65		 DB	 101			; 00000065H
  00611	00		 DB	 0
?convert_rgb24_to_rgb32_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_rgb24_to_rgb32_avx2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
$T1 = -512						; size = 12
$T2 = -496						; size = 12
$T3 = -480						; size = 32
$T4 = -448						; size = 32
$T5 = -416						; size = 32
$T6 = -384						; size = 32
$T7 = -352						; size = 32
$T8 = -320						; size = 32
_x$9 = -260						; size = 4
_y2$10 = -256						; size = 32
_y1$11 = -224						; size = 32
_y0$12 = -192						; size = 32
_dst_ptr$13 = -136					; size = 4
_src_v_ptr$14 = -132					; size = 4
_src_u_ptr$15 = -128					; size = 4
_x_fin$16 = -124					; size = 4
_y$17 = -120						; size = 4
_dstLine$ = -116					; size = 4
_srcVLine$ = -112					; size = 4
_srcULine$ = -108					; size = 4
$T18 = -104						; size = 12
_uv_range$ = -88					; size = 12
_y$19 = -72						; size = 4
_y_width$20 = -68					; size = 4
_y_fin$21 = -64						; size = 4
_dstLine$22 = -60					; size = 4
_srcYLine$23 = -56					; size = 4
$T24 = -52						; size = 12
_y_range$25 = -36					; size = 12
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yv12_to_nv12_avx2_base@$00@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_to_nv12_avx2_base<1>

; 261  : static void __forceinline convert_yv12_to_nv12_avx2_base(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 00 02 00
	00		 sub	 esp, 512		; 00000200H
  0001c	57		 push	 edi
  0001d	8d bd 00 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-512]
  00023	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 262  :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 263  :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 264  :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 265  :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 266  :     //Y
; 267  :     if (!uv_only) {

  0007c	33 d2		 xor	 edx, edx
  0007e	0f 84 d1 00 00
	00		 je	 $LN11@convert_yv

; 268  :         const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00084	8b 43 2c	 mov	 eax, DWORD PTR _thread_n$[ebx]
  00087	50		 push	 eax
  00088	8b 4b 28	 mov	 ecx, DWORD PTR _thread_id$[ebx]
  0008b	51		 push	 ecx
  0008c	8b 53 20	 mov	 edx, DWORD PTR _height$[ebx]
  0008f	2b 55 ec	 sub	 edx, DWORD PTR _crop_bottom$[ebp]
  00092	52		 push	 edx
  00093	8b 45 f4	 mov	 eax, DWORD PTR _crop_up$[ebp]
  00096	50		 push	 eax
  00097	8d 8d 10 fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  0009d	51		 push	 ecx
  0009e	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  000a3	83 c4 14	 add	 esp, 20			; 00000014H
  000a6	8b 10		 mov	 edx, DWORD PTR [eax]
  000a8	89 55 cc	 mov	 DWORD PTR $T24[ebp], edx
  000ab	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ae	89 4d d0	 mov	 DWORD PTR $T24[ebp+4], ecx
  000b1	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000b4	89 55 d4	 mov	 DWORD PTR $T24[ebp+8], edx
  000b7	8b 45 cc	 mov	 eax, DWORD PTR $T24[ebp]
  000ba	89 45 dc	 mov	 DWORD PTR _y_range$25[ebp], eax
  000bd	8b 4d d0	 mov	 ecx, DWORD PTR $T24[ebp+4]
  000c0	89 4d e0	 mov	 DWORD PTR _y_range$25[ebp+4], ecx
  000c3	8b 55 d4	 mov	 edx, DWORD PTR $T24[ebp+8]
  000c6	89 55 e4	 mov	 DWORD PTR _y_range$25[ebp+8], edx

; 269  :         uint8_t *srcYLine = (uint8_t *)src[0] + src_y_pitch_byte * y_range.start_src + crop_left;

  000c9	b8 04 00 00 00	 mov	 eax, 4
  000ce	6b c8 00	 imul	 ecx, eax, 0
  000d1	8b 53 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  000d4	0f af 55 dc	 imul	 edx, DWORD PTR _y_range$25[ebp]
  000d8	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  000db	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  000de	03 ca		 add	 ecx, edx
  000e0	03 4d f8	 add	 ecx, DWORD PTR _crop_left$[ebp]
  000e3	89 4d c8	 mov	 DWORD PTR _srcYLine$23[ebp], ecx

; 270  :         uint8_t *dstLine = (uint8_t *)dst[0] + dst_y_pitch_byte * y_range.start_dst;

  000e6	ba 04 00 00 00	 mov	 edx, 4
  000eb	6b c2 00	 imul	 eax, edx, 0
  000ee	8b 4b 1c	 mov	 ecx, DWORD PTR _dst_y_pitch_byte$[ebx]
  000f1	0f af 4d e0	 imul	 ecx, DWORD PTR _y_range$25[ebp+4]
  000f5	8b 53 08	 mov	 edx, DWORD PTR _dst$[ebx]
  000f8	03 0c 02	 add	 ecx, DWORD PTR [edx+eax]
  000fb	89 4d c4	 mov	 DWORD PTR _dstLine$22[ebp], ecx

; 271  :         const int y_fin = height - crop_bottom;

  000fe	8b 43 20	 mov	 eax, DWORD PTR _height$[ebx]
  00101	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  00104	89 45 c0	 mov	 DWORD PTR _y_fin$21[ebp], eax

; 272  :         const int y_width = width - crop_right - crop_left;

  00107	8b 4b 10	 mov	 ecx, DWORD PTR _width$[ebx]
  0010a	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  0010d	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  00110	89 4d bc	 mov	 DWORD PTR _y_width$20[ebp], ecx

; 273  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch_byte, dstLine += dst_y_pitch_byte) {

  00113	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _y$19[ebp], 0
  0011a	eb 1b		 jmp	 SHORT $LN4@convert_yv
$LN2@convert_yv:
  0011c	8b 55 b8	 mov	 edx, DWORD PTR _y$19[ebp]
  0011f	83 c2 01	 add	 edx, 1
  00122	89 55 b8	 mov	 DWORD PTR _y$19[ebp], edx
  00125	8b 45 c8	 mov	 eax, DWORD PTR _srcYLine$23[ebp]
  00128	03 43 14	 add	 eax, DWORD PTR _src_y_pitch_byte$[ebx]
  0012b	89 45 c8	 mov	 DWORD PTR _srcYLine$23[ebp], eax
  0012e	8b 4d c4	 mov	 ecx, DWORD PTR _dstLine$22[ebp]
  00131	03 4b 1c	 add	 ecx, DWORD PTR _dst_y_pitch_byte$[ebx]
  00134	89 4d c4	 mov	 DWORD PTR _dstLine$22[ebp], ecx
$LN4@convert_yv:
  00137	8b 55 b8	 mov	 edx, DWORD PTR _y$19[ebp]
  0013a	3b 55 e4	 cmp	 edx, DWORD PTR _y_range$25[ebp+8]
  0013d	7d 16		 jge	 SHORT $LN11@convert_yv

; 274  :             avx2_memcpy<false>(dstLine, srcYLine, y_width);

  0013f	8b 45 bc	 mov	 eax, DWORD PTR _y_width$20[ebp]
  00142	50		 push	 eax
  00143	8b 4d c8	 mov	 ecx, DWORD PTR _srcYLine$23[ebp]
  00146	51		 push	 ecx
  00147	8b 55 c4	 mov	 edx, DWORD PTR _dstLine$22[ebp]
  0014a	52		 push	 edx
  0014b	e8 00 00 00 00	 call	 ??$avx2_memcpy@$0A@@@YAXPAEPBEH@Z ; avx2_memcpy<0>
  00150	83 c4 0c	 add	 esp, 12			; 0000000cH

; 275  :         }

  00153	eb c7		 jmp	 SHORT $LN2@convert_yv
$LN11@convert_yv:

; 276  :     }
; 277  :     //UV
; 278  :     const auto uv_range = thread_y_range(crop_up >> 1, (height - crop_bottom) >> 1, thread_id, thread_n);

  00155	8b 43 2c	 mov	 eax, DWORD PTR _thread_n$[ebx]
  00158	50		 push	 eax
  00159	8b 4b 28	 mov	 ecx, DWORD PTR _thread_id$[ebx]
  0015c	51		 push	 ecx
  0015d	8b 53 20	 mov	 edx, DWORD PTR _height$[ebx]
  00160	2b 55 ec	 sub	 edx, DWORD PTR _crop_bottom$[ebp]
  00163	d1 fa		 sar	 edx, 1
  00165	52		 push	 edx
  00166	8b 45 f4	 mov	 eax, DWORD PTR _crop_up$[ebp]
  00169	d1 f8		 sar	 eax, 1
  0016b	50		 push	 eax
  0016c	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  00172	51		 push	 ecx
  00173	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  00178	83 c4 14	 add	 esp, 20			; 00000014H
  0017b	8b 10		 mov	 edx, DWORD PTR [eax]
  0017d	89 55 98	 mov	 DWORD PTR $T18[ebp], edx
  00180	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00183	89 4d 9c	 mov	 DWORD PTR $T18[ebp+4], ecx
  00186	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00189	89 55 a0	 mov	 DWORD PTR $T18[ebp+8], edx
  0018c	8b 45 98	 mov	 eax, DWORD PTR $T18[ebp]
  0018f	89 45 a8	 mov	 DWORD PTR _uv_range$[ebp], eax
  00192	8b 4d 9c	 mov	 ecx, DWORD PTR $T18[ebp+4]
  00195	89 4d ac	 mov	 DWORD PTR _uv_range$[ebp+4], ecx
  00198	8b 55 a0	 mov	 edx, DWORD PTR $T18[ebp+8]
  0019b	89 55 b0	 mov	 DWORD PTR _uv_range$[ebp+8], edx

; 279  :     uint8_t *srcULine = (uint8_t *)src[1] + ((src_uv_pitch_byte * uv_range.start_src) + (crop_left >> 1));

  0019e	b8 04 00 00 00	 mov	 eax, 4
  001a3	c1 e0 00	 shl	 eax, 0
  001a6	8b 4b 18	 mov	 ecx, DWORD PTR _src_uv_pitch_byte$[ebx]
  001a9	0f af 4d a8	 imul	 ecx, DWORD PTR _uv_range$[ebp]
  001ad	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  001b0	d1 fa		 sar	 edx, 1
  001b2	03 ca		 add	 ecx, edx
  001b4	8b 53 0c	 mov	 edx, DWORD PTR _src$[ebx]
  001b7	03 0c 02	 add	 ecx, DWORD PTR [edx+eax]
  001ba	89 4d 94	 mov	 DWORD PTR _srcULine$[ebp], ecx

; 280  :     uint8_t *srcVLine = (uint8_t *)src[2] + ((src_uv_pitch_byte * uv_range.start_src) + (crop_left >> 1));

  001bd	b8 04 00 00 00	 mov	 eax, 4
  001c2	d1 e0		 shl	 eax, 1
  001c4	8b 4b 18	 mov	 ecx, DWORD PTR _src_uv_pitch_byte$[ebx]
  001c7	0f af 4d a8	 imul	 ecx, DWORD PTR _uv_range$[ebp]
  001cb	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  001ce	d1 fa		 sar	 edx, 1
  001d0	03 ca		 add	 ecx, edx
  001d2	8b 53 0c	 mov	 edx, DWORD PTR _src$[ebx]
  001d5	03 0c 02	 add	 ecx, DWORD PTR [edx+eax]
  001d8	89 4d 90	 mov	 DWORD PTR _srcVLine$[ebp], ecx

; 281  :     uint8_t *dstLine = (uint8_t *)dst[1] + dst_y_pitch_byte * uv_range.start_dst;

  001db	b8 04 00 00 00	 mov	 eax, 4
  001e0	c1 e0 00	 shl	 eax, 0
  001e3	8b 4b 1c	 mov	 ecx, DWORD PTR _dst_y_pitch_byte$[ebx]
  001e6	0f af 4d ac	 imul	 ecx, DWORD PTR _uv_range$[ebp+4]
  001ea	8b 53 08	 mov	 edx, DWORD PTR _dst$[ebx]
  001ed	03 0c 02	 add	 ecx, DWORD PTR [edx+eax]
  001f0	89 4d 8c	 mov	 DWORD PTR _dstLine$[ebp], ecx

; 282  :     for (int y = 0; y < uv_range.len; y++, srcULine += src_uv_pitch_byte, srcVLine += src_uv_pitch_byte, dstLine += dst_y_pitch_byte) {

  001f3	c7 45 88 00 00
	00 00		 mov	 DWORD PTR _y$17[ebp], 0
  001fa	eb 24		 jmp	 SHORT $LN7@convert_yv
$LN5@convert_yv:
  001fc	8b 45 88	 mov	 eax, DWORD PTR _y$17[ebp]
  001ff	83 c0 01	 add	 eax, 1
  00202	89 45 88	 mov	 DWORD PTR _y$17[ebp], eax
  00205	8b 4d 94	 mov	 ecx, DWORD PTR _srcULine$[ebp]
  00208	03 4b 18	 add	 ecx, DWORD PTR _src_uv_pitch_byte$[ebx]
  0020b	89 4d 94	 mov	 DWORD PTR _srcULine$[ebp], ecx
  0020e	8b 55 90	 mov	 edx, DWORD PTR _srcVLine$[ebp]
  00211	03 53 18	 add	 edx, DWORD PTR _src_uv_pitch_byte$[ebx]
  00214	89 55 90	 mov	 DWORD PTR _srcVLine$[ebp], edx
  00217	8b 45 8c	 mov	 eax, DWORD PTR _dstLine$[ebp]
  0021a	03 43 1c	 add	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  0021d	89 45 8c	 mov	 DWORD PTR _dstLine$[ebp], eax
$LN7@convert_yv:
  00220	8b 4d 88	 mov	 ecx, DWORD PTR _y$17[ebp]
  00223	3b 4d b0	 cmp	 ecx, DWORD PTR _uv_range$[ebp+8]
  00226	0f 8d 77 01 00
	00		 jge	 $LN6@convert_yv

; 283  :         const int x_fin = width - crop_right;

  0022c	8b 53 10	 mov	 edx, DWORD PTR _width$[ebx]
  0022f	2b 55 f0	 sub	 edx, DWORD PTR _crop_right$[ebp]
  00232	89 55 84	 mov	 DWORD PTR _x_fin$16[ebp], edx

; 284  :         uint8_t *src_u_ptr = srcULine;

  00235	8b 45 94	 mov	 eax, DWORD PTR _srcULine$[ebp]
  00238	89 45 80	 mov	 DWORD PTR _src_u_ptr$15[ebp], eax

; 285  :         uint8_t *src_v_ptr = srcVLine;

  0023b	8b 4d 90	 mov	 ecx, DWORD PTR _srcVLine$[ebp]
  0023e	89 8d 7c ff ff
	ff		 mov	 DWORD PTR _src_v_ptr$14[ebp], ecx

; 286  :         uint8_t *dst_ptr = dstLine;

  00244	8b 55 8c	 mov	 edx, DWORD PTR _dstLine$[ebp]
  00247	89 95 78 ff ff
	ff		 mov	 DWORD PTR _dst_ptr$13[ebp], edx

; 287  :         __m256i y0, y1, y2;
; 288  :         for (int x = crop_left; x < x_fin; x += 64, src_u_ptr += 32, src_v_ptr += 32, dst_ptr += 64) {

  0024d	8b 45 f8	 mov	 eax, DWORD PTR _crop_left$[ebp]
  00250	89 85 fc fe ff
	ff		 mov	 DWORD PTR _x$9[ebp], eax
  00256	eb 36		 jmp	 SHORT $LN10@convert_yv
$LN8@convert_yv:
  00258	8b 8d fc fe ff
	ff		 mov	 ecx, DWORD PTR _x$9[ebp]
  0025e	83 c1 40	 add	 ecx, 64			; 00000040H
  00261	89 8d fc fe ff
	ff		 mov	 DWORD PTR _x$9[ebp], ecx
  00267	8b 55 80	 mov	 edx, DWORD PTR _src_u_ptr$15[ebp]
  0026a	83 c2 20	 add	 edx, 32			; 00000020H
  0026d	89 55 80	 mov	 DWORD PTR _src_u_ptr$15[ebp], edx
  00270	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _src_v_ptr$14[ebp]
  00276	83 c0 20	 add	 eax, 32			; 00000020H
  00279	89 85 7c ff ff
	ff		 mov	 DWORD PTR _src_v_ptr$14[ebp], eax
  0027f	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _dst_ptr$13[ebp]
  00285	83 c1 40	 add	 ecx, 64			; 00000040H
  00288	89 8d 78 ff ff
	ff		 mov	 DWORD PTR _dst_ptr$13[ebp], ecx
$LN10@convert_yv:
  0028e	8b 95 fc fe ff
	ff		 mov	 edx, DWORD PTR _x$9[ebp]
  00294	3b 55 84	 cmp	 edx, DWORD PTR _x_fin$16[ebp]
  00297	0f 8d 01 01 00
	00		 jge	 $LN9@convert_yv

; 289  :             y0 = _mm256_loadu_si256((const __m256i *)src_u_ptr);

  0029d	8b 45 80	 mov	 eax, DWORD PTR _src_u_ptr$15[ebp]
  002a0	c5 fe 6f 00	 vmovdqu ymm0, YMMWORD PTR [eax]
  002a4	c5 fe 7f 85 c0
	fe ff ff	 vmovdqu YMMWORD PTR $T8[ebp], ymm0
  002ac	c5 fe 6f 85 c0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T8[ebp]
  002b4	c5 fe 7f 85 40
	ff ff ff	 vmovdqu YMMWORD PTR _y0$12[ebp], ymm0

; 290  :             y1 = _mm256_loadu_si256((const __m256i *)src_v_ptr);

  002bc	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _src_v_ptr$14[ebp]
  002c2	c5 fe 6f 01	 vmovdqu ymm0, YMMWORD PTR [ecx]
  002c6	c5 fe 7f 85 a0
	fe ff ff	 vmovdqu YMMWORD PTR $T7[ebp], ymm0
  002ce	c5 fe 6f 85 a0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T7[ebp]
  002d6	c5 fe 7f 85 20
	ff ff ff	 vmovdqu YMMWORD PTR _y1$11[ebp], ymm0

; 291  : 
; 292  :             y0 = _mm256_permute4x64_epi64(y0, _MM_SHUFFLE(3,1,2,0));

  002de	c4 e3 fd 00 85
	40 ff ff ff d8	 vpermq	 ymm0, YMMWORD PTR _y0$12[ebp], 216 ; 000000d8H
  002e8	c5 fe 7f 85 80
	fe ff ff	 vmovdqu YMMWORD PTR $T6[ebp], ymm0
  002f0	c5 fe 6f 85 80
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T6[ebp]
  002f8	c5 fe 7f 85 40
	ff ff ff	 vmovdqu YMMWORD PTR _y0$12[ebp], ymm0

; 293  :             y1 = _mm256_permute4x64_epi64(y1, _MM_SHUFFLE(3,1,2,0));

  00300	c4 e3 fd 00 85
	20 ff ff ff d8	 vpermq	 ymm0, YMMWORD PTR _y1$11[ebp], 216 ; 000000d8H
  0030a	c5 fe 7f 85 60
	fe ff ff	 vmovdqu YMMWORD PTR $T5[ebp], ymm0
  00312	c5 fe 6f 85 60
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T5[ebp]
  0031a	c5 fe 7f 85 20
	ff ff ff	 vmovdqu YMMWORD PTR _y1$11[ebp], ymm0

; 294  : 
; 295  :             y2 = _mm256_unpackhi_epi8(y0, y1);

  00322	c5 fe 6f 85 40
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR _y0$12[ebp]
  0032a	c5 fd 68 85 20
	ff ff ff	 vpunpckhbw ymm0, ymm0, YMMWORD PTR _y1$11[ebp]
  00332	c5 fe 7f 85 40
	fe ff ff	 vmovdqu YMMWORD PTR $T4[ebp], ymm0
  0033a	c5 fe 6f 85 40
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T4[ebp]
  00342	c5 fe 7f 85 00
	ff ff ff	 vmovdqu YMMWORD PTR _y2$10[ebp], ymm0

; 296  :             y0 = _mm256_unpacklo_epi8(y0, y1);

  0034a	c5 fe 6f 85 40
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR _y0$12[ebp]
  00352	c5 fd 60 85 20
	ff ff ff	 vpunpcklbw ymm0, ymm0, YMMWORD PTR _y1$11[ebp]
  0035a	c5 fe 7f 85 20
	fe ff ff	 vmovdqu YMMWORD PTR $T3[ebp], ymm0
  00362	c5 fe 6f 85 20
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T3[ebp]
  0036a	c5 fe 7f 85 40
	ff ff ff	 vmovdqu YMMWORD PTR _y0$12[ebp], ymm0

; 297  : 
; 298  :             _mm256_storeu_si256((__m256i *)(dst_ptr +  0), y0);

  00372	c5 fe 6f 85 40
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR _y0$12[ebp]
  0037a	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _dst_ptr$13[ebp]
  00380	c5 fe 7f 02	 vmovdqu YMMWORD PTR [edx], ymm0

; 299  :             _mm256_storeu_si256((__m256i *)(dst_ptr + 32), y2);

  00384	c5 fe 6f 85 00
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR _y2$10[ebp]
  0038c	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _dst_ptr$13[ebp]
  00392	83 c0 20	 add	 eax, 32			; 00000020H
  00395	c5 fe 7f 00	 vmovdqu YMMWORD PTR [eax], ymm0

; 300  :         }

  00399	e9 ba fe ff ff	 jmp	 $LN8@convert_yv
$LN9@convert_yv:

; 301  :     }

  0039e	e9 59 fe ff ff	 jmp	 $LN5@convert_yv
$LN6@convert_yv:

; 302  :     _mm256_zeroupper();

  003a3	c5 f8 77	 vzeroupper

; 303  : }

  003a6	52		 push	 edx
  003a7	8b cd		 mov	 ecx, ebp
  003a9	50		 push	 eax
  003aa	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN16@convert_yv
  003b0	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  003b5	58		 pop	 eax
  003b6	5a		 pop	 edx
  003b7	5f		 pop	 edi
  003b8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003bb	33 cd		 xor	 ecx, ebp
  003bd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003c2	8b e5		 mov	 esp, ebp
  003c4	5d		 pop	 ebp
  003c5	8b e3		 mov	 esp, ebx
  003c7	5b		 pop	 ebx
  003c8	c3		 ret	 0
  003c9	0f 1f 00	 npad	 3
$LN16@convert_yv:
  003cc	02 00 00 00	 DD	 2
  003d0	00 00 00 00	 DD	 $LN15@convert_yv
$LN15@convert_yv:
  003d4	dc ff ff ff	 DD	 -36			; ffffffdcH
  003d8	0c 00 00 00	 DD	 12			; 0000000cH
  003dc	00 00 00 00	 DD	 $LN13@convert_yv
  003e0	a8 ff ff ff	 DD	 -88			; ffffffa8H
  003e4	0c 00 00 00	 DD	 12			; 0000000cH
  003e8	00 00 00 00	 DD	 $LN14@convert_yv
$LN14@convert_yv:
  003ec	75		 DB	 117			; 00000075H
  003ed	76		 DB	 118			; 00000076H
  003ee	5f		 DB	 95			; 0000005fH
  003ef	72		 DB	 114			; 00000072H
  003f0	61		 DB	 97			; 00000061H
  003f1	6e		 DB	 110			; 0000006eH
  003f2	67		 DB	 103			; 00000067H
  003f3	65		 DB	 101			; 00000065H
  003f4	00		 DB	 0
$LN13@convert_yv:
  003f5	79		 DB	 121			; 00000079H
  003f6	5f		 DB	 95			; 0000005fH
  003f7	72		 DB	 114			; 00000072H
  003f8	61		 DB	 97			; 00000061H
  003f9	6e		 DB	 110			; 0000006eH
  003fa	67		 DB	 103			; 00000067H
  003fb	65		 DB	 101			; 00000065H
  003fc	00		 DB	 0
??$convert_yv12_to_nv12_avx2_base@$00@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_to_nv12_avx2_base<1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_uv_yv12_to_nv12_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_uv_yv12_to_nv12_avx2

; 310  : void convert_uv_yv12_to_nv12_avx2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 311  :     convert_yv12_to_nv12_avx2_base<true>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yv12_to_nv12_avx2_base@$00@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_to_nv12_avx2_base<1>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 312  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_uv_yv12_to_nv12_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_uv_yv12_to_nv12_avx2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
$T1 = -512						; size = 12
$T2 = -496						; size = 12
$T3 = -480						; size = 32
$T4 = -448						; size = 32
$T5 = -416						; size = 32
$T6 = -384						; size = 32
$T7 = -352						; size = 32
$T8 = -320						; size = 32
_x$9 = -260						; size = 4
_y2$10 = -256						; size = 32
_y1$11 = -224						; size = 32
_y0$12 = -192						; size = 32
_dst_ptr$13 = -136					; size = 4
_src_v_ptr$14 = -132					; size = 4
_src_u_ptr$15 = -128					; size = 4
_x_fin$16 = -124					; size = 4
_y$17 = -120						; size = 4
_dstLine$ = -116					; size = 4
_srcVLine$ = -112					; size = 4
_srcULine$ = -108					; size = 4
$T18 = -104						; size = 12
_uv_range$ = -88					; size = 12
_y$19 = -72						; size = 4
_y_width$20 = -68					; size = 4
_y_fin$21 = -64						; size = 4
_dstLine$22 = -60					; size = 4
_srcYLine$23 = -56					; size = 4
$T24 = -52						; size = 12
_y_range$25 = -36					; size = 12
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$convert_yv12_to_nv12_avx2_base@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_to_nv12_avx2_base<0>

; 261  : static void __forceinline convert_yv12_to_nv12_avx2_base(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 00 02 00
	00		 sub	 esp, 512		; 00000200H
  0001c	57		 push	 edi
  0001d	8d bd 00 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-512]
  00023	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 262  :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 263  :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 264  :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 265  :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 266  :     //Y
; 267  :     if (!uv_only) {

  0007c	ba 01 00 00 00	 mov	 edx, 1
  00081	85 d2		 test	 edx, edx
  00083	0f 84 d1 00 00
	00		 je	 $LN11@convert_yv

; 268  :         const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  00089	8b 43 2c	 mov	 eax, DWORD PTR _thread_n$[ebx]
  0008c	50		 push	 eax
  0008d	8b 4b 28	 mov	 ecx, DWORD PTR _thread_id$[ebx]
  00090	51		 push	 ecx
  00091	8b 53 20	 mov	 edx, DWORD PTR _height$[ebx]
  00094	2b 55 ec	 sub	 edx, DWORD PTR _crop_bottom$[ebp]
  00097	52		 push	 edx
  00098	8b 45 f4	 mov	 eax, DWORD PTR _crop_up$[ebp]
  0009b	50		 push	 eax
  0009c	8d 8d 10 fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  000a2	51		 push	 ecx
  000a3	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  000a8	83 c4 14	 add	 esp, 20			; 00000014H
  000ab	8b 10		 mov	 edx, DWORD PTR [eax]
  000ad	89 55 cc	 mov	 DWORD PTR $T24[ebp], edx
  000b0	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000b3	89 4d d0	 mov	 DWORD PTR $T24[ebp+4], ecx
  000b6	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000b9	89 55 d4	 mov	 DWORD PTR $T24[ebp+8], edx
  000bc	8b 45 cc	 mov	 eax, DWORD PTR $T24[ebp]
  000bf	89 45 dc	 mov	 DWORD PTR _y_range$25[ebp], eax
  000c2	8b 4d d0	 mov	 ecx, DWORD PTR $T24[ebp+4]
  000c5	89 4d e0	 mov	 DWORD PTR _y_range$25[ebp+4], ecx
  000c8	8b 55 d4	 mov	 edx, DWORD PTR $T24[ebp+8]
  000cb	89 55 e4	 mov	 DWORD PTR _y_range$25[ebp+8], edx

; 269  :         uint8_t *srcYLine = (uint8_t *)src[0] + src_y_pitch_byte * y_range.start_src + crop_left;

  000ce	b8 04 00 00 00	 mov	 eax, 4
  000d3	6b c8 00	 imul	 ecx, eax, 0
  000d6	8b 53 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  000d9	0f af 55 dc	 imul	 edx, DWORD PTR _y_range$25[ebp]
  000dd	8b 43 0c	 mov	 eax, DWORD PTR _src$[ebx]
  000e0	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  000e3	03 ca		 add	 ecx, edx
  000e5	03 4d f8	 add	 ecx, DWORD PTR _crop_left$[ebp]
  000e8	89 4d c8	 mov	 DWORD PTR _srcYLine$23[ebp], ecx

; 270  :         uint8_t *dstLine = (uint8_t *)dst[0] + dst_y_pitch_byte * y_range.start_dst;

  000eb	ba 04 00 00 00	 mov	 edx, 4
  000f0	6b c2 00	 imul	 eax, edx, 0
  000f3	8b 4b 1c	 mov	 ecx, DWORD PTR _dst_y_pitch_byte$[ebx]
  000f6	0f af 4d e0	 imul	 ecx, DWORD PTR _y_range$25[ebp+4]
  000fa	8b 53 08	 mov	 edx, DWORD PTR _dst$[ebx]
  000fd	03 0c 02	 add	 ecx, DWORD PTR [edx+eax]
  00100	89 4d c4	 mov	 DWORD PTR _dstLine$22[ebp], ecx

; 271  :         const int y_fin = height - crop_bottom;

  00103	8b 43 20	 mov	 eax, DWORD PTR _height$[ebx]
  00106	2b 45 ec	 sub	 eax, DWORD PTR _crop_bottom$[ebp]
  00109	89 45 c0	 mov	 DWORD PTR _y_fin$21[ebp], eax

; 272  :         const int y_width = width - crop_right - crop_left;

  0010c	8b 4b 10	 mov	 ecx, DWORD PTR _width$[ebx]
  0010f	2b 4d f0	 sub	 ecx, DWORD PTR _crop_right$[ebp]
  00112	2b 4d f8	 sub	 ecx, DWORD PTR _crop_left$[ebp]
  00115	89 4d bc	 mov	 DWORD PTR _y_width$20[ebp], ecx

; 273  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch_byte, dstLine += dst_y_pitch_byte) {

  00118	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _y$19[ebp], 0
  0011f	eb 1b		 jmp	 SHORT $LN4@convert_yv
$LN2@convert_yv:
  00121	8b 55 b8	 mov	 edx, DWORD PTR _y$19[ebp]
  00124	83 c2 01	 add	 edx, 1
  00127	89 55 b8	 mov	 DWORD PTR _y$19[ebp], edx
  0012a	8b 45 c8	 mov	 eax, DWORD PTR _srcYLine$23[ebp]
  0012d	03 43 14	 add	 eax, DWORD PTR _src_y_pitch_byte$[ebx]
  00130	89 45 c8	 mov	 DWORD PTR _srcYLine$23[ebp], eax
  00133	8b 4d c4	 mov	 ecx, DWORD PTR _dstLine$22[ebp]
  00136	03 4b 1c	 add	 ecx, DWORD PTR _dst_y_pitch_byte$[ebx]
  00139	89 4d c4	 mov	 DWORD PTR _dstLine$22[ebp], ecx
$LN4@convert_yv:
  0013c	8b 55 b8	 mov	 edx, DWORD PTR _y$19[ebp]
  0013f	3b 55 e4	 cmp	 edx, DWORD PTR _y_range$25[ebp+8]
  00142	7d 16		 jge	 SHORT $LN11@convert_yv

; 274  :             avx2_memcpy<false>(dstLine, srcYLine, y_width);

  00144	8b 45 bc	 mov	 eax, DWORD PTR _y_width$20[ebp]
  00147	50		 push	 eax
  00148	8b 4d c8	 mov	 ecx, DWORD PTR _srcYLine$23[ebp]
  0014b	51		 push	 ecx
  0014c	8b 55 c4	 mov	 edx, DWORD PTR _dstLine$22[ebp]
  0014f	52		 push	 edx
  00150	e8 00 00 00 00	 call	 ??$avx2_memcpy@$0A@@@YAXPAEPBEH@Z ; avx2_memcpy<0>
  00155	83 c4 0c	 add	 esp, 12			; 0000000cH

; 275  :         }

  00158	eb c7		 jmp	 SHORT $LN2@convert_yv
$LN11@convert_yv:

; 276  :     }
; 277  :     //UV
; 278  :     const auto uv_range = thread_y_range(crop_up >> 1, (height - crop_bottom) >> 1, thread_id, thread_n);

  0015a	8b 43 2c	 mov	 eax, DWORD PTR _thread_n$[ebx]
  0015d	50		 push	 eax
  0015e	8b 4b 28	 mov	 ecx, DWORD PTR _thread_id$[ebx]
  00161	51		 push	 ecx
  00162	8b 53 20	 mov	 edx, DWORD PTR _height$[ebx]
  00165	2b 55 ec	 sub	 edx, DWORD PTR _crop_bottom$[ebp]
  00168	d1 fa		 sar	 edx, 1
  0016a	52		 push	 edx
  0016b	8b 45 f4	 mov	 eax, DWORD PTR _crop_up$[ebp]
  0016e	d1 f8		 sar	 eax, 1
  00170	50		 push	 eax
  00171	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  00177	51		 push	 ecx
  00178	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  0017d	83 c4 14	 add	 esp, 20			; 00000014H
  00180	8b 10		 mov	 edx, DWORD PTR [eax]
  00182	89 55 98	 mov	 DWORD PTR $T18[ebp], edx
  00185	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00188	89 4d 9c	 mov	 DWORD PTR $T18[ebp+4], ecx
  0018b	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0018e	89 55 a0	 mov	 DWORD PTR $T18[ebp+8], edx
  00191	8b 45 98	 mov	 eax, DWORD PTR $T18[ebp]
  00194	89 45 a8	 mov	 DWORD PTR _uv_range$[ebp], eax
  00197	8b 4d 9c	 mov	 ecx, DWORD PTR $T18[ebp+4]
  0019a	89 4d ac	 mov	 DWORD PTR _uv_range$[ebp+4], ecx
  0019d	8b 55 a0	 mov	 edx, DWORD PTR $T18[ebp+8]
  001a0	89 55 b0	 mov	 DWORD PTR _uv_range$[ebp+8], edx

; 279  :     uint8_t *srcULine = (uint8_t *)src[1] + ((src_uv_pitch_byte * uv_range.start_src) + (crop_left >> 1));

  001a3	b8 04 00 00 00	 mov	 eax, 4
  001a8	c1 e0 00	 shl	 eax, 0
  001ab	8b 4b 18	 mov	 ecx, DWORD PTR _src_uv_pitch_byte$[ebx]
  001ae	0f af 4d a8	 imul	 ecx, DWORD PTR _uv_range$[ebp]
  001b2	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  001b5	d1 fa		 sar	 edx, 1
  001b7	03 ca		 add	 ecx, edx
  001b9	8b 53 0c	 mov	 edx, DWORD PTR _src$[ebx]
  001bc	03 0c 02	 add	 ecx, DWORD PTR [edx+eax]
  001bf	89 4d 94	 mov	 DWORD PTR _srcULine$[ebp], ecx

; 280  :     uint8_t *srcVLine = (uint8_t *)src[2] + ((src_uv_pitch_byte * uv_range.start_src) + (crop_left >> 1));

  001c2	b8 04 00 00 00	 mov	 eax, 4
  001c7	d1 e0		 shl	 eax, 1
  001c9	8b 4b 18	 mov	 ecx, DWORD PTR _src_uv_pitch_byte$[ebx]
  001cc	0f af 4d a8	 imul	 ecx, DWORD PTR _uv_range$[ebp]
  001d0	8b 55 f8	 mov	 edx, DWORD PTR _crop_left$[ebp]
  001d3	d1 fa		 sar	 edx, 1
  001d5	03 ca		 add	 ecx, edx
  001d7	8b 53 0c	 mov	 edx, DWORD PTR _src$[ebx]
  001da	03 0c 02	 add	 ecx, DWORD PTR [edx+eax]
  001dd	89 4d 90	 mov	 DWORD PTR _srcVLine$[ebp], ecx

; 281  :     uint8_t *dstLine = (uint8_t *)dst[1] + dst_y_pitch_byte * uv_range.start_dst;

  001e0	b8 04 00 00 00	 mov	 eax, 4
  001e5	c1 e0 00	 shl	 eax, 0
  001e8	8b 4b 1c	 mov	 ecx, DWORD PTR _dst_y_pitch_byte$[ebx]
  001eb	0f af 4d ac	 imul	 ecx, DWORD PTR _uv_range$[ebp+4]
  001ef	8b 53 08	 mov	 edx, DWORD PTR _dst$[ebx]
  001f2	03 0c 02	 add	 ecx, DWORD PTR [edx+eax]
  001f5	89 4d 8c	 mov	 DWORD PTR _dstLine$[ebp], ecx

; 282  :     for (int y = 0; y < uv_range.len; y++, srcULine += src_uv_pitch_byte, srcVLine += src_uv_pitch_byte, dstLine += dst_y_pitch_byte) {

  001f8	c7 45 88 00 00
	00 00		 mov	 DWORD PTR _y$17[ebp], 0
  001ff	eb 24		 jmp	 SHORT $LN7@convert_yv
$LN5@convert_yv:
  00201	8b 45 88	 mov	 eax, DWORD PTR _y$17[ebp]
  00204	83 c0 01	 add	 eax, 1
  00207	89 45 88	 mov	 DWORD PTR _y$17[ebp], eax
  0020a	8b 4d 94	 mov	 ecx, DWORD PTR _srcULine$[ebp]
  0020d	03 4b 18	 add	 ecx, DWORD PTR _src_uv_pitch_byte$[ebx]
  00210	89 4d 94	 mov	 DWORD PTR _srcULine$[ebp], ecx
  00213	8b 55 90	 mov	 edx, DWORD PTR _srcVLine$[ebp]
  00216	03 53 18	 add	 edx, DWORD PTR _src_uv_pitch_byte$[ebx]
  00219	89 55 90	 mov	 DWORD PTR _srcVLine$[ebp], edx
  0021c	8b 45 8c	 mov	 eax, DWORD PTR _dstLine$[ebp]
  0021f	03 43 1c	 add	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  00222	89 45 8c	 mov	 DWORD PTR _dstLine$[ebp], eax
$LN7@convert_yv:
  00225	8b 4d 88	 mov	 ecx, DWORD PTR _y$17[ebp]
  00228	3b 4d b0	 cmp	 ecx, DWORD PTR _uv_range$[ebp+8]
  0022b	0f 8d 77 01 00
	00		 jge	 $LN6@convert_yv

; 283  :         const int x_fin = width - crop_right;

  00231	8b 53 10	 mov	 edx, DWORD PTR _width$[ebx]
  00234	2b 55 f0	 sub	 edx, DWORD PTR _crop_right$[ebp]
  00237	89 55 84	 mov	 DWORD PTR _x_fin$16[ebp], edx

; 284  :         uint8_t *src_u_ptr = srcULine;

  0023a	8b 45 94	 mov	 eax, DWORD PTR _srcULine$[ebp]
  0023d	89 45 80	 mov	 DWORD PTR _src_u_ptr$15[ebp], eax

; 285  :         uint8_t *src_v_ptr = srcVLine;

  00240	8b 4d 90	 mov	 ecx, DWORD PTR _srcVLine$[ebp]
  00243	89 8d 7c ff ff
	ff		 mov	 DWORD PTR _src_v_ptr$14[ebp], ecx

; 286  :         uint8_t *dst_ptr = dstLine;

  00249	8b 55 8c	 mov	 edx, DWORD PTR _dstLine$[ebp]
  0024c	89 95 78 ff ff
	ff		 mov	 DWORD PTR _dst_ptr$13[ebp], edx

; 287  :         __m256i y0, y1, y2;
; 288  :         for (int x = crop_left; x < x_fin; x += 64, src_u_ptr += 32, src_v_ptr += 32, dst_ptr += 64) {

  00252	8b 45 f8	 mov	 eax, DWORD PTR _crop_left$[ebp]
  00255	89 85 fc fe ff
	ff		 mov	 DWORD PTR _x$9[ebp], eax
  0025b	eb 36		 jmp	 SHORT $LN10@convert_yv
$LN8@convert_yv:
  0025d	8b 8d fc fe ff
	ff		 mov	 ecx, DWORD PTR _x$9[ebp]
  00263	83 c1 40	 add	 ecx, 64			; 00000040H
  00266	89 8d fc fe ff
	ff		 mov	 DWORD PTR _x$9[ebp], ecx
  0026c	8b 55 80	 mov	 edx, DWORD PTR _src_u_ptr$15[ebp]
  0026f	83 c2 20	 add	 edx, 32			; 00000020H
  00272	89 55 80	 mov	 DWORD PTR _src_u_ptr$15[ebp], edx
  00275	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _src_v_ptr$14[ebp]
  0027b	83 c0 20	 add	 eax, 32			; 00000020H
  0027e	89 85 7c ff ff
	ff		 mov	 DWORD PTR _src_v_ptr$14[ebp], eax
  00284	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _dst_ptr$13[ebp]
  0028a	83 c1 40	 add	 ecx, 64			; 00000040H
  0028d	89 8d 78 ff ff
	ff		 mov	 DWORD PTR _dst_ptr$13[ebp], ecx
$LN10@convert_yv:
  00293	8b 95 fc fe ff
	ff		 mov	 edx, DWORD PTR _x$9[ebp]
  00299	3b 55 84	 cmp	 edx, DWORD PTR _x_fin$16[ebp]
  0029c	0f 8d 01 01 00
	00		 jge	 $LN9@convert_yv

; 289  :             y0 = _mm256_loadu_si256((const __m256i *)src_u_ptr);

  002a2	8b 45 80	 mov	 eax, DWORD PTR _src_u_ptr$15[ebp]
  002a5	c5 fe 6f 00	 vmovdqu ymm0, YMMWORD PTR [eax]
  002a9	c5 fe 7f 85 c0
	fe ff ff	 vmovdqu YMMWORD PTR $T8[ebp], ymm0
  002b1	c5 fe 6f 85 c0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T8[ebp]
  002b9	c5 fe 7f 85 40
	ff ff ff	 vmovdqu YMMWORD PTR _y0$12[ebp], ymm0

; 290  :             y1 = _mm256_loadu_si256((const __m256i *)src_v_ptr);

  002c1	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _src_v_ptr$14[ebp]
  002c7	c5 fe 6f 01	 vmovdqu ymm0, YMMWORD PTR [ecx]
  002cb	c5 fe 7f 85 a0
	fe ff ff	 vmovdqu YMMWORD PTR $T7[ebp], ymm0
  002d3	c5 fe 6f 85 a0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T7[ebp]
  002db	c5 fe 7f 85 20
	ff ff ff	 vmovdqu YMMWORD PTR _y1$11[ebp], ymm0

; 291  : 
; 292  :             y0 = _mm256_permute4x64_epi64(y0, _MM_SHUFFLE(3,1,2,0));

  002e3	c4 e3 fd 00 85
	40 ff ff ff d8	 vpermq	 ymm0, YMMWORD PTR _y0$12[ebp], 216 ; 000000d8H
  002ed	c5 fe 7f 85 80
	fe ff ff	 vmovdqu YMMWORD PTR $T6[ebp], ymm0
  002f5	c5 fe 6f 85 80
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T6[ebp]
  002fd	c5 fe 7f 85 40
	ff ff ff	 vmovdqu YMMWORD PTR _y0$12[ebp], ymm0

; 293  :             y1 = _mm256_permute4x64_epi64(y1, _MM_SHUFFLE(3,1,2,0));

  00305	c4 e3 fd 00 85
	20 ff ff ff d8	 vpermq	 ymm0, YMMWORD PTR _y1$11[ebp], 216 ; 000000d8H
  0030f	c5 fe 7f 85 60
	fe ff ff	 vmovdqu YMMWORD PTR $T5[ebp], ymm0
  00317	c5 fe 6f 85 60
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T5[ebp]
  0031f	c5 fe 7f 85 20
	ff ff ff	 vmovdqu YMMWORD PTR _y1$11[ebp], ymm0

; 294  : 
; 295  :             y2 = _mm256_unpackhi_epi8(y0, y1);

  00327	c5 fe 6f 85 40
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR _y0$12[ebp]
  0032f	c5 fd 68 85 20
	ff ff ff	 vpunpckhbw ymm0, ymm0, YMMWORD PTR _y1$11[ebp]
  00337	c5 fe 7f 85 40
	fe ff ff	 vmovdqu YMMWORD PTR $T4[ebp], ymm0
  0033f	c5 fe 6f 85 40
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T4[ebp]
  00347	c5 fe 7f 85 00
	ff ff ff	 vmovdqu YMMWORD PTR _y2$10[ebp], ymm0

; 296  :             y0 = _mm256_unpacklo_epi8(y0, y1);

  0034f	c5 fe 6f 85 40
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR _y0$12[ebp]
  00357	c5 fd 60 85 20
	ff ff ff	 vpunpcklbw ymm0, ymm0, YMMWORD PTR _y1$11[ebp]
  0035f	c5 fe 7f 85 20
	fe ff ff	 vmovdqu YMMWORD PTR $T3[ebp], ymm0
  00367	c5 fe 6f 85 20
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T3[ebp]
  0036f	c5 fe 7f 85 40
	ff ff ff	 vmovdqu YMMWORD PTR _y0$12[ebp], ymm0

; 297  : 
; 298  :             _mm256_storeu_si256((__m256i *)(dst_ptr +  0), y0);

  00377	c5 fe 6f 85 40
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR _y0$12[ebp]
  0037f	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _dst_ptr$13[ebp]
  00385	c5 fe 7f 02	 vmovdqu YMMWORD PTR [edx], ymm0

; 299  :             _mm256_storeu_si256((__m256i *)(dst_ptr + 32), y2);

  00389	c5 fe 6f 85 00
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR _y2$10[ebp]
  00391	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _dst_ptr$13[ebp]
  00397	83 c0 20	 add	 eax, 32			; 00000020H
  0039a	c5 fe 7f 00	 vmovdqu YMMWORD PTR [eax], ymm0

; 300  :         }

  0039e	e9 ba fe ff ff	 jmp	 $LN8@convert_yv
$LN9@convert_yv:

; 301  :     }

  003a3	e9 59 fe ff ff	 jmp	 $LN5@convert_yv
$LN6@convert_yv:

; 302  :     _mm256_zeroupper();

  003a8	c5 f8 77	 vzeroupper

; 303  : }

  003ab	52		 push	 edx
  003ac	8b cd		 mov	 ecx, ebp
  003ae	50		 push	 eax
  003af	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN16@convert_yv
  003b5	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  003ba	58		 pop	 eax
  003bb	5a		 pop	 edx
  003bc	5f		 pop	 edi
  003bd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003c0	33 cd		 xor	 ecx, ebp
  003c2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003c7	8b e5		 mov	 esp, ebp
  003c9	5d		 pop	 ebp
  003ca	8b e3		 mov	 esp, ebx
  003cc	5b		 pop	 ebx
  003cd	c3		 ret	 0
  003ce	66 90		 npad	 2
$LN16@convert_yv:
  003d0	02 00 00 00	 DD	 2
  003d4	00 00 00 00	 DD	 $LN15@convert_yv
$LN15@convert_yv:
  003d8	dc ff ff ff	 DD	 -36			; ffffffdcH
  003dc	0c 00 00 00	 DD	 12			; 0000000cH
  003e0	00 00 00 00	 DD	 $LN13@convert_yv
  003e4	a8 ff ff ff	 DD	 -88			; ffffffa8H
  003e8	0c 00 00 00	 DD	 12			; 0000000cH
  003ec	00 00 00 00	 DD	 $LN14@convert_yv
$LN14@convert_yv:
  003f0	75		 DB	 117			; 00000075H
  003f1	76		 DB	 118			; 00000076H
  003f2	5f		 DB	 95			; 0000005fH
  003f3	72		 DB	 114			; 00000072H
  003f4	61		 DB	 97			; 00000061H
  003f5	6e		 DB	 110			; 0000006eH
  003f6	67		 DB	 103			; 00000067H
  003f7	65		 DB	 101			; 00000065H
  003f8	00		 DB	 0
$LN13@convert_yv:
  003f9	79		 DB	 121			; 00000079H
  003fa	5f		 DB	 95			; 0000005fH
  003fb	72		 DB	 114			; 00000072H
  003fc	61		 DB	 97			; 00000061H
  003fd	6e		 DB	 110			; 0000006eH
  003fe	67		 DB	 103			; 00000067H
  003ff	65		 DB	 101			; 00000065H
  00400	00		 DB	 0
??$convert_yv12_to_nv12_avx2_base@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_to_nv12_avx2_base<0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yv12_to_nv12_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yv12_to_nv12_avx2

; 306  : void convert_yv12_to_nv12_avx2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 307  :     convert_yv12_to_nv12_avx2_base<false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$convert_yv12_to_nv12_avx2_base@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; convert_yv12_to_nv12_avx2_base<0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 308  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?convert_yv12_to_nv12_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yv12_to_nv12_avx2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
$T1 = -816						; size = 12
$T2 = -800						; size = 32
$T3 = -768						; size = 32
$T4 = -720						; size = 16
$T5 = -704						; size = 32
$T6 = -656						; size = 16
$T7 = -640						; size = 32
$T8 = -592						; size = 16
$T9 = -576						; size = 32
$T10 = -528						; size = 16
$T11 = -512						; size = 32
$T12 = -464						; size = 16
$T13 = -448						; size = 32
$T14 = -400						; size = 16
$T15 = -384						; size = 32
$T16 = -336						; size = 16
$T17 = -320						; size = 32
$T18 = -288						; size = 16
_x$19 = -264						; size = 4
_x_fin$20 = -260					; size = 4
_y3$21 = -256						; size = 32
_y1$22 = -192						; size = 32
_y0$23 = -128						; size = 32
_pw$24 = -84						; size = 4
_p$25 = -80						; size = 4
_i$26 = -76						; size = 4
_y$27 = -72						; size = 4
_dstCLine$ = -68					; size = 4
_dstYLine$ = -64					; size = 4
_srcLine$ = -60						; size = 4
$T28 = -56						; size = 12
_y_range$ = -40						; size = 12
_src$ = -24						; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst_array$ = 8						; size = 4
_src_array$ = 12					; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuy2_to_nv12_i_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuy2_to_nv12_i_avx2

; 209  : void convert_yuy2_to_nv12_i_avx2(void **dst_array, const void **src_array, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 40 03 00
	00		 sub	 esp, 832		; 00000340H
  0001c	57		 push	 edi
  0001d	8d bd c0 fc ff
	ff		 lea	 edi, DWORD PTR [ebp-832]
  00023	b9 d0 00 00 00	 mov	 ecx, 208		; 000000d0H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 210  :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 211  :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 212  :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 213  :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 214  :     const void *src = src_array[0];

  0007c	ba 04 00 00 00	 mov	 edx, 4
  00081	6b c2 00	 imul	 eax, edx, 0
  00084	8b 4b 0c	 mov	 ecx, DWORD PTR _src_array$[ebx]
  00087	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  0008a	89 55 e8	 mov	 DWORD PTR _src$[ebp], edx

; 215  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  0008d	8b 43 2c	 mov	 eax, DWORD PTR _thread_n$[ebx]
  00090	50		 push	 eax
  00091	8b 4b 28	 mov	 ecx, DWORD PTR _thread_id$[ebx]
  00094	51		 push	 ecx
  00095	8b 53 20	 mov	 edx, DWORD PTR _height$[ebx]
  00098	2b 55 ec	 sub	 edx, DWORD PTR _crop_bottom$[ebp]
  0009b	52		 push	 edx
  0009c	8b 45 f4	 mov	 eax, DWORD PTR _crop_up$[ebp]
  0009f	50		 push	 eax
  000a0	8d 8d d0 fc ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  000a6	51		 push	 ecx
  000a7	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  000ac	83 c4 14	 add	 esp, 20			; 00000014H
  000af	8b 10		 mov	 edx, DWORD PTR [eax]
  000b1	89 55 c8	 mov	 DWORD PTR $T28[ebp], edx
  000b4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000b7	89 4d cc	 mov	 DWORD PTR $T28[ebp+4], ecx
  000ba	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000bd	89 55 d0	 mov	 DWORD PTR $T28[ebp+8], edx
  000c0	8b 45 c8	 mov	 eax, DWORD PTR $T28[ebp]
  000c3	89 45 d8	 mov	 DWORD PTR _y_range$[ebp], eax
  000c6	8b 4d cc	 mov	 ecx, DWORD PTR $T28[ebp+4]
  000c9	89 4d dc	 mov	 DWORD PTR _y_range$[ebp+4], ecx
  000cc	8b 55 d0	 mov	 edx, DWORD PTR $T28[ebp+8]
  000cf	89 55 e0	 mov	 DWORD PTR _y_range$[ebp+8], edx

; 216  :     uint8_t *srcLine = (uint8_t *)src + src_y_pitch_byte * y_range.start_src + crop_left;

  000d2	8b 43 14	 mov	 eax, DWORD PTR _src_y_pitch_byte$[ebx]
  000d5	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp]
  000d9	03 45 e8	 add	 eax, DWORD PTR _src$[ebp]
  000dc	03 45 f8	 add	 eax, DWORD PTR _crop_left$[ebp]
  000df	89 45 c4	 mov	 DWORD PTR _srcLine$[ebp], eax

; 217  :     uint8_t *dstYLine = (uint8_t *)dst_array[0] + src_y_pitch_byte * y_range.start_dst;

  000e2	b9 04 00 00 00	 mov	 ecx, 4
  000e7	6b d1 00	 imul	 edx, ecx, 0
  000ea	8b 43 14	 mov	 eax, DWORD PTR _src_y_pitch_byte$[ebx]
  000ed	0f af 45 dc	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  000f1	8b 4b 08	 mov	 ecx, DWORD PTR _dst_array$[ebx]
  000f4	03 04 11	 add	 eax, DWORD PTR [ecx+edx]
  000f7	89 45 c0	 mov	 DWORD PTR _dstYLine$[ebp], eax

; 218  :     uint8_t *dstCLine = (uint8_t *)dst_array[1] + dst_y_pitch_byte * (y_range.start_dst >> 1);

  000fa	ba 04 00 00 00	 mov	 edx, 4
  000ff	c1 e2 00	 shl	 edx, 0
  00102	8b 45 dc	 mov	 eax, DWORD PTR _y_range$[ebp+4]
  00105	d1 f8		 sar	 eax, 1
  00107	0f af 43 1c	 imul	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  0010b	8b 4b 08	 mov	 ecx, DWORD PTR _dst_array$[ebx]
  0010e	03 04 11	 add	 eax, DWORD PTR [ecx+edx]
  00111	89 45 bc	 mov	 DWORD PTR _dstCLine$[ebp], eax

; 219  :     for (int y = 0; y < y_range.len; y += 4) {

  00114	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _y$27[ebp], 0
  0011b	eb 09		 jmp	 SHORT $LN4@convert_yu
$LN2@convert_yu:
  0011d	8b 55 b8	 mov	 edx, DWORD PTR _y$27[ebp]
  00120	83 c2 04	 add	 edx, 4
  00123	89 55 b8	 mov	 DWORD PTR _y$27[ebp], edx
$LN4@convert_yu:
  00126	8b 45 b8	 mov	 eax, DWORD PTR _y$27[ebp]
  00129	3b 45 e0	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  0012c	0f 8d bd 02 00
	00		 jge	 $LN3@convert_yu

; 220  :         for (int i = 0; i < 2; i++) {

  00132	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _i$26[ebp], 0
  00139	eb 09		 jmp	 SHORT $LN7@convert_yu
$LN5@convert_yu:
  0013b	8b 4d b4	 mov	 ecx, DWORD PTR _i$26[ebp]
  0013e	83 c1 01	 add	 ecx, 1
  00141	89 4d b4	 mov	 DWORD PTR _i$26[ebp], ecx
$LN7@convert_yu:
  00144	83 7d b4 02	 cmp	 DWORD PTR _i$26[ebp], 2
  00148	0f 8d 84 02 00
	00		 jge	 $LN6@convert_yu

; 221  :             uint8_t *p = srcLine;

  0014e	8b 55 c4	 mov	 edx, DWORD PTR _srcLine$[ebp]
  00151	89 55 b0	 mov	 DWORD PTR _p$25[ebp], edx

; 222  :             uint8_t *pw = p + (src_y_pitch_byte<<1);

  00154	8b 43 14	 mov	 eax, DWORD PTR _src_y_pitch_byte$[ebx]
  00157	8b 4d b0	 mov	 ecx, DWORD PTR _p$25[ebp]
  0015a	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  0015d	89 55 ac	 mov	 DWORD PTR _pw$24[ebp], edx

; 223  :             __m256i y0, y1, y3;
; 224  :             const int x_fin = width - crop_right - crop_left;

  00160	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  00163	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  00166	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  00169	89 85 fc fe ff
	ff		 mov	 DWORD PTR _x_fin$20[ebp], eax

; 225  :             for (int x = 0; x < x_fin; x += 32, p += 64, pw += 64) {

  0016f	c7 85 f8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _x$19[ebp], 0
  00179	eb 21		 jmp	 SHORT $LN10@convert_yu
$LN8@convert_yu:
  0017b	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR _x$19[ebp]
  00181	83 c1 20	 add	 ecx, 32			; 00000020H
  00184	89 8d f8 fe ff
	ff		 mov	 DWORD PTR _x$19[ebp], ecx
  0018a	8b 55 b0	 mov	 edx, DWORD PTR _p$25[ebp]
  0018d	83 c2 40	 add	 edx, 64			; 00000040H
  00190	89 55 b0	 mov	 DWORD PTR _p$25[ebp], edx
  00193	8b 45 ac	 mov	 eax, DWORD PTR _pw$24[ebp]
  00196	83 c0 40	 add	 eax, 64			; 00000040H
  00199	89 45 ac	 mov	 DWORD PTR _pw$24[ebp], eax
$LN10@convert_yu:
  0019c	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR _x$19[ebp]
  001a2	3b 8d fc fe ff
	ff		 cmp	 ecx, DWORD PTR _x_fin$20[ebp]
  001a8	0f 8d 04 02 00
	00		 jge	 $LN9@convert_yu

; 226  :                 //-----------    1+i   ---------------
; 227  :                 y0 = _mm256_set_m128i(_mm_loadu_si128((__m128i*)(p+32)), _mm_loadu_si128((__m128i*)(p+ 0)));

  001ae	8b 55 b0	 mov	 edx, DWORD PTR _p$25[ebp]
  001b1	83 c2 20	 add	 edx, 32			; 00000020H
  001b4	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  001b7	0f 29 85 b0 fe
	ff ff		 movaps	 XMMWORD PTR $T16[ebp], xmm0
  001be	8b 45 b0	 mov	 eax, DWORD PTR _p$25[ebp]
  001c1	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  001c4	0f 29 85 e0 fe
	ff ff		 movaps	 XMMWORD PTR $T18[ebp], xmm0
  001cb	c5 fa 6f 85 e0
	fe ff ff	 vmovdqu xmm0, XMMWORD PTR $T18[ebp]
  001d3	c5 fe 7f 85 c0
	fe ff ff	 vmovdqu YMMWORD PTR $T17[ebp], ymm0
  001db	c5 fe 6f 85 c0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T17[ebp]
  001e3	c4 e3 7d 18 85
	b0 fe ff ff 01	 vinsertf128 ymm0, ymm0, XMMWORD PTR $T16[ebp], 1
  001ed	c5 fe 7f 85 80
	fe ff ff	 vmovdqu YMMWORD PTR $T15[ebp], ymm0
  001f5	c5 fe 6f 85 80
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T15[ebp]
  001fd	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _y0$23[ebp], ymm0

; 228  :                 y1 = _mm256_set_m128i(_mm_loadu_si128((__m128i*)(p+48)), _mm_loadu_si128((__m128i*)(p+16)));

  00202	8b 4d b0	 mov	 ecx, DWORD PTR _p$25[ebp]
  00205	83 c1 30	 add	 ecx, 48			; 00000030H
  00208	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  0020b	0f 29 85 30 fe
	ff ff		 movaps	 XMMWORD PTR $T12[ebp], xmm0
  00212	8b 55 b0	 mov	 edx, DWORD PTR _p$25[ebp]
  00215	83 c2 10	 add	 edx, 16			; 00000010H
  00218	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  0021b	0f 29 85 70 fe
	ff ff		 movaps	 XMMWORD PTR $T14[ebp], xmm0
  00222	c5 fa 6f 85 70
	fe ff ff	 vmovdqu xmm0, XMMWORD PTR $T14[ebp]
  0022a	c5 fe 7f 85 40
	fe ff ff	 vmovdqu YMMWORD PTR $T13[ebp], ymm0
  00232	c5 fe 6f 85 40
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T13[ebp]
  0023a	c4 e3 7d 18 85
	30 fe ff ff 01	 vinsertf128 ymm0, ymm0, XMMWORD PTR $T12[ebp], 1
  00244	c5 fe 7f 85 00
	fe ff ff	 vmovdqu YMMWORD PTR $T11[ebp], ymm0
  0024c	c5 fe 6f 85 00
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T11[ebp]
  00254	c5 fe 7f 85 40
	ff ff ff	 vmovdqu YMMWORD PTR _y1$22[ebp], ymm0

; 229  : 
; 230  :                 separate_low_up(y0, y1);

  0025c	8d 85 40 ff ff
	ff		 lea	 eax, DWORD PTR _y1$22[ebp]
  00262	50		 push	 eax
  00263	8d 4d 80	 lea	 ecx, DWORD PTR _y0$23[ebp]
  00266	51		 push	 ecx
  00267	e8 00 00 00 00	 call	 ?separate_low_up@@YAXAAT__m256i@@0@Z ; separate_low_up
  0026c	83 c4 08	 add	 esp, 8

; 231  :                 y3 = y1;

  0026f	c5 fe 6f 85 40
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR _y1$22[ebp]
  00277	c5 fe 7f 85 00
	ff ff ff	 vmovdqu YMMWORD PTR _y3$21[ebp], ymm0

; 232  : 
; 233  :                 _mm256_storeu_si256((__m256i *)(dstYLine + x), y0);

  0027f	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR _y0$23[ebp]
  00284	8b 55 c0	 mov	 edx, DWORD PTR _dstYLine$[ebp]
  00287	03 95 f8 fe ff
	ff		 add	 edx, DWORD PTR _x$19[ebp]
  0028d	c5 fe 7f 02	 vmovdqu YMMWORD PTR [edx], ymm0

; 234  :                 //-----------1+i---------------
; 235  : 
; 236  :                 //-----------3+i---------------
; 237  :                 y0 = _mm256_set_m128i(_mm_loadu_si128((__m128i*)(pw+32)), _mm_loadu_si128((__m128i*)(pw+ 0)));

  00291	8b 45 ac	 mov	 eax, DWORD PTR _pw$24[ebp]
  00294	83 c0 20	 add	 eax, 32			; 00000020H
  00297	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  0029a	0f 29 85 b0 fd
	ff ff		 movaps	 XMMWORD PTR $T8[ebp], xmm0
  002a1	8b 4d ac	 mov	 ecx, DWORD PTR _pw$24[ebp]
  002a4	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  002a7	0f 29 85 f0 fd
	ff ff		 movaps	 XMMWORD PTR $T10[ebp], xmm0
  002ae	c5 fa 6f 85 f0
	fd ff ff	 vmovdqu xmm0, XMMWORD PTR $T10[ebp]
  002b6	c5 fe 7f 85 c0
	fd ff ff	 vmovdqu YMMWORD PTR $T9[ebp], ymm0
  002be	c5 fe 6f 85 c0
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T9[ebp]
  002c6	c4 e3 7d 18 85
	b0 fd ff ff 01	 vinsertf128 ymm0, ymm0, XMMWORD PTR $T8[ebp], 1
  002d0	c5 fe 7f 85 80
	fd ff ff	 vmovdqu YMMWORD PTR $T7[ebp], ymm0
  002d8	c5 fe 6f 85 80
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T7[ebp]
  002e0	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _y0$23[ebp], ymm0

; 238  :                 y1 = _mm256_set_m128i(_mm_loadu_si128((__m128i*)(pw+48)), _mm_loadu_si128((__m128i*)(pw+16)));

  002e5	8b 55 ac	 mov	 edx, DWORD PTR _pw$24[ebp]
  002e8	83 c2 30	 add	 edx, 48			; 00000030H
  002eb	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  002ee	0f 29 85 30 fd
	ff ff		 movaps	 XMMWORD PTR $T4[ebp], xmm0
  002f5	8b 45 ac	 mov	 eax, DWORD PTR _pw$24[ebp]
  002f8	83 c0 10	 add	 eax, 16			; 00000010H
  002fb	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  002fe	0f 29 85 70 fd
	ff ff		 movaps	 XMMWORD PTR $T6[ebp], xmm0
  00305	c5 fa 6f 85 70
	fd ff ff	 vmovdqu xmm0, XMMWORD PTR $T6[ebp]
  0030d	c5 fe 7f 85 40
	fd ff ff	 vmovdqu YMMWORD PTR $T5[ebp], ymm0
  00315	c5 fe 6f 85 40
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T5[ebp]
  0031d	c4 e3 7d 18 85
	30 fd ff ff 01	 vinsertf128 ymm0, ymm0, XMMWORD PTR $T4[ebp], 1
  00327	c5 fe 7f 85 00
	fd ff ff	 vmovdqu YMMWORD PTR $T3[ebp], ymm0
  0032f	c5 fe 6f 85 00
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T3[ebp]
  00337	c5 fe 7f 85 40
	ff ff ff	 vmovdqu YMMWORD PTR _y1$22[ebp], ymm0

; 239  : 
; 240  :                 separate_low_up(y0, y1);

  0033f	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR _y1$22[ebp]
  00345	51		 push	 ecx
  00346	8d 55 80	 lea	 edx, DWORD PTR _y0$23[ebp]
  00349	52		 push	 edx
  0034a	e8 00 00 00 00	 call	 ?separate_low_up@@YAXAAT__m256i@@0@Z ; separate_low_up
  0034f	83 c4 08	 add	 esp, 8

; 241  : 
; 242  :                 _mm256_storeu_si256((__m256i *)(dstYLine + (dst_y_pitch_byte<<1) + x), y0);

  00352	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR _y0$23[ebp]
  00357	8b 43 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  0035a	8b 4d c0	 mov	 ecx, DWORD PTR _dstYLine$[ebp]
  0035d	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00360	03 95 f8 fe ff
	ff		 add	 edx, DWORD PTR _x$19[ebp]
  00366	c5 fe 7f 02	 vmovdqu YMMWORD PTR [edx], ymm0

; 243  :                 //-----------3+i---------------
; 244  :                 y0 = yuv422_to_420_i_interpolate(y3, y1, i);

  0036a	8b 45 b4	 mov	 eax, DWORD PTR _i$26[ebp]
  0036d	50		 push	 eax
  0036e	c5 fe 6f 8d 40
	ff ff ff	 vmovdqu ymm1, YMMWORD PTR _y1$22[ebp]
  00376	c5 fe 6f 85 00
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR _y3$21[ebp]
  0037e	e8 00 00 00 00	 call	 ?yuv422_to_420_i_interpolate@@YA?AT__m256i@@T1@0H@Z ; yuv422_to_420_i_interpolate
  00383	83 c4 04	 add	 esp, 4
  00386	c5 fe 7f 85 e0
	fc ff ff	 vmovdqu YMMWORD PTR $T2[ebp], ymm0
  0038e	c5 fe 6f 85 e0
	fc ff ff	 vmovdqu ymm0, YMMWORD PTR $T2[ebp]
  00396	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _y0$23[ebp], ymm0

; 245  : 
; 246  :                 _mm256_storeu_si256((__m256i *)(dstCLine + x), y0);

  0039b	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR _y0$23[ebp]
  003a0	8b 4d bc	 mov	 ecx, DWORD PTR _dstCLine$[ebp]
  003a3	03 8d f8 fe ff
	ff		 add	 ecx, DWORD PTR _x$19[ebp]
  003a9	c5 fe 7f 01	 vmovdqu YMMWORD PTR [ecx], ymm0

; 247  :             }

  003ad	e9 c9 fd ff ff	 jmp	 $LN8@convert_yu
$LN9@convert_yu:

; 248  :             srcLine  += src_y_pitch_byte;

  003b2	8b 55 c4	 mov	 edx, DWORD PTR _srcLine$[ebp]
  003b5	03 53 14	 add	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  003b8	89 55 c4	 mov	 DWORD PTR _srcLine$[ebp], edx

; 249  :             dstYLine += dst_y_pitch_byte;

  003bb	8b 45 c0	 mov	 eax, DWORD PTR _dstYLine$[ebp]
  003be	03 43 1c	 add	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  003c1	89 45 c0	 mov	 DWORD PTR _dstYLine$[ebp], eax

; 250  :             dstCLine += dst_y_pitch_byte;

  003c4	8b 4d bc	 mov	 ecx, DWORD PTR _dstCLine$[ebp]
  003c7	03 4b 1c	 add	 ecx, DWORD PTR _dst_y_pitch_byte$[ebx]
  003ca	89 4d bc	 mov	 DWORD PTR _dstCLine$[ebp], ecx

; 251  :         }

  003cd	e9 69 fd ff ff	 jmp	 $LN5@convert_yu
$LN6@convert_yu:

; 252  :         srcLine  += src_y_pitch_byte << 1;

  003d2	8b 53 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  003d5	8b 45 c4	 mov	 eax, DWORD PTR _srcLine$[ebp]
  003d8	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  003db	89 4d c4	 mov	 DWORD PTR _srcLine$[ebp], ecx

; 253  :         dstYLine += dst_y_pitch_byte << 1;

  003de	8b 53 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebx]
  003e1	8b 45 c0	 mov	 eax, DWORD PTR _dstYLine$[ebp]
  003e4	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  003e7	89 4d c0	 mov	 DWORD PTR _dstYLine$[ebp], ecx

; 254  :     }

  003ea	e9 2e fd ff ff	 jmp	 $LN2@convert_yu
$LN3@convert_yu:

; 255  :     _mm256_zeroupper();

  003ef	c5 f8 77	 vzeroupper

; 256  : }

  003f2	52		 push	 edx
  003f3	8b cd		 mov	 ecx, ebp
  003f5	50		 push	 eax
  003f6	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN16@convert_yu
  003fc	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00401	58		 pop	 eax
  00402	5a		 pop	 edx
  00403	5f		 pop	 edi
  00404	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00407	33 cd		 xor	 ecx, ebp
  00409	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0040e	8b e5		 mov	 esp, ebp
  00410	5d		 pop	 ebp
  00411	8b e3		 mov	 esp, ebx
  00413	5b		 pop	 ebx
  00414	c3		 ret	 0
  00415	0f 1f 00	 npad	 3
$LN16@convert_yu:
  00418	03 00 00 00	 DD	 3
  0041c	00 00 00 00	 DD	 $LN15@convert_yu
$LN15@convert_yu:
  00420	d8 ff ff ff	 DD	 -40			; ffffffd8H
  00424	0c 00 00 00	 DD	 12			; 0000000cH
  00428	00 00 00 00	 DD	 $LN12@convert_yu
  0042c	80 ff ff ff	 DD	 -128			; ffffff80H
  00430	20 00 00 00	 DD	 32			; 00000020H
  00434	00 00 00 00	 DD	 $LN13@convert_yu
  00438	40 ff ff ff	 DD	 -192			; ffffff40H
  0043c	20 00 00 00	 DD	 32			; 00000020H
  00440	00 00 00 00	 DD	 $LN14@convert_yu
$LN14@convert_yu:
  00444	79		 DB	 121			; 00000079H
  00445	31		 DB	 49			; 00000031H
  00446	00		 DB	 0
$LN13@convert_yu:
  00447	79		 DB	 121			; 00000079H
  00448	30		 DB	 48			; 00000030H
  00449	00		 DB	 0
$LN12@convert_yu:
  0044a	79		 DB	 121			; 00000079H
  0044b	5f		 DB	 95			; 0000005fH
  0044c	72		 DB	 114			; 00000072H
  0044d	61		 DB	 97			; 00000061H
  0044e	6e		 DB	 110			; 0000006eH
  0044f	67		 DB	 103			; 00000067H
  00450	65		 DB	 101			; 00000065H
  00451	00		 DB	 0
?convert_yuy2_to_nv12_i_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuy2_to_nv12_i_avx2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
$T1 = -544						; size = 32
$T2 = -512						; size = 32
$T3 = -480						; size = 32
$T4 = -448						; size = 32
$T5 = -416						; size = 32
$T6 = -384						; size = 32
$T7 = -352						; size = 32
$T8 = -320						; size = 32
$T9 = -288						; size = 32
$T10 = -256						; size = 32
$T11 = -224						; size = 32
$T12 = -192						; size = 32
$T13 = -160						; size = 32
_y1$ = -128						; size = 32
_y0$ = -96						; size = 32
_y_down$ = -64						; size = 32
_y_up$ = -32						; size = 32
_i$ = 8							; size = 4
?yuv422_to_420_i_interpolate@@YA?AT__m256i@@T1@0H@Z PROC ; yuv422_to_420_i_interpolate
; _y_up$ = ymm0
; _y_down$ = ymm1

; 192  : static __forceinline __m256i yuv422_to_420_i_interpolate(__m256i y_up, __m256i y_down, int i) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 20 02 00
	00		 sub	 esp, 544		; 00000220H
  0001c	57		 push	 edi
  0001d	8d bd e0 fd ff
	ff		 lea	 edi, DWORD PTR [ebp-544]
  00023	b9 88 00 00 00	 mov	 ecx, 136		; 00000088H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	c5 fc 11 4d c0	 vmovups YMMWORD PTR _y_down$[ebp], ymm1
  00034	c5 fc 11 45 e0	 vmovups YMMWORD PTR _y_up$[ebp], ymm0

; 193  :     __m256i y0, y1;
; 194  :     y0 = _mm256_unpacklo_epi8(y_down, y_up);

  00039	c5 fe 6f 45 c0	 vmovdqu ymm0, YMMWORD PTR _y_down$[ebp]
  0003e	c5 fd 60 45 e0	 vpunpcklbw ymm0, ymm0, YMMWORD PTR _y_up$[ebp]
  00043	c5 fe 7f 85 60
	ff ff ff	 vmovdqu YMMWORD PTR $T13[ebp], ymm0
  0004b	c5 fe 6f 85 60
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T13[ebp]
  00053	c5 fe 7f 45 a0	 vmovdqu YMMWORD PTR _y0$[ebp], ymm0

; 195  :     y1 = _mm256_unpackhi_epi8(y_down, y_up);

  00058	c5 fe 6f 45 c0	 vmovdqu ymm0, YMMWORD PTR _y_down$[ebp]
  0005d	c5 fd 68 45 e0	 vpunpckhbw ymm0, ymm0, YMMWORD PTR _y_up$[ebp]
  00062	c5 fe 7f 85 40
	ff ff ff	 vmovdqu YMMWORD PTR $T12[ebp], ymm0
  0006a	c5 fe 6f 85 40
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T12[ebp]
  00072	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _y1$[ebp], ymm0

; 196  :     y0 = _mm256_maddubs_epi16(y0, yC_INTERLACE_WEIGHT(i));

  00077	8b 43 08	 mov	 eax, DWORD PTR _i$[ebx]
  0007a	c1 e0 05	 shl	 eax, 5
  0007d	05 00 00 00 00	 add	 eax, OFFSET ?Array_INTERLACE_WEIGHT@@3QAY0CA@$$CBEA
  00082	c5 fe 6f 00	 vmovdqu ymm0, YMMWORD PTR [eax]
  00086	c5 fe 7f 85 20
	ff ff ff	 vmovdqu YMMWORD PTR $T11[ebp], ymm0
  0008e	c5 fe 6f 45 a0	 vmovdqu ymm0, YMMWORD PTR _y0$[ebp]
  00093	c4 e2 7d 04 85
	20 ff ff ff	 vpmaddubsw ymm0, ymm0, YMMWORD PTR $T11[ebp]
  0009c	c5 fe 7f 85 00
	ff ff ff	 vmovdqu YMMWORD PTR $T10[ebp], ymm0
  000a4	c5 fe 6f 85 00
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T10[ebp]
  000ac	c5 fe 7f 45 a0	 vmovdqu YMMWORD PTR _y0$[ebp], ymm0

; 197  :     y1 = _mm256_maddubs_epi16(y1, yC_INTERLACE_WEIGHT(i));

  000b1	8b 4b 08	 mov	 ecx, DWORD PTR _i$[ebx]
  000b4	c1 e1 05	 shl	 ecx, 5
  000b7	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?Array_INTERLACE_WEIGHT@@3QAY0CA@$$CBEA
  000bd	c5 fe 6f 01	 vmovdqu ymm0, YMMWORD PTR [ecx]
  000c1	c5 fe 7f 85 e0
	fe ff ff	 vmovdqu YMMWORD PTR $T9[ebp], ymm0
  000c9	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR _y1$[ebp]
  000ce	c4 e2 7d 04 85
	e0 fe ff ff	 vpmaddubsw ymm0, ymm0, YMMWORD PTR $T9[ebp]
  000d7	c5 fe 7f 85 c0
	fe ff ff	 vmovdqu YMMWORD PTR $T8[ebp], ymm0
  000df	c5 fe 6f 85 c0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T8[ebp]
  000e7	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _y1$[ebp], ymm0

; 198  :     y0 = _mm256_add_epi16(y0, _mm256_set1_epi16(2));

  000ec	c5 fe 6f 05 00
	00 00 00	 vmovdqu ymm0, YMMWORD PTR __ymm@0002000200020002000200020002000200020002000200020002000200020002
  000f4	c5 fe 7f 85 a0
	fe ff ff	 vmovdqu YMMWORD PTR $T7[ebp], ymm0
  000fc	c5 fe 6f 45 a0	 vmovdqu ymm0, YMMWORD PTR _y0$[ebp]
  00101	c5 fd fd 85 a0
	fe ff ff	 vpaddw	 ymm0, ymm0, YMMWORD PTR $T7[ebp]
  00109	c5 fe 7f 85 80
	fe ff ff	 vmovdqu YMMWORD PTR $T6[ebp], ymm0
  00111	c5 fe 6f 85 80
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T6[ebp]
  00119	c5 fe 7f 45 a0	 vmovdqu YMMWORD PTR _y0$[ebp], ymm0

; 199  :     y1 = _mm256_add_epi16(y1, _mm256_set1_epi16(2));

  0011e	c5 fe 6f 05 00
	00 00 00	 vmovdqu ymm0, YMMWORD PTR __ymm@0002000200020002000200020002000200020002000200020002000200020002
  00126	c5 fe 7f 85 60
	fe ff ff	 vmovdqu YMMWORD PTR $T5[ebp], ymm0
  0012e	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR _y1$[ebp]
  00133	c5 fd fd 85 60
	fe ff ff	 vpaddw	 ymm0, ymm0, YMMWORD PTR $T5[ebp]
  0013b	c5 fe 7f 85 40
	fe ff ff	 vmovdqu YMMWORD PTR $T4[ebp], ymm0
  00143	c5 fe 6f 85 40
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T4[ebp]
  0014b	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _y1$[ebp], ymm0

; 200  :     y0 = _mm256_srai_epi16(y0, 2);

  00150	c5 fe 6f 45 a0	 vmovdqu ymm0, YMMWORD PTR _y0$[ebp]
  00155	c5 fd 71 e0 02	 vpsraw	 ymm0, ymm0, 2
  0015a	c5 fe 7f 85 20
	fe ff ff	 vmovdqu YMMWORD PTR $T3[ebp], ymm0
  00162	c5 fe 6f 85 20
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T3[ebp]
  0016a	c5 fe 7f 45 a0	 vmovdqu YMMWORD PTR _y0$[ebp], ymm0

; 201  :     y1 = _mm256_srai_epi16(y1, 2);

  0016f	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR _y1$[ebp]
  00174	c5 fd 71 e0 02	 vpsraw	 ymm0, ymm0, 2
  00179	c5 fe 7f 85 00
	fe ff ff	 vmovdqu YMMWORD PTR $T2[ebp], ymm0
  00181	c5 fe 6f 85 00
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T2[ebp]
  00189	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _y1$[ebp], ymm0

; 202  :     y0 = _mm256_packus_epi16(y0, y1);

  0018e	c5 fe 6f 45 a0	 vmovdqu ymm0, YMMWORD PTR _y0$[ebp]
  00193	c5 fd 67 45 80	 vpackuswb ymm0, ymm0, YMMWORD PTR _y1$[ebp]
  00198	c5 fe 7f 85 e0
	fd ff ff	 vmovdqu YMMWORD PTR $T1[ebp], ymm0
  001a0	c5 fe 6f 85 e0
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T1[ebp]
  001a8	c5 fe 7f 45 a0	 vmovdqu YMMWORD PTR _y0$[ebp], ymm0

; 203  :     return y0;

  001ad	c5 fe 6f 45 a0	 vmovdqu ymm0, YMMWORD PTR _y0$[ebp]

; 204  : }

  001b2	5f		 pop	 edi
  001b3	8b e5		 mov	 esp, ebp
  001b5	5d		 pop	 ebp
  001b6	8b e3		 mov	 esp, ebx
  001b8	5b		 pop	 ebx
  001b9	c3		 ret	 0
?yuv422_to_420_i_interpolate@@YA?AT__m256i@@T1@0H@Z ENDP ; yuv422_to_420_i_interpolate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
$T1 = -816						; size = 12
$T2 = -800						; size = 32
$T3 = -768						; size = 32
$T4 = -720						; size = 16
$T5 = -704						; size = 32
$T6 = -656						; size = 16
$T7 = -640						; size = 32
$T8 = -592						; size = 16
$T9 = -576						; size = 32
$T10 = -528						; size = 16
$T11 = -512						; size = 32
$T12 = -464						; size = 16
$T13 = -448						; size = 32
$T14 = -400						; size = 16
$T15 = -384						; size = 32
$T16 = -336						; size = 16
$T17 = -320						; size = 32
$T18 = -288						; size = 16
_x$19 = -260						; size = 4
_y3$20 = -256						; size = 32
_y1$21 = -192						; size = 32
_y0$22 = -128						; size = 32
_x_fin$23 = -84						; size = 4
_pw$24 = -80						; size = 4
_p$25 = -76						; size = 4
_y$26 = -72						; size = 4
_dstCLine$ = -68					; size = 4
_dstYLine$ = -64					; size = 4
_srcLine$ = -60						; size = 4
$T27 = -56						; size = 12
_y_range$ = -40						; size = 12
_src$ = -24						; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst_array$ = 8						; size = 4
_src_array$ = 12					; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?convert_yuy2_to_nv12_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; convert_yuy2_to_nv12_avx2

; 146  : void convert_yuy2_to_nv12_avx2(void **dst_array, const void **src_array, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 40 03 00
	00		 sub	 esp, 832		; 00000340H
  0001c	57		 push	 edi
  0001d	8d bd c0 fc ff
	ff		 lea	 edi, DWORD PTR [ebp-832]
  00023	b9 d0 00 00 00	 mov	 ecx, 208		; 000000d0H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 147  :     const int crop_left   = crop[0];

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00044	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00047	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 148  :     const int crop_up     = crop[1];

  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	c1 e1 00	 shl	 ecx, 0
  00052	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00055	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00058	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 149  :     const int crop_right  = crop[2];

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	d1 e1		 shl	 ecx, 1
  00062	8b 53 30	 mov	 edx, DWORD PTR _crop$[ebx]
  00065	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00068	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 150  :     const int crop_bottom = crop[3];

  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	6b d1 03	 imul	 edx, ecx, 3
  00073	8b 43 30	 mov	 eax, DWORD PTR _crop$[ebx]
  00076	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00079	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 151  :     const void *src = src_array[0];

  0007c	ba 04 00 00 00	 mov	 edx, 4
  00081	6b c2 00	 imul	 eax, edx, 0
  00084	8b 4b 0c	 mov	 ecx, DWORD PTR _src_array$[ebx]
  00087	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  0008a	89 55 e8	 mov	 DWORD PTR _src$[ebp], edx

; 152  :     const auto y_range = thread_y_range(crop_up, height - crop_bottom, thread_id, thread_n);

  0008d	8b 43 2c	 mov	 eax, DWORD PTR _thread_n$[ebx]
  00090	50		 push	 eax
  00091	8b 4b 28	 mov	 ecx, DWORD PTR _thread_id$[ebx]
  00094	51		 push	 ecx
  00095	8b 53 20	 mov	 edx, DWORD PTR _height$[ebx]
  00098	2b 55 ec	 sub	 edx, DWORD PTR _crop_bottom$[ebp]
  0009b	52		 push	 edx
  0009c	8b 45 f4	 mov	 eax, DWORD PTR _crop_up$[ebp]
  0009f	50		 push	 eax
  000a0	8d 8d d0 fc ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  000a6	51		 push	 ecx
  000a7	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  000ac	83 c4 14	 add	 esp, 20			; 00000014H
  000af	8b 10		 mov	 edx, DWORD PTR [eax]
  000b1	89 55 c8	 mov	 DWORD PTR $T27[ebp], edx
  000b4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000b7	89 4d cc	 mov	 DWORD PTR $T27[ebp+4], ecx
  000ba	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000bd	89 55 d0	 mov	 DWORD PTR $T27[ebp+8], edx
  000c0	8b 45 c8	 mov	 eax, DWORD PTR $T27[ebp]
  000c3	89 45 d8	 mov	 DWORD PTR _y_range$[ebp], eax
  000c6	8b 4d cc	 mov	 ecx, DWORD PTR $T27[ebp+4]
  000c9	89 4d dc	 mov	 DWORD PTR _y_range$[ebp+4], ecx
  000cc	8b 55 d0	 mov	 edx, DWORD PTR $T27[ebp+8]
  000cf	89 55 e0	 mov	 DWORD PTR _y_range$[ebp+8], edx

; 153  :     uint8_t *srcLine = (uint8_t *)src + src_y_pitch_byte * y_range.start_src + crop_left;

  000d2	8b 43 14	 mov	 eax, DWORD PTR _src_y_pitch_byte$[ebx]
  000d5	0f af 45 d8	 imul	 eax, DWORD PTR _y_range$[ebp]
  000d9	03 45 e8	 add	 eax, DWORD PTR _src$[ebp]
  000dc	03 45 f8	 add	 eax, DWORD PTR _crop_left$[ebp]
  000df	89 45 c4	 mov	 DWORD PTR _srcLine$[ebp], eax

; 154  :     uint8_t *dstYLine = (uint8_t *)dst_array[0] + dst_y_pitch_byte * y_range.start_dst;

  000e2	b9 04 00 00 00	 mov	 ecx, 4
  000e7	6b d1 00	 imul	 edx, ecx, 0
  000ea	8b 43 1c	 mov	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  000ed	0f af 45 dc	 imul	 eax, DWORD PTR _y_range$[ebp+4]
  000f1	8b 4b 08	 mov	 ecx, DWORD PTR _dst_array$[ebx]
  000f4	03 04 11	 add	 eax, DWORD PTR [ecx+edx]
  000f7	89 45 c0	 mov	 DWORD PTR _dstYLine$[ebp], eax

; 155  :     uint8_t *dstCLine = (uint8_t *)dst_array[1] + dst_y_pitch_byte * (y_range.start_dst >> 1);

  000fa	ba 04 00 00 00	 mov	 edx, 4
  000ff	c1 e2 00	 shl	 edx, 0
  00102	8b 45 dc	 mov	 eax, DWORD PTR _y_range$[ebp+4]
  00105	d1 f8		 sar	 eax, 1
  00107	0f af 43 1c	 imul	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  0010b	8b 4b 08	 mov	 ecx, DWORD PTR _dst_array$[ebx]
  0010e	03 04 11	 add	 eax, DWORD PTR [ecx+edx]
  00111	89 45 bc	 mov	 DWORD PTR _dstCLine$[ebp], eax

; 156  :     for (int y = 0; y < y_range.len; y += 2) {

  00114	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _y$26[ebp], 0
  0011b	eb 09		 jmp	 SHORT $LN4@convert_yu
$LN2@convert_yu:
  0011d	8b 55 b8	 mov	 edx, DWORD PTR _y$26[ebp]
  00120	83 c2 02	 add	 edx, 2
  00123	89 55 b8	 mov	 DWORD PTR _y$26[ebp], edx
$LN4@convert_yu:
  00126	8b 45 b8	 mov	 eax, DWORD PTR _y$26[ebp]
  00129	3b 45 e0	 cmp	 eax, DWORD PTR _y_range$[ebp+8]
  0012c	0f 8d 78 02 00
	00		 jge	 $LN3@convert_yu

; 157  :         uint8_t *p = srcLine;

  00132	8b 4d c4	 mov	 ecx, DWORD PTR _srcLine$[ebp]
  00135	89 4d b4	 mov	 DWORD PTR _p$25[ebp], ecx

; 158  :         uint8_t *pw = p + src_y_pitch_byte;

  00138	8b 55 b4	 mov	 edx, DWORD PTR _p$25[ebp]
  0013b	03 53 14	 add	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  0013e	89 55 b0	 mov	 DWORD PTR _pw$24[ebp], edx

; 159  :         const int x_fin = width - crop_right - crop_left;

  00141	8b 43 10	 mov	 eax, DWORD PTR _width$[ebx]
  00144	2b 45 f0	 sub	 eax, DWORD PTR _crop_right$[ebp]
  00147	2b 45 f8	 sub	 eax, DWORD PTR _crop_left$[ebp]
  0014a	89 45 ac	 mov	 DWORD PTR _x_fin$23[ebp], eax

; 160  :         __m256i y0, y1, y3;
; 161  :         for (int x = 0; x < x_fin; x += 32, p += 64, pw += 64) {

  0014d	c7 85 fc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _x$19[ebp], 0
  00157	eb 21		 jmp	 SHORT $LN7@convert_yu
$LN5@convert_yu:
  00159	8b 8d fc fe ff
	ff		 mov	 ecx, DWORD PTR _x$19[ebp]
  0015f	83 c1 20	 add	 ecx, 32			; 00000020H
  00162	89 8d fc fe ff
	ff		 mov	 DWORD PTR _x$19[ebp], ecx
  00168	8b 55 b4	 mov	 edx, DWORD PTR _p$25[ebp]
  0016b	83 c2 40	 add	 edx, 64			; 00000040H
  0016e	89 55 b4	 mov	 DWORD PTR _p$25[ebp], edx
  00171	8b 45 b0	 mov	 eax, DWORD PTR _pw$24[ebp]
  00174	83 c0 40	 add	 eax, 64			; 00000040H
  00177	89 45 b0	 mov	 DWORD PTR _pw$24[ebp], eax
$LN7@convert_yu:
  0017a	8b 8d fc fe ff
	ff		 mov	 ecx, DWORD PTR _x$19[ebp]
  00180	3b 4d ac	 cmp	 ecx, DWORD PTR _x_fin$23[ebp]
  00183	0f 8d fb 01 00
	00		 jge	 $LN6@convert_yu

; 162  :             //-----------1---------------
; 163  :             y0 = _mm256_set_m128i(_mm_loadu_si128((__m128i*)(p+32)), _mm_loadu_si128((__m128i*)(p+ 0)));

  00189	8b 55 b4	 mov	 edx, DWORD PTR _p$25[ebp]
  0018c	83 c2 20	 add	 edx, 32			; 00000020H
  0018f	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  00192	0f 29 85 b0 fe
	ff ff		 movaps	 XMMWORD PTR $T16[ebp], xmm0
  00199	8b 45 b4	 mov	 eax, DWORD PTR _p$25[ebp]
  0019c	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  0019f	0f 29 85 e0 fe
	ff ff		 movaps	 XMMWORD PTR $T18[ebp], xmm0
  001a6	c5 fa 6f 85 e0
	fe ff ff	 vmovdqu xmm0, XMMWORD PTR $T18[ebp]
  001ae	c5 fe 7f 85 c0
	fe ff ff	 vmovdqu YMMWORD PTR $T17[ebp], ymm0
  001b6	c5 fe 6f 85 c0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T17[ebp]
  001be	c4 e3 7d 18 85
	b0 fe ff ff 01	 vinsertf128 ymm0, ymm0, XMMWORD PTR $T16[ebp], 1
  001c8	c5 fe 7f 85 80
	fe ff ff	 vmovdqu YMMWORD PTR $T15[ebp], ymm0
  001d0	c5 fe 6f 85 80
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T15[ebp]
  001d8	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _y0$22[ebp], ymm0

; 164  :             y1 = _mm256_set_m128i(_mm_loadu_si128((__m128i*)(p+48)), _mm_loadu_si128((__m128i*)(p+16)));

  001dd	8b 4d b4	 mov	 ecx, DWORD PTR _p$25[ebp]
  001e0	83 c1 30	 add	 ecx, 48			; 00000030H
  001e3	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  001e6	0f 29 85 30 fe
	ff ff		 movaps	 XMMWORD PTR $T12[ebp], xmm0
  001ed	8b 55 b4	 mov	 edx, DWORD PTR _p$25[ebp]
  001f0	83 c2 10	 add	 edx, 16			; 00000010H
  001f3	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  001f6	0f 29 85 70 fe
	ff ff		 movaps	 XMMWORD PTR $T14[ebp], xmm0
  001fd	c5 fa 6f 85 70
	fe ff ff	 vmovdqu xmm0, XMMWORD PTR $T14[ebp]
  00205	c5 fe 7f 85 40
	fe ff ff	 vmovdqu YMMWORD PTR $T13[ebp], ymm0
  0020d	c5 fe 6f 85 40
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T13[ebp]
  00215	c4 e3 7d 18 85
	30 fe ff ff 01	 vinsertf128 ymm0, ymm0, XMMWORD PTR $T12[ebp], 1
  0021f	c5 fe 7f 85 00
	fe ff ff	 vmovdqu YMMWORD PTR $T11[ebp], ymm0
  00227	c5 fe 6f 85 00
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T11[ebp]
  0022f	c5 fe 7f 85 40
	ff ff ff	 vmovdqu YMMWORD PTR _y1$21[ebp], ymm0

; 165  : 
; 166  :             separate_low_up(y0, y1);

  00237	8d 85 40 ff ff
	ff		 lea	 eax, DWORD PTR _y1$21[ebp]
  0023d	50		 push	 eax
  0023e	8d 4d 80	 lea	 ecx, DWORD PTR _y0$22[ebp]
  00241	51		 push	 ecx
  00242	e8 00 00 00 00	 call	 ?separate_low_up@@YAXAAT__m256i@@0@Z ; separate_low_up
  00247	83 c4 08	 add	 esp, 8

; 167  :             y3 = y1;

  0024a	c5 fe 6f 85 40
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR _y1$21[ebp]
  00252	c5 fe 7f 85 00
	ff ff ff	 vmovdqu YMMWORD PTR _y3$20[ebp], ymm0

; 168  : 
; 169  :             _mm256_storeu_si256((__m256i *)(dstYLine + x), y0);

  0025a	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR _y0$22[ebp]
  0025f	8b 55 c0	 mov	 edx, DWORD PTR _dstYLine$[ebp]
  00262	03 95 fc fe ff
	ff		 add	 edx, DWORD PTR _x$19[ebp]
  00268	c5 fe 7f 02	 vmovdqu YMMWORD PTR [edx], ymm0

; 170  :             //-----------1---------------
; 171  : 
; 172  :             //-----------2---------------
; 173  :             y0 = _mm256_set_m128i(_mm_loadu_si128((__m128i*)(pw+32)), _mm_loadu_si128((__m128i*)(pw+ 0)));

  0026c	8b 45 b0	 mov	 eax, DWORD PTR _pw$24[ebp]
  0026f	83 c0 20	 add	 eax, 32			; 00000020H
  00272	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00275	0f 29 85 b0 fd
	ff ff		 movaps	 XMMWORD PTR $T8[ebp], xmm0
  0027c	8b 4d b0	 mov	 ecx, DWORD PTR _pw$24[ebp]
  0027f	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00282	0f 29 85 f0 fd
	ff ff		 movaps	 XMMWORD PTR $T10[ebp], xmm0
  00289	c5 fa 6f 85 f0
	fd ff ff	 vmovdqu xmm0, XMMWORD PTR $T10[ebp]
  00291	c5 fe 7f 85 c0
	fd ff ff	 vmovdqu YMMWORD PTR $T9[ebp], ymm0
  00299	c5 fe 6f 85 c0
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T9[ebp]
  002a1	c4 e3 7d 18 85
	b0 fd ff ff 01	 vinsertf128 ymm0, ymm0, XMMWORD PTR $T8[ebp], 1
  002ab	c5 fe 7f 85 80
	fd ff ff	 vmovdqu YMMWORD PTR $T7[ebp], ymm0
  002b3	c5 fe 6f 85 80
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T7[ebp]
  002bb	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR _y0$22[ebp], ymm0

; 174  :             y1 = _mm256_set_m128i(_mm_loadu_si128((__m128i*)(pw+48)), _mm_loadu_si128((__m128i*)(pw+16)));

  002c0	8b 55 b0	 mov	 edx, DWORD PTR _pw$24[ebp]
  002c3	83 c2 30	 add	 edx, 48			; 00000030H
  002c6	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  002c9	0f 29 85 30 fd
	ff ff		 movaps	 XMMWORD PTR $T4[ebp], xmm0
  002d0	8b 45 b0	 mov	 eax, DWORD PTR _pw$24[ebp]
  002d3	83 c0 10	 add	 eax, 16			; 00000010H
  002d6	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  002d9	0f 29 85 70 fd
	ff ff		 movaps	 XMMWORD PTR $T6[ebp], xmm0
  002e0	c5 fa 6f 85 70
	fd ff ff	 vmovdqu xmm0, XMMWORD PTR $T6[ebp]
  002e8	c5 fe 7f 85 40
	fd ff ff	 vmovdqu YMMWORD PTR $T5[ebp], ymm0
  002f0	c5 fe 6f 85 40
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T5[ebp]
  002f8	c4 e3 7d 18 85
	30 fd ff ff 01	 vinsertf128 ymm0, ymm0, XMMWORD PTR $T4[ebp], 1
  00302	c5 fe 7f 85 00
	fd ff ff	 vmovdqu YMMWORD PTR $T3[ebp], ymm0
  0030a	c5 fe 6f 85 00
	fd ff ff	 vmovdqu ymm0, YMMWORD PTR $T3[ebp]
  00312	c5 fe 7f 85 40
	ff ff ff	 vmovdqu YMMWORD PTR _y1$21[ebp], ymm0

; 175  : 
; 176  :             separate_low_up(y0, y1);

  0031a	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR _y1$21[ebp]
  00320	51		 push	 ecx
  00321	8d 55 80	 lea	 edx, DWORD PTR _y0$22[ebp]
  00324	52		 push	 edx
  00325	e8 00 00 00 00	 call	 ?separate_low_up@@YAXAAT__m256i@@0@Z ; separate_low_up
  0032a	83 c4 08	 add	 esp, 8

; 177  : 
; 178  :             _mm256_storeu_si256((__m256i *)(dstYLine + dst_y_pitch_byte + x), y0);

  0032d	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR _y0$22[ebp]
  00332	8b 45 c0	 mov	 eax, DWORD PTR _dstYLine$[ebp]
  00335	03 43 1c	 add	 eax, DWORD PTR _dst_y_pitch_byte$[ebx]
  00338	03 85 fc fe ff
	ff		 add	 eax, DWORD PTR _x$19[ebp]
  0033e	c5 fe 7f 00	 vmovdqu YMMWORD PTR [eax], ymm0

; 179  :             //-----------2---------------
; 180  : 
; 181  :             y1 = _mm256_avg_epu8(y1, y3);  //VUVUVUVUVUVUVUVU

  00342	c5 fe 6f 85 40
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR _y1$21[ebp]
  0034a	c5 fd e0 85 00
	ff ff ff	 vpavgb	 ymm0, ymm0, YMMWORD PTR _y3$20[ebp]
  00352	c5 fe 7f 85 e0
	fc ff ff	 vmovdqu YMMWORD PTR $T2[ebp], ymm0
  0035a	c5 fe 6f 85 e0
	fc ff ff	 vmovdqu ymm0, YMMWORD PTR $T2[ebp]
  00362	c5 fe 7f 85 40
	ff ff ff	 vmovdqu YMMWORD PTR _y1$21[ebp], ymm0

; 182  :             _mm256_storeu_si256((__m256i *)(dstCLine + x), y1);

  0036a	c5 fe 6f 85 40
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR _y1$21[ebp]
  00372	8b 4d bc	 mov	 ecx, DWORD PTR _dstCLine$[ebp]
  00375	03 8d fc fe ff
	ff		 add	 ecx, DWORD PTR _x$19[ebp]
  0037b	c5 fe 7f 01	 vmovdqu YMMWORD PTR [ecx], ymm0

; 183  :         }

  0037f	e9 d5 fd ff ff	 jmp	 $LN5@convert_yu
$LN6@convert_yu:

; 184  :         srcLine  += src_y_pitch_byte << 1;

  00384	8b 53 14	 mov	 edx, DWORD PTR _src_y_pitch_byte$[ebx]
  00387	8b 45 c4	 mov	 eax, DWORD PTR _srcLine$[ebp]
  0038a	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  0038d	89 4d c4	 mov	 DWORD PTR _srcLine$[ebp], ecx

; 185  :         dstYLine += dst_y_pitch_byte << 1;

  00390	8b 53 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebx]
  00393	8b 45 c0	 mov	 eax, DWORD PTR _dstYLine$[ebp]
  00396	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00399	89 4d c0	 mov	 DWORD PTR _dstYLine$[ebp], ecx

; 186  :         dstCLine += dst_y_pitch_byte;

  0039c	8b 55 bc	 mov	 edx, DWORD PTR _dstCLine$[ebp]
  0039f	03 53 1c	 add	 edx, DWORD PTR _dst_y_pitch_byte$[ebx]
  003a2	89 55 bc	 mov	 DWORD PTR _dstCLine$[ebp], edx

; 187  :     }

  003a5	e9 73 fd ff ff	 jmp	 $LN2@convert_yu
$LN3@convert_yu:

; 188  :     _mm256_zeroupper();

  003aa	c5 f8 77	 vzeroupper

; 189  : }

  003ad	52		 push	 edx
  003ae	8b cd		 mov	 ecx, ebp
  003b0	50		 push	 eax
  003b1	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN13@convert_yu
  003b7	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  003bc	58		 pop	 eax
  003bd	5a		 pop	 edx
  003be	5f		 pop	 edi
  003bf	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003c2	33 cd		 xor	 ecx, ebp
  003c4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003c9	8b e5		 mov	 esp, ebp
  003cb	5d		 pop	 ebp
  003cc	8b e3		 mov	 esp, ebx
  003ce	5b		 pop	 ebx
  003cf	c3		 ret	 0
$LN13@convert_yu:
  003d0	03 00 00 00	 DD	 3
  003d4	00 00 00 00	 DD	 $LN12@convert_yu
$LN12@convert_yu:
  003d8	d8 ff ff ff	 DD	 -40			; ffffffd8H
  003dc	0c 00 00 00	 DD	 12			; 0000000cH
  003e0	00 00 00 00	 DD	 $LN9@convert_yu
  003e4	80 ff ff ff	 DD	 -128			; ffffff80H
  003e8	20 00 00 00	 DD	 32			; 00000020H
  003ec	00 00 00 00	 DD	 $LN10@convert_yu
  003f0	40 ff ff ff	 DD	 -192			; ffffff40H
  003f4	20 00 00 00	 DD	 32			; 00000020H
  003f8	00 00 00 00	 DD	 $LN11@convert_yu
$LN11@convert_yu:
  003fc	79		 DB	 121			; 00000079H
  003fd	31		 DB	 49			; 00000031H
  003fe	00		 DB	 0
$LN10@convert_yu:
  003ff	79		 DB	 121			; 00000079H
  00400	30		 DB	 48			; 00000030H
  00401	00		 DB	 0
$LN9@convert_yu:
  00402	79		 DB	 121			; 00000079H
  00403	5f		 DB	 95			; 0000005fH
  00404	72		 DB	 114			; 00000072H
  00405	61		 DB	 97			; 00000061H
  00406	6e		 DB	 110			; 0000006eH
  00407	67		 DB	 103			; 00000067H
  00408	65		 DB	 101			; 00000065H
  00409	00		 DB	 0
?convert_yuy2_to_nv12_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; convert_yuy2_to_nv12_avx2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
;	COMDAT ??$copy_nv12_to_nv12_avx2_internal@$00@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
_TEXT	SEGMENT
$T1 = -88						; size = 12
_y$2 = -76						; size = 4
_y_width$3 = -72					; size = 4
_dstLine$4 = -68					; size = 4
_srcYLine$5 = -64					; size = 4
$T6 = -60						; size = 12
_y_range$7 = -44					; size = 12
_i$8 = -28						; size = 4
_pixel_size$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$copy_nv12_to_nv12_avx2_internal@$00@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; copy_nv12_to_nv12_avx2_internal<1>, COMDAT

; 122  : void copy_nv12_to_nv12_avx2_internal(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	57		 push	 edi
  00007	8d 7d a8	 lea	 edi, DWORD PTR [ebp-88]
  0000a	b9 16 00 00 00	 mov	 ecx, 22			; 00000016H
  0000f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00014	f3 ab		 rep stosd
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 123  :     const int crop_left   = crop[0];

  00020	b8 04 00 00 00	 mov	 eax, 4
  00025	6b c8 00	 imul	 ecx, eax, 0
  00028	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  0002b	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0002e	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 124  :     const int crop_up     = crop[1];

  00031	b9 04 00 00 00	 mov	 ecx, 4
  00036	c1 e1 00	 shl	 ecx, 0
  00039	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  0003c	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0003f	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 125  :     const int crop_right  = crop[2];

  00042	b9 04 00 00 00	 mov	 ecx, 4
  00047	d1 e1		 shl	 ecx, 1
  00049	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  0004c	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0004f	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 126  :     const int crop_bottom = crop[3];

  00052	b9 04 00 00 00	 mov	 ecx, 4
  00057	6b d1 03	 imul	 edx, ecx, 3
  0005a	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  0005d	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00060	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 127  :     const int pixel_size = highbit_depth ? 2 : 1;

  00063	c7 45 e8 02 00
	00 00		 mov	 DWORD PTR _pixel_size$[ebp], 2

; 128  :     for (int i = 0; i < 2; i++) {

  0006a	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _i$8[ebp], 0
  00071	eb 09		 jmp	 SHORT $LN4@copy_nv12_
$LN2@copy_nv12_:
  00073	8b 55 e4	 mov	 edx, DWORD PTR _i$8[ebp]
  00076	83 c2 01	 add	 edx, 1
  00079	89 55 e4	 mov	 DWORD PTR _i$8[ebp], edx
$LN4@copy_nv12_:
  0007c	83 7d e4 02	 cmp	 DWORD PTR _i$8[ebp], 2
  00080	0f 8d cc 00 00
	00		 jge	 $LN1@copy_nv12_

; 129  :         const auto y_range = thread_y_range(crop_up >> i, (height - crop_bottom) >> i, thread_id, thread_n);

  00086	8b 45 2c	 mov	 eax, DWORD PTR _thread_n$[ebp]
  00089	50		 push	 eax
  0008a	8b 4d 28	 mov	 ecx, DWORD PTR _thread_id$[ebp]
  0008d	51		 push	 ecx
  0008e	8b 55 20	 mov	 edx, DWORD PTR _height$[ebp]
  00091	2b 55 ec	 sub	 edx, DWORD PTR _crop_bottom$[ebp]
  00094	8b 4d e4	 mov	 ecx, DWORD PTR _i$8[ebp]
  00097	d3 fa		 sar	 edx, cl
  00099	52		 push	 edx
  0009a	8b 45 f4	 mov	 eax, DWORD PTR _crop_up$[ebp]
  0009d	8b 4d e4	 mov	 ecx, DWORD PTR _i$8[ebp]
  000a0	d3 f8		 sar	 eax, cl
  000a2	50		 push	 eax
  000a3	8d 4d a8	 lea	 ecx, DWORD PTR $T1[ebp]
  000a6	51		 push	 ecx
  000a7	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  000ac	83 c4 14	 add	 esp, 20			; 00000014H
  000af	8b 10		 mov	 edx, DWORD PTR [eax]
  000b1	89 55 c4	 mov	 DWORD PTR $T6[ebp], edx
  000b4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000b7	89 4d c8	 mov	 DWORD PTR $T6[ebp+4], ecx
  000ba	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000bd	89 55 cc	 mov	 DWORD PTR $T6[ebp+8], edx
  000c0	8b 45 c4	 mov	 eax, DWORD PTR $T6[ebp]
  000c3	89 45 d4	 mov	 DWORD PTR _y_range$7[ebp], eax
  000c6	8b 4d c8	 mov	 ecx, DWORD PTR $T6[ebp+4]
  000c9	89 4d d8	 mov	 DWORD PTR _y_range$7[ebp+4], ecx
  000cc	8b 55 cc	 mov	 edx, DWORD PTR $T6[ebp+8]
  000cf	89 55 dc	 mov	 DWORD PTR _y_range$7[ebp+8], edx

; 130  :         const uint8_t *srcYLine = (const uint8_t *)src[i] + src_y_pitch_byte * y_range.start_src + crop_left;

  000d2	8b 45 14	 mov	 eax, DWORD PTR _src_y_pitch_byte$[ebp]
  000d5	0f af 45 d4	 imul	 eax, DWORD PTR _y_range$7[ebp]
  000d9	8b 4d e4	 mov	 ecx, DWORD PTR _i$8[ebp]
  000dc	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  000df	8b 0c 8a	 mov	 ecx, DWORD PTR [edx+ecx*4]
  000e2	03 c8		 add	 ecx, eax
  000e4	03 4d f8	 add	 ecx, DWORD PTR _crop_left$[ebp]
  000e7	89 4d c0	 mov	 DWORD PTR _srcYLine$5[ebp], ecx

; 131  :         uint8_t *dstLine = (uint8_t *)dst[i] + dst_y_pitch_byte * y_range.start_dst;

  000ea	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  000ed	0f af 55 d8	 imul	 edx, DWORD PTR _y_range$7[ebp+4]
  000f1	8b 45 e4	 mov	 eax, DWORD PTR _i$8[ebp]
  000f4	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  000f7	03 14 81	 add	 edx, DWORD PTR [ecx+eax*4]
  000fa	89 55 bc	 mov	 DWORD PTR _dstLine$4[ebp], edx

; 132  :         const int y_width = width - crop_right - crop_left;

  000fd	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00100	2b 55 f0	 sub	 edx, DWORD PTR _crop_right$[ebp]
  00103	2b 55 f8	 sub	 edx, DWORD PTR _crop_left$[ebp]
  00106	89 55 b8	 mov	 DWORD PTR _y_width$3[ebp], edx

; 133  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch_byte, dstLine += dst_y_pitch_byte) {

  00109	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _y$2[ebp], 0
  00110	eb 1b		 jmp	 SHORT $LN7@copy_nv12_
$LN5@copy_nv12_:
  00112	8b 45 b4	 mov	 eax, DWORD PTR _y$2[ebp]
  00115	83 c0 01	 add	 eax, 1
  00118	89 45 b4	 mov	 DWORD PTR _y$2[ebp], eax
  0011b	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$5[ebp]
  0011e	03 4d 14	 add	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00121	89 4d c0	 mov	 DWORD PTR _srcYLine$5[ebp], ecx
  00124	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$4[ebp]
  00127	03 55 1c	 add	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0012a	89 55 bc	 mov	 DWORD PTR _dstLine$4[ebp], edx
$LN7@copy_nv12_:
  0012d	8b 45 b4	 mov	 eax, DWORD PTR _y$2[ebp]
  00130	3b 45 dc	 cmp	 eax, DWORD PTR _y_range$7[ebp+8]
  00133	7d 18		 jge	 SHORT $LN6@copy_nv12_

; 134  :             avx2_memcpy<true>(dstLine, srcYLine, y_width * pixel_size);

  00135	8b 4d b8	 mov	 ecx, DWORD PTR _y_width$3[ebp]
  00138	d1 e1		 shl	 ecx, 1
  0013a	51		 push	 ecx
  0013b	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$5[ebp]
  0013e	52		 push	 edx
  0013f	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$4[ebp]
  00142	50		 push	 eax
  00143	e8 00 00 00 00	 call	 ??$avx2_memcpy@$00@@YAXPAEPBEH@Z ; avx2_memcpy<1>
  00148	83 c4 0c	 add	 esp, 12			; 0000000cH

; 135  :         }

  0014b	eb c5		 jmp	 SHORT $LN5@copy_nv12_
$LN6@copy_nv12_:

; 136  :     }

  0014d	e9 21 ff ff ff	 jmp	 $LN2@copy_nv12_
$LN1@copy_nv12_:

; 137  : }

  00152	52		 push	 edx
  00153	8b cd		 mov	 ecx, ebp
  00155	50		 push	 eax
  00156	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN11@copy_nv12_
  0015c	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00161	58		 pop	 eax
  00162	5a		 pop	 edx
  00163	5f		 pop	 edi
  00164	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00167	33 cd		 xor	 ecx, ebp
  00169	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0016e	83 c4 58	 add	 esp, 88			; 00000058H
  00171	3b ec		 cmp	 ebp, esp
  00173	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00178	8b e5		 mov	 esp, ebp
  0017a	5d		 pop	 ebp
  0017b	c3		 ret	 0
$LN11@copy_nv12_:
  0017c	01 00 00 00	 DD	 1
  00180	00 00 00 00	 DD	 $LN10@copy_nv12_
$LN10@copy_nv12_:
  00184	d4 ff ff ff	 DD	 -44			; ffffffd4H
  00188	0c 00 00 00	 DD	 12			; 0000000cH
  0018c	00 00 00 00	 DD	 $LN9@copy_nv12_
$LN9@copy_nv12_:
  00190	79		 DB	 121			; 00000079H
  00191	5f		 DB	 95			; 0000005fH
  00192	72		 DB	 114			; 00000072H
  00193	61		 DB	 97			; 00000061H
  00194	6e		 DB	 110			; 0000006eH
  00195	67		 DB	 103			; 00000067H
  00196	65		 DB	 101			; 00000065H
  00197	00		 DB	 0
??$copy_nv12_to_nv12_avx2_internal@$00@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; copy_nv12_to_nv12_avx2_internal<1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?copy_p010_to_p010_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; copy_p010_to_p010_avx2

; 142  : void copy_p010_to_p010_avx2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 143  :     return copy_nv12_to_nv12_avx2_internal<true>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$copy_nv12_to_nv12_avx2_internal@$00@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; copy_nv12_to_nv12_avx2_internal<1>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 144  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?copy_p010_to_p010_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; copy_p010_to_p010_avx2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
;	COMDAT ??$copy_nv12_to_nv12_avx2_internal@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z
_TEXT	SEGMENT
$T1 = -88						; size = 12
_y$2 = -76						; size = 4
_y_width$3 = -72					; size = 4
_dstLine$4 = -68					; size = 4
_srcYLine$5 = -64					; size = 4
$T6 = -60						; size = 12
_y_range$7 = -44					; size = 12
_i$8 = -28						; size = 4
_pixel_size$ = -24					; size = 4
_crop_bottom$ = -20					; size = 4
_crop_right$ = -16					; size = 4
_crop_up$ = -12						; size = 4
_crop_left$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
??$copy_nv12_to_nv12_avx2_internal@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; copy_nv12_to_nv12_avx2_internal<0>, COMDAT

; 122  : void copy_nv12_to_nv12_avx2_internal(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	57		 push	 edi
  00007	8d 7d a8	 lea	 edi, DWORD PTR [ebp-88]
  0000a	b9 16 00 00 00	 mov	 ecx, 22			; 00000016H
  0000f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00014	f3 ab		 rep stosd
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 123  :     const int crop_left   = crop[0];

  00020	b8 04 00 00 00	 mov	 eax, 4
  00025	6b c8 00	 imul	 ecx, eax, 0
  00028	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  0002b	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0002e	89 45 f8	 mov	 DWORD PTR _crop_left$[ebp], eax

; 124  :     const int crop_up     = crop[1];

  00031	b9 04 00 00 00	 mov	 ecx, 4
  00036	c1 e1 00	 shl	 ecx, 0
  00039	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  0003c	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0003f	89 45 f4	 mov	 DWORD PTR _crop_up$[ebp], eax

; 125  :     const int crop_right  = crop[2];

  00042	b9 04 00 00 00	 mov	 ecx, 4
  00047	d1 e1		 shl	 ecx, 1
  00049	8b 55 30	 mov	 edx, DWORD PTR _crop$[ebp]
  0004c	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0004f	89 45 f0	 mov	 DWORD PTR _crop_right$[ebp], eax

; 126  :     const int crop_bottom = crop[3];

  00052	b9 04 00 00 00	 mov	 ecx, 4
  00057	6b d1 03	 imul	 edx, ecx, 3
  0005a	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  0005d	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00060	89 4d ec	 mov	 DWORD PTR _crop_bottom$[ebp], ecx

; 127  :     const int pixel_size = highbit_depth ? 2 : 1;

  00063	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _pixel_size$[ebp], 1

; 128  :     for (int i = 0; i < 2; i++) {

  0006a	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _i$8[ebp], 0
  00071	eb 09		 jmp	 SHORT $LN4@copy_nv12_
$LN2@copy_nv12_:
  00073	8b 55 e4	 mov	 edx, DWORD PTR _i$8[ebp]
  00076	83 c2 01	 add	 edx, 1
  00079	89 55 e4	 mov	 DWORD PTR _i$8[ebp], edx
$LN4@copy_nv12_:
  0007c	83 7d e4 02	 cmp	 DWORD PTR _i$8[ebp], 2
  00080	0f 8d ca 00 00
	00		 jge	 $LN1@copy_nv12_

; 129  :         const auto y_range = thread_y_range(crop_up >> i, (height - crop_bottom) >> i, thread_id, thread_n);

  00086	8b 45 2c	 mov	 eax, DWORD PTR _thread_n$[ebp]
  00089	50		 push	 eax
  0008a	8b 4d 28	 mov	 ecx, DWORD PTR _thread_id$[ebp]
  0008d	51		 push	 ecx
  0008e	8b 55 20	 mov	 edx, DWORD PTR _height$[ebp]
  00091	2b 55 ec	 sub	 edx, DWORD PTR _crop_bottom$[ebp]
  00094	8b 4d e4	 mov	 ecx, DWORD PTR _i$8[ebp]
  00097	d3 fa		 sar	 edx, cl
  00099	52		 push	 edx
  0009a	8b 45 f4	 mov	 eax, DWORD PTR _crop_up$[ebp]
  0009d	8b 4d e4	 mov	 ecx, DWORD PTR _i$8[ebp]
  000a0	d3 f8		 sar	 eax, cl
  000a2	50		 push	 eax
  000a3	8d 4d a8	 lea	 ecx, DWORD PTR $T1[ebp]
  000a6	51		 push	 ecx
  000a7	e8 00 00 00 00	 call	 ?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ; thread_y_range
  000ac	83 c4 14	 add	 esp, 20			; 00000014H
  000af	8b 10		 mov	 edx, DWORD PTR [eax]
  000b1	89 55 c4	 mov	 DWORD PTR $T6[ebp], edx
  000b4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000b7	89 4d c8	 mov	 DWORD PTR $T6[ebp+4], ecx
  000ba	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000bd	89 55 cc	 mov	 DWORD PTR $T6[ebp+8], edx
  000c0	8b 45 c4	 mov	 eax, DWORD PTR $T6[ebp]
  000c3	89 45 d4	 mov	 DWORD PTR _y_range$7[ebp], eax
  000c6	8b 4d c8	 mov	 ecx, DWORD PTR $T6[ebp+4]
  000c9	89 4d d8	 mov	 DWORD PTR _y_range$7[ebp+4], ecx
  000cc	8b 55 cc	 mov	 edx, DWORD PTR $T6[ebp+8]
  000cf	89 55 dc	 mov	 DWORD PTR _y_range$7[ebp+8], edx

; 130  :         const uint8_t *srcYLine = (const uint8_t *)src[i] + src_y_pitch_byte * y_range.start_src + crop_left;

  000d2	8b 45 14	 mov	 eax, DWORD PTR _src_y_pitch_byte$[ebp]
  000d5	0f af 45 d4	 imul	 eax, DWORD PTR _y_range$7[ebp]
  000d9	8b 4d e4	 mov	 ecx, DWORD PTR _i$8[ebp]
  000dc	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  000df	8b 0c 8a	 mov	 ecx, DWORD PTR [edx+ecx*4]
  000e2	03 c8		 add	 ecx, eax
  000e4	03 4d f8	 add	 ecx, DWORD PTR _crop_left$[ebp]
  000e7	89 4d c0	 mov	 DWORD PTR _srcYLine$5[ebp], ecx

; 131  :         uint8_t *dstLine = (uint8_t *)dst[i] + dst_y_pitch_byte * y_range.start_dst;

  000ea	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  000ed	0f af 55 d8	 imul	 edx, DWORD PTR _y_range$7[ebp+4]
  000f1	8b 45 e4	 mov	 eax, DWORD PTR _i$8[ebp]
  000f4	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  000f7	03 14 81	 add	 edx, DWORD PTR [ecx+eax*4]
  000fa	89 55 bc	 mov	 DWORD PTR _dstLine$4[ebp], edx

; 132  :         const int y_width = width - crop_right - crop_left;

  000fd	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00100	2b 55 f0	 sub	 edx, DWORD PTR _crop_right$[ebp]
  00103	2b 55 f8	 sub	 edx, DWORD PTR _crop_left$[ebp]
  00106	89 55 b8	 mov	 DWORD PTR _y_width$3[ebp], edx

; 133  :         for (int y = 0; y < y_range.len; y++, srcYLine += src_y_pitch_byte, dstLine += dst_y_pitch_byte) {

  00109	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _y$2[ebp], 0
  00110	eb 1b		 jmp	 SHORT $LN7@copy_nv12_
$LN5@copy_nv12_:
  00112	8b 45 b4	 mov	 eax, DWORD PTR _y$2[ebp]
  00115	83 c0 01	 add	 eax, 1
  00118	89 45 b4	 mov	 DWORD PTR _y$2[ebp], eax
  0011b	8b 4d c0	 mov	 ecx, DWORD PTR _srcYLine$5[ebp]
  0011e	03 4d 14	 add	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00121	89 4d c0	 mov	 DWORD PTR _srcYLine$5[ebp], ecx
  00124	8b 55 bc	 mov	 edx, DWORD PTR _dstLine$4[ebp]
  00127	03 55 1c	 add	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0012a	89 55 bc	 mov	 DWORD PTR _dstLine$4[ebp], edx
$LN7@copy_nv12_:
  0012d	8b 45 b4	 mov	 eax, DWORD PTR _y$2[ebp]
  00130	3b 45 dc	 cmp	 eax, DWORD PTR _y_range$7[ebp+8]
  00133	7d 16		 jge	 SHORT $LN6@copy_nv12_

; 134  :             avx2_memcpy<true>(dstLine, srcYLine, y_width * pixel_size);

  00135	8b 4d b8	 mov	 ecx, DWORD PTR _y_width$3[ebp]
  00138	51		 push	 ecx
  00139	8b 55 c0	 mov	 edx, DWORD PTR _srcYLine$5[ebp]
  0013c	52		 push	 edx
  0013d	8b 45 bc	 mov	 eax, DWORD PTR _dstLine$4[ebp]
  00140	50		 push	 eax
  00141	e8 00 00 00 00	 call	 ??$avx2_memcpy@$00@@YAXPAEPBEH@Z ; avx2_memcpy<1>
  00146	83 c4 0c	 add	 esp, 12			; 0000000cH

; 135  :         }

  00149	eb c7		 jmp	 SHORT $LN5@copy_nv12_
$LN6@copy_nv12_:

; 136  :     }

  0014b	e9 23 ff ff ff	 jmp	 $LN2@copy_nv12_
$LN1@copy_nv12_:

; 137  : }

  00150	52		 push	 edx
  00151	8b cd		 mov	 ecx, ebp
  00153	50		 push	 eax
  00154	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN11@copy_nv12_
  0015a	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0015f	58		 pop	 eax
  00160	5a		 pop	 edx
  00161	5f		 pop	 edi
  00162	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00165	33 cd		 xor	 ecx, ebp
  00167	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0016c	83 c4 58	 add	 esp, 88			; 00000058H
  0016f	3b ec		 cmp	 ebp, esp
  00171	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00176	8b e5		 mov	 esp, ebp
  00178	5d		 pop	 ebp
  00179	c3		 ret	 0
  0017a	66 90		 npad	 2
$LN11@copy_nv12_:
  0017c	01 00 00 00	 DD	 1
  00180	00 00 00 00	 DD	 $LN10@copy_nv12_
$LN10@copy_nv12_:
  00184	d4 ff ff ff	 DD	 -44			; ffffffd4H
  00188	0c 00 00 00	 DD	 12			; 0000000cH
  0018c	00 00 00 00	 DD	 $LN9@copy_nv12_
$LN9@copy_nv12_:
  00190	79		 DB	 121			; 00000079H
  00191	5f		 DB	 95			; 0000005fH
  00192	72		 DB	 114			; 00000072H
  00193	61		 DB	 97			; 00000061H
  00194	6e		 DB	 110			; 0000006eH
  00195	67		 DB	 103			; 00000067H
  00196	65		 DB	 101			; 00000065H
  00197	00		 DB	 0
??$copy_nv12_to_nv12_avx2_internal@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; copy_nv12_to_nv12_avx2_internal<0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_width$ = 16						; size = 4
_src_y_pitch_byte$ = 20					; size = 4
_src_uv_pitch_byte$ = 24				; size = 4
_dst_y_pitch_byte$ = 28					; size = 4
_height$ = 32						; size = 4
_dst_height$ = 36					; size = 4
_thread_id$ = 40					; size = 4
_thread_n$ = 44						; size = 4
_crop$ = 48						; size = 4
?copy_nv12_to_nv12_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z PROC ; copy_nv12_to_nv12_avx2

; 138  : void copy_nv12_to_nv12_avx2(void **dst, const void **src, int width, int src_y_pitch_byte, int src_uv_pitch_byte, int dst_y_pitch_byte, int height, int dst_height, int thread_id, int thread_n, int *crop) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 139  :     return copy_nv12_to_nv12_avx2_internal<false>(dst, src, width, src_y_pitch_byte, src_uv_pitch_byte, dst_y_pitch_byte, height, dst_height, thread_id, thread_n, crop);

  00003	8b 45 30	 mov	 eax, DWORD PTR _crop$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _thread_n$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 28	 mov	 edx, DWORD PTR _thread_id$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 24	 mov	 eax, DWORD PTR _dst_height$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 20	 mov	 ecx, DWORD PTR _height$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 1c	 mov	 edx, DWORD PTR _dst_y_pitch_byte$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 18	 mov	 eax, DWORD PTR _src_uv_pitch_byte$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _src_y_pitch_byte$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$copy_nv12_to_nv12_avx2_internal@$0A@@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ; copy_nv12_to_nv12_avx2_internal<0>
  00034	83 c4 2c	 add	 esp, 44			; 0000002cH

; 140  : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?copy_nv12_to_nv12_avx2@@YAXPAPAXPAPBXHHHHHHHHPAH@Z ENDP ; copy_nv12_to_nv12_avx2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp_avx2.cpp
_TEXT	SEGMENT
$T1 = -416						; size = 32
$T2 = -384						; size = 32
$T3 = -352						; size = 32
$T4 = -320						; size = 32
$T5 = -288						; size = 32
$T6 = -256						; size = 32
$T7 = -224						; size = 32
$T8 = -192						; size = 32
$T9 = -160						; size = 32
$T10 = -128						; size = 32
_xMaskLowByte$ = -96					; size = 32
_x5$ = -64						; size = 32
_x4$ = -32						; size = 32
_x0_return_lower$ = 8					; size = 4
_x1_return_upper$ = 12					; size = 4
?separate_low_up@@YAXAAT__m256i@@0@Z PROC		; separate_low_up

; 106  : static __forceinline void separate_low_up(__m256i& x0_return_lower, __m256i& x1_return_upper) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec a0 01 00
	00		 sub	 esp, 416		; 000001a0H
  0001c	57		 push	 edi
  0001d	8d bd 60 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-416]
  00023	b9 68 00 00 00	 mov	 ecx, 104		; 00000068H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd

; 107  :     __m256i x4, x5;
; 108  :     const __m256i xMaskLowByte = _mm256_srli_epi16(_mm256_cmpeq_epi8(_mm256_setzero_si256(), _mm256_setzero_si256()), 8);

  0002f	c5 f9 ef c0	 vpxor	 xmm0, xmm0, xmm0
  00033	c5 fe 7f 85 60
	ff ff ff	 vmovdqu YMMWORD PTR $T9[ebp], ymm0
  0003b	c5 f9 ef c0	 vpxor	 xmm0, xmm0, xmm0
  0003f	c5 fe 7f 45 80	 vmovdqu YMMWORD PTR $T10[ebp], ymm0
  00044	c5 fe 6f 45 80	 vmovdqu ymm0, YMMWORD PTR $T10[ebp]
  00049	c5 fd 74 85 60
	ff ff ff	 vpcmpeqb ymm0, ymm0, YMMWORD PTR $T9[ebp]
  00051	c5 fe 7f 85 40
	ff ff ff	 vmovdqu YMMWORD PTR $T8[ebp], ymm0
  00059	c5 fe 6f 85 40
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T8[ebp]
  00061	c5 fd 71 d0 08	 vpsrlw	 ymm0, ymm0, 8
  00066	c5 fe 7f 85 20
	ff ff ff	 vmovdqu YMMWORD PTR $T7[ebp], ymm0
  0006e	c5 fe 6f 85 20
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T7[ebp]
  00076	c5 fe 7f 45 a0	 vmovdqu YMMWORD PTR _xMaskLowByte$[ebp], ymm0

; 109  :     x4 = _mm256_srli_epi16(x0_return_lower, 8);

  0007b	8b 43 08	 mov	 eax, DWORD PTR _x0_return_lower$[ebx]
  0007e	c5 fe 6f 00	 vmovdqu ymm0, YMMWORD PTR [eax]
  00082	c5 fd 71 d0 08	 vpsrlw	 ymm0, ymm0, 8
  00087	c5 fe 7f 85 00
	ff ff ff	 vmovdqu YMMWORD PTR $T6[ebp], ymm0
  0008f	c5 fe 6f 85 00
	ff ff ff	 vmovdqu ymm0, YMMWORD PTR $T6[ebp]
  00097	c5 fe 7f 45 e0	 vmovdqu YMMWORD PTR _x4$[ebp], ymm0

; 110  :     x5 = _mm256_srli_epi16(x1_return_upper, 8);

  0009c	8b 4b 0c	 mov	 ecx, DWORD PTR _x1_return_upper$[ebx]
  0009f	c5 fe 6f 01	 vmovdqu ymm0, YMMWORD PTR [ecx]
  000a3	c5 fd 71 d0 08	 vpsrlw	 ymm0, ymm0, 8
  000a8	c5 fe 7f 85 e0
	fe ff ff	 vmovdqu YMMWORD PTR $T5[ebp], ymm0
  000b0	c5 fe 6f 85 e0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T5[ebp]
  000b8	c5 fe 7f 45 c0	 vmovdqu YMMWORD PTR _x5$[ebp], ymm0

; 111  : 
; 112  :     x0_return_lower = _mm256_and_si256(x0_return_lower, xMaskLowByte);

  000bd	8b 53 08	 mov	 edx, DWORD PTR _x0_return_lower$[ebx]
  000c0	c5 fe 6f 02	 vmovdqu ymm0, YMMWORD PTR [edx]
  000c4	c5 fd db 45 a0	 vpand	 ymm0, ymm0, YMMWORD PTR _xMaskLowByte$[ebp]
  000c9	c5 fe 7f 85 c0
	fe ff ff	 vmovdqu YMMWORD PTR $T4[ebp], ymm0
  000d1	8b 43 08	 mov	 eax, DWORD PTR _x0_return_lower$[ebx]
  000d4	c5 fe 6f 85 c0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T4[ebp]
  000dc	c5 fe 7f 00	 vmovdqu YMMWORD PTR [eax], ymm0

; 113  :     x1_return_upper = _mm256_and_si256(x1_return_upper, xMaskLowByte);

  000e0	8b 4b 0c	 mov	 ecx, DWORD PTR _x1_return_upper$[ebx]
  000e3	c5 fe 6f 01	 vmovdqu ymm0, YMMWORD PTR [ecx]
  000e7	c5 fd db 45 a0	 vpand	 ymm0, ymm0, YMMWORD PTR _xMaskLowByte$[ebp]
  000ec	c5 fe 7f 85 a0
	fe ff ff	 vmovdqu YMMWORD PTR $T3[ebp], ymm0
  000f4	8b 53 0c	 mov	 edx, DWORD PTR _x1_return_upper$[ebx]
  000f7	c5 fe 6f 85 a0
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T3[ebp]
  000ff	c5 fe 7f 02	 vmovdqu YMMWORD PTR [edx], ymm0

; 114  : 
; 115  :     x0_return_lower = _mm256_packus_epi16(x0_return_lower, x1_return_upper);

  00103	8b 43 0c	 mov	 eax, DWORD PTR _x1_return_upper$[ebx]
  00106	8b 4b 08	 mov	 ecx, DWORD PTR _x0_return_lower$[ebx]
  00109	c5 fe 6f 01	 vmovdqu ymm0, YMMWORD PTR [ecx]
  0010d	c5 fd 67 00	 vpackuswb ymm0, ymm0, YMMWORD PTR [eax]
  00111	c5 fe 7f 85 80
	fe ff ff	 vmovdqu YMMWORD PTR $T2[ebp], ymm0
  00119	8b 53 08	 mov	 edx, DWORD PTR _x0_return_lower$[ebx]
  0011c	c5 fe 6f 85 80
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T2[ebp]
  00124	c5 fe 7f 02	 vmovdqu YMMWORD PTR [edx], ymm0

; 116  :     x1_return_upper = _mm256_packus_epi16(x4, x5);

  00128	c5 fe 6f 45 e0	 vmovdqu ymm0, YMMWORD PTR _x4$[ebp]
  0012d	c5 fd 67 45 c0	 vpackuswb ymm0, ymm0, YMMWORD PTR _x5$[ebp]
  00132	c5 fe 7f 85 60
	fe ff ff	 vmovdqu YMMWORD PTR $T1[ebp], ymm0
  0013a	8b 43 0c	 mov	 eax, DWORD PTR _x1_return_upper$[ebx]
  0013d	c5 fe 6f 85 60
	fe ff ff	 vmovdqu ymm0, YMMWORD PTR $T1[ebp]
  00145	c5 fe 7f 00	 vmovdqu YMMWORD PTR [eax], ymm0

; 117  : }

  00149	5f		 pop	 edi
  0014a	8b e5		 mov	 esp, ebp
  0014c	5d		 pop	 ebp
  0014d	8b e3		 mov	 esp, ebx
  0014f	5b		 pop	 ebx
  00150	c3		 ret	 0
?separate_low_up@@YAXAAT__m256i@@0@Z ENDP		; separate_low_up
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\work\intel\intel_codec\QSVPipeline\convert_csp.h
_TEXT	SEGMENT
_y1$ = -36						; size = 4
_y0$ = -32						; size = 4
_y_range$ = -24						; size = 12
_h$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
$T1 = 8							; size = 4
_y_start$ = 12						; size = 4
_y_end$ = 16						; size = 4
_thread_id$ = 20					; size = 4
_thread_n$ = 24						; size = 4
?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z PROC	; thread_y_range

; 375  : static inline THREAD_Y_RANGE thread_y_range(int y_start, int y_end, int thread_id, int thread_n) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 dc	 mov	 DWORD PTR [ebp-36], eax
  0000e	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  00011	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  00014	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00017	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0001a	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0001d	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00020	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00023	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002b	33 c5		 xor	 eax, ebp
  0002d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 376  :     const int h = y_end - y_start;

  00030	8b 45 10	 mov	 eax, DWORD PTR _y_end$[ebp]
  00033	2b 45 0c	 sub	 eax, DWORD PTR _y_start$[ebp]
  00036	89 45 f8	 mov	 DWORD PTR _h$[ebp], eax

; 377  :     THREAD_Y_RANGE y_range;
; 378  :     int y0 = ((((h *  thread_id)    / thread_n) + 3) & ~3);

  00039	8b 45 f8	 mov	 eax, DWORD PTR _h$[ebp]
  0003c	0f af 45 14	 imul	 eax, DWORD PTR _thread_id$[ebp]
  00040	99		 cdq
  00041	f7 7d 18	 idiv	 DWORD PTR _thread_n$[ebp]
  00044	83 c0 03	 add	 eax, 3
  00047	83 e0 fc	 and	 eax, -4			; fffffffcH
  0004a	89 45 e0	 mov	 DWORD PTR _y0$[ebp], eax

; 379  :     int y1 = ((((h * (thread_id+1)) / thread_n) + 3) & ~3);

  0004d	8b 4d 14	 mov	 ecx, DWORD PTR _thread_id$[ebp]
  00050	83 c1 01	 add	 ecx, 1
  00053	8b c1		 mov	 eax, ecx
  00055	0f af 45 f8	 imul	 eax, DWORD PTR _h$[ebp]
  00059	99		 cdq
  0005a	f7 7d 18	 idiv	 DWORD PTR _thread_n$[ebp]
  0005d	83 c0 03	 add	 eax, 3
  00060	83 e0 fc	 and	 eax, -4			; fffffffcH
  00063	89 45 dc	 mov	 DWORD PTR _y1$[ebp], eax

; 380  :     if (y1 > h) {

  00066	8b 55 dc	 mov	 edx, DWORD PTR _y1$[ebp]
  00069	3b 55 f8	 cmp	 edx, DWORD PTR _h$[ebp]
  0006c	7e 06		 jle	 SHORT $LN2@thread_y_r

; 381  :         y1 = h;

  0006e	8b 45 f8	 mov	 eax, DWORD PTR _h$[ebp]
  00071	89 45 dc	 mov	 DWORD PTR _y1$[ebp], eax
$LN2@thread_y_r:

; 382  :     }
; 383  :     y_range.start_src = y_start + y0;

  00074	8b 4d 0c	 mov	 ecx, DWORD PTR _y_start$[ebp]
  00077	03 4d e0	 add	 ecx, DWORD PTR _y0$[ebp]
  0007a	89 4d e8	 mov	 DWORD PTR _y_range$[ebp], ecx

; 384  :     y_range.start_dst = y0;

  0007d	8b 55 e0	 mov	 edx, DWORD PTR _y0$[ebp]
  00080	89 55 ec	 mov	 DWORD PTR _y_range$[ebp+4], edx

; 385  :     y_range.len = y1 - y0;

  00083	8b 45 dc	 mov	 eax, DWORD PTR _y1$[ebp]
  00086	2b 45 e0	 sub	 eax, DWORD PTR _y0$[ebp]
  00089	89 45 f0	 mov	 DWORD PTR _y_range$[ebp+8], eax

; 386  :     return y_range;

  0008c	8b 4d 08	 mov	 ecx, DWORD PTR $T1[ebp]
  0008f	8b 55 e8	 mov	 edx, DWORD PTR _y_range$[ebp]
  00092	89 11		 mov	 DWORD PTR [ecx], edx
  00094	8b 45 ec	 mov	 eax, DWORD PTR _y_range$[ebp+4]
  00097	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0009a	8b 55 f0	 mov	 edx, DWORD PTR _y_range$[ebp+8]
  0009d	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  000a0	8b 45 08	 mov	 eax, DWORD PTR $T1[ebp]

; 387  : }

  000a3	52		 push	 edx
  000a4	8b cd		 mov	 ecx, ebp
  000a6	50		 push	 eax
  000a7	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN6@thread_y_r
  000ad	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000b2	58		 pop	 eax
  000b3	5a		 pop	 edx
  000b4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b7	33 cd		 xor	 ecx, ebp
  000b9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000be	8b e5		 mov	 esp, ebp
  000c0	5d		 pop	 ebp
  000c1	c3		 ret	 0
  000c2	66 90		 npad	 2
$LN6@thread_y_r:
  000c4	01 00 00 00	 DD	 1
  000c8	00 00 00 00	 DD	 $LN5@thread_y_r
$LN5@thread_y_r:
  000cc	e8 ff ff ff	 DD	 -24			; ffffffe8H
  000d0	0c 00 00 00	 DD	 12			; 0000000cH
  000d4	00 00 00 00	 DD	 $LN4@thread_y_r
$LN4@thread_y_r:
  000d8	79		 DB	 121			; 00000079H
  000d9	5f		 DB	 95			; 0000005fH
  000da	72		 DB	 114			; 00000072H
  000db	61		 DB	 97			; 00000061H
  000dc	6e		 DB	 110			; 0000006eH
  000dd	67		 DB	 103			; 00000067H
  000de	65		 DB	 101			; 00000065H
  000df	00		 DB	 0
?thread_y_range@@YA?AUTHREAD_Y_RANGE@@HHHH@Z ENDP	; thread_y_range
_TEXT	ENDS
END
